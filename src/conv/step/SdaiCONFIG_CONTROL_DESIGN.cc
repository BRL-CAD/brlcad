#ifndef  SDAICONFIG_CONTROL_DESIGN_CC
#define  SDAICONFIG_CONTROL_DESIGN_CC
// This file was generated by fedex_plus.  You probably don't want to edit
// it since your modifications will be lost if fedex_plus is used to
// regenerate it.
/* $Id$  */
#ifndef  SCHEMA_H
#include <schema.h>
#endif

#ifdef  SCL_LOGGING
#include <fstream.h>
    extern ofstream *logStream;
#define SCLLOGFILE "scl.log"
#endif

static int debug_access_hooks = 0;

#ifdef PART26

const char * sclHostName = CORBA::Orbix.myHost(); // Default is local host
#endif

Schema *s_config_control_design =0;

/*	**************  TYPES  	*/
SelectTypeDescriptor 	*config_control_designt_characterized_definition;
TypeDescriptor 	*config_control_designt_parameter_value;
TypeDescriptor 	*config_control_designt_plane_angle_measure;
SelectTypeDescriptor 	*config_control_designt_change_request_item;
TypeDescriptor 	*config_control_designt_text;
TypeDescriptor 	*config_control_designt_year_number;
SelectTypeDescriptor 	*config_control_designt_characterized_product_definition;
SelectTypeDescriptor 	*config_control_designt_reversible_topology_item;
SelectTypeDescriptor 	*config_control_designt_axis2_placement;
SetTypeDescriptor 	*config_control_designt_set_of_reversible_topology_item;

#if __OSTORE__
STEPaggregate *
create_SdaiSet_of_reversible_topology_item (os_database *db) { return create_SdaiReversible_topology_items(db);  }
#else
STEPaggregate *
create_SdaiSet_of_reversible_topology_item () {  return create_SdaiReversible_topology_items();  }
#endif
TypeDescriptor 	*config_control_designt_week_in_year_number;
EnumTypeDescriptor 	*config_control_designt_knot_type;
//////////  ENUMERATION TYPE SdaiKnot_type_var
const char *
SdaiKnot_type_var::element_at (int n) const  {
  switch (n)  {
  case Knot_type__uniform_knots	:  return "UNIFORM_KNOTS";
  case Knot_type__quasi_uniform_knots	:  return "QUASI_UNIFORM_KNOTS";
  case Knot_type__piecewise_bezier_knots	:  return "PIECEWISE_BEZIER_KNOTS";
  case Knot_type__unspecified	:  return "UNSPECIFIED";
  case Knot_type_unset	:
  default		:  return "UNSET";
  }
}

SdaiKnot_type_var::SdaiKnot_type_var (const char * n, EnumTypeDescriptor *et)
  : type(et)
{
  set_value (n);
}

#ifdef __OSTORE__
void
SdaiKnot_type_var::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiKnot_type_var: virtual access function." << endl;
    SdaiKnot_type_var_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiKnot_type_var_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiKnot_type_var *e = (SdaiKnot_type_var *)object;
    if(e->type == 0)
        e->type = config_control_designt_knot_type;
}

#endif

SdaiKnot_type_var::operator Knot_type () const {
  switch (v) {
	case Knot_type__uniform_knots	:  return Knot_type__uniform_knots;
	case Knot_type__quasi_uniform_knots	:  return Knot_type__quasi_uniform_knots;
	case Knot_type__piecewise_bezier_knots	:  return Knot_type__piecewise_bezier_knots;
	case Knot_type__unspecified	:  return Knot_type__unspecified;
	case Knot_type_unset	:
	default		:  return Knot_type_unset;
  }
}

#ifdef __OSTORE__

SCLP23(Enum) *
create_SdaiKnot_type_var (os_database *db)
{
    if(db)
        return new (db,
                    SdaiKnot_type_var::get_os_typespec()) SdaiKnot_type_var;
    else
        return new SdaiKnot_type_var( "", config_control_designt_knot_type );
}

#else

SCLP23(Enum) *
create_SdaiKnot_type_var ()
{
    return new SdaiKnot_type_var( "", config_control_designt_knot_type );
}
#endif


SdaiKnot_type_vars::SdaiKnot_type_vars( EnumTypeDescriptor *et )
    : enum_type(et)
{
}

SdaiKnot_type_vars::~SdaiKnot_type_vars()
{
}

#ifdef __OSTORE__
void
SdaiKnot_type_vars_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiKnot_type_vars *e = (SdaiKnot_type_vars *)object;
    if(e->enum_type == 0)
        e->enum_type = config_control_designt_knot_type;
}

#endif

#ifdef __OSTORE__

STEPaggregate *
create_SdaiKnot_type_vars (os_database *db)
{
    if(db)
        return new (db,
                    SdaiKnot_type_vars::get_os_typespec()) SdaiKnot_type_vars;
    else
        return new SdaiKnot_type_vars( config_control_designt_knot_type );
}

#else

STEPaggregate *
create_SdaiKnot_type_vars ()
{
    return new SdaiKnot_type_vars( config_control_designt_knot_type );
}
#endif

//////////  END ENUMERATION knot_type

SelectTypeDescriptor 	*config_control_designt_specified_item;
TypeDescriptor 	*config_control_designt_minute_in_hour;
EnumTypeDescriptor 	*config_control_designt_transition_code;
//////////  ENUMERATION TYPE SdaiTransition_code_var
const char *
SdaiTransition_code_var::element_at (int n) const  {
  switch (n)  {
  case Transition_code__discontinuous	:  return "DISCONTINUOUS";
  case Transition_code__cont_same_gradient_same_curvature	:  return "CONT_SAME_GRADIENT_SAME_CURVATURE";
  case Transition_code__cont_same_gradient	:  return "CONT_SAME_GRADIENT";
  case Transition_code__continuous	:  return "CONTINUOUS";
  case Transition_code_unset	:
  default		:  return "UNSET";
  }
}

SdaiTransition_code_var::SdaiTransition_code_var (const char * n, EnumTypeDescriptor *et)
  : type(et)
{
  set_value (n);
}

#ifdef __OSTORE__
void
SdaiTransition_code_var::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiTransition_code_var: virtual access function." << endl;
    SdaiTransition_code_var_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiTransition_code_var_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiTransition_code_var *e = (SdaiTransition_code_var *)object;
    if(e->type == 0)
        e->type = config_control_designt_transition_code;
}

#endif

SdaiTransition_code_var::operator Transition_code () const {
  switch (v) {
	case Transition_code__discontinuous	:  return Transition_code__discontinuous;
	case Transition_code__cont_same_gradient_same_curvature	:  return Transition_code__cont_same_gradient_same_curvature;
	case Transition_code__cont_same_gradient	:  return Transition_code__cont_same_gradient;
	case Transition_code__continuous	:  return Transition_code__continuous;
	case Transition_code_unset	:
	default		:  return Transition_code_unset;
  }
}

#ifdef __OSTORE__

SCLP23(Enum) *
create_SdaiTransition_code_var (os_database *db)
{
    if(db)
        return new (db,
                    SdaiTransition_code_var::get_os_typespec()) SdaiTransition_code_var;
    else
        return new SdaiTransition_code_var( "", config_control_designt_transition_code );
}

#else

SCLP23(Enum) *
create_SdaiTransition_code_var ()
{
    return new SdaiTransition_code_var( "", config_control_designt_transition_code );
}
#endif


SdaiTransition_code_vars::SdaiTransition_code_vars( EnumTypeDescriptor *et )
    : enum_type(et)
{
}

SdaiTransition_code_vars::~SdaiTransition_code_vars()
{
}

#ifdef __OSTORE__
void
SdaiTransition_code_vars_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiTransition_code_vars *e = (SdaiTransition_code_vars *)object;
    if(e->enum_type == 0)
        e->enum_type = config_control_designt_transition_code;
}

#endif

#ifdef __OSTORE__

STEPaggregate *
create_SdaiTransition_code_vars (os_database *db)
{
    if(db)
        return new (db,
                    SdaiTransition_code_vars::get_os_typespec()) SdaiTransition_code_vars;
    else
        return new SdaiTransition_code_vars( config_control_designt_transition_code );
}

#else

STEPaggregate *
create_SdaiTransition_code_vars ()
{
    return new SdaiTransition_code_vars( config_control_designt_transition_code );
}
#endif

//////////  END ENUMERATION transition_code

TypeDescriptor 	*config_control_designt_identifier;
SelectTypeDescriptor 	*config_control_designt_measure_value;
SelectTypeDescriptor 	*config_control_designt_person_organization_select;
EnumTypeDescriptor 	*config_control_designt_preferred_surface_curve_representation;
//////////  ENUMERATION TYPE SdaiPreferred_surface_curve_representation_var
const char *
SdaiPreferred_surface_curve_representation_var::element_at (int n) const  {
  switch (n)  {
  case Preferred_surface_curve_representation__pcurve_s2	:  return "PCURVE_S2";
  case Preferred_surface_curve_representation__pcurve_s1	:  return "PCURVE_S1";
  case Preferred_surface_curve_representation__curve_3d	:  return "CURVE_3D";
  case Preferred_surface_curve_representation_unset	:
  default		:  return "UNSET";
  }
}

SdaiPreferred_surface_curve_representation_var::SdaiPreferred_surface_curve_representation_var (const char * n, EnumTypeDescriptor *et)
  : type(et)
{
  set_value (n);
}

#ifdef __OSTORE__
void
SdaiPreferred_surface_curve_representation_var::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPreferred_surface_curve_representation_var: virtual access function." << endl;
    SdaiPreferred_surface_curve_representation_var_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPreferred_surface_curve_representation_var_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiPreferred_surface_curve_representation_var *e = (SdaiPreferred_surface_curve_representation_var *)object;
    if(e->type == 0)
        e->type = config_control_designt_preferred_surface_curve_representation;
}

#endif

SdaiPreferred_surface_curve_representation_var::operator Preferred_surface_curve_representation () const {
  switch (v) {
	case Preferred_surface_curve_representation__pcurve_s2	:  return Preferred_surface_curve_representation__pcurve_s2;
	case Preferred_surface_curve_representation__pcurve_s1	:  return Preferred_surface_curve_representation__pcurve_s1;
	case Preferred_surface_curve_representation__curve_3d	:  return Preferred_surface_curve_representation__curve_3d;
	case Preferred_surface_curve_representation_unset	:
	default		:  return Preferred_surface_curve_representation_unset;
  }
}

#ifdef __OSTORE__

SCLP23(Enum) *
create_SdaiPreferred_surface_curve_representation_var (os_database *db)
{
    if(db)
        return new (db,
                    SdaiPreferred_surface_curve_representation_var::get_os_typespec()) SdaiPreferred_surface_curve_representation_var;
    else
        return new SdaiPreferred_surface_curve_representation_var( "", config_control_designt_preferred_surface_curve_representation );
}

#else

SCLP23(Enum) *
create_SdaiPreferred_surface_curve_representation_var ()
{
    return new SdaiPreferred_surface_curve_representation_var( "", config_control_designt_preferred_surface_curve_representation );
}
#endif


SdaiPreferred_surface_curve_representation_vars::SdaiPreferred_surface_curve_representation_vars( EnumTypeDescriptor *et )
    : enum_type(et)
{
}

SdaiPreferred_surface_curve_representation_vars::~SdaiPreferred_surface_curve_representation_vars()
{
}

#ifdef __OSTORE__
void
SdaiPreferred_surface_curve_representation_vars_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiPreferred_surface_curve_representation_vars *e = (SdaiPreferred_surface_curve_representation_vars *)object;
    if(e->enum_type == 0)
        e->enum_type = config_control_designt_preferred_surface_curve_representation;
}

#endif

#ifdef __OSTORE__

STEPaggregate *
create_SdaiPreferred_surface_curve_representation_vars (os_database *db)
{
    if(db)
        return new (db,
                    SdaiPreferred_surface_curve_representation_vars::get_os_typespec()) SdaiPreferred_surface_curve_representation_vars;
    else
        return new SdaiPreferred_surface_curve_representation_vars( config_control_designt_preferred_surface_curve_representation );
}

#else

STEPaggregate *
create_SdaiPreferred_surface_curve_representation_vars ()
{
    return new SdaiPreferred_surface_curve_representation_vars( config_control_designt_preferred_surface_curve_representation );
}
#endif

//////////  END ENUMERATION preferred_surface_curve_representation

TypeDescriptor 	*config_control_designt_dimension_count;
SelectTypeDescriptor 	*config_control_designt_pcurve_or_surface;
TypeDescriptor 	*config_control_designt_positive_length_measure;
EnumTypeDescriptor 	*config_control_designt_b_spline_curve_form;
//////////  ENUMERATION TYPE SdaiB_spline_curve_form_var
const char *
SdaiB_spline_curve_form_var::element_at (int n) const  {
  switch (n)  {
  case B_spline_curve_form__elliptic_arc	:  return "ELLIPTIC_ARC";
  case B_spline_curve_form__polyline_form	:  return "POLYLINE_FORM";
  case B_spline_curve_form__parabolic_arc	:  return "PARABOLIC_ARC";
  case B_spline_curve_form__circular_arc	:  return "CIRCULAR_ARC";
  case B_spline_curve_form__unspecified	:  return "UNSPECIFIED";
  case B_spline_curve_form__hyperbolic_arc	:  return "HYPERBOLIC_ARC";
  case B_spline_curve_form_unset	:
  default		:  return "UNSET";
  }
}

SdaiB_spline_curve_form_var::SdaiB_spline_curve_form_var (const char * n, EnumTypeDescriptor *et)
  : type(et)
{
  set_value (n);
}

#ifdef __OSTORE__
void
SdaiB_spline_curve_form_var::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiB_spline_curve_form_var: virtual access function." << endl;
    SdaiB_spline_curve_form_var_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiB_spline_curve_form_var_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiB_spline_curve_form_var *e = (SdaiB_spline_curve_form_var *)object;
    if(e->type == 0)
        e->type = config_control_designt_b_spline_curve_form;
}

#endif

SdaiB_spline_curve_form_var::operator B_spline_curve_form () const {
  switch (v) {
	case B_spline_curve_form__elliptic_arc	:  return B_spline_curve_form__elliptic_arc;
	case B_spline_curve_form__polyline_form	:  return B_spline_curve_form__polyline_form;
	case B_spline_curve_form__parabolic_arc	:  return B_spline_curve_form__parabolic_arc;
	case B_spline_curve_form__circular_arc	:  return B_spline_curve_form__circular_arc;
	case B_spline_curve_form__unspecified	:  return B_spline_curve_form__unspecified;
	case B_spline_curve_form__hyperbolic_arc	:  return B_spline_curve_form__hyperbolic_arc;
	case B_spline_curve_form_unset	:
	default		:  return B_spline_curve_form_unset;
  }
}

#ifdef __OSTORE__

SCLP23(Enum) *
create_SdaiB_spline_curve_form_var (os_database *db)
{
    if(db)
        return new (db,
                    SdaiB_spline_curve_form_var::get_os_typespec()) SdaiB_spline_curve_form_var;
    else
        return new SdaiB_spline_curve_form_var( "", config_control_designt_b_spline_curve_form );
}

#else

SCLP23(Enum) *
create_SdaiB_spline_curve_form_var ()
{
    return new SdaiB_spline_curve_form_var( "", config_control_designt_b_spline_curve_form );
}
#endif


SdaiB_spline_curve_form_vars::SdaiB_spline_curve_form_vars( EnumTypeDescriptor *et )
    : enum_type(et)
{
}

SdaiB_spline_curve_form_vars::~SdaiB_spline_curve_form_vars()
{
}

#ifdef __OSTORE__
void
SdaiB_spline_curve_form_vars_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiB_spline_curve_form_vars *e = (SdaiB_spline_curve_form_vars *)object;
    if(e->enum_type == 0)
        e->enum_type = config_control_designt_b_spline_curve_form;
}

#endif

#ifdef __OSTORE__

STEPaggregate *
create_SdaiB_spline_curve_form_vars (os_database *db)
{
    if(db)
        return new (db,
                    SdaiB_spline_curve_form_vars::get_os_typespec()) SdaiB_spline_curve_form_vars;
    else
        return new SdaiB_spline_curve_form_vars( config_control_designt_b_spline_curve_form );
}

#else

STEPaggregate *
create_SdaiB_spline_curve_form_vars ()
{
    return new SdaiB_spline_curve_form_vars( config_control_designt_b_spline_curve_form );
}
#endif

//////////  END ENUMERATION b_spline_curve_form

TypeDescriptor 	*config_control_designt_hour_in_day;
SelectTypeDescriptor 	*config_control_designt_classified_item;
EnumTypeDescriptor 	*config_control_designt_si_unit_name;
//////////  ENUMERATION TYPE SdaiSi_unit_name_var
const char *
SdaiSi_unit_name_var::element_at (int n) const  {
  switch (n)  {
  case Si_unit_name__hertz	:  return "HERTZ";
  case Si_unit_name__degree_celsius	:  return "DEGREE_CELSIUS";
  case Si_unit_name__siemens	:  return "SIEMENS";
  case Si_unit_name__sievert	:  return "SIEVERT";
  case Si_unit_name__lux	:  return "LUX";
  case Si_unit_name__watt	:  return "WATT";
  case Si_unit_name__ohm	:  return "OHM";
  case Si_unit_name__second	:  return "SECOND";
  case Si_unit_name__becquerel	:  return "BECQUEREL";
  case Si_unit_name__pascal	:  return "PASCAL";
  case Si_unit_name__henry	:  return "HENRY";
  case Si_unit_name__tesla	:  return "TESLA";
  case Si_unit_name__volt	:  return "VOLT";
  case Si_unit_name__joule	:  return "JOULE";
  case Si_unit_name__kelvin	:  return "KELVIN";
  case Si_unit_name__ampere	:  return "AMPERE";
  case Si_unit_name__gram	:  return "GRAM";
  case Si_unit_name__steradian	:  return "STERADIAN";
  case Si_unit_name__mole	:  return "MOLE";
  case Si_unit_name__lumen	:  return "LUMEN";
  case Si_unit_name__gray	:  return "GRAY";
  case Si_unit_name__candela	:  return "CANDELA";
  case Si_unit_name__farad	:  return "FARAD";
  case Si_unit_name__radian	:  return "RADIAN";
  case Si_unit_name__newton	:  return "NEWTON";
  case Si_unit_name__metre	:  return "METRE";
  case Si_unit_name__weber	:  return "WEBER";
  case Si_unit_name__coulomb	:  return "COULOMB";
  case Si_unit_name_unset	:
  default		:  return "UNSET";
  }
}

SdaiSi_unit_name_var::SdaiSi_unit_name_var (const char * n, EnumTypeDescriptor *et)
  : type(et)
{
  set_value (n);
}

#ifdef __OSTORE__
void
SdaiSi_unit_name_var::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSi_unit_name_var: virtual access function." << endl;
    SdaiSi_unit_name_var_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSi_unit_name_var_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiSi_unit_name_var *e = (SdaiSi_unit_name_var *)object;
    if(e->type == 0)
        e->type = config_control_designt_si_unit_name;
}

#endif

SdaiSi_unit_name_var::operator Si_unit_name () const {
  switch (v) {
	case Si_unit_name__hertz	:  return Si_unit_name__hertz;
	case Si_unit_name__degree_celsius	:  return Si_unit_name__degree_celsius;
	case Si_unit_name__siemens	:  return Si_unit_name__siemens;
	case Si_unit_name__sievert	:  return Si_unit_name__sievert;
	case Si_unit_name__lux	:  return Si_unit_name__lux;
	case Si_unit_name__watt	:  return Si_unit_name__watt;
	case Si_unit_name__ohm	:  return Si_unit_name__ohm;
	case Si_unit_name__second	:  return Si_unit_name__second;
	case Si_unit_name__becquerel	:  return Si_unit_name__becquerel;
	case Si_unit_name__pascal	:  return Si_unit_name__pascal;
	case Si_unit_name__henry	:  return Si_unit_name__henry;
	case Si_unit_name__tesla	:  return Si_unit_name__tesla;
	case Si_unit_name__volt	:  return Si_unit_name__volt;
	case Si_unit_name__joule	:  return Si_unit_name__joule;
	case Si_unit_name__kelvin	:  return Si_unit_name__kelvin;
	case Si_unit_name__ampere	:  return Si_unit_name__ampere;
	case Si_unit_name__gram	:  return Si_unit_name__gram;
	case Si_unit_name__steradian	:  return Si_unit_name__steradian;
	case Si_unit_name__mole	:  return Si_unit_name__mole;
	case Si_unit_name__lumen	:  return Si_unit_name__lumen;
	case Si_unit_name__gray	:  return Si_unit_name__gray;
	case Si_unit_name__candela	:  return Si_unit_name__candela;
	case Si_unit_name__farad	:  return Si_unit_name__farad;
	case Si_unit_name__radian	:  return Si_unit_name__radian;
	case Si_unit_name__newton	:  return Si_unit_name__newton;
	case Si_unit_name__metre	:  return Si_unit_name__metre;
	case Si_unit_name__weber	:  return Si_unit_name__weber;
	case Si_unit_name__coulomb	:  return Si_unit_name__coulomb;
	case Si_unit_name_unset	:
	default		:  return Si_unit_name_unset;
  }
}

#ifdef __OSTORE__

SCLP23(Enum) *
create_SdaiSi_unit_name_var (os_database *db)
{
    if(db)
        return new (db,
                    SdaiSi_unit_name_var::get_os_typespec()) SdaiSi_unit_name_var;
    else
        return new SdaiSi_unit_name_var( "", config_control_designt_si_unit_name );
}

#else

SCLP23(Enum) *
create_SdaiSi_unit_name_var ()
{
    return new SdaiSi_unit_name_var( "", config_control_designt_si_unit_name );
}
#endif


SdaiSi_unit_name_vars::SdaiSi_unit_name_vars( EnumTypeDescriptor *et )
    : enum_type(et)
{
}

SdaiSi_unit_name_vars::~SdaiSi_unit_name_vars()
{
}

#ifdef __OSTORE__
void
SdaiSi_unit_name_vars_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiSi_unit_name_vars *e = (SdaiSi_unit_name_vars *)object;
    if(e->enum_type == 0)
        e->enum_type = config_control_designt_si_unit_name;
}

#endif

#ifdef __OSTORE__

STEPaggregate *
create_SdaiSi_unit_name_vars (os_database *db)
{
    if(db)
        return new (db,
                    SdaiSi_unit_name_vars::get_os_typespec()) SdaiSi_unit_name_vars;
    else
        return new SdaiSi_unit_name_vars( config_control_designt_si_unit_name );
}

#else

STEPaggregate *
create_SdaiSi_unit_name_vars ()
{
    return new SdaiSi_unit_name_vars( config_control_designt_si_unit_name );
}
#endif

//////////  END ENUMERATION si_unit_name

TypeDescriptor 	*config_control_designt_day_in_month_number;
SelectTypeDescriptor 	*config_control_designt_founded_item_select;
EnumTypeDescriptor 	*config_control_designt_trimming_preference;
//////////  ENUMERATION TYPE SdaiTrimming_preference_var
const char *
SdaiTrimming_preference_var::element_at (int n) const  {
  switch (n)  {
  case Trimming_preference__parameter	:  return "PARAMETER";
  case Trimming_preference__unspecified	:  return "UNSPECIFIED";
  case Trimming_preference__cartesian	:  return "CARTESIAN";
  case Trimming_preference_unset	:
  default		:  return "UNSET";
  }
}

SdaiTrimming_preference_var::SdaiTrimming_preference_var (const char * n, EnumTypeDescriptor *et)
  : type(et)
{
  set_value (n);
}

#ifdef __OSTORE__
void
SdaiTrimming_preference_var::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiTrimming_preference_var: virtual access function." << endl;
    SdaiTrimming_preference_var_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiTrimming_preference_var_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiTrimming_preference_var *e = (SdaiTrimming_preference_var *)object;
    if(e->type == 0)
        e->type = config_control_designt_trimming_preference;
}

#endif

SdaiTrimming_preference_var::operator Trimming_preference () const {
  switch (v) {
	case Trimming_preference__parameter	:  return Trimming_preference__parameter;
	case Trimming_preference__unspecified	:  return Trimming_preference__unspecified;
	case Trimming_preference__cartesian	:  return Trimming_preference__cartesian;
	case Trimming_preference_unset	:
	default		:  return Trimming_preference_unset;
  }
}

#ifdef __OSTORE__

SCLP23(Enum) *
create_SdaiTrimming_preference_var (os_database *db)
{
    if(db)
        return new (db,
                    SdaiTrimming_preference_var::get_os_typespec()) SdaiTrimming_preference_var;
    else
        return new SdaiTrimming_preference_var( "", config_control_designt_trimming_preference );
}

#else

SCLP23(Enum) *
create_SdaiTrimming_preference_var ()
{
    return new SdaiTrimming_preference_var( "", config_control_designt_trimming_preference );
}
#endif


SdaiTrimming_preference_vars::SdaiTrimming_preference_vars( EnumTypeDescriptor *et )
    : enum_type(et)
{
}

SdaiTrimming_preference_vars::~SdaiTrimming_preference_vars()
{
}

#ifdef __OSTORE__
void
SdaiTrimming_preference_vars_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiTrimming_preference_vars *e = (SdaiTrimming_preference_vars *)object;
    if(e->enum_type == 0)
        e->enum_type = config_control_designt_trimming_preference;
}

#endif

#ifdef __OSTORE__

STEPaggregate *
create_SdaiTrimming_preference_vars (os_database *db)
{
    if(db)
        return new (db,
                    SdaiTrimming_preference_vars::get_os_typespec()) SdaiTrimming_preference_vars;
    else
        return new SdaiTrimming_preference_vars( config_control_designt_trimming_preference );
}

#else

STEPaggregate *
create_SdaiTrimming_preference_vars ()
{
    return new SdaiTrimming_preference_vars( config_control_designt_trimming_preference );
}
#endif

//////////  END ENUMERATION trimming_preference

SelectTypeDescriptor 	*config_control_designt_vector_or_direction;
SelectTypeDescriptor 	*config_control_designt_wireframe_model;
TypeDescriptor 	*config_control_designt_volume_measure;
SelectTypeDescriptor 	*config_control_designt_geometric_set_select;
TypeDescriptor 	*config_control_designt_positive_plane_angle_measure;
SelectTypeDescriptor 	*config_control_designt_start_request_item;
EnumTypeDescriptor 	*config_control_designt_b_spline_surface_form;
//////////  ENUMERATION TYPE SdaiB_spline_surface_form_var
const char *
SdaiB_spline_surface_form_var::element_at (int n) const  {
  switch (n)  {
  case B_spline_surface_form__surf_of_linear_extrusion	:  return "SURF_OF_LINEAR_EXTRUSION";
  case B_spline_surface_form__plane_surf	:  return "PLANE_SURF";
  case B_spline_surface_form__generalised_cone	:  return "GENERALISED_CONE";
  case B_spline_surface_form__toroidal_surf	:  return "TOROIDAL_SURF";
  case B_spline_surface_form__conical_surf	:  return "CONICAL_SURF";
  case B_spline_surface_form__spherical_surf	:  return "SPHERICAL_SURF";
  case B_spline_surface_form__unspecified	:  return "UNSPECIFIED";
  case B_spline_surface_form__ruled_surf	:  return "RULED_SURF";
  case B_spline_surface_form__surf_of_revolution	:  return "SURF_OF_REVOLUTION";
  case B_spline_surface_form__cylindrical_surf	:  return "CYLINDRICAL_SURF";
  case B_spline_surface_form__quadric_surf	:  return "QUADRIC_SURF";
  case B_spline_surface_form_unset	:
  default		:  return "UNSET";
  }
}

SdaiB_spline_surface_form_var::SdaiB_spline_surface_form_var (const char * n, EnumTypeDescriptor *et)
  : type(et)
{
  set_value (n);
}

#ifdef __OSTORE__
void
SdaiB_spline_surface_form_var::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiB_spline_surface_form_var: virtual access function." << endl;
    SdaiB_spline_surface_form_var_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiB_spline_surface_form_var_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiB_spline_surface_form_var *e = (SdaiB_spline_surface_form_var *)object;
    if(e->type == 0)
        e->type = config_control_designt_b_spline_surface_form;
}

#endif

SdaiB_spline_surface_form_var::operator B_spline_surface_form () const {
  switch (v) {
	case B_spline_surface_form__surf_of_linear_extrusion	:  return B_spline_surface_form__surf_of_linear_extrusion;
	case B_spline_surface_form__plane_surf	:  return B_spline_surface_form__plane_surf;
	case B_spline_surface_form__generalised_cone	:  return B_spline_surface_form__generalised_cone;
	case B_spline_surface_form__toroidal_surf	:  return B_spline_surface_form__toroidal_surf;
	case B_spline_surface_form__conical_surf	:  return B_spline_surface_form__conical_surf;
	case B_spline_surface_form__spherical_surf	:  return B_spline_surface_form__spherical_surf;
	case B_spline_surface_form__unspecified	:  return B_spline_surface_form__unspecified;
	case B_spline_surface_form__ruled_surf	:  return B_spline_surface_form__ruled_surf;
	case B_spline_surface_form__surf_of_revolution	:  return B_spline_surface_form__surf_of_revolution;
	case B_spline_surface_form__cylindrical_surf	:  return B_spline_surface_form__cylindrical_surf;
	case B_spline_surface_form__quadric_surf	:  return B_spline_surface_form__quadric_surf;
	case B_spline_surface_form_unset	:
	default		:  return B_spline_surface_form_unset;
  }
}

#ifdef __OSTORE__

SCLP23(Enum) *
create_SdaiB_spline_surface_form_var (os_database *db)
{
    if(db)
        return new (db,
                    SdaiB_spline_surface_form_var::get_os_typespec()) SdaiB_spline_surface_form_var;
    else
        return new SdaiB_spline_surface_form_var( "", config_control_designt_b_spline_surface_form );
}

#else

SCLP23(Enum) *
create_SdaiB_spline_surface_form_var ()
{
    return new SdaiB_spline_surface_form_var( "", config_control_designt_b_spline_surface_form );
}
#endif


SdaiB_spline_surface_form_vars::SdaiB_spline_surface_form_vars( EnumTypeDescriptor *et )
    : enum_type(et)
{
}

SdaiB_spline_surface_form_vars::~SdaiB_spline_surface_form_vars()
{
}

#ifdef __OSTORE__
void
SdaiB_spline_surface_form_vars_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiB_spline_surface_form_vars *e = (SdaiB_spline_surface_form_vars *)object;
    if(e->enum_type == 0)
        e->enum_type = config_control_designt_b_spline_surface_form;
}

#endif

#ifdef __OSTORE__

STEPaggregate *
create_SdaiB_spline_surface_form_vars (os_database *db)
{
    if(db)
        return new (db,
                    SdaiB_spline_surface_form_vars::get_os_typespec()) SdaiB_spline_surface_form_vars;
    else
        return new SdaiB_spline_surface_form_vars( config_control_designt_b_spline_surface_form );
}

#else

STEPaggregate *
create_SdaiB_spline_surface_form_vars ()
{
    return new SdaiB_spline_surface_form_vars( config_control_designt_b_spline_surface_form );
}
#endif

//////////  END ENUMERATION b_spline_surface_form

SelectTypeDescriptor 	*config_control_designt_person_organization_item;
SelectTypeDescriptor 	*config_control_designt_date_time_item;
SelectTypeDescriptor 	*config_control_designt_shell;
SelectTypeDescriptor 	*config_control_designt_transformation;
TypeDescriptor 	*config_control_designt_day_in_week_number;
SelectTypeDescriptor 	*config_control_designt_boolean_operand;
SelectTypeDescriptor 	*config_control_designt_certified_item;
SelectTypeDescriptor 	*config_control_designt_date_time_select;
TypeDescriptor 	*config_control_designt_solid_angle_measure;
SelectTypeDescriptor 	*config_control_designt_curve_on_surface;
SelectTypeDescriptor 	*config_control_designt_trimming_select;
EnumTypeDescriptor 	*config_control_designt_ahead_or_behind;
//////////  ENUMERATION TYPE SdaiAhead_or_behind_var
const char *
SdaiAhead_or_behind_var::element_at (int n) const  {
  switch (n)  {
  case Ahead_or_behind__ahead	:  return "AHEAD";
  case Ahead_or_behind__behind	:  return "BEHIND";
  case Ahead_or_behind_unset	:
  default		:  return "UNSET";
  }
}

SdaiAhead_or_behind_var::SdaiAhead_or_behind_var (const char * n, EnumTypeDescriptor *et)
  : type(et)
{
  set_value (n);
}

#ifdef __OSTORE__
void
SdaiAhead_or_behind_var::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAhead_or_behind_var: virtual access function." << endl;
    SdaiAhead_or_behind_var_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAhead_or_behind_var_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiAhead_or_behind_var *e = (SdaiAhead_or_behind_var *)object;
    if(e->type == 0)
        e->type = config_control_designt_ahead_or_behind;
}

#endif

SdaiAhead_or_behind_var::operator Ahead_or_behind () const {
  switch (v) {
	case Ahead_or_behind__ahead	:  return Ahead_or_behind__ahead;
	case Ahead_or_behind__behind	:  return Ahead_or_behind__behind;
	case Ahead_or_behind_unset	:
	default		:  return Ahead_or_behind_unset;
  }
}

#ifdef __OSTORE__

SCLP23(Enum) *
create_SdaiAhead_or_behind_var (os_database *db)
{
    if(db)
        return new (db,
                    SdaiAhead_or_behind_var::get_os_typespec()) SdaiAhead_or_behind_var;
    else
        return new SdaiAhead_or_behind_var( "", config_control_designt_ahead_or_behind );
}

#else

SCLP23(Enum) *
create_SdaiAhead_or_behind_var ()
{
    return new SdaiAhead_or_behind_var( "", config_control_designt_ahead_or_behind );
}
#endif


SdaiAhead_or_behind_vars::SdaiAhead_or_behind_vars( EnumTypeDescriptor *et )
    : enum_type(et)
{
}

SdaiAhead_or_behind_vars::~SdaiAhead_or_behind_vars()
{
}

#ifdef __OSTORE__
void
SdaiAhead_or_behind_vars_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiAhead_or_behind_vars *e = (SdaiAhead_or_behind_vars *)object;
    if(e->enum_type == 0)
        e->enum_type = config_control_designt_ahead_or_behind;
}

#endif

#ifdef __OSTORE__

STEPaggregate *
create_SdaiAhead_or_behind_vars (os_database *db)
{
    if(db)
        return new (db,
                    SdaiAhead_or_behind_vars::get_os_typespec()) SdaiAhead_or_behind_vars;
    else
        return new SdaiAhead_or_behind_vars( config_control_designt_ahead_or_behind );
}

#else

STEPaggregate *
create_SdaiAhead_or_behind_vars ()
{
    return new SdaiAhead_or_behind_vars( config_control_designt_ahead_or_behind );
}
#endif

//////////  END ENUMERATION ahead_or_behind

SelectTypeDescriptor 	*config_control_designt_contracted_item;
TypeDescriptor 	*config_control_designt_day_in_year_number;
TypeDescriptor 	*config_control_designt_mass_measure;
TypeDescriptor 	*config_control_designt_descriptive_measure;
TypeDescriptor 	*config_control_designt_area_measure;
TypeDescriptor 	*config_control_designt_month_in_year_number;
EnumTypeDescriptor 	*config_control_designt_source;
//////////  ENUMERATION TYPE SdaiSource_var
const char *
SdaiSource_var::element_at (int n) const  {
  switch (n)  {
  case Source__bought	:  return "BOUGHT";
  case Source__not_known	:  return "NOT_KNOWN";
  case Source__made	:  return "MADE";
  case Source_unset	:
  default		:  return "UNSET";
  }
}

SdaiSource_var::SdaiSource_var (const char * n, EnumTypeDescriptor *et)
  : type(et)
{
  set_value (n);
}

#ifdef __OSTORE__
void
SdaiSource_var::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSource_var: virtual access function." << endl;
    SdaiSource_var_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSource_var_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiSource_var *e = (SdaiSource_var *)object;
    if(e->type == 0)
        e->type = config_control_designt_source;
}

#endif

SdaiSource_var::operator Source () const {
  switch (v) {
	case Source__bought	:  return Source__bought;
	case Source__not_known	:  return Source__not_known;
	case Source__made	:  return Source__made;
	case Source_unset	:
	default		:  return Source_unset;
  }
}

#ifdef __OSTORE__

SCLP23(Enum) *
create_SdaiSource_var (os_database *db)
{
    if(db)
        return new (db,
                    SdaiSource_var::get_os_typespec()) SdaiSource_var;
    else
        return new SdaiSource_var( "", config_control_designt_source );
}

#else

SCLP23(Enum) *
create_SdaiSource_var ()
{
    return new SdaiSource_var( "", config_control_designt_source );
}
#endif


SdaiSource_vars::SdaiSource_vars( EnumTypeDescriptor *et )
    : enum_type(et)
{
}

SdaiSource_vars::~SdaiSource_vars()
{
}

#ifdef __OSTORE__
void
SdaiSource_vars_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiSource_vars *e = (SdaiSource_vars *)object;
    if(e->enum_type == 0)
        e->enum_type = config_control_designt_source;
}

#endif

#ifdef __OSTORE__

STEPaggregate *
create_SdaiSource_vars (os_database *db)
{
    if(db)
        return new (db,
                    SdaiSource_vars::get_os_typespec()) SdaiSource_vars;
    else
        return new SdaiSource_vars( config_control_designt_source );
}

#else

STEPaggregate *
create_SdaiSource_vars ()
{
    return new SdaiSource_vars( config_control_designt_source );
}
#endif

//////////  END ENUMERATION source

SelectTypeDescriptor 	*config_control_designt_unit;
SelectTypeDescriptor 	*config_control_designt_reversible_topology;
SelectTypeDescriptor 	*config_control_designt_work_item;
SelectTypeDescriptor 	*config_control_designt_shape_definition;
TypeDescriptor 	*config_control_designt_second_in_minute;
TypeDescriptor 	*config_control_designt_label;
TypeDescriptor 	*config_control_designt_context_dependent_measure;
SelectTypeDescriptor 	*config_control_designt_supported_item;
EnumTypeDescriptor 	*config_control_designt_si_prefix;
//////////  ENUMERATION TYPE SdaiSi_prefix_var
const char *
SdaiSi_prefix_var::element_at (int n) const  {
  switch (n)  {
  case Si_prefix__exa	:  return "EXA";
  case Si_prefix__pico	:  return "PICO";
  case Si_prefix__mega	:  return "MEGA";
  case Si_prefix__femto	:  return "FEMTO";
  case Si_prefix__atto	:  return "ATTO";
  case Si_prefix__centi	:  return "CENTI";
  case Si_prefix__nano	:  return "NANO";
  case Si_prefix__hecto	:  return "HECTO";
  case Si_prefix__micro	:  return "MICRO";
  case Si_prefix__tera	:  return "TERA";
  case Si_prefix__giga	:  return "GIGA";
  case Si_prefix__milli	:  return "MILLI";
  case Si_prefix__peta	:  return "PETA";
  case Si_prefix__deci	:  return "DECI";
  case Si_prefix__kilo	:  return "KILO";
  case Si_prefix__deca	:  return "DECA";
  case Si_prefix_unset	:
  default		:  return "UNSET";
  }
}

SdaiSi_prefix_var::SdaiSi_prefix_var (const char * n, EnumTypeDescriptor *et)
  : type(et)
{
  set_value (n);
}

#ifdef __OSTORE__
void
SdaiSi_prefix_var::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSi_prefix_var: virtual access function." << endl;
    SdaiSi_prefix_var_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSi_prefix_var_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiSi_prefix_var *e = (SdaiSi_prefix_var *)object;
    if(e->type == 0)
        e->type = config_control_designt_si_prefix;
}

#endif

SdaiSi_prefix_var::operator Si_prefix () const {
  switch (v) {
	case Si_prefix__exa	:  return Si_prefix__exa;
	case Si_prefix__pico	:  return Si_prefix__pico;
	case Si_prefix__mega	:  return Si_prefix__mega;
	case Si_prefix__femto	:  return Si_prefix__femto;
	case Si_prefix__atto	:  return Si_prefix__atto;
	case Si_prefix__centi	:  return Si_prefix__centi;
	case Si_prefix__nano	:  return Si_prefix__nano;
	case Si_prefix__hecto	:  return Si_prefix__hecto;
	case Si_prefix__micro	:  return Si_prefix__micro;
	case Si_prefix__tera	:  return Si_prefix__tera;
	case Si_prefix__giga	:  return Si_prefix__giga;
	case Si_prefix__milli	:  return Si_prefix__milli;
	case Si_prefix__peta	:  return Si_prefix__peta;
	case Si_prefix__deci	:  return Si_prefix__deci;
	case Si_prefix__kilo	:  return Si_prefix__kilo;
	case Si_prefix__deca	:  return Si_prefix__deca;
	case Si_prefix_unset	:
	default		:  return Si_prefix_unset;
  }
}

#ifdef __OSTORE__

SCLP23(Enum) *
create_SdaiSi_prefix_var (os_database *db)
{
    if(db)
        return new (db,
                    SdaiSi_prefix_var::get_os_typespec()) SdaiSi_prefix_var;
    else
        return new SdaiSi_prefix_var( "", config_control_designt_si_prefix );
}

#else

SCLP23(Enum) *
create_SdaiSi_prefix_var ()
{
    return new SdaiSi_prefix_var( "", config_control_designt_si_prefix );
}
#endif


SdaiSi_prefix_vars::SdaiSi_prefix_vars( EnumTypeDescriptor *et )
    : enum_type(et)
{
}

SdaiSi_prefix_vars::~SdaiSi_prefix_vars()
{
}

#ifdef __OSTORE__
void
SdaiSi_prefix_vars_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    SdaiSi_prefix_vars *e = (SdaiSi_prefix_vars *)object;
    if(e->enum_type == 0)
        e->enum_type = config_control_designt_si_prefix;
}

#endif

#ifdef __OSTORE__

STEPaggregate *
create_SdaiSi_prefix_vars (os_database *db)
{
    if(db)
        return new (db,
                    SdaiSi_prefix_vars::get_os_typespec()) SdaiSi_prefix_vars;
    else
        return new SdaiSi_prefix_vars( config_control_designt_si_prefix );
}

#else

STEPaggregate *
create_SdaiSi_prefix_vars ()
{
    return new SdaiSi_prefix_vars( config_control_designt_si_prefix );
}
#endif

//////////  END ENUMERATION si_prefix

TypeDescriptor 	*config_control_designt_length_measure;
SelectTypeDescriptor 	*config_control_designt_approved_item;
TypeDescriptor 	*config_control_designt_count_measure;
SelectTypeDescriptor 	*config_control_designt_surface_model;
ListTypeDescriptor 	*config_control_designt_list_of_reversible_topology_item;

#if __OSTORE__
STEPaggregate *
create_SdaiList_of_reversible_topology_item (os_database *db) { return create_SdaiReversible_topology_items(db);  }
#else
STEPaggregate *
create_SdaiList_of_reversible_topology_item () {  return create_SdaiReversible_topology_items();  }
#endif

//////////  SELECT TYPE characterized_product_definition

const TypeDescriptor *
SdaiCharacterized_product_definition::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PRODUCT_DEFINITION
  if (se -> IsA (config_control_designe_product_definition))
  {
	_app_inst = (SdaiProduct_definition_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition);
  }
  //  PRODUCT_DEFINITION_RELATIONSHIP
  if (se -> IsA (config_control_designe_product_definition_relationship))
  {
	_app_inst = (SdaiProduct_definition_relationship_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition_relationship);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiCharacterized_product_definition::NewSelect ()
{
#ifdef __OSTORE__
    SdaiCharacterized_product_definition * tmp =
		new( os_segment::of(this),
		     SdaiCharacterized_product_definition::get_os_typespec() )
			SdaiCharacterized_product_definition();
#else
    SdaiCharacterized_product_definition * tmp = new SdaiCharacterized_product_definition();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiCharacterized_product_definition::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_product_definition_relationship)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiCharacterized_product_definition::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_product_definition)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_product_definition_relationship)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiCharacterized_product_definition::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_product_definition)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_product_definition_relationship)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiCharacterized_product_definition::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_product_definition_relationship)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiCharacterized_product_definition::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiCharacterized_product_definition (os_database *db)
{
    return new (db, SdaiCharacterized_product_definition::get_os_typespec())
		SdaiCharacterized_product_definition ;
}

void
SdaiCharacterized_product_definition_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiCharacterized_product_definition access hook funct called." << endl;
    }
#endif
    SdaiCharacterized_product_definition *s = (SdaiCharacterized_product_definition *) object;
    s->_type = config_control_designt_characterized_product_definition;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiCharacterized_product_definitions (os_database *db)
{
    return new (db, SdaiCharacterized_product_definitions::get_os_typespec())
		SdaiCharacterized_product_definitions ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiCharacterized_product_definition::SdaiCharacterized_product_definition( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCharacterized_product_definition constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCharacterized_product_definition constructor." << endl;
    }
#endif
}

	//  part 1
SdaiCharacterized_product_definition::SdaiCharacterized_product_definition( const SdaiProduct_definition_ptr& o,
                                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCharacterized_product_definition constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCharacterized_product_definition constructor." << endl;
    }
#endif
}

SdaiCharacterized_product_definition::SdaiCharacterized_product_definition( const SdaiProduct_definition_relationship_ptr& o,
                                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition_relationship)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCharacterized_product_definition constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCharacterized_product_definition constructor." << endl;
    }
#endif
}

SdaiCharacterized_product_definition::~SdaiCharacterized_product_definition()
{
}

SdaiCharacterized_product_definitions::SdaiCharacterized_product_definitions( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiCharacterized_product_definitions::~SdaiCharacterized_product_definitions() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiCharacterized_product_definitions::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiCharacterized_product_definition::get_os_typespec() )
		    SdaiCharacterized_product_definition );
}
#endif


	//  part 2
SdaiCharacterized_product_definition::operator SdaiProduct_definition_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return ((SdaiProduct_definition_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiCharacterized_product_definition::operator SdaiProduct_definition_relationship_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
      return ((SdaiProduct_definition_relationship_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiProduct_definition_ptr
SdaiCharacterized_product_definition::related_product_definition_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	//  PRODUCT_DEFINITION_RELATIONSHIP
	return ((SdaiProduct_definition_relationship_ptr) _app_inst) ->related_product_definition_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCharacterized_product_definition::related_product_definition_ (const SdaiProduct_definition_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	//  PRODUCT_DEFINITION_RELATIONSHIP
	{  ((SdaiProduct_definition_relationship_ptr) _app_inst) ->related_product_definition_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_ptr
SdaiCharacterized_product_definition::relating_product_definition_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	//  PRODUCT_DEFINITION_RELATIONSHIP
	return ((SdaiProduct_definition_relationship_ptr) _app_inst) ->relating_product_definition_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCharacterized_product_definition::relating_product_definition_ (const SdaiProduct_definition_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	//  PRODUCT_DEFINITION_RELATIONSHIP
	{  ((SdaiProduct_definition_relationship_ptr) _app_inst) ->relating_product_definition_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiCharacterized_product_definition::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	//  PRODUCT_DEFINITION_RELATIONSHIP
	return ((SdaiProduct_definition_relationship_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCharacterized_product_definition::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	//  PRODUCT_DEFINITION_RELATIONSHIP
	{  ((SdaiProduct_definition_relationship_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_context_ptr
SdaiCharacterized_product_definition::frame_of_reference_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->frame_of_reference_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCharacterized_product_definition::frame_of_reference_ (const SdaiProduct_definition_context_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->frame_of_reference_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_formation_ptr
SdaiCharacterized_product_definition::formation_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->formation_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCharacterized_product_definition::formation_ (const SdaiProduct_definition_formation_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->formation_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiCharacterized_product_definition::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	//  PRODUCT_DEFINITION_RELATIONSHIP
	return ((SdaiProduct_definition_relationship_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCharacterized_product_definition::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	//  PRODUCT_DEFINITION_RELATIONSHIP
	{  ((SdaiProduct_definition_relationship_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiCharacterized_product_definition::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	//  PRODUCT_DEFINITION_RELATIONSHIP
	return ((SdaiProduct_definition_relationship_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCharacterized_product_definition::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->id_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	//  PRODUCT_DEFINITION_RELATIONSHIP
	{  ((SdaiProduct_definition_relationship_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiCharacterized_product_definition& SdaiCharacterized_product_definition::operator =( const SdaiProduct_definition_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition);
   return *this;
}

SdaiCharacterized_product_definition& SdaiCharacterized_product_definition::operator =( const SdaiProduct_definition_relationship_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition_relationship);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiCharacterized_product_definition& SdaiCharacterized_product_definition::operator =( const SdaiCharacterized_product_definition_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiCharacterized_product_definition::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_product_definition )
	_app_inst = ((SdaiCharacterized_product_definition&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	_app_inst = ((SdaiCharacterized_product_definition&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiCharacterized_product_definition::IsProduct_definition() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiCharacterized_product_definition::IsProduct_definition_relationship() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiCharacterized_product_definition


//////////  SELECT TYPE shape_definition

const TypeDescriptor *
SdaiShape_definition::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PRODUCT_DEFINITION_SHAPE
  if (se -> IsA (config_control_designe_product_definition_shape))
  {
	_app_inst = (SdaiProduct_definition_shape_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition_shape);
  }
  //  SHAPE_ASPECT
  if (se -> IsA (config_control_designe_shape_aspect))
  {
	_app_inst = (SdaiShape_aspect_ptr) se;
	return SetUnderlyingType (config_control_designe_shape_aspect);
  }
  //  SHAPE_ASPECT_RELATIONSHIP
  if (se -> IsA (config_control_designe_shape_aspect_relationship))
  {
	_app_inst = (SdaiShape_aspect_relationship_ptr) se;
	return SetUnderlyingType (config_control_designe_shape_aspect_relationship);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiShape_definition::NewSelect ()
{
#ifdef __OSTORE__
    SdaiShape_definition * tmp =
		new( os_segment::of(this),
		     SdaiShape_definition::get_os_typespec() )
			SdaiShape_definition();
#else
    SdaiShape_definition * tmp = new SdaiShape_definition();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiShape_definition::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_shape)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_shape_aspect)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiShape_definition::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_product_definition_shape)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_shape_aspect)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_shape_aspect_relationship)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiShape_definition::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_product_definition_shape)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_shape_aspect)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_shape_aspect_relationship)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiShape_definition::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_shape)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_shape_aspect)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiShape_definition::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiShape_definition (os_database *db)
{
    return new (db, SdaiShape_definition::get_os_typespec())
		SdaiShape_definition ;
}

void
SdaiShape_definition_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiShape_definition access hook funct called." << endl;
    }
#endif
    SdaiShape_definition *s = (SdaiShape_definition *) object;
    s->_type = config_control_designt_shape_definition;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiShape_definitions (os_database *db)
{
    return new (db, SdaiShape_definitions::get_os_typespec())
		SdaiShape_definitions ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiShape_definition::SdaiShape_definition( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiShape_definition constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiShape_definition constructor." << endl;
    }
#endif
}

	//  part 1
SdaiShape_definition::SdaiShape_definition( const SdaiProduct_definition_shape_ptr& o,
                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition_shape)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiShape_definition constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiShape_definition constructor." << endl;
    }
#endif
}

SdaiShape_definition::SdaiShape_definition( const SdaiShape_aspect_ptr& o,
                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_shape_aspect)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiShape_definition constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiShape_definition constructor." << endl;
    }
#endif
}

SdaiShape_definition::SdaiShape_definition( const SdaiShape_aspect_relationship_ptr& o,
                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_shape_aspect_relationship)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiShape_definition constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiShape_definition constructor." << endl;
    }
#endif
}

SdaiShape_definition::~SdaiShape_definition()
{
}

SdaiShape_definitions::SdaiShape_definitions( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiShape_definitions::~SdaiShape_definitions() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiShape_definitions::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiShape_definition::get_os_typespec() )
		    SdaiShape_definition );
}
#endif


	//  part 2
SdaiShape_definition::operator SdaiProduct_definition_shape_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_shape )
      return ((SdaiProduct_definition_shape_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiShape_definition::operator SdaiShape_aspect_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
      return ((SdaiShape_aspect_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiShape_definition::operator SdaiShape_aspect_relationship_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
      return ((SdaiShape_aspect_relationship_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiShape_aspect_ptr
SdaiShape_definition::related_shape_aspect_() const
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	//  SHAPE_ASPECT_RELATIONSHIP
	return ((SdaiShape_aspect_relationship_ptr) _app_inst) ->related_shape_aspect_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiShape_definition::related_shape_aspect_ (const SdaiShape_aspect_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	//  SHAPE_ASPECT_RELATIONSHIP
	{  ((SdaiShape_aspect_relationship_ptr) _app_inst) ->related_shape_aspect_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiShape_aspect_ptr
SdaiShape_definition::relating_shape_aspect_() const
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	//  SHAPE_ASPECT_RELATIONSHIP
	return ((SdaiShape_aspect_relationship_ptr) _app_inst) ->relating_shape_aspect_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiShape_definition::relating_shape_aspect_ (const SdaiShape_aspect_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	//  SHAPE_ASPECT_RELATIONSHIP
	{  ((SdaiShape_aspect_relationship_ptr) _app_inst) ->relating_shape_aspect_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SCLLOG(Logical)
SdaiShape_definition::product_definitional_() const
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	return ((SdaiShape_aspect_ptr) _app_inst) ->product_definitional_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return (SCLLOG(Logical)) 0;
}


void
SdaiShape_definition::product_definitional_ (const SCLLOG(Logical) x)

{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspect_ptr) _app_inst) ->product_definitional_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_shape_ptr
SdaiShape_definition::of_shape_() const
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	return ((SdaiShape_aspect_ptr) _app_inst) ->of_shape_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiShape_definition::of_shape_ (const SdaiProduct_definition_shape_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspect_ptr) _app_inst) ->of_shape_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiCharacterized_definition_ptr
SdaiShape_definition::definition_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape )
	//  PRODUCT_DEFINITION_SHAPE
	return ((SdaiProduct_definition_shape_ptr) _app_inst) ->definition_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiShape_definition::definition_ (const SdaiCharacterized_definition_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape )
	//  PRODUCT_DEFINITION_SHAPE
	{  ((SdaiProduct_definition_shape_ptr) _app_inst) ->definition_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiShape_definition::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape )
	//  PRODUCT_DEFINITION_SHAPE
	return ((SdaiProduct_definition_shape_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	return ((SdaiShape_aspect_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	//  SHAPE_ASPECT_RELATIONSHIP
	return ((SdaiShape_aspect_relationship_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiShape_definition::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape )
	//  PRODUCT_DEFINITION_SHAPE
	{  ((SdaiProduct_definition_shape_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspect_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	//  SHAPE_ASPECT_RELATIONSHIP
	{  ((SdaiShape_aspect_relationship_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiShape_definition::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape )
	//  PRODUCT_DEFINITION_SHAPE
	return ((SdaiProduct_definition_shape_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	return ((SdaiShape_aspect_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	//  SHAPE_ASPECT_RELATIONSHIP
	return ((SdaiShape_aspect_relationship_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiShape_definition::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape )
	//  PRODUCT_DEFINITION_SHAPE
	{  ((SdaiProduct_definition_shape_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspect_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	//  SHAPE_ASPECT_RELATIONSHIP
	{  ((SdaiShape_aspect_relationship_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiShape_definition& SdaiShape_definition::operator =( const SdaiProduct_definition_shape_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition_shape);
   return *this;
}

SdaiShape_definition& SdaiShape_definition::operator =( const SdaiShape_aspect_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_shape_aspect);
   return *this;
}

SdaiShape_definition& SdaiShape_definition::operator =( const SdaiShape_aspect_relationship_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_shape_aspect_relationship);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiShape_definition& SdaiShape_definition::operator =( const SdaiShape_definition_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition_shape )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_shape_aspect )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiShape_definition::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_product_definition_shape )
	_app_inst = ((SdaiShape_definition&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_shape_aspect )
	_app_inst = ((SdaiShape_definition&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	_app_inst = ((SdaiShape_definition&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiShape_definition::IsProduct_definition_shape() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition_shape )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiShape_definition::IsShape_aspect() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiShape_definition::IsShape_aspect_relationship() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiShape_definition


//////////  SELECT TYPE characterized_definition

const TypeDescriptor *
SdaiCharacterized_definition::AssignEntity (SCLP23(Application_instance) * se)
{
  //  CHARACTERIZED_PRODUCT_DEFINITION
  if (config_control_designt_characterized_product_definition -> CanBe (se -> eDesc))
  {
	_sdaicharacterized_product_definition.AssignEntity (se);
	return SetUnderlyingType (config_control_designt_characterized_product_definition);
  }
  //  SHAPE_DEFINITION
  if (config_control_designt_shape_definition -> CanBe (se -> eDesc))
  {
	_sdaishape_definition.AssignEntity (se);
	return SetUnderlyingType (config_control_designt_shape_definition);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiCharacterized_definition::NewSelect ()
{
#ifdef __OSTORE__
    SdaiCharacterized_definition * tmp =
		new( os_segment::of(this),
		     SdaiCharacterized_definition::get_os_typespec() )
			SdaiCharacterized_definition();
#else
    SdaiCharacterized_definition * tmp = new SdaiCharacterized_definition();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiCharacterized_definition::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designt_characterized_product_definition)
	_sdaicharacterized_product_definition.STEPwrite (out, currSch);
  else if (CurrentUnderlyingType () == config_control_designt_shape_definition)
	_sdaishape_definition.STEPwrite (out, currSch);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiCharacterized_definition::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designt_characterized_product_definition)
    return _sdaicharacterized_product_definition.ValueType();
  else if (CurrentUnderlyingType() == config_control_designt_shape_definition)
    return _sdaishape_definition.ValueType();
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiCharacterized_definition::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designt_characterized_product_definition)
  {
    out << tmp.chars() << "(";
    _sdaicharacterized_product_definition.STEPwrite_verbose (out, currSch);
    out << ")";
  }
  else if (td == config_control_designt_shape_definition)
  {
    out << tmp.chars() << "(";
    _sdaishape_definition.STEPwrite_verbose (out, currSch);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiCharacterized_definition::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designt_characterized_product_definition)   {
	_sdaicharacterized_product_definition.STEPread (in, &_error, instances, utype, addFileId, currSch);
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_shape_definition)   {
	_sdaishape_definition.STEPread (in, &_error, instances, utype, addFileId, currSch);
	return severity ();
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiCharacterized_definition::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiCharacterized_definition (os_database *db)
{
    return new (db, SdaiCharacterized_definition::get_os_typespec())
		SdaiCharacterized_definition ;
}

void
SdaiCharacterized_definition_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiCharacterized_definition access hook funct called." << endl;
    }
#endif
    SdaiCharacterized_definition *s = (SdaiCharacterized_definition *) object;
    s->_type = config_control_designt_characterized_definition;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiCharacterized_definitions (os_database *db)
{
    return new (db, SdaiCharacterized_definitions::get_os_typespec())
		SdaiCharacterized_definitions ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiCharacterized_definition::SdaiCharacterized_definition( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript),
    _sdaicharacterized_product_definition (config_control_designt_characterized_product_definition),
    _sdaishape_definition (config_control_designt_shape_definition)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCharacterized_definition constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCharacterized_definition constructor." << endl;
    }
#endif
}

	//  part 1
SdaiCharacterized_definition::SdaiCharacterized_definition( const SdaiCharacterized_product_definition_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designt_characterized_product_definition),
    _sdaicharacterized_product_definition (config_control_designt_characterized_product_definition),
    _sdaishape_definition (config_control_designt_shape_definition)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCharacterized_definition constructor." << endl;
    }
#endif
   _sdaicharacterized_product_definition = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCharacterized_definition constructor." << endl;
    }
#endif
}

SdaiCharacterized_definition::SdaiCharacterized_definition( const SdaiShape_definition_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designt_shape_definition),
    _sdaicharacterized_product_definition (config_control_designt_characterized_product_definition),
    _sdaishape_definition (config_control_designt_shape_definition)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCharacterized_definition constructor." << endl;
    }
#endif
   _sdaishape_definition = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCharacterized_definition constructor." << endl;
    }
#endif
}

SdaiCharacterized_definition::~SdaiCharacterized_definition()
{
}

SdaiCharacterized_definitions::SdaiCharacterized_definitions( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiCharacterized_definitions::~SdaiCharacterized_definitions() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiCharacterized_definitions::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiCharacterized_definition::get_os_typespec() )
		    SdaiCharacterized_definition );
}
#endif


	//  part 2
SdaiCharacterized_definition::operator SdaiCharacterized_product_definition_ptr()
{
   if( CurrentUnderlyingType () == config_control_designt_characterized_product_definition )
      return & _sdaicharacterized_product_definition;

   severity( SEVERITY_WARNING );
   Error( "Underlying type is not SdaiCharacterized_product_definition_ptr" );

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return 0;
}

SdaiCharacterized_definition::operator SdaiShape_definition_ptr()
{
   if( CurrentUnderlyingType () == config_control_designt_shape_definition )
      return & _sdaishape_definition;

   severity( SEVERITY_WARNING );
   Error( "Underlying type is not SdaiShape_definition_ptr" );

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return 0;
}


	//  part 3

	//  part 4
SdaiCharacterized_definition& SdaiCharacterized_definition::operator =( const SdaiCharacterized_product_definition_ptr& o )
{
   nullify ();
   _sdaicharacterized_product_definition = o;
   SetUnderlyingType (config_control_designt_characterized_product_definition);
   return *this;
}

SdaiCharacterized_definition& SdaiCharacterized_definition::operator =( const SdaiShape_definition_ptr& o )
{
   nullify ();
   _sdaishape_definition = o;
   SetUnderlyingType (config_control_designt_shape_definition);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiCharacterized_definition& SdaiCharacterized_definition::operator =( const SdaiCharacterized_definition_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designt_characterized_product_definition )
	_sdaicharacterized_product_definition =  &(o -> _sdaicharacterized_product_definition);
   else if ( o -> CurrentUnderlyingType () == config_control_designt_shape_definition )
	_sdaishape_definition =  &(o -> _sdaishape_definition);
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiCharacterized_definition::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designt_characterized_product_definition )
	_sdaicharacterized_product_definition = &(((SdaiCharacterized_definition&) o)._sdaicharacterized_product_definition);
   else if ( o.CurrentUnderlyingType () == config_control_designt_shape_definition )
	_sdaishape_definition = &(((SdaiCharacterized_definition&) o)._sdaishape_definition);
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiCharacterized_definition::IsCharacterized_product_definition() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_characterized_product_definition )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiCharacterized_definition::IsShape_definition() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_shape_definition )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiCharacterized_definition


//////////  SELECT TYPE change_request_item

const TypeDescriptor *
SdaiChange_request_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> IsA (config_control_designe_product_definition_formation))
  {
	_app_inst = (SdaiProduct_definition_formation_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiChange_request_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiChange_request_item * tmp =
		new( os_segment::of(this),
		     SdaiChange_request_item::get_os_typespec() )
			SdaiChange_request_item();
#else
    SdaiChange_request_item * tmp = new SdaiChange_request_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiChange_request_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiChange_request_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_product_definition_formation)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiChange_request_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_product_definition_formation)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiChange_request_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiChange_request_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiChange_request_item (os_database *db)
{
    return new (db, SdaiChange_request_item::get_os_typespec())
		SdaiChange_request_item ;
}

void
SdaiChange_request_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiChange_request_item access hook funct called." << endl;
    }
#endif
    SdaiChange_request_item *s = (SdaiChange_request_item *) object;
    s->_type = config_control_designt_change_request_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiChange_request_items (os_database *db)
{
    return new (db, SdaiChange_request_items::get_os_typespec())
		SdaiChange_request_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiChange_request_item::SdaiChange_request_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiChange_request_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiChange_request_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiChange_request_item::SdaiChange_request_item( const SdaiProduct_definition_formation_ptr& o,
                                                  const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition_formation)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiChange_request_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiChange_request_item constructor." << endl;
    }
#endif
}

SdaiChange_request_item::~SdaiChange_request_item()
{
}

SdaiChange_request_items::SdaiChange_request_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiChange_request_items::~SdaiChange_request_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiChange_request_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiChange_request_item::get_os_typespec() )
		    SdaiChange_request_item );
}
#endif


	//  part 2
SdaiChange_request_item::operator SdaiProduct_definition_formation_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formation_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiProduct_ptr
SdaiChange_request_item::of_product_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiChange_request_item::of_product_ (const SdaiProduct_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiChange_request_item::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiChange_request_item::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiChange_request_item::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiChange_request_item::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiChange_request_item& SdaiChange_request_item::operator =( const SdaiProduct_definition_formation_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiChange_request_item& SdaiChange_request_item::operator =( const SdaiChange_request_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiChange_request_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst = ((SdaiChange_request_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiChange_request_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiChange_request_item


//////////  SELECT TYPE reversible_topology_item

const TypeDescriptor *
SdaiReversible_topology_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  EDGE
  if (se -> IsA (config_control_designe_edge))
  {
	_app_inst = (SdaiEdge_ptr) se;
	return SetUnderlyingType (config_control_designe_edge);
  }
  //  PATH
  if (se -> IsA (config_control_designe_path))
  {
	_app_inst = (SdaiPath_ptr) se;
	return SetUnderlyingType (config_control_designe_path);
  }
  //  FACE
  if (se -> IsA (config_control_designe_face))
  {
	_app_inst = (SdaiFace_ptr) se;
	return SetUnderlyingType (config_control_designe_face);
  }
  //  FACE_BOUND
  if (se -> IsA (config_control_designe_face_bound))
  {
	_app_inst = (SdaiFace_bound_ptr) se;
	return SetUnderlyingType (config_control_designe_face_bound);
  }
  //  CLOSED_SHELL
  if (se -> IsA (config_control_designe_closed_shell))
  {
	_app_inst = (SdaiClosed_shell_ptr) se;
	return SetUnderlyingType (config_control_designe_closed_shell);
  }
  //  OPEN_SHELL
  if (se -> IsA (config_control_designe_open_shell))
  {
	_app_inst = (SdaiOpen_shell_ptr) se;
	return SetUnderlyingType (config_control_designe_open_shell);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiReversible_topology_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiReversible_topology_item * tmp =
		new( os_segment::of(this),
		     SdaiReversible_topology_item::get_os_typespec() )
			SdaiReversible_topology_item();
#else
    SdaiReversible_topology_item * tmp = new SdaiReversible_topology_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiReversible_topology_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_edge)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_path)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_face)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_face_bound)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_closed_shell)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_open_shell)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiReversible_topology_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_edge)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_path)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_face)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_face_bound)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_closed_shell)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_open_shell)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiReversible_topology_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_edge)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_path)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_face)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_face_bound)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_closed_shell)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_open_shell)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiReversible_topology_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_edge)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_path)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_face)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_face_bound)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_closed_shell)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_open_shell)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiReversible_topology_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiReversible_topology_item (os_database *db)
{
    return new (db, SdaiReversible_topology_item::get_os_typespec())
		SdaiReversible_topology_item ;
}

void
SdaiReversible_topology_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiReversible_topology_item access hook funct called." << endl;
    }
#endif
    SdaiReversible_topology_item *s = (SdaiReversible_topology_item *) object;
    s->_type = config_control_designt_reversible_topology_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiReversible_topology_items (os_database *db)
{
    return new (db, SdaiReversible_topology_items::get_os_typespec())
		SdaiReversible_topology_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiReversible_topology_item::SdaiReversible_topology_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiEdge_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_edge)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << endl;
    }
#endif
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiPath_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_path)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << endl;
    }
#endif
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiFace_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_face)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << endl;
    }
#endif
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiFace_bound_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_face_bound)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << endl;
    }
#endif
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiClosed_shell_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_closed_shell)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << endl;
    }
#endif
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiOpen_shell_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_open_shell)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiReversible_topology_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiReversible_topology_item constructor." << endl;
    }
#endif
}

SdaiReversible_topology_item::~SdaiReversible_topology_item()
{
}

SdaiReversible_topology_items::SdaiReversible_topology_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiReversible_topology_items::~SdaiReversible_topology_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiReversible_topology_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiReversible_topology_item::get_os_typespec() )
		    SdaiReversible_topology_item );
}
#endif


	//  part 2
SdaiReversible_topology_item::operator SdaiEdge_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_edge )
      return ((SdaiEdge_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiPath_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_path )
      return ((SdaiPath_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiFace_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_face )
      return ((SdaiFace_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiFace_bound_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_face_bound )
      return ((SdaiFace_bound_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiClosed_shell_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_closed_shell )
      return ((SdaiClosed_shell_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiOpen_shell_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_open_shell )
      return ((SdaiOpen_shell_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const EntityAggregate_ptr
SdaiReversible_topology_item::cfs_faces_() const
{
  if( CurrentUnderlyingType () == config_control_designe_closed_shell )
	//  CLOSED_SHELL
	return ((SdaiClosed_shell_ptr) _app_inst) ->cfs_faces_();
  if( CurrentUnderlyingType () == config_control_designe_open_shell )
	//  OPEN_SHELL
	return ((SdaiOpen_shell_ptr) _app_inst) ->cfs_faces_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiReversible_topology_item::cfs_faces_ (const EntityAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_closed_shell )
	//  CLOSED_SHELL
	{  ((SdaiClosed_shell_ptr) _app_inst) ->cfs_faces_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_open_shell )
	//  OPEN_SHELL
	{  ((SdaiOpen_shell_ptr) _app_inst) ->cfs_faces_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SCLBOOL(Bool)
SdaiReversible_topology_item::orientation_() const
{
  if( CurrentUnderlyingType () == config_control_designe_face_bound )
	//  FACE_BOUND
	return ((SdaiFace_bound_ptr) _app_inst) ->orientation_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return (SCLBOOL(Bool)) 0;
}


void
SdaiReversible_topology_item::orientation_ (const SCLBOOL(Bool) x)

{
  if( CurrentUnderlyingType () == config_control_designe_face_bound )
	//  FACE_BOUND
	{  ((SdaiFace_bound_ptr) _app_inst) ->orientation_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLoop_ptr
SdaiReversible_topology_item::bound_() const
{
  if( CurrentUnderlyingType () == config_control_designe_face_bound )
	//  FACE_BOUND
	return ((SdaiFace_bound_ptr) _app_inst) ->bound_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiReversible_topology_item::bound_ (const SdaiLoop_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_face_bound )
	//  FACE_BOUND
	{  ((SdaiFace_bound_ptr) _app_inst) ->bound_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const EntityAggregate_ptr
SdaiReversible_topology_item::bounds_() const
{
  if( CurrentUnderlyingType () == config_control_designe_face )
	//  FACE
	return ((SdaiFace_ptr) _app_inst) ->bounds_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiReversible_topology_item::bounds_ (const EntityAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_face )
	//  FACE
	{  ((SdaiFace_ptr) _app_inst) ->bounds_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const EntityAggregate_ptr
SdaiReversible_topology_item::edge_list_() const
{
  if( CurrentUnderlyingType () == config_control_designe_path )
	//  PATH
	return ((SdaiPath_ptr) _app_inst) ->edge_list_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiReversible_topology_item::edge_list_ (const EntityAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_path )
	//  PATH
	{  ((SdaiPath_ptr) _app_inst) ->edge_list_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiVertex_ptr
SdaiReversible_topology_item::edge_end_() const
{
  if( CurrentUnderlyingType () == config_control_designe_edge )
	//  EDGE
	return ((SdaiEdge_ptr) _app_inst) ->edge_end_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiReversible_topology_item::edge_end_ (const SdaiVertex_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_edge )
	//  EDGE
	{  ((SdaiEdge_ptr) _app_inst) ->edge_end_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiVertex_ptr
SdaiReversible_topology_item::edge_start_() const
{
  if( CurrentUnderlyingType () == config_control_designe_edge )
	//  EDGE
	return ((SdaiEdge_ptr) _app_inst) ->edge_start_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiReversible_topology_item::edge_start_ (const SdaiVertex_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_edge )
	//  EDGE
	{  ((SdaiEdge_ptr) _app_inst) ->edge_start_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiReversible_topology_item::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_edge )
	//  EDGE
	return ((SdaiEdge_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_path )
	//  PATH
	return ((SdaiPath_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_face )
	//  FACE
	return ((SdaiFace_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_face_bound )
	//  FACE_BOUND
	return ((SdaiFace_bound_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_closed_shell )
	//  CLOSED_SHELL
	return ((SdaiClosed_shell_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_open_shell )
	//  OPEN_SHELL
	return ((SdaiOpen_shell_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiReversible_topology_item::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_edge )
	//  EDGE
	{  ((SdaiEdge_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_path )
	//  PATH
	{  ((SdaiPath_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_face )
	//  FACE
	{  ((SdaiFace_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_face_bound )
	//  FACE_BOUND
	{  ((SdaiFace_bound_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_closed_shell )
	//  CLOSED_SHELL
	{  ((SdaiClosed_shell_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_open_shell )
	//  OPEN_SHELL
	{  ((SdaiOpen_shell_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiEdge_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_edge);
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiPath_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_path);
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiFace_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_face);
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiFace_bound_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_face_bound);
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiClosed_shell_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_closed_shell);
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiOpen_shell_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_open_shell);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiReversible_topology_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_edge )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_path )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_face )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_face_bound )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_closed_shell )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_open_shell )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiReversible_topology_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_edge )
	_app_inst = ((SdaiReversible_topology_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_path )
	_app_inst = ((SdaiReversible_topology_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_face )
	_app_inst = ((SdaiReversible_topology_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_face_bound )
	_app_inst = ((SdaiReversible_topology_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_closed_shell )
	_app_inst = ((SdaiReversible_topology_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_open_shell )
	_app_inst = ((SdaiReversible_topology_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiReversible_topology_item::IsEdge() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_edge )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiReversible_topology_item::IsPath() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_path )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiReversible_topology_item::IsFace() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_face )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiReversible_topology_item::IsFace_bound() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_face_bound )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiReversible_topology_item::IsClosed_shell() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_closed_shell )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiReversible_topology_item::IsOpen_shell() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_open_shell )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiReversible_topology_item


//////////  SELECT TYPE axis2_placement

const TypeDescriptor *
SdaiAxis2_placement::AssignEntity (SCLP23(Application_instance) * se)
{
  //  AXIS2_PLACEMENT_2D
  if (se -> IsA (config_control_designe_axis2_placement_2d))
  {
	_app_inst = (SdaiAxis2_placement_2d_ptr) se;
	return SetUnderlyingType (config_control_designe_axis2_placement_2d);
  }
  //  AXIS2_PLACEMENT_3D
  if (se -> IsA (config_control_designe_axis2_placement_3d))
  {
	_app_inst = (SdaiAxis2_placement_3d_ptr) se;
	return SetUnderlyingType (config_control_designe_axis2_placement_3d);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiAxis2_placement::NewSelect ()
{
#ifdef __OSTORE__
    SdaiAxis2_placement * tmp =
		new( os_segment::of(this),
		     SdaiAxis2_placement::get_os_typespec() )
			SdaiAxis2_placement();
#else
    SdaiAxis2_placement * tmp = new SdaiAxis2_placement();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiAxis2_placement::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_axis2_placement_2d)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_axis2_placement_3d)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiAxis2_placement::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_axis2_placement_2d)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_axis2_placement_3d)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiAxis2_placement::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_axis2_placement_2d)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_axis2_placement_3d)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiAxis2_placement::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_axis2_placement_2d)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_axis2_placement_3d)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiAxis2_placement::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiAxis2_placement (os_database *db)
{
    return new (db, SdaiAxis2_placement::get_os_typespec())
		SdaiAxis2_placement ;
}

void
SdaiAxis2_placement_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiAxis2_placement access hook funct called." << endl;
    }
#endif
    SdaiAxis2_placement *s = (SdaiAxis2_placement *) object;
    s->_type = config_control_designt_axis2_placement;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiAxis2_placements (os_database *db)
{
    return new (db, SdaiAxis2_placements::get_os_typespec())
		SdaiAxis2_placements ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiAxis2_placement::SdaiAxis2_placement( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiAxis2_placement constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiAxis2_placement constructor." << endl;
    }
#endif
}

	//  part 1
SdaiAxis2_placement::SdaiAxis2_placement( const SdaiAxis2_placement_2d_ptr& o,
                                          const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_axis2_placement_2d)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiAxis2_placement constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiAxis2_placement constructor." << endl;
    }
#endif
}

SdaiAxis2_placement::SdaiAxis2_placement( const SdaiAxis2_placement_3d_ptr& o,
                                          const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_axis2_placement_3d)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiAxis2_placement constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiAxis2_placement constructor." << endl;
    }
#endif
}

SdaiAxis2_placement::~SdaiAxis2_placement()
{
}

SdaiAxis2_placements::SdaiAxis2_placements( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiAxis2_placements::~SdaiAxis2_placements() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiAxis2_placements::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiAxis2_placement::get_os_typespec() )
		    SdaiAxis2_placement );
}
#endif


	//  part 2
SdaiAxis2_placement::operator SdaiAxis2_placement_2d_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
      return ((SdaiAxis2_placement_2d_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiAxis2_placement::operator SdaiAxis2_placement_3d_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
      return ((SdaiAxis2_placement_3d_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiDirection_ptr
SdaiAxis2_placement::axis_() const
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	//  AXIS2_PLACEMENT_3D
	return ((SdaiAxis2_placement_3d_ptr) _app_inst) ->axis_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiAxis2_placement::axis_ (const SdaiDirection_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	//  AXIS2_PLACEMENT_3D
	{  ((SdaiAxis2_placement_3d_ptr) _app_inst) ->axis_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiDirection_ptr
SdaiAxis2_placement::ref_direction_() const
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
	//  AXIS2_PLACEMENT_2D
	return ((SdaiAxis2_placement_2d_ptr) _app_inst) ->ref_direction_();
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	//  AXIS2_PLACEMENT_3D
	return ((SdaiAxis2_placement_3d_ptr) _app_inst) ->ref_direction_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiAxis2_placement::ref_direction_ (const SdaiDirection_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
	//  AXIS2_PLACEMENT_2D
	{  ((SdaiAxis2_placement_2d_ptr) _app_inst) ->ref_direction_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	//  AXIS2_PLACEMENT_3D
	{  ((SdaiAxis2_placement_3d_ptr) _app_inst) ->ref_direction_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiCartesian_point_ptr
SdaiAxis2_placement::location_() const
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
	//  AXIS2_PLACEMENT_2D
	return ((SdaiAxis2_placement_2d_ptr) _app_inst) ->location_();
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	//  AXIS2_PLACEMENT_3D
	return ((SdaiAxis2_placement_3d_ptr) _app_inst) ->location_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiAxis2_placement::location_ (const SdaiCartesian_point_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
	//  AXIS2_PLACEMENT_2D
	{  ((SdaiAxis2_placement_2d_ptr) _app_inst) ->location_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	//  AXIS2_PLACEMENT_3D
	{  ((SdaiAxis2_placement_3d_ptr) _app_inst) ->location_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiAxis2_placement::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
	//  AXIS2_PLACEMENT_2D
	return ((SdaiAxis2_placement_2d_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	//  AXIS2_PLACEMENT_3D
	return ((SdaiAxis2_placement_3d_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiAxis2_placement::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
	//  AXIS2_PLACEMENT_2D
	{  ((SdaiAxis2_placement_2d_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	//  AXIS2_PLACEMENT_3D
	{  ((SdaiAxis2_placement_3d_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiAxis2_placement& SdaiAxis2_placement::operator =( const SdaiAxis2_placement_2d_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_axis2_placement_2d);
   return *this;
}

SdaiAxis2_placement& SdaiAxis2_placement::operator =( const SdaiAxis2_placement_3d_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_axis2_placement_3d);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiAxis2_placement& SdaiAxis2_placement::operator =( const SdaiAxis2_placement_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiAxis2_placement::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
	_app_inst = ((SdaiAxis2_placement&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	_app_inst = ((SdaiAxis2_placement&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiAxis2_placement::IsAxis2_placement_2d() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiAxis2_placement::IsAxis2_placement_3d() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiAxis2_placement


//////////  SELECT TYPE specified_item

const TypeDescriptor *
SdaiSpecified_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PRODUCT_DEFINITION
  if (se -> IsA (config_control_designe_product_definition))
  {
	_app_inst = (SdaiProduct_definition_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition);
  }
  //  SHAPE_ASPECT
  if (se -> IsA (config_control_designe_shape_aspect))
  {
	_app_inst = (SdaiShape_aspect_ptr) se;
	return SetUnderlyingType (config_control_designe_shape_aspect);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiSpecified_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiSpecified_item * tmp =
		new( os_segment::of(this),
		     SdaiSpecified_item::get_os_typespec() )
			SdaiSpecified_item();
#else
    SdaiSpecified_item * tmp = new SdaiSpecified_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiSpecified_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_shape_aspect)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiSpecified_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_product_definition)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_shape_aspect)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiSpecified_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_product_definition)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_shape_aspect)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiSpecified_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_shape_aspect)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiSpecified_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiSpecified_item (os_database *db)
{
    return new (db, SdaiSpecified_item::get_os_typespec())
		SdaiSpecified_item ;
}

void
SdaiSpecified_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiSpecified_item access hook funct called." << endl;
    }
#endif
    SdaiSpecified_item *s = (SdaiSpecified_item *) object;
    s->_type = config_control_designt_specified_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiSpecified_items (os_database *db)
{
    return new (db, SdaiSpecified_items::get_os_typespec())
		SdaiSpecified_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiSpecified_item::SdaiSpecified_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiSpecified_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiSpecified_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiSpecified_item::SdaiSpecified_item( const SdaiProduct_definition_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiSpecified_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiSpecified_item constructor." << endl;
    }
#endif
}

SdaiSpecified_item::SdaiSpecified_item( const SdaiShape_aspect_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_shape_aspect)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiSpecified_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiSpecified_item constructor." << endl;
    }
#endif
}

SdaiSpecified_item::~SdaiSpecified_item()
{
}

SdaiSpecified_items::SdaiSpecified_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiSpecified_items::~SdaiSpecified_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiSpecified_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiSpecified_item::get_os_typespec() )
		    SdaiSpecified_item );
}
#endif


	//  part 2
SdaiSpecified_item::operator SdaiProduct_definition_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return ((SdaiProduct_definition_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiSpecified_item::operator SdaiShape_aspect_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
      return ((SdaiShape_aspect_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SCLLOG(Logical)
SdaiSpecified_item::product_definitional_() const
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	return ((SdaiShape_aspect_ptr) _app_inst) ->product_definitional_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return (SCLLOG(Logical)) 0;
}


void
SdaiSpecified_item::product_definitional_ (const SCLLOG(Logical) x)

{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspect_ptr) _app_inst) ->product_definitional_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_shape_ptr
SdaiSpecified_item::of_shape_() const
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	return ((SdaiShape_aspect_ptr) _app_inst) ->of_shape_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSpecified_item::of_shape_ (const SdaiProduct_definition_shape_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspect_ptr) _app_inst) ->of_shape_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiSpecified_item::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	return ((SdaiShape_aspect_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSpecified_item::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspect_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_context_ptr
SdaiSpecified_item::frame_of_reference_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->frame_of_reference_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSpecified_item::frame_of_reference_ (const SdaiProduct_definition_context_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->frame_of_reference_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_formation_ptr
SdaiSpecified_item::formation_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->formation_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSpecified_item::formation_ (const SdaiProduct_definition_formation_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->formation_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiSpecified_item::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	return ((SdaiShape_aspect_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSpecified_item::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspect_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiSpecified_item::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSpecified_item::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiSpecified_item& SdaiSpecified_item::operator =( const SdaiProduct_definition_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition);
   return *this;
}

SdaiSpecified_item& SdaiSpecified_item::operator =( const SdaiShape_aspect_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_shape_aspect);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiSpecified_item& SdaiSpecified_item::operator =( const SdaiSpecified_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_shape_aspect )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiSpecified_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_product_definition )
	_app_inst = ((SdaiSpecified_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_shape_aspect )
	_app_inst = ((SdaiSpecified_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiSpecified_item::IsProduct_definition() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiSpecified_item::IsShape_aspect() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiSpecified_item


//////////  SELECT TYPE measure_value

const TypeDescriptor *
SdaiMeasure_value::AssignEntity (SCLP23(Application_instance) * se)
{
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiMeasure_value::NewSelect ()
{
#ifdef __OSTORE__
    SdaiMeasure_value * tmp =
		new( os_segment::of(this),
		     SdaiMeasure_value::get_os_typespec() )
			SdaiMeasure_value();
#else
    SdaiMeasure_value * tmp = new SdaiMeasure_value();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiMeasure_value::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designt_length_measure)
	WriteReal(_real,out);
  else if (CurrentUnderlyingType () == config_control_designt_mass_measure)
	WriteReal(_real,out);
  else if (CurrentUnderlyingType () == config_control_designt_plane_angle_measure)
	WriteReal(_real,out);
  else if (CurrentUnderlyingType () == config_control_designt_solid_angle_measure)
	WriteReal(_real,out);
  else if (CurrentUnderlyingType () == config_control_designt_area_measure)
	WriteReal(_real,out);
  else if (CurrentUnderlyingType () == config_control_designt_volume_measure)
	WriteReal(_real,out);
  else if (CurrentUnderlyingType () == config_control_designt_parameter_value)
	WriteReal(_real,out);
  else if (CurrentUnderlyingType () == config_control_designt_context_dependent_measure)
	WriteReal(_real,out);
  else if (CurrentUnderlyingType () == config_control_designt_descriptive_measure)
	_string.STEPwrite (out);
  else if (CurrentUnderlyingType () == config_control_designt_positive_length_measure)
	WriteReal(_real,out);
  else if (CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure)
	WriteReal(_real,out);
  else if (CurrentUnderlyingType () == config_control_designt_count_measure)
	WriteReal(_real,out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiMeasure_value::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designt_length_measure)
    return sdaiREAL;
  else if (CurrentUnderlyingType() == config_control_designt_mass_measure)
    return sdaiREAL;
  else if (CurrentUnderlyingType() == config_control_designt_plane_angle_measure)
    return sdaiREAL;
  else if (CurrentUnderlyingType() == config_control_designt_solid_angle_measure)
    return sdaiREAL;
  else if (CurrentUnderlyingType() == config_control_designt_area_measure)
    return sdaiREAL;
  else if (CurrentUnderlyingType() == config_control_designt_volume_measure)
    return sdaiREAL;
  else if (CurrentUnderlyingType() == config_control_designt_parameter_value)
    return sdaiREAL;
  else if (CurrentUnderlyingType() == config_control_designt_context_dependent_measure)
    return sdaiREAL;
  else if (CurrentUnderlyingType() == config_control_designt_descriptive_measure)
    return sdaiSTRING;
  else if (CurrentUnderlyingType() == config_control_designt_positive_length_measure)
    return sdaiREAL;
  else if (CurrentUnderlyingType() == config_control_designt_positive_plane_angle_measure)
    return sdaiREAL;
  else if (CurrentUnderlyingType() == config_control_designt_count_measure)
    return sdaiNUMBER;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiMeasure_value::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designt_length_measure)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else if (td == config_control_designt_mass_measure)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else if (td == config_control_designt_plane_angle_measure)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else if (td == config_control_designt_solid_angle_measure)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else if (td == config_control_designt_area_measure)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else if (td == config_control_designt_volume_measure)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else if (td == config_control_designt_parameter_value)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else if (td == config_control_designt_context_dependent_measure)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else if (td == config_control_designt_descriptive_measure)
  {
    out << tmp.chars() << "(";
    _string.STEPwrite (out);
    out << ")";
  }
  else if (td == config_control_designt_positive_length_measure)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else if (td == config_control_designt_positive_plane_angle_measure)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else if (td == config_control_designt_count_measure)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiMeasure_value::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designt_length_measure)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_mass_measure)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_plane_angle_measure)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_solid_angle_measure)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_area_measure)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_volume_measure)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_parameter_value)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_context_dependent_measure)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_descriptive_measure)   {
	_string.STEPread (in, &_error);
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_positive_length_measure)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_count_measure)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiMeasure_value::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  case sdaiSTRING :
	return _string.StrToVal (str);
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiMeasure_value (os_database *db)
{
    return new (db, SdaiMeasure_value::get_os_typespec())
		SdaiMeasure_value ;
}

void
SdaiMeasure_value_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiMeasure_value access hook funct called." << endl;
    }
#endif
    SdaiMeasure_value *s = (SdaiMeasure_value *) object;
    s->_type = config_control_designt_measure_value;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiMeasure_values (os_database *db)
{
    return new (db, SdaiMeasure_values::get_os_typespec())
		SdaiMeasure_values ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiMeasure_value::SdaiMeasure_value( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiMeasure_value constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiMeasure_value constructor." << endl;
    }
#endif
}

	//  part 1
SdaiMeasure_value::SdaiMeasure_value( const SdaiDescriptive_measure& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designt_descriptive_measure)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiMeasure_value constructor." << endl;
    }
#endif
   _string = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiMeasure_value constructor." << endl;
    }
#endif
}

SdaiMeasure_value::SdaiMeasure_value( const SCLP23(Real)& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) ( typedescript, config_control_designt_mass_measure )
{
   _real = o;
//  NOTE:  Underlying type defaults to config_control_designt_mass_measure instead of NULL
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiMeasure_value constructor." << endl;
    }
#endif
}

SdaiMeasure_value::~SdaiMeasure_value()
{
}

SdaiMeasure_values::SdaiMeasure_values( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiMeasure_values::~SdaiMeasure_values() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiMeasure_values::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiMeasure_value::get_os_typespec() )
		    SdaiMeasure_value );
}
#endif


	//  part 2
SdaiMeasure_value::operator SdaiDescriptive_measure()
{
   if( CurrentUnderlyingType () == config_control_designt_descriptive_measure )
      return  _string;

   severity( SEVERITY_WARNING );
   Error( "Underlying type is not SdaiDescriptive_measure" );

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return 0;
}

SdaiMeasure_value::operator SCLP23(Real)()
{
   if( CurrentUnderlyingType () == config_control_designt_length_measure )
      return  _real;
   if( CurrentUnderlyingType () == config_control_designt_mass_measure )
      return  _real;
   if( CurrentUnderlyingType () == config_control_designt_plane_angle_measure )
      return  _real;
   if( CurrentUnderlyingType () == config_control_designt_solid_angle_measure )
      return  _real;
   if( CurrentUnderlyingType () == config_control_designt_area_measure )
      return  _real;
   if( CurrentUnderlyingType () == config_control_designt_volume_measure )
      return  _real;
   if( CurrentUnderlyingType () == config_control_designt_parameter_value )
      return  _real;
   if( CurrentUnderlyingType () == config_control_designt_context_dependent_measure )
      return  _real;
   if( CurrentUnderlyingType () == config_control_designt_positive_length_measure )
      return  _real;
   if( CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure )
      return  _real;
   if( CurrentUnderlyingType () == config_control_designt_count_measure )
      return  _real;

   severity( SEVERITY_WARNING );
   Error( "Underlying type is not SCLP23(Real)" );

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return (SCLP23(Real))0;
}


	//  part 3

	//  part 4
SdaiMeasure_value& SdaiMeasure_value::operator =( const SdaiDescriptive_measure& o )
{
   nullify ();
   _string = o;
   SetUnderlyingType (config_control_designt_descriptive_measure);
   return *this;
}

SdaiMeasure_value& SdaiMeasure_value::operator =( const SCLP23(Real)& o )
{
   _real = o;
   underlying_type = 0; // MUST BE SET BY USER
#ifdef __OSTORE__
  underlying_type_name.set_null();
#endif
   //	discriminator = UNSET
   return *this;
}

#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiMeasure_value& SdaiMeasure_value::operator =( const SdaiMeasure_value_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designt_length_measure )
      _real = o -> _real;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_mass_measure )
      _real = o -> _real;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_plane_angle_measure )
      _real = o -> _real;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_solid_angle_measure )
      _real = o -> _real;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_area_measure )
      _real = o -> _real;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_volume_measure )
      _real = o -> _real;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_parameter_value )
      _real = o -> _real;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_context_dependent_measure )
      _real = o -> _real;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_descriptive_measure )
	_string =  o -> _string;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_positive_length_measure )
      _real = o -> _real;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure )
      _real = o -> _real;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_count_measure )
      _real = o -> _real;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiMeasure_value::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designt_length_measure )
	_real = ((SdaiMeasure_value&) o)._real;
   else if ( o.CurrentUnderlyingType () == config_control_designt_mass_measure )
	_real = ((SdaiMeasure_value&) o)._real;
   else if ( o.CurrentUnderlyingType () == config_control_designt_plane_angle_measure )
	_real = ((SdaiMeasure_value&) o)._real;
   else if ( o.CurrentUnderlyingType () == config_control_designt_solid_angle_measure )
	_real = ((SdaiMeasure_value&) o)._real;
   else if ( o.CurrentUnderlyingType () == config_control_designt_area_measure )
	_real = ((SdaiMeasure_value&) o)._real;
   else if ( o.CurrentUnderlyingType () == config_control_designt_volume_measure )
	_real = ((SdaiMeasure_value&) o)._real;
   else if ( o.CurrentUnderlyingType () == config_control_designt_parameter_value )
	_real = ((SdaiMeasure_value&) o)._real;
   else if ( o.CurrentUnderlyingType () == config_control_designt_context_dependent_measure )
	_real = ((SdaiMeasure_value&) o)._real;
   else if ( o.CurrentUnderlyingType () == config_control_designt_descriptive_measure )
	_string = ((SdaiMeasure_value&) o)._string;
   else if ( o.CurrentUnderlyingType () == config_control_designt_positive_length_measure )
	_real = ((SdaiMeasure_value&) o)._real;
   else if ( o.CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure )
	_real = ((SdaiMeasure_value&) o)._real;
   else if ( o.CurrentUnderlyingType () == config_control_designt_count_measure )
	_real = ((SdaiMeasure_value&) o)._real;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiMeasure_value::IsLength_measure() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_length_measure )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiMeasure_value::IsMass_measure() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_mass_measure )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiMeasure_value::IsPlane_angle_measure() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_plane_angle_measure )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiMeasure_value::IsSolid_angle_measure() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_solid_angle_measure )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiMeasure_value::IsArea_measure() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_area_measure )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiMeasure_value::IsVolume_measure() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_volume_measure )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiMeasure_value::IsParameter_value() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_parameter_value )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiMeasure_value::IsContext_dependent_measure() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_context_dependent_measure )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiMeasure_value::IsDescriptive_measure() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_descriptive_measure )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiMeasure_value::IsPositive_length_measure() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_positive_length_measure )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiMeasure_value::IsPositive_plane_angle_measure() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiMeasure_value::IsCount_measure() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_count_measure )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}


	//  part 7
const TypeDescriptor *
SdaiMeasure_value::SetUnderlyingType (const TypeDescriptor * td)
{
  return SCLP23(Select)::SetUnderlyingType (td);
}
//////////  END SELECT TYPE SdaiMeasure_value


//////////  SELECT TYPE person_organization_select

const TypeDescriptor *
SdaiPerson_organization_select::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PERSON
  if (se -> IsA (config_control_designe_person))
  {
	_app_inst = (SdaiPerson_ptr) se;
	return SetUnderlyingType (config_control_designe_person);
  }
  //  ORGANIZATION
  if (se -> IsA (config_control_designe_organization))
  {
	_app_inst = (SdaiOrganization_ptr) se;
	return SetUnderlyingType (config_control_designe_organization);
  }
  //  PERSON_AND_ORGANIZATION
  if (se -> IsA (config_control_designe_person_and_organization))
  {
	_app_inst = (SdaiPerson_and_organization_ptr) se;
	return SetUnderlyingType (config_control_designe_person_and_organization);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiPerson_organization_select::NewSelect ()
{
#ifdef __OSTORE__
    SdaiPerson_organization_select * tmp =
		new( os_segment::of(this),
		     SdaiPerson_organization_select::get_os_typespec() )
			SdaiPerson_organization_select();
#else
    SdaiPerson_organization_select * tmp = new SdaiPerson_organization_select();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiPerson_organization_select::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_person)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_organization)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_person_and_organization)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiPerson_organization_select::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_person)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_organization)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_person_and_organization)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiPerson_organization_select::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_person)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_organization)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_person_and_organization)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiPerson_organization_select::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_person)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_organization)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_person_and_organization)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiPerson_organization_select::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiPerson_organization_select (os_database *db)
{
    return new (db, SdaiPerson_organization_select::get_os_typespec())
		SdaiPerson_organization_select ;
}

void
SdaiPerson_organization_select_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiPerson_organization_select access hook funct called." << endl;
    }
#endif
    SdaiPerson_organization_select *s = (SdaiPerson_organization_select *) object;
    s->_type = config_control_designt_person_organization_select;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiPerson_organization_selects (os_database *db)
{
    return new (db, SdaiPerson_organization_selects::get_os_typespec())
		SdaiPerson_organization_selects ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiPerson_organization_select::SdaiPerson_organization_select( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_select constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_select constructor." << endl;
    }
#endif
}

	//  part 1
SdaiPerson_organization_select::SdaiPerson_organization_select( const SdaiPerson_ptr& o,
                                                                const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_person)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_select constructor." << endl;
    }
#endif
}

SdaiPerson_organization_select::SdaiPerson_organization_select( const SdaiOrganization_ptr& o,
                                                                const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_organization)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_select constructor." << endl;
    }
#endif
}

SdaiPerson_organization_select::SdaiPerson_organization_select( const SdaiPerson_and_organization_ptr& o,
                                                                const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_person_and_organization)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_select constructor." << endl;
    }
#endif
}

SdaiPerson_organization_select::~SdaiPerson_organization_select()
{
}

SdaiPerson_organization_selects::SdaiPerson_organization_selects( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiPerson_organization_selects::~SdaiPerson_organization_selects() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiPerson_organization_selects::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiPerson_organization_select::get_os_typespec() )
		    SdaiPerson_organization_select );
}
#endif


	//  part 2
SdaiPerson_organization_select::operator SdaiPerson_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_person )
      return ((SdaiPerson_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_select::operator SdaiOrganization_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_organization )
      return ((SdaiOrganization_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_select::operator SdaiPerson_and_organization_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_person_and_organization )
      return ((SdaiPerson_and_organization_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiOrganization_ptr
SdaiPerson_organization_select::the_organization_() const
{
  if( CurrentUnderlyingType () == config_control_designe_person_and_organization )
	//  PERSON_AND_ORGANIZATION
	return ((SdaiPerson_and_organization_ptr) _app_inst) ->the_organization_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_select::the_organization_ (const SdaiOrganization_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_person_and_organization )
	//  PERSON_AND_ORGANIZATION
	{  ((SdaiPerson_and_organization_ptr) _app_inst) ->the_organization_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiPerson_ptr
SdaiPerson_organization_select::the_person_() const
{
  if( CurrentUnderlyingType () == config_control_designe_person_and_organization )
	//  PERSON_AND_ORGANIZATION
	return ((SdaiPerson_and_organization_ptr) _app_inst) ->the_person_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_select::the_person_ (const SdaiPerson_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_person_and_organization )
	//  PERSON_AND_ORGANIZATION
	{  ((SdaiPerson_and_organization_ptr) _app_inst) ->the_person_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiPerson_organization_select::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_organization )
	//  ORGANIZATION
	return ((SdaiOrganization_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_select::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_organization )
	//  ORGANIZATION
	{  ((SdaiOrganization_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiPerson_organization_select::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_organization )
	//  ORGANIZATION
	return ((SdaiOrganization_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_select::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_organization )
	//  ORGANIZATION
	{  ((SdaiOrganization_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const StringAggregate_ptr
SdaiPerson_organization_select::suffix_titles_() const
{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	return ((SdaiPerson_ptr) _app_inst) ->suffix_titles_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_select::suffix_titles_ (const StringAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	{  ((SdaiPerson_ptr) _app_inst) ->suffix_titles_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const StringAggregate_ptr
SdaiPerson_organization_select::prefix_titles_() const
{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	return ((SdaiPerson_ptr) _app_inst) ->prefix_titles_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_select::prefix_titles_ (const StringAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	{  ((SdaiPerson_ptr) _app_inst) ->prefix_titles_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const StringAggregate_ptr
SdaiPerson_organization_select::middle_names_() const
{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	return ((SdaiPerson_ptr) _app_inst) ->middle_names_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_select::middle_names_ (const StringAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	{  ((SdaiPerson_ptr) _app_inst) ->middle_names_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiPerson_organization_select::first_name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	return ((SdaiPerson_ptr) _app_inst) ->first_name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_select::first_name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	{  ((SdaiPerson_ptr) _app_inst) ->first_name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiPerson_organization_select::last_name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	return ((SdaiPerson_ptr) _app_inst) ->last_name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_select::last_name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	{  ((SdaiPerson_ptr) _app_inst) ->last_name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiPerson_organization_select::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	return ((SdaiPerson_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_designe_organization )
	//  ORGANIZATION
	return ((SdaiOrganization_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_select::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_person )
	//  PERSON
	{  ((SdaiPerson_ptr) _app_inst) ->id_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_organization )
	//  ORGANIZATION
	{  ((SdaiOrganization_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiPerson_organization_select& SdaiPerson_organization_select::operator =( const SdaiPerson_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_person);
   return *this;
}

SdaiPerson_organization_select& SdaiPerson_organization_select::operator =( const SdaiOrganization_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_organization);
   return *this;
}

SdaiPerson_organization_select& SdaiPerson_organization_select::operator =( const SdaiPerson_and_organization_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_person_and_organization);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiPerson_organization_select& SdaiPerson_organization_select::operator =( const SdaiPerson_organization_select_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_person )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_organization )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_person_and_organization )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiPerson_organization_select::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_person )
	_app_inst = ((SdaiPerson_organization_select&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_organization )
	_app_inst = ((SdaiPerson_organization_select&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_person_and_organization )
	_app_inst = ((SdaiPerson_organization_select&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiPerson_organization_select::IsPerson() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_person )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPerson_organization_select::IsOrganization() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_organization )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPerson_organization_select::IsPerson_and_organization() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_person_and_organization )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiPerson_organization_select


//////////  SELECT TYPE pcurve_or_surface

const TypeDescriptor *
SdaiPcurve_or_surface::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PCURVE
  if (se -> IsA (config_control_designe_pcurve))
  {
	_app_inst = (SdaiPcurve_ptr) se;
	return SetUnderlyingType (config_control_designe_pcurve);
  }
  //  SURFACE
  if (se -> IsA (config_control_designe_surface))
  {
	_app_inst = (SdaiSurface_ptr) se;
	return SetUnderlyingType (config_control_designe_surface);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiPcurve_or_surface::NewSelect ()
{
#ifdef __OSTORE__
    SdaiPcurve_or_surface * tmp =
		new( os_segment::of(this),
		     SdaiPcurve_or_surface::get_os_typespec() )
			SdaiPcurve_or_surface();
#else
    SdaiPcurve_or_surface * tmp = new SdaiPcurve_or_surface();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiPcurve_or_surface::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_pcurve)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_surface)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiPcurve_or_surface::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_pcurve)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_surface)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiPcurve_or_surface::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_pcurve)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_surface)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiPcurve_or_surface::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_pcurve)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_surface)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiPcurve_or_surface::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiPcurve_or_surface (os_database *db)
{
    return new (db, SdaiPcurve_or_surface::get_os_typespec())
		SdaiPcurve_or_surface ;
}

void
SdaiPcurve_or_surface_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiPcurve_or_surface access hook funct called." << endl;
    }
#endif
    SdaiPcurve_or_surface *s = (SdaiPcurve_or_surface *) object;
    s->_type = config_control_designt_pcurve_or_surface;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiPcurve_or_surfaces (os_database *db)
{
    return new (db, SdaiPcurve_or_surfaces::get_os_typespec())
		SdaiPcurve_or_surfaces ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiPcurve_or_surface::SdaiPcurve_or_surface( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPcurve_or_surface constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPcurve_or_surface constructor." << endl;
    }
#endif
}

	//  part 1
SdaiPcurve_or_surface::SdaiPcurve_or_surface( const SdaiPcurve_ptr& o,
                                              const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_pcurve)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPcurve_or_surface constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPcurve_or_surface constructor." << endl;
    }
#endif
}

SdaiPcurve_or_surface::SdaiPcurve_or_surface( const SdaiSurface_ptr& o,
                                              const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_surface)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPcurve_or_surface constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPcurve_or_surface constructor." << endl;
    }
#endif
}

SdaiPcurve_or_surface::~SdaiPcurve_or_surface()
{
}

SdaiPcurve_or_surfaces::SdaiPcurve_or_surfaces( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiPcurve_or_surfaces::~SdaiPcurve_or_surfaces() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiPcurve_or_surfaces::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiPcurve_or_surface::get_os_typespec() )
		    SdaiPcurve_or_surface );
}
#endif


	//  part 2
SdaiPcurve_or_surface::operator SdaiPcurve_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_pcurve )
      return ((SdaiPcurve_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPcurve_or_surface::operator SdaiSurface_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_surface )
      return ((SdaiSurface_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiDefinitional_representation_ptr
SdaiPcurve_or_surface::reference_to_curve_() const
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	return ((SdaiPcurve_ptr) _app_inst) ->reference_to_curve_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPcurve_or_surface::reference_to_curve_ (const SdaiDefinitional_representation_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	{  ((SdaiPcurve_ptr) _app_inst) ->reference_to_curve_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiSurface_ptr
SdaiPcurve_or_surface::basis_surface_() const
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	return ((SdaiPcurve_ptr) _app_inst) ->basis_surface_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPcurve_or_surface::basis_surface_ (const SdaiSurface_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	{  ((SdaiPcurve_ptr) _app_inst) ->basis_surface_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiPcurve_or_surface::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	return ((SdaiPcurve_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_surface )
	//  SURFACE
	return ((SdaiSurface_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPcurve_or_surface::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	{  ((SdaiPcurve_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_surface )
	//  SURFACE
	{  ((SdaiSurface_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiPcurve_or_surface& SdaiPcurve_or_surface::operator =( const SdaiPcurve_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_pcurve);
   return *this;
}

SdaiPcurve_or_surface& SdaiPcurve_or_surface::operator =( const SdaiSurface_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_surface);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiPcurve_or_surface& SdaiPcurve_or_surface::operator =( const SdaiPcurve_or_surface_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_pcurve )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_surface )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiPcurve_or_surface::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_pcurve )
	_app_inst = ((SdaiPcurve_or_surface&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_surface )
	_app_inst = ((SdaiPcurve_or_surface&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiPcurve_or_surface::IsPcurve() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_pcurve )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPcurve_or_surface::IsSurface() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_surface )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiPcurve_or_surface


//////////  SELECT TYPE classified_item

const TypeDescriptor *
SdaiClassified_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> IsA (config_control_designe_product_definition_formation))
  {
	_app_inst = (SdaiProduct_definition_formation_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  //  ASSEMBLY_COMPONENT_USAGE
  if (se -> IsA (config_control_designe_assembly_component_usage))
  {
	_app_inst = (SdaiAssembly_component_usage_ptr) se;
	return SetUnderlyingType (config_control_designe_assembly_component_usage);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiClassified_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiClassified_item * tmp =
		new( os_segment::of(this),
		     SdaiClassified_item::get_os_typespec() )
			SdaiClassified_item();
#else
    SdaiClassified_item * tmp = new SdaiClassified_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiClassified_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_assembly_component_usage)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiClassified_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_product_definition_formation)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_assembly_component_usage)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiClassified_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_product_definition_formation)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_assembly_component_usage)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiClassified_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_assembly_component_usage)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiClassified_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiClassified_item (os_database *db)
{
    return new (db, SdaiClassified_item::get_os_typespec())
		SdaiClassified_item ;
}

void
SdaiClassified_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiClassified_item access hook funct called." << endl;
    }
#endif
    SdaiClassified_item *s = (SdaiClassified_item *) object;
    s->_type = config_control_designt_classified_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiClassified_items (os_database *db)
{
    return new (db, SdaiClassified_items::get_os_typespec())
		SdaiClassified_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiClassified_item::SdaiClassified_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiClassified_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiClassified_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiClassified_item::SdaiClassified_item( const SdaiProduct_definition_formation_ptr& o,
                                          const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition_formation)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiClassified_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiClassified_item constructor." << endl;
    }
#endif
}

SdaiClassified_item::SdaiClassified_item( const SdaiAssembly_component_usage_ptr& o,
                                          const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_assembly_component_usage)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiClassified_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiClassified_item constructor." << endl;
    }
#endif
}

SdaiClassified_item::~SdaiClassified_item()
{
}

SdaiClassified_items::SdaiClassified_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiClassified_items::~SdaiClassified_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiClassified_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiClassified_item::get_os_typespec() )
		    SdaiClassified_item );
}
#endif


	//  part 2
SdaiClassified_item::operator SdaiProduct_definition_formation_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formation_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiClassified_item::operator SdaiAssembly_component_usage_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
      return ((SdaiAssembly_component_usage_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiIdentifier
SdaiClassified_item::reference_designator_() const
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usage_ptr) _app_inst) ->reference_designator_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiClassified_item::reference_designator_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usage_ptr) _app_inst) ->reference_designator_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_ptr
SdaiClassified_item::related_product_definition_() const
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usage_ptr) _app_inst) ->related_product_definition_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiClassified_item::related_product_definition_ (const SdaiProduct_definition_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usage_ptr) _app_inst) ->related_product_definition_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_ptr
SdaiClassified_item::relating_product_definition_() const
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usage_ptr) _app_inst) ->relating_product_definition_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiClassified_item::relating_product_definition_ (const SdaiProduct_definition_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usage_ptr) _app_inst) ->relating_product_definition_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiClassified_item::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usage_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiClassified_item::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usage_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_ptr
SdaiClassified_item::of_product_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiClassified_item::of_product_ (const SdaiProduct_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiClassified_item::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usage_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiClassified_item::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usage_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiClassified_item::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usage_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiClassified_item::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usage_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiClassified_item& SdaiClassified_item::operator =( const SdaiProduct_definition_formation_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}

SdaiClassified_item& SdaiClassified_item::operator =( const SdaiAssembly_component_usage_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_assembly_component_usage);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiClassified_item& SdaiClassified_item::operator =( const SdaiClassified_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiClassified_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst = ((SdaiClassified_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	_app_inst = ((SdaiClassified_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiClassified_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiClassified_item::IsAssembly_component_usage() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiClassified_item


//////////  SELECT TYPE founded_item_select

const TypeDescriptor *
SdaiFounded_item_select::AssignEntity (SCLP23(Application_instance) * se)
{
  //  FOUNDED_ITEM
  if (se -> IsA (config_control_designe_founded_item))
  {
	_app_inst = (SdaiFounded_item_ptr) se;
	return SetUnderlyingType (config_control_designe_founded_item);
  }
  //  REPRESENTATION_ITEM
  if (se -> IsA (config_control_designe_representation_item))
  {
	_app_inst = (SdaiRepresentation_item_ptr) se;
	return SetUnderlyingType (config_control_designe_representation_item);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiFounded_item_select::NewSelect ()
{
#ifdef __OSTORE__
    SdaiFounded_item_select * tmp =
		new( os_segment::of(this),
		     SdaiFounded_item_select::get_os_typespec() )
			SdaiFounded_item_select();
#else
    SdaiFounded_item_select * tmp = new SdaiFounded_item_select();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiFounded_item_select::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_founded_item)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_representation_item)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiFounded_item_select::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_founded_item)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_representation_item)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiFounded_item_select::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_founded_item)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_representation_item)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiFounded_item_select::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_founded_item)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_representation_item)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiFounded_item_select::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiFounded_item_select (os_database *db)
{
    return new (db, SdaiFounded_item_select::get_os_typespec())
		SdaiFounded_item_select ;
}

void
SdaiFounded_item_select_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiFounded_item_select access hook funct called." << endl;
    }
#endif
    SdaiFounded_item_select *s = (SdaiFounded_item_select *) object;
    s->_type = config_control_designt_founded_item_select;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiFounded_item_selects (os_database *db)
{
    return new (db, SdaiFounded_item_selects::get_os_typespec())
		SdaiFounded_item_selects ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiFounded_item_select::SdaiFounded_item_select( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiFounded_item_select constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiFounded_item_select constructor." << endl;
    }
#endif
}

	//  part 1
SdaiFounded_item_select::SdaiFounded_item_select( const SdaiFounded_item_ptr& o,
                                                  const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_founded_item)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiFounded_item_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiFounded_item_select constructor." << endl;
    }
#endif
}

SdaiFounded_item_select::SdaiFounded_item_select( const SdaiRepresentation_item_ptr& o,
                                                  const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_representation_item)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiFounded_item_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiFounded_item_select constructor." << endl;
    }
#endif
}

SdaiFounded_item_select::~SdaiFounded_item_select()
{
}

SdaiFounded_item_selects::SdaiFounded_item_selects( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiFounded_item_selects::~SdaiFounded_item_selects() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiFounded_item_selects::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiFounded_item_select::get_os_typespec() )
		    SdaiFounded_item_select );
}
#endif


	//  part 2
SdaiFounded_item_select::operator SdaiFounded_item_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_founded_item )
      return ((SdaiFounded_item_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiFounded_item_select::operator SdaiRepresentation_item_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_representation_item )
      return ((SdaiRepresentation_item_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiLabel
SdaiFounded_item_select::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_representation_item )
	//  REPRESENTATION_ITEM
	return ((SdaiRepresentation_item_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiFounded_item_select::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_representation_item )
	//  REPRESENTATION_ITEM
	{  ((SdaiRepresentation_item_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiFounded_item_select& SdaiFounded_item_select::operator =( const SdaiFounded_item_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_founded_item);
   return *this;
}

SdaiFounded_item_select& SdaiFounded_item_select::operator =( const SdaiRepresentation_item_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_representation_item);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiFounded_item_select& SdaiFounded_item_select::operator =( const SdaiFounded_item_select_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_founded_item )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_representation_item )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiFounded_item_select::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_founded_item )
	_app_inst = ((SdaiFounded_item_select&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_representation_item )
	_app_inst = ((SdaiFounded_item_select&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiFounded_item_select::IsFounded_item() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_founded_item )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiFounded_item_select::IsRepresentation_item() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_representation_item )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiFounded_item_select


//////////  SELECT TYPE vector_or_direction

const TypeDescriptor *
SdaiVector_or_direction::AssignEntity (SCLP23(Application_instance) * se)
{
  //  VECTOR
  if (se -> IsA (config_control_designe_vector))
  {
	_app_inst = (SdaiVector_ptr) se;
	return SetUnderlyingType (config_control_designe_vector);
  }
  //  DIRECTION
  if (se -> IsA (config_control_designe_direction))
  {
	_app_inst = (SdaiDirection_ptr) se;
	return SetUnderlyingType (config_control_designe_direction);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiVector_or_direction::NewSelect ()
{
#ifdef __OSTORE__
    SdaiVector_or_direction * tmp =
		new( os_segment::of(this),
		     SdaiVector_or_direction::get_os_typespec() )
			SdaiVector_or_direction();
#else
    SdaiVector_or_direction * tmp = new SdaiVector_or_direction();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiVector_or_direction::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_vector)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_direction)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiVector_or_direction::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_vector)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_direction)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiVector_or_direction::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_vector)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_direction)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiVector_or_direction::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_vector)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_direction)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiVector_or_direction::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiVector_or_direction (os_database *db)
{
    return new (db, SdaiVector_or_direction::get_os_typespec())
		SdaiVector_or_direction ;
}

void
SdaiVector_or_direction_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiVector_or_direction access hook funct called." << endl;
    }
#endif
    SdaiVector_or_direction *s = (SdaiVector_or_direction *) object;
    s->_type = config_control_designt_vector_or_direction;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiVector_or_directions (os_database *db)
{
    return new (db, SdaiVector_or_directions::get_os_typespec())
		SdaiVector_or_directions ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiVector_or_direction::SdaiVector_or_direction( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiVector_or_direction constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiVector_or_direction constructor." << endl;
    }
#endif
}

	//  part 1
SdaiVector_or_direction::SdaiVector_or_direction( const SdaiVector_ptr& o,
                                                  const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_vector)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiVector_or_direction constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiVector_or_direction constructor." << endl;
    }
#endif
}

SdaiVector_or_direction::SdaiVector_or_direction( const SdaiDirection_ptr& o,
                                                  const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_direction)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiVector_or_direction constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiVector_or_direction constructor." << endl;
    }
#endif
}

SdaiVector_or_direction::~SdaiVector_or_direction()
{
}

SdaiVector_or_directions::SdaiVector_or_directions( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiVector_or_directions::~SdaiVector_or_directions() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiVector_or_directions::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiVector_or_direction::get_os_typespec() )
		    SdaiVector_or_direction );
}
#endif


	//  part 2
SdaiVector_or_direction::operator SdaiVector_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_vector )
      return ((SdaiVector_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiVector_or_direction::operator SdaiDirection_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_direction )
      return ((SdaiDirection_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const RealAggregate_ptr
SdaiVector_or_direction::direction_ratios_() const
{
  if( CurrentUnderlyingType () == config_control_designe_direction )
	//  DIRECTION
	return ((SdaiDirection_ptr) _app_inst) ->direction_ratios_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiVector_or_direction::direction_ratios_ (const RealAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_direction )
	//  DIRECTION
	{  ((SdaiDirection_ptr) _app_inst) ->direction_ratios_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLength_measure
SdaiVector_or_direction::magnitude_() const
{
  if( CurrentUnderlyingType () == config_control_designe_vector )
	//  VECTOR
	return ((SdaiVector_ptr) _app_inst) ->magnitude_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiVector_or_direction::magnitude_ (const SdaiLength_measure x)

{
  if( CurrentUnderlyingType () == config_control_designe_vector )
	//  VECTOR
	{  ((SdaiVector_ptr) _app_inst) ->magnitude_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiDirection_ptr
SdaiVector_or_direction::orientation_() const
{
  if( CurrentUnderlyingType () == config_control_designe_vector )
	//  VECTOR
	return ((SdaiVector_ptr) _app_inst) ->orientation_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiVector_or_direction::orientation_ (const SdaiDirection_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_vector )
	//  VECTOR
	{  ((SdaiVector_ptr) _app_inst) ->orientation_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiVector_or_direction::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_vector )
	//  VECTOR
	return ((SdaiVector_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_direction )
	//  DIRECTION
	return ((SdaiDirection_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiVector_or_direction::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_vector )
	//  VECTOR
	{  ((SdaiVector_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_direction )
	//  DIRECTION
	{  ((SdaiDirection_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiVector_or_direction& SdaiVector_or_direction::operator =( const SdaiVector_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_vector);
   return *this;
}

SdaiVector_or_direction& SdaiVector_or_direction::operator =( const SdaiDirection_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_direction);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiVector_or_direction& SdaiVector_or_direction::operator =( const SdaiVector_or_direction_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_vector )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_direction )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiVector_or_direction::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_vector )
	_app_inst = ((SdaiVector_or_direction&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_direction )
	_app_inst = ((SdaiVector_or_direction&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiVector_or_direction::IsVector() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_vector )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiVector_or_direction::IsDirection() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_direction )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiVector_or_direction


//////////  SELECT TYPE wireframe_model

const TypeDescriptor *
SdaiWireframe_model::AssignEntity (SCLP23(Application_instance) * se)
{
  //  SHELL_BASED_WIREFRAME_MODEL
  if (se -> IsA (config_control_designe_shell_based_wireframe_model))
  {
	_app_inst = (SdaiShell_based_wireframe_model_ptr) se;
	return SetUnderlyingType (config_control_designe_shell_based_wireframe_model);
  }
  //  EDGE_BASED_WIREFRAME_MODEL
  if (se -> IsA (config_control_designe_edge_based_wireframe_model))
  {
	_app_inst = (SdaiEdge_based_wireframe_model_ptr) se;
	return SetUnderlyingType (config_control_designe_edge_based_wireframe_model);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiWireframe_model::NewSelect ()
{
#ifdef __OSTORE__
    SdaiWireframe_model * tmp =
		new( os_segment::of(this),
		     SdaiWireframe_model::get_os_typespec() )
			SdaiWireframe_model();
#else
    SdaiWireframe_model * tmp = new SdaiWireframe_model();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiWireframe_model::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiWireframe_model::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_shell_based_wireframe_model)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_edge_based_wireframe_model)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiWireframe_model::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_shell_based_wireframe_model)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_edge_based_wireframe_model)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiWireframe_model::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiWireframe_model::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiWireframe_model (os_database *db)
{
    return new (db, SdaiWireframe_model::get_os_typespec())
		SdaiWireframe_model ;
}

void
SdaiWireframe_model_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiWireframe_model access hook funct called." << endl;
    }
#endif
    SdaiWireframe_model *s = (SdaiWireframe_model *) object;
    s->_type = config_control_designt_wireframe_model;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiWireframe_models (os_database *db)
{
    return new (db, SdaiWireframe_models::get_os_typespec())
		SdaiWireframe_models ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiWireframe_model::SdaiWireframe_model( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiWireframe_model constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiWireframe_model constructor." << endl;
    }
#endif
}

	//  part 1
SdaiWireframe_model::SdaiWireframe_model( const SdaiShell_based_wireframe_model_ptr& o,
                                          const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_shell_based_wireframe_model)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiWireframe_model constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiWireframe_model constructor." << endl;
    }
#endif
}

SdaiWireframe_model::SdaiWireframe_model( const SdaiEdge_based_wireframe_model_ptr& o,
                                          const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_edge_based_wireframe_model)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiWireframe_model constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiWireframe_model constructor." << endl;
    }
#endif
}

SdaiWireframe_model::~SdaiWireframe_model()
{
}

SdaiWireframe_models::SdaiWireframe_models( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiWireframe_models::~SdaiWireframe_models() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiWireframe_models::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiWireframe_model::get_os_typespec() )
		    SdaiWireframe_model );
}
#endif


	//  part 2
SdaiWireframe_model::operator SdaiShell_based_wireframe_model_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
      return ((SdaiShell_based_wireframe_model_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiWireframe_model::operator SdaiEdge_based_wireframe_model_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
      return ((SdaiEdge_based_wireframe_model_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const EntityAggregate_ptr
SdaiWireframe_model::ebwm_boundary_() const
{
  if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
	//  EDGE_BASED_WIREFRAME_MODEL
	return ((SdaiEdge_based_wireframe_model_ptr) _app_inst) ->ebwm_boundary_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiWireframe_model::ebwm_boundary_ (const EntityAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
	//  EDGE_BASED_WIREFRAME_MODEL
	{  ((SdaiEdge_based_wireframe_model_ptr) _app_inst) ->ebwm_boundary_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiShells_ptr
SdaiWireframe_model::sbwm_boundary_() const
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
	//  SHELL_BASED_WIREFRAME_MODEL
	return ((SdaiShell_based_wireframe_model_ptr) _app_inst) ->sbwm_boundary_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiWireframe_model::sbwm_boundary_ (const SdaiShells_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
	//  SHELL_BASED_WIREFRAME_MODEL
	{  ((SdaiShell_based_wireframe_model_ptr) _app_inst) ->sbwm_boundary_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiWireframe_model::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
	//  SHELL_BASED_WIREFRAME_MODEL
	return ((SdaiShell_based_wireframe_model_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
	//  EDGE_BASED_WIREFRAME_MODEL
	return ((SdaiEdge_based_wireframe_model_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiWireframe_model::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
	//  SHELL_BASED_WIREFRAME_MODEL
	{  ((SdaiShell_based_wireframe_model_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
	//  EDGE_BASED_WIREFRAME_MODEL
	{  ((SdaiEdge_based_wireframe_model_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiWireframe_model& SdaiWireframe_model::operator =( const SdaiShell_based_wireframe_model_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_shell_based_wireframe_model);
   return *this;
}

SdaiWireframe_model& SdaiWireframe_model::operator =( const SdaiEdge_based_wireframe_model_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_edge_based_wireframe_model);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiWireframe_model& SdaiWireframe_model::operator =( const SdaiWireframe_model_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiWireframe_model::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
	_app_inst = ((SdaiWireframe_model&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
	_app_inst = ((SdaiWireframe_model&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiWireframe_model::IsShell_based_wireframe_model() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiWireframe_model::IsEdge_based_wireframe_model() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiWireframe_model


//////////  SELECT TYPE geometric_set_select

const TypeDescriptor *
SdaiGeometric_set_select::AssignEntity (SCLP23(Application_instance) * se)
{
  //  POINT
  if (se -> IsA (config_control_designe_point))
  {
	_app_inst = (SdaiPoint_ptr) se;
	return SetUnderlyingType (config_control_designe_point);
  }
  //  CURVE
  if (se -> IsA (config_control_designe_curve))
  {
	_app_inst = (SdaiCurve_ptr) se;
	return SetUnderlyingType (config_control_designe_curve);
  }
  //  SURFACE
  if (se -> IsA (config_control_designe_surface))
  {
	_app_inst = (SdaiSurface_ptr) se;
	return SetUnderlyingType (config_control_designe_surface);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiGeometric_set_select::NewSelect ()
{
#ifdef __OSTORE__
    SdaiGeometric_set_select * tmp =
		new( os_segment::of(this),
		     SdaiGeometric_set_select::get_os_typespec() )
			SdaiGeometric_set_select();
#else
    SdaiGeometric_set_select * tmp = new SdaiGeometric_set_select();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiGeometric_set_select::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_point)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_curve)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_surface)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiGeometric_set_select::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_point)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_curve)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_surface)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiGeometric_set_select::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_point)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_curve)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_surface)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiGeometric_set_select::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_point)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_curve)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_surface)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiGeometric_set_select::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiGeometric_set_select (os_database *db)
{
    return new (db, SdaiGeometric_set_select::get_os_typespec())
		SdaiGeometric_set_select ;
}

void
SdaiGeometric_set_select_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiGeometric_set_select access hook funct called." << endl;
    }
#endif
    SdaiGeometric_set_select *s = (SdaiGeometric_set_select *) object;
    s->_type = config_control_designt_geometric_set_select;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiGeometric_set_selects (os_database *db)
{
    return new (db, SdaiGeometric_set_selects::get_os_typespec())
		SdaiGeometric_set_selects ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiGeometric_set_select::SdaiGeometric_set_select( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiGeometric_set_select constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiGeometric_set_select constructor." << endl;
    }
#endif
}

	//  part 1
SdaiGeometric_set_select::SdaiGeometric_set_select( const SdaiPoint_ptr& o,
                                                    const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_point)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiGeometric_set_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiGeometric_set_select constructor." << endl;
    }
#endif
}

SdaiGeometric_set_select::SdaiGeometric_set_select( const SdaiCurve_ptr& o,
                                                    const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_curve)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiGeometric_set_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiGeometric_set_select constructor." << endl;
    }
#endif
}

SdaiGeometric_set_select::SdaiGeometric_set_select( const SdaiSurface_ptr& o,
                                                    const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_surface)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiGeometric_set_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiGeometric_set_select constructor." << endl;
    }
#endif
}

SdaiGeometric_set_select::~SdaiGeometric_set_select()
{
}

SdaiGeometric_set_selects::SdaiGeometric_set_selects( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiGeometric_set_selects::~SdaiGeometric_set_selects() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiGeometric_set_selects::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiGeometric_set_select::get_os_typespec() )
		    SdaiGeometric_set_select );
}
#endif


	//  part 2
SdaiGeometric_set_select::operator SdaiPoint_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_point )
      return ((SdaiPoint_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiGeometric_set_select::operator SdaiCurve_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_curve )
      return ((SdaiCurve_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiGeometric_set_select::operator SdaiSurface_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_surface )
      return ((SdaiSurface_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiLabel
SdaiGeometric_set_select::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_point )
	//  POINT
	return ((SdaiPoint_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_curve )
	//  CURVE
	return ((SdaiCurve_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_surface )
	//  SURFACE
	return ((SdaiSurface_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiGeometric_set_select::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_point )
	//  POINT
	{  ((SdaiPoint_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_curve )
	//  CURVE
	{  ((SdaiCurve_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_surface )
	//  SURFACE
	{  ((SdaiSurface_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiGeometric_set_select& SdaiGeometric_set_select::operator =( const SdaiPoint_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_point);
   return *this;
}

SdaiGeometric_set_select& SdaiGeometric_set_select::operator =( const SdaiCurve_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_curve);
   return *this;
}

SdaiGeometric_set_select& SdaiGeometric_set_select::operator =( const SdaiSurface_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_surface);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiGeometric_set_select& SdaiGeometric_set_select::operator =( const SdaiGeometric_set_select_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_point )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_curve )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_surface )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiGeometric_set_select::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_point )
	_app_inst = ((SdaiGeometric_set_select&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_curve )
	_app_inst = ((SdaiGeometric_set_select&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_surface )
	_app_inst = ((SdaiGeometric_set_select&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiGeometric_set_select::IsPoint() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_point )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiGeometric_set_select::IsCurve() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_curve )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiGeometric_set_select::IsSurface() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_surface )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiGeometric_set_select


//////////  SELECT TYPE start_request_item

const TypeDescriptor *
SdaiStart_request_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> IsA (config_control_designe_product_definition_formation))
  {
	_app_inst = (SdaiProduct_definition_formation_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiStart_request_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiStart_request_item * tmp =
		new( os_segment::of(this),
		     SdaiStart_request_item::get_os_typespec() )
			SdaiStart_request_item();
#else
    SdaiStart_request_item * tmp = new SdaiStart_request_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiStart_request_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiStart_request_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_product_definition_formation)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiStart_request_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_product_definition_formation)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiStart_request_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiStart_request_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiStart_request_item (os_database *db)
{
    return new (db, SdaiStart_request_item::get_os_typespec())
		SdaiStart_request_item ;
}

void
SdaiStart_request_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiStart_request_item access hook funct called." << endl;
    }
#endif
    SdaiStart_request_item *s = (SdaiStart_request_item *) object;
    s->_type = config_control_designt_start_request_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiStart_request_items (os_database *db)
{
    return new (db, SdaiStart_request_items::get_os_typespec())
		SdaiStart_request_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiStart_request_item::SdaiStart_request_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiStart_request_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiStart_request_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiStart_request_item::SdaiStart_request_item( const SdaiProduct_definition_formation_ptr& o,
                                                const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition_formation)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiStart_request_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiStart_request_item constructor." << endl;
    }
#endif
}

SdaiStart_request_item::~SdaiStart_request_item()
{
}

SdaiStart_request_items::SdaiStart_request_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiStart_request_items::~SdaiStart_request_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiStart_request_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiStart_request_item::get_os_typespec() )
		    SdaiStart_request_item );
}
#endif


	//  part 2
SdaiStart_request_item::operator SdaiProduct_definition_formation_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formation_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiProduct_ptr
SdaiStart_request_item::of_product_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiStart_request_item::of_product_ (const SdaiProduct_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiStart_request_item::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiStart_request_item::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiStart_request_item::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiStart_request_item::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiStart_request_item& SdaiStart_request_item::operator =( const SdaiProduct_definition_formation_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiStart_request_item& SdaiStart_request_item::operator =( const SdaiStart_request_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiStart_request_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst = ((SdaiStart_request_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiStart_request_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiStart_request_item


//////////  SELECT TYPE person_organization_item

const TypeDescriptor *
SdaiPerson_organization_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  CHANGE
  if (se -> IsA (config_control_designe_change))
  {
	_app_inst = (SdaiChange_ptr) se;
	return SetUnderlyingType (config_control_designe_change);
  }
  //  START_WORK
  if (se -> IsA (config_control_designe_start_work))
  {
	_app_inst = (SdaiStart_work_ptr) se;
	return SetUnderlyingType (config_control_designe_start_work);
  }
  //  CHANGE_REQUEST
  if (se -> IsA (config_control_designe_change_request))
  {
	_app_inst = (SdaiChange_request_ptr) se;
	return SetUnderlyingType (config_control_designe_change_request);
  }
  //  START_REQUEST
  if (se -> IsA (config_control_designe_start_request))
  {
	_app_inst = (SdaiStart_request_ptr) se;
	return SetUnderlyingType (config_control_designe_start_request);
  }
  //  CONFIGURATION_ITEM
  if (se -> IsA (config_control_designe_configuration_item))
  {
	_app_inst = (SdaiConfiguration_item_ptr) se;
	return SetUnderlyingType (config_control_designe_configuration_item);
  }
  //  PRODUCT
  if (se -> IsA (config_control_designe_product))
  {
	_app_inst = (SdaiProduct_ptr) se;
	return SetUnderlyingType (config_control_designe_product);
  }
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> IsA (config_control_designe_product_definition_formation))
  {
	_app_inst = (SdaiProduct_definition_formation_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  //  PRODUCT_DEFINITION
  if (se -> IsA (config_control_designe_product_definition))
  {
	_app_inst = (SdaiProduct_definition_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition);
  }
  //  CONTRACT
  if (se -> IsA (config_control_designe_contract))
  {
	_app_inst = (SdaiContract_ptr) se;
	return SetUnderlyingType (config_control_designe_contract);
  }
  //  SECURITY_CLASSIFICATION
  if (se -> IsA (config_control_designe_security_classification))
  {
	_app_inst = (SdaiSecurity_classification_ptr) se;
	return SetUnderlyingType (config_control_designe_security_classification);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiPerson_organization_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiPerson_organization_item * tmp =
		new( os_segment::of(this),
		     SdaiPerson_organization_item::get_os_typespec() )
			SdaiPerson_organization_item();
#else
    SdaiPerson_organization_item * tmp = new SdaiPerson_organization_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiPerson_organization_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_change)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_start_work)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_change_request)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_start_request)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_configuration_item)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_product)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_product_definition)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_contract)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_security_classification)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiPerson_organization_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_change)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_start_work)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_change_request)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_start_request)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_configuration_item)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_product)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_product_definition_formation)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_product_definition)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_contract)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_security_classification)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiPerson_organization_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_change)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_start_work)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_change_request)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_start_request)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_configuration_item)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_product)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_product_definition_formation)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_product_definition)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_contract)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_security_classification)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiPerson_organization_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_change)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_start_work)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_change_request)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_start_request)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_configuration_item)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_product)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_product_definition)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_contract)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_security_classification)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiPerson_organization_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiPerson_organization_item (os_database *db)
{
    return new (db, SdaiPerson_organization_item::get_os_typespec())
		SdaiPerson_organization_item ;
}

void
SdaiPerson_organization_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiPerson_organization_item access hook funct called." << endl;
    }
#endif
    SdaiPerson_organization_item *s = (SdaiPerson_organization_item *) object;
    s->_type = config_control_designt_person_organization_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiPerson_organization_items (os_database *db)
{
    return new (db, SdaiPerson_organization_items::get_os_typespec())
		SdaiPerson_organization_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiPerson_organization_item::SdaiPerson_organization_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiChange_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_change)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_item constructor." << endl;
    }
#endif
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiStart_work_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_start_work)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_item constructor." << endl;
    }
#endif
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiChange_request_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_change_request)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_item constructor." << endl;
    }
#endif
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiStart_request_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_start_request)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_item constructor." << endl;
    }
#endif
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiConfiguration_item_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_configuration_item)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_item constructor." << endl;
    }
#endif
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiProduct_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_item constructor." << endl;
    }
#endif
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiProduct_definition_formation_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition_formation)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_item constructor." << endl;
    }
#endif
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiProduct_definition_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_item constructor." << endl;
    }
#endif
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiContract_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_contract)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_item constructor." << endl;
    }
#endif
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiSecurity_classification_ptr& o,
                                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_security_classification)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiPerson_organization_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiPerson_organization_item constructor." << endl;
    }
#endif
}

SdaiPerson_organization_item::~SdaiPerson_organization_item()
{
}

SdaiPerson_organization_items::SdaiPerson_organization_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiPerson_organization_items::~SdaiPerson_organization_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiPerson_organization_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiPerson_organization_item::get_os_typespec() )
		    SdaiPerson_organization_item );
}
#endif


	//  part 2
SdaiPerson_organization_item::operator SdaiChange_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_change )
      return ((SdaiChange_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiStart_work_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return ((SdaiStart_work_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiChange_request_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return ((SdaiChange_request_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiStart_request_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return ((SdaiStart_request_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiConfiguration_item_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_configuration_item )
      return ((SdaiConfiguration_item_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiProduct_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product )
      return ((SdaiProduct_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiProduct_definition_formation_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formation_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiProduct_definition_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return ((SdaiProduct_definition_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiContract_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return ((SdaiContract_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiSecurity_classification_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return ((SdaiSecurity_classification_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiSecurity_classification_level_ptr
SdaiPerson_organization_item::security_level_() const
{
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classification_ptr) _app_inst) ->security_level_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::security_level_ (const SdaiSecurity_classification_level_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classification_ptr) _app_inst) ->security_level_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiContract_type_ptr
SdaiPerson_organization_item::kind_() const
{
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	return ((SdaiContract_ptr) _app_inst) ->kind_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::kind_ (const SdaiContract_type_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	{  ((SdaiContract_ptr) _app_inst) ->kind_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_formation_ptr
SdaiPerson_organization_item::formation_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->formation_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::formation_ (const SdaiProduct_definition_formation_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->formation_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_ptr
SdaiPerson_organization_item::of_product_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::of_product_ (const SdaiProduct_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const EntityAggregate_ptr
SdaiPerson_organization_item::frame_of_reference_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product )
	//  PRODUCT
	return ((SdaiProduct_ptr) _app_inst) ->frame_of_reference_();
  //  PRODUCT_DEFINITION
	//  attribute access function has a different return type
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::frame_of_reference_ (const EntityAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product )
	//  PRODUCT
	{  ((SdaiProduct_ptr) _app_inst) ->frame_of_reference_( x );
	  return;
	}
  //  for PRODUCT_DEFINITION  attribute access function has a different argument type

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiPerson_organization_item::purpose_() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_item_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	return ((SdaiContract_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classification_ptr) _app_inst) ->purpose_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::purpose_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_item_ptr) _app_inst) ->purpose_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	{  ((SdaiContract_ptr) _app_inst) ->purpose_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classification_ptr) _app_inst) ->purpose_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_concept_ptr
SdaiPerson_organization_item::item_concept_() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_item_ptr) _app_inst) ->item_concept_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::item_concept_ (const SdaiProduct_concept_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_item_ptr) _app_inst) ->item_concept_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiPerson_organization_item::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_item_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_product )
	//  PRODUCT
	return ((SdaiProduct_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_item_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product )
	//  PRODUCT
	{  ((SdaiProduct_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiPerson_organization_item::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_item_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_product )
	//  PRODUCT
	return ((SdaiProduct_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	return ((SdaiContract_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classification_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_item_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product )
	//  PRODUCT
	{  ((SdaiProduct_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	{  ((SdaiContract_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classification_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiPerson_organization_item::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_item_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_designe_product )
	//  PRODUCT
	return ((SdaiProduct_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_item_ptr) _app_inst) ->id_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product )
	//  PRODUCT
	{  ((SdaiProduct_ptr) _app_inst) ->id_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiVersioned_action_request_ptr
SdaiPerson_organization_item::assigned_action_request_() const
{
  if( CurrentUnderlyingType () == config_control_designe_change_request )
	//  CHANGE_REQUEST
	return ((SdaiChange_request_ptr) _app_inst) ->assigned_action_request_();
  if( CurrentUnderlyingType () == config_control_designe_start_request )
	//  START_REQUEST
	return ((SdaiStart_request_ptr) _app_inst) ->assigned_action_request_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::assigned_action_request_ (const SdaiVersioned_action_request_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_change_request )
	//  CHANGE_REQUEST
	{  ((SdaiChange_request_ptr) _app_inst) ->assigned_action_request_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_request )
	//  START_REQUEST
	{  ((SdaiStart_request_ptr) _app_inst) ->assigned_action_request_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiWork_items_ptr
SdaiPerson_organization_item::items_() const
{
  if( CurrentUnderlyingType () == config_control_designe_change )
	//  CHANGE
	return ((SdaiChange_ptr) _app_inst) ->items_();
  if( CurrentUnderlyingType () == config_control_designe_start_work )
	//  START_WORK
	return ((SdaiStart_work_ptr) _app_inst) ->items_();
  //  CHANGE_REQUEST
	//  attribute access function has a different return type
  //  START_REQUEST
	//  attribute access function has a different return type
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::items_ (const SdaiWork_items_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_change )
	//  CHANGE
	{  ((SdaiChange_ptr) _app_inst) ->items_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_work )
	//  START_WORK
	{  ((SdaiStart_work_ptr) _app_inst) ->items_( x );
	  return;
	}
  //  for CHANGE_REQUEST  attribute access function has a different argument type
  //  for START_REQUEST  attribute access function has a different argument type

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiAction_ptr
SdaiPerson_organization_item::assigned_action_() const
{
  if( CurrentUnderlyingType () == config_control_designe_change )
	//  CHANGE
	return ((SdaiChange_ptr) _app_inst) ->assigned_action_();
  if( CurrentUnderlyingType () == config_control_designe_start_work )
	//  START_WORK
	return ((SdaiStart_work_ptr) _app_inst) ->assigned_action_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiPerson_organization_item::assigned_action_ (const SdaiAction_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_change )
	//  CHANGE
	{  ((SdaiChange_ptr) _app_inst) ->assigned_action_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_work )
	//  START_WORK
	{  ((SdaiStart_work_ptr) _app_inst) ->assigned_action_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiChange_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_change);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiStart_work_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_start_work);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiChange_request_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_change_request);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiStart_request_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_start_request);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiConfiguration_item_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_configuration_item);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiProduct_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiProduct_definition_formation_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiProduct_definition_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiContract_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_contract);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiSecurity_classification_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_security_classification);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiPerson_organization_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_change )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_start_work )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_change_request )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_start_request )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_configuration_item )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_product )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_contract )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_security_classification )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiPerson_organization_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_change )
	_app_inst = ((SdaiPerson_organization_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_start_work )
	_app_inst = ((SdaiPerson_organization_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_change_request )
	_app_inst = ((SdaiPerson_organization_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_start_request )
	_app_inst = ((SdaiPerson_organization_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_configuration_item )
	_app_inst = ((SdaiPerson_organization_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_product )
	_app_inst = ((SdaiPerson_organization_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst = ((SdaiPerson_organization_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_product_definition )
	_app_inst = ((SdaiPerson_organization_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_contract )
	_app_inst = ((SdaiPerson_organization_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_security_classification )
	_app_inst = ((SdaiPerson_organization_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiPerson_organization_item::IsChange() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_change )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPerson_organization_item::IsStart_work() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPerson_organization_item::IsChange_request() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPerson_organization_item::IsStart_request() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPerson_organization_item::IsConfiguration_item() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_configuration_item )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPerson_organization_item::IsProduct() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPerson_organization_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPerson_organization_item::IsProduct_definition() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPerson_organization_item::IsContract() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiPerson_organization_item::IsSecurity_classification() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiPerson_organization_item


//////////  SELECT TYPE date_time_item

const TypeDescriptor *
SdaiDate_time_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PRODUCT_DEFINITION
  if (se -> IsA (config_control_designe_product_definition))
  {
	_app_inst = (SdaiProduct_definition_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition);
  }
  //  CHANGE_REQUEST
  if (se -> IsA (config_control_designe_change_request))
  {
	_app_inst = (SdaiChange_request_ptr) se;
	return SetUnderlyingType (config_control_designe_change_request);
  }
  //  START_REQUEST
  if (se -> IsA (config_control_designe_start_request))
  {
	_app_inst = (SdaiStart_request_ptr) se;
	return SetUnderlyingType (config_control_designe_start_request);
  }
  //  CHANGE
  if (se -> IsA (config_control_designe_change))
  {
	_app_inst = (SdaiChange_ptr) se;
	return SetUnderlyingType (config_control_designe_change);
  }
  //  START_WORK
  if (se -> IsA (config_control_designe_start_work))
  {
	_app_inst = (SdaiStart_work_ptr) se;
	return SetUnderlyingType (config_control_designe_start_work);
  }
  //  APPROVAL_PERSON_ORGANIZATION
  if (se -> IsA (config_control_designe_approval_person_organization))
  {
	_app_inst = (SdaiApproval_person_organization_ptr) se;
	return SetUnderlyingType (config_control_designe_approval_person_organization);
  }
  //  CONTRACT
  if (se -> IsA (config_control_designe_contract))
  {
	_app_inst = (SdaiContract_ptr) se;
	return SetUnderlyingType (config_control_designe_contract);
  }
  //  SECURITY_CLASSIFICATION
  if (se -> IsA (config_control_designe_security_classification))
  {
	_app_inst = (SdaiSecurity_classification_ptr) se;
	return SetUnderlyingType (config_control_designe_security_classification);
  }
  //  CERTIFICATION
  if (se -> IsA (config_control_designe_certification))
  {
	_app_inst = (SdaiCertification_ptr) se;
	return SetUnderlyingType (config_control_designe_certification);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiDate_time_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiDate_time_item * tmp =
		new( os_segment::of(this),
		     SdaiDate_time_item::get_os_typespec() )
			SdaiDate_time_item();
#else
    SdaiDate_time_item * tmp = new SdaiDate_time_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiDate_time_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_change_request)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_start_request)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_change)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_start_work)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_approval_person_organization)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_contract)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_security_classification)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_certification)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiDate_time_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_product_definition)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_change_request)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_start_request)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_change)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_start_work)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_approval_person_organization)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_contract)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_security_classification)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_certification)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiDate_time_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_product_definition)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_change_request)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_start_request)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_change)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_start_work)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_approval_person_organization)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_contract)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_security_classification)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_certification)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiDate_time_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_change_request)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_start_request)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_change)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_start_work)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_approval_person_organization)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_contract)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_security_classification)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_certification)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiDate_time_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiDate_time_item (os_database *db)
{
    return new (db, SdaiDate_time_item::get_os_typespec())
		SdaiDate_time_item ;
}

void
SdaiDate_time_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiDate_time_item access hook funct called." << endl;
    }
#endif
    SdaiDate_time_item *s = (SdaiDate_time_item *) object;
    s->_type = config_control_designt_date_time_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiDate_time_items (os_database *db)
{
    return new (db, SdaiDate_time_items::get_os_typespec())
		SdaiDate_time_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiDate_time_item::SdaiDate_time_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiDate_time_item::SdaiDate_time_item( const SdaiProduct_definition_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_item constructor." << endl;
    }
#endif
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiChange_request_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_change_request)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_item constructor." << endl;
    }
#endif
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiStart_request_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_start_request)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_item constructor." << endl;
    }
#endif
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiChange_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_change)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_item constructor." << endl;
    }
#endif
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiStart_work_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_start_work)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_item constructor." << endl;
    }
#endif
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiApproval_person_organization_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_approval_person_organization)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_item constructor." << endl;
    }
#endif
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiContract_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_contract)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_item constructor." << endl;
    }
#endif
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiSecurity_classification_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_security_classification)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_item constructor." << endl;
    }
#endif
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiCertification_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_certification)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_item constructor." << endl;
    }
#endif
}

SdaiDate_time_item::~SdaiDate_time_item()
{
}

SdaiDate_time_items::SdaiDate_time_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiDate_time_items::~SdaiDate_time_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiDate_time_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiDate_time_item::get_os_typespec() )
		    SdaiDate_time_item );
}
#endif


	//  part 2
SdaiDate_time_item::operator SdaiProduct_definition_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return ((SdaiProduct_definition_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiChange_request_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return ((SdaiChange_request_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiStart_request_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return ((SdaiStart_request_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiChange_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_change )
      return ((SdaiChange_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiStart_work_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return ((SdaiStart_work_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiApproval_person_organization_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_approval_person_organization )
      return ((SdaiApproval_person_organization_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiContract_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return ((SdaiContract_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiSecurity_classification_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return ((SdaiSecurity_classification_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiCertification_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_certification )
      return ((SdaiCertification_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiSecurity_classification_level_ptr
SdaiDate_time_item::security_level_() const
{
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classification_ptr) _app_inst) ->security_level_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::security_level_ (const SdaiSecurity_classification_level_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classification_ptr) _app_inst) ->security_level_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiContract_type_ptr
SdaiDate_time_item::kind_() const
{
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	return ((SdaiContract_ptr) _app_inst) ->kind_();
  //  CERTIFICATION
	//  attribute access function has a different return type
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::kind_ (const SdaiContract_type_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	{  ((SdaiContract_ptr) _app_inst) ->kind_( x );
	  return;
	}
  //  for CERTIFICATION  attribute access function has a different argument type

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiDate_time_item::purpose_() const
{
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	return ((SdaiContract_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classification_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_designe_certification )
	//  CERTIFICATION
	return ((SdaiCertification_ptr) _app_inst) ->purpose_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::purpose_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	{  ((SdaiContract_ptr) _app_inst) ->purpose_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classification_ptr) _app_inst) ->purpose_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_certification )
	//  CERTIFICATION
	{  ((SdaiCertification_ptr) _app_inst) ->purpose_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiDate_time_item::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	return ((SdaiContract_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classification_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_certification )
	//  CERTIFICATION
	return ((SdaiCertification_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	{  ((SdaiContract_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classification_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_certification )
	//  CERTIFICATION
	{  ((SdaiCertification_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiApproval_role_ptr
SdaiDate_time_item::role_() const
{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization )
	//  APPROVAL_PERSON_ORGANIZATION
	return ((SdaiApproval_person_organization_ptr) _app_inst) ->role_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::role_ (const SdaiApproval_role_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization )
	//  APPROVAL_PERSON_ORGANIZATION
	{  ((SdaiApproval_person_organization_ptr) _app_inst) ->role_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiApproval_ptr
SdaiDate_time_item::authorized_approval_() const
{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization )
	//  APPROVAL_PERSON_ORGANIZATION
	return ((SdaiApproval_person_organization_ptr) _app_inst) ->authorized_approval_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::authorized_approval_ (const SdaiApproval_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization )
	//  APPROVAL_PERSON_ORGANIZATION
	{  ((SdaiApproval_person_organization_ptr) _app_inst) ->authorized_approval_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiPerson_organization_select_ptr
SdaiDate_time_item::person_organization_() const
{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization )
	//  APPROVAL_PERSON_ORGANIZATION
	return ((SdaiApproval_person_organization_ptr) _app_inst) ->person_organization_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::person_organization_ (const SdaiPerson_organization_select_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization )
	//  APPROVAL_PERSON_ORGANIZATION
	{  ((SdaiApproval_person_organization_ptr) _app_inst) ->person_organization_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiAction_ptr
SdaiDate_time_item::assigned_action_() const
{
  if( CurrentUnderlyingType () == config_control_designe_change )
	//  CHANGE
	return ((SdaiChange_ptr) _app_inst) ->assigned_action_();
  if( CurrentUnderlyingType () == config_control_designe_start_work )
	//  START_WORK
	return ((SdaiStart_work_ptr) _app_inst) ->assigned_action_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::assigned_action_ (const SdaiAction_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_change )
	//  CHANGE
	{  ((SdaiChange_ptr) _app_inst) ->assigned_action_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_work )
	//  START_WORK
	{  ((SdaiStart_work_ptr) _app_inst) ->assigned_action_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiChange_request_items_ptr
SdaiDate_time_item::items_() const
{
  if( CurrentUnderlyingType () == config_control_designe_change_request )
	//  CHANGE_REQUEST
	return ((SdaiChange_request_ptr) _app_inst) ->items_();
  //  START_REQUEST
	//  attribute access function has a different return type
  //  CHANGE
	//  attribute access function has a different return type
  //  START_WORK
	//  attribute access function has a different return type
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::items_ (const SdaiChange_request_items_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_change_request )
	//  CHANGE_REQUEST
	{  ((SdaiChange_request_ptr) _app_inst) ->items_( x );
	  return;
	}
  //  for START_REQUEST  attribute access function has a different argument type
  //  for CHANGE  attribute access function has a different argument type
  //  for START_WORK  attribute access function has a different argument type

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiVersioned_action_request_ptr
SdaiDate_time_item::assigned_action_request_() const
{
  if( CurrentUnderlyingType () == config_control_designe_change_request )
	//  CHANGE_REQUEST
	return ((SdaiChange_request_ptr) _app_inst) ->assigned_action_request_();
  if( CurrentUnderlyingType () == config_control_designe_start_request )
	//  START_REQUEST
	return ((SdaiStart_request_ptr) _app_inst) ->assigned_action_request_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::assigned_action_request_ (const SdaiVersioned_action_request_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_change_request )
	//  CHANGE_REQUEST
	{  ((SdaiChange_request_ptr) _app_inst) ->assigned_action_request_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_request )
	//  START_REQUEST
	{  ((SdaiStart_request_ptr) _app_inst) ->assigned_action_request_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_context_ptr
SdaiDate_time_item::frame_of_reference_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->frame_of_reference_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::frame_of_reference_ (const SdaiProduct_definition_context_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->frame_of_reference_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_formation_ptr
SdaiDate_time_item::formation_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->formation_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::formation_ (const SdaiProduct_definition_formation_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->formation_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiDate_time_item::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiDate_time_item::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_item::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiProduct_definition_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiChange_request_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_change_request);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiStart_request_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_start_request);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiChange_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_change);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiStart_work_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_start_work);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiApproval_person_organization_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_approval_person_organization);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiContract_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_contract);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiSecurity_classification_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_security_classification);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiCertification_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_certification);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiDate_time_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_change_request )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_start_request )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_change )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_start_work )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_approval_person_organization )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_contract )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_security_classification )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_certification )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiDate_time_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_product_definition )
	_app_inst = ((SdaiDate_time_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_change_request )
	_app_inst = ((SdaiDate_time_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_start_request )
	_app_inst = ((SdaiDate_time_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_change )
	_app_inst = ((SdaiDate_time_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_start_work )
	_app_inst = ((SdaiDate_time_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_approval_person_organization )
	_app_inst = ((SdaiDate_time_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_contract )
	_app_inst = ((SdaiDate_time_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_security_classification )
	_app_inst = ((SdaiDate_time_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_certification )
	_app_inst = ((SdaiDate_time_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiDate_time_item::IsProduct_definition() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiDate_time_item::IsChange_request() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiDate_time_item::IsStart_request() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiDate_time_item::IsChange() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_change )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiDate_time_item::IsStart_work() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiDate_time_item::IsApproval_person_organization() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_approval_person_organization )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiDate_time_item::IsContract() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiDate_time_item::IsSecurity_classification() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiDate_time_item::IsCertification() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_certification )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiDate_time_item


//////////  SELECT TYPE shell

const TypeDescriptor *
SdaiShell::AssignEntity (SCLP23(Application_instance) * se)
{
  //  VERTEX_SHELL
  if (se -> IsA (config_control_designe_vertex_shell))
  {
	_app_inst = (SdaiVertex_shell_ptr) se;
	return SetUnderlyingType (config_control_designe_vertex_shell);
  }
  //  WIRE_SHELL
  if (se -> IsA (config_control_designe_wire_shell))
  {
	_app_inst = (SdaiWire_shell_ptr) se;
	return SetUnderlyingType (config_control_designe_wire_shell);
  }
  //  OPEN_SHELL
  if (se -> IsA (config_control_designe_open_shell))
  {
	_app_inst = (SdaiOpen_shell_ptr) se;
	return SetUnderlyingType (config_control_designe_open_shell);
  }
  //  CLOSED_SHELL
  if (se -> IsA (config_control_designe_closed_shell))
  {
	_app_inst = (SdaiClosed_shell_ptr) se;
	return SetUnderlyingType (config_control_designe_closed_shell);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiShell::NewSelect ()
{
#ifdef __OSTORE__
    SdaiShell * tmp =
		new( os_segment::of(this),
		     SdaiShell::get_os_typespec() )
			SdaiShell();
#else
    SdaiShell * tmp = new SdaiShell();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiShell::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_vertex_shell)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_wire_shell)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_open_shell)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_closed_shell)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiShell::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_vertex_shell)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_wire_shell)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_open_shell)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_closed_shell)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiShell::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_vertex_shell)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_wire_shell)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_open_shell)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_closed_shell)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiShell::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_vertex_shell)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_wire_shell)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_open_shell)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_closed_shell)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiShell::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiShell (os_database *db)
{
    return new (db, SdaiShell::get_os_typespec())
		SdaiShell ;
}

void
SdaiShell_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiShell access hook funct called." << endl;
    }
#endif
    SdaiShell *s = (SdaiShell *) object;
    s->_type = config_control_designt_shell;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiShells (os_database *db)
{
    return new (db, SdaiShells::get_os_typespec())
		SdaiShells ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiShell::SdaiShell( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiShell constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiShell constructor." << endl;
    }
#endif
}

	//  part 1
SdaiShell::SdaiShell( const SdaiVertex_shell_ptr& o,
                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_vertex_shell)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiShell constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiShell constructor." << endl;
    }
#endif
}

SdaiShell::SdaiShell( const SdaiWire_shell_ptr& o,
                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_wire_shell)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiShell constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiShell constructor." << endl;
    }
#endif
}

SdaiShell::SdaiShell( const SdaiOpen_shell_ptr& o,
                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_open_shell)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiShell constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiShell constructor." << endl;
    }
#endif
}

SdaiShell::SdaiShell( const SdaiClosed_shell_ptr& o,
                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_closed_shell)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiShell constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiShell constructor." << endl;
    }
#endif
}

SdaiShell::~SdaiShell()
{
}

SdaiShells::SdaiShells( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiShells::~SdaiShells() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiShells::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiShell::get_os_typespec() )
		    SdaiShell );
}
#endif


	//  part 2
SdaiShell::operator SdaiVertex_shell_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_vertex_shell )
      return ((SdaiVertex_shell_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiShell::operator SdaiWire_shell_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_wire_shell )
      return ((SdaiWire_shell_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiShell::operator SdaiOpen_shell_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_open_shell )
      return ((SdaiOpen_shell_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiShell::operator SdaiClosed_shell_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_closed_shell )
      return ((SdaiClosed_shell_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const EntityAggregate_ptr
SdaiShell::cfs_faces_() const
{
  if( CurrentUnderlyingType () == config_control_designe_open_shell )
	//  OPEN_SHELL
	return ((SdaiOpen_shell_ptr) _app_inst) ->cfs_faces_();
  if( CurrentUnderlyingType () == config_control_designe_closed_shell )
	//  CLOSED_SHELL
	return ((SdaiClosed_shell_ptr) _app_inst) ->cfs_faces_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiShell::cfs_faces_ (const EntityAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_open_shell )
	//  OPEN_SHELL
	{  ((SdaiOpen_shell_ptr) _app_inst) ->cfs_faces_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_closed_shell )
	//  CLOSED_SHELL
	{  ((SdaiClosed_shell_ptr) _app_inst) ->cfs_faces_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const EntityAggregate_ptr
SdaiShell::wire_shell_extent_() const
{
  if( CurrentUnderlyingType () == config_control_designe_wire_shell )
	//  WIRE_SHELL
	return ((SdaiWire_shell_ptr) _app_inst) ->wire_shell_extent_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiShell::wire_shell_extent_ (const EntityAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_wire_shell )
	//  WIRE_SHELL
	{  ((SdaiWire_shell_ptr) _app_inst) ->wire_shell_extent_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiVertex_loop_ptr
SdaiShell::vertex_shell_extent_() const
{
  if( CurrentUnderlyingType () == config_control_designe_vertex_shell )
	//  VERTEX_SHELL
	return ((SdaiVertex_shell_ptr) _app_inst) ->vertex_shell_extent_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiShell::vertex_shell_extent_ (const SdaiVertex_loop_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_vertex_shell )
	//  VERTEX_SHELL
	{  ((SdaiVertex_shell_ptr) _app_inst) ->vertex_shell_extent_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiShell::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_vertex_shell )
	//  VERTEX_SHELL
	return ((SdaiVertex_shell_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_wire_shell )
	//  WIRE_SHELL
	return ((SdaiWire_shell_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_open_shell )
	//  OPEN_SHELL
	return ((SdaiOpen_shell_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_closed_shell )
	//  CLOSED_SHELL
	return ((SdaiClosed_shell_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiShell::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_vertex_shell )
	//  VERTEX_SHELL
	{  ((SdaiVertex_shell_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_wire_shell )
	//  WIRE_SHELL
	{  ((SdaiWire_shell_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_open_shell )
	//  OPEN_SHELL
	{  ((SdaiOpen_shell_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_closed_shell )
	//  CLOSED_SHELL
	{  ((SdaiClosed_shell_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiShell& SdaiShell::operator =( const SdaiVertex_shell_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_vertex_shell);
   return *this;
}

SdaiShell& SdaiShell::operator =( const SdaiWire_shell_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_wire_shell);
   return *this;
}

SdaiShell& SdaiShell::operator =( const SdaiOpen_shell_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_open_shell);
   return *this;
}

SdaiShell& SdaiShell::operator =( const SdaiClosed_shell_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_closed_shell);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiShell& SdaiShell::operator =( const SdaiShell_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_vertex_shell )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_wire_shell )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_open_shell )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_closed_shell )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiShell::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_vertex_shell )
	_app_inst = ((SdaiShell&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_wire_shell )
	_app_inst = ((SdaiShell&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_open_shell )
	_app_inst = ((SdaiShell&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_closed_shell )
	_app_inst = ((SdaiShell&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiShell::IsVertex_shell() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_vertex_shell )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiShell::IsWire_shell() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_wire_shell )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiShell::IsOpen_shell() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_open_shell )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiShell::IsClosed_shell() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_closed_shell )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiShell


//////////  SELECT TYPE transformation

const TypeDescriptor *
SdaiTransformation::AssignEntity (SCLP23(Application_instance) * se)
{
  //  ITEM_DEFINED_TRANSFORMATION
  if (se -> IsA (config_control_designe_item_defined_transformation))
  {
	_app_inst = (SdaiItem_defined_transformation_ptr) se;
	return SetUnderlyingType (config_control_designe_item_defined_transformation);
  }
  //  FUNCTIONALLY_DEFINED_TRANSFORMATION
  if (se -> IsA (config_control_designe_functionally_defined_transformation))
  {
	_app_inst = (SdaiFunctionally_defined_transformation_ptr) se;
	return SetUnderlyingType (config_control_designe_functionally_defined_transformation);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiTransformation::NewSelect ()
{
#ifdef __OSTORE__
    SdaiTransformation * tmp =
		new( os_segment::of(this),
		     SdaiTransformation::get_os_typespec() )
			SdaiTransformation();
#else
    SdaiTransformation * tmp = new SdaiTransformation();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiTransformation::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_item_defined_transformation)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiTransformation::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_item_defined_transformation)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_functionally_defined_transformation)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiTransformation::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_item_defined_transformation)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_functionally_defined_transformation)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiTransformation::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_item_defined_transformation)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiTransformation::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiTransformation (os_database *db)
{
    return new (db, SdaiTransformation::get_os_typespec())
		SdaiTransformation ;
}

void
SdaiTransformation_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiTransformation access hook funct called." << endl;
    }
#endif
    SdaiTransformation *s = (SdaiTransformation *) object;
    s->_type = config_control_designt_transformation;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiTransformations (os_database *db)
{
    return new (db, SdaiTransformations::get_os_typespec())
		SdaiTransformations ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiTransformation::SdaiTransformation( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiTransformation constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiTransformation constructor." << endl;
    }
#endif
}

	//  part 1
SdaiTransformation::SdaiTransformation( const SdaiItem_defined_transformation_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_item_defined_transformation)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiTransformation constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiTransformation constructor." << endl;
    }
#endif
}

SdaiTransformation::SdaiTransformation( const SdaiFunctionally_defined_transformation_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_functionally_defined_transformation)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiTransformation constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiTransformation constructor." << endl;
    }
#endif
}

SdaiTransformation::~SdaiTransformation()
{
}

SdaiTransformations::SdaiTransformations( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiTransformations::~SdaiTransformations() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiTransformations::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiTransformation::get_os_typespec() )
		    SdaiTransformation );
}
#endif


	//  part 2
SdaiTransformation::operator SdaiItem_defined_transformation_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
      return ((SdaiItem_defined_transformation_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiTransformation::operator SdaiFunctionally_defined_transformation_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
      return ((SdaiFunctionally_defined_transformation_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiRepresentation_item_ptr
SdaiTransformation::transform_item_2_() const
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	//  ITEM_DEFINED_TRANSFORMATION
	return ((SdaiItem_defined_transformation_ptr) _app_inst) ->transform_item_2_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiTransformation::transform_item_2_ (const SdaiRepresentation_item_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	//  ITEM_DEFINED_TRANSFORMATION
	{  ((SdaiItem_defined_transformation_ptr) _app_inst) ->transform_item_2_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiRepresentation_item_ptr
SdaiTransformation::transform_item_1_() const
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	//  ITEM_DEFINED_TRANSFORMATION
	return ((SdaiItem_defined_transformation_ptr) _app_inst) ->transform_item_1_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiTransformation::transform_item_1_ (const SdaiRepresentation_item_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	//  ITEM_DEFINED_TRANSFORMATION
	{  ((SdaiItem_defined_transformation_ptr) _app_inst) ->transform_item_1_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiTransformation::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	//  ITEM_DEFINED_TRANSFORMATION
	return ((SdaiItem_defined_transformation_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
	//  FUNCTIONALLY_DEFINED_TRANSFORMATION
	return ((SdaiFunctionally_defined_transformation_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiTransformation::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	//  ITEM_DEFINED_TRANSFORMATION
	{  ((SdaiItem_defined_transformation_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
	//  FUNCTIONALLY_DEFINED_TRANSFORMATION
	{  ((SdaiFunctionally_defined_transformation_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiTransformation::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	//  ITEM_DEFINED_TRANSFORMATION
	return ((SdaiItem_defined_transformation_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
	//  FUNCTIONALLY_DEFINED_TRANSFORMATION
	return ((SdaiFunctionally_defined_transformation_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiTransformation::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	//  ITEM_DEFINED_TRANSFORMATION
	{  ((SdaiItem_defined_transformation_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
	//  FUNCTIONALLY_DEFINED_TRANSFORMATION
	{  ((SdaiFunctionally_defined_transformation_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiTransformation& SdaiTransformation::operator =( const SdaiItem_defined_transformation_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_item_defined_transformation);
   return *this;
}

SdaiTransformation& SdaiTransformation::operator =( const SdaiFunctionally_defined_transformation_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_functionally_defined_transformation);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiTransformation& SdaiTransformation::operator =( const SdaiTransformation_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiTransformation::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	_app_inst = ((SdaiTransformation&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
	_app_inst = ((SdaiTransformation&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiTransformation::IsItem_defined_transformation() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiTransformation::IsFunctionally_defined_transformation() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiTransformation


//////////  SELECT TYPE boolean_operand

const TypeDescriptor *
SdaiBoolean_operand::AssignEntity (SCLP23(Application_instance) * se)
{
  //  SOLID_MODEL
  if (se -> IsA (config_control_designe_solid_model))
  {
	_app_inst = (SdaiSolid_model_ptr) se;
	return SetUnderlyingType (config_control_designe_solid_model);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiBoolean_operand::NewSelect ()
{
#ifdef __OSTORE__
    SdaiBoolean_operand * tmp =
		new( os_segment::of(this),
		     SdaiBoolean_operand::get_os_typespec() )
			SdaiBoolean_operand();
#else
    SdaiBoolean_operand * tmp = new SdaiBoolean_operand();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiBoolean_operand::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_solid_model)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiBoolean_operand::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_solid_model)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiBoolean_operand::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_solid_model)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiBoolean_operand::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_solid_model)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiBoolean_operand::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiBoolean_operand (os_database *db)
{
    return new (db, SdaiBoolean_operand::get_os_typespec())
		SdaiBoolean_operand ;
}

void
SdaiBoolean_operand_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiBoolean_operand access hook funct called." << endl;
    }
#endif
    SdaiBoolean_operand *s = (SdaiBoolean_operand *) object;
    s->_type = config_control_designt_boolean_operand;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiBoolean_operands (os_database *db)
{
    return new (db, SdaiBoolean_operands::get_os_typespec())
		SdaiBoolean_operands ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiBoolean_operand::SdaiBoolean_operand( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiBoolean_operand constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiBoolean_operand constructor." << endl;
    }
#endif
}

	//  part 1
SdaiBoolean_operand::SdaiBoolean_operand( const SdaiSolid_model_ptr& o,
                                          const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_solid_model)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiBoolean_operand constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiBoolean_operand constructor." << endl;
    }
#endif
}

SdaiBoolean_operand::~SdaiBoolean_operand()
{
}

SdaiBoolean_operands::SdaiBoolean_operands( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiBoolean_operands::~SdaiBoolean_operands() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiBoolean_operands::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiBoolean_operand::get_os_typespec() )
		    SdaiBoolean_operand );
}
#endif


	//  part 2
SdaiBoolean_operand::operator SdaiSolid_model_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_solid_model )
      return ((SdaiSolid_model_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiLabel
SdaiBoolean_operand::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_solid_model )
	//  SOLID_MODEL
	return ((SdaiSolid_model_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiBoolean_operand::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_solid_model )
	//  SOLID_MODEL
	{  ((SdaiSolid_model_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiBoolean_operand& SdaiBoolean_operand::operator =( const SdaiSolid_model_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_solid_model);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiBoolean_operand& SdaiBoolean_operand::operator =( const SdaiBoolean_operand_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_solid_model )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiBoolean_operand::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_solid_model )
	_app_inst = ((SdaiBoolean_operand&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiBoolean_operand::IsSolid_model() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_solid_model )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiBoolean_operand


//////////  SELECT TYPE certified_item

const TypeDescriptor *
SdaiCertified_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  SUPPLIED_PART_RELATIONSHIP
  if (se -> IsA (config_control_designe_supplied_part_relationship))
  {
	_app_inst = (SdaiSupplied_part_relationship_ptr) se;
	return SetUnderlyingType (config_control_designe_supplied_part_relationship);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiCertified_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiCertified_item * tmp =
		new( os_segment::of(this),
		     SdaiCertified_item::get_os_typespec() )
			SdaiCertified_item();
#else
    SdaiCertified_item * tmp = new SdaiCertified_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiCertified_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_supplied_part_relationship)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiCertified_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_supplied_part_relationship)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiCertified_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_supplied_part_relationship)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiCertified_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_supplied_part_relationship)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiCertified_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiCertified_item (os_database *db)
{
    return new (db, SdaiCertified_item::get_os_typespec())
		SdaiCertified_item ;
}

void
SdaiCertified_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiCertified_item access hook funct called." << endl;
    }
#endif
    SdaiCertified_item *s = (SdaiCertified_item *) object;
    s->_type = config_control_designt_certified_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiCertified_items (os_database *db)
{
    return new (db, SdaiCertified_items::get_os_typespec())
		SdaiCertified_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiCertified_item::SdaiCertified_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCertified_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCertified_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiCertified_item::SdaiCertified_item( const SdaiSupplied_part_relationship_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_supplied_part_relationship)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCertified_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCertified_item constructor." << endl;
    }
#endif
}

SdaiCertified_item::~SdaiCertified_item()
{
}

SdaiCertified_items::SdaiCertified_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiCertified_items::~SdaiCertified_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiCertified_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiCertified_item::get_os_typespec() )
		    SdaiCertified_item );
}
#endif


	//  part 2
SdaiCertified_item::operator SdaiSupplied_part_relationship_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
      return ((SdaiSupplied_part_relationship_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiProduct_definition_ptr
SdaiCertified_item::related_product_definition_() const
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	//  SUPPLIED_PART_RELATIONSHIP
	return ((SdaiSupplied_part_relationship_ptr) _app_inst) ->related_product_definition_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCertified_item::related_product_definition_ (const SdaiProduct_definition_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	//  SUPPLIED_PART_RELATIONSHIP
	{  ((SdaiSupplied_part_relationship_ptr) _app_inst) ->related_product_definition_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_ptr
SdaiCertified_item::relating_product_definition_() const
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	//  SUPPLIED_PART_RELATIONSHIP
	return ((SdaiSupplied_part_relationship_ptr) _app_inst) ->relating_product_definition_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCertified_item::relating_product_definition_ (const SdaiProduct_definition_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	//  SUPPLIED_PART_RELATIONSHIP
	{  ((SdaiSupplied_part_relationship_ptr) _app_inst) ->relating_product_definition_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiCertified_item::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	//  SUPPLIED_PART_RELATIONSHIP
	return ((SdaiSupplied_part_relationship_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCertified_item::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	//  SUPPLIED_PART_RELATIONSHIP
	{  ((SdaiSupplied_part_relationship_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiCertified_item::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	//  SUPPLIED_PART_RELATIONSHIP
	return ((SdaiSupplied_part_relationship_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCertified_item::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	//  SUPPLIED_PART_RELATIONSHIP
	{  ((SdaiSupplied_part_relationship_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiCertified_item::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	//  SUPPLIED_PART_RELATIONSHIP
	return ((SdaiSupplied_part_relationship_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCertified_item::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	//  SUPPLIED_PART_RELATIONSHIP
	{  ((SdaiSupplied_part_relationship_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiCertified_item& SdaiCertified_item::operator =( const SdaiSupplied_part_relationship_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_supplied_part_relationship);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiCertified_item& SdaiCertified_item::operator =( const SdaiCertified_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiCertified_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	_app_inst = ((SdaiCertified_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiCertified_item::IsSupplied_part_relationship() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiCertified_item


//////////  SELECT TYPE date_time_select

const TypeDescriptor *
SdaiDate_time_select::AssignEntity (SCLP23(Application_instance) * se)
{
  //  DATE
  if (se -> IsA (config_control_designe_date))
  {
	_app_inst = (SdaiDate_ptr) se;
	return SetUnderlyingType (config_control_designe_date);
  }
  //  LOCAL_TIME
  if (se -> IsA (config_control_designe_local_time))
  {
	_app_inst = (SdaiLocal_time_ptr) se;
	return SetUnderlyingType (config_control_designe_local_time);
  }
  //  DATE_AND_TIME
  if (se -> IsA (config_control_designe_date_and_time))
  {
	_app_inst = (SdaiDate_and_time_ptr) se;
	return SetUnderlyingType (config_control_designe_date_and_time);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiDate_time_select::NewSelect ()
{
#ifdef __OSTORE__
    SdaiDate_time_select * tmp =
		new( os_segment::of(this),
		     SdaiDate_time_select::get_os_typespec() )
			SdaiDate_time_select();
#else
    SdaiDate_time_select * tmp = new SdaiDate_time_select();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiDate_time_select::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_date)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_local_time)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_date_and_time)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiDate_time_select::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_date)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_local_time)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_date_and_time)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiDate_time_select::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_date)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_local_time)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_date_and_time)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiDate_time_select::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_date)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_local_time)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_date_and_time)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiDate_time_select::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiDate_time_select (os_database *db)
{
    return new (db, SdaiDate_time_select::get_os_typespec())
		SdaiDate_time_select ;
}

void
SdaiDate_time_select_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiDate_time_select access hook funct called." << endl;
    }
#endif
    SdaiDate_time_select *s = (SdaiDate_time_select *) object;
    s->_type = config_control_designt_date_time_select;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiDate_time_selects (os_database *db)
{
    return new (db, SdaiDate_time_selects::get_os_typespec())
		SdaiDate_time_selects ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiDate_time_select::SdaiDate_time_select( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_select constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_select constructor." << endl;
    }
#endif
}

	//  part 1
SdaiDate_time_select::SdaiDate_time_select( const SdaiDate_ptr& o,
                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_date)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_select constructor." << endl;
    }
#endif
}

SdaiDate_time_select::SdaiDate_time_select( const SdaiLocal_time_ptr& o,
                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_local_time)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_select constructor." << endl;
    }
#endif
}

SdaiDate_time_select::SdaiDate_time_select( const SdaiDate_and_time_ptr& o,
                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_date_and_time)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiDate_time_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiDate_time_select constructor." << endl;
    }
#endif
}

SdaiDate_time_select::~SdaiDate_time_select()
{
}

SdaiDate_time_selects::SdaiDate_time_selects( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiDate_time_selects::~SdaiDate_time_selects() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiDate_time_selects::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiDate_time_select::get_os_typespec() )
		    SdaiDate_time_select );
}
#endif


	//  part 2
SdaiDate_time_select::operator SdaiDate_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_date )
      return ((SdaiDate_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_select::operator SdaiLocal_time_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_local_time )
      return ((SdaiLocal_time_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_select::operator SdaiDate_and_time_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_date_and_time )
      return ((SdaiDate_and_time_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiLocal_time_ptr
SdaiDate_time_select::time_component_() const
{
  if( CurrentUnderlyingType () == config_control_designe_date_and_time )
	//  DATE_AND_TIME
	return ((SdaiDate_and_time_ptr) _app_inst) ->time_component_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_select::time_component_ (const SdaiLocal_time_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_date_and_time )
	//  DATE_AND_TIME
	{  ((SdaiDate_and_time_ptr) _app_inst) ->time_component_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiDate_ptr
SdaiDate_time_select::date_component_() const
{
  if( CurrentUnderlyingType () == config_control_designe_date_and_time )
	//  DATE_AND_TIME
	return ((SdaiDate_and_time_ptr) _app_inst) ->date_component_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_select::date_component_ (const SdaiDate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_date_and_time )
	//  DATE_AND_TIME
	{  ((SdaiDate_and_time_ptr) _app_inst) ->date_component_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiCoordinated_universal_time_offset_ptr
SdaiDate_time_select::zone_() const
{
  if( CurrentUnderlyingType () == config_control_designe_local_time )
	//  LOCAL_TIME
	return ((SdaiLocal_time_ptr) _app_inst) ->zone_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_select::zone_ (const SdaiCoordinated_universal_time_offset_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_local_time )
	//  LOCAL_TIME
	{  ((SdaiLocal_time_ptr) _app_inst) ->zone_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiSecond_in_minute
SdaiDate_time_select::second_component_() const
{
  if( CurrentUnderlyingType () == config_control_designe_local_time )
	//  LOCAL_TIME
	return ((SdaiLocal_time_ptr) _app_inst) ->second_component_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_select::second_component_ (const SdaiSecond_in_minute x)

{
  if( CurrentUnderlyingType () == config_control_designe_local_time )
	//  LOCAL_TIME
	{  ((SdaiLocal_time_ptr) _app_inst) ->second_component_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiMinute_in_hour
SdaiDate_time_select::minute_component_() const
{
  if( CurrentUnderlyingType () == config_control_designe_local_time )
	//  LOCAL_TIME
	return ((SdaiLocal_time_ptr) _app_inst) ->minute_component_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_select::minute_component_ (const SdaiMinute_in_hour x)

{
  if( CurrentUnderlyingType () == config_control_designe_local_time )
	//  LOCAL_TIME
	{  ((SdaiLocal_time_ptr) _app_inst) ->minute_component_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiHour_in_day
SdaiDate_time_select::hour_component_() const
{
  if( CurrentUnderlyingType () == config_control_designe_local_time )
	//  LOCAL_TIME
	return ((SdaiLocal_time_ptr) _app_inst) ->hour_component_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_select::hour_component_ (const SdaiHour_in_day x)

{
  if( CurrentUnderlyingType () == config_control_designe_local_time )
	//  LOCAL_TIME
	{  ((SdaiLocal_time_ptr) _app_inst) ->hour_component_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiYear_number
SdaiDate_time_select::year_component_() const
{
  if( CurrentUnderlyingType () == config_control_designe_date )
	//  DATE
	return ((SdaiDate_ptr) _app_inst) ->year_component_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiDate_time_select::year_component_ (const SdaiYear_number x)

{
  if( CurrentUnderlyingType () == config_control_designe_date )
	//  DATE
	{  ((SdaiDate_ptr) _app_inst) ->year_component_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiDate_time_select& SdaiDate_time_select::operator =( const SdaiDate_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_date);
   return *this;
}

SdaiDate_time_select& SdaiDate_time_select::operator =( const SdaiLocal_time_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_local_time);
   return *this;
}

SdaiDate_time_select& SdaiDate_time_select::operator =( const SdaiDate_and_time_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_date_and_time);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiDate_time_select& SdaiDate_time_select::operator =( const SdaiDate_time_select_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_date )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_local_time )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_date_and_time )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiDate_time_select::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_date )
	_app_inst = ((SdaiDate_time_select&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_local_time )
	_app_inst = ((SdaiDate_time_select&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_date_and_time )
	_app_inst = ((SdaiDate_time_select&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiDate_time_select::IsDate() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_date )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiDate_time_select::IsLocal_time() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_local_time )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiDate_time_select::IsDate_and_time() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_date_and_time )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiDate_time_select


//////////  SELECT TYPE curve_on_surface

const TypeDescriptor *
SdaiCurve_on_surface::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PCURVE
  if (se -> IsA (config_control_designe_pcurve))
  {
	_app_inst = (SdaiPcurve_ptr) se;
	return SetUnderlyingType (config_control_designe_pcurve);
  }
  //  SURFACE_CURVE
  if (se -> IsA (config_control_designe_surface_curve))
  {
	_app_inst = (SdaiSurface_curve_ptr) se;
	return SetUnderlyingType (config_control_designe_surface_curve);
  }
  //  COMPOSITE_CURVE_ON_SURFACE
  if (se -> IsA (config_control_designe_composite_curve_on_surface))
  {
	_app_inst = (SdaiComposite_curve_on_surface_ptr) se;
	return SetUnderlyingType (config_control_designe_composite_curve_on_surface);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiCurve_on_surface::NewSelect ()
{
#ifdef __OSTORE__
    SdaiCurve_on_surface * tmp =
		new( os_segment::of(this),
		     SdaiCurve_on_surface::get_os_typespec() )
			SdaiCurve_on_surface();
#else
    SdaiCurve_on_surface * tmp = new SdaiCurve_on_surface();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiCurve_on_surface::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_pcurve)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_surface_curve)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiCurve_on_surface::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_pcurve)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_surface_curve)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_composite_curve_on_surface)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiCurve_on_surface::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_pcurve)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_surface_curve)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_composite_curve_on_surface)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiCurve_on_surface::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_pcurve)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_surface_curve)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiCurve_on_surface::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiCurve_on_surface (os_database *db)
{
    return new (db, SdaiCurve_on_surface::get_os_typespec())
		SdaiCurve_on_surface ;
}

void
SdaiCurve_on_surface_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiCurve_on_surface access hook funct called." << endl;
    }
#endif
    SdaiCurve_on_surface *s = (SdaiCurve_on_surface *) object;
    s->_type = config_control_designt_curve_on_surface;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiCurve_on_surfaces (os_database *db)
{
    return new (db, SdaiCurve_on_surfaces::get_os_typespec())
		SdaiCurve_on_surfaces ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiCurve_on_surface::SdaiCurve_on_surface( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCurve_on_surface constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCurve_on_surface constructor." << endl;
    }
#endif
}

	//  part 1
SdaiCurve_on_surface::SdaiCurve_on_surface( const SdaiPcurve_ptr& o,
                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_pcurve)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCurve_on_surface constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCurve_on_surface constructor." << endl;
    }
#endif
}

SdaiCurve_on_surface::SdaiCurve_on_surface( const SdaiSurface_curve_ptr& o,
                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_surface_curve)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCurve_on_surface constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCurve_on_surface constructor." << endl;
    }
#endif
}

SdaiCurve_on_surface::SdaiCurve_on_surface( const SdaiComposite_curve_on_surface_ptr& o,
                                            const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_composite_curve_on_surface)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiCurve_on_surface constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiCurve_on_surface constructor." << endl;
    }
#endif
}

SdaiCurve_on_surface::~SdaiCurve_on_surface()
{
}

SdaiCurve_on_surfaces::SdaiCurve_on_surfaces( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiCurve_on_surfaces::~SdaiCurve_on_surfaces() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiCurve_on_surfaces::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiCurve_on_surface::get_os_typespec() )
		    SdaiCurve_on_surface );
}
#endif


	//  part 2
SdaiCurve_on_surface::operator SdaiPcurve_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_pcurve )
      return ((SdaiPcurve_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiCurve_on_surface::operator SdaiSurface_curve_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_surface_curve )
      return ((SdaiSurface_curve_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiCurve_on_surface::operator SdaiComposite_curve_on_surface_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
      return ((SdaiComposite_curve_on_surface_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SCLLOG(Logical)
SdaiCurve_on_surface::self_intersect_() const
{
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
	//  COMPOSITE_CURVE_ON_SURFACE
	return ((SdaiComposite_curve_on_surface_ptr) _app_inst) ->self_intersect_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return (SCLLOG(Logical)) 0;
}


void
SdaiCurve_on_surface::self_intersect_ (const SCLLOG(Logical) x)

{
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
	//  COMPOSITE_CURVE_ON_SURFACE
	{  ((SdaiComposite_curve_on_surface_ptr) _app_inst) ->self_intersect_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const EntityAggregate_ptr
SdaiCurve_on_surface::segments_() const
{
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
	//  COMPOSITE_CURVE_ON_SURFACE
	return ((SdaiComposite_curve_on_surface_ptr) _app_inst) ->segments_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCurve_on_surface::segments_ (const EntityAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
	//  COMPOSITE_CURVE_ON_SURFACE
	{  ((SdaiComposite_curve_on_surface_ptr) _app_inst) ->segments_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiPreferred_surface_curve_representation_var
SdaiCurve_on_surface::master_representation_() const
{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve )
	//  SURFACE_CURVE
	return ((SdaiSurface_curve_ptr) _app_inst) ->master_representation_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return (Preferred_surface_curve_representation) 0;
}


void
SdaiCurve_on_surface::master_representation_ (const SdaiPreferred_surface_curve_representation_var x)

{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve )
	//  SURFACE_CURVE
	{  ((SdaiSurface_curve_ptr) _app_inst) ->master_representation_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiPcurve_or_surfaces_ptr
SdaiCurve_on_surface::associated_geometry_() const
{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve )
	//  SURFACE_CURVE
	return ((SdaiSurface_curve_ptr) _app_inst) ->associated_geometry_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCurve_on_surface::associated_geometry_ (const SdaiPcurve_or_surfaces_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve )
	//  SURFACE_CURVE
	{  ((SdaiSurface_curve_ptr) _app_inst) ->associated_geometry_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiCurve_ptr
SdaiCurve_on_surface::curve_3d_() const
{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve )
	//  SURFACE_CURVE
	return ((SdaiSurface_curve_ptr) _app_inst) ->curve_3d_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCurve_on_surface::curve_3d_ (const SdaiCurve_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve )
	//  SURFACE_CURVE
	{  ((SdaiSurface_curve_ptr) _app_inst) ->curve_3d_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiDefinitional_representation_ptr
SdaiCurve_on_surface::reference_to_curve_() const
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	return ((SdaiPcurve_ptr) _app_inst) ->reference_to_curve_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCurve_on_surface::reference_to_curve_ (const SdaiDefinitional_representation_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	{  ((SdaiPcurve_ptr) _app_inst) ->reference_to_curve_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiSurface_ptr
SdaiCurve_on_surface::basis_surface_() const
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	return ((SdaiPcurve_ptr) _app_inst) ->basis_surface_();
  //  for SURFACE_CURVE  attribute is derived
  //  for COMPOSITE_CURVE_ON_SURFACE  attribute is derived
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCurve_on_surface::basis_surface_ (const SdaiSurface_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	{  ((SdaiPcurve_ptr) _app_inst) ->basis_surface_( x );
	  return;
	}
  //  for SURFACE_CURVE  attribute is derived
  //  for COMPOSITE_CURVE_ON_SURFACE  attribute is derived

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiCurve_on_surface::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	return ((SdaiPcurve_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_surface_curve )
	//  SURFACE_CURVE
	return ((SdaiSurface_curve_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
	//  COMPOSITE_CURVE_ON_SURFACE
	return ((SdaiComposite_curve_on_surface_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiCurve_on_surface::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_pcurve )
	//  PCURVE
	{  ((SdaiPcurve_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_surface_curve )
	//  SURFACE_CURVE
	{  ((SdaiSurface_curve_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
	//  COMPOSITE_CURVE_ON_SURFACE
	{  ((SdaiComposite_curve_on_surface_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiCurve_on_surface& SdaiCurve_on_surface::operator =( const SdaiPcurve_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_pcurve);
   return *this;
}

SdaiCurve_on_surface& SdaiCurve_on_surface::operator =( const SdaiSurface_curve_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_surface_curve);
   return *this;
}

SdaiCurve_on_surface& SdaiCurve_on_surface::operator =( const SdaiComposite_curve_on_surface_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_composite_curve_on_surface);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiCurve_on_surface& SdaiCurve_on_surface::operator =( const SdaiCurve_on_surface_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_pcurve )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_surface_curve )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiCurve_on_surface::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_pcurve )
	_app_inst = ((SdaiCurve_on_surface&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_surface_curve )
	_app_inst = ((SdaiCurve_on_surface&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
	_app_inst = ((SdaiCurve_on_surface&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiCurve_on_surface::IsPcurve() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_pcurve )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiCurve_on_surface::IsSurface_curve() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_surface_curve )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiCurve_on_surface::IsComposite_curve_on_surface() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiCurve_on_surface


//////////  SELECT TYPE trimming_select

const TypeDescriptor *
SdaiTrimming_select::AssignEntity (SCLP23(Application_instance) * se)
{
  //  CARTESIAN_POINT
  if (se -> IsA (config_control_designe_cartesian_point))
  {
	_app_inst = (SdaiCartesian_point_ptr) se;
	return SetUnderlyingType (config_control_designe_cartesian_point);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiTrimming_select::NewSelect ()
{
#ifdef __OSTORE__
    SdaiTrimming_select * tmp =
		new( os_segment::of(this),
		     SdaiTrimming_select::get_os_typespec() )
			SdaiTrimming_select();
#else
    SdaiTrimming_select * tmp = new SdaiTrimming_select();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiTrimming_select::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_cartesian_point)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designt_parameter_value)
	WriteReal(_real,out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiTrimming_select::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_cartesian_point)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designt_parameter_value)
    return sdaiREAL;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiTrimming_select::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_cartesian_point)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designt_parameter_value)
  {
    out << tmp.chars() << "(";
    WriteReal(_real,out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiTrimming_select::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_cartesian_point)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designt_parameter_value)   {
	ReadReal (_real, in, &_error, "),");
	return severity ();
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiTrimming_select::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiTrimming_select (os_database *db)
{
    return new (db, SdaiTrimming_select::get_os_typespec())
		SdaiTrimming_select ;
}

void
SdaiTrimming_select_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiTrimming_select access hook funct called." << endl;
    }
#endif
    SdaiTrimming_select *s = (SdaiTrimming_select *) object;
    s->_type = config_control_designt_trimming_select;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiTrimming_selects (os_database *db)
{
    return new (db, SdaiTrimming_selects::get_os_typespec())
		SdaiTrimming_selects ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiTrimming_select::SdaiTrimming_select( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiTrimming_select constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiTrimming_select constructor." << endl;
    }
#endif
}

	//  part 1
SdaiTrimming_select::SdaiTrimming_select( const SdaiCartesian_point_ptr& o,
                                          const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_cartesian_point)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiTrimming_select constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiTrimming_select constructor." << endl;
    }
#endif
}

SdaiTrimming_select::SdaiTrimming_select( const SdaiParameter_value& o,
                                          const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designt_parameter_value)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiTrimming_select constructor." << endl;
    }
#endif
   _real = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiTrimming_select constructor." << endl;
    }
#endif
}

SdaiTrimming_select::~SdaiTrimming_select()
{
}

SdaiTrimming_selects::SdaiTrimming_selects( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiTrimming_selects::~SdaiTrimming_selects() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiTrimming_selects::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiTrimming_select::get_os_typespec() )
		    SdaiTrimming_select );
}
#endif


	//  part 2
SdaiTrimming_select::operator SdaiCartesian_point_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_cartesian_point )
      return ((SdaiCartesian_point_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiTrimming_select::operator SdaiParameter_value()
{
   if( CurrentUnderlyingType () == config_control_designt_parameter_value )
      return  _real;

   severity( SEVERITY_WARNING );
   Error( "Underlying type is not SdaiParameter_value" );

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return 0;
}


	//  part 3

const RealAggregate_ptr
SdaiTrimming_select::coordinates_() const
{
  if( CurrentUnderlyingType () == config_control_designe_cartesian_point )
	//  CARTESIAN_POINT
	return ((SdaiCartesian_point_ptr) _app_inst) ->coordinates_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiTrimming_select::coordinates_ (const RealAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_cartesian_point )
	//  CARTESIAN_POINT
	{  ((SdaiCartesian_point_ptr) _app_inst) ->coordinates_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiTrimming_select::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_cartesian_point )
	//  CARTESIAN_POINT
	return ((SdaiCartesian_point_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiTrimming_select::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_cartesian_point )
	//  CARTESIAN_POINT
	{  ((SdaiCartesian_point_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiTrimming_select& SdaiTrimming_select::operator =( const SdaiCartesian_point_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_cartesian_point);
   return *this;
}

SdaiTrimming_select& SdaiTrimming_select::operator =( const SdaiParameter_value& o )
{
   nullify ();
   _real = o;
   SetUnderlyingType (config_control_designt_parameter_value);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiTrimming_select& SdaiTrimming_select::operator =( const SdaiTrimming_select_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_cartesian_point )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_parameter_value )
	_real =  o -> _real;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiTrimming_select::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_cartesian_point )
	_app_inst = ((SdaiTrimming_select&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designt_parameter_value )
	_real = ((SdaiTrimming_select&) o)._real;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiTrimming_select::IsCartesian_point() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_cartesian_point )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiTrimming_select::IsParameter_value() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_parameter_value )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiTrimming_select


//////////  SELECT TYPE contracted_item

const TypeDescriptor *
SdaiContracted_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> IsA (config_control_designe_product_definition_formation))
  {
	_app_inst = (SdaiProduct_definition_formation_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiContracted_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiContracted_item * tmp =
		new( os_segment::of(this),
		     SdaiContracted_item::get_os_typespec() )
			SdaiContracted_item();
#else
    SdaiContracted_item * tmp = new SdaiContracted_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiContracted_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiContracted_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_product_definition_formation)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiContracted_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_product_definition_formation)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiContracted_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiContracted_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiContracted_item (os_database *db)
{
    return new (db, SdaiContracted_item::get_os_typespec())
		SdaiContracted_item ;
}

void
SdaiContracted_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiContracted_item access hook funct called." << endl;
    }
#endif
    SdaiContracted_item *s = (SdaiContracted_item *) object;
    s->_type = config_control_designt_contracted_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiContracted_items (os_database *db)
{
    return new (db, SdaiContracted_items::get_os_typespec())
		SdaiContracted_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiContracted_item::SdaiContracted_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiContracted_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiContracted_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiContracted_item::SdaiContracted_item( const SdaiProduct_definition_formation_ptr& o,
                                          const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition_formation)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiContracted_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiContracted_item constructor." << endl;
    }
#endif
}

SdaiContracted_item::~SdaiContracted_item()
{
}

SdaiContracted_items::SdaiContracted_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiContracted_items::~SdaiContracted_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiContracted_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiContracted_item::get_os_typespec() )
		    SdaiContracted_item );
}
#endif


	//  part 2
SdaiContracted_item::operator SdaiProduct_definition_formation_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formation_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiProduct_ptr
SdaiContracted_item::of_product_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiContracted_item::of_product_ (const SdaiProduct_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiContracted_item::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiContracted_item::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiContracted_item::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiContracted_item::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiContracted_item& SdaiContracted_item::operator =( const SdaiProduct_definition_formation_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiContracted_item& SdaiContracted_item::operator =( const SdaiContracted_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiContracted_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst = ((SdaiContracted_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiContracted_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiContracted_item


//////////  SELECT TYPE unit

const TypeDescriptor *
SdaiUnit::AssignEntity (SCLP23(Application_instance) * se)
{
  //  NAMED_UNIT
  if (se -> IsA (config_control_designe_named_unit))
  {
	_app_inst = (SdaiNamed_unit_ptr) se;
	return SetUnderlyingType (config_control_designe_named_unit);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiUnit::NewSelect ()
{
#ifdef __OSTORE__
    SdaiUnit * tmp =
		new( os_segment::of(this),
		     SdaiUnit::get_os_typespec() )
			SdaiUnit();
#else
    SdaiUnit * tmp = new SdaiUnit();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiUnit::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_named_unit)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiUnit::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_named_unit)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiUnit::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_named_unit)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiUnit::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_named_unit)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiUnit::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiUnit (os_database *db)
{
    return new (db, SdaiUnit::get_os_typespec())
		SdaiUnit ;
}

void
SdaiUnit_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiUnit access hook funct called." << endl;
    }
#endif
    SdaiUnit *s = (SdaiUnit *) object;
    s->_type = config_control_designt_unit;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiUnits (os_database *db)
{
    return new (db, SdaiUnits::get_os_typespec())
		SdaiUnits ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiUnit::SdaiUnit( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiUnit constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiUnit constructor." << endl;
    }
#endif
}

	//  part 1
SdaiUnit::SdaiUnit( const SdaiNamed_unit_ptr& o,
                    const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_named_unit)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiUnit constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiUnit constructor." << endl;
    }
#endif
}

SdaiUnit::~SdaiUnit()
{
}

SdaiUnits::SdaiUnits( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiUnits::~SdaiUnits() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiUnits::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiUnit::get_os_typespec() )
		    SdaiUnit );
}
#endif


	//  part 2
SdaiUnit::operator SdaiNamed_unit_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_named_unit )
      return ((SdaiNamed_unit_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiDimensional_exponents_ptr
SdaiUnit::dimensions_() const
{
  if( CurrentUnderlyingType () == config_control_designe_named_unit )
	//  NAMED_UNIT
	return ((SdaiNamed_unit_ptr) _app_inst) ->dimensions_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiUnit::dimensions_ (const SdaiDimensional_exponents_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_named_unit )
	//  NAMED_UNIT
	{  ((SdaiNamed_unit_ptr) _app_inst) ->dimensions_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiUnit& SdaiUnit::operator =( const SdaiNamed_unit_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_named_unit);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiUnit& SdaiUnit::operator =( const SdaiUnit_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_named_unit )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiUnit::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_named_unit )
	_app_inst = ((SdaiUnit&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiUnit::IsNamed_unit() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_named_unit )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiUnit


//////////  SELECT TYPE reversible_topology

const TypeDescriptor *
SdaiReversible_topology::AssignEntity (SCLP23(Application_instance) * se)
{
  //  REVERSIBLE_TOPOLOGY_ITEM
  if (config_control_designt_reversible_topology_item -> CanBe (se -> eDesc))
  {
	_sdaireversible_topology_item.AssignEntity (se);
	return SetUnderlyingType (config_control_designt_reversible_topology_item);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiReversible_topology::NewSelect ()
{
#ifdef __OSTORE__
    SdaiReversible_topology * tmp =
		new( os_segment::of(this),
		     SdaiReversible_topology::get_os_typespec() )
			SdaiReversible_topology();
#else
    SdaiReversible_topology * tmp = new SdaiReversible_topology();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiReversible_topology::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designt_reversible_topology_item)
	_sdaireversible_topology_item.STEPwrite (out, currSch);
  else if (CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item)
	_sdaireversible_topology_items.STEPwrite (out);
  else if (CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item)
	_sdaireversible_topology_items.STEPwrite (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiReversible_topology::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designt_reversible_topology_item)
    return _sdaireversible_topology_item.ValueType();
  else if (CurrentUnderlyingType() == config_control_designt_list_of_reversible_topology_item)
    return LIST_TYPE;
  else if (CurrentUnderlyingType() == config_control_designt_set_of_reversible_topology_item)
    return SET_TYPE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiReversible_topology::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designt_reversible_topology_item)
  {
    out << tmp.chars() << "(";
    _sdaireversible_topology_item.STEPwrite_verbose (out, currSch);
    out << ")";
  }
  else if (td == config_control_designt_list_of_reversible_topology_item)
  {
    out << tmp.chars() << "(";
    _sdaireversible_topology_items.STEPwrite (out, currSch);
    out << ")";
  }
  else if (td == config_control_designt_set_of_reversible_topology_item)
  {
    out << tmp.chars() << "(";
    _sdaireversible_topology_items.STEPwrite (out, currSch);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiReversible_topology::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designt_reversible_topology_item)   {
	_sdaireversible_topology_item.STEPread (in, &_error, instances, utype, addFileId, currSch);
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item)   {
	_sdaireversible_topology_items.STEPread (in, &_error,
			     config_control_designt_list_of_reversible_topology_item -> AggrElemTypeDescriptor (),
			     instances, addFileId, currSch);
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item)   {
	_sdaireversible_topology_items.STEPread (in, &_error,
			     config_control_designt_set_of_reversible_topology_item -> AggrElemTypeDescriptor (),
			     instances, addFileId, currSch);
	return severity ();
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiReversible_topology::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  case LIST_TYPE :
	return _sdaireversible_topology_items.StrToVal (str, &_error, config_control_designt_list_of_reversible_topology_item -> AggrElemTypeDescriptor ());
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiReversible_topology (os_database *db)
{
    return new (db, SdaiReversible_topology::get_os_typespec())
		SdaiReversible_topology ;
}

void
SdaiReversible_topology_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiReversible_topology access hook funct called." << endl;
    }
#endif
    SdaiReversible_topology *s = (SdaiReversible_topology *) object;
    s->_type = config_control_designt_reversible_topology;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiReversible_topologys (os_database *db)
{
    return new (db, SdaiReversible_topologys::get_os_typespec())
		SdaiReversible_topologys ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiReversible_topology::SdaiReversible_topology( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript),
    _sdaireversible_topology_item (config_control_designt_reversible_topology_item)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiReversible_topology constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiReversible_topology constructor." << endl;
    }
#endif
}

	//  part 1
SdaiReversible_topology::SdaiReversible_topology( const SdaiReversible_topology_item_ptr& o,
                                                  const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designt_reversible_topology_item),
    _sdaireversible_topology_item (config_control_designt_reversible_topology_item)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiReversible_topology constructor." << endl;
    }
#endif
   _sdaireversible_topology_item = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiReversible_topology constructor." << endl;
    }
#endif
}

SdaiReversible_topology::SdaiReversible_topology( const SdaiSet_of_reversible_topology_item_ptr& o,
                                                  const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) ( typedescript, config_control_designt_set_of_reversible_topology_item ),
    _sdaireversible_topology_item (config_control_designt_reversible_topology_item)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiReversible_topology constructor." << endl;
    }
#endif
   _sdaireversible_topology_items.ShallowCopy (*o);
//  NOTE:  Underlying type defaults to config_control_designt_set_of_reversible_topology_item instead of NULL
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiReversible_topology constructor." << endl;
    }
#endif
}

SdaiReversible_topology::~SdaiReversible_topology()
{
}

SdaiReversible_topologys::SdaiReversible_topologys( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiReversible_topologys::~SdaiReversible_topologys() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiReversible_topologys::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiReversible_topology::get_os_typespec() )
		    SdaiReversible_topology );
}
#endif


	//  part 2
SdaiReversible_topology::operator SdaiReversible_topology_item_ptr()
{
   if( CurrentUnderlyingType () == config_control_designt_reversible_topology_item )
      return & _sdaireversible_topology_item;

   severity( SEVERITY_WARNING );
   Error( "Underlying type is not SdaiReversible_topology_item_ptr" );

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return 0;
}

SdaiReversible_topology::operator SdaiSet_of_reversible_topology_item_ptr()
{
   if( CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item )
      return & _sdaireversible_topology_items;
   if( CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item )
      return & _sdaireversible_topology_items;

   severity( SEVERITY_WARNING );
   Error( "Underlying type is not SdaiSet_of_reversible_topology_item_ptr" );

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return (SdaiSet_of_reversible_topology_item_ptr)0;
}


	//  part 3

	//  part 4
SdaiReversible_topology& SdaiReversible_topology::operator =( const SdaiReversible_topology_item_ptr& o )
{
   nullify ();
   _sdaireversible_topology_item = o;
   SetUnderlyingType (config_control_designt_reversible_topology_item);
   return *this;
}

SdaiReversible_topology& SdaiReversible_topology::operator =( const SdaiSet_of_reversible_topology_item_ptr& o )
{
   _sdaireversible_topology_items.ShallowCopy (*o);
   underlying_type = 0; // MUST BE SET BY USER
#ifdef __OSTORE__
  underlying_type_name.set_null();
#endif
   //	discriminator = UNSET
   return *this;
}

#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiReversible_topology& SdaiReversible_topology::operator =( const SdaiReversible_topology_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designt_reversible_topology_item )
	_sdaireversible_topology_item =  &(o -> _sdaireversible_topology_item);
   else if ( o -> CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item )
      _sdaireversible_topology_items = o -> _sdaireversible_topology_items;
   else if ( o -> CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item )
      _sdaireversible_topology_items = o -> _sdaireversible_topology_items;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiReversible_topology::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designt_reversible_topology_item )
	_sdaireversible_topology_item = &(((SdaiReversible_topology&) o)._sdaireversible_topology_item);
   else if ( o.CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item )
	_sdaireversible_topology_items = ((SdaiReversible_topology&) o)._sdaireversible_topology_items;
   else if ( o.CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item )
	_sdaireversible_topology_items = ((SdaiReversible_topology&) o)._sdaireversible_topology_items;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiReversible_topology::IsReversible_topology_item() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_reversible_topology_item )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiReversible_topology::IsList_of_reversible_topology_item() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiReversible_topology::IsSet_of_reversible_topology_item() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}


	//  part 7
const TypeDescriptor *
SdaiReversible_topology::SetUnderlyingType (const TypeDescriptor * td)
{
  return SCLP23(Select)::SetUnderlyingType (td);
}
//////////  END SELECT TYPE SdaiReversible_topology


//////////  SELECT TYPE work_item

const TypeDescriptor *
SdaiWork_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> IsA (config_control_designe_product_definition_formation))
  {
	_app_inst = (SdaiProduct_definition_formation_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiWork_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiWork_item * tmp =
		new( os_segment::of(this),
		     SdaiWork_item::get_os_typespec() )
			SdaiWork_item();
#else
    SdaiWork_item * tmp = new SdaiWork_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiWork_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiWork_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_product_definition_formation)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiWork_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_product_definition_formation)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiWork_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiWork_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiWork_item (os_database *db)
{
    return new (db, SdaiWork_item::get_os_typespec())
		SdaiWork_item ;
}

void
SdaiWork_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiWork_item access hook funct called." << endl;
    }
#endif
    SdaiWork_item *s = (SdaiWork_item *) object;
    s->_type = config_control_designt_work_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiWork_items (os_database *db)
{
    return new (db, SdaiWork_items::get_os_typespec())
		SdaiWork_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiWork_item::SdaiWork_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiWork_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiWork_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiWork_item::SdaiWork_item( const SdaiProduct_definition_formation_ptr& o,
                              const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition_formation)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiWork_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiWork_item constructor." << endl;
    }
#endif
}

SdaiWork_item::~SdaiWork_item()
{
}

SdaiWork_items::SdaiWork_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiWork_items::~SdaiWork_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiWork_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiWork_item::get_os_typespec() )
		    SdaiWork_item );
}
#endif


	//  part 2
SdaiWork_item::operator SdaiProduct_definition_formation_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formation_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiProduct_ptr
SdaiWork_item::of_product_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiWork_item::of_product_ (const SdaiProduct_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiWork_item::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiWork_item::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiWork_item::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiWork_item::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiWork_item& SdaiWork_item::operator =( const SdaiProduct_definition_formation_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiWork_item& SdaiWork_item::operator =( const SdaiWork_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiWork_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst = ((SdaiWork_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiWork_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiWork_item


//////////  SELECT TYPE supported_item

const TypeDescriptor *
SdaiSupported_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  ACTION_DIRECTIVE
  if (se -> IsA (config_control_designe_action_directive))
  {
	_app_inst = (SdaiAction_directive_ptr) se;
	return SetUnderlyingType (config_control_designe_action_directive);
  }
  //  ACTION
  if (se -> IsA (config_control_designe_action))
  {
	_app_inst = (SdaiAction_ptr) se;
	return SetUnderlyingType (config_control_designe_action);
  }
  //  ACTION_METHOD
  if (se -> IsA (config_control_designe_action_method))
  {
	_app_inst = (SdaiAction_method_ptr) se;
	return SetUnderlyingType (config_control_designe_action_method);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiSupported_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiSupported_item * tmp =
		new( os_segment::of(this),
		     SdaiSupported_item::get_os_typespec() )
			SdaiSupported_item();
#else
    SdaiSupported_item * tmp = new SdaiSupported_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiSupported_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_action_directive)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_action)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_action_method)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiSupported_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_action_directive)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_action)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_action_method)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiSupported_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_action_directive)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_action)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_action_method)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiSupported_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_action_directive)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_action)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_action_method)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiSupported_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiSupported_item (os_database *db)
{
    return new (db, SdaiSupported_item::get_os_typespec())
		SdaiSupported_item ;
}

void
SdaiSupported_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiSupported_item access hook funct called." << endl;
    }
#endif
    SdaiSupported_item *s = (SdaiSupported_item *) object;
    s->_type = config_control_designt_supported_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiSupported_items (os_database *db)
{
    return new (db, SdaiSupported_items::get_os_typespec())
		SdaiSupported_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiSupported_item::SdaiSupported_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiSupported_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiSupported_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiSupported_item::SdaiSupported_item( const SdaiAction_directive_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_action_directive)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiSupported_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiSupported_item constructor." << endl;
    }
#endif
}

SdaiSupported_item::SdaiSupported_item( const SdaiAction_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_action)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiSupported_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiSupported_item constructor." << endl;
    }
#endif
}

SdaiSupported_item::SdaiSupported_item( const SdaiAction_method_ptr& o,
                                        const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_action_method)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiSupported_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiSupported_item constructor." << endl;
    }
#endif
}

SdaiSupported_item::~SdaiSupported_item()
{
}

SdaiSupported_items::SdaiSupported_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiSupported_items::~SdaiSupported_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiSupported_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiSupported_item::get_os_typespec() )
		    SdaiSupported_item );
}
#endif


	//  part 2
SdaiSupported_item::operator SdaiAction_directive_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_action_directive )
      return ((SdaiAction_directive_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiSupported_item::operator SdaiAction_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_action )
      return ((SdaiAction_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiSupported_item::operator SdaiAction_method_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_action_method )
      return ((SdaiAction_method_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiText
SdaiSupported_item::purpose_() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_method )
	//  ACTION_METHOD
	return ((SdaiAction_method_ptr) _app_inst) ->purpose_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSupported_item::purpose_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_action_method )
	//  ACTION_METHOD
	{  ((SdaiAction_method_ptr) _app_inst) ->purpose_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiSupported_item::consequence_() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_method )
	//  ACTION_METHOD
	return ((SdaiAction_method_ptr) _app_inst) ->consequence_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSupported_item::consequence_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_action_method )
	//  ACTION_METHOD
	{  ((SdaiAction_method_ptr) _app_inst) ->consequence_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiAction_method_ptr
SdaiSupported_item::chosen_method_() const
{
  if( CurrentUnderlyingType () == config_control_designe_action )
	//  ACTION
	return ((SdaiAction_ptr) _app_inst) ->chosen_method_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSupported_item::chosen_method_ (const SdaiAction_method_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_action )
	//  ACTION
	{  ((SdaiAction_ptr) _app_inst) ->chosen_method_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const EntityAggregate_ptr
SdaiSupported_item::requests_() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive )
	//  ACTION_DIRECTIVE
	return ((SdaiAction_directive_ptr) _app_inst) ->requests_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSupported_item::requests_ (const EntityAggregate_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_action_directive )
	//  ACTION_DIRECTIVE
	{  ((SdaiAction_directive_ptr) _app_inst) ->requests_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiSupported_item::comment_() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive )
	//  ACTION_DIRECTIVE
	return ((SdaiAction_directive_ptr) _app_inst) ->comment_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSupported_item::comment_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_action_directive )
	//  ACTION_DIRECTIVE
	{  ((SdaiAction_directive_ptr) _app_inst) ->comment_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiSupported_item::analysis_() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive )
	//  ACTION_DIRECTIVE
	return ((SdaiAction_directive_ptr) _app_inst) ->analysis_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSupported_item::analysis_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_action_directive )
	//  ACTION_DIRECTIVE
	{  ((SdaiAction_directive_ptr) _app_inst) ->analysis_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiSupported_item::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive )
	//  ACTION_DIRECTIVE
	return ((SdaiAction_directive_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_action )
	//  ACTION
	return ((SdaiAction_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_action_method )
	//  ACTION_METHOD
	return ((SdaiAction_method_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSupported_item::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_action_directive )
	//  ACTION_DIRECTIVE
	{  ((SdaiAction_directive_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_action )
	//  ACTION
	{  ((SdaiAction_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_action_method )
	//  ACTION_METHOD
	{  ((SdaiAction_method_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiSupported_item::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive )
	//  ACTION_DIRECTIVE
	return ((SdaiAction_directive_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_action )
	//  ACTION
	return ((SdaiAction_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_action_method )
	//  ACTION_METHOD
	return ((SdaiAction_method_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSupported_item::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_action_directive )
	//  ACTION_DIRECTIVE
	{  ((SdaiAction_directive_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_action )
	//  ACTION
	{  ((SdaiAction_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_action_method )
	//  ACTION_METHOD
	{  ((SdaiAction_method_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiSupported_item& SdaiSupported_item::operator =( const SdaiAction_directive_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_action_directive);
   return *this;
}

SdaiSupported_item& SdaiSupported_item::operator =( const SdaiAction_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_action);
   return *this;
}

SdaiSupported_item& SdaiSupported_item::operator =( const SdaiAction_method_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_action_method);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiSupported_item& SdaiSupported_item::operator =( const SdaiSupported_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_action_directive )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_action )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_action_method )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiSupported_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_action_directive )
	_app_inst = ((SdaiSupported_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_action )
	_app_inst = ((SdaiSupported_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_action_method )
	_app_inst = ((SdaiSupported_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiSupported_item::IsAction_directive() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_action_directive )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiSupported_item::IsAction() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_action )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiSupported_item::IsAction_method() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_action_method )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiSupported_item


//////////  SELECT TYPE approved_item

const TypeDescriptor *
SdaiApproved_item::AssignEntity (SCLP23(Application_instance) * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> IsA (config_control_designe_product_definition_formation))
  {
	_app_inst = (SdaiProduct_definition_formation_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  //  PRODUCT_DEFINITION
  if (se -> IsA (config_control_designe_product_definition))
  {
	_app_inst = (SdaiProduct_definition_ptr) se;
	return SetUnderlyingType (config_control_designe_product_definition);
  }
  //  CONFIGURATION_EFFECTIVITY
  if (se -> IsA (config_control_designe_configuration_effectivity))
  {
	_app_inst = (SdaiConfiguration_effectivity_ptr) se;
	return SetUnderlyingType (config_control_designe_configuration_effectivity);
  }
  //  CONFIGURATION_ITEM
  if (se -> IsA (config_control_designe_configuration_item))
  {
	_app_inst = (SdaiConfiguration_item_ptr) se;
	return SetUnderlyingType (config_control_designe_configuration_item);
  }
  //  SECURITY_CLASSIFICATION
  if (se -> IsA (config_control_designe_security_classification))
  {
	_app_inst = (SdaiSecurity_classification_ptr) se;
	return SetUnderlyingType (config_control_designe_security_classification);
  }
  //  CHANGE_REQUEST
  if (se -> IsA (config_control_designe_change_request))
  {
	_app_inst = (SdaiChange_request_ptr) se;
	return SetUnderlyingType (config_control_designe_change_request);
  }
  //  CHANGE
  if (se -> IsA (config_control_designe_change))
  {
	_app_inst = (SdaiChange_ptr) se;
	return SetUnderlyingType (config_control_designe_change);
  }
  //  START_REQUEST
  if (se -> IsA (config_control_designe_start_request))
  {
	_app_inst = (SdaiStart_request_ptr) se;
	return SetUnderlyingType (config_control_designe_start_request);
  }
  //  START_WORK
  if (se -> IsA (config_control_designe_start_work))
  {
	_app_inst = (SdaiStart_work_ptr) se;
	return SetUnderlyingType (config_control_designe_start_work);
  }
  //  CERTIFICATION
  if (se -> IsA (config_control_designe_certification))
  {
	_app_inst = (SdaiCertification_ptr) se;
	return SetUnderlyingType (config_control_designe_certification);
  }
  //  CONTRACT
  if (se -> IsA (config_control_designe_contract))
  {
	_app_inst = (SdaiContract_ptr) se;
	return SetUnderlyingType (config_control_designe_contract);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiApproved_item::NewSelect ()
{
#ifdef __OSTORE__
    SdaiApproved_item * tmp =
		new( os_segment::of(this),
		     SdaiApproved_item::get_os_typespec() )
			SdaiApproved_item();
#else
    SdaiApproved_item * tmp = new SdaiApproved_item();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiApproved_item::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_product_definition)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_configuration_effectivity)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_configuration_item)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_security_classification)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_change_request)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_change)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_start_request)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_start_work)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_certification)
	_app_inst -> STEPwrite_reference (out);
  else if (CurrentUnderlyingType () == config_control_designe_contract)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiApproved_item::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_product_definition_formation)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_product_definition)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_configuration_effectivity)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_configuration_item)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_security_classification)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_change_request)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_change)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_start_request)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_start_work)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_certification)
    return sdaiINSTANCE;
  else if (CurrentUnderlyingType() == config_control_designe_contract)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiApproved_item::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_product_definition_formation)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_product_definition)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_configuration_effectivity)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_configuration_item)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_security_classification)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_change_request)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_change)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_start_request)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_start_work)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_certification)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else if (td == config_control_designe_contract)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiApproved_item::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_product_definition)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_configuration_effectivity)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_configuration_item)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_security_classification)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_change_request)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_change)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_start_request)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_start_work)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_certification)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }
  if (CurrentUnderlyingType () == config_control_designe_contract)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiApproved_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiApproved_item (os_database *db)
{
    return new (db, SdaiApproved_item::get_os_typespec())
		SdaiApproved_item ;
}

void
SdaiApproved_item_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiApproved_item access hook funct called." << endl;
    }
#endif
    SdaiApproved_item *s = (SdaiApproved_item *) object;
    s->_type = config_control_designt_approved_item;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiApproved_items (os_database *db)
{
    return new (db, SdaiApproved_items::get_os_typespec())
		SdaiApproved_items ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiApproved_item::SdaiApproved_item( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

	//  part 1
SdaiApproved_item::SdaiApproved_item( const SdaiProduct_definition_formation_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition_formation)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiProduct_definition_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_product_definition)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiConfiguration_effectivity_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_configuration_effectivity)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiConfiguration_item_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_configuration_item)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiSecurity_classification_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_security_classification)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiChange_request_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_change_request)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiChange_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_change)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiStart_request_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_start_request)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiStart_work_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_start_work)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiCertification_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_certification)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

SdaiApproved_item::SdaiApproved_item( const SdaiContract_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_contract)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiApproved_item constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiApproved_item constructor." << endl;
    }
#endif
}

SdaiApproved_item::~SdaiApproved_item()
{
}

SdaiApproved_items::SdaiApproved_items( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiApproved_items::~SdaiApproved_items() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiApproved_items::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiApproved_item::get_os_typespec() )
		    SdaiApproved_item );
}
#endif


	//  part 2
SdaiApproved_item::operator SdaiProduct_definition_formation_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formation_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiProduct_definition_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return ((SdaiProduct_definition_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiConfiguration_effectivity_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
      return ((SdaiConfiguration_effectivity_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiConfiguration_item_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_configuration_item )
      return ((SdaiConfiguration_item_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiSecurity_classification_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return ((SdaiSecurity_classification_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiChange_request_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return ((SdaiChange_request_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiChange_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_change )
      return ((SdaiChange_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiStart_request_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return ((SdaiStart_request_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiStart_work_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return ((SdaiStart_work_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiCertification_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_certification )
      return ((SdaiCertification_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiContract_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return ((SdaiContract_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiCertification_type_ptr
SdaiApproved_item::kind_() const
{
  if( CurrentUnderlyingType () == config_control_designe_certification )
	//  CERTIFICATION
	return ((SdaiCertification_ptr) _app_inst) ->kind_();
  //  CONTRACT
	//  attribute access function has a different return type
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::kind_ (const SdaiCertification_type_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_certification )
	//  CERTIFICATION
	{  ((SdaiCertification_ptr) _app_inst) ->kind_( x );
	  return;
	}
  //  for CONTRACT  attribute access function has a different argument type

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiAction_ptr
SdaiApproved_item::assigned_action_() const
{
  if( CurrentUnderlyingType () == config_control_designe_change )
	//  CHANGE
	return ((SdaiChange_ptr) _app_inst) ->assigned_action_();
  if( CurrentUnderlyingType () == config_control_designe_start_work )
	//  START_WORK
	return ((SdaiStart_work_ptr) _app_inst) ->assigned_action_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::assigned_action_ (const SdaiAction_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_change )
	//  CHANGE
	{  ((SdaiChange_ptr) _app_inst) ->assigned_action_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_work )
	//  START_WORK
	{  ((SdaiStart_work_ptr) _app_inst) ->assigned_action_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiChange_request_items_ptr
SdaiApproved_item::items_() const
{
  if( CurrentUnderlyingType () == config_control_designe_change_request )
	//  CHANGE_REQUEST
	return ((SdaiChange_request_ptr) _app_inst) ->items_();
  //  CHANGE
	//  attribute access function has a different return type
  //  START_REQUEST
	//  attribute access function has a different return type
  //  START_WORK
	//  attribute access function has a different return type
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::items_ (const SdaiChange_request_items_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_change_request )
	//  CHANGE_REQUEST
	{  ((SdaiChange_request_ptr) _app_inst) ->items_( x );
	  return;
	}
  //  for CHANGE  attribute access function has a different argument type
  //  for START_REQUEST  attribute access function has a different argument type
  //  for START_WORK  attribute access function has a different argument type

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiVersioned_action_request_ptr
SdaiApproved_item::assigned_action_request_() const
{
  if( CurrentUnderlyingType () == config_control_designe_change_request )
	//  CHANGE_REQUEST
	return ((SdaiChange_request_ptr) _app_inst) ->assigned_action_request_();
  if( CurrentUnderlyingType () == config_control_designe_start_request )
	//  START_REQUEST
	return ((SdaiStart_request_ptr) _app_inst) ->assigned_action_request_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::assigned_action_request_ (const SdaiVersioned_action_request_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_change_request )
	//  CHANGE_REQUEST
	{  ((SdaiChange_request_ptr) _app_inst) ->assigned_action_request_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_request )
	//  START_REQUEST
	{  ((SdaiStart_request_ptr) _app_inst) ->assigned_action_request_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiSecurity_classification_level_ptr
SdaiApproved_item::security_level_() const
{
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classification_ptr) _app_inst) ->security_level_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::security_level_ (const SdaiSecurity_classification_level_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classification_ptr) _app_inst) ->security_level_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiApproved_item::purpose_() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_item_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classification_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_designe_certification )
	//  CERTIFICATION
	return ((SdaiCertification_ptr) _app_inst) ->purpose_();
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	return ((SdaiContract_ptr) _app_inst) ->purpose_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::purpose_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_item_ptr) _app_inst) ->purpose_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classification_ptr) _app_inst) ->purpose_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_certification )
	//  CERTIFICATION
	{  ((SdaiCertification_ptr) _app_inst) ->purpose_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	{  ((SdaiContract_ptr) _app_inst) ->purpose_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_concept_ptr
SdaiApproved_item::item_concept_() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_item_ptr) _app_inst) ->item_concept_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::item_concept_ (const SdaiProduct_concept_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_item_ptr) _app_inst) ->item_concept_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiApproved_item::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_item_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classification_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_certification )
	//  CERTIFICATION
	return ((SdaiCertification_ptr) _app_inst) ->name_();
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	return ((SdaiContract_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_item_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification )
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classification_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_certification )
	//  CERTIFICATION
	{  ((SdaiCertification_ptr) _app_inst) ->name_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_contract )
	//  CONTRACT
	{  ((SdaiContract_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiConfiguration_design_ptr
SdaiApproved_item::configuration_() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
	//  CONFIGURATION_EFFECTIVITY
	return ((SdaiConfiguration_effectivity_ptr) _app_inst) ->configuration_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::configuration_ (const SdaiConfiguration_design_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
	//  CONFIGURATION_EFFECTIVITY
	{  ((SdaiConfiguration_effectivity_ptr) _app_inst) ->configuration_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_relationship_ptr
SdaiApproved_item::usage_() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
	//  CONFIGURATION_EFFECTIVITY
	return ((SdaiConfiguration_effectivity_ptr) _app_inst) ->usage_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::usage_ (const SdaiProduct_definition_relationship_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
	//  CONFIGURATION_EFFECTIVITY
	{  ((SdaiConfiguration_effectivity_ptr) _app_inst) ->usage_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_context_ptr
SdaiApproved_item::frame_of_reference_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->frame_of_reference_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::frame_of_reference_ (const SdaiProduct_definition_context_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->frame_of_reference_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_definition_formation_ptr
SdaiApproved_item::formation_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->formation_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::formation_ (const SdaiProduct_definition_formation_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->formation_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiProduct_ptr
SdaiApproved_item::of_product_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::of_product_ (const SdaiProduct_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->of_product_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiText
SdaiApproved_item::description_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->description_();
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_item_ptr) _app_inst) ->description_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::description_ (const SdaiText x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->description_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_item_ptr) _app_inst) ->description_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiIdentifier
SdaiApproved_item::id_() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definition_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
	//  CONFIGURATION_EFFECTIVITY
	return ((SdaiConfiguration_effectivity_ptr) _app_inst) ->id_();
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_item_ptr) _app_inst) ->id_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiApproved_item::id_ (const SdaiIdentifier x)

{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formation_ptr) _app_inst) ->id_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition )
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definition_ptr) _app_inst) ->id_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
	//  CONFIGURATION_EFFECTIVITY
	{  ((SdaiConfiguration_effectivity_ptr) _app_inst) ->id_( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_configuration_item )
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_item_ptr) _app_inst) ->id_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiApproved_item& SdaiApproved_item::operator =( const SdaiProduct_definition_formation_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiProduct_definition_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_product_definition);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiConfiguration_effectivity_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_configuration_effectivity);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiConfiguration_item_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_configuration_item);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiSecurity_classification_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_security_classification);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiChange_request_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_change_request);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiChange_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_change);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiStart_request_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_start_request);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiStart_work_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_start_work);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiCertification_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_certification);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiContract_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_contract);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiApproved_item_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_product_definition )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_configuration_item )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_security_classification )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_change_request )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_change )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_start_request )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_start_work )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_certification )
	_app_inst =  o -> _app_inst;
   else if ( o -> CurrentUnderlyingType () == config_control_designe_contract )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiApproved_item::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_app_inst = ((SdaiApproved_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_product_definition )
	_app_inst = ((SdaiApproved_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
	_app_inst = ((SdaiApproved_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_configuration_item )
	_app_inst = ((SdaiApproved_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_security_classification )
	_app_inst = ((SdaiApproved_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_change_request )
	_app_inst = ((SdaiApproved_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_change )
	_app_inst = ((SdaiApproved_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_start_request )
	_app_inst = ((SdaiApproved_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_start_work )
	_app_inst = ((SdaiApproved_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_certification )
	_app_inst = ((SdaiApproved_item&) o)._app_inst;
   else if ( o.CurrentUnderlyingType () == config_control_designe_contract )
	_app_inst = ((SdaiApproved_item&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiApproved_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiApproved_item::IsProduct_definition() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiApproved_item::IsConfiguration_effectivity() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiApproved_item::IsConfiguration_item() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_configuration_item )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiApproved_item::IsSecurity_classification() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiApproved_item::IsChange_request() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiApproved_item::IsChange() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_change )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiApproved_item::IsStart_request() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiApproved_item::IsStart_work() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiApproved_item::IsCertification() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_certification )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

SCLLOG(Logical) SdaiApproved_item::IsContract() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiApproved_item


//////////  SELECT TYPE surface_model

const TypeDescriptor *
SdaiSurface_model::AssignEntity (SCLP23(Application_instance) * se)
{
  //  SHELL_BASED_SURFACE_MODEL
  if (se -> IsA (config_control_designe_shell_based_surface_model))
  {
	_app_inst = (SdaiShell_based_surface_model_ptr) se;
	return SetUnderlyingType (config_control_designe_shell_based_surface_model);
  }
  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SCLP23(Select) *
SdaiSurface_model::NewSelect ()
{
#ifdef __OSTORE__
    SdaiSurface_model * tmp =
		new( os_segment::of(this),
		     SdaiSurface_model::get_os_typespec() )
			SdaiSurface_model();
#else
    SdaiSurface_model * tmp = new SdaiSurface_model();
#endif
    return tmp;
}


// STEP Part 21

void
SdaiSurface_model::STEPwrite_content (ostream& out, const char * currSch) const
{
  if (CurrentUnderlyingType () == config_control_designe_shell_based_surface_model)
	_app_inst -> STEPwrite_reference (out);
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

BASE_TYPE
SdaiSurface_model::ValueType() const
{
  if (CurrentUnderlyingType() == config_control_designe_shell_based_surface_model)
    return sdaiINSTANCE;
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return (BASE_TYPE)0;
}

void
SdaiSurface_model::STEPwrite_verbose (ostream& out, const char *currSch) const
{
  const TypeDescriptor *td = CurrentUnderlyingType();
  SCLstring tmp;

  if ( td ) {
    // If we have a legal underlying type, get its name acc
    // to the current schema.
    StrToUpper( td->Name(currSch), tmp );
  }
  if (td == config_control_designe_shell_based_surface_model)
  {
    out <<  tmp.chars() << "(";
    _app_inst -> STEPwrite_reference (out);
    out << ")";
  }
  else   {
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiSurface_model::STEPread_content (istream& in, InstMgr * instances,
			const char *utype, int addFileId, const char *currSch)
{
  if (CurrentUnderlyingType () == config_control_designe_shell_based_surface_model)   {
	// set Underlying Type in Select class
	_app_inst = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_app_inst && (_app_inst != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_app_inst -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _app_inst = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiSurface_model::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - done in Select class

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

#ifdef __OSTORE__
SCLP23(Select) *
create_SdaiSurface_model (os_database *db)
{
    return new (db, SdaiSurface_model::get_os_typespec())
		SdaiSurface_model ;
}

void
SdaiSurface_model_access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "SdaiSurface_model access hook funct called." << endl;
    }
#endif
    SdaiSurface_model *s = (SdaiSurface_model *) object;
    s->_type = config_control_designt_surface_model;
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "underlying type set to " << s->UnderlyingTypeName() << endl << endl;
    }
#endif
    const TypeDescriptor *td = s->CanBe(s->UnderlyingTypeName());
    s->SetUnderlyingType(td);
    if(!td)
	cerr << "ERROR: can't reinitialize underlying select TypeDescriptor."
	     << endl;
}
#endif


#ifdef __OSTORE__
STEPaggregate *
create_SdaiSurface_models (os_database *db)
{
    return new (db, SdaiSurface_models::get_os_typespec())
		SdaiSurface_models ;
}
#endif


// STEP Part 22:  SDAI

	//  part 0
SdaiSurface_model::SdaiSurface_model( const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiSurface_model constructor." << endl;
    }
#endif
   nullify();
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiSurface_model constructor." << endl;
    }
#endif
}

	//  part 1
SdaiSurface_model::SdaiSurface_model( const SdaiShell_based_surface_model_ptr& o,
                                      const SelectTypeDescriptor *typedescript )
  : SCLP23(Select) (typedescript, config_control_designe_shell_based_surface_model)
{
#ifdef SCL_LOGGING
    if( *logStream )
    {
	*logStream << "DAVE ERR entering SdaiSurface_model constructor." << endl;
    }
#endif
   _app_inst = o;
#ifdef SCL_LOGGING
    if( *logStream )
    {
//	*logStream << "DAVE ERR exiting SdaiSurface_model constructor." << endl;
    }
#endif
}

SdaiSurface_model::~SdaiSurface_model()
{
}

SdaiSurface_models::SdaiSurface_models( SelectTypeDescriptor *s)
  : SelectAggregate(), sel_type(s)
{
}

SdaiSurface_models::~SdaiSurface_models() { }


#ifdef __OSTORE__
SingleLinkNode *
SdaiSurface_models::NewNode()
{
    return new( os_segment::of(this), SelectNode::get_os_typespec() )
	SelectNode( new( os_segment::of(this),
			 SdaiSurface_model::get_os_typespec() )
		    SdaiSurface_model );
}
#endif


	//  part 2
SdaiSurface_model::operator SdaiShell_based_surface_model_ptr()
{
   if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
      return ((SdaiShell_based_surface_model_ptr) _app_inst);

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiShells_ptr
SdaiSurface_model::sbsm_boundary_() const
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
	//  SHELL_BASED_SURFACE_MODEL
	return ((SdaiShell_based_surface_model_ptr) _app_inst) ->sbsm_boundary_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSurface_model::sbsm_boundary_ (const SdaiShells_ptr x)

{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
	//  SHELL_BASED_SURFACE_MODEL
	{  ((SdaiShell_based_surface_model_ptr) _app_inst) ->sbsm_boundary_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

const SdaiLabel
SdaiSurface_model::name_() const
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
	//  SHELL_BASED_SURFACE_MODEL
	return ((SdaiShell_based_surface_model_ptr) _app_inst) ->name_();
   cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n"
	<< _POC_ << "\n\n";
   return 0;
}


void
SdaiSurface_model::name_ (const SdaiLabel x)

{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
	//  SHELL_BASED_SURFACE_MODEL
	{  ((SdaiShell_based_surface_model_ptr) _app_inst) ->name_( x );
	  return;
	}

   severity( SEVERITY_WARNING );
   cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of"
        << " SELECT TYPE from schema library.\n";
   Error( "Mismatch in underlying type." );
}

	//  part 4
SdaiSurface_model& SdaiSurface_model::operator =( const SdaiShell_based_surface_model_ptr& o )
{
   nullify ();
   _app_inst = o;
   SetUnderlyingType (config_control_designe_shell_based_surface_model);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else

SdaiSurface_model& SdaiSurface_model::operator =( const SdaiSurface_model_ptr& o )
{
   if ( o -> CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
	_app_inst =  o -> _app_inst;
   underlying_type = o -> CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o -> UnderlyingTypeName();
#endif
   return *this;
}

SCLP23(Select)& SdaiSurface_model::operator =( const SCLP23(Select)& o )
{
   if ( o.CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
	_app_inst = ((SdaiSurface_model&) o)._app_inst;
   underlying_type = o.CurrentUnderlyingType ();
#ifdef __OSTORE__
   underlying_type_name = o.UnderlyingTypeName();
#endif
   return *this;
}

#endif

	//  part 5
SCLLOG(Logical) SdaiSurface_model::IsShell_based_surface_model() const
{
   if( !exists() )
      return SCLLOG(LUnknown);
   if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
      return SCLLOG(LTrue);
   return SCLLOG(LFalse);
}

//////////  END SELECT TYPE SdaiSurface_model


/*	**************  ENTITIES  	*/

/////////	 ENTITY representation_item
int SdaiRepresentation_item::num_times_inherited=0;
EntityDescriptor *config_control_designe_representation_item =0;
AttrDescriptor *a_0name =0;
SdaiRepresentation_item::SdaiRepresentation_item( )
{
    num_times_inherited++;
	/*  no SuperTypes */

    eDesc = config_control_designe_representation_item;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_0name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_0name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);
    //cout << "Representation_item" << endl;
    //PrintSTEPattributes ();
}
SdaiRepresentation_item::SdaiRepresentation_item (SdaiRepresentation_item& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiRepresentation_item::~SdaiRepresentation_item () {  }

#ifdef __OSTORE__

void
SdaiRepresentation_item::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation_item: virtual access function." << endl;
    SdaiRepresentation_item_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiRepresentation_item_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation_item: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiRepresentation_item *ent = (SdaiRepresentation_item *)sent;
//    SdaiRepresentation_item *ent = (SdaiRepresentation_item *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_representation_item;
    ent->attributes[0].aDesc = a_0name;
}

SCLP23(Application_instance_ptr)
create_SdaiRepresentation_item(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiRepresentation_item::get_os_typespec())
                                   SdaiRepresentation_item;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiRepresentation_item::get_os_typespec())
//                                   SdaiRepresentation_item;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiRepresentation_item;
}
#endif

#ifdef __O3DB__
void
SdaiRepresentation_item::oodb_reInit ()
{	eDesc = config_control_designe_representation_item;
	attributes [0].aDesc = a_0name;
}
#endif
void SdaiRepresentation_item::decrement_inherit_cnt()
{
   num_times_inherited--;
}
SdaiRepresentation_item::SdaiRepresentation_item( SCLP23(Application_instance) *se, int *addAttrs)
{
    num_times_inherited++;
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_item;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_0name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_0name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiRepresentation_item::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiRepresentation_item::name_ (const SdaiLabel x)

{
    _name = x;
}

/////////	 END_ENTITY representation_item


/////////	 ENTITY geometric_representation_item

EntityDescriptor *config_control_designe_geometric_representation_item =0;
Derived_attribute *a_1Ddim =0;
SdaiGeometric_representation_item::SdaiGeometric_representation_item( )
{

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_representation_item;
    MakeDerived ("dim");
}
SdaiGeometric_representation_item::SdaiGeometric_representation_item (SdaiGeometric_representation_item& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiGeometric_representation_item::~SdaiGeometric_representation_item () {
	cout << "Bye bye - " << this << endl;
}

#ifdef __OSTORE__

void
SdaiGeometric_representation_item::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometric_representation_item: virtual access function." << endl;
    SdaiGeometric_representation_item_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiGeometric_representation_item_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometric_representation_item: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiGeometric_representation_item *ent = (SdaiGeometric_representation_item *)sent;
//    SdaiGeometric_representation_item *ent = (SdaiGeometric_representation_item *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_geometric_representation_item;
}

SCLP23(Application_instance_ptr)
create_SdaiGeometric_representation_item(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiGeometric_representation_item::get_os_typespec())
                                   SdaiGeometric_representation_item;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiGeometric_representation_item::get_os_typespec())
//                                   SdaiGeometric_representation_item;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiGeometric_representation_item;
}
#endif

#ifdef __O3DB__
void
SdaiGeometric_representation_item::oodb_reInit ()
{	eDesc = config_control_designe_geometric_representation_item;
}
#endif

SdaiGeometric_representation_item::SdaiGeometric_representation_item (SCLP23(Application_instance) *se, int *addAttrs) : SdaiRepresentation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_representation_item;
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometric_representation_item


/////////	 ENTITY functionally_defined_transformation

EntityDescriptor *config_control_designe_functionally_defined_transformation =0;
AttrDescriptor *a_2name =0;
AttrDescriptor *a_3description =0;
SdaiFunctionally_defined_transformation::SdaiFunctionally_defined_transformation( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_functionally_defined_transformation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_2name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_2name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_3description,  &_description);
#else
    a = new STEPattribute(*a_3description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiFunctionally_defined_transformation::SdaiFunctionally_defined_transformation (SdaiFunctionally_defined_transformation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiFunctionally_defined_transformation::~SdaiFunctionally_defined_transformation () {  }

#ifdef __OSTORE__

void
SdaiFunctionally_defined_transformation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFunctionally_defined_transformation: virtual access function." << endl;
    SdaiFunctionally_defined_transformation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiFunctionally_defined_transformation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFunctionally_defined_transformation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiFunctionally_defined_transformation *ent = (SdaiFunctionally_defined_transformation *)sent;
//    SdaiFunctionally_defined_transformation *ent = (SdaiFunctionally_defined_transformation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_functionally_defined_transformation;
    ent->attributes[0].aDesc = a_2name;
    ent->attributes[1].aDesc = a_3description;
}

SCLP23(Application_instance_ptr)
create_SdaiFunctionally_defined_transformation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiFunctionally_defined_transformation::get_os_typespec())
                                   SdaiFunctionally_defined_transformation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiFunctionally_defined_transformation::get_os_typespec())
//                                   SdaiFunctionally_defined_transformation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiFunctionally_defined_transformation;
}
#endif

#ifdef __O3DB__
void
SdaiFunctionally_defined_transformation::oodb_reInit ()
{	eDesc = config_control_designe_functionally_defined_transformation;
	attributes [0].aDesc = a_2name;
	attributes [1].aDesc = a_3description;
}
#endif

SdaiFunctionally_defined_transformation::SdaiFunctionally_defined_transformation( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_functionally_defined_transformation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_2name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_2name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_3description,  &_description);
#else
    a = new STEPattribute(*a_3description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiFunctionally_defined_transformation::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiFunctionally_defined_transformation::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiFunctionally_defined_transformation::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiFunctionally_defined_transformation::description_ (const SdaiText x)

{
    _description = x;
}

/////////	 END_ENTITY functionally_defined_transformation


/////////	 ENTITY cartesian_transformation_operator

EntityDescriptor *config_control_designe_cartesian_transformation_operator =0;
AttrDescriptor *a_4axis1 =0;
AttrDescriptor *a_5axis2 =0;
AttrDescriptor *a_6local_origin =0;
AttrDescriptor *a_7scale =0;
Derived_attribute *a_8Dscl =0;
SdaiCartesian_transformation_operator::SdaiCartesian_transformation_operator( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiFunctionally_defined_transformation  */
    HeadEntity(this);
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    AppendMultInstance(new SdaiFunctionally_defined_transformation(this, attrFlags));
#endif
    AppendMultInstance(new SdaiFunctionally_defined_transformation(this));

    eDesc = config_control_designe_cartesian_transformation_operator;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_4axis1, (SCLP23(Application_instance_ptr) *) &_axis1);
#else
    STEPattribute *a = new STEPattribute(*a_4axis1, (SCLP23(Application_instance_ptr) *) &_axis1);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_5axis2, (SCLP23(Application_instance_ptr) *) &_axis2);
#else
    a = new STEPattribute(*a_5axis2, (SCLP23(Application_instance_ptr) *) &_axis2);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_6local_origin, (SCLP23(Application_instance_ptr) *) &_local_origin);
#else
    a = new STEPattribute(*a_6local_origin, (SCLP23(Application_instance_ptr) *) &_local_origin);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_7scale,  &_scale);
#else
    a = new STEPattribute(*a_7scale,  &_scale);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("scl");
}
SdaiCartesian_transformation_operator::SdaiCartesian_transformation_operator (SdaiCartesian_transformation_operator& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCartesian_transformation_operator::~SdaiCartesian_transformation_operator () {  }

#ifdef __OSTORE__

void
SdaiCartesian_transformation_operator::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCartesian_transformation_operator: virtual access function." << endl;
    SdaiCartesian_transformation_operator_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCartesian_transformation_operator_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCartesian_transformation_operator: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCartesian_transformation_operator *ent = (SdaiCartesian_transformation_operator *)sent;
//    SdaiCartesian_transformation_operator *ent = (SdaiCartesian_transformation_operator *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_cartesian_transformation_operator;
    ent->attributes[3].aDesc = a_4axis1;
    if(ent->_axis1 == 0)
        ent->_axis1 = S_ENTITY_NULL;
    ent->attributes[4].aDesc = a_5axis2;
    if(ent->_axis2 == 0)
        ent->_axis2 = S_ENTITY_NULL;
    ent->attributes[5].aDesc = a_6local_origin;
    if(ent->_local_origin == 0)
        ent->_local_origin = S_ENTITY_NULL;
    ent->attributes[6].aDesc = a_7scale;
}

SCLP23(Application_instance_ptr)
create_SdaiCartesian_transformation_operator(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCartesian_transformation_operator::get_os_typespec())
                                   SdaiCartesian_transformation_operator;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCartesian_transformation_operator::get_os_typespec())
//                                   SdaiCartesian_transformation_operator;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCartesian_transformation_operator;
}
#endif

#ifdef __O3DB__
void
SdaiCartesian_transformation_operator::oodb_reInit ()
{	eDesc = config_control_designe_cartesian_transformation_operator;
	attributes [3].aDesc = a_4axis1;
	attributes [4].aDesc = a_5axis2;
	attributes [5].aDesc = a_6local_origin;
	attributes [6].aDesc = a_7scale;
}
#endif

SdaiCartesian_transformation_operator::SdaiCartesian_transformation_operator (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiFunctionally_defined_transformation  */
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    se->AppendMultInstance(new SdaiFunctionally_defined_transformation(se, attrFlags));
#endif
    se->AppendMultInstance(new SdaiFunctionally_defined_transformation(se, 0));

    eDesc = config_control_designe_cartesian_transformation_operator;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_4axis1, (SCLP23(Application_instance_ptr) *) &_axis1);
#else
    STEPattribute *a = new STEPattribute(*a_4axis1, (SCLP23(Application_instance_ptr) *) &_axis1);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_5axis2, (SCLP23(Application_instance_ptr) *) &_axis2);
#else
    a = new STEPattribute(*a_5axis2, (SCLP23(Application_instance_ptr) *) &_axis2);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_6local_origin, (SCLP23(Application_instance_ptr) *) &_local_origin);
#else
    a = new STEPattribute(*a_6local_origin, (SCLP23(Application_instance_ptr) *) &_local_origin);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_7scale,  &_scale);
#else
    a = new STEPattribute(*a_7scale,  &_scale);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("scl");
}

const SdaiDirection_ptr
SdaiCartesian_transformation_operator::axis1_() const
{
    return (SdaiDirection_ptr) _axis1;
}

void
SdaiCartesian_transformation_operator::axis1_ (const SdaiDirection_ptr x)

{
    _axis1 = x;
}

const SdaiDirection_ptr
SdaiCartesian_transformation_operator::axis2_() const
{
    return (SdaiDirection_ptr) _axis2;
}

void
SdaiCartesian_transformation_operator::axis2_ (const SdaiDirection_ptr x)

{
    _axis2 = x;
}

const SdaiCartesian_point_ptr
SdaiCartesian_transformation_operator::local_origin_() const
{
    return (SdaiCartesian_point_ptr) _local_origin;
}

void
SdaiCartesian_transformation_operator::local_origin_ (const SdaiCartesian_point_ptr x)

{
    _local_origin = x;
}

const SCLP23(Real)
SdaiCartesian_transformation_operator::scale_() const
{
    return (const SCLP23(Real)) _scale;
}

void
SdaiCartesian_transformation_operator::scale_ (const SCLP23(Real) x)

{
    _scale = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

const SdaiLabel
SdaiCartesian_transformation_operator::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiCartesian_transformation_operator::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiCartesian_transformation_operator::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiCartesian_transformation_operator::description_ (const SdaiText x)

{
    _description = x;
}

#endif

/////////	 END_ENTITY cartesian_transformation_operator


/////////	 ENTITY cartesian_transformation_operator_3d

EntityDescriptor *config_control_designe_cartesian_transformation_operator_3d =0;
AttrDescriptor *a_9axis3 =0;
Derived_attribute *a_10Du =0;
SdaiCartesian_transformation_operator_3d::SdaiCartesian_transformation_operator_3d( )
{

	/*  parent: SdaiCartesian_transformation_operator  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cartesian_transformation_operator_3d;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_9axis3, (SCLP23(Application_instance_ptr) *) &_axis3);
#else
    STEPattribute *a = new STEPattribute(*a_9axis3, (SCLP23(Application_instance_ptr) *) &_axis3);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("scl");
    MakeDerived ("u");
}
SdaiCartesian_transformation_operator_3d::SdaiCartesian_transformation_operator_3d (SdaiCartesian_transformation_operator_3d& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCartesian_transformation_operator_3d::~SdaiCartesian_transformation_operator_3d () {  }

#ifdef __OSTORE__

void
SdaiCartesian_transformation_operator_3d::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCartesian_transformation_operator_3d: virtual access function." << endl;
    SdaiCartesian_transformation_operator_3d_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCartesian_transformation_operator_3d_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCartesian_transformation_operator_3d: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCartesian_transformation_operator_3d *ent = (SdaiCartesian_transformation_operator_3d *)sent;
//    SdaiCartesian_transformation_operator_3d *ent = (SdaiCartesian_transformation_operator_3d *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_cartesian_transformation_operator_3d;
    ent->attributes[7].aDesc = a_9axis3;
    if(ent->_axis3 == 0)
        ent->_axis3 = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiCartesian_transformation_operator_3d(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCartesian_transformation_operator_3d::get_os_typespec())
                                   SdaiCartesian_transformation_operator_3d;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCartesian_transformation_operator_3d::get_os_typespec())
//                                   SdaiCartesian_transformation_operator_3d;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCartesian_transformation_operator_3d;
}
#endif

#ifdef __O3DB__
void
SdaiCartesian_transformation_operator_3d::oodb_reInit ()
{	eDesc = config_control_designe_cartesian_transformation_operator_3d;
	attributes [7].aDesc = a_9axis3;
}
#endif

SdaiCartesian_transformation_operator_3d::SdaiCartesian_transformation_operator_3d (SCLP23(Application_instance) *se, int *addAttrs) : SdaiCartesian_transformation_operator(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiCartesian_transformation_operator  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cartesian_transformation_operator_3d;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_9axis3, (SCLP23(Application_instance_ptr) *) &_axis3);
#else
    STEPattribute *a = new STEPattribute(*a_9axis3, (SCLP23(Application_instance_ptr) *) &_axis3);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("scl");
    MakeDerived ("u");
}

const SdaiDirection_ptr
SdaiCartesian_transformation_operator_3d::axis3_() const
{
    return (SdaiDirection_ptr) _axis3;
}

void
SdaiCartesian_transformation_operator_3d::axis3_ (const SdaiDirection_ptr x)

{
    _axis3 = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cartesian_transformation_operator_3d


/////////	 ENTITY versioned_action_request

EntityDescriptor *config_control_designe_versioned_action_request =0;
AttrDescriptor *a_11id =0;
AttrDescriptor *a_12version =0;
AttrDescriptor *a_13purpose =0;
AttrDescriptor *a_14description =0;
SdaiVersioned_action_request::SdaiVersioned_action_request( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_versioned_action_request;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_11id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_11id,  &_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_12version,  &_version);
#else
    a = new STEPattribute(*a_12version,  &_version);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_13purpose,  &_purpose);
#else
    a = new STEPattribute(*a_13purpose,  &_purpose);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_14description,  &_description);
#else
    a = new STEPattribute(*a_14description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiVersioned_action_request::SdaiVersioned_action_request (SdaiVersioned_action_request& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiVersioned_action_request::~SdaiVersioned_action_request () {  }

#ifdef __OSTORE__

void
SdaiVersioned_action_request::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVersioned_action_request: virtual access function." << endl;
    SdaiVersioned_action_request_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiVersioned_action_request_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVersioned_action_request: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiVersioned_action_request *ent = (SdaiVersioned_action_request *)sent;
//    SdaiVersioned_action_request *ent = (SdaiVersioned_action_request *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_versioned_action_request;
    ent->attributes[0].aDesc = a_11id;
    ent->attributes[1].aDesc = a_12version;
    ent->attributes[2].aDesc = a_13purpose;
    ent->attributes[3].aDesc = a_14description;
}

SCLP23(Application_instance_ptr)
create_SdaiVersioned_action_request(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiVersioned_action_request::get_os_typespec())
                                   SdaiVersioned_action_request;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiVersioned_action_request::get_os_typespec())
//                                   SdaiVersioned_action_request;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiVersioned_action_request;
}
#endif

#ifdef __O3DB__
void
SdaiVersioned_action_request::oodb_reInit ()
{	eDesc = config_control_designe_versioned_action_request;
	attributes [0].aDesc = a_11id;
	attributes [1].aDesc = a_12version;
	attributes [2].aDesc = a_13purpose;
	attributes [3].aDesc = a_14description;
}
#endif

SdaiVersioned_action_request::SdaiVersioned_action_request( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_versioned_action_request;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_11id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_11id,  &_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_12version,  &_version);
#else
    a = new STEPattribute(*a_12version,  &_version);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_13purpose,  &_purpose);
#else
    a = new STEPattribute(*a_13purpose,  &_purpose);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_14description,  &_description);
#else
    a = new STEPattribute(*a_14description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiVersioned_action_request::id_() const
{
    return (const SdaiIdentifier) _id;
}

void
SdaiVersioned_action_request::id_ (const SdaiIdentifier x)

{
    _id = x;
}

const SdaiLabel
SdaiVersioned_action_request::version_() const
{
    return (const SdaiLabel) _version;
}

void
SdaiVersioned_action_request::version_ (const SdaiLabel x)

{
    _version = x;
}

const SdaiText
SdaiVersioned_action_request::purpose_() const
{
    return (const SdaiText) _purpose;
}

void
SdaiVersioned_action_request::purpose_ (const SdaiText x)

{
    _purpose = x;
}

const SdaiText
SdaiVersioned_action_request::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiVersioned_action_request::description_ (const SdaiText x)

{
    _description = x;
}

/////////	 END_ENTITY versioned_action_request


/////////	 ENTITY representation

EntityDescriptor *config_control_designe_representation =0;
AttrDescriptor *a_15name =0;
AttrDescriptor *a_16items =0;
AttrDescriptor *a_17context_of_items =0;
SdaiRepresentation::SdaiRepresentation( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_representation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_15name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_15name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_16items,  &_items);
#else
    a = new STEPattribute(*a_16items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_17context_of_items, (SCLP23(Application_instance_ptr) *) &_context_of_items);
#else
    a = new STEPattribute(*a_17context_of_items, (SCLP23(Application_instance_ptr) *) &_context_of_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiRepresentation::SdaiRepresentation (SdaiRepresentation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiRepresentation::~SdaiRepresentation () {  }

#ifdef __OSTORE__

void
SdaiRepresentation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation: virtual access function." << endl;
    SdaiRepresentation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiRepresentation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiRepresentation *ent = (SdaiRepresentation *)sent;
//    SdaiRepresentation *ent = (SdaiRepresentation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_representation;
    ent->attributes[0].aDesc = a_15name;
    ent->attributes[1].aDesc = a_16items;
    ent->attributes[2].aDesc = a_17context_of_items;
    if(ent->_context_of_items == 0)
        ent->_context_of_items = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiRepresentation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiRepresentation::get_os_typespec())
                                   SdaiRepresentation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiRepresentation::get_os_typespec())
//                                   SdaiRepresentation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiRepresentation;
}
#endif

#ifdef __O3DB__
void
SdaiRepresentation::oodb_reInit ()
{	eDesc = config_control_designe_representation;
	attributes [0].aDesc = a_15name;
	attributes [1].aDesc = a_16items;
	attributes [2].aDesc = a_17context_of_items;
}
#endif

SdaiRepresentation::SdaiRepresentation( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_representation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_15name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_15name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_16items,  &_items);
#else
    a = new STEPattribute(*a_16items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_17context_of_items, (SCLP23(Application_instance_ptr) *) &_context_of_items);
#else
    a = new STEPattribute(*a_17context_of_items, (SCLP23(Application_instance_ptr) *) &_context_of_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiRepresentation::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiRepresentation::name_ (const SdaiLabel x)

{
    _name = x;
}

const EntityAggregate_ptr
SdaiRepresentation::items_() const
{
    return (EntityAggregate_ptr) &_items;
}

void
SdaiRepresentation::items_ (const EntityAggregate_ptr x)

	{ _items.ShallowCopy (*x); }

const SdaiRepresentation_context_ptr
SdaiRepresentation::context_of_items_() const
{
    return (SdaiRepresentation_context_ptr) _context_of_items;
}

void
SdaiRepresentation::context_of_items_ (const SdaiRepresentation_context_ptr x)

{
    _context_of_items = x;
}

/////////	 END_ENTITY representation


/////////	 ENTITY shape_representation

EntityDescriptor *config_control_designe_shape_representation =0;
SdaiShape_representation::SdaiShape_representation( )
{

	/*  parent: SdaiRepresentation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_representation;
}
SdaiShape_representation::SdaiShape_representation (SdaiShape_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiShape_representation::~SdaiShape_representation () {  }

#ifdef __OSTORE__

void
SdaiShape_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShape_representation: virtual access function." << endl;
    SdaiShape_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiShape_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShape_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiShape_representation *ent = (SdaiShape_representation *)sent;
//    SdaiShape_representation *ent = (SdaiShape_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_shape_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiShape_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiShape_representation::get_os_typespec())
                                   SdaiShape_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiShape_representation::get_os_typespec())
//                                   SdaiShape_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiShape_representation;
}
#endif

#ifdef __O3DB__
void
SdaiShape_representation::oodb_reInit ()
{	eDesc = config_control_designe_shape_representation;
}
#endif

SdaiShape_representation::SdaiShape_representation (SCLP23(Application_instance) *se, int *addAttrs) : SdaiRepresentation(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiRepresentation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shape_representation


/////////	 ENTITY manifold_surface_shape_representation

EntityDescriptor *config_control_designe_manifold_surface_shape_representation =0;
SdaiManifold_surface_shape_representation::SdaiManifold_surface_shape_representation( )
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_manifold_surface_shape_representation;
}
SdaiManifold_surface_shape_representation::SdaiManifold_surface_shape_representation (SdaiManifold_surface_shape_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiManifold_surface_shape_representation::~SdaiManifold_surface_shape_representation () {  }

#ifdef __OSTORE__

void
SdaiManifold_surface_shape_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiManifold_surface_shape_representation: virtual access function." << endl;
    SdaiManifold_surface_shape_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiManifold_surface_shape_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiManifold_surface_shape_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiManifold_surface_shape_representation *ent = (SdaiManifold_surface_shape_representation *)sent;
//    SdaiManifold_surface_shape_representation *ent = (SdaiManifold_surface_shape_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_manifold_surface_shape_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiManifold_surface_shape_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiManifold_surface_shape_representation::get_os_typespec())
                                   SdaiManifold_surface_shape_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiManifold_surface_shape_representation::get_os_typespec())
//                                   SdaiManifold_surface_shape_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiManifold_surface_shape_representation;
}
#endif

#ifdef __O3DB__
void
SdaiManifold_surface_shape_representation::oodb_reInit ()
{	eDesc = config_control_designe_manifold_surface_shape_representation;
}
#endif

SdaiManifold_surface_shape_representation::SdaiManifold_surface_shape_representation (SCLP23(Application_instance) *se, int *addAttrs) : SdaiShape_representation(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_manifold_surface_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY manifold_surface_shape_representation


/////////	 ENTITY certification

EntityDescriptor *config_control_designe_certification =0;
AttrDescriptor *a_18name =0;
AttrDescriptor *a_19purpose =0;
AttrDescriptor *a_20kind =0;
SdaiCertification::SdaiCertification( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_certification;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_18name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_18name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_19purpose,  &_purpose);
#else
    a = new STEPattribute(*a_19purpose,  &_purpose);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_20kind, (SCLP23(Application_instance_ptr) *) &_kind);
#else
    a = new STEPattribute(*a_20kind, (SCLP23(Application_instance_ptr) *) &_kind);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCertification::SdaiCertification (SdaiCertification& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCertification::~SdaiCertification () {  }

#ifdef __OSTORE__

void
SdaiCertification::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCertification: virtual access function." << endl;
    SdaiCertification_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCertification_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCertification: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCertification *ent = (SdaiCertification *)sent;
//    SdaiCertification *ent = (SdaiCertification *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_certification;
    ent->attributes[0].aDesc = a_18name;
    ent->attributes[1].aDesc = a_19purpose;
    ent->attributes[2].aDesc = a_20kind;
    if(ent->_kind == 0)
        ent->_kind = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiCertification(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCertification::get_os_typespec())
                                   SdaiCertification;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCertification::get_os_typespec())
//                                   SdaiCertification;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCertification;
}
#endif

#ifdef __O3DB__
void
SdaiCertification::oodb_reInit ()
{	eDesc = config_control_designe_certification;
	attributes [0].aDesc = a_18name;
	attributes [1].aDesc = a_19purpose;
	attributes [2].aDesc = a_20kind;
}
#endif

SdaiCertification::SdaiCertification( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_certification;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_18name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_18name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_19purpose,  &_purpose);
#else
    a = new STEPattribute(*a_19purpose,  &_purpose);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_20kind, (SCLP23(Application_instance_ptr) *) &_kind);
#else
    a = new STEPattribute(*a_20kind, (SCLP23(Application_instance_ptr) *) &_kind);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiCertification::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiCertification::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiCertification::purpose_() const
{
    return (const SdaiText) _purpose;
}

void
SdaiCertification::purpose_ (const SdaiText x)

{
    _purpose = x;
}

const SdaiCertification_type_ptr
SdaiCertification::kind_() const
{
    return (SdaiCertification_type_ptr) _kind;
}

void
SdaiCertification::kind_ (const SdaiCertification_type_ptr x)

{
    _kind = x;
}

/////////	 END_ENTITY certification


/////////	 ENTITY product_definition_relationship

EntityDescriptor *config_control_designe_product_definition_relationship =0;
AttrDescriptor *a_21id =0;
AttrDescriptor *a_22name =0;
AttrDescriptor *a_23description =0;
AttrDescriptor *a_24relating_product_definition =0;
AttrDescriptor *a_25related_product_definition =0;
SdaiProduct_definition_relationship::SdaiProduct_definition_relationship( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_21id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_21id,  &_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_22name,  &_name);
#else
    a = new STEPattribute(*a_22name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_23description,  &_description);
#else
    a = new STEPattribute(*a_23description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_24relating_product_definition, (SCLP23(Application_instance_ptr) *) &_relating_product_definition);
#else
    a = new STEPattribute(*a_24relating_product_definition, (SCLP23(Application_instance_ptr) *) &_relating_product_definition);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_25related_product_definition, (SCLP23(Application_instance_ptr) *) &_related_product_definition);
#else
    a = new STEPattribute(*a_25related_product_definition, (SCLP23(Application_instance_ptr) *) &_related_product_definition);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_relationship::SdaiProduct_definition_relationship (SdaiProduct_definition_relationship& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_definition_relationship::~SdaiProduct_definition_relationship () {  }

#ifdef __OSTORE__

void
SdaiProduct_definition_relationship::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_relationship: virtual access function." << endl;
    SdaiProduct_definition_relationship_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_definition_relationship_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_relationship: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_definition_relationship *ent = (SdaiProduct_definition_relationship *)sent;
//    SdaiProduct_definition_relationship *ent = (SdaiProduct_definition_relationship *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_definition_relationship;
    ent->attributes[0].aDesc = a_21id;
    ent->attributes[1].aDesc = a_22name;
    ent->attributes[2].aDesc = a_23description;
    ent->attributes[3].aDesc = a_24relating_product_definition;
    if(ent->_relating_product_definition == 0)
        ent->_relating_product_definition = S_ENTITY_NULL;
    ent->attributes[4].aDesc = a_25related_product_definition;
    if(ent->_related_product_definition == 0)
        ent->_related_product_definition = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_definition_relationship(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_definition_relationship::get_os_typespec())
                                   SdaiProduct_definition_relationship;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_definition_relationship::get_os_typespec())
//                                   SdaiProduct_definition_relationship;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_definition_relationship;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_definition_relationship::oodb_reInit ()
{	eDesc = config_control_designe_product_definition_relationship;
	attributes [0].aDesc = a_21id;
	attributes [1].aDesc = a_22name;
	attributes [2].aDesc = a_23description;
	attributes [3].aDesc = a_24relating_product_definition;
	attributes [4].aDesc = a_25related_product_definition;
}
#endif

SdaiProduct_definition_relationship::SdaiProduct_definition_relationship( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_21id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_21id,  &_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_22name,  &_name);
#else
    a = new STEPattribute(*a_22name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_23description,  &_description);
#else
    a = new STEPattribute(*a_23description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_24relating_product_definition, (SCLP23(Application_instance_ptr) *) &_relating_product_definition);
#else
    a = new STEPattribute(*a_24relating_product_definition, (SCLP23(Application_instance_ptr) *) &_relating_product_definition);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_25related_product_definition, (SCLP23(Application_instance_ptr) *) &_related_product_definition);
#else
    a = new STEPattribute(*a_25related_product_definition, (SCLP23(Application_instance_ptr) *) &_related_product_definition);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiProduct_definition_relationship::id_() const
{
    return (const SdaiIdentifier) _id;
}

void
SdaiProduct_definition_relationship::id_ (const SdaiIdentifier x)

{
    _id = x;
}

const SdaiLabel
SdaiProduct_definition_relationship::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiProduct_definition_relationship::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiProduct_definition_relationship::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiProduct_definition_relationship::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiProduct_definition_ptr
SdaiProduct_definition_relationship::relating_product_definition_() const
{
    return (SdaiProduct_definition_ptr) _relating_product_definition;
}

void
SdaiProduct_definition_relationship::relating_product_definition_ (const SdaiProduct_definition_ptr x)

{
    _relating_product_definition = x;
}

const SdaiProduct_definition_ptr
SdaiProduct_definition_relationship::related_product_definition_() const
{
    return (SdaiProduct_definition_ptr) _related_product_definition;
}

void
SdaiProduct_definition_relationship::related_product_definition_ (const SdaiProduct_definition_ptr x)

{
    _related_product_definition = x;
}

/////////	 END_ENTITY product_definition_relationship


/////////	 ENTITY product_definition_usage

EntityDescriptor *config_control_designe_product_definition_usage =0;
SdaiProduct_definition_usage::SdaiProduct_definition_usage( )
{

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_usage;
}
SdaiProduct_definition_usage::SdaiProduct_definition_usage (SdaiProduct_definition_usage& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_definition_usage::~SdaiProduct_definition_usage () {  }

#ifdef __OSTORE__

void
SdaiProduct_definition_usage::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_usage: virtual access function." << endl;
    SdaiProduct_definition_usage_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_definition_usage_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_usage: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_definition_usage *ent = (SdaiProduct_definition_usage *)sent;
//    SdaiProduct_definition_usage *ent = (SdaiProduct_definition_usage *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_definition_usage;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_definition_usage(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_definition_usage::get_os_typespec())
                                   SdaiProduct_definition_usage;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_definition_usage::get_os_typespec())
//                                   SdaiProduct_definition_usage;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_definition_usage;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_definition_usage::oodb_reInit ()
{	eDesc = config_control_designe_product_definition_usage;
}
#endif

SdaiProduct_definition_usage::SdaiProduct_definition_usage (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProduct_definition_relationship(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_usage;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_usage


/////////	 ENTITY assembly_component_usage

EntityDescriptor *config_control_designe_assembly_component_usage =0;
AttrDescriptor *a_26reference_designator =0;
SdaiAssembly_component_usage::SdaiAssembly_component_usage( )
{

	/*  parent: SdaiProduct_definition_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_assembly_component_usage;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_26reference_designator,  &_reference_designator);
#else
    STEPattribute *a = new STEPattribute(*a_26reference_designator,  &_reference_designator);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAssembly_component_usage::SdaiAssembly_component_usage (SdaiAssembly_component_usage& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAssembly_component_usage::~SdaiAssembly_component_usage () {  }

#ifdef __OSTORE__

void
SdaiAssembly_component_usage::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAssembly_component_usage: virtual access function." << endl;
    SdaiAssembly_component_usage_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAssembly_component_usage_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAssembly_component_usage: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAssembly_component_usage *ent = (SdaiAssembly_component_usage *)sent;
//    SdaiAssembly_component_usage *ent = (SdaiAssembly_component_usage *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_assembly_component_usage;
    ent->attributes[5].aDesc = a_26reference_designator;
}

SCLP23(Application_instance_ptr)
create_SdaiAssembly_component_usage(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAssembly_component_usage::get_os_typespec())
                                   SdaiAssembly_component_usage;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAssembly_component_usage::get_os_typespec())
//                                   SdaiAssembly_component_usage;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAssembly_component_usage;
}
#endif

#ifdef __O3DB__
void
SdaiAssembly_component_usage::oodb_reInit ()
{	eDesc = config_control_designe_assembly_component_usage;
	attributes [5].aDesc = a_26reference_designator;
}
#endif

SdaiAssembly_component_usage::SdaiAssembly_component_usage (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProduct_definition_usage(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProduct_definition_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_assembly_component_usage;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_26reference_designator,  &_reference_designator);
#else
    STEPattribute *a = new STEPattribute(*a_26reference_designator,  &_reference_designator);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiAssembly_component_usage::reference_designator_() const
{
    return (const SdaiIdentifier) _reference_designator;
}

void
SdaiAssembly_component_usage::reference_designator_ (const SdaiIdentifier x)

{
    _reference_designator = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY assembly_component_usage


/////////	 ENTITY quantified_assembly_component_usage

EntityDescriptor *config_control_designe_quantified_assembly_component_usage =0;
AttrDescriptor *a_27quantity =0;
SdaiQuantified_assembly_component_usage::SdaiQuantified_assembly_component_usage( )
{

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quantified_assembly_component_usage;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_27quantity, (SCLP23(Application_instance_ptr) *) &_quantity);
#else
    STEPattribute *a = new STEPattribute(*a_27quantity, (SCLP23(Application_instance_ptr) *) &_quantity);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiQuantified_assembly_component_usage::SdaiQuantified_assembly_component_usage (SdaiQuantified_assembly_component_usage& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiQuantified_assembly_component_usage::~SdaiQuantified_assembly_component_usage () {  }

#ifdef __OSTORE__

void
SdaiQuantified_assembly_component_usage::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiQuantified_assembly_component_usage: virtual access function." << endl;
    SdaiQuantified_assembly_component_usage_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiQuantified_assembly_component_usage_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiQuantified_assembly_component_usage: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiQuantified_assembly_component_usage *ent = (SdaiQuantified_assembly_component_usage *)sent;
//    SdaiQuantified_assembly_component_usage *ent = (SdaiQuantified_assembly_component_usage *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_quantified_assembly_component_usage;
    ent->attributes[6].aDesc = a_27quantity;
    if(ent->_quantity == 0)
        ent->_quantity = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiQuantified_assembly_component_usage(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiQuantified_assembly_component_usage::get_os_typespec())
                                   SdaiQuantified_assembly_component_usage;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiQuantified_assembly_component_usage::get_os_typespec())
//                                   SdaiQuantified_assembly_component_usage;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiQuantified_assembly_component_usage;
}
#endif

#ifdef __O3DB__
void
SdaiQuantified_assembly_component_usage::oodb_reInit ()
{	eDesc = config_control_designe_quantified_assembly_component_usage;
	attributes [6].aDesc = a_27quantity;
}
#endif

SdaiQuantified_assembly_component_usage::SdaiQuantified_assembly_component_usage (SCLP23(Application_instance) *se, int *addAttrs) : SdaiAssembly_component_usage(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quantified_assembly_component_usage;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_27quantity, (SCLP23(Application_instance_ptr) *) &_quantity);
#else
    STEPattribute *a = new STEPattribute(*a_27quantity, (SCLP23(Application_instance_ptr) *) &_quantity);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiMeasure_with_unit_ptr
SdaiQuantified_assembly_component_usage::quantity_() const
{
    return (SdaiMeasure_with_unit_ptr) _quantity;
}

void
SdaiQuantified_assembly_component_usage::quantity_ (const SdaiMeasure_with_unit_ptr x)

{
    _quantity = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY quantified_assembly_component_usage


/////////	 ENTITY solid_model

EntityDescriptor *config_control_designe_solid_model =0;
SdaiSolid_model::SdaiSolid_model( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_model;
    MakeDerived ("dim");
}
SdaiSolid_model::SdaiSolid_model (SdaiSolid_model& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSolid_model::~SdaiSolid_model () {  }

#ifdef __OSTORE__

void
SdaiSolid_model::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSolid_model: virtual access function." << endl;
    SdaiSolid_model_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSolid_model_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSolid_model: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSolid_model *ent = (SdaiSolid_model *)sent;
//    SdaiSolid_model *ent = (SdaiSolid_model *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_solid_model;
}

SCLP23(Application_instance_ptr)
create_SdaiSolid_model(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSolid_model::get_os_typespec())
                                   SdaiSolid_model;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSolid_model::get_os_typespec())
//                                   SdaiSolid_model;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSolid_model;
}
#endif

#ifdef __O3DB__
void
SdaiSolid_model::oodb_reInit ()
{	eDesc = config_control_designe_solid_model;
}
#endif

SdaiSolid_model::SdaiSolid_model (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_model;
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY solid_model


/////////	 ENTITY manifold_solid_brep

EntityDescriptor *config_control_designe_manifold_solid_brep =0;
AttrDescriptor *a_28outer =0;
SdaiManifold_solid_brep::SdaiManifold_solid_brep( )
{

	/*  parent: SdaiSolid_model  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_manifold_solid_brep;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_28outer, (SCLP23(Application_instance_ptr) *) &_outer);
#else
    STEPattribute *a = new STEPattribute(*a_28outer, (SCLP23(Application_instance_ptr) *) &_outer);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiManifold_solid_brep::SdaiManifold_solid_brep (SdaiManifold_solid_brep& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiManifold_solid_brep::~SdaiManifold_solid_brep () {  }

#ifdef __OSTORE__

void
SdaiManifold_solid_brep::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiManifold_solid_brep: virtual access function." << endl;
    SdaiManifold_solid_brep_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiManifold_solid_brep_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiManifold_solid_brep: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiManifold_solid_brep *ent = (SdaiManifold_solid_brep *)sent;
//    SdaiManifold_solid_brep *ent = (SdaiManifold_solid_brep *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_manifold_solid_brep;
    ent->attributes[1].aDesc = a_28outer;
    if(ent->_outer == 0)
        ent->_outer = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiManifold_solid_brep(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiManifold_solid_brep::get_os_typespec())
                                   SdaiManifold_solid_brep;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiManifold_solid_brep::get_os_typespec())
//                                   SdaiManifold_solid_brep;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiManifold_solid_brep;
}
#endif

#ifdef __O3DB__
void
SdaiManifold_solid_brep::oodb_reInit ()
{	eDesc = config_control_designe_manifold_solid_brep;
	attributes [1].aDesc = a_28outer;
}
#endif

SdaiManifold_solid_brep::SdaiManifold_solid_brep (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSolid_model(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSolid_model  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_manifold_solid_brep;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_28outer, (SCLP23(Application_instance_ptr) *) &_outer);
#else
    STEPattribute *a = new STEPattribute(*a_28outer, (SCLP23(Application_instance_ptr) *) &_outer);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiClosed_shell_ptr
SdaiManifold_solid_brep::outer_() const
{
    return (SdaiClosed_shell_ptr) _outer;
}

void
SdaiManifold_solid_brep::outer_ (const SdaiClosed_shell_ptr x)

{
    _outer = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY manifold_solid_brep


/////////	 ENTITY faceted_brep

EntityDescriptor *config_control_designe_faceted_brep =0;
SdaiFaceted_brep::SdaiFaceted_brep( )
{

	/*  parent: SdaiManifold_solid_brep  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_faceted_brep;
    MakeDerived ("dim");
}
SdaiFaceted_brep::SdaiFaceted_brep (SdaiFaceted_brep& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiFaceted_brep::~SdaiFaceted_brep () {  }

#ifdef __OSTORE__

void
SdaiFaceted_brep::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFaceted_brep: virtual access function." << endl;
    SdaiFaceted_brep_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiFaceted_brep_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFaceted_brep: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiFaceted_brep *ent = (SdaiFaceted_brep *)sent;
//    SdaiFaceted_brep *ent = (SdaiFaceted_brep *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_faceted_brep;
}

SCLP23(Application_instance_ptr)
create_SdaiFaceted_brep(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiFaceted_brep::get_os_typespec())
                                   SdaiFaceted_brep;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiFaceted_brep::get_os_typespec())
//                                   SdaiFaceted_brep;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiFaceted_brep;
}
#endif

#ifdef __O3DB__
void
SdaiFaceted_brep::oodb_reInit ()
{	eDesc = config_control_designe_faceted_brep;
}
#endif

SdaiFaceted_brep::SdaiFaceted_brep (SCLP23(Application_instance) *se, int *addAttrs) : SdaiManifold_solid_brep(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiManifold_solid_brep  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_faceted_brep;
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY faceted_brep


/////////	 ENTITY action_directive

EntityDescriptor *config_control_designe_action_directive =0;
AttrDescriptor *a_29name =0;
AttrDescriptor *a_30description =0;
AttrDescriptor *a_31analysis =0;
AttrDescriptor *a_32comment =0;
AttrDescriptor *a_33requests =0;
SdaiAction_directive::SdaiAction_directive( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_directive;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_29name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_29name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_30description,  &_description);
#else
    a = new STEPattribute(*a_30description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_31analysis,  &_analysis);
#else
    a = new STEPattribute(*a_31analysis,  &_analysis);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_32comment,  &_comment);
#else
    a = new STEPattribute(*a_32comment,  &_comment);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_33requests,  &_requests);
#else
    a = new STEPattribute(*a_33requests,  &_requests);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_directive::SdaiAction_directive (SdaiAction_directive& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAction_directive::~SdaiAction_directive () {  }

#ifdef __OSTORE__

void
SdaiAction_directive::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_directive: virtual access function." << endl;
    SdaiAction_directive_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAction_directive_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_directive: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAction_directive *ent = (SdaiAction_directive *)sent;
//    SdaiAction_directive *ent = (SdaiAction_directive *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_action_directive;
    ent->attributes[0].aDesc = a_29name;
    ent->attributes[1].aDesc = a_30description;
    ent->attributes[2].aDesc = a_31analysis;
    ent->attributes[3].aDesc = a_32comment;
    ent->attributes[4].aDesc = a_33requests;
}

SCLP23(Application_instance_ptr)
create_SdaiAction_directive(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAction_directive::get_os_typespec())
                                   SdaiAction_directive;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAction_directive::get_os_typespec())
//                                   SdaiAction_directive;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAction_directive;
}
#endif

#ifdef __O3DB__
void
SdaiAction_directive::oodb_reInit ()
{	eDesc = config_control_designe_action_directive;
	attributes [0].aDesc = a_29name;
	attributes [1].aDesc = a_30description;
	attributes [2].aDesc = a_31analysis;
	attributes [3].aDesc = a_32comment;
	attributes [4].aDesc = a_33requests;
}
#endif

SdaiAction_directive::SdaiAction_directive( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_action_directive;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_29name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_29name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_30description,  &_description);
#else
    a = new STEPattribute(*a_30description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_31analysis,  &_analysis);
#else
    a = new STEPattribute(*a_31analysis,  &_analysis);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_32comment,  &_comment);
#else
    a = new STEPattribute(*a_32comment,  &_comment);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_33requests,  &_requests);
#else
    a = new STEPattribute(*a_33requests,  &_requests);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiAction_directive::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiAction_directive::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiAction_directive::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiAction_directive::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiText
SdaiAction_directive::analysis_() const
{
    return (const SdaiText) _analysis;
}

void
SdaiAction_directive::analysis_ (const SdaiText x)

{
    _analysis = x;
}

const SdaiText
SdaiAction_directive::comment_() const
{
    return (const SdaiText) _comment;
}

void
SdaiAction_directive::comment_ (const SdaiText x)

{
    _comment = x;
}

const EntityAggregate_ptr
SdaiAction_directive::requests_() const
{
    return (EntityAggregate_ptr) &_requests;
}

void
SdaiAction_directive::requests_ (const EntityAggregate_ptr x)

	{ _requests.ShallowCopy (*x); }

/////////	 END_ENTITY action_directive


/////////	 ENTITY named_unit

EntityDescriptor *config_control_designe_named_unit =0;
AttrDescriptor *a_34dimensions =0;
SdaiNamed_unit::SdaiNamed_unit( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_named_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_34dimensions, (SCLP23(Application_instance_ptr) *) &_dimensions);
#else
    STEPattribute *a = new STEPattribute(*a_34dimensions, (SCLP23(Application_instance_ptr) *) &_dimensions);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiNamed_unit::SdaiNamed_unit (SdaiNamed_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiNamed_unit::~SdaiNamed_unit () {  }

#ifdef __OSTORE__

void
SdaiNamed_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiNamed_unit: virtual access function." << endl;
    SdaiNamed_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiNamed_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiNamed_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiNamed_unit *ent = (SdaiNamed_unit *)sent;
//    SdaiNamed_unit *ent = (SdaiNamed_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_named_unit;
    ent->attributes[0].aDesc = a_34dimensions;
    if(ent->_dimensions == 0)
        ent->_dimensions = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiNamed_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiNamed_unit::get_os_typespec())
                                   SdaiNamed_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiNamed_unit::get_os_typespec())
//                                   SdaiNamed_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiNamed_unit;
}
#endif

#ifdef __O3DB__
void
SdaiNamed_unit::oodb_reInit ()
{	eDesc = config_control_designe_named_unit;
	attributes [0].aDesc = a_34dimensions;
}
#endif

SdaiNamed_unit::SdaiNamed_unit( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_named_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_34dimensions, (SCLP23(Application_instance_ptr) *) &_dimensions);
#else
    STEPattribute *a = new STEPattribute(*a_34dimensions, (SCLP23(Application_instance_ptr) *) &_dimensions);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiDimensional_exponents_ptr
SdaiNamed_unit::dimensions_() const
{
    return (SdaiDimensional_exponents_ptr) _dimensions;
}

void
SdaiNamed_unit::dimensions_ (const SdaiDimensional_exponents_ptr x)

{
    _dimensions = x;
}

/////////	 END_ENTITY named_unit


/////////	 ENTITY plane_angle_unit

EntityDescriptor *config_control_designe_plane_angle_unit =0;
SdaiPlane_angle_unit::SdaiPlane_angle_unit( )
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane_angle_unit;
}
SdaiPlane_angle_unit::SdaiPlane_angle_unit (SdaiPlane_angle_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPlane_angle_unit::~SdaiPlane_angle_unit () {  }

#ifdef __OSTORE__

void
SdaiPlane_angle_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPlane_angle_unit: virtual access function." << endl;
    SdaiPlane_angle_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPlane_angle_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPlane_angle_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPlane_angle_unit *ent = (SdaiPlane_angle_unit *)sent;
//    SdaiPlane_angle_unit *ent = (SdaiPlane_angle_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_plane_angle_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiPlane_angle_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPlane_angle_unit::get_os_typespec())
                                   SdaiPlane_angle_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPlane_angle_unit::get_os_typespec())
//                                   SdaiPlane_angle_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPlane_angle_unit;
}
#endif

#ifdef __O3DB__
void
SdaiPlane_angle_unit::oodb_reInit ()
{	eDesc = config_control_designe_plane_angle_unit;
}
#endif

SdaiPlane_angle_unit::SdaiPlane_angle_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiNamed_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane_angle_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY plane_angle_unit


/////////	 ENTITY measure_with_unit

EntityDescriptor *config_control_designe_measure_with_unit =0;
AttrDescriptor *a_35value_component =0;
AttrDescriptor *a_36unit_component =0;
SdaiMeasure_with_unit::SdaiMeasure_with_unit( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_measure_with_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_35value_component,  &_value_component);
#else
    STEPattribute *a = new STEPattribute(*a_35value_component,  &_value_component);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_36unit_component,  &_unit_component);
#else
    a = new STEPattribute(*a_36unit_component,  &_unit_component);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiMeasure_with_unit::SdaiMeasure_with_unit (SdaiMeasure_with_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiMeasure_with_unit::~SdaiMeasure_with_unit () {  }

#ifdef __OSTORE__

void
SdaiMeasure_with_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiMeasure_with_unit: virtual access function." << endl;
    SdaiMeasure_with_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiMeasure_with_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiMeasure_with_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiMeasure_with_unit *ent = (SdaiMeasure_with_unit *)sent;
//    SdaiMeasure_with_unit *ent = (SdaiMeasure_with_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_measure_with_unit;
    ent->attributes[0].aDesc = a_35value_component;
    ent->attributes[1].aDesc = a_36unit_component;
}

SCLP23(Application_instance_ptr)
create_SdaiMeasure_with_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiMeasure_with_unit::get_os_typespec())
                                   SdaiMeasure_with_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiMeasure_with_unit::get_os_typespec())
//                                   SdaiMeasure_with_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiMeasure_with_unit;
}
#endif

#ifdef __O3DB__
void
SdaiMeasure_with_unit::oodb_reInit ()
{	eDesc = config_control_designe_measure_with_unit;
	attributes [0].aDesc = a_35value_component;
	attributes [1].aDesc = a_36unit_component;
}
#endif

SdaiMeasure_with_unit::SdaiMeasure_with_unit( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_measure_with_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_35value_component,  &_value_component);
#else
    STEPattribute *a = new STEPattribute(*a_35value_component,  &_value_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_36unit_component,  &_unit_component);
#else
    a = new STEPattribute(*a_36unit_component,  &_unit_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiMeasure_value_ptr
SdaiMeasure_with_unit::value_component_() const
	{ return (const SdaiMeasure_value_ptr) &_value_component; }

void
SdaiMeasure_with_unit::value_component_ (const SdaiMeasure_value_ptr x)

	{ _value_component = x; }

const SdaiUnit_ptr
SdaiMeasure_with_unit::unit_component_() const
	{ return (const SdaiUnit_ptr) &_unit_component; }

void
SdaiMeasure_with_unit::unit_component_ (const SdaiUnit_ptr x)

	{ _unit_component = x; }

/////////	 END_ENTITY measure_with_unit


/////////	 ENTITY area_measure_with_unit

EntityDescriptor *config_control_designe_area_measure_with_unit =0;
SdaiArea_measure_with_unit::SdaiArea_measure_with_unit( )
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_area_measure_with_unit;
}
SdaiArea_measure_with_unit::SdaiArea_measure_with_unit (SdaiArea_measure_with_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiArea_measure_with_unit::~SdaiArea_measure_with_unit () {  }

#ifdef __OSTORE__

void
SdaiArea_measure_with_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiArea_measure_with_unit: virtual access function." << endl;
    SdaiArea_measure_with_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiArea_measure_with_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiArea_measure_with_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiArea_measure_with_unit *ent = (SdaiArea_measure_with_unit *)sent;
//    SdaiArea_measure_with_unit *ent = (SdaiArea_measure_with_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_area_measure_with_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiArea_measure_with_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiArea_measure_with_unit::get_os_typespec())
                                   SdaiArea_measure_with_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiArea_measure_with_unit::get_os_typespec())
//                                   SdaiArea_measure_with_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiArea_measure_with_unit;
}
#endif

#ifdef __O3DB__
void
SdaiArea_measure_with_unit::oodb_reInit ()
{	eDesc = config_control_designe_area_measure_with_unit;
}
#endif

SdaiArea_measure_with_unit::SdaiArea_measure_with_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiMeasure_with_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_area_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY area_measure_with_unit


/////////	 ENTITY effectivity

EntityDescriptor *config_control_designe_effectivity =0;
AttrDescriptor *a_37id =0;
SdaiEffectivity::SdaiEffectivity( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_37id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_37id,  &_id);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiEffectivity::SdaiEffectivity (SdaiEffectivity& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiEffectivity::~SdaiEffectivity () {  }

#ifdef __OSTORE__

void
SdaiEffectivity::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEffectivity: virtual access function." << endl;
    SdaiEffectivity_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiEffectivity_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEffectivity: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiEffectivity *ent = (SdaiEffectivity *)sent;
//    SdaiEffectivity *ent = (SdaiEffectivity *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_effectivity;
    ent->attributes[0].aDesc = a_37id;
}

SCLP23(Application_instance_ptr)
create_SdaiEffectivity(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiEffectivity::get_os_typespec())
                                   SdaiEffectivity;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiEffectivity::get_os_typespec())
//                                   SdaiEffectivity;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiEffectivity;
}
#endif

#ifdef __O3DB__
void
SdaiEffectivity::oodb_reInit ()
{	eDesc = config_control_designe_effectivity;
	attributes [0].aDesc = a_37id;
}
#endif

SdaiEffectivity::SdaiEffectivity( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_37id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_37id,  &_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiEffectivity::id_() const
{
    return (const SdaiIdentifier) _id;
}

void
SdaiEffectivity::id_ (const SdaiIdentifier x)

{
    _id = x;
}

/////////	 END_ENTITY effectivity


/////////	 ENTITY serial_numbered_effectivity

EntityDescriptor *config_control_designe_serial_numbered_effectivity =0;
AttrDescriptor *a_38effectivity_start_id =0;
AttrDescriptor *a_39effectivity_end_id =0;
SdaiSerial_numbered_effectivity::SdaiSerial_numbered_effectivity( )
{

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_serial_numbered_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_38effectivity_start_id,  &_effectivity_start_id);
#else
    STEPattribute *a = new STEPattribute(*a_38effectivity_start_id,  &_effectivity_start_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_39effectivity_end_id,  &_effectivity_end_id);
#else
    a = new STEPattribute(*a_39effectivity_end_id,  &_effectivity_end_id);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiSerial_numbered_effectivity::SdaiSerial_numbered_effectivity (SdaiSerial_numbered_effectivity& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSerial_numbered_effectivity::~SdaiSerial_numbered_effectivity () {  }

#ifdef __OSTORE__

void
SdaiSerial_numbered_effectivity::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSerial_numbered_effectivity: virtual access function." << endl;
    SdaiSerial_numbered_effectivity_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSerial_numbered_effectivity_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSerial_numbered_effectivity: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSerial_numbered_effectivity *ent = (SdaiSerial_numbered_effectivity *)sent;
//    SdaiSerial_numbered_effectivity *ent = (SdaiSerial_numbered_effectivity *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_serial_numbered_effectivity;
    ent->attributes[1].aDesc = a_38effectivity_start_id;
    ent->attributes[2].aDesc = a_39effectivity_end_id;
}

SCLP23(Application_instance_ptr)
create_SdaiSerial_numbered_effectivity(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSerial_numbered_effectivity::get_os_typespec())
                                   SdaiSerial_numbered_effectivity;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSerial_numbered_effectivity::get_os_typespec())
//                                   SdaiSerial_numbered_effectivity;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSerial_numbered_effectivity;
}
#endif

#ifdef __O3DB__
void
SdaiSerial_numbered_effectivity::oodb_reInit ()
{	eDesc = config_control_designe_serial_numbered_effectivity;
	attributes [1].aDesc = a_38effectivity_start_id;
	attributes [2].aDesc = a_39effectivity_end_id;
}
#endif

SdaiSerial_numbered_effectivity::SdaiSerial_numbered_effectivity (SCLP23(Application_instance) *se, int *addAttrs) : SdaiEffectivity(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_serial_numbered_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_38effectivity_start_id,  &_effectivity_start_id);
#else
    STEPattribute *a = new STEPattribute(*a_38effectivity_start_id,  &_effectivity_start_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_39effectivity_end_id,  &_effectivity_end_id);
#else
    a = new STEPattribute(*a_39effectivity_end_id,  &_effectivity_end_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiSerial_numbered_effectivity::effectivity_start_id_() const
{
    return (const SdaiIdentifier) _effectivity_start_id;
}

void
SdaiSerial_numbered_effectivity::effectivity_start_id_ (const SdaiIdentifier x)

{
    _effectivity_start_id = x;
}

const SdaiIdentifier
SdaiSerial_numbered_effectivity::effectivity_end_id_() const
{
    return (const SdaiIdentifier) _effectivity_end_id;
}

void
SdaiSerial_numbered_effectivity::effectivity_end_id_ (const SdaiIdentifier x)

{
    _effectivity_end_id = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY serial_numbered_effectivity


/////////	 ENTITY surface

EntityDescriptor *config_control_designe_surface =0;
SdaiSurface::SdaiSurface( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface;
    MakeDerived ("dim");
}
SdaiSurface::SdaiSurface (SdaiSurface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSurface::~SdaiSurface () {  }

#ifdef __OSTORE__

void
SdaiSurface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface: virtual access function." << endl;
    SdaiSurface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSurface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSurface *ent = (SdaiSurface *)sent;
//    SdaiSurface *ent = (SdaiSurface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_surface;
}

SCLP23(Application_instance_ptr)
create_SdaiSurface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSurface::get_os_typespec())
                                   SdaiSurface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSurface::get_os_typespec())
//                                   SdaiSurface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSurface;
}
#endif

#ifdef __O3DB__
void
SdaiSurface::oodb_reInit ()
{	eDesc = config_control_designe_surface;
}
#endif

SdaiSurface::SdaiSurface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface;
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY surface


/////////	 ENTITY offset_surface

EntityDescriptor *config_control_designe_offset_surface =0;
AttrDescriptor *a_40basis_surface =0;
AttrDescriptor *a_41distance =0;
AttrDescriptor *a_42self_intersect =0;
SdaiOffset_surface::SdaiOffset_surface( )
{

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_offset_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_40basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_40basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_41distance,  &_distance);
#else
    a = new STEPattribute(*a_41distance,  &_distance);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_42self_intersect,  &_self_intersect);
#else
    a = new STEPattribute(*a_42self_intersect,  &_self_intersect);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiOffset_surface::SdaiOffset_surface (SdaiOffset_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOffset_surface::~SdaiOffset_surface () {  }

#ifdef __OSTORE__

void
SdaiOffset_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOffset_surface: virtual access function." << endl;
    SdaiOffset_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOffset_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOffset_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOffset_surface *ent = (SdaiOffset_surface *)sent;
//    SdaiOffset_surface *ent = (SdaiOffset_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_offset_surface;
    ent->attributes[1].aDesc = a_40basis_surface;
    if(ent->_basis_surface == 0)
        ent->_basis_surface = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_41distance;
    ent->attributes[3].aDesc = a_42self_intersect;
}

SCLP23(Application_instance_ptr)
create_SdaiOffset_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOffset_surface::get_os_typespec())
                                   SdaiOffset_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOffset_surface::get_os_typespec())
//                                   SdaiOffset_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOffset_surface;
}
#endif

#ifdef __O3DB__
void
SdaiOffset_surface::oodb_reInit ()
{	eDesc = config_control_designe_offset_surface;
	attributes [1].aDesc = a_40basis_surface;
	attributes [2].aDesc = a_41distance;
	attributes [3].aDesc = a_42self_intersect;
}
#endif

SdaiOffset_surface::SdaiOffset_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSurface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_offset_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_40basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_40basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_41distance,  &_distance);
#else
    a = new STEPattribute(*a_41distance,  &_distance);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_42self_intersect,  &_self_intersect);
#else
    a = new STEPattribute(*a_42self_intersect,  &_self_intersect);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiSurface_ptr
SdaiOffset_surface::basis_surface_() const
{
    return (SdaiSurface_ptr) _basis_surface;
}

void
SdaiOffset_surface::basis_surface_ (const SdaiSurface_ptr x)

{
    _basis_surface = x;
}

const SdaiLength_measure
SdaiOffset_surface::distance_() const
{
    return (const SdaiLength_measure) _distance;
}

void
SdaiOffset_surface::distance_ (const SdaiLength_measure x)

{
    _distance = x;
}

const SCLLOG(Logical)
SdaiOffset_surface::self_intersect_() const
{
    return (SCLLOG(Logical)) _self_intersect;
}

void
SdaiOffset_surface::self_intersect_ (const SCLLOG(Logical) x)

{
    _self_intersect.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY offset_surface


/////////	 ENTITY placement

EntityDescriptor *config_control_designe_placement =0;
AttrDescriptor *a_43location =0;
SdaiPlacement::SdaiPlacement( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_placement;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_43location, (SCLP23(Application_instance_ptr) *) &_location);
#else
    STEPattribute *a = new STEPattribute(*a_43location, (SCLP23(Application_instance_ptr) *) &_location);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiPlacement::SdaiPlacement (SdaiPlacement& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPlacement::~SdaiPlacement () {  }

#ifdef __OSTORE__

void
SdaiPlacement::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPlacement: virtual access function." << endl;
    SdaiPlacement_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPlacement_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPlacement: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPlacement *ent = (SdaiPlacement *)sent;
//    SdaiPlacement *ent = (SdaiPlacement *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_placement;
    ent->attributes[1].aDesc = a_43location;
    if(ent->_location == 0)
        ent->_location = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiPlacement(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPlacement::get_os_typespec())
                                   SdaiPlacement;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPlacement::get_os_typespec())
//                                   SdaiPlacement;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPlacement;
}
#endif

#ifdef __O3DB__
void
SdaiPlacement::oodb_reInit ()
{	eDesc = config_control_designe_placement;
	attributes [1].aDesc = a_43location;
}
#endif

SdaiPlacement::SdaiPlacement (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_placement;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_43location, (SCLP23(Application_instance_ptr) *) &_location);
#else
    STEPattribute *a = new STEPattribute(*a_43location, (SCLP23(Application_instance_ptr) *) &_location);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiCartesian_point_ptr
SdaiPlacement::location_() const
{
    return (SdaiCartesian_point_ptr) _location;
}

void
SdaiPlacement::location_ (const SdaiCartesian_point_ptr x)

{
    _location = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY placement


/////////	 ENTITY axis2_placement_2d

EntityDescriptor *config_control_designe_axis2_placement_2d =0;
AttrDescriptor *a_44ref_direction =0;
Derived_attribute *a_45Dp =0;
SdaiAxis2_placement_2d::SdaiAxis2_placement_2d( )
{

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis2_placement_2d;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_44ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#else
    STEPattribute *a = new STEPattribute(*a_44ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("p");
}
SdaiAxis2_placement_2d::SdaiAxis2_placement_2d (SdaiAxis2_placement_2d& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAxis2_placement_2d::~SdaiAxis2_placement_2d () {  }

#ifdef __OSTORE__

void
SdaiAxis2_placement_2d::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAxis2_placement_2d: virtual access function." << endl;
    SdaiAxis2_placement_2d_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAxis2_placement_2d_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAxis2_placement_2d: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAxis2_placement_2d *ent = (SdaiAxis2_placement_2d *)sent;
//    SdaiAxis2_placement_2d *ent = (SdaiAxis2_placement_2d *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_axis2_placement_2d;
    ent->attributes[2].aDesc = a_44ref_direction;
    if(ent->_ref_direction == 0)
        ent->_ref_direction = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiAxis2_placement_2d(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAxis2_placement_2d::get_os_typespec())
                                   SdaiAxis2_placement_2d;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAxis2_placement_2d::get_os_typespec())
//                                   SdaiAxis2_placement_2d;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAxis2_placement_2d;
}
#endif

#ifdef __O3DB__
void
SdaiAxis2_placement_2d::oodb_reInit ()
{	eDesc = config_control_designe_axis2_placement_2d;
	attributes [2].aDesc = a_44ref_direction;
}
#endif

SdaiAxis2_placement_2d::SdaiAxis2_placement_2d (SCLP23(Application_instance) *se, int *addAttrs) : SdaiPlacement(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis2_placement_2d;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_44ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#else
    STEPattribute *a = new STEPattribute(*a_44ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("p");
}

const SdaiDirection_ptr
SdaiAxis2_placement_2d::ref_direction_() const
{
    return (SdaiDirection_ptr) _ref_direction;
}

void
SdaiAxis2_placement_2d::ref_direction_ (const SdaiDirection_ptr x)

{
    _ref_direction = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY axis2_placement_2d


/////////	 ENTITY product_category

EntityDescriptor *config_control_designe_product_category =0;
AttrDescriptor *a_46name =0;
AttrDescriptor *a_47description =0;
SdaiProduct_category::SdaiProduct_category( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_category;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_46name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_46name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_47description,  &_description);
#else
    a = new STEPattribute(*a_47description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_category::SdaiProduct_category (SdaiProduct_category& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_category::~SdaiProduct_category () {  }

#ifdef __OSTORE__

void
SdaiProduct_category::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_category: virtual access function." << endl;
    SdaiProduct_category_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_category_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_category: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_category *ent = (SdaiProduct_category *)sent;
//    SdaiProduct_category *ent = (SdaiProduct_category *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_category;
    ent->attributes[0].aDesc = a_46name;
    ent->attributes[1].aDesc = a_47description;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_category(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_category::get_os_typespec())
                                   SdaiProduct_category;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_category::get_os_typespec())
//                                   SdaiProduct_category;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_category;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_category::oodb_reInit ()
{	eDesc = config_control_designe_product_category;
	attributes [0].aDesc = a_46name;
	attributes [1].aDesc = a_47description;
}
#endif

SdaiProduct_category::SdaiProduct_category( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_product_category;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_46name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_46name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_47description,  &_description);
#else
    a = new STEPattribute(*a_47description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiProduct_category::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiProduct_category::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiProduct_category::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiProduct_category::description_ (const SdaiText x)

{
    _description = x;
}

/////////	 END_ENTITY product_category


/////////	 ENTITY product_related_product_category

EntityDescriptor *config_control_designe_product_related_product_category =0;
AttrDescriptor *a_48products =0;
SdaiProduct_related_product_category::SdaiProduct_related_product_category( )
{

	/*  parent: SdaiProduct_category  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_related_product_category;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_48products,  &_products);
#else
    STEPattribute *a = new STEPattribute(*a_48products,  &_products);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_related_product_category::SdaiProduct_related_product_category (SdaiProduct_related_product_category& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_related_product_category::~SdaiProduct_related_product_category () {  }

#ifdef __OSTORE__

void
SdaiProduct_related_product_category::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_related_product_category: virtual access function." << endl;
    SdaiProduct_related_product_category_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_related_product_category_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_related_product_category: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_related_product_category *ent = (SdaiProduct_related_product_category *)sent;
//    SdaiProduct_related_product_category *ent = (SdaiProduct_related_product_category *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_related_product_category;
    ent->attributes[2].aDesc = a_48products;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_related_product_category(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_related_product_category::get_os_typespec())
                                   SdaiProduct_related_product_category;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_related_product_category::get_os_typespec())
//                                   SdaiProduct_related_product_category;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_related_product_category;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_related_product_category::oodb_reInit ()
{	eDesc = config_control_designe_product_related_product_category;
	attributes [2].aDesc = a_48products;
}
#endif

SdaiProduct_related_product_category::SdaiProduct_related_product_category (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProduct_category(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProduct_category  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_related_product_category;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_48products,  &_products);
#else
    STEPattribute *a = new STEPattribute(*a_48products,  &_products);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const EntityAggregate_ptr
SdaiProduct_related_product_category::products_() const
{
    return (EntityAggregate_ptr) &_products;
}

void
SdaiProduct_related_product_category::products_ (const EntityAggregate_ptr x)

	{ _products.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_related_product_category


/////////	 ENTITY curve

EntityDescriptor *config_control_designe_curve =0;
SdaiCurve::SdaiCurve( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve;
    MakeDerived ("dim");
}
SdaiCurve::SdaiCurve (SdaiCurve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCurve::~SdaiCurve () {  }

#ifdef __OSTORE__

void
SdaiCurve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCurve: virtual access function." << endl;
    SdaiCurve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCurve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCurve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCurve *ent = (SdaiCurve *)sent;
//    SdaiCurve *ent = (SdaiCurve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_curve;
}

SCLP23(Application_instance_ptr)
create_SdaiCurve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCurve::get_os_typespec())
                                   SdaiCurve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCurve::get_os_typespec())
//                                   SdaiCurve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCurve;
}
#endif

#ifdef __O3DB__
void
SdaiCurve::oodb_reInit ()
{	eDesc = config_control_designe_curve;
}
#endif

SdaiCurve::SdaiCurve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve;
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY curve


/////////	 ENTITY conic

EntityDescriptor *config_control_designe_conic =0;
AttrDescriptor *a_49position =0;
SdaiConic::SdaiConic( )
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conic;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_49position,  &_position);
#else
    STEPattribute *a = new STEPattribute(*a_49position,  &_position);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiConic::SdaiConic (SdaiConic& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiConic::~SdaiConic () {  }

#ifdef __OSTORE__

void
SdaiConic::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConic: virtual access function." << endl;
    SdaiConic_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiConic_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConic: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiConic *ent = (SdaiConic *)sent;
//    SdaiConic *ent = (SdaiConic *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_conic;
    ent->attributes[1].aDesc = a_49position;
}

SCLP23(Application_instance_ptr)
create_SdaiConic(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiConic::get_os_typespec())
                                   SdaiConic;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiConic::get_os_typespec())
//                                   SdaiConic;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiConic;
}
#endif

#ifdef __O3DB__
void
SdaiConic::oodb_reInit ()
{	eDesc = config_control_designe_conic;
	attributes [1].aDesc = a_49position;
}
#endif

SdaiConic::SdaiConic (SCLP23(Application_instance) *se, int *addAttrs) : SdaiCurve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conic;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_49position,  &_position);
#else
    STEPattribute *a = new STEPattribute(*a_49position,  &_position);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiAxis2_placement_ptr
SdaiConic::position_() const
	{ return (const SdaiAxis2_placement_ptr) &_position; }

void
SdaiConic::position_ (const SdaiAxis2_placement_ptr x)

	{ _position = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY conic


/////////	 ENTITY hyperbola

EntityDescriptor *config_control_designe_hyperbola =0;
AttrDescriptor *a_50semi_axis =0;
AttrDescriptor *a_51semi_imag_axis =0;
SdaiHyperbola::SdaiHyperbola( )
{

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_hyperbola;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_50semi_axis,  &_semi_axis);
#else
    STEPattribute *a = new STEPattribute(*a_50semi_axis,  &_semi_axis);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_51semi_imag_axis,  &_semi_imag_axis);
#else
    a = new STEPattribute(*a_51semi_imag_axis,  &_semi_imag_axis);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiHyperbola::SdaiHyperbola (SdaiHyperbola& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiHyperbola::~SdaiHyperbola () {  }

#ifdef __OSTORE__

void
SdaiHyperbola::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiHyperbola: virtual access function." << endl;
    SdaiHyperbola_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiHyperbola_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiHyperbola: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiHyperbola *ent = (SdaiHyperbola *)sent;
//    SdaiHyperbola *ent = (SdaiHyperbola *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_hyperbola;
    ent->attributes[2].aDesc = a_50semi_axis;
    ent->attributes[3].aDesc = a_51semi_imag_axis;
}

SCLP23(Application_instance_ptr)
create_SdaiHyperbola(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiHyperbola::get_os_typespec())
                                   SdaiHyperbola;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiHyperbola::get_os_typespec())
//                                   SdaiHyperbola;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiHyperbola;
}
#endif

#ifdef __O3DB__
void
SdaiHyperbola::oodb_reInit ()
{	eDesc = config_control_designe_hyperbola;
	attributes [2].aDesc = a_50semi_axis;
	attributes [3].aDesc = a_51semi_imag_axis;
}
#endif

SdaiHyperbola::SdaiHyperbola (SCLP23(Application_instance) *se, int *addAttrs) : SdaiConic(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_hyperbola;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_50semi_axis,  &_semi_axis);
#else
    STEPattribute *a = new STEPattribute(*a_50semi_axis,  &_semi_axis);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_51semi_imag_axis,  &_semi_imag_axis);
#else
    a = new STEPattribute(*a_51semi_imag_axis,  &_semi_imag_axis);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiPositive_length_measure
SdaiHyperbola::semi_axis_() const
{
    return (const SdaiPositive_length_measure) _semi_axis;
}

void
SdaiHyperbola::semi_axis_ (const SdaiPositive_length_measure x)

{
    _semi_axis = x;
}

const SdaiPositive_length_measure
SdaiHyperbola::semi_imag_axis_() const
{
    return (const SdaiPositive_length_measure) _semi_imag_axis;
}

void
SdaiHyperbola::semi_imag_axis_ (const SdaiPositive_length_measure x)

{
    _semi_imag_axis = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY hyperbola


/////////	 ENTITY address

EntityDescriptor *config_control_designe_address =0;
AttrDescriptor *a_52internal_location =0;
AttrDescriptor *a_53street_number =0;
AttrDescriptor *a_54street =0;
AttrDescriptor *a_55postal_box =0;
AttrDescriptor *a_56town =0;
AttrDescriptor *a_57region =0;
AttrDescriptor *a_58postal_code =0;
AttrDescriptor *a_59country =0;
AttrDescriptor *a_60facsimile_number =0;
AttrDescriptor *a_61telephone_number =0;
AttrDescriptor *a_62electronic_mail_address =0;
AttrDescriptor *a_63telex_number =0;
SdaiAddress::SdaiAddress( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_address;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_52internal_location,  &_internal_location);
#else
    STEPattribute *a = new STEPattribute(*a_52internal_location,  &_internal_location);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_53street_number,  &_street_number);
#else
    a = new STEPattribute(*a_53street_number,  &_street_number);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_54street,  &_street);
#else
    a = new STEPattribute(*a_54street,  &_street);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_55postal_box,  &_postal_box);
#else
    a = new STEPattribute(*a_55postal_box,  &_postal_box);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_56town,  &_town);
#else
    a = new STEPattribute(*a_56town,  &_town);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_57region,  &_region);
#else
    a = new STEPattribute(*a_57region,  &_region);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_58postal_code,  &_postal_code);
#else
    a = new STEPattribute(*a_58postal_code,  &_postal_code);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_59country,  &_country);
#else
    a = new STEPattribute(*a_59country,  &_country);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_60facsimile_number,  &_facsimile_number);
#else
    a = new STEPattribute(*a_60facsimile_number,  &_facsimile_number);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_61telephone_number,  &_telephone_number);
#else
    a = new STEPattribute(*a_61telephone_number,  &_telephone_number);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_62electronic_mail_address,  &_electronic_mail_address);
#else
    a = new STEPattribute(*a_62electronic_mail_address,  &_electronic_mail_address);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_63telex_number,  &_telex_number);
#else
    a = new STEPattribute(*a_63telex_number,  &_telex_number);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAddress::SdaiAddress (SdaiAddress& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAddress::~SdaiAddress () {  }

#ifdef __OSTORE__

void
SdaiAddress::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAddress: virtual access function." << endl;
    SdaiAddress_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAddress_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAddress: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAddress *ent = (SdaiAddress *)sent;
//    SdaiAddress *ent = (SdaiAddress *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_address;
    ent->attributes[0].aDesc = a_52internal_location;
    ent->attributes[1].aDesc = a_53street_number;
    ent->attributes[2].aDesc = a_54street;
    ent->attributes[3].aDesc = a_55postal_box;
    ent->attributes[4].aDesc = a_56town;
    ent->attributes[5].aDesc = a_57region;
    ent->attributes[6].aDesc = a_58postal_code;
    ent->attributes[7].aDesc = a_59country;
    ent->attributes[8].aDesc = a_60facsimile_number;
    ent->attributes[9].aDesc = a_61telephone_number;
    ent->attributes[10].aDesc = a_62electronic_mail_address;
    ent->attributes[11].aDesc = a_63telex_number;
}

SCLP23(Application_instance_ptr)
create_SdaiAddress(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAddress::get_os_typespec())
                                   SdaiAddress;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAddress::get_os_typespec())
//                                   SdaiAddress;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAddress;
}
#endif

#ifdef __O3DB__
void
SdaiAddress::oodb_reInit ()
{	eDesc = config_control_designe_address;
	attributes [0].aDesc = a_52internal_location;
	attributes [1].aDesc = a_53street_number;
	attributes [2].aDesc = a_54street;
	attributes [3].aDesc = a_55postal_box;
	attributes [4].aDesc = a_56town;
	attributes [5].aDesc = a_57region;
	attributes [6].aDesc = a_58postal_code;
	attributes [7].aDesc = a_59country;
	attributes [8].aDesc = a_60facsimile_number;
	attributes [9].aDesc = a_61telephone_number;
	attributes [10].aDesc = a_62electronic_mail_address;
	attributes [11].aDesc = a_63telex_number;
}
#endif

SdaiAddress::SdaiAddress( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_address;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_52internal_location,  &_internal_location);
#else
    STEPattribute *a = new STEPattribute(*a_52internal_location,  &_internal_location);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_53street_number,  &_street_number);
#else
    a = new STEPattribute(*a_53street_number,  &_street_number);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_54street,  &_street);
#else
    a = new STEPattribute(*a_54street,  &_street);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_55postal_box,  &_postal_box);
#else
    a = new STEPattribute(*a_55postal_box,  &_postal_box);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_56town,  &_town);
#else
    a = new STEPattribute(*a_56town,  &_town);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_57region,  &_region);
#else
    a = new STEPattribute(*a_57region,  &_region);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_58postal_code,  &_postal_code);
#else
    a = new STEPattribute(*a_58postal_code,  &_postal_code);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_59country,  &_country);
#else
    a = new STEPattribute(*a_59country,  &_country);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_60facsimile_number,  &_facsimile_number);
#else
    a = new STEPattribute(*a_60facsimile_number,  &_facsimile_number);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_61telephone_number,  &_telephone_number);
#else
    a = new STEPattribute(*a_61telephone_number,  &_telephone_number);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_62electronic_mail_address,  &_electronic_mail_address);
#else
    a = new STEPattribute(*a_62electronic_mail_address,  &_electronic_mail_address);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_63telex_number,  &_telex_number);
#else
    a = new STEPattribute(*a_63telex_number,  &_telex_number);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiAddress::internal_location_() const
{
    return (const SdaiLabel) _internal_location;
}

void
SdaiAddress::internal_location_ (const SdaiLabel x)

{
    _internal_location = x;
}

const SdaiLabel
SdaiAddress::street_number_() const
{
    return (const SdaiLabel) _street_number;
}

void
SdaiAddress::street_number_ (const SdaiLabel x)

{
    _street_number = x;
}

const SdaiLabel
SdaiAddress::street_() const
{
    return (const SdaiLabel) _street;
}

void
SdaiAddress::street_ (const SdaiLabel x)

{
    _street = x;
}

const SdaiLabel
SdaiAddress::postal_box_() const
{
    return (const SdaiLabel) _postal_box;
}

void
SdaiAddress::postal_box_ (const SdaiLabel x)

{
    _postal_box = x;
}

const SdaiLabel
SdaiAddress::town_() const
{
    return (const SdaiLabel) _town;
}

void
SdaiAddress::town_ (const SdaiLabel x)

{
    _town = x;
}

const SdaiLabel
SdaiAddress::region_() const
{
    return (const SdaiLabel) _region;
}

void
SdaiAddress::region_ (const SdaiLabel x)

{
    _region = x;
}

const SdaiLabel
SdaiAddress::postal_code_() const
{
    return (const SdaiLabel) _postal_code;
}

void
SdaiAddress::postal_code_ (const SdaiLabel x)

{
    _postal_code = x;
}

const SdaiLabel
SdaiAddress::country_() const
{
    return (const SdaiLabel) _country;
}

void
SdaiAddress::country_ (const SdaiLabel x)

{
    _country = x;
}

const SdaiLabel
SdaiAddress::facsimile_number_() const
{
    return (const SdaiLabel) _facsimile_number;
}

void
SdaiAddress::facsimile_number_ (const SdaiLabel x)

{
    _facsimile_number = x;
}

const SdaiLabel
SdaiAddress::telephone_number_() const
{
    return (const SdaiLabel) _telephone_number;
}

void
SdaiAddress::telephone_number_ (const SdaiLabel x)

{
    _telephone_number = x;
}

const SdaiLabel
SdaiAddress::electronic_mail_address_() const
{
    return (const SdaiLabel) _electronic_mail_address;
}

void
SdaiAddress::electronic_mail_address_ (const SdaiLabel x)

{
    _electronic_mail_address = x;
}

const SdaiLabel
SdaiAddress::telex_number_() const
{
    return (const SdaiLabel) _telex_number;
}

void
SdaiAddress::telex_number_ (const SdaiLabel x)

{
    _telex_number = x;
}

/////////	 END_ENTITY address


/////////	 ENTITY organizational_address

EntityDescriptor *config_control_designe_organizational_address =0;
AttrDescriptor *a_64organizations =0;
AttrDescriptor *a_65description =0;
SdaiOrganizational_address::SdaiOrganizational_address( )
{

	/*  parent: SdaiAddress  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_organizational_address;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_64organizations,  &_organizations);
#else
    STEPattribute *a = new STEPattribute(*a_64organizations,  &_organizations);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_65description,  &_description);
#else
    a = new STEPattribute(*a_65description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiOrganizational_address::SdaiOrganizational_address (SdaiOrganizational_address& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOrganizational_address::~SdaiOrganizational_address () {  }

#ifdef __OSTORE__

void
SdaiOrganizational_address::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOrganizational_address: virtual access function." << endl;
    SdaiOrganizational_address_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOrganizational_address_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOrganizational_address: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOrganizational_address *ent = (SdaiOrganizational_address *)sent;
//    SdaiOrganizational_address *ent = (SdaiOrganizational_address *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_organizational_address;
    ent->attributes[12].aDesc = a_64organizations;
    ent->attributes[13].aDesc = a_65description;
}

SCLP23(Application_instance_ptr)
create_SdaiOrganizational_address(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOrganizational_address::get_os_typespec())
                                   SdaiOrganizational_address;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOrganizational_address::get_os_typespec())
//                                   SdaiOrganizational_address;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOrganizational_address;
}
#endif

#ifdef __O3DB__
void
SdaiOrganizational_address::oodb_reInit ()
{	eDesc = config_control_designe_organizational_address;
	attributes [12].aDesc = a_64organizations;
	attributes [13].aDesc = a_65description;
}
#endif

SdaiOrganizational_address::SdaiOrganizational_address (SCLP23(Application_instance) *se, int *addAttrs) : SdaiAddress(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiAddress  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_organizational_address;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_64organizations,  &_organizations);
#else
    STEPattribute *a = new STEPattribute(*a_64organizations,  &_organizations);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_65description,  &_description);
#else
    a = new STEPattribute(*a_65description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const EntityAggregate_ptr
SdaiOrganizational_address::organizations_() const
{
    return (EntityAggregate_ptr) &_organizations;
}

void
SdaiOrganizational_address::organizations_ (const EntityAggregate_ptr x)

	{ _organizations.ShallowCopy (*x); }

const SdaiText
SdaiOrganizational_address::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiOrganizational_address::description_ (const SdaiText x)

{
    _description = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY organizational_address


/////////	 ENTITY bounded_surface

EntityDescriptor *config_control_designe_bounded_surface =0;
SdaiBounded_surface::SdaiBounded_surface( )
{

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bounded_surface;
    MakeDerived ("dim");
}
SdaiBounded_surface::SdaiBounded_surface (SdaiBounded_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiBounded_surface::~SdaiBounded_surface () {  }

#ifdef __OSTORE__

void
SdaiBounded_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBounded_surface: virtual access function." << endl;
    SdaiBounded_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiBounded_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBounded_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiBounded_surface *ent = (SdaiBounded_surface *)sent;
//    SdaiBounded_surface *ent = (SdaiBounded_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_bounded_surface;
}

SCLP23(Application_instance_ptr)
create_SdaiBounded_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiBounded_surface::get_os_typespec())
                                   SdaiBounded_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiBounded_surface::get_os_typespec())
//                                   SdaiBounded_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiBounded_surface;
}
#endif

#ifdef __O3DB__
void
SdaiBounded_surface::oodb_reInit ()
{	eDesc = config_control_designe_bounded_surface;
}
#endif

SdaiBounded_surface::SdaiBounded_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSurface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bounded_surface;
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY bounded_surface


/////////	 ENTITY b_spline_surface

EntityDescriptor *config_control_designe_b_spline_surface =0;
AttrDescriptor *a_66u_degree =0;
AttrDescriptor *a_67v_degree =0;
AttrDescriptor *a_68control_points_list =0;
AttrDescriptor *a_69surface_form =0;
AttrDescriptor *a_70u_closed =0;
AttrDescriptor *a_71v_closed =0;
AttrDescriptor *a_72self_intersect =0;
Derived_attribute *a_73Du_upper =0;
Derived_attribute *a_74Dv_upper =0;
Derived_attribute *a_75Dcontrol_points =0;
SdaiB_spline_surface::SdaiB_spline_surface( )
{

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_66u_degree,  &_u_degree);
#else
    STEPattribute *a = new STEPattribute(*a_66u_degree,  &_u_degree);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_67v_degree,  &_v_degree);
#else
    a = new STEPattribute(*a_67v_degree,  &_v_degree);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_68control_points_list,  &_control_points_list);
#else
    a = new STEPattribute(*a_68control_points_list,  &_control_points_list);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_69surface_form,  &_surface_form);
#else
    a = new STEPattribute(*a_69surface_form,  &_surface_form);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_70u_closed,  &_u_closed);
#else
    a = new STEPattribute(*a_70u_closed,  &_u_closed);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_71v_closed,  &_v_closed);
#else
    a = new STEPattribute(*a_71v_closed,  &_v_closed);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_72self_intersect,  &_self_intersect);
#else
    a = new STEPattribute(*a_72self_intersect,  &_self_intersect);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
}
SdaiB_spline_surface::SdaiB_spline_surface (SdaiB_spline_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiB_spline_surface::~SdaiB_spline_surface () {  }

#ifdef __OSTORE__

void
SdaiB_spline_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiB_spline_surface: virtual access function." << endl;
    SdaiB_spline_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiB_spline_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiB_spline_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiB_spline_surface *ent = (SdaiB_spline_surface *)sent;
//    SdaiB_spline_surface *ent = (SdaiB_spline_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_b_spline_surface;
    ent->attributes[1].aDesc = a_66u_degree;
    ent->attributes[2].aDesc = a_67v_degree;
    ent->attributes[3].aDesc = a_68control_points_list;
    ent->attributes[4].aDesc = a_69surface_form;
    ent->attributes[5].aDesc = a_70u_closed;
    ent->attributes[6].aDesc = a_71v_closed;
    ent->attributes[7].aDesc = a_72self_intersect;
}

SCLP23(Application_instance_ptr)
create_SdaiB_spline_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiB_spline_surface::get_os_typespec())
                                   SdaiB_spline_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiB_spline_surface::get_os_typespec())
//                                   SdaiB_spline_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiB_spline_surface;
}
#endif

#ifdef __O3DB__
void
SdaiB_spline_surface::oodb_reInit ()
{	eDesc = config_control_designe_b_spline_surface;
	attributes [1].aDesc = a_66u_degree;
	attributes [2].aDesc = a_67v_degree;
	attributes [3].aDesc = a_68control_points_list;
	attributes [4].aDesc = a_69surface_form;
	attributes [5].aDesc = a_70u_closed;
	attributes [6].aDesc = a_71v_closed;
	attributes [7].aDesc = a_72self_intersect;
}
#endif

SdaiB_spline_surface::SdaiB_spline_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiBounded_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_66u_degree,  &_u_degree);
#else
    STEPattribute *a = new STEPattribute(*a_66u_degree,  &_u_degree);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_67v_degree,  &_v_degree);
#else
    a = new STEPattribute(*a_67v_degree,  &_v_degree);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_68control_points_list,  &_control_points_list);
#else
    a = new STEPattribute(*a_68control_points_list,  &_control_points_list);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_69surface_form,  &_surface_form);
#else
    a = new STEPattribute(*a_69surface_form,  &_surface_form);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_70u_closed,  &_u_closed);
#else
    a = new STEPattribute(*a_70u_closed,  &_u_closed);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_71v_closed,  &_v_closed);
#else
    a = new STEPattribute(*a_71v_closed,  &_v_closed);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_72self_intersect,  &_self_intersect);
#else
    a = new STEPattribute(*a_72self_intersect,  &_self_intersect);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
}

const SCLP23(Integer)
SdaiB_spline_surface::u_degree_() const
{
    return (const SCLP23(Integer)) _u_degree;
}

void
SdaiB_spline_surface::u_degree_ (const SCLP23(Integer) x)

{
    _u_degree = x;
}

const SCLP23(Integer)
SdaiB_spline_surface::v_degree_() const
{
    return (const SCLP23(Integer)) _v_degree;
}

void
SdaiB_spline_surface::v_degree_ (const SCLP23(Integer) x)

{
    _v_degree = x;
}

const GenericAggregate_ptr
SdaiB_spline_surface::control_points_list_() const
{
    return (GenericAggregate_ptr) &_control_points_list;
}

void
SdaiB_spline_surface::control_points_list_ (const GenericAggregate_ptr x)

	{ _control_points_list.ShallowCopy (*x); }

const SdaiB_spline_surface_form_var
SdaiB_spline_surface::surface_form_() const
{
    return (B_spline_surface_form) _surface_form;
}

void
SdaiB_spline_surface::surface_form_ (const SdaiB_spline_surface_form_var x)

{
    _surface_form.put (x);
}

const SCLLOG(Logical)
SdaiB_spline_surface::u_closed_() const
{
    return (SCLLOG(Logical)) _u_closed;
}

void
SdaiB_spline_surface::u_closed_ (const SCLLOG(Logical) x)

{
    _u_closed.put (x);
}

const SCLLOG(Logical)
SdaiB_spline_surface::v_closed_() const
{
    return (SCLLOG(Logical)) _v_closed;
}

void
SdaiB_spline_surface::v_closed_ (const SCLLOG(Logical) x)

{
    _v_closed.put (x);
}

const SCLLOG(Logical)
SdaiB_spline_surface::self_intersect_() const
{
    return (SCLLOG(Logical)) _self_intersect;
}

void
SdaiB_spline_surface::self_intersect_ (const SCLLOG(Logical) x)

{
    _self_intersect.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY b_spline_surface


/////////	 ENTITY uniform_surface

EntityDescriptor *config_control_designe_uniform_surface =0;
SdaiUniform_surface::SdaiUniform_surface( )
{

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uniform_surface;
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
}
SdaiUniform_surface::SdaiUniform_surface (SdaiUniform_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiUniform_surface::~SdaiUniform_surface () {  }

#ifdef __OSTORE__

void
SdaiUniform_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiUniform_surface: virtual access function." << endl;
    SdaiUniform_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiUniform_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiUniform_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiUniform_surface *ent = (SdaiUniform_surface *)sent;
//    SdaiUniform_surface *ent = (SdaiUniform_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_uniform_surface;
}

SCLP23(Application_instance_ptr)
create_SdaiUniform_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiUniform_surface::get_os_typespec())
                                   SdaiUniform_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiUniform_surface::get_os_typespec())
//                                   SdaiUniform_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiUniform_surface;
}
#endif

#ifdef __O3DB__
void
SdaiUniform_surface::oodb_reInit ()
{	eDesc = config_control_designe_uniform_surface;
}
#endif

SdaiUniform_surface::SdaiUniform_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiB_spline_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uniform_surface;
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY uniform_surface


/////////	 ENTITY geometrically_bounded_surface_shape_representation

EntityDescriptor *config_control_designe_geometrically_bounded_surface_shape_representation =0;
SdaiGeometrically_bounded_surface_shape_representation::SdaiGeometrically_bounded_surface_shape_representation( )
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometrically_bounded_surface_shape_representation;
}
SdaiGeometrically_bounded_surface_shape_representation::SdaiGeometrically_bounded_surface_shape_representation (SdaiGeometrically_bounded_surface_shape_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiGeometrically_bounded_surface_shape_representation::~SdaiGeometrically_bounded_surface_shape_representation () {  }

#ifdef __OSTORE__

void
SdaiGeometrically_bounded_surface_shape_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometrically_bounded_surface_shape_representation: virtual access function." << endl;
    SdaiGeometrically_bounded_surface_shape_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiGeometrically_bounded_surface_shape_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometrically_bounded_surface_shape_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiGeometrically_bounded_surface_shape_representation *ent = (SdaiGeometrically_bounded_surface_shape_representation *)sent;
//    SdaiGeometrically_bounded_surface_shape_representation *ent = (SdaiGeometrically_bounded_surface_shape_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_geometrically_bounded_surface_shape_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiGeometrically_bounded_surface_shape_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiGeometrically_bounded_surface_shape_representation::get_os_typespec())
                                   SdaiGeometrically_bounded_surface_shape_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiGeometrically_bounded_surface_shape_representation::get_os_typespec())
//                                   SdaiGeometrically_bounded_surface_shape_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiGeometrically_bounded_surface_shape_representation;
}
#endif

#ifdef __O3DB__
void
SdaiGeometrically_bounded_surface_shape_representation::oodb_reInit ()
{	eDesc = config_control_designe_geometrically_bounded_surface_shape_representation;
}
#endif

SdaiGeometrically_bounded_surface_shape_representation::SdaiGeometrically_bounded_surface_shape_representation (SCLP23(Application_instance) *se, int *addAttrs) : SdaiShape_representation(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometrically_bounded_surface_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometrically_bounded_surface_shape_representation


/////////	 ENTITY axis1_placement

EntityDescriptor *config_control_designe_axis1_placement =0;
AttrDescriptor *a_76axis =0;
Derived_attribute *a_77Dz =0;
SdaiAxis1_placement::SdaiAxis1_placement( )
{

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis1_placement;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_76axis, (SCLP23(Application_instance_ptr) *) &_axis);
#else
    STEPattribute *a = new STEPattribute(*a_76axis, (SCLP23(Application_instance_ptr) *) &_axis);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("z");
}
SdaiAxis1_placement::SdaiAxis1_placement (SdaiAxis1_placement& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAxis1_placement::~SdaiAxis1_placement () {  }

#ifdef __OSTORE__

void
SdaiAxis1_placement::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAxis1_placement: virtual access function." << endl;
    SdaiAxis1_placement_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAxis1_placement_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAxis1_placement: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAxis1_placement *ent = (SdaiAxis1_placement *)sent;
//    SdaiAxis1_placement *ent = (SdaiAxis1_placement *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_axis1_placement;
    ent->attributes[2].aDesc = a_76axis;
    if(ent->_axis == 0)
        ent->_axis = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiAxis1_placement(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAxis1_placement::get_os_typespec())
                                   SdaiAxis1_placement;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAxis1_placement::get_os_typespec())
//                                   SdaiAxis1_placement;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAxis1_placement;
}
#endif

#ifdef __O3DB__
void
SdaiAxis1_placement::oodb_reInit ()
{	eDesc = config_control_designe_axis1_placement;
	attributes [2].aDesc = a_76axis;
}
#endif

SdaiAxis1_placement::SdaiAxis1_placement (SCLP23(Application_instance) *se, int *addAttrs) : SdaiPlacement(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis1_placement;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_76axis, (SCLP23(Application_instance_ptr) *) &_axis);
#else
    STEPattribute *a = new STEPattribute(*a_76axis, (SCLP23(Application_instance_ptr) *) &_axis);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("z");
}

const SdaiDirection_ptr
SdaiAxis1_placement::axis_() const
{
    return (SdaiDirection_ptr) _axis;
}

void
SdaiAxis1_placement::axis_ (const SdaiDirection_ptr x)

{
    _axis = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY axis1_placement


/////////	 ENTITY bounded_curve

EntityDescriptor *config_control_designe_bounded_curve =0;
SdaiBounded_curve::SdaiBounded_curve( )
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bounded_curve;
    MakeDerived ("dim");
}
SdaiBounded_curve::SdaiBounded_curve (SdaiBounded_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiBounded_curve::~SdaiBounded_curve () {  }

#ifdef __OSTORE__

void
SdaiBounded_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBounded_curve: virtual access function." << endl;
    SdaiBounded_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiBounded_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBounded_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiBounded_curve *ent = (SdaiBounded_curve *)sent;
//    SdaiBounded_curve *ent = (SdaiBounded_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_bounded_curve;
}

SCLP23(Application_instance_ptr)
create_SdaiBounded_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiBounded_curve::get_os_typespec())
                                   SdaiBounded_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiBounded_curve::get_os_typespec())
//                                   SdaiBounded_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiBounded_curve;
}
#endif

#ifdef __O3DB__
void
SdaiBounded_curve::oodb_reInit ()
{	eDesc = config_control_designe_bounded_curve;
}
#endif

SdaiBounded_curve::SdaiBounded_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiCurve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bounded_curve;
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY bounded_curve


/////////	 ENTITY b_spline_curve

EntityDescriptor *config_control_designe_b_spline_curve =0;
AttrDescriptor *a_78degree =0;
AttrDescriptor *a_79control_points_list =0;
AttrDescriptor *a_80curve_form =0;
AttrDescriptor *a_81closed_curve =0;
AttrDescriptor *a_82self_intersect =0;
Derived_attribute *a_83Dupper_index_on_control_points =0;
Derived_attribute *a_84Dcontrol_points =0;
SdaiB_spline_curve::SdaiB_spline_curve( )
{

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_78degree,  &_degree);
#else
    STEPattribute *a = new STEPattribute(*a_78degree,  &_degree);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_79control_points_list,  &_control_points_list);
#else
    a = new STEPattribute(*a_79control_points_list,  &_control_points_list);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_80curve_form,  &_curve_form);
#else
    a = new STEPattribute(*a_80curve_form,  &_curve_form);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_81closed_curve,  &_closed_curve);
#else
    a = new STEPattribute(*a_81closed_curve,  &_closed_curve);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_82self_intersect,  &_self_intersect);
#else
    a = new STEPattribute(*a_82self_intersect,  &_self_intersect);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
}
SdaiB_spline_curve::SdaiB_spline_curve (SdaiB_spline_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiB_spline_curve::~SdaiB_spline_curve () {  }

#ifdef __OSTORE__

void
SdaiB_spline_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiB_spline_curve: virtual access function." << endl;
    SdaiB_spline_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiB_spline_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiB_spline_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiB_spline_curve *ent = (SdaiB_spline_curve *)sent;
//    SdaiB_spline_curve *ent = (SdaiB_spline_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_b_spline_curve;
    ent->attributes[1].aDesc = a_78degree;
    ent->attributes[2].aDesc = a_79control_points_list;
    ent->attributes[3].aDesc = a_80curve_form;
    ent->attributes[4].aDesc = a_81closed_curve;
    ent->attributes[5].aDesc = a_82self_intersect;
}

SCLP23(Application_instance_ptr)
create_SdaiB_spline_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiB_spline_curve::get_os_typespec())
                                   SdaiB_spline_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiB_spline_curve::get_os_typespec())
//                                   SdaiB_spline_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiB_spline_curve;
}
#endif

#ifdef __O3DB__
void
SdaiB_spline_curve::oodb_reInit ()
{	eDesc = config_control_designe_b_spline_curve;
	attributes [1].aDesc = a_78degree;
	attributes [2].aDesc = a_79control_points_list;
	attributes [3].aDesc = a_80curve_form;
	attributes [4].aDesc = a_81closed_curve;
	attributes [5].aDesc = a_82self_intersect;
}
#endif

SdaiB_spline_curve::SdaiB_spline_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiBounded_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_78degree,  &_degree);
#else
    STEPattribute *a = new STEPattribute(*a_78degree,  &_degree);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_79control_points_list,  &_control_points_list);
#else
    a = new STEPattribute(*a_79control_points_list,  &_control_points_list);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_80curve_form,  &_curve_form);
#else
    a = new STEPattribute(*a_80curve_form,  &_curve_form);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_81closed_curve,  &_closed_curve);
#else
    a = new STEPattribute(*a_81closed_curve,  &_closed_curve);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_82self_intersect,  &_self_intersect);
#else
    a = new STEPattribute(*a_82self_intersect,  &_self_intersect);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
}

const SCLP23(Integer)
SdaiB_spline_curve::degree_() const
{
    return (const SCLP23(Integer)) _degree;
}

void
SdaiB_spline_curve::degree_ (const SCLP23(Integer) x)

{
    _degree = x;
}

const EntityAggregate_ptr
SdaiB_spline_curve::control_points_list_() const
{
    return (EntityAggregate_ptr) &_control_points_list;
}

void
SdaiB_spline_curve::control_points_list_ (const EntityAggregate_ptr x)

	{ _control_points_list.ShallowCopy (*x); }

const SdaiB_spline_curve_form_var
SdaiB_spline_curve::curve_form_() const
{
    return (B_spline_curve_form) _curve_form;
}

void
SdaiB_spline_curve::curve_form_ (const SdaiB_spline_curve_form_var x)

{
    _curve_form.put (x);
}

const SCLLOG(Logical)
SdaiB_spline_curve::closed_curve_() const
{
    return (SCLLOG(Logical)) _closed_curve;
}

void
SdaiB_spline_curve::closed_curve_ (const SCLLOG(Logical) x)

{
    _closed_curve.put (x);
}

const SCLLOG(Logical)
SdaiB_spline_curve::self_intersect_() const
{
    return (SCLLOG(Logical)) _self_intersect;
}

void
SdaiB_spline_curve::self_intersect_ (const SCLLOG(Logical) x)

{
    _self_intersect.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY b_spline_curve


/////////	 ENTITY rational_b_spline_curve

EntityDescriptor *config_control_designe_rational_b_spline_curve =0;
AttrDescriptor *a_85weights_data =0;
Derived_attribute *a_86Dweights =0;
SdaiRational_b_spline_curve::SdaiRational_b_spline_curve( )
{

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rational_b_spline_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_85weights_data,  &_weights_data);
#else
    STEPattribute *a = new STEPattribute(*a_85weights_data,  &_weights_data);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
    MakeDerived ("weights");
}
SdaiRational_b_spline_curve::SdaiRational_b_spline_curve (SdaiRational_b_spline_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiRational_b_spline_curve::~SdaiRational_b_spline_curve () {  }

#ifdef __OSTORE__

void
SdaiRational_b_spline_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRational_b_spline_curve: virtual access function." << endl;
    SdaiRational_b_spline_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiRational_b_spline_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRational_b_spline_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiRational_b_spline_curve *ent = (SdaiRational_b_spline_curve *)sent;
//    SdaiRational_b_spline_curve *ent = (SdaiRational_b_spline_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_rational_b_spline_curve;
    ent->attributes[6].aDesc = a_85weights_data;
}

SCLP23(Application_instance_ptr)
create_SdaiRational_b_spline_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiRational_b_spline_curve::get_os_typespec())
                                   SdaiRational_b_spline_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiRational_b_spline_curve::get_os_typespec())
//                                   SdaiRational_b_spline_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiRational_b_spline_curve;
}
#endif

#ifdef __O3DB__
void
SdaiRational_b_spline_curve::oodb_reInit ()
{	eDesc = config_control_designe_rational_b_spline_curve;
	attributes [6].aDesc = a_85weights_data;
}
#endif

SdaiRational_b_spline_curve::SdaiRational_b_spline_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiB_spline_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rational_b_spline_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_85weights_data,  &_weights_data);
#else
    STEPattribute *a = new STEPattribute(*a_85weights_data,  &_weights_data);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
    MakeDerived ("weights");
}

const RealAggregate_ptr
SdaiRational_b_spline_curve::weights_data_() const
{
    return (RealAggregate_ptr) &_weights_data;
}

void
SdaiRational_b_spline_curve::weights_data_ (const RealAggregate_ptr x)

	{ _weights_data.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY rational_b_spline_curve


/////////	 ENTITY action_request_assignment

EntityDescriptor *config_control_designe_action_request_assignment =0;
AttrDescriptor *a_87assigned_action_request =0;
SdaiAction_request_assignment::SdaiAction_request_assignment( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_87assigned_action_request, (SCLP23(Application_instance_ptr) *) &_assigned_action_request);
#else
    STEPattribute *a = new STEPattribute(*a_87assigned_action_request, (SCLP23(Application_instance_ptr) *) &_assigned_action_request);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_request_assignment::SdaiAction_request_assignment (SdaiAction_request_assignment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAction_request_assignment::~SdaiAction_request_assignment () {  }

#ifdef __OSTORE__

void
SdaiAction_request_assignment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_request_assignment: virtual access function." << endl;
    SdaiAction_request_assignment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAction_request_assignment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_request_assignment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAction_request_assignment *ent = (SdaiAction_request_assignment *)sent;
//    SdaiAction_request_assignment *ent = (SdaiAction_request_assignment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_action_request_assignment;
    ent->attributes[0].aDesc = a_87assigned_action_request;
    if(ent->_assigned_action_request == 0)
        ent->_assigned_action_request = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiAction_request_assignment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAction_request_assignment::get_os_typespec())
                                   SdaiAction_request_assignment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAction_request_assignment::get_os_typespec())
//                                   SdaiAction_request_assignment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAction_request_assignment;
}
#endif

#ifdef __O3DB__
void
SdaiAction_request_assignment::oodb_reInit ()
{	eDesc = config_control_designe_action_request_assignment;
	attributes [0].aDesc = a_87assigned_action_request;
}
#endif

SdaiAction_request_assignment::SdaiAction_request_assignment( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_87assigned_action_request, (SCLP23(Application_instance_ptr) *) &_assigned_action_request);
#else
    STEPattribute *a = new STEPattribute(*a_87assigned_action_request, (SCLP23(Application_instance_ptr) *) &_assigned_action_request);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiVersioned_action_request_ptr
SdaiAction_request_assignment::assigned_action_request_() const
{
    return (SdaiVersioned_action_request_ptr) _assigned_action_request;
}

void
SdaiAction_request_assignment::assigned_action_request_ (const SdaiVersioned_action_request_ptr x)

{
    _assigned_action_request = x;
}

/////////	 END_ENTITY action_request_assignment


/////////	 ENTITY topological_representation_item

EntityDescriptor *config_control_designe_topological_representation_item =0;
SdaiTopological_representation_item::SdaiTopological_representation_item( )
{

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_topological_representation_item;
    //cout << "Topological_representation_item" << endl;
    //PrintSTEPattributes ();
}
SdaiTopological_representation_item::SdaiTopological_representation_item (SdaiTopological_representation_item& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiTopological_representation_item::~SdaiTopological_representation_item () {  }

#ifdef __OSTORE__

void
SdaiTopological_representation_item::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiTopological_representation_item: virtual access function." << endl;
    SdaiTopological_representation_item_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiTopological_representation_item_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiTopological_representation_item: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiTopological_representation_item *ent = (SdaiTopological_representation_item *)sent;
//    SdaiTopological_representation_item *ent = (SdaiTopological_representation_item *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_topological_representation_item;
}

SCLP23(Application_instance_ptr)
create_SdaiTopological_representation_item(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiTopological_representation_item::get_os_typespec())
                                   SdaiTopological_representation_item;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiTopological_representation_item::get_os_typespec())
//                                   SdaiTopological_representation_item;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiTopological_representation_item;
}
#endif

#ifdef __O3DB__
void
SdaiTopological_representation_item::oodb_reInit ()
{	eDesc = config_control_designe_topological_representation_item;
}
#endif

SdaiTopological_representation_item::SdaiTopological_representation_item (SCLP23(Application_instance) *se, int *addAttrs) : SdaiRepresentation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_topological_representation_item;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY topological_representation_item


/////////	 ENTITY face_bound

EntityDescriptor *config_control_designe_face_bound =0;
AttrDescriptor *a_88bound =0;
AttrDescriptor *a_89orientation =0;
SdaiFace_bound::SdaiFace_bound( )
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face_bound;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_88bound, (SCLP23(Application_instance_ptr) *) &_bound);
#else
    STEPattribute *a = new STEPattribute(*a_88bound, (SCLP23(Application_instance_ptr) *) &_bound);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_89orientation,  &_orientation);
#else
    a = new STEPattribute(*a_89orientation,  &_orientation);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiFace_bound::SdaiFace_bound (SdaiFace_bound& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiFace_bound::~SdaiFace_bound () {  }

#ifdef __OSTORE__

void
SdaiFace_bound::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFace_bound: virtual access function." << endl;
    SdaiFace_bound_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiFace_bound_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFace_bound: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiFace_bound *ent = (SdaiFace_bound *)sent;
//    SdaiFace_bound *ent = (SdaiFace_bound *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_face_bound;
    ent->attributes[1].aDesc = a_88bound;
    if(ent->_bound == 0)
        ent->_bound = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_89orientation;
}

SCLP23(Application_instance_ptr)
create_SdaiFace_bound(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiFace_bound::get_os_typespec())
                                   SdaiFace_bound;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiFace_bound::get_os_typespec())
//                                   SdaiFace_bound;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiFace_bound;
}
#endif

#ifdef __O3DB__
void
SdaiFace_bound::oodb_reInit ()
{	eDesc = config_control_designe_face_bound;
	attributes [1].aDesc = a_88bound;
	attributes [2].aDesc = a_89orientation;
}
#endif

SdaiFace_bound::SdaiFace_bound (SCLP23(Application_instance) *se, int *addAttrs) : SdaiTopological_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face_bound;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_88bound, (SCLP23(Application_instance_ptr) *) &_bound);
#else
    STEPattribute *a = new STEPattribute(*a_88bound, (SCLP23(Application_instance_ptr) *) &_bound);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_89orientation,  &_orientation);
#else
    a = new STEPattribute(*a_89orientation,  &_orientation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLoop_ptr
SdaiFace_bound::bound_() const
{
    return (SdaiLoop_ptr) _bound;
}

void
SdaiFace_bound::bound_ (const SdaiLoop_ptr x)

{
    _bound = x;
}

const SCLBOOL(Bool)
SdaiFace_bound::orientation_() const
{
    return (SCLBOOL(Bool)) _orientation;
}

void
SdaiFace_bound::orientation_ (const SCLBOOL(Bool) x)

{
    _orientation.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY face_bound


/////////	 ENTITY length_measure_with_unit

EntityDescriptor *config_control_designe_length_measure_with_unit =0;
SdaiLength_measure_with_unit::SdaiLength_measure_with_unit( )
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_length_measure_with_unit;
}
SdaiLength_measure_with_unit::SdaiLength_measure_with_unit (SdaiLength_measure_with_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiLength_measure_with_unit::~SdaiLength_measure_with_unit () {  }

#ifdef __OSTORE__

void
SdaiLength_measure_with_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLength_measure_with_unit: virtual access function." << endl;
    SdaiLength_measure_with_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiLength_measure_with_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLength_measure_with_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiLength_measure_with_unit *ent = (SdaiLength_measure_with_unit *)sent;
//    SdaiLength_measure_with_unit *ent = (SdaiLength_measure_with_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_length_measure_with_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiLength_measure_with_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiLength_measure_with_unit::get_os_typespec())
                                   SdaiLength_measure_with_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiLength_measure_with_unit::get_os_typespec())
//                                   SdaiLength_measure_with_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiLength_measure_with_unit;
}
#endif

#ifdef __O3DB__
void
SdaiLength_measure_with_unit::oodb_reInit ()
{	eDesc = config_control_designe_length_measure_with_unit;
}
#endif

SdaiLength_measure_with_unit::SdaiLength_measure_with_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiMeasure_with_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_length_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY length_measure_with_unit


/////////	 ENTITY dated_effectivity

EntityDescriptor *config_control_designe_dated_effectivity =0;
AttrDescriptor *a_90effectivity_start_date =0;
AttrDescriptor *a_91effectivity_end_date =0;
SdaiDated_effectivity::SdaiDated_effectivity( )
{

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_dated_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_90effectivity_start_date, (SCLP23(Application_instance_ptr) *) &_effectivity_start_date);
#else
    STEPattribute *a = new STEPattribute(*a_90effectivity_start_date, (SCLP23(Application_instance_ptr) *) &_effectivity_start_date);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_91effectivity_end_date, (SCLP23(Application_instance_ptr) *) &_effectivity_end_date);
#else
    a = new STEPattribute(*a_91effectivity_end_date, (SCLP23(Application_instance_ptr) *) &_effectivity_end_date);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDated_effectivity::SdaiDated_effectivity (SdaiDated_effectivity& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDated_effectivity::~SdaiDated_effectivity () {  }

#ifdef __OSTORE__

void
SdaiDated_effectivity::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDated_effectivity: virtual access function." << endl;
    SdaiDated_effectivity_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDated_effectivity_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDated_effectivity: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDated_effectivity *ent = (SdaiDated_effectivity *)sent;
//    SdaiDated_effectivity *ent = (SdaiDated_effectivity *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_dated_effectivity;
    ent->attributes[1].aDesc = a_90effectivity_start_date;
    if(ent->_effectivity_start_date == 0)
        ent->_effectivity_start_date = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_91effectivity_end_date;
    if(ent->_effectivity_end_date == 0)
        ent->_effectivity_end_date = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiDated_effectivity(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDated_effectivity::get_os_typespec())
                                   SdaiDated_effectivity;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDated_effectivity::get_os_typespec())
//                                   SdaiDated_effectivity;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDated_effectivity;
}
#endif

#ifdef __O3DB__
void
SdaiDated_effectivity::oodb_reInit ()
{	eDesc = config_control_designe_dated_effectivity;
	attributes [1].aDesc = a_90effectivity_start_date;
	attributes [2].aDesc = a_91effectivity_end_date;
}
#endif

SdaiDated_effectivity::SdaiDated_effectivity (SCLP23(Application_instance) *se, int *addAttrs) : SdaiEffectivity(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_dated_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_90effectivity_start_date, (SCLP23(Application_instance_ptr) *) &_effectivity_start_date);
#else
    STEPattribute *a = new STEPattribute(*a_90effectivity_start_date, (SCLP23(Application_instance_ptr) *) &_effectivity_start_date);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_91effectivity_end_date, (SCLP23(Application_instance_ptr) *) &_effectivity_end_date);
#else
    a = new STEPattribute(*a_91effectivity_end_date, (SCLP23(Application_instance_ptr) *) &_effectivity_end_date);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiDate_and_time_ptr
SdaiDated_effectivity::effectivity_start_date_() const
{
    return (SdaiDate_and_time_ptr) _effectivity_start_date;
}

void
SdaiDated_effectivity::effectivity_start_date_ (const SdaiDate_and_time_ptr x)

{
    _effectivity_start_date = x;
}

const SdaiDate_and_time_ptr
SdaiDated_effectivity::effectivity_end_date_() const
{
    return (SdaiDate_and_time_ptr) _effectivity_end_date;
}

void
SdaiDated_effectivity::effectivity_end_date_ (const SdaiDate_and_time_ptr x)

{
    _effectivity_end_date = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY dated_effectivity


/////////	 ENTITY direction

EntityDescriptor *config_control_designe_direction =0;
AttrDescriptor *a_92direction_ratios =0;
SdaiDirection::SdaiDirection( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_direction;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_92direction_ratios,  &_direction_ratios);
#else
    STEPattribute *a = new STEPattribute(*a_92direction_ratios,  &_direction_ratios);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiDirection::SdaiDirection (SdaiDirection& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDirection::~SdaiDirection () {  }

#ifdef __OSTORE__

void
SdaiDirection::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDirection: virtual access function." << endl;
    SdaiDirection_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDirection_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDirection: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDirection *ent = (SdaiDirection *)sent;
//    SdaiDirection *ent = (SdaiDirection *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_direction;
    ent->attributes[1].aDesc = a_92direction_ratios;
}

SCLP23(Application_instance_ptr)
create_SdaiDirection(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDirection::get_os_typespec())
                                   SdaiDirection;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDirection::get_os_typespec())
//                                   SdaiDirection;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDirection;
}
#endif

#ifdef __O3DB__
void
SdaiDirection::oodb_reInit ()
{	eDesc = config_control_designe_direction;
	attributes [1].aDesc = a_92direction_ratios;
}
#endif

SdaiDirection::SdaiDirection (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_direction;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_92direction_ratios,  &_direction_ratios);
#else
    STEPattribute *a = new STEPattribute(*a_92direction_ratios,  &_direction_ratios);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const RealAggregate_ptr
SdaiDirection::direction_ratios_() const
{
    return (RealAggregate_ptr) &_direction_ratios;
}

void
SdaiDirection::direction_ratios_ (const RealAggregate_ptr x)

	{ _direction_ratios.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY direction


/////////	 ENTITY next_assembly_usage_occurrence

EntityDescriptor *config_control_designe_next_assembly_usage_occurrence =0;
SdaiNext_assembly_usage_occurrence::SdaiNext_assembly_usage_occurrence( )
{

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_next_assembly_usage_occurrence;
}
SdaiNext_assembly_usage_occurrence::SdaiNext_assembly_usage_occurrence (SdaiNext_assembly_usage_occurrence& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiNext_assembly_usage_occurrence::~SdaiNext_assembly_usage_occurrence () {  }

#ifdef __OSTORE__

void
SdaiNext_assembly_usage_occurrence::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiNext_assembly_usage_occurrence: virtual access function." << endl;
    SdaiNext_assembly_usage_occurrence_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiNext_assembly_usage_occurrence_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiNext_assembly_usage_occurrence: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiNext_assembly_usage_occurrence *ent = (SdaiNext_assembly_usage_occurrence *)sent;
//    SdaiNext_assembly_usage_occurrence *ent = (SdaiNext_assembly_usage_occurrence *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_next_assembly_usage_occurrence;
}

SCLP23(Application_instance_ptr)
create_SdaiNext_assembly_usage_occurrence(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiNext_assembly_usage_occurrence::get_os_typespec())
                                   SdaiNext_assembly_usage_occurrence;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiNext_assembly_usage_occurrence::get_os_typespec())
//                                   SdaiNext_assembly_usage_occurrence;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiNext_assembly_usage_occurrence;
}
#endif

#ifdef __O3DB__
void
SdaiNext_assembly_usage_occurrence::oodb_reInit ()
{	eDesc = config_control_designe_next_assembly_usage_occurrence;
}
#endif

SdaiNext_assembly_usage_occurrence::SdaiNext_assembly_usage_occurrence (SCLP23(Application_instance) *se, int *addAttrs) : SdaiAssembly_component_usage(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_next_assembly_usage_occurrence;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY next_assembly_usage_occurrence


/////////	 ENTITY edge

EntityDescriptor *config_control_designe_edge =0;
AttrDescriptor *a_93edge_start =0;
AttrDescriptor *a_94edge_end =0;
SdaiEdge::SdaiEdge( )
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_93edge_start, (SCLP23(Application_instance_ptr) *) &_edge_start);
#else
    STEPattribute *a = new STEPattribute(*a_93edge_start, (SCLP23(Application_instance_ptr) *) &_edge_start);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_94edge_end, (SCLP23(Application_instance_ptr) *) &_edge_end);
#else
    a = new STEPattribute(*a_94edge_end, (SCLP23(Application_instance_ptr) *) &_edge_end);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiEdge::SdaiEdge (SdaiEdge& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiEdge::~SdaiEdge () {  }

#ifdef __OSTORE__

void
SdaiEdge::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEdge: virtual access function." << endl;
    SdaiEdge_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiEdge_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEdge: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiEdge *ent = (SdaiEdge *)sent;
//    SdaiEdge *ent = (SdaiEdge *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_edge;
    ent->attributes[1].aDesc = a_93edge_start;
    if(ent->_edge_start == 0)
        ent->_edge_start = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_94edge_end;
    if(ent->_edge_end == 0)
        ent->_edge_end = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiEdge(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiEdge::get_os_typespec())
                                   SdaiEdge;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiEdge::get_os_typespec())
//                                   SdaiEdge;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiEdge;
}
#endif

#ifdef __O3DB__
void
SdaiEdge::oodb_reInit ()
{	eDesc = config_control_designe_edge;
	attributes [1].aDesc = a_93edge_start;
	attributes [2].aDesc = a_94edge_end;
}
#endif

SdaiEdge::SdaiEdge (SCLP23(Application_instance) *se, int *addAttrs) : SdaiTopological_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_93edge_start, (SCLP23(Application_instance_ptr) *) &_edge_start);
#else
    STEPattribute *a = new STEPattribute(*a_93edge_start, (SCLP23(Application_instance_ptr) *) &_edge_start);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_94edge_end, (SCLP23(Application_instance_ptr) *) &_edge_end);
#else
    a = new STEPattribute(*a_94edge_end, (SCLP23(Application_instance_ptr) *) &_edge_end);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiVertex_ptr
SdaiEdge::edge_start_() const
{
    return (SdaiVertex_ptr) _edge_start;
}

void
SdaiEdge::edge_start_ (const SdaiVertex_ptr x)

{
    _edge_start = x;
}

const SdaiVertex_ptr
SdaiEdge::edge_end_() const
{
    return (SdaiVertex_ptr) _edge_end;
}

void
SdaiEdge::edge_end_ (const SdaiVertex_ptr x)

{
    _edge_end = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY edge


/////////	 ENTITY oriented_edge

EntityDescriptor *config_control_designe_oriented_edge =0;
AttrDescriptor *a_95edge_element =0;
AttrDescriptor *a_96orientation =0;
Derived_attribute *a_97Dedge_edge_start =0;
Derived_attribute *a_98Dedge_edge_end =0;
SdaiOriented_edge::SdaiOriented_edge( )
{

	/*  parent: SdaiEdge  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_edge;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_95edge_element, (SCLP23(Application_instance_ptr) *) &_edge_element);
#else
    STEPattribute *a = new STEPattribute(*a_95edge_element, (SCLP23(Application_instance_ptr) *) &_edge_element);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_96orientation,  &_orientation);
#else
    a = new STEPattribute(*a_96orientation,  &_orientation);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("edge_start");
    MakeDerived ("edge_end");
}
SdaiOriented_edge::SdaiOriented_edge (SdaiOriented_edge& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOriented_edge::~SdaiOriented_edge () {  }

#ifdef __OSTORE__

void
SdaiOriented_edge::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOriented_edge: virtual access function." << endl;
    SdaiOriented_edge_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOriented_edge_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOriented_edge: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOriented_edge *ent = (SdaiOriented_edge *)sent;
//    SdaiOriented_edge *ent = (SdaiOriented_edge *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_oriented_edge;
    ent->attributes[3].aDesc = a_95edge_element;
    if(ent->_edge_element == 0)
        ent->_edge_element = S_ENTITY_NULL;
    ent->attributes[4].aDesc = a_96orientation;
}

SCLP23(Application_instance_ptr)
create_SdaiOriented_edge(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOriented_edge::get_os_typespec())
                                   SdaiOriented_edge;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOriented_edge::get_os_typespec())
//                                   SdaiOriented_edge;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOriented_edge;
}
#endif

#ifdef __O3DB__
void
SdaiOriented_edge::oodb_reInit ()
{	eDesc = config_control_designe_oriented_edge;
	attributes [3].aDesc = a_95edge_element;
	attributes [4].aDesc = a_96orientation;
}
#endif

SdaiOriented_edge::SdaiOriented_edge (SCLP23(Application_instance) *se, int *addAttrs) : SdaiEdge(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiEdge  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_edge;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_95edge_element, (SCLP23(Application_instance_ptr) *) &_edge_element);
#else
    STEPattribute *a = new STEPattribute(*a_95edge_element, (SCLP23(Application_instance_ptr) *) &_edge_element);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_96orientation,  &_orientation);
#else
    a = new STEPattribute(*a_96orientation,  &_orientation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("edge_start");
    MakeDerived ("edge_end");
}

const SdaiEdge_ptr
SdaiOriented_edge::edge_element_() const
{
    return (SdaiEdge_ptr) _edge_element;
}

void
SdaiOriented_edge::edge_element_ (const SdaiEdge_ptr x)

{
    _edge_element = x;
}

const SCLBOOL(Bool)
SdaiOriented_edge::orientation_() const
{
    return (SCLBOOL(Bool)) _orientation;
}

void
SdaiOriented_edge::orientation_ (const SCLBOOL(Bool) x)

{
    _orientation.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY oriented_edge


/////////	 ENTITY person

EntityDescriptor *config_control_designe_person =0;
AttrDescriptor *a_99id =0;
AttrDescriptor *a_100last_name =0;
AttrDescriptor *a_101first_name =0;
AttrDescriptor *a_102middle_names =0;
AttrDescriptor *a_103prefix_titles =0;
AttrDescriptor *a_104suffix_titles =0;
SdaiPerson::SdaiPerson( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_person;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_99id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_99id,  &_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_100last_name,  &_last_name);
#else
    a = new STEPattribute(*a_100last_name,  &_last_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_101first_name,  &_first_name);
#else
    a = new STEPattribute(*a_101first_name,  &_first_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_102middle_names,  &_middle_names);
#else
    a = new STEPattribute(*a_102middle_names,  &_middle_names);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_103prefix_titles,  &_prefix_titles);
#else
    a = new STEPattribute(*a_103prefix_titles,  &_prefix_titles);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_104suffix_titles,  &_suffix_titles);
#else
    a = new STEPattribute(*a_104suffix_titles,  &_suffix_titles);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiPerson::SdaiPerson (SdaiPerson& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPerson::~SdaiPerson () {  }

#ifdef __OSTORE__

void
SdaiPerson::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPerson: virtual access function." << endl;
    SdaiPerson_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPerson_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPerson: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPerson *ent = (SdaiPerson *)sent;
//    SdaiPerson *ent = (SdaiPerson *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_person;
    ent->attributes[0].aDesc = a_99id;
    ent->attributes[1].aDesc = a_100last_name;
    ent->attributes[2].aDesc = a_101first_name;
    ent->attributes[3].aDesc = a_102middle_names;
    ent->attributes[4].aDesc = a_103prefix_titles;
    ent->attributes[5].aDesc = a_104suffix_titles;
}

SCLP23(Application_instance_ptr)
create_SdaiPerson(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPerson::get_os_typespec())
                                   SdaiPerson;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPerson::get_os_typespec())
//                                   SdaiPerson;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPerson;
}
#endif

#ifdef __O3DB__
void
SdaiPerson::oodb_reInit ()
{	eDesc = config_control_designe_person;
	attributes [0].aDesc = a_99id;
	attributes [1].aDesc = a_100last_name;
	attributes [2].aDesc = a_101first_name;
	attributes [3].aDesc = a_102middle_names;
	attributes [4].aDesc = a_103prefix_titles;
	attributes [5].aDesc = a_104suffix_titles;
}
#endif

SdaiPerson::SdaiPerson( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_person;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_99id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_99id,  &_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_100last_name,  &_last_name);
#else
    a = new STEPattribute(*a_100last_name,  &_last_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_101first_name,  &_first_name);
#else
    a = new STEPattribute(*a_101first_name,  &_first_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_102middle_names,  &_middle_names);
#else
    a = new STEPattribute(*a_102middle_names,  &_middle_names);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_103prefix_titles,  &_prefix_titles);
#else
    a = new STEPattribute(*a_103prefix_titles,  &_prefix_titles);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_104suffix_titles,  &_suffix_titles);
#else
    a = new STEPattribute(*a_104suffix_titles,  &_suffix_titles);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiPerson::id_() const
{
    return (const SdaiIdentifier) _id;
}

void
SdaiPerson::id_ (const SdaiIdentifier x)

{
    _id = x;
}

const SdaiLabel
SdaiPerson::last_name_() const
{
    return (const SdaiLabel) _last_name;
}

void
SdaiPerson::last_name_ (const SdaiLabel x)

{
    _last_name = x;
}

const SdaiLabel
SdaiPerson::first_name_() const
{
    return (const SdaiLabel) _first_name;
}

void
SdaiPerson::first_name_ (const SdaiLabel x)

{
    _first_name = x;
}

const StringAggregate_ptr
SdaiPerson::middle_names_() const
{
    return (StringAggregate_ptr) &_middle_names;
}

void
SdaiPerson::middle_names_ (const StringAggregate_ptr x)

	{ _middle_names.ShallowCopy (*x); }

const StringAggregate_ptr
SdaiPerson::prefix_titles_() const
{
    return (StringAggregate_ptr) &_prefix_titles;
}

void
SdaiPerson::prefix_titles_ (const StringAggregate_ptr x)

	{ _prefix_titles.ShallowCopy (*x); }

const StringAggregate_ptr
SdaiPerson::suffix_titles_() const
{
    return (StringAggregate_ptr) &_suffix_titles;
}

void
SdaiPerson::suffix_titles_ (const StringAggregate_ptr x)

	{ _suffix_titles.ShallowCopy (*x); }

/////////	 END_ENTITY person


/////////	 ENTITY document

EntityDescriptor *config_control_designe_document =0;
AttrDescriptor *a_105id =0;
AttrDescriptor *a_106name =0;
AttrDescriptor *a_107description =0;
AttrDescriptor *a_108kind =0;
SdaiDocument::SdaiDocument( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_document;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_105id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_105id,  &_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_106name,  &_name);
#else
    a = new STEPattribute(*a_106name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_107description,  &_description);
#else
    a = new STEPattribute(*a_107description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_108kind, (SCLP23(Application_instance_ptr) *) &_kind);
#else
    a = new STEPattribute(*a_108kind, (SCLP23(Application_instance_ptr) *) &_kind);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument::SdaiDocument (SdaiDocument& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDocument::~SdaiDocument () {  }

#ifdef __OSTORE__

void
SdaiDocument::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument: virtual access function." << endl;
    SdaiDocument_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDocument_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDocument *ent = (SdaiDocument *)sent;
//    SdaiDocument *ent = (SdaiDocument *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_document;
    ent->attributes[0].aDesc = a_105id;
    ent->attributes[1].aDesc = a_106name;
    ent->attributes[2].aDesc = a_107description;
    ent->attributes[3].aDesc = a_108kind;
    if(ent->_kind == 0)
        ent->_kind = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiDocument(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDocument::get_os_typespec())
                                   SdaiDocument;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDocument::get_os_typespec())
//                                   SdaiDocument;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDocument;
}
#endif

#ifdef __O3DB__
void
SdaiDocument::oodb_reInit ()
{	eDesc = config_control_designe_document;
	attributes [0].aDesc = a_105id;
	attributes [1].aDesc = a_106name;
	attributes [2].aDesc = a_107description;
	attributes [3].aDesc = a_108kind;
}
#endif

SdaiDocument::SdaiDocument( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_document;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_105id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_105id,  &_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_106name,  &_name);
#else
    a = new STEPattribute(*a_106name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_107description,  &_description);
#else
    a = new STEPattribute(*a_107description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_108kind, (SCLP23(Application_instance_ptr) *) &_kind);
#else
    a = new STEPattribute(*a_108kind, (SCLP23(Application_instance_ptr) *) &_kind);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiDocument::id_() const
{
    return (const SdaiIdentifier) _id;
}

void
SdaiDocument::id_ (const SdaiIdentifier x)

{
    _id = x;
}

const SdaiLabel
SdaiDocument::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiDocument::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiDocument::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiDocument::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiDocument_type_ptr
SdaiDocument::kind_() const
{
    return (SdaiDocument_type_ptr) _kind;
}

void
SdaiDocument::kind_ (const SdaiDocument_type_ptr x)

{
    _kind = x;
}

/////////	 END_ENTITY document


/////////	 ENTITY document_with_class

EntityDescriptor *config_control_designe_document_with_class =0;
AttrDescriptor *a_109class =0;
SdaiDocument_with_class::SdaiDocument_with_class( )
{

	/*  parent: SdaiDocument  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_document_with_class;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_109class,  &_class);
#else
    STEPattribute *a = new STEPattribute(*a_109class,  &_class);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument_with_class::SdaiDocument_with_class (SdaiDocument_with_class& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDocument_with_class::~SdaiDocument_with_class () {  }

#ifdef __OSTORE__

void
SdaiDocument_with_class::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument_with_class: virtual access function." << endl;
    SdaiDocument_with_class_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDocument_with_class_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument_with_class: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDocument_with_class *ent = (SdaiDocument_with_class *)sent;
//    SdaiDocument_with_class *ent = (SdaiDocument_with_class *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_document_with_class;
    ent->attributes[4].aDesc = a_109class;
}

SCLP23(Application_instance_ptr)
create_SdaiDocument_with_class(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDocument_with_class::get_os_typespec())
                                   SdaiDocument_with_class;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDocument_with_class::get_os_typespec())
//                                   SdaiDocument_with_class;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDocument_with_class;
}
#endif

#ifdef __O3DB__
void
SdaiDocument_with_class::oodb_reInit ()
{	eDesc = config_control_designe_document_with_class;
	attributes [4].aDesc = a_109class;
}
#endif

SdaiDocument_with_class::SdaiDocument_with_class (SCLP23(Application_instance) *se, int *addAttrs) : SdaiDocument(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiDocument  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_document_with_class;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_109class,  &_class);
#else
    STEPattribute *a = new STEPattribute(*a_109class,  &_class);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiDocument_with_class::class_() const
{
    return (const SdaiIdentifier) _class;
}

void
SdaiDocument_with_class::class_ (const SdaiIdentifier x)

{
    _class = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY document_with_class


/////////	 ENTITY conversion_based_unit

EntityDescriptor *config_control_designe_conversion_based_unit =0;
AttrDescriptor *a_110name =0;
AttrDescriptor *a_111conversion_factor =0;
SdaiConversion_based_unit::SdaiConversion_based_unit( )
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conversion_based_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_110name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_110name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_111conversion_factor, (SCLP23(Application_instance_ptr) *) &_conversion_factor);
#else
    a = new STEPattribute(*a_111conversion_factor, (SCLP23(Application_instance_ptr) *) &_conversion_factor);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiConversion_based_unit::SdaiConversion_based_unit (SdaiConversion_based_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiConversion_based_unit::~SdaiConversion_based_unit () {  }

#ifdef __OSTORE__

void
SdaiConversion_based_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConversion_based_unit: virtual access function." << endl;
    SdaiConversion_based_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiConversion_based_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConversion_based_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiConversion_based_unit *ent = (SdaiConversion_based_unit *)sent;
//    SdaiConversion_based_unit *ent = (SdaiConversion_based_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_conversion_based_unit;
    ent->attributes[1].aDesc = a_110name;
    ent->attributes[2].aDesc = a_111conversion_factor;
    if(ent->_conversion_factor == 0)
        ent->_conversion_factor = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiConversion_based_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiConversion_based_unit::get_os_typespec())
                                   SdaiConversion_based_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiConversion_based_unit::get_os_typespec())
//                                   SdaiConversion_based_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiConversion_based_unit;
}
#endif

#ifdef __O3DB__
void
SdaiConversion_based_unit::oodb_reInit ()
{	eDesc = config_control_designe_conversion_based_unit;
	attributes [1].aDesc = a_110name;
	attributes [2].aDesc = a_111conversion_factor;
}
#endif

SdaiConversion_based_unit::SdaiConversion_based_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiNamed_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conversion_based_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_110name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_110name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_111conversion_factor, (SCLP23(Application_instance_ptr) *) &_conversion_factor);
#else
    a = new STEPattribute(*a_111conversion_factor, (SCLP23(Application_instance_ptr) *) &_conversion_factor);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiConversion_based_unit::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiConversion_based_unit::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiMeasure_with_unit_ptr
SdaiConversion_based_unit::conversion_factor_() const
{
    return (SdaiMeasure_with_unit_ptr) _conversion_factor;
}

void
SdaiConversion_based_unit::conversion_factor_ (const SdaiMeasure_with_unit_ptr x)

{
    _conversion_factor = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY conversion_based_unit


/////////	 ENTITY point

EntityDescriptor *config_control_designe_point =0;
SdaiPoint::SdaiPoint( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point;
    MakeDerived ("dim");
}
SdaiPoint::SdaiPoint (SdaiPoint& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPoint::~SdaiPoint () {  }

#ifdef __OSTORE__

void
SdaiPoint::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPoint: virtual access function." << endl;
    SdaiPoint_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPoint_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPoint: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPoint *ent = (SdaiPoint *)sent;
//    SdaiPoint *ent = (SdaiPoint *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_point;
}

SCLP23(Application_instance_ptr)
create_SdaiPoint(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPoint::get_os_typespec())
                                   SdaiPoint;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPoint::get_os_typespec())
//                                   SdaiPoint;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPoint;
}
#endif

#ifdef __O3DB__
void
SdaiPoint::oodb_reInit ()
{	eDesc = config_control_designe_point;
}
#endif

SdaiPoint::SdaiPoint (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point;
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY point


/////////	 ENTITY point_on_surface

EntityDescriptor *config_control_designe_point_on_surface =0;
AttrDescriptor *a_112basis_surface =0;
AttrDescriptor *a_113point_parameter_u =0;
AttrDescriptor *a_114point_parameter_v =0;
SdaiPoint_on_surface::SdaiPoint_on_surface( )
{

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_on_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_112basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_112basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_113point_parameter_u,  &_point_parameter_u);
#else
    a = new STEPattribute(*a_113point_parameter_u,  &_point_parameter_u);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_114point_parameter_v,  &_point_parameter_v);
#else
    a = new STEPattribute(*a_114point_parameter_v,  &_point_parameter_v);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiPoint_on_surface::SdaiPoint_on_surface (SdaiPoint_on_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPoint_on_surface::~SdaiPoint_on_surface () {  }

#ifdef __OSTORE__

void
SdaiPoint_on_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPoint_on_surface: virtual access function." << endl;
    SdaiPoint_on_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPoint_on_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPoint_on_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPoint_on_surface *ent = (SdaiPoint_on_surface *)sent;
//    SdaiPoint_on_surface *ent = (SdaiPoint_on_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_point_on_surface;
    ent->attributes[1].aDesc = a_112basis_surface;
    if(ent->_basis_surface == 0)
        ent->_basis_surface = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_113point_parameter_u;
    ent->attributes[3].aDesc = a_114point_parameter_v;
}

SCLP23(Application_instance_ptr)
create_SdaiPoint_on_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPoint_on_surface::get_os_typespec())
                                   SdaiPoint_on_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPoint_on_surface::get_os_typespec())
//                                   SdaiPoint_on_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPoint_on_surface;
}
#endif

#ifdef __O3DB__
void
SdaiPoint_on_surface::oodb_reInit ()
{	eDesc = config_control_designe_point_on_surface;
	attributes [1].aDesc = a_112basis_surface;
	attributes [2].aDesc = a_113point_parameter_u;
	attributes [3].aDesc = a_114point_parameter_v;
}
#endif

SdaiPoint_on_surface::SdaiPoint_on_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiPoint(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_on_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_112basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_112basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_113point_parameter_u,  &_point_parameter_u);
#else
    a = new STEPattribute(*a_113point_parameter_u,  &_point_parameter_u);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_114point_parameter_v,  &_point_parameter_v);
#else
    a = new STEPattribute(*a_114point_parameter_v,  &_point_parameter_v);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiSurface_ptr
SdaiPoint_on_surface::basis_surface_() const
{
    return (SdaiSurface_ptr) _basis_surface;
}

void
SdaiPoint_on_surface::basis_surface_ (const SdaiSurface_ptr x)

{
    _basis_surface = x;
}

const SdaiParameter_value
SdaiPoint_on_surface::point_parameter_u_() const
{
    return (const SdaiParameter_value) _point_parameter_u;
}

void
SdaiPoint_on_surface::point_parameter_u_ (const SdaiParameter_value x)

{
    _point_parameter_u = x;
}

const SdaiParameter_value
SdaiPoint_on_surface::point_parameter_v_() const
{
    return (const SdaiParameter_value) _point_parameter_v;
}

void
SdaiPoint_on_surface::point_parameter_v_ (const SdaiParameter_value x)

{
    _point_parameter_v = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY point_on_surface


/////////	 ENTITY product_definition_formation

EntityDescriptor *config_control_designe_product_definition_formation =0;
AttrDescriptor *a_115id =0;
AttrDescriptor *a_116description =0;
AttrDescriptor *a_117of_product =0;
SdaiProduct_definition_formation::SdaiProduct_definition_formation( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition_formation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_115id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_115id,  &_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_116description,  &_description);
#else
    a = new STEPattribute(*a_116description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_117of_product, (SCLP23(Application_instance_ptr) *) &_of_product);
#else
    a = new STEPattribute(*a_117of_product, (SCLP23(Application_instance_ptr) *) &_of_product);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_formation::SdaiProduct_definition_formation (SdaiProduct_definition_formation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_definition_formation::~SdaiProduct_definition_formation () {  }

#ifdef __OSTORE__

void
SdaiProduct_definition_formation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_formation: virtual access function." << endl;
    SdaiProduct_definition_formation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_definition_formation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_formation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_definition_formation *ent = (SdaiProduct_definition_formation *)sent;
//    SdaiProduct_definition_formation *ent = (SdaiProduct_definition_formation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_definition_formation;
    ent->attributes[0].aDesc = a_115id;
    ent->attributes[1].aDesc = a_116description;
    ent->attributes[2].aDesc = a_117of_product;
    if(ent->_of_product == 0)
        ent->_of_product = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_definition_formation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_definition_formation::get_os_typespec())
                                   SdaiProduct_definition_formation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_definition_formation::get_os_typespec())
//                                   SdaiProduct_definition_formation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_definition_formation;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_definition_formation::oodb_reInit ()
{	eDesc = config_control_designe_product_definition_formation;
	attributes [0].aDesc = a_115id;
	attributes [1].aDesc = a_116description;
	attributes [2].aDesc = a_117of_product;
}
#endif

SdaiProduct_definition_formation::SdaiProduct_definition_formation( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition_formation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_115id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_115id,  &_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_116description,  &_description);
#else
    a = new STEPattribute(*a_116description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_117of_product, (SCLP23(Application_instance_ptr) *) &_of_product);
#else
    a = new STEPattribute(*a_117of_product, (SCLP23(Application_instance_ptr) *) &_of_product);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiProduct_definition_formation::id_() const
{
    return (const SdaiIdentifier) _id;
}

void
SdaiProduct_definition_formation::id_ (const SdaiIdentifier x)

{
    _id = x;
}

const SdaiText
SdaiProduct_definition_formation::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiProduct_definition_formation::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiProduct_ptr
SdaiProduct_definition_formation::of_product_() const
{
    return (SdaiProduct_ptr) _of_product;
}

void
SdaiProduct_definition_formation::of_product_ (const SdaiProduct_ptr x)

{
    _of_product = x;
}

/////////	 END_ENTITY product_definition_formation


/////////	 ENTITY person_and_organization_assignment

EntityDescriptor *config_control_designe_person_and_organization_assignment =0;
AttrDescriptor *a_118assigned_person_and_organization =0;
AttrDescriptor *a_119role =0;
SdaiPerson_and_organization_assignment::SdaiPerson_and_organization_assignment( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_118assigned_person_and_organization, (SCLP23(Application_instance_ptr) *) &_assigned_person_and_organization);
#else
    STEPattribute *a = new STEPattribute(*a_118assigned_person_and_organization, (SCLP23(Application_instance_ptr) *) &_assigned_person_and_organization);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_119role, (SCLP23(Application_instance_ptr) *) &_role);
#else
    a = new STEPattribute(*a_119role, (SCLP23(Application_instance_ptr) *) &_role);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiPerson_and_organization_assignment::SdaiPerson_and_organization_assignment (SdaiPerson_and_organization_assignment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPerson_and_organization_assignment::~SdaiPerson_and_organization_assignment () {  }

#ifdef __OSTORE__

void
SdaiPerson_and_organization_assignment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPerson_and_organization_assignment: virtual access function." << endl;
    SdaiPerson_and_organization_assignment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPerson_and_organization_assignment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPerson_and_organization_assignment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPerson_and_organization_assignment *ent = (SdaiPerson_and_organization_assignment *)sent;
//    SdaiPerson_and_organization_assignment *ent = (SdaiPerson_and_organization_assignment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_person_and_organization_assignment;
    ent->attributes[0].aDesc = a_118assigned_person_and_organization;
    if(ent->_assigned_person_and_organization == 0)
        ent->_assigned_person_and_organization = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_119role;
    if(ent->_role == 0)
        ent->_role = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiPerson_and_organization_assignment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPerson_and_organization_assignment::get_os_typespec())
                                   SdaiPerson_and_organization_assignment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPerson_and_organization_assignment::get_os_typespec())
//                                   SdaiPerson_and_organization_assignment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPerson_and_organization_assignment;
}
#endif

#ifdef __O3DB__
void
SdaiPerson_and_organization_assignment::oodb_reInit ()
{	eDesc = config_control_designe_person_and_organization_assignment;
	attributes [0].aDesc = a_118assigned_person_and_organization;
	attributes [1].aDesc = a_119role;
}
#endif

SdaiPerson_and_organization_assignment::SdaiPerson_and_organization_assignment( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_118assigned_person_and_organization, (SCLP23(Application_instance_ptr) *) &_assigned_person_and_organization);
#else
    STEPattribute *a = new STEPattribute(*a_118assigned_person_and_organization, (SCLP23(Application_instance_ptr) *) &_assigned_person_and_organization);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_119role, (SCLP23(Application_instance_ptr) *) &_role);
#else
    a = new STEPattribute(*a_119role, (SCLP23(Application_instance_ptr) *) &_role);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiPerson_and_organization_ptr
SdaiPerson_and_organization_assignment::assigned_person_and_organization_() const
{
    return (SdaiPerson_and_organization_ptr) _assigned_person_and_organization;
}

void
SdaiPerson_and_organization_assignment::assigned_person_and_organization_ (const SdaiPerson_and_organization_ptr x)

{
    _assigned_person_and_organization = x;
}

const SdaiPerson_and_organization_role_ptr
SdaiPerson_and_organization_assignment::role_() const
{
    return (SdaiPerson_and_organization_role_ptr) _role;
}

void
SdaiPerson_and_organization_assignment::role_ (const SdaiPerson_and_organization_role_ptr x)

{
    _role = x;
}

/////////	 END_ENTITY person_and_organization_assignment


/////////	 ENTITY cc_design_person_and_organization_assignment

EntityDescriptor *config_control_designe_cc_design_person_and_organization_assignment =0;
AttrDescriptor *a_120items =0;
SdaiCc_design_person_and_organization_assignment::SdaiCc_design_person_and_organization_assignment( )
{

	/*  parent: SdaiPerson_and_organization_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_person_and_organization_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_120items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_120items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_person_and_organization_assignment::SdaiCc_design_person_and_organization_assignment (SdaiCc_design_person_and_organization_assignment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCc_design_person_and_organization_assignment::~SdaiCc_design_person_and_organization_assignment () {  }

#ifdef __OSTORE__

void
SdaiCc_design_person_and_organization_assignment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_person_and_organization_assignment: virtual access function." << endl;
    SdaiCc_design_person_and_organization_assignment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCc_design_person_and_organization_assignment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_person_and_organization_assignment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCc_design_person_and_organization_assignment *ent = (SdaiCc_design_person_and_organization_assignment *)sent;
//    SdaiCc_design_person_and_organization_assignment *ent = (SdaiCc_design_person_and_organization_assignment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_cc_design_person_and_organization_assignment;
    ent->attributes[2].aDesc = a_120items;
}

SCLP23(Application_instance_ptr)
create_SdaiCc_design_person_and_organization_assignment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCc_design_person_and_organization_assignment::get_os_typespec())
                                   SdaiCc_design_person_and_organization_assignment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCc_design_person_and_organization_assignment::get_os_typespec())
//                                   SdaiCc_design_person_and_organization_assignment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCc_design_person_and_organization_assignment;
}
#endif

#ifdef __O3DB__
void
SdaiCc_design_person_and_organization_assignment::oodb_reInit ()
{	eDesc = config_control_designe_cc_design_person_and_organization_assignment;
	attributes [2].aDesc = a_120items;
}
#endif

SdaiCc_design_person_and_organization_assignment::SdaiCc_design_person_and_organization_assignment (SCLP23(Application_instance) *se, int *addAttrs) : SdaiPerson_and_organization_assignment(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiPerson_and_organization_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_person_and_organization_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_120items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_120items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiPerson_organization_items_ptr
SdaiCc_design_person_and_organization_assignment::items_() const
{
    return (SdaiPerson_organization_items_ptr) &_items;
}

void
SdaiCc_design_person_and_organization_assignment::items_ (const SdaiPerson_organization_items_ptr x)

	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_person_and_organization_assignment


/////////	 ENTITY offset_curve_3d

EntityDescriptor *config_control_designe_offset_curve_3d =0;
AttrDescriptor *a_121basis_curve =0;
AttrDescriptor *a_122distance =0;
AttrDescriptor *a_123self_intersect =0;
AttrDescriptor *a_124ref_direction =0;
SdaiOffset_curve_3d::SdaiOffset_curve_3d( )
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_offset_curve_3d;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_121basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#else
    STEPattribute *a = new STEPattribute(*a_121basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_122distance,  &_distance);
#else
    a = new STEPattribute(*a_122distance,  &_distance);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_123self_intersect,  &_self_intersect);
#else
    a = new STEPattribute(*a_123self_intersect,  &_self_intersect);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_124ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#else
    a = new STEPattribute(*a_124ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiOffset_curve_3d::SdaiOffset_curve_3d (SdaiOffset_curve_3d& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOffset_curve_3d::~SdaiOffset_curve_3d () {  }

#ifdef __OSTORE__

void
SdaiOffset_curve_3d::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOffset_curve_3d: virtual access function." << endl;
    SdaiOffset_curve_3d_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOffset_curve_3d_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOffset_curve_3d: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOffset_curve_3d *ent = (SdaiOffset_curve_3d *)sent;
//    SdaiOffset_curve_3d *ent = (SdaiOffset_curve_3d *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_offset_curve_3d;
    ent->attributes[1].aDesc = a_121basis_curve;
    if(ent->_basis_curve == 0)
        ent->_basis_curve = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_122distance;
    ent->attributes[3].aDesc = a_123self_intersect;
    ent->attributes[4].aDesc = a_124ref_direction;
    if(ent->_ref_direction == 0)
        ent->_ref_direction = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiOffset_curve_3d(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOffset_curve_3d::get_os_typespec())
                                   SdaiOffset_curve_3d;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOffset_curve_3d::get_os_typespec())
//                                   SdaiOffset_curve_3d;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOffset_curve_3d;
}
#endif

#ifdef __O3DB__
void
SdaiOffset_curve_3d::oodb_reInit ()
{	eDesc = config_control_designe_offset_curve_3d;
	attributes [1].aDesc = a_121basis_curve;
	attributes [2].aDesc = a_122distance;
	attributes [3].aDesc = a_123self_intersect;
	attributes [4].aDesc = a_124ref_direction;
}
#endif

SdaiOffset_curve_3d::SdaiOffset_curve_3d (SCLP23(Application_instance) *se, int *addAttrs) : SdaiCurve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_offset_curve_3d;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_121basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#else
    STEPattribute *a = new STEPattribute(*a_121basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_122distance,  &_distance);
#else
    a = new STEPattribute(*a_122distance,  &_distance);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_123self_intersect,  &_self_intersect);
#else
    a = new STEPattribute(*a_123self_intersect,  &_self_intersect);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_124ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#else
    a = new STEPattribute(*a_124ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiCurve_ptr
SdaiOffset_curve_3d::basis_curve_() const
{
    return (SdaiCurve_ptr) _basis_curve;
}

void
SdaiOffset_curve_3d::basis_curve_ (const SdaiCurve_ptr x)

{
    _basis_curve = x;
}

const SdaiLength_measure
SdaiOffset_curve_3d::distance_() const
{
    return (const SdaiLength_measure) _distance;
}

void
SdaiOffset_curve_3d::distance_ (const SdaiLength_measure x)

{
    _distance = x;
}

const SCLLOG(Logical)
SdaiOffset_curve_3d::self_intersect_() const
{
    return (SCLLOG(Logical)) _self_intersect;
}

void
SdaiOffset_curve_3d::self_intersect_ (const SCLLOG(Logical) x)

{
    _self_intersect.put (x);
}

const SdaiDirection_ptr
SdaiOffset_curve_3d::ref_direction_() const
{
    return (SdaiDirection_ptr) _ref_direction;
}

void
SdaiOffset_curve_3d::ref_direction_ (const SdaiDirection_ptr x)

{
    _ref_direction = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY offset_curve_3d


/////////	 ENTITY approval

EntityDescriptor *config_control_designe_approval =0;
AttrDescriptor *a_125status =0;
AttrDescriptor *a_126level =0;
SdaiApproval::SdaiApproval( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_125status, (SCLP23(Application_instance_ptr) *) &_status);
#else
    STEPattribute *a = new STEPattribute(*a_125status, (SCLP23(Application_instance_ptr) *) &_status);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_126level,  &_level);
#else
    a = new STEPattribute(*a_126level,  &_level);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval::SdaiApproval (SdaiApproval& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiApproval::~SdaiApproval () {  }

#ifdef __OSTORE__

void
SdaiApproval::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval: virtual access function." << endl;
    SdaiApproval_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiApproval_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiApproval *ent = (SdaiApproval *)sent;
//    SdaiApproval *ent = (SdaiApproval *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_approval;
    ent->attributes[0].aDesc = a_125status;
    if(ent->_status == 0)
        ent->_status = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_126level;
}

SCLP23(Application_instance_ptr)
create_SdaiApproval(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiApproval::get_os_typespec())
                                   SdaiApproval;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiApproval::get_os_typespec())
//                                   SdaiApproval;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiApproval;
}
#endif

#ifdef __O3DB__
void
SdaiApproval::oodb_reInit ()
{	eDesc = config_control_designe_approval;
	attributes [0].aDesc = a_125status;
	attributes [1].aDesc = a_126level;
}
#endif

SdaiApproval::SdaiApproval( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_approval;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_125status, (SCLP23(Application_instance_ptr) *) &_status);
#else
    STEPattribute *a = new STEPattribute(*a_125status, (SCLP23(Application_instance_ptr) *) &_status);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_126level,  &_level);
#else
    a = new STEPattribute(*a_126level,  &_level);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiApproval_status_ptr
SdaiApproval::status_() const
{
    return (SdaiApproval_status_ptr) _status;
}

void
SdaiApproval::status_ (const SdaiApproval_status_ptr x)

{
    _status = x;
}

const SdaiLabel
SdaiApproval::level_() const
{
    return (const SdaiLabel) _level;
}

void
SdaiApproval::level_ (const SdaiLabel x)

{
    _level = x;
}

/////////	 END_ENTITY approval


/////////	 ENTITY composite_curve

EntityDescriptor *config_control_designe_composite_curve =0;
AttrDescriptor *a_127segments =0;
AttrDescriptor *a_128self_intersect =0;
Derived_attribute *a_129Dn_segments =0;
Derived_attribute *a_130Dclosed_curve =0;
SdaiComposite_curve::SdaiComposite_curve( )
{

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_composite_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_127segments,  &_segments);
#else
    STEPattribute *a = new STEPattribute(*a_127segments,  &_segments);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_128self_intersect,  &_self_intersect);
#else
    a = new STEPattribute(*a_128self_intersect,  &_self_intersect);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("n_segments");
    MakeDerived ("closed_curve");
}
SdaiComposite_curve::SdaiComposite_curve (SdaiComposite_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiComposite_curve::~SdaiComposite_curve () {  }

#ifdef __OSTORE__

void
SdaiComposite_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiComposite_curve: virtual access function." << endl;
    SdaiComposite_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiComposite_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiComposite_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiComposite_curve *ent = (SdaiComposite_curve *)sent;
//    SdaiComposite_curve *ent = (SdaiComposite_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_composite_curve;
    ent->attributes[1].aDesc = a_127segments;
    ent->attributes[2].aDesc = a_128self_intersect;
}

SCLP23(Application_instance_ptr)
create_SdaiComposite_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiComposite_curve::get_os_typespec())
                                   SdaiComposite_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiComposite_curve::get_os_typespec())
//                                   SdaiComposite_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiComposite_curve;
}
#endif

#ifdef __O3DB__
void
SdaiComposite_curve::oodb_reInit ()
{	eDesc = config_control_designe_composite_curve;
	attributes [1].aDesc = a_127segments;
	attributes [2].aDesc = a_128self_intersect;
}
#endif

SdaiComposite_curve::SdaiComposite_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiBounded_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_composite_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_127segments,  &_segments);
#else
    STEPattribute *a = new STEPattribute(*a_127segments,  &_segments);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_128self_intersect,  &_self_intersect);
#else
    a = new STEPattribute(*a_128self_intersect,  &_self_intersect);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("n_segments");
    MakeDerived ("closed_curve");
}

const EntityAggregate_ptr
SdaiComposite_curve::segments_() const
{
    return (EntityAggregate_ptr) &_segments;
}

void
SdaiComposite_curve::segments_ (const EntityAggregate_ptr x)

	{ _segments.ShallowCopy (*x); }

const SCLLOG(Logical)
SdaiComposite_curve::self_intersect_() const
{
    return (SCLLOG(Logical)) _self_intersect;
}

void
SdaiComposite_curve::self_intersect_ (const SCLLOG(Logical) x)

{
    _self_intersect.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY composite_curve


/////////	 ENTITY composite_curve_on_surface

EntityDescriptor *config_control_designe_composite_curve_on_surface =0;
Derived_attribute *a_131Dbasis_surface =0;
SdaiComposite_curve_on_surface::SdaiComposite_curve_on_surface( )
{

	/*  parent: SdaiComposite_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_composite_curve_on_surface;
    MakeDerived ("dim");
    MakeDerived ("n_segments");
    MakeDerived ("closed_curve");
    MakeDerived ("basis_surface");
}
SdaiComposite_curve_on_surface::SdaiComposite_curve_on_surface (SdaiComposite_curve_on_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiComposite_curve_on_surface::~SdaiComposite_curve_on_surface () {  }

#ifdef __OSTORE__

void
SdaiComposite_curve_on_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiComposite_curve_on_surface: virtual access function." << endl;
    SdaiComposite_curve_on_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiComposite_curve_on_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiComposite_curve_on_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiComposite_curve_on_surface *ent = (SdaiComposite_curve_on_surface *)sent;
//    SdaiComposite_curve_on_surface *ent = (SdaiComposite_curve_on_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_composite_curve_on_surface;
}

SCLP23(Application_instance_ptr)
create_SdaiComposite_curve_on_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiComposite_curve_on_surface::get_os_typespec())
                                   SdaiComposite_curve_on_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiComposite_curve_on_surface::get_os_typespec())
//                                   SdaiComposite_curve_on_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiComposite_curve_on_surface;
}
#endif

#ifdef __O3DB__
void
SdaiComposite_curve_on_surface::oodb_reInit ()
{	eDesc = config_control_designe_composite_curve_on_surface;
}
#endif

SdaiComposite_curve_on_surface::SdaiComposite_curve_on_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiComposite_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiComposite_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_composite_curve_on_surface;
    MakeDerived ("dim");
    MakeDerived ("n_segments");
    MakeDerived ("closed_curve");
    MakeDerived ("basis_surface");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY composite_curve_on_surface


/////////	 ENTITY boundary_curve

EntityDescriptor *config_control_designe_boundary_curve =0;
SdaiBoundary_curve::SdaiBoundary_curve( )
{

	/*  parent: SdaiComposite_curve_on_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_boundary_curve;
    MakeDerived ("dim");
    MakeDerived ("n_segments");
    MakeDerived ("closed_curve");
    MakeDerived ("basis_surface");
}
SdaiBoundary_curve::SdaiBoundary_curve (SdaiBoundary_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiBoundary_curve::~SdaiBoundary_curve () {  }

#ifdef __OSTORE__

void
SdaiBoundary_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBoundary_curve: virtual access function." << endl;
    SdaiBoundary_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiBoundary_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBoundary_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiBoundary_curve *ent = (SdaiBoundary_curve *)sent;
//    SdaiBoundary_curve *ent = (SdaiBoundary_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_boundary_curve;
}

SCLP23(Application_instance_ptr)
create_SdaiBoundary_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiBoundary_curve::get_os_typespec())
                                   SdaiBoundary_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiBoundary_curve::get_os_typespec())
//                                   SdaiBoundary_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiBoundary_curve;
}
#endif

#ifdef __O3DB__
void
SdaiBoundary_curve::oodb_reInit ()
{	eDesc = config_control_designe_boundary_curve;
}
#endif

SdaiBoundary_curve::SdaiBoundary_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiComposite_curve_on_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiComposite_curve_on_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_boundary_curve;
    MakeDerived ("dim");
    MakeDerived ("n_segments");
    MakeDerived ("closed_curve");
    MakeDerived ("basis_surface");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY boundary_curve


/////////	 ENTITY representation_context

EntityDescriptor *config_control_designe_representation_context =0;
AttrDescriptor *a_132context_identifier =0;
AttrDescriptor *a_133context_type =0;
Inverse_attribute *a_134Irepresentations_in_context =0;
SdaiRepresentation_context::SdaiRepresentation_context( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_132context_identifier,  &_context_identifier);
#else
    STEPattribute *a = new STEPattribute(*a_132context_identifier,  &_context_identifier);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_133context_type,  &_context_type);
#else
    a = new STEPattribute(*a_133context_type,  &_context_type);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiRepresentation_context::SdaiRepresentation_context (SdaiRepresentation_context& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiRepresentation_context::~SdaiRepresentation_context () {  }

#ifdef __OSTORE__

void
SdaiRepresentation_context::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation_context: virtual access function." << endl;
    SdaiRepresentation_context_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiRepresentation_context_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation_context: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiRepresentation_context *ent = (SdaiRepresentation_context *)sent;
//    SdaiRepresentation_context *ent = (SdaiRepresentation_context *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_representation_context;
    ent->attributes[0].aDesc = a_132context_identifier;
    ent->attributes[1].aDesc = a_133context_type;
}

SCLP23(Application_instance_ptr)
create_SdaiRepresentation_context(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiRepresentation_context::get_os_typespec())
                                   SdaiRepresentation_context;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiRepresentation_context::get_os_typespec())
//                                   SdaiRepresentation_context;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiRepresentation_context;
}
#endif

#ifdef __O3DB__
void
SdaiRepresentation_context::oodb_reInit ()
{	eDesc = config_control_designe_representation_context;
	attributes [0].aDesc = a_132context_identifier;
	attributes [1].aDesc = a_133context_type;
}
#endif

SdaiRepresentation_context::SdaiRepresentation_context( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_132context_identifier,  &_context_identifier);
#else
    STEPattribute *a = new STEPattribute(*a_132context_identifier,  &_context_identifier);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_133context_type,  &_context_type);
#else
    a = new STEPattribute(*a_133context_type,  &_context_type);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiRepresentation_context::context_identifier_() const
{
    return (const SdaiIdentifier) _context_identifier;
}

void
SdaiRepresentation_context::context_identifier_ (const SdaiIdentifier x)

{
    _context_identifier = x;
}

const SdaiText
SdaiRepresentation_context::context_type_() const
{
    return (const SdaiText) _context_type;
}

void
SdaiRepresentation_context::context_type_ (const SdaiText x)

{
    _context_type = x;
}

const EntityAggregate_ptr
SdaiRepresentation_context::representations_in_context_() const
{
    return (EntityAggregate_ptr) &_representations_in_context;
}

void
SdaiRepresentation_context::representations_in_context_ (const EntityAggregate_ptr x)

	{ _representations_in_context.ShallowCopy (*x); }

/////////	 END_ENTITY representation_context


/////////	 ENTITY geometric_representation_context

EntityDescriptor *config_control_designe_geometric_representation_context =0;
AttrDescriptor *a_135coordinate_space_dimension =0;
SdaiGeometric_representation_context::SdaiGeometric_representation_context( )
{

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_representation_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_135coordinate_space_dimension,  &_coordinate_space_dimension);
#else
    STEPattribute *a = new STEPattribute(*a_135coordinate_space_dimension,  &_coordinate_space_dimension);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiGeometric_representation_context::SdaiGeometric_representation_context (SdaiGeometric_representation_context& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiGeometric_representation_context::~SdaiGeometric_representation_context () {  }

#ifdef __OSTORE__

void
SdaiGeometric_representation_context::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometric_representation_context: virtual access function." << endl;
    SdaiGeometric_representation_context_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiGeometric_representation_context_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometric_representation_context: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiGeometric_representation_context *ent = (SdaiGeometric_representation_context *)sent;
//    SdaiGeometric_representation_context *ent = (SdaiGeometric_representation_context *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_geometric_representation_context;
    ent->attributes[2].aDesc = a_135coordinate_space_dimension;
}

SCLP23(Application_instance_ptr)
create_SdaiGeometric_representation_context(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiGeometric_representation_context::get_os_typespec())
                                   SdaiGeometric_representation_context;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiGeometric_representation_context::get_os_typespec())
//                                   SdaiGeometric_representation_context;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiGeometric_representation_context;
}
#endif

#ifdef __O3DB__
void
SdaiGeometric_representation_context::oodb_reInit ()
{	eDesc = config_control_designe_geometric_representation_context;
	attributes [2].aDesc = a_135coordinate_space_dimension;
}
#endif

SdaiGeometric_representation_context::SdaiGeometric_representation_context (SCLP23(Application_instance) *se, int *addAttrs) : SdaiRepresentation_context(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_representation_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_135coordinate_space_dimension,  &_coordinate_space_dimension);
#else
    STEPattribute *a = new STEPattribute(*a_135coordinate_space_dimension,  &_coordinate_space_dimension);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiDimension_count
SdaiGeometric_representation_context::coordinate_space_dimension_() const
{
    return (const SdaiDimension_count) _coordinate_space_dimension;
}

void
SdaiGeometric_representation_context::coordinate_space_dimension_ (const SdaiDimension_count x)

{
    _coordinate_space_dimension = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometric_representation_context


/////////	 ENTITY action_status

EntityDescriptor *config_control_designe_action_status =0;
AttrDescriptor *a_136status =0;
AttrDescriptor *a_137assigned_action =0;
SdaiAction_status::SdaiAction_status( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_status;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_136status,  &_status);
#else
    STEPattribute *a = new STEPattribute(*a_136status,  &_status);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_137assigned_action, (SCLP23(Application_instance_ptr) *) &_assigned_action);
#else
    a = new STEPattribute(*a_137assigned_action, (SCLP23(Application_instance_ptr) *) &_assigned_action);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_status::SdaiAction_status (SdaiAction_status& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAction_status::~SdaiAction_status () {  }

#ifdef __OSTORE__

void
SdaiAction_status::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_status: virtual access function." << endl;
    SdaiAction_status_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAction_status_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_status: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAction_status *ent = (SdaiAction_status *)sent;
//    SdaiAction_status *ent = (SdaiAction_status *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_action_status;
    ent->attributes[0].aDesc = a_136status;
    ent->attributes[1].aDesc = a_137assigned_action;
    if(ent->_assigned_action == 0)
        ent->_assigned_action = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiAction_status(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAction_status::get_os_typespec())
                                   SdaiAction_status;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAction_status::get_os_typespec())
//                                   SdaiAction_status;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAction_status;
}
#endif

#ifdef __O3DB__
void
SdaiAction_status::oodb_reInit ()
{	eDesc = config_control_designe_action_status;
	attributes [0].aDesc = a_136status;
	attributes [1].aDesc = a_137assigned_action;
}
#endif

SdaiAction_status::SdaiAction_status( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_action_status;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_136status,  &_status);
#else
    STEPattribute *a = new STEPattribute(*a_136status,  &_status);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_137assigned_action, (SCLP23(Application_instance_ptr) *) &_assigned_action);
#else
    a = new STEPattribute(*a_137assigned_action, (SCLP23(Application_instance_ptr) *) &_assigned_action);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiAction_status::status_() const
{
    return (const SdaiLabel) _status;
}

void
SdaiAction_status::status_ (const SdaiLabel x)

{
    _status = x;
}

const SdaiExecuted_action_ptr
SdaiAction_status::assigned_action_() const
{
    return (SdaiExecuted_action_ptr) _assigned_action;
}

void
SdaiAction_status::assigned_action_ (const SdaiExecuted_action_ptr x)

{
    _assigned_action = x;
}

/////////	 END_ENTITY action_status


/////////	 ENTITY application_context

EntityDescriptor *config_control_designe_application_context =0;
AttrDescriptor *a_138application =0;
Inverse_attribute *a_139Icontext_elements =0;
SdaiApplication_context::SdaiApplication_context( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_application_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_138application,  &_application);
#else
    STEPattribute *a = new STEPattribute(*a_138application,  &_application);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiApplication_context::SdaiApplication_context (SdaiApplication_context& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiApplication_context::~SdaiApplication_context () {  }

#ifdef __OSTORE__

void
SdaiApplication_context::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApplication_context: virtual access function." << endl;
    SdaiApplication_context_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiApplication_context_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApplication_context: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiApplication_context *ent = (SdaiApplication_context *)sent;
//    SdaiApplication_context *ent = (SdaiApplication_context *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_application_context;
    ent->attributes[0].aDesc = a_138application;
}

SCLP23(Application_instance_ptr)
create_SdaiApplication_context(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiApplication_context::get_os_typespec())
                                   SdaiApplication_context;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiApplication_context::get_os_typespec())
//                                   SdaiApplication_context;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiApplication_context;
}
#endif

#ifdef __O3DB__
void
SdaiApplication_context::oodb_reInit ()
{	eDesc = config_control_designe_application_context;
	attributes [0].aDesc = a_138application;
}
#endif

SdaiApplication_context::SdaiApplication_context( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_application_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_138application,  &_application);
#else
    STEPattribute *a = new STEPattribute(*a_138application,  &_application);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiText
SdaiApplication_context::application_() const
{
    return (const SdaiText) _application;
}

void
SdaiApplication_context::application_ (const SdaiText x)

{
    _application = x;
}

const EntityAggregate_ptr
SdaiApplication_context::context_elements_() const
{
    return (EntityAggregate_ptr) &_context_elements;
}

void
SdaiApplication_context::context_elements_ (const EntityAggregate_ptr x)

	{ _context_elements.ShallowCopy (*x); }

/////////	 END_ENTITY application_context


/////////	 ENTITY change_request

EntityDescriptor *config_control_designe_change_request =0;
AttrDescriptor *a_140items =0;
SdaiChange_request::SdaiChange_request( )
{

	/*  parent: SdaiAction_request_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_change_request;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_140items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_140items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiChange_request::SdaiChange_request (SdaiChange_request& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiChange_request::~SdaiChange_request () {  }

#ifdef __OSTORE__

void
SdaiChange_request::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiChange_request: virtual access function." << endl;
    SdaiChange_request_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiChange_request_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiChange_request: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiChange_request *ent = (SdaiChange_request *)sent;
//    SdaiChange_request *ent = (SdaiChange_request *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_change_request;
    ent->attributes[1].aDesc = a_140items;
}

SCLP23(Application_instance_ptr)
create_SdaiChange_request(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiChange_request::get_os_typespec())
                                   SdaiChange_request;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiChange_request::get_os_typespec())
//                                   SdaiChange_request;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiChange_request;
}
#endif

#ifdef __O3DB__
void
SdaiChange_request::oodb_reInit ()
{	eDesc = config_control_designe_change_request;
	attributes [1].aDesc = a_140items;
}
#endif

SdaiChange_request::SdaiChange_request (SCLP23(Application_instance) *se, int *addAttrs) : SdaiAction_request_assignment(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiAction_request_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_change_request;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_140items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_140items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiChange_request_items_ptr
SdaiChange_request::items_() const
{
    return (SdaiChange_request_items_ptr) &_items;
}

void
SdaiChange_request::items_ (const SdaiChange_request_items_ptr x)

	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY change_request


/////////	 ENTITY date_and_time

EntityDescriptor *config_control_designe_date_and_time =0;
AttrDescriptor *a_141date_component =0;
AttrDescriptor *a_142time_component =0;
SdaiDate_and_time::SdaiDate_and_time( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_date_and_time;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_141date_component, (SCLP23(Application_instance_ptr) *) &_date_component);
#else
    STEPattribute *a = new STEPattribute(*a_141date_component, (SCLP23(Application_instance_ptr) *) &_date_component);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_142time_component, (SCLP23(Application_instance_ptr) *) &_time_component);
#else
    a = new STEPattribute(*a_142time_component, (SCLP23(Application_instance_ptr) *) &_time_component);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDate_and_time::SdaiDate_and_time (SdaiDate_and_time& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDate_and_time::~SdaiDate_and_time () {  }

#ifdef __OSTORE__

void
SdaiDate_and_time::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDate_and_time: virtual access function." << endl;
    SdaiDate_and_time_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDate_and_time_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDate_and_time: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDate_and_time *ent = (SdaiDate_and_time *)sent;
//    SdaiDate_and_time *ent = (SdaiDate_and_time *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_date_and_time;
    ent->attributes[0].aDesc = a_141date_component;
    if(ent->_date_component == 0)
        ent->_date_component = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_142time_component;
    if(ent->_time_component == 0)
        ent->_time_component = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiDate_and_time(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDate_and_time::get_os_typespec())
                                   SdaiDate_and_time;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDate_and_time::get_os_typespec())
//                                   SdaiDate_and_time;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDate_and_time;
}
#endif

#ifdef __O3DB__
void
SdaiDate_and_time::oodb_reInit ()
{	eDesc = config_control_designe_date_and_time;
	attributes [0].aDesc = a_141date_component;
	attributes [1].aDesc = a_142time_component;
}
#endif

SdaiDate_and_time::SdaiDate_and_time( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_date_and_time;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_141date_component, (SCLP23(Application_instance_ptr) *) &_date_component);
#else
    STEPattribute *a = new STEPattribute(*a_141date_component, (SCLP23(Application_instance_ptr) *) &_date_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_142time_component, (SCLP23(Application_instance_ptr) *) &_time_component);
#else
    a = new STEPattribute(*a_142time_component, (SCLP23(Application_instance_ptr) *) &_time_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiDate_ptr
SdaiDate_and_time::date_component_() const
{
    return (SdaiDate_ptr) _date_component;
}

void
SdaiDate_and_time::date_component_ (const SdaiDate_ptr x)

{
    _date_component = x;
}

const SdaiLocal_time_ptr
SdaiDate_and_time::time_component_() const
{
    return (SdaiLocal_time_ptr) _time_component;
}

void
SdaiDate_and_time::time_component_ (const SdaiLocal_time_ptr x)

{
    _time_component = x;
}

/////////	 END_ENTITY date_and_time


/////////	 ENTITY approval_date_time

EntityDescriptor *config_control_designe_approval_date_time =0;
AttrDescriptor *a_143date_time =0;
AttrDescriptor *a_144dated_approval =0;
SdaiApproval_date_time::SdaiApproval_date_time( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_date_time;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_143date_time,  &_date_time);
#else
    STEPattribute *a = new STEPattribute(*a_143date_time,  &_date_time);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_144dated_approval, (SCLP23(Application_instance_ptr) *) &_dated_approval);
#else
    a = new STEPattribute(*a_144dated_approval, (SCLP23(Application_instance_ptr) *) &_dated_approval);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_date_time::SdaiApproval_date_time (SdaiApproval_date_time& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiApproval_date_time::~SdaiApproval_date_time () {  }

#ifdef __OSTORE__

void
SdaiApproval_date_time::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_date_time: virtual access function." << endl;
    SdaiApproval_date_time_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiApproval_date_time_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_date_time: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiApproval_date_time *ent = (SdaiApproval_date_time *)sent;
//    SdaiApproval_date_time *ent = (SdaiApproval_date_time *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_approval_date_time;
    ent->attributes[0].aDesc = a_143date_time;
    ent->attributes[1].aDesc = a_144dated_approval;
    if(ent->_dated_approval == 0)
        ent->_dated_approval = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiApproval_date_time(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiApproval_date_time::get_os_typespec())
                                   SdaiApproval_date_time;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiApproval_date_time::get_os_typespec())
//                                   SdaiApproval_date_time;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiApproval_date_time;
}
#endif

#ifdef __O3DB__
void
SdaiApproval_date_time::oodb_reInit ()
{	eDesc = config_control_designe_approval_date_time;
	attributes [0].aDesc = a_143date_time;
	attributes [1].aDesc = a_144dated_approval;
}
#endif

SdaiApproval_date_time::SdaiApproval_date_time( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_date_time;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_143date_time,  &_date_time);
#else
    STEPattribute *a = new STEPattribute(*a_143date_time,  &_date_time);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_144dated_approval, (SCLP23(Application_instance_ptr) *) &_dated_approval);
#else
    a = new STEPattribute(*a_144dated_approval, (SCLP23(Application_instance_ptr) *) &_dated_approval);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiDate_time_select_ptr
SdaiApproval_date_time::date_time_() const
	{ return (const SdaiDate_time_select_ptr) &_date_time; }

void
SdaiApproval_date_time::date_time_ (const SdaiDate_time_select_ptr x)

	{ _date_time = x; }

const SdaiApproval_ptr
SdaiApproval_date_time::dated_approval_() const
{
    return (SdaiApproval_ptr) _dated_approval;
}

void
SdaiApproval_date_time::dated_approval_ (const SdaiApproval_ptr x)

{
    _dated_approval = x;
}

/////////	 END_ENTITY approval_date_time


/////////	 ENTITY approval_role

EntityDescriptor *config_control_designe_approval_role =0;
AttrDescriptor *a_145role =0;
SdaiApproval_role::SdaiApproval_role( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_role;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_145role,  &_role);
#else
    STEPattribute *a = new STEPattribute(*a_145role,  &_role);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_role::SdaiApproval_role (SdaiApproval_role& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiApproval_role::~SdaiApproval_role () {  }

#ifdef __OSTORE__

void
SdaiApproval_role::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_role: virtual access function." << endl;
    SdaiApproval_role_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiApproval_role_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_role: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiApproval_role *ent = (SdaiApproval_role *)sent;
//    SdaiApproval_role *ent = (SdaiApproval_role *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_approval_role;
    ent->attributes[0].aDesc = a_145role;
}

SCLP23(Application_instance_ptr)
create_SdaiApproval_role(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiApproval_role::get_os_typespec())
                                   SdaiApproval_role;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiApproval_role::get_os_typespec())
//                                   SdaiApproval_role;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiApproval_role;
}
#endif

#ifdef __O3DB__
void
SdaiApproval_role::oodb_reInit ()
{	eDesc = config_control_designe_approval_role;
	attributes [0].aDesc = a_145role;
}
#endif

SdaiApproval_role::SdaiApproval_role( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_role;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_145role,  &_role);
#else
    STEPattribute *a = new STEPattribute(*a_145role,  &_role);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiApproval_role::role_() const
{
    return (const SdaiLabel) _role;
}

void
SdaiApproval_role::role_ (const SdaiLabel x)

{
    _role = x;
}

/////////	 END_ENTITY approval_role


/////////	 ENTITY application_context_element

EntityDescriptor *config_control_designe_application_context_element =0;
AttrDescriptor *a_146name =0;
AttrDescriptor *a_147frame_of_reference =0;
SdaiApplication_context_element::SdaiApplication_context_element( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_application_context_element;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_146name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_146name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_147frame_of_reference, (SCLP23(Application_instance_ptr) *) &_frame_of_reference);
#else
    a = new STEPattribute(*a_147frame_of_reference, (SCLP23(Application_instance_ptr) *) &_frame_of_reference);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiApplication_context_element::SdaiApplication_context_element (SdaiApplication_context_element& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiApplication_context_element::~SdaiApplication_context_element () {  }

#ifdef __OSTORE__

void
SdaiApplication_context_element::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApplication_context_element: virtual access function." << endl;
    SdaiApplication_context_element_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiApplication_context_element_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApplication_context_element: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiApplication_context_element *ent = (SdaiApplication_context_element *)sent;
//    SdaiApplication_context_element *ent = (SdaiApplication_context_element *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_application_context_element;
    ent->attributes[0].aDesc = a_146name;
    ent->attributes[1].aDesc = a_147frame_of_reference;
    if(ent->_frame_of_reference == 0)
        ent->_frame_of_reference = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiApplication_context_element(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiApplication_context_element::get_os_typespec())
                                   SdaiApplication_context_element;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiApplication_context_element::get_os_typespec())
//                                   SdaiApplication_context_element;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiApplication_context_element;
}
#endif

#ifdef __O3DB__
void
SdaiApplication_context_element::oodb_reInit ()
{	eDesc = config_control_designe_application_context_element;
	attributes [0].aDesc = a_146name;
	attributes [1].aDesc = a_147frame_of_reference;
}
#endif

SdaiApplication_context_element::SdaiApplication_context_element( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_application_context_element;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_146name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_146name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_147frame_of_reference, (SCLP23(Application_instance_ptr) *) &_frame_of_reference);
#else
    a = new STEPattribute(*a_147frame_of_reference, (SCLP23(Application_instance_ptr) *) &_frame_of_reference);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiApplication_context_element::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiApplication_context_element::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiApplication_context_ptr
SdaiApplication_context_element::frame_of_reference_() const
{
    return (SdaiApplication_context_ptr) _frame_of_reference;
}

void
SdaiApplication_context_element::frame_of_reference_ (const SdaiApplication_context_ptr x)

{
    _frame_of_reference = x;
}

/////////	 END_ENTITY application_context_element


/////////	 ENTITY product_context

EntityDescriptor *config_control_designe_product_context =0;
AttrDescriptor *a_148discipline_type =0;
SdaiProduct_context::SdaiProduct_context( )
{

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_148discipline_type,  &_discipline_type);
#else
    STEPattribute *a = new STEPattribute(*a_148discipline_type,  &_discipline_type);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_context::SdaiProduct_context (SdaiProduct_context& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_context::~SdaiProduct_context () {  }

#ifdef __OSTORE__

void
SdaiProduct_context::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_context: virtual access function." << endl;
    SdaiProduct_context_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_context_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_context: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_context *ent = (SdaiProduct_context *)sent;
//    SdaiProduct_context *ent = (SdaiProduct_context *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_context;
    ent->attributes[2].aDesc = a_148discipline_type;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_context(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_context::get_os_typespec())
                                   SdaiProduct_context;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_context::get_os_typespec())
//                                   SdaiProduct_context;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_context;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_context::oodb_reInit ()
{	eDesc = config_control_designe_product_context;
	attributes [2].aDesc = a_148discipline_type;
}
#endif

SdaiProduct_context::SdaiProduct_context (SCLP23(Application_instance) *se, int *addAttrs) : SdaiApplication_context_element(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_148discipline_type,  &_discipline_type);
#else
    STEPattribute *a = new STEPattribute(*a_148discipline_type,  &_discipline_type);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiProduct_context::discipline_type_() const
{
    return (const SdaiLabel) _discipline_type;
}

void
SdaiProduct_context::discipline_type_ (const SdaiLabel x)

{
    _discipline_type = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_context


/////////	 ENTITY elementary_surface

EntityDescriptor *config_control_designe_elementary_surface =0;
AttrDescriptor *a_149position =0;
SdaiElementary_surface::SdaiElementary_surface( )
{

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_elementary_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_149position, (SCLP23(Application_instance_ptr) *) &_position);
#else
    STEPattribute *a = new STEPattribute(*a_149position, (SCLP23(Application_instance_ptr) *) &_position);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiElementary_surface::SdaiElementary_surface (SdaiElementary_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiElementary_surface::~SdaiElementary_surface () {  }

#ifdef __OSTORE__

void
SdaiElementary_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiElementary_surface: virtual access function." << endl;
    SdaiElementary_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiElementary_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiElementary_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiElementary_surface *ent = (SdaiElementary_surface *)sent;
//    SdaiElementary_surface *ent = (SdaiElementary_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_elementary_surface;
    ent->attributes[1].aDesc = a_149position;
    if(ent->_position == 0)
        ent->_position = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiElementary_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiElementary_surface::get_os_typespec())
                                   SdaiElementary_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiElementary_surface::get_os_typespec())
//                                   SdaiElementary_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiElementary_surface;
}
#endif

#ifdef __O3DB__
void
SdaiElementary_surface::oodb_reInit ()
{	eDesc = config_control_designe_elementary_surface;
	attributes [1].aDesc = a_149position;
}
#endif

SdaiElementary_surface::SdaiElementary_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSurface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_elementary_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_149position, (SCLP23(Application_instance_ptr) *) &_position);
#else
    STEPattribute *a = new STEPattribute(*a_149position, (SCLP23(Application_instance_ptr) *) &_position);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiAxis2_placement_3d_ptr
SdaiElementary_surface::position_() const
{
    return (SdaiAxis2_placement_3d_ptr) _position;
}

void
SdaiElementary_surface::position_ (const SdaiAxis2_placement_3d_ptr x)

{
    _position = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY elementary_surface


/////////	 ENTITY spherical_surface

EntityDescriptor *config_control_designe_spherical_surface =0;
AttrDescriptor *a_150radius =0;
SdaiSpherical_surface::SdaiSpherical_surface( )
{

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_spherical_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_150radius,  &_radius);
#else
    STEPattribute *a = new STEPattribute(*a_150radius,  &_radius);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiSpherical_surface::SdaiSpherical_surface (SdaiSpherical_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSpherical_surface::~SdaiSpherical_surface () {  }

#ifdef __OSTORE__

void
SdaiSpherical_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSpherical_surface: virtual access function." << endl;
    SdaiSpherical_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSpherical_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSpherical_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSpherical_surface *ent = (SdaiSpherical_surface *)sent;
//    SdaiSpherical_surface *ent = (SdaiSpherical_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_spherical_surface;
    ent->attributes[2].aDesc = a_150radius;
}

SCLP23(Application_instance_ptr)
create_SdaiSpherical_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSpherical_surface::get_os_typespec())
                                   SdaiSpherical_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSpherical_surface::get_os_typespec())
//                                   SdaiSpherical_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSpherical_surface;
}
#endif

#ifdef __O3DB__
void
SdaiSpherical_surface::oodb_reInit ()
{	eDesc = config_control_designe_spherical_surface;
	attributes [2].aDesc = a_150radius;
}
#endif

SdaiSpherical_surface::SdaiSpherical_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiElementary_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_spherical_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_150radius,  &_radius);
#else
    STEPattribute *a = new STEPattribute(*a_150radius,  &_radius);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiPositive_length_measure
SdaiSpherical_surface::radius_() const
{
    return (const SdaiPositive_length_measure) _radius;
}

void
SdaiSpherical_surface::radius_ (const SdaiPositive_length_measure x)

{
    _radius = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY spherical_surface


/////////	 ENTITY application_protocol_definition

EntityDescriptor *config_control_designe_application_protocol_definition =0;
AttrDescriptor *a_151status =0;
AttrDescriptor *a_152application_interpreted_model_schema_name =0;
AttrDescriptor *a_153application_protocol_year =0;
AttrDescriptor *a_154application =0;
SdaiApplication_protocol_definition::SdaiApplication_protocol_definition( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_application_protocol_definition;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_151status,  &_status);
#else
    STEPattribute *a = new STEPattribute(*a_151status,  &_status);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_152application_interpreted_model_schema_name,  &_application_interpreted_model_schema_name);
#else
    a = new STEPattribute(*a_152application_interpreted_model_schema_name,  &_application_interpreted_model_schema_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_153application_protocol_year,  &_application_protocol_year);
#else
    a = new STEPattribute(*a_153application_protocol_year,  &_application_protocol_year);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_154application, (SCLP23(Application_instance_ptr) *) &_application);
#else
    a = new STEPattribute(*a_154application, (SCLP23(Application_instance_ptr) *) &_application);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiApplication_protocol_definition::SdaiApplication_protocol_definition (SdaiApplication_protocol_definition& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiApplication_protocol_definition::~SdaiApplication_protocol_definition () {  }

#ifdef __OSTORE__

void
SdaiApplication_protocol_definition::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApplication_protocol_definition: virtual access function." << endl;
    SdaiApplication_protocol_definition_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiApplication_protocol_definition_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApplication_protocol_definition: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiApplication_protocol_definition *ent = (SdaiApplication_protocol_definition *)sent;
//    SdaiApplication_protocol_definition *ent = (SdaiApplication_protocol_definition *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_application_protocol_definition;
    ent->attributes[0].aDesc = a_151status;
    ent->attributes[1].aDesc = a_152application_interpreted_model_schema_name;
    ent->attributes[2].aDesc = a_153application_protocol_year;
    ent->attributes[3].aDesc = a_154application;
    if(ent->_application == 0)
        ent->_application = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiApplication_protocol_definition(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiApplication_protocol_definition::get_os_typespec())
                                   SdaiApplication_protocol_definition;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiApplication_protocol_definition::get_os_typespec())
//                                   SdaiApplication_protocol_definition;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiApplication_protocol_definition;
}
#endif

#ifdef __O3DB__
void
SdaiApplication_protocol_definition::oodb_reInit ()
{	eDesc = config_control_designe_application_protocol_definition;
	attributes [0].aDesc = a_151status;
	attributes [1].aDesc = a_152application_interpreted_model_schema_name;
	attributes [2].aDesc = a_153application_protocol_year;
	attributes [3].aDesc = a_154application;
}
#endif

SdaiApplication_protocol_definition::SdaiApplication_protocol_definition( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_application_protocol_definition;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_151status,  &_status);
#else
    STEPattribute *a = new STEPattribute(*a_151status,  &_status);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_152application_interpreted_model_schema_name,  &_application_interpreted_model_schema_name);
#else
    a = new STEPattribute(*a_152application_interpreted_model_schema_name,  &_application_interpreted_model_schema_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_153application_protocol_year,  &_application_protocol_year);
#else
    a = new STEPattribute(*a_153application_protocol_year,  &_application_protocol_year);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_154application, (SCLP23(Application_instance_ptr) *) &_application);
#else
    a = new STEPattribute(*a_154application, (SCLP23(Application_instance_ptr) *) &_application);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiApplication_protocol_definition::status_() const
{
    return (const SdaiLabel) _status;
}

void
SdaiApplication_protocol_definition::status_ (const SdaiLabel x)

{
    _status = x;
}

const SdaiLabel
SdaiApplication_protocol_definition::application_interpreted_model_schema_name_() const
{
    return (const SdaiLabel) _application_interpreted_model_schema_name;
}

void
SdaiApplication_protocol_definition::application_interpreted_model_schema_name_ (const SdaiLabel x)

{
    _application_interpreted_model_schema_name = x;
}

const SdaiYear_number
SdaiApplication_protocol_definition::application_protocol_year_() const
{
    return (const SdaiYear_number) _application_protocol_year;
}

void
SdaiApplication_protocol_definition::application_protocol_year_ (const SdaiYear_number x)

{
    _application_protocol_year = x;
}

const SdaiApplication_context_ptr
SdaiApplication_protocol_definition::application_() const
{
    return (SdaiApplication_context_ptr) _application;
}

void
SdaiApplication_protocol_definition::application_ (const SdaiApplication_context_ptr x)

{
    _application = x;
}

/////////	 END_ENTITY application_protocol_definition


/////////	 ENTITY specified_higher_usage_occurrence

EntityDescriptor *config_control_designe_specified_higher_usage_occurrence =0;
AttrDescriptor *a_155upper_usage =0;
AttrDescriptor *a_156next_usage =0;
SdaiSpecified_higher_usage_occurrence::SdaiSpecified_higher_usage_occurrence( )
{

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_specified_higher_usage_occurrence;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_155upper_usage, (SCLP23(Application_instance_ptr) *) &_upper_usage);
#else
    STEPattribute *a = new STEPattribute(*a_155upper_usage, (SCLP23(Application_instance_ptr) *) &_upper_usage);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_156next_usage, (SCLP23(Application_instance_ptr) *) &_next_usage);
#else
    a = new STEPattribute(*a_156next_usage, (SCLP23(Application_instance_ptr) *) &_next_usage);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiSpecified_higher_usage_occurrence::SdaiSpecified_higher_usage_occurrence (SdaiSpecified_higher_usage_occurrence& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSpecified_higher_usage_occurrence::~SdaiSpecified_higher_usage_occurrence () {  }

#ifdef __OSTORE__

void
SdaiSpecified_higher_usage_occurrence::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSpecified_higher_usage_occurrence: virtual access function." << endl;
    SdaiSpecified_higher_usage_occurrence_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSpecified_higher_usage_occurrence_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSpecified_higher_usage_occurrence: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSpecified_higher_usage_occurrence *ent = (SdaiSpecified_higher_usage_occurrence *)sent;
//    SdaiSpecified_higher_usage_occurrence *ent = (SdaiSpecified_higher_usage_occurrence *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_specified_higher_usage_occurrence;
    ent->attributes[6].aDesc = a_155upper_usage;
    if(ent->_upper_usage == 0)
        ent->_upper_usage = S_ENTITY_NULL;
    ent->attributes[7].aDesc = a_156next_usage;
    if(ent->_next_usage == 0)
        ent->_next_usage = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiSpecified_higher_usage_occurrence(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSpecified_higher_usage_occurrence::get_os_typespec())
                                   SdaiSpecified_higher_usage_occurrence;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSpecified_higher_usage_occurrence::get_os_typespec())
//                                   SdaiSpecified_higher_usage_occurrence;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSpecified_higher_usage_occurrence;
}
#endif

#ifdef __O3DB__
void
SdaiSpecified_higher_usage_occurrence::oodb_reInit ()
{	eDesc = config_control_designe_specified_higher_usage_occurrence;
	attributes [6].aDesc = a_155upper_usage;
	attributes [7].aDesc = a_156next_usage;
}
#endif

SdaiSpecified_higher_usage_occurrence::SdaiSpecified_higher_usage_occurrence (SCLP23(Application_instance) *se, int *addAttrs) : SdaiAssembly_component_usage(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_specified_higher_usage_occurrence;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_155upper_usage, (SCLP23(Application_instance_ptr) *) &_upper_usage);
#else
    STEPattribute *a = new STEPattribute(*a_155upper_usage, (SCLP23(Application_instance_ptr) *) &_upper_usage);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_156next_usage, (SCLP23(Application_instance_ptr) *) &_next_usage);
#else
    a = new STEPattribute(*a_156next_usage, (SCLP23(Application_instance_ptr) *) &_next_usage);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiAssembly_component_usage_ptr
SdaiSpecified_higher_usage_occurrence::upper_usage_() const
{
    return (SdaiAssembly_component_usage_ptr) _upper_usage;
}

void
SdaiSpecified_higher_usage_occurrence::upper_usage_ (const SdaiAssembly_component_usage_ptr x)

{
    _upper_usage = x;
}

const SdaiNext_assembly_usage_occurrence_ptr
SdaiSpecified_higher_usage_occurrence::next_usage_() const
{
    return (SdaiNext_assembly_usage_occurrence_ptr) _next_usage;
}

void
SdaiSpecified_higher_usage_occurrence::next_usage_ (const SdaiNext_assembly_usage_occurrence_ptr x)

{
    _next_usage = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY specified_higher_usage_occurrence


/////////	 ENTITY product_definition_formation_with_specified_source

EntityDescriptor *config_control_designe_product_definition_formation_with_specified_source =0;
AttrDescriptor *a_157make_or_buy =0;
SdaiProduct_definition_formation_with_specified_source::SdaiProduct_definition_formation_with_specified_source( )
{

	/*  parent: SdaiProduct_definition_formation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_formation_with_specified_source;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_157make_or_buy,  &_make_or_buy);
#else
    STEPattribute *a = new STEPattribute(*a_157make_or_buy,  &_make_or_buy);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_formation_with_specified_source::SdaiProduct_definition_formation_with_specified_source (SdaiProduct_definition_formation_with_specified_source& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_definition_formation_with_specified_source::~SdaiProduct_definition_formation_with_specified_source () {  }

#ifdef __OSTORE__

void
SdaiProduct_definition_formation_with_specified_source::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_formation_with_specified_source: virtual access function." << endl;
    SdaiProduct_definition_formation_with_specified_source_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_definition_formation_with_specified_source_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_formation_with_specified_source: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_definition_formation_with_specified_source *ent = (SdaiProduct_definition_formation_with_specified_source *)sent;
//    SdaiProduct_definition_formation_with_specified_source *ent = (SdaiProduct_definition_formation_with_specified_source *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_definition_formation_with_specified_source;
    ent->attributes[3].aDesc = a_157make_or_buy;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_definition_formation_with_specified_source(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_definition_formation_with_specified_source::get_os_typespec())
                                   SdaiProduct_definition_formation_with_specified_source;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_definition_formation_with_specified_source::get_os_typespec())
//                                   SdaiProduct_definition_formation_with_specified_source;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_definition_formation_with_specified_source;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_definition_formation_with_specified_source::oodb_reInit ()
{	eDesc = config_control_designe_product_definition_formation_with_specified_source;
	attributes [3].aDesc = a_157make_or_buy;
}
#endif

SdaiProduct_definition_formation_with_specified_source::SdaiProduct_definition_formation_with_specified_source (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProduct_definition_formation(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProduct_definition_formation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_formation_with_specified_source;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_157make_or_buy,  &_make_or_buy);
#else
    STEPattribute *a = new STEPattribute(*a_157make_or_buy,  &_make_or_buy);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiSource_var
SdaiProduct_definition_formation_with_specified_source::make_or_buy_() const
{
    return (Source) _make_or_buy;
}

void
SdaiProduct_definition_formation_with_specified_source::make_or_buy_ (const SdaiSource_var x)

{
    _make_or_buy.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_formation_with_specified_source


/////////	 ENTITY action_request_solution

EntityDescriptor *config_control_designe_action_request_solution =0;
AttrDescriptor *a_158method =0;
AttrDescriptor *a_159request =0;
SdaiAction_request_solution::SdaiAction_request_solution( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_solution;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_158method, (SCLP23(Application_instance_ptr) *) &_method);
#else
    STEPattribute *a = new STEPattribute(*a_158method, (SCLP23(Application_instance_ptr) *) &_method);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_159request, (SCLP23(Application_instance_ptr) *) &_request);
#else
    a = new STEPattribute(*a_159request, (SCLP23(Application_instance_ptr) *) &_request);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_request_solution::SdaiAction_request_solution (SdaiAction_request_solution& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAction_request_solution::~SdaiAction_request_solution () {  }

#ifdef __OSTORE__

void
SdaiAction_request_solution::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_request_solution: virtual access function." << endl;
    SdaiAction_request_solution_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAction_request_solution_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_request_solution: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAction_request_solution *ent = (SdaiAction_request_solution *)sent;
//    SdaiAction_request_solution *ent = (SdaiAction_request_solution *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_action_request_solution;
    ent->attributes[0].aDesc = a_158method;
    if(ent->_method == 0)
        ent->_method = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_159request;
    if(ent->_request == 0)
        ent->_request = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiAction_request_solution(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAction_request_solution::get_os_typespec())
                                   SdaiAction_request_solution;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAction_request_solution::get_os_typespec())
//                                   SdaiAction_request_solution;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAction_request_solution;
}
#endif

#ifdef __O3DB__
void
SdaiAction_request_solution::oodb_reInit ()
{	eDesc = config_control_designe_action_request_solution;
	attributes [0].aDesc = a_158method;
	attributes [1].aDesc = a_159request;
}
#endif

SdaiAction_request_solution::SdaiAction_request_solution( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_solution;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_158method, (SCLP23(Application_instance_ptr) *) &_method);
#else
    STEPattribute *a = new STEPattribute(*a_158method, (SCLP23(Application_instance_ptr) *) &_method);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_159request, (SCLP23(Application_instance_ptr) *) &_request);
#else
    a = new STEPattribute(*a_159request, (SCLP23(Application_instance_ptr) *) &_request);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiAction_method_ptr
SdaiAction_request_solution::method_() const
{
    return (SdaiAction_method_ptr) _method;
}

void
SdaiAction_request_solution::method_ (const SdaiAction_method_ptr x)

{
    _method = x;
}

const SdaiVersioned_action_request_ptr
SdaiAction_request_solution::request_() const
{
    return (SdaiVersioned_action_request_ptr) _request;
}

void
SdaiAction_request_solution::request_ (const SdaiVersioned_action_request_ptr x)

{
    _request = x;
}

/////////	 END_ENTITY action_request_solution


/////////	 ENTITY uncertainty_measure_with_unit

EntityDescriptor *config_control_designe_uncertainty_measure_with_unit =0;
AttrDescriptor *a_160name =0;
AttrDescriptor *a_161description =0;
SdaiUncertainty_measure_with_unit::SdaiUncertainty_measure_with_unit( )
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uncertainty_measure_with_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_160name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_160name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_161description,  &_description);
#else
    a = new STEPattribute(*a_161description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiUncertainty_measure_with_unit::SdaiUncertainty_measure_with_unit (SdaiUncertainty_measure_with_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiUncertainty_measure_with_unit::~SdaiUncertainty_measure_with_unit () {  }

#ifdef __OSTORE__

void
SdaiUncertainty_measure_with_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiUncertainty_measure_with_unit: virtual access function." << endl;
    SdaiUncertainty_measure_with_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiUncertainty_measure_with_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiUncertainty_measure_with_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiUncertainty_measure_with_unit *ent = (SdaiUncertainty_measure_with_unit *)sent;
//    SdaiUncertainty_measure_with_unit *ent = (SdaiUncertainty_measure_with_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_uncertainty_measure_with_unit;
    ent->attributes[2].aDesc = a_160name;
    ent->attributes[3].aDesc = a_161description;
}

SCLP23(Application_instance_ptr)
create_SdaiUncertainty_measure_with_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiUncertainty_measure_with_unit::get_os_typespec())
                                   SdaiUncertainty_measure_with_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiUncertainty_measure_with_unit::get_os_typespec())
//                                   SdaiUncertainty_measure_with_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiUncertainty_measure_with_unit;
}
#endif

#ifdef __O3DB__
void
SdaiUncertainty_measure_with_unit::oodb_reInit ()
{	eDesc = config_control_designe_uncertainty_measure_with_unit;
	attributes [2].aDesc = a_160name;
	attributes [3].aDesc = a_161description;
}
#endif

SdaiUncertainty_measure_with_unit::SdaiUncertainty_measure_with_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiMeasure_with_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uncertainty_measure_with_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_160name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_160name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_161description,  &_description);
#else
    a = new STEPattribute(*a_161description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiUncertainty_measure_with_unit::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiUncertainty_measure_with_unit::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiUncertainty_measure_with_unit::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiUncertainty_measure_with_unit::description_ (const SdaiText x)

{
    _description = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY uncertainty_measure_with_unit


/////////	 ENTITY edge_based_wireframe_model

EntityDescriptor *config_control_designe_edge_based_wireframe_model =0;
AttrDescriptor *a_162ebwm_boundary =0;
SdaiEdge_based_wireframe_model::SdaiEdge_based_wireframe_model( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge_based_wireframe_model;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_162ebwm_boundary,  &_ebwm_boundary);
#else
    STEPattribute *a = new STEPattribute(*a_162ebwm_boundary,  &_ebwm_boundary);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiEdge_based_wireframe_model::SdaiEdge_based_wireframe_model (SdaiEdge_based_wireframe_model& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiEdge_based_wireframe_model::~SdaiEdge_based_wireframe_model () {  }

#ifdef __OSTORE__

void
SdaiEdge_based_wireframe_model::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEdge_based_wireframe_model: virtual access function." << endl;
    SdaiEdge_based_wireframe_model_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiEdge_based_wireframe_model_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEdge_based_wireframe_model: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiEdge_based_wireframe_model *ent = (SdaiEdge_based_wireframe_model *)sent;
//    SdaiEdge_based_wireframe_model *ent = (SdaiEdge_based_wireframe_model *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_edge_based_wireframe_model;
    ent->attributes[1].aDesc = a_162ebwm_boundary;
}

SCLP23(Application_instance_ptr)
create_SdaiEdge_based_wireframe_model(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiEdge_based_wireframe_model::get_os_typespec())
                                   SdaiEdge_based_wireframe_model;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiEdge_based_wireframe_model::get_os_typespec())
//                                   SdaiEdge_based_wireframe_model;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiEdge_based_wireframe_model;
}
#endif

#ifdef __O3DB__
void
SdaiEdge_based_wireframe_model::oodb_reInit ()
{	eDesc = config_control_designe_edge_based_wireframe_model;
	attributes [1].aDesc = a_162ebwm_boundary;
}
#endif

SdaiEdge_based_wireframe_model::SdaiEdge_based_wireframe_model (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge_based_wireframe_model;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_162ebwm_boundary,  &_ebwm_boundary);
#else
    STEPattribute *a = new STEPattribute(*a_162ebwm_boundary,  &_ebwm_boundary);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const EntityAggregate_ptr
SdaiEdge_based_wireframe_model::ebwm_boundary_() const
{
    return (EntityAggregate_ptr) &_ebwm_boundary;
}

void
SdaiEdge_based_wireframe_model::ebwm_boundary_ (const EntityAggregate_ptr x)

	{ _ebwm_boundary.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY edge_based_wireframe_model


/////////	 ENTITY path

EntityDescriptor *config_control_designe_path =0;
AttrDescriptor *a_163edge_list =0;
SdaiPath::SdaiPath( )
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_path;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_163edge_list,  &_edge_list);
#else
    STEPattribute *a = new STEPattribute(*a_163edge_list,  &_edge_list);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiPath::SdaiPath (SdaiPath& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPath::~SdaiPath () {  }

#ifdef __OSTORE__

void
SdaiPath::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPath: virtual access function." << endl;
    SdaiPath_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPath_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPath: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPath *ent = (SdaiPath *)sent;
//    SdaiPath *ent = (SdaiPath *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_path;
    ent->attributes[1].aDesc = a_163edge_list;
}

SCLP23(Application_instance_ptr)
create_SdaiPath(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPath::get_os_typespec())
                                   SdaiPath;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPath::get_os_typespec())
//                                   SdaiPath;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPath;
}
#endif

#ifdef __O3DB__
void
SdaiPath::oodb_reInit ()
{	eDesc = config_control_designe_path;
	attributes [1].aDesc = a_163edge_list;
}
#endif

SdaiPath::SdaiPath (SCLP23(Application_instance) *se, int *addAttrs) : SdaiTopological_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_path;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_163edge_list,  &_edge_list);
#else
    STEPattribute *a = new STEPattribute(*a_163edge_list,  &_edge_list);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const EntityAggregate_ptr
SdaiPath::edge_list_() const
{
    return (EntityAggregate_ptr) &_edge_list;
}

void
SdaiPath::edge_list_ (const EntityAggregate_ptr x)

	{ _edge_list.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY path


/////////	 ENTITY connected_face_set

EntityDescriptor *config_control_designe_connected_face_set =0;
AttrDescriptor *a_164cfs_faces =0;
SdaiConnected_face_set::SdaiConnected_face_set( )
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_connected_face_set;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_164cfs_faces,  &_cfs_faces);
#else
    STEPattribute *a = new STEPattribute(*a_164cfs_faces,  &_cfs_faces);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiConnected_face_set::SdaiConnected_face_set (SdaiConnected_face_set& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiConnected_face_set::~SdaiConnected_face_set () {  }

#ifdef __OSTORE__

void
SdaiConnected_face_set::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConnected_face_set: virtual access function." << endl;
    SdaiConnected_face_set_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiConnected_face_set_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConnected_face_set: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiConnected_face_set *ent = (SdaiConnected_face_set *)sent;
//    SdaiConnected_face_set *ent = (SdaiConnected_face_set *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_connected_face_set;
    ent->attributes[1].aDesc = a_164cfs_faces;
}

SCLP23(Application_instance_ptr)
create_SdaiConnected_face_set(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiConnected_face_set::get_os_typespec())
                                   SdaiConnected_face_set;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiConnected_face_set::get_os_typespec())
//                                   SdaiConnected_face_set;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiConnected_face_set;
}
#endif

#ifdef __O3DB__
void
SdaiConnected_face_set::oodb_reInit ()
{	eDesc = config_control_designe_connected_face_set;
	attributes [1].aDesc = a_164cfs_faces;
}
#endif

SdaiConnected_face_set::SdaiConnected_face_set (SCLP23(Application_instance) *se, int *addAttrs) : SdaiTopological_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_connected_face_set;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_164cfs_faces,  &_cfs_faces);
#else
    STEPattribute *a = new STEPattribute(*a_164cfs_faces,  &_cfs_faces);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const EntityAggregate_ptr
SdaiConnected_face_set::cfs_faces_() const
{
    return (EntityAggregate_ptr) &_cfs_faces;
}

void
SdaiConnected_face_set::cfs_faces_ (const EntityAggregate_ptr x)

	{ _cfs_faces.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY connected_face_set


/////////	 ENTITY open_shell

EntityDescriptor *config_control_designe_open_shell =0;
SdaiOpen_shell::SdaiOpen_shell( )
{

	/*  parent: SdaiConnected_face_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_open_shell;
}
SdaiOpen_shell::SdaiOpen_shell (SdaiOpen_shell& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOpen_shell::~SdaiOpen_shell () {  }

#ifdef __OSTORE__

void
SdaiOpen_shell::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOpen_shell: virtual access function." << endl;
    SdaiOpen_shell_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOpen_shell_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOpen_shell: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOpen_shell *ent = (SdaiOpen_shell *)sent;
//    SdaiOpen_shell *ent = (SdaiOpen_shell *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_open_shell;
}

SCLP23(Application_instance_ptr)
create_SdaiOpen_shell(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOpen_shell::get_os_typespec())
                                   SdaiOpen_shell;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOpen_shell::get_os_typespec())
//                                   SdaiOpen_shell;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOpen_shell;
}
#endif

#ifdef __O3DB__
void
SdaiOpen_shell::oodb_reInit ()
{	eDesc = config_control_designe_open_shell;
}
#endif

SdaiOpen_shell::SdaiOpen_shell (SCLP23(Application_instance) *se, int *addAttrs) : SdaiConnected_face_set(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiConnected_face_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_open_shell;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY open_shell


/////////	 ENTITY oriented_open_shell

EntityDescriptor *config_control_designe_oriented_open_shell =0;
AttrDescriptor *a_165open_shell_element =0;
AttrDescriptor *a_166orientation =0;
Derived_attribute *a_167Dconnected_face_set_cfs_faces =0;
SdaiOriented_open_shell::SdaiOriented_open_shell( )
{

	/*  parent: SdaiOpen_shell  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_open_shell;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_165open_shell_element, (SCLP23(Application_instance_ptr) *) &_open_shell_element);
#else
    STEPattribute *a = new STEPattribute(*a_165open_shell_element, (SCLP23(Application_instance_ptr) *) &_open_shell_element);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_166orientation,  &_orientation);
#else
    a = new STEPattribute(*a_166orientation,  &_orientation);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("cfs_faces");
}
SdaiOriented_open_shell::SdaiOriented_open_shell (SdaiOriented_open_shell& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOriented_open_shell::~SdaiOriented_open_shell () {  }

#ifdef __OSTORE__

void
SdaiOriented_open_shell::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOriented_open_shell: virtual access function." << endl;
    SdaiOriented_open_shell_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOriented_open_shell_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOriented_open_shell: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOriented_open_shell *ent = (SdaiOriented_open_shell *)sent;
//    SdaiOriented_open_shell *ent = (SdaiOriented_open_shell *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_oriented_open_shell;
    ent->attributes[2].aDesc = a_165open_shell_element;
    if(ent->_open_shell_element == 0)
        ent->_open_shell_element = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_166orientation;
}

SCLP23(Application_instance_ptr)
create_SdaiOriented_open_shell(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOriented_open_shell::get_os_typespec())
                                   SdaiOriented_open_shell;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOriented_open_shell::get_os_typespec())
//                                   SdaiOriented_open_shell;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOriented_open_shell;
}
#endif

#ifdef __O3DB__
void
SdaiOriented_open_shell::oodb_reInit ()
{	eDesc = config_control_designe_oriented_open_shell;
	attributes [2].aDesc = a_165open_shell_element;
	attributes [3].aDesc = a_166orientation;
}
#endif

SdaiOriented_open_shell::SdaiOriented_open_shell (SCLP23(Application_instance) *se, int *addAttrs) : SdaiOpen_shell(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiOpen_shell  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_open_shell;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_165open_shell_element, (SCLP23(Application_instance_ptr) *) &_open_shell_element);
#else
    STEPattribute *a = new STEPattribute(*a_165open_shell_element, (SCLP23(Application_instance_ptr) *) &_open_shell_element);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_166orientation,  &_orientation);
#else
    a = new STEPattribute(*a_166orientation,  &_orientation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("cfs_faces");
}

const SdaiOpen_shell_ptr
SdaiOriented_open_shell::open_shell_element_() const
{
    return (SdaiOpen_shell_ptr) _open_shell_element;
}

void
SdaiOriented_open_shell::open_shell_element_ (const SdaiOpen_shell_ptr x)

{
    _open_shell_element = x;
}

const SCLBOOL(Bool)
SdaiOriented_open_shell::orientation_() const
{
    return (SCLBOOL(Bool)) _orientation;
}

void
SdaiOriented_open_shell::orientation_ (const SCLBOOL(Bool) x)

{
    _orientation.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY oriented_open_shell


/////////	 ENTITY solid_angle_unit

EntityDescriptor *config_control_designe_solid_angle_unit =0;
SdaiSolid_angle_unit::SdaiSolid_angle_unit( )
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_angle_unit;
}
SdaiSolid_angle_unit::SdaiSolid_angle_unit (SdaiSolid_angle_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSolid_angle_unit::~SdaiSolid_angle_unit () {  }

#ifdef __OSTORE__

void
SdaiSolid_angle_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSolid_angle_unit: virtual access function." << endl;
    SdaiSolid_angle_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSolid_angle_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSolid_angle_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSolid_angle_unit *ent = (SdaiSolid_angle_unit *)sent;
//    SdaiSolid_angle_unit *ent = (SdaiSolid_angle_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_solid_angle_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiSolid_angle_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSolid_angle_unit::get_os_typespec())
                                   SdaiSolid_angle_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSolid_angle_unit::get_os_typespec())
//                                   SdaiSolid_angle_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSolid_angle_unit;
}
#endif

#ifdef __O3DB__
void
SdaiSolid_angle_unit::oodb_reInit ()
{	eDesc = config_control_designe_solid_angle_unit;
}
#endif

SdaiSolid_angle_unit::SdaiSolid_angle_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiNamed_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_angle_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY solid_angle_unit


/////////	 ENTITY coordinated_universal_time_offset

EntityDescriptor *config_control_designe_coordinated_universal_time_offset =0;
AttrDescriptor *a_168hour_offset =0;
AttrDescriptor *a_169minute_offset =0;
AttrDescriptor *a_170sense =0;
SdaiCoordinated_universal_time_offset::SdaiCoordinated_universal_time_offset( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_coordinated_universal_time_offset;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_168hour_offset,  &_hour_offset);
#else
    STEPattribute *a = new STEPattribute(*a_168hour_offset,  &_hour_offset);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_169minute_offset,  &_minute_offset);
#else
    a = new STEPattribute(*a_169minute_offset,  &_minute_offset);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_170sense,  &_sense);
#else
    a = new STEPattribute(*a_170sense,  &_sense);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCoordinated_universal_time_offset::SdaiCoordinated_universal_time_offset (SdaiCoordinated_universal_time_offset& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCoordinated_universal_time_offset::~SdaiCoordinated_universal_time_offset () {  }

#ifdef __OSTORE__

void
SdaiCoordinated_universal_time_offset::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCoordinated_universal_time_offset: virtual access function." << endl;
    SdaiCoordinated_universal_time_offset_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCoordinated_universal_time_offset_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCoordinated_universal_time_offset: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCoordinated_universal_time_offset *ent = (SdaiCoordinated_universal_time_offset *)sent;
//    SdaiCoordinated_universal_time_offset *ent = (SdaiCoordinated_universal_time_offset *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_coordinated_universal_time_offset;
    ent->attributes[0].aDesc = a_168hour_offset;
    ent->attributes[1].aDesc = a_169minute_offset;
    ent->attributes[2].aDesc = a_170sense;
}

SCLP23(Application_instance_ptr)
create_SdaiCoordinated_universal_time_offset(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCoordinated_universal_time_offset::get_os_typespec())
                                   SdaiCoordinated_universal_time_offset;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCoordinated_universal_time_offset::get_os_typespec())
//                                   SdaiCoordinated_universal_time_offset;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCoordinated_universal_time_offset;
}
#endif

#ifdef __O3DB__
void
SdaiCoordinated_universal_time_offset::oodb_reInit ()
{	eDesc = config_control_designe_coordinated_universal_time_offset;
	attributes [0].aDesc = a_168hour_offset;
	attributes [1].aDesc = a_169minute_offset;
	attributes [2].aDesc = a_170sense;
}
#endif

SdaiCoordinated_universal_time_offset::SdaiCoordinated_universal_time_offset( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_coordinated_universal_time_offset;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_168hour_offset,  &_hour_offset);
#else
    STEPattribute *a = new STEPattribute(*a_168hour_offset,  &_hour_offset);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_169minute_offset,  &_minute_offset);
#else
    a = new STEPattribute(*a_169minute_offset,  &_minute_offset);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_170sense,  &_sense);
#else
    a = new STEPattribute(*a_170sense,  &_sense);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiHour_in_day
SdaiCoordinated_universal_time_offset::hour_offset_() const
{
    return (const SdaiHour_in_day) _hour_offset;
}

void
SdaiCoordinated_universal_time_offset::hour_offset_ (const SdaiHour_in_day x)

{
    _hour_offset = x;
}

const SdaiMinute_in_hour
SdaiCoordinated_universal_time_offset::minute_offset_() const
{
    return (const SdaiMinute_in_hour) _minute_offset;
}

void
SdaiCoordinated_universal_time_offset::minute_offset_ (const SdaiMinute_in_hour x)

{
    _minute_offset = x;
}

const SdaiAhead_or_behind_var
SdaiCoordinated_universal_time_offset::sense_() const
{
    return (Ahead_or_behind) _sense;
}

void
SdaiCoordinated_universal_time_offset::sense_ (const SdaiAhead_or_behind_var x)

{
    _sense.put (x);
}

/////////	 END_ENTITY coordinated_universal_time_offset


/////////	 ENTITY curve_replica

EntityDescriptor *config_control_designe_curve_replica =0;
AttrDescriptor *a_171parent_curve =0;
AttrDescriptor *a_172transformation =0;
SdaiCurve_replica::SdaiCurve_replica( )
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve_replica;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_171parent_curve, (SCLP23(Application_instance_ptr) *) &_parent_curve);
#else
    STEPattribute *a = new STEPattribute(*a_171parent_curve, (SCLP23(Application_instance_ptr) *) &_parent_curve);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_172transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#else
    a = new STEPattribute(*a_172transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiCurve_replica::SdaiCurve_replica (SdaiCurve_replica& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCurve_replica::~SdaiCurve_replica () {  }

#ifdef __OSTORE__

void
SdaiCurve_replica::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCurve_replica: virtual access function." << endl;
    SdaiCurve_replica_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCurve_replica_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCurve_replica: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCurve_replica *ent = (SdaiCurve_replica *)sent;
//    SdaiCurve_replica *ent = (SdaiCurve_replica *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_curve_replica;
    ent->attributes[1].aDesc = a_171parent_curve;
    if(ent->_parent_curve == 0)
        ent->_parent_curve = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_172transformation;
    if(ent->_transformation == 0)
        ent->_transformation = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiCurve_replica(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCurve_replica::get_os_typespec())
                                   SdaiCurve_replica;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCurve_replica::get_os_typespec())
//                                   SdaiCurve_replica;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCurve_replica;
}
#endif

#ifdef __O3DB__
void
SdaiCurve_replica::oodb_reInit ()
{	eDesc = config_control_designe_curve_replica;
	attributes [1].aDesc = a_171parent_curve;
	attributes [2].aDesc = a_172transformation;
}
#endif

SdaiCurve_replica::SdaiCurve_replica (SCLP23(Application_instance) *se, int *addAttrs) : SdaiCurve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve_replica;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_171parent_curve, (SCLP23(Application_instance_ptr) *) &_parent_curve);
#else
    STEPattribute *a = new STEPattribute(*a_171parent_curve, (SCLP23(Application_instance_ptr) *) &_parent_curve);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_172transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#else
    a = new STEPattribute(*a_172transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiCurve_ptr
SdaiCurve_replica::parent_curve_() const
{
    return (SdaiCurve_ptr) _parent_curve;
}

void
SdaiCurve_replica::parent_curve_ (const SdaiCurve_ptr x)

{
    _parent_curve = x;
}

const SdaiCartesian_transformation_operator_ptr
SdaiCurve_replica::transformation_() const
{
    return (SdaiCartesian_transformation_operator_ptr) _transformation;
}

void
SdaiCurve_replica::transformation_ (const SdaiCartesian_transformation_operator_ptr x)

{
    _transformation = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY curve_replica


/////////	 ENTITY quasi_uniform_surface

EntityDescriptor *config_control_designe_quasi_uniform_surface =0;
SdaiQuasi_uniform_surface::SdaiQuasi_uniform_surface( )
{

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quasi_uniform_surface;
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
}
SdaiQuasi_uniform_surface::SdaiQuasi_uniform_surface (SdaiQuasi_uniform_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiQuasi_uniform_surface::~SdaiQuasi_uniform_surface () {  }

#ifdef __OSTORE__

void
SdaiQuasi_uniform_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiQuasi_uniform_surface: virtual access function." << endl;
    SdaiQuasi_uniform_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiQuasi_uniform_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiQuasi_uniform_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiQuasi_uniform_surface *ent = (SdaiQuasi_uniform_surface *)sent;
//    SdaiQuasi_uniform_surface *ent = (SdaiQuasi_uniform_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_quasi_uniform_surface;
}

SCLP23(Application_instance_ptr)
create_SdaiQuasi_uniform_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiQuasi_uniform_surface::get_os_typespec())
                                   SdaiQuasi_uniform_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiQuasi_uniform_surface::get_os_typespec())
//                                   SdaiQuasi_uniform_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiQuasi_uniform_surface;
}
#endif

#ifdef __O3DB__
void
SdaiQuasi_uniform_surface::oodb_reInit ()
{	eDesc = config_control_designe_quasi_uniform_surface;
}
#endif

SdaiQuasi_uniform_surface::SdaiQuasi_uniform_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiB_spline_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quasi_uniform_surface;
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY quasi_uniform_surface


/////////	 ENTITY surface_curve

EntityDescriptor *config_control_designe_surface_curve =0;
AttrDescriptor *a_173curve_3d =0;
AttrDescriptor *a_174associated_geometry =0;
AttrDescriptor *a_175master_representation =0;
Derived_attribute *a_176Dbasis_surface =0;
SdaiSurface_curve::SdaiSurface_curve( )
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_173curve_3d, (SCLP23(Application_instance_ptr) *) &_curve_3d);
#else
    STEPattribute *a = new STEPattribute(*a_173curve_3d, (SCLP23(Application_instance_ptr) *) &_curve_3d);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_174associated_geometry,  &_associated_geometry);
#else
    a = new STEPattribute(*a_174associated_geometry,  &_associated_geometry);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_175master_representation,  &_master_representation);
#else
    a = new STEPattribute(*a_175master_representation,  &_master_representation);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("basis_surface");
}
SdaiSurface_curve::SdaiSurface_curve (SdaiSurface_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSurface_curve::~SdaiSurface_curve () {  }

#ifdef __OSTORE__

void
SdaiSurface_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface_curve: virtual access function." << endl;
    SdaiSurface_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSurface_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSurface_curve *ent = (SdaiSurface_curve *)sent;
//    SdaiSurface_curve *ent = (SdaiSurface_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_surface_curve;
    ent->attributes[1].aDesc = a_173curve_3d;
    if(ent->_curve_3d == 0)
        ent->_curve_3d = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_174associated_geometry;
    ent->attributes[3].aDesc = a_175master_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiSurface_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSurface_curve::get_os_typespec())
                                   SdaiSurface_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSurface_curve::get_os_typespec())
//                                   SdaiSurface_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSurface_curve;
}
#endif

#ifdef __O3DB__
void
SdaiSurface_curve::oodb_reInit ()
{	eDesc = config_control_designe_surface_curve;
	attributes [1].aDesc = a_173curve_3d;
	attributes [2].aDesc = a_174associated_geometry;
	attributes [3].aDesc = a_175master_representation;
}
#endif

SdaiSurface_curve::SdaiSurface_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiCurve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_173curve_3d, (SCLP23(Application_instance_ptr) *) &_curve_3d);
#else
    STEPattribute *a = new STEPattribute(*a_173curve_3d, (SCLP23(Application_instance_ptr) *) &_curve_3d);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_174associated_geometry,  &_associated_geometry);
#else
    a = new STEPattribute(*a_174associated_geometry,  &_associated_geometry);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_175master_representation,  &_master_representation);
#else
    a = new STEPattribute(*a_175master_representation,  &_master_representation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("basis_surface");
}

const SdaiCurve_ptr
SdaiSurface_curve::curve_3d_() const
{
    return (SdaiCurve_ptr) _curve_3d;
}

void
SdaiSurface_curve::curve_3d_ (const SdaiCurve_ptr x)

{
    _curve_3d = x;
}

const SdaiPcurve_or_surfaces_ptr
SdaiSurface_curve::associated_geometry_() const
{
    return (SdaiPcurve_or_surfaces_ptr) &_associated_geometry;
}

void
SdaiSurface_curve::associated_geometry_ (const SdaiPcurve_or_surfaces_ptr x)

	{ _associated_geometry.ShallowCopy (*x); }

const SdaiPreferred_surface_curve_representation_var
SdaiSurface_curve::master_representation_() const
{
    return (Preferred_surface_curve_representation) _master_representation;
}

void
SdaiSurface_curve::master_representation_ (const SdaiPreferred_surface_curve_representation_var x)

{
    _master_representation.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY surface_curve


/////////	 ENTITY action_request_status

EntityDescriptor *config_control_designe_action_request_status =0;
AttrDescriptor *a_177status =0;
AttrDescriptor *a_178assigned_request =0;
SdaiAction_request_status::SdaiAction_request_status( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_status;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_177status,  &_status);
#else
    STEPattribute *a = new STEPattribute(*a_177status,  &_status);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_178assigned_request, (SCLP23(Application_instance_ptr) *) &_assigned_request);
#else
    a = new STEPattribute(*a_178assigned_request, (SCLP23(Application_instance_ptr) *) &_assigned_request);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_request_status::SdaiAction_request_status (SdaiAction_request_status& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAction_request_status::~SdaiAction_request_status () {  }

#ifdef __OSTORE__

void
SdaiAction_request_status::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_request_status: virtual access function." << endl;
    SdaiAction_request_status_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAction_request_status_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_request_status: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAction_request_status *ent = (SdaiAction_request_status *)sent;
//    SdaiAction_request_status *ent = (SdaiAction_request_status *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_action_request_status;
    ent->attributes[0].aDesc = a_177status;
    ent->attributes[1].aDesc = a_178assigned_request;
    if(ent->_assigned_request == 0)
        ent->_assigned_request = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiAction_request_status(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAction_request_status::get_os_typespec())
                                   SdaiAction_request_status;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAction_request_status::get_os_typespec())
//                                   SdaiAction_request_status;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAction_request_status;
}
#endif

#ifdef __O3DB__
void
SdaiAction_request_status::oodb_reInit ()
{	eDesc = config_control_designe_action_request_status;
	attributes [0].aDesc = a_177status;
	attributes [1].aDesc = a_178assigned_request;
}
#endif

SdaiAction_request_status::SdaiAction_request_status( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_status;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_177status,  &_status);
#else
    STEPattribute *a = new STEPattribute(*a_177status,  &_status);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_178assigned_request, (SCLP23(Application_instance_ptr) *) &_assigned_request);
#else
    a = new STEPattribute(*a_178assigned_request, (SCLP23(Application_instance_ptr) *) &_assigned_request);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiAction_request_status::status_() const
{
    return (const SdaiLabel) _status;
}

void
SdaiAction_request_status::status_ (const SdaiLabel x)

{
    _status = x;
}

const SdaiVersioned_action_request_ptr
SdaiAction_request_status::assigned_request_() const
{
    return (SdaiVersioned_action_request_ptr) _assigned_request;
}

void
SdaiAction_request_status::assigned_request_ (const SdaiVersioned_action_request_ptr x)

{
    _assigned_request = x;
}

/////////	 END_ENTITY action_request_status


/////////	 ENTITY founded_item

EntityDescriptor *config_control_designe_founded_item =0;
SdaiFounded_item::SdaiFounded_item( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_founded_item;
}
SdaiFounded_item::SdaiFounded_item (SdaiFounded_item& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiFounded_item::~SdaiFounded_item () {  }

#ifdef __OSTORE__

void
SdaiFounded_item::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFounded_item: virtual access function." << endl;
    SdaiFounded_item_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiFounded_item_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFounded_item: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiFounded_item *ent = (SdaiFounded_item *)sent;
//    SdaiFounded_item *ent = (SdaiFounded_item *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_founded_item;
}

SCLP23(Application_instance_ptr)
create_SdaiFounded_item(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiFounded_item::get_os_typespec())
                                   SdaiFounded_item;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiFounded_item::get_os_typespec())
//                                   SdaiFounded_item;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiFounded_item;
}
#endif

#ifdef __O3DB__
void
SdaiFounded_item::oodb_reInit ()
{	eDesc = config_control_designe_founded_item;
}
#endif

SdaiFounded_item::SdaiFounded_item( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_founded_item;
}

/////////	 END_ENTITY founded_item


/////////	 ENTITY composite_curve_segment

EntityDescriptor *config_control_designe_composite_curve_segment =0;
AttrDescriptor *a_179transition =0;
AttrDescriptor *a_180same_sense =0;
AttrDescriptor *a_181parent_curve =0;
Inverse_attribute *a_182Iusing_curves =0;
SdaiComposite_curve_segment::SdaiComposite_curve_segment( )
{

	/*  parent: SdaiFounded_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_composite_curve_segment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_179transition,  &_transition);
#else
    STEPattribute *a = new STEPattribute(*a_179transition,  &_transition);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_180same_sense,  &_same_sense);
#else
    a = new STEPattribute(*a_180same_sense,  &_same_sense);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_181parent_curve, (SCLP23(Application_instance_ptr) *) &_parent_curve);
#else
    a = new STEPattribute(*a_181parent_curve, (SCLP23(Application_instance_ptr) *) &_parent_curve);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiComposite_curve_segment::SdaiComposite_curve_segment (SdaiComposite_curve_segment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiComposite_curve_segment::~SdaiComposite_curve_segment () {  }

#ifdef __OSTORE__

void
SdaiComposite_curve_segment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiComposite_curve_segment: virtual access function." << endl;
    SdaiComposite_curve_segment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiComposite_curve_segment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiComposite_curve_segment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiComposite_curve_segment *ent = (SdaiComposite_curve_segment *)sent;
//    SdaiComposite_curve_segment *ent = (SdaiComposite_curve_segment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_composite_curve_segment;
    ent->attributes[0].aDesc = a_179transition;
    ent->attributes[1].aDesc = a_180same_sense;
    ent->attributes[2].aDesc = a_181parent_curve;
    if(ent->_parent_curve == 0)
        ent->_parent_curve = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiComposite_curve_segment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiComposite_curve_segment::get_os_typespec())
                                   SdaiComposite_curve_segment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiComposite_curve_segment::get_os_typespec())
//                                   SdaiComposite_curve_segment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiComposite_curve_segment;
}
#endif

#ifdef __O3DB__
void
SdaiComposite_curve_segment::oodb_reInit ()
{	eDesc = config_control_designe_composite_curve_segment;
	attributes [0].aDesc = a_179transition;
	attributes [1].aDesc = a_180same_sense;
	attributes [2].aDesc = a_181parent_curve;
}
#endif

SdaiComposite_curve_segment::SdaiComposite_curve_segment (SCLP23(Application_instance) *se, int *addAttrs) : SdaiFounded_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiFounded_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_composite_curve_segment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_179transition,  &_transition);
#else
    STEPattribute *a = new STEPattribute(*a_179transition,  &_transition);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_180same_sense,  &_same_sense);
#else
    a = new STEPattribute(*a_180same_sense,  &_same_sense);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_181parent_curve, (SCLP23(Application_instance_ptr) *) &_parent_curve);
#else
    a = new STEPattribute(*a_181parent_curve, (SCLP23(Application_instance_ptr) *) &_parent_curve);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiTransition_code_var
SdaiComposite_curve_segment::transition_() const
{
    return (Transition_code) _transition;
}

void
SdaiComposite_curve_segment::transition_ (const SdaiTransition_code_var x)

{
    _transition.put (x);
}

const SCLBOOL(Bool)
SdaiComposite_curve_segment::same_sense_() const
{
    return (SCLBOOL(Bool)) _same_sense;
}

void
SdaiComposite_curve_segment::same_sense_ (const SCLBOOL(Bool) x)

{
    _same_sense.put (x);
}

const SdaiCurve_ptr
SdaiComposite_curve_segment::parent_curve_() const
{
    return (SdaiCurve_ptr) _parent_curve;
}

void
SdaiComposite_curve_segment::parent_curve_ (const SdaiCurve_ptr x)

{
    _parent_curve = x;
}

const EntityAggregate_ptr
SdaiComposite_curve_segment::using_curves_() const
{
    return (EntityAggregate_ptr) &_using_curves;
}

void
SdaiComposite_curve_segment::using_curves_ (const EntityAggregate_ptr x)

	{ _using_curves.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY composite_curve_segment


/////////	 ENTITY reparametrised_composite_curve_segment

EntityDescriptor *config_control_designe_reparametrised_composite_curve_segment =0;
AttrDescriptor *a_183param_length =0;
SdaiReparametrised_composite_curve_segment::SdaiReparametrised_composite_curve_segment( )
{

	/*  parent: SdaiComposite_curve_segment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_reparametrised_composite_curve_segment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_183param_length,  &_param_length);
#else
    STEPattribute *a = new STEPattribute(*a_183param_length,  &_param_length);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiReparametrised_composite_curve_segment::SdaiReparametrised_composite_curve_segment (SdaiReparametrised_composite_curve_segment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiReparametrised_composite_curve_segment::~SdaiReparametrised_composite_curve_segment () {  }

#ifdef __OSTORE__

void
SdaiReparametrised_composite_curve_segment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiReparametrised_composite_curve_segment: virtual access function." << endl;
    SdaiReparametrised_composite_curve_segment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiReparametrised_composite_curve_segment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiReparametrised_composite_curve_segment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiReparametrised_composite_curve_segment *ent = (SdaiReparametrised_composite_curve_segment *)sent;
//    SdaiReparametrised_composite_curve_segment *ent = (SdaiReparametrised_composite_curve_segment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_reparametrised_composite_curve_segment;
    ent->attributes[3].aDesc = a_183param_length;
}

SCLP23(Application_instance_ptr)
create_SdaiReparametrised_composite_curve_segment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiReparametrised_composite_curve_segment::get_os_typespec())
                                   SdaiReparametrised_composite_curve_segment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiReparametrised_composite_curve_segment::get_os_typespec())
//                                   SdaiReparametrised_composite_curve_segment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiReparametrised_composite_curve_segment;
}
#endif

#ifdef __O3DB__
void
SdaiReparametrised_composite_curve_segment::oodb_reInit ()
{	eDesc = config_control_designe_reparametrised_composite_curve_segment;
	attributes [3].aDesc = a_183param_length;
}
#endif

SdaiReparametrised_composite_curve_segment::SdaiReparametrised_composite_curve_segment (SCLP23(Application_instance) *se, int *addAttrs) : SdaiComposite_curve_segment(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiComposite_curve_segment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_reparametrised_composite_curve_segment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_183param_length,  &_param_length);
#else
    STEPattribute *a = new STEPattribute(*a_183param_length,  &_param_length);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiParameter_value
SdaiReparametrised_composite_curve_segment::param_length_() const
{
    return (const SdaiParameter_value) _param_length;
}

void
SdaiReparametrised_composite_curve_segment::param_length_ (const SdaiParameter_value x)

{
    _param_length = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY reparametrised_composite_curve_segment


/////////	 ENTITY representation_relationship

EntityDescriptor *config_control_designe_representation_relationship =0;
AttrDescriptor *a_184name =0;
AttrDescriptor *a_185description =0;
AttrDescriptor *a_186rep_1 =0;
AttrDescriptor *a_187rep_2 =0;
SdaiRepresentation_relationship::SdaiRepresentation_relationship( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_184name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_184name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_185description,  &_description);
#else
    a = new STEPattribute(*a_185description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_186rep_1, (SCLP23(Application_instance_ptr) *) &_rep_1);
#else
    a = new STEPattribute(*a_186rep_1, (SCLP23(Application_instance_ptr) *) &_rep_1);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_187rep_2, (SCLP23(Application_instance_ptr) *) &_rep_2);
#else
    a = new STEPattribute(*a_187rep_2, (SCLP23(Application_instance_ptr) *) &_rep_2);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiRepresentation_relationship::SdaiRepresentation_relationship (SdaiRepresentation_relationship& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiRepresentation_relationship::~SdaiRepresentation_relationship () {  }

#ifdef __OSTORE__

void
SdaiRepresentation_relationship::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation_relationship: virtual access function." << endl;
    SdaiRepresentation_relationship_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiRepresentation_relationship_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation_relationship: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiRepresentation_relationship *ent = (SdaiRepresentation_relationship *)sent;
//    SdaiRepresentation_relationship *ent = (SdaiRepresentation_relationship *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_representation_relationship;
    ent->attributes[0].aDesc = a_184name;
    ent->attributes[1].aDesc = a_185description;
    ent->attributes[2].aDesc = a_186rep_1;
    if(ent->_rep_1 == 0)
        ent->_rep_1 = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_187rep_2;
    if(ent->_rep_2 == 0)
        ent->_rep_2 = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiRepresentation_relationship(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiRepresentation_relationship::get_os_typespec())
                                   SdaiRepresentation_relationship;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiRepresentation_relationship::get_os_typespec())
//                                   SdaiRepresentation_relationship;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiRepresentation_relationship;
}
#endif

#ifdef __O3DB__
void
SdaiRepresentation_relationship::oodb_reInit ()
{	eDesc = config_control_designe_representation_relationship;
	attributes [0].aDesc = a_184name;
	attributes [1].aDesc = a_185description;
	attributes [2].aDesc = a_186rep_1;
	attributes [3].aDesc = a_187rep_2;
}
#endif

SdaiRepresentation_relationship::SdaiRepresentation_relationship( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_184name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_184name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_185description,  &_description);
#else
    a = new STEPattribute(*a_185description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_186rep_1, (SCLP23(Application_instance_ptr) *) &_rep_1);
#else
    a = new STEPattribute(*a_186rep_1, (SCLP23(Application_instance_ptr) *) &_rep_1);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_187rep_2, (SCLP23(Application_instance_ptr) *) &_rep_2);
#else
    a = new STEPattribute(*a_187rep_2, (SCLP23(Application_instance_ptr) *) &_rep_2);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiRepresentation_relationship::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiRepresentation_relationship::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiRepresentation_relationship::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiRepresentation_relationship::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiRepresentation_ptr
SdaiRepresentation_relationship::rep_1_() const
{
    return (SdaiRepresentation_ptr) _rep_1;
}

void
SdaiRepresentation_relationship::rep_1_ (const SdaiRepresentation_ptr x)

{
    _rep_1 = x;
}

const SdaiRepresentation_ptr
SdaiRepresentation_relationship::rep_2_() const
{
    return (SdaiRepresentation_ptr) _rep_2;
}

void
SdaiRepresentation_relationship::rep_2_ (const SdaiRepresentation_ptr x)

{
    _rep_2 = x;
}

/////////	 END_ENTITY representation_relationship


/////////	 ENTITY representation_relationship_with_transformation

EntityDescriptor *config_control_designe_representation_relationship_with_transformation =0;
AttrDescriptor *a_188transformation_operator =0;
SdaiRepresentation_relationship_with_transformation::SdaiRepresentation_relationship_with_transformation( )
{

	/*  parent: SdaiRepresentation_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_representation_relationship_with_transformation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_188transformation_operator,  &_transformation_operator);
#else
    STEPattribute *a = new STEPattribute(*a_188transformation_operator,  &_transformation_operator);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiRepresentation_relationship_with_transformation::SdaiRepresentation_relationship_with_transformation (SdaiRepresentation_relationship_with_transformation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiRepresentation_relationship_with_transformation::~SdaiRepresentation_relationship_with_transformation () {  }

#ifdef __OSTORE__

void
SdaiRepresentation_relationship_with_transformation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation_relationship_with_transformation: virtual access function." << endl;
    SdaiRepresentation_relationship_with_transformation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiRepresentation_relationship_with_transformation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation_relationship_with_transformation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiRepresentation_relationship_with_transformation *ent = (SdaiRepresentation_relationship_with_transformation *)sent;
//    SdaiRepresentation_relationship_with_transformation *ent = (SdaiRepresentation_relationship_with_transformation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_representation_relationship_with_transformation;
    ent->attributes[4].aDesc = a_188transformation_operator;
}

SCLP23(Application_instance_ptr)
create_SdaiRepresentation_relationship_with_transformation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiRepresentation_relationship_with_transformation::get_os_typespec())
                                   SdaiRepresentation_relationship_with_transformation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiRepresentation_relationship_with_transformation::get_os_typespec())
//                                   SdaiRepresentation_relationship_with_transformation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiRepresentation_relationship_with_transformation;
}
#endif

#ifdef __O3DB__
void
SdaiRepresentation_relationship_with_transformation::oodb_reInit ()
{	eDesc = config_control_designe_representation_relationship_with_transformation;
	attributes [4].aDesc = a_188transformation_operator;
}
#endif

SdaiRepresentation_relationship_with_transformation::SdaiRepresentation_relationship_with_transformation (SCLP23(Application_instance) *se, int *addAttrs) : SdaiRepresentation_relationship(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiRepresentation_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_representation_relationship_with_transformation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_188transformation_operator,  &_transformation_operator);
#else
    STEPattribute *a = new STEPattribute(*a_188transformation_operator,  &_transformation_operator);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiTransformation_ptr
SdaiRepresentation_relationship_with_transformation::transformation_operator_() const
	{ return (const SdaiTransformation_ptr) &_transformation_operator; }

void
SdaiRepresentation_relationship_with_transformation::transformation_operator_ (const SdaiTransformation_ptr x)

	{ _transformation_operator = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY representation_relationship_with_transformation


/////////	 ENTITY person_and_organization_role

EntityDescriptor *config_control_designe_person_and_organization_role =0;
AttrDescriptor *a_189name =0;
SdaiPerson_and_organization_role::SdaiPerson_and_organization_role( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization_role;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_189name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_189name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiPerson_and_organization_role::SdaiPerson_and_organization_role (SdaiPerson_and_organization_role& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPerson_and_organization_role::~SdaiPerson_and_organization_role () {  }

#ifdef __OSTORE__

void
SdaiPerson_and_organization_role::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPerson_and_organization_role: virtual access function." << endl;
    SdaiPerson_and_organization_role_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPerson_and_organization_role_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPerson_and_organization_role: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPerson_and_organization_role *ent = (SdaiPerson_and_organization_role *)sent;
//    SdaiPerson_and_organization_role *ent = (SdaiPerson_and_organization_role *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_person_and_organization_role;
    ent->attributes[0].aDesc = a_189name;
}

SCLP23(Application_instance_ptr)
create_SdaiPerson_and_organization_role(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPerson_and_organization_role::get_os_typespec())
                                   SdaiPerson_and_organization_role;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPerson_and_organization_role::get_os_typespec())
//                                   SdaiPerson_and_organization_role;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPerson_and_organization_role;
}
#endif

#ifdef __O3DB__
void
SdaiPerson_and_organization_role::oodb_reInit ()
{	eDesc = config_control_designe_person_and_organization_role;
	attributes [0].aDesc = a_189name;
}
#endif

SdaiPerson_and_organization_role::SdaiPerson_and_organization_role( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization_role;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_189name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_189name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiPerson_and_organization_role::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiPerson_and_organization_role::name_ (const SdaiLabel x)

{
    _name = x;
}

/////////	 END_ENTITY person_and_organization_role


/////////	 ENTITY quasi_uniform_curve

EntityDescriptor *config_control_designe_quasi_uniform_curve =0;
SdaiQuasi_uniform_curve::SdaiQuasi_uniform_curve( )
{

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quasi_uniform_curve;
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
}
SdaiQuasi_uniform_curve::SdaiQuasi_uniform_curve (SdaiQuasi_uniform_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiQuasi_uniform_curve::~SdaiQuasi_uniform_curve () {  }

#ifdef __OSTORE__

void
SdaiQuasi_uniform_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiQuasi_uniform_curve: virtual access function." << endl;
    SdaiQuasi_uniform_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiQuasi_uniform_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiQuasi_uniform_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiQuasi_uniform_curve *ent = (SdaiQuasi_uniform_curve *)sent;
//    SdaiQuasi_uniform_curve *ent = (SdaiQuasi_uniform_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_quasi_uniform_curve;
}

SCLP23(Application_instance_ptr)
create_SdaiQuasi_uniform_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiQuasi_uniform_curve::get_os_typespec())
                                   SdaiQuasi_uniform_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiQuasi_uniform_curve::get_os_typespec())
//                                   SdaiQuasi_uniform_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiQuasi_uniform_curve;
}
#endif

#ifdef __O3DB__
void
SdaiQuasi_uniform_curve::oodb_reInit ()
{	eDesc = config_control_designe_quasi_uniform_curve;
}
#endif

SdaiQuasi_uniform_curve::SdaiQuasi_uniform_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiB_spline_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quasi_uniform_curve;
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY quasi_uniform_curve


/////////	 ENTITY swept_surface

EntityDescriptor *config_control_designe_swept_surface =0;
AttrDescriptor *a_190swept_curve =0;
SdaiSwept_surface::SdaiSwept_surface( )
{

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_swept_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_190swept_curve, (SCLP23(Application_instance_ptr) *) &_swept_curve);
#else
    STEPattribute *a = new STEPattribute(*a_190swept_curve, (SCLP23(Application_instance_ptr) *) &_swept_curve);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiSwept_surface::SdaiSwept_surface (SdaiSwept_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSwept_surface::~SdaiSwept_surface () {  }

#ifdef __OSTORE__

void
SdaiSwept_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSwept_surface: virtual access function." << endl;
    SdaiSwept_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSwept_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSwept_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSwept_surface *ent = (SdaiSwept_surface *)sent;
//    SdaiSwept_surface *ent = (SdaiSwept_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_swept_surface;
    ent->attributes[1].aDesc = a_190swept_curve;
    if(ent->_swept_curve == 0)
        ent->_swept_curve = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiSwept_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSwept_surface::get_os_typespec())
                                   SdaiSwept_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSwept_surface::get_os_typespec())
//                                   SdaiSwept_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSwept_surface;
}
#endif

#ifdef __O3DB__
void
SdaiSwept_surface::oodb_reInit ()
{	eDesc = config_control_designe_swept_surface;
	attributes [1].aDesc = a_190swept_curve;
}
#endif

SdaiSwept_surface::SdaiSwept_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSurface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_swept_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_190swept_curve, (SCLP23(Application_instance_ptr) *) &_swept_curve);
#else
    STEPattribute *a = new STEPattribute(*a_190swept_curve, (SCLP23(Application_instance_ptr) *) &_swept_curve);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiCurve_ptr
SdaiSwept_surface::swept_curve_() const
{
    return (SdaiCurve_ptr) _swept_curve;
}

void
SdaiSwept_surface::swept_curve_ (const SdaiCurve_ptr x)

{
    _swept_curve = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY swept_surface


/////////	 ENTITY property_definition

EntityDescriptor *config_control_designe_property_definition =0;
AttrDescriptor *a_191name =0;
AttrDescriptor *a_192description =0;
AttrDescriptor *a_193definition =0;
SdaiProperty_definition::SdaiProperty_definition( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_property_definition;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_191name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_191name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_192description,  &_description);
#else
    a = new STEPattribute(*a_192description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_193definition,  &_definition);
#else
    a = new STEPattribute(*a_193definition,  &_definition);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProperty_definition::SdaiProperty_definition (SdaiProperty_definition& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProperty_definition::~SdaiProperty_definition () {  }

#ifdef __OSTORE__

void
SdaiProperty_definition::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProperty_definition: virtual access function." << endl;
    SdaiProperty_definition_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProperty_definition_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProperty_definition: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProperty_definition *ent = (SdaiProperty_definition *)sent;
//    SdaiProperty_definition *ent = (SdaiProperty_definition *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_property_definition;
    ent->attributes[0].aDesc = a_191name;
    ent->attributes[1].aDesc = a_192description;
    ent->attributes[2].aDesc = a_193definition;
}

SCLP23(Application_instance_ptr)
create_SdaiProperty_definition(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProperty_definition::get_os_typespec())
                                   SdaiProperty_definition;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProperty_definition::get_os_typespec())
//                                   SdaiProperty_definition;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProperty_definition;
}
#endif

#ifdef __O3DB__
void
SdaiProperty_definition::oodb_reInit ()
{	eDesc = config_control_designe_property_definition;
	attributes [0].aDesc = a_191name;
	attributes [1].aDesc = a_192description;
	attributes [2].aDesc = a_193definition;
}
#endif

SdaiProperty_definition::SdaiProperty_definition( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_property_definition;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_191name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_191name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_192description,  &_description);
#else
    a = new STEPattribute(*a_192description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_193definition,  &_definition);
#else
    a = new STEPattribute(*a_193definition,  &_definition);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiProperty_definition::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiProperty_definition::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiProperty_definition::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiProperty_definition::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiCharacterized_definition_ptr
SdaiProperty_definition::definition_() const
	{ return (const SdaiCharacterized_definition_ptr) &_definition; }

void
SdaiProperty_definition::definition_ (const SdaiCharacterized_definition_ptr x)

	{ _definition = x; }

/////////	 END_ENTITY property_definition


/////////	 ENTITY global_uncertainty_assigned_context

EntityDescriptor *config_control_designe_global_uncertainty_assigned_context =0;
AttrDescriptor *a_194uncertainty =0;
SdaiGlobal_uncertainty_assigned_context::SdaiGlobal_uncertainty_assigned_context( )
{

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_global_uncertainty_assigned_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_194uncertainty,  &_uncertainty);
#else
    STEPattribute *a = new STEPattribute(*a_194uncertainty,  &_uncertainty);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiGlobal_uncertainty_assigned_context::SdaiGlobal_uncertainty_assigned_context (SdaiGlobal_uncertainty_assigned_context& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiGlobal_uncertainty_assigned_context::~SdaiGlobal_uncertainty_assigned_context () {  }

#ifdef __OSTORE__

void
SdaiGlobal_uncertainty_assigned_context::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGlobal_uncertainty_assigned_context: virtual access function." << endl;
    SdaiGlobal_uncertainty_assigned_context_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiGlobal_uncertainty_assigned_context_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGlobal_uncertainty_assigned_context: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiGlobal_uncertainty_assigned_context *ent = (SdaiGlobal_uncertainty_assigned_context *)sent;
//    SdaiGlobal_uncertainty_assigned_context *ent = (SdaiGlobal_uncertainty_assigned_context *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_global_uncertainty_assigned_context;
    ent->attributes[2].aDesc = a_194uncertainty;
}

SCLP23(Application_instance_ptr)
create_SdaiGlobal_uncertainty_assigned_context(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiGlobal_uncertainty_assigned_context::get_os_typespec())
                                   SdaiGlobal_uncertainty_assigned_context;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiGlobal_uncertainty_assigned_context::get_os_typespec())
//                                   SdaiGlobal_uncertainty_assigned_context;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiGlobal_uncertainty_assigned_context;
}
#endif

#ifdef __O3DB__
void
SdaiGlobal_uncertainty_assigned_context::oodb_reInit ()
{	eDesc = config_control_designe_global_uncertainty_assigned_context;
	attributes [2].aDesc = a_194uncertainty;
}
#endif

SdaiGlobal_uncertainty_assigned_context::SdaiGlobal_uncertainty_assigned_context (SCLP23(Application_instance) *se, int *addAttrs) : SdaiRepresentation_context(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_global_uncertainty_assigned_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_194uncertainty,  &_uncertainty);
#else
    STEPattribute *a = new STEPattribute(*a_194uncertainty,  &_uncertainty);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const EntityAggregate_ptr
SdaiGlobal_uncertainty_assigned_context::uncertainty_() const
{
    return (EntityAggregate_ptr) &_uncertainty;
}

void
SdaiGlobal_uncertainty_assigned_context::uncertainty_ (const EntityAggregate_ptr x)

	{ _uncertainty.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY global_uncertainty_assigned_context


/////////	 ENTITY organization_relationship

EntityDescriptor *config_control_designe_organization_relationship =0;
AttrDescriptor *a_195name =0;
AttrDescriptor *a_196description =0;
AttrDescriptor *a_197relating_organization =0;
AttrDescriptor *a_198related_organization =0;
SdaiOrganization_relationship::SdaiOrganization_relationship( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_organization_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_195name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_195name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_196description,  &_description);
#else
    a = new STEPattribute(*a_196description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_197relating_organization, (SCLP23(Application_instance_ptr) *) &_relating_organization);
#else
    a = new STEPattribute(*a_197relating_organization, (SCLP23(Application_instance_ptr) *) &_relating_organization);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_198related_organization, (SCLP23(Application_instance_ptr) *) &_related_organization);
#else
    a = new STEPattribute(*a_198related_organization, (SCLP23(Application_instance_ptr) *) &_related_organization);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiOrganization_relationship::SdaiOrganization_relationship (SdaiOrganization_relationship& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOrganization_relationship::~SdaiOrganization_relationship () {  }

#ifdef __OSTORE__

void
SdaiOrganization_relationship::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOrganization_relationship: virtual access function." << endl;
    SdaiOrganization_relationship_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOrganization_relationship_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOrganization_relationship: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOrganization_relationship *ent = (SdaiOrganization_relationship *)sent;
//    SdaiOrganization_relationship *ent = (SdaiOrganization_relationship *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_organization_relationship;
    ent->attributes[0].aDesc = a_195name;
    ent->attributes[1].aDesc = a_196description;
    ent->attributes[2].aDesc = a_197relating_organization;
    if(ent->_relating_organization == 0)
        ent->_relating_organization = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_198related_organization;
    if(ent->_related_organization == 0)
        ent->_related_organization = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiOrganization_relationship(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOrganization_relationship::get_os_typespec())
                                   SdaiOrganization_relationship;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOrganization_relationship::get_os_typespec())
//                                   SdaiOrganization_relationship;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOrganization_relationship;
}
#endif

#ifdef __O3DB__
void
SdaiOrganization_relationship::oodb_reInit ()
{	eDesc = config_control_designe_organization_relationship;
	attributes [0].aDesc = a_195name;
	attributes [1].aDesc = a_196description;
	attributes [2].aDesc = a_197relating_organization;
	attributes [3].aDesc = a_198related_organization;
}
#endif

SdaiOrganization_relationship::SdaiOrganization_relationship( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_organization_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_195name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_195name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_196description,  &_description);
#else
    a = new STEPattribute(*a_196description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_197relating_organization, (SCLP23(Application_instance_ptr) *) &_relating_organization);
#else
    a = new STEPattribute(*a_197relating_organization, (SCLP23(Application_instance_ptr) *) &_relating_organization);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_198related_organization, (SCLP23(Application_instance_ptr) *) &_related_organization);
#else
    a = new STEPattribute(*a_198related_organization, (SCLP23(Application_instance_ptr) *) &_related_organization);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiOrganization_relationship::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiOrganization_relationship::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiOrganization_relationship::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiOrganization_relationship::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiOrganization_ptr
SdaiOrganization_relationship::relating_organization_() const
{
    return (SdaiOrganization_ptr) _relating_organization;
}

void
SdaiOrganization_relationship::relating_organization_ (const SdaiOrganization_ptr x)

{
    _relating_organization = x;
}

const SdaiOrganization_ptr
SdaiOrganization_relationship::related_organization_() const
{
    return (SdaiOrganization_ptr) _related_organization;
}

void
SdaiOrganization_relationship::related_organization_ (const SdaiOrganization_ptr x)

{
    _related_organization = x;
}

/////////	 END_ENTITY organization_relationship


/////////	 ENTITY parabola

EntityDescriptor *config_control_designe_parabola =0;
AttrDescriptor *a_199focal_dist =0;
SdaiParabola::SdaiParabola( )
{

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_parabola;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_199focal_dist,  &_focal_dist);
#else
    STEPattribute *a = new STEPattribute(*a_199focal_dist,  &_focal_dist);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiParabola::SdaiParabola (SdaiParabola& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiParabola::~SdaiParabola () {  }

#ifdef __OSTORE__

void
SdaiParabola::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiParabola: virtual access function." << endl;
    SdaiParabola_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiParabola_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiParabola: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiParabola *ent = (SdaiParabola *)sent;
//    SdaiParabola *ent = (SdaiParabola *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_parabola;
    ent->attributes[2].aDesc = a_199focal_dist;
}

SCLP23(Application_instance_ptr)
create_SdaiParabola(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiParabola::get_os_typespec())
                                   SdaiParabola;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiParabola::get_os_typespec())
//                                   SdaiParabola;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiParabola;
}
#endif

#ifdef __O3DB__
void
SdaiParabola::oodb_reInit ()
{	eDesc = config_control_designe_parabola;
	attributes [2].aDesc = a_199focal_dist;
}
#endif

SdaiParabola::SdaiParabola (SCLP23(Application_instance) *se, int *addAttrs) : SdaiConic(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_parabola;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_199focal_dist,  &_focal_dist);
#else
    STEPattribute *a = new STEPattribute(*a_199focal_dist,  &_focal_dist);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiLength_measure
SdaiParabola::focal_dist_() const
{
    return (const SdaiLength_measure) _focal_dist;
}

void
SdaiParabola::focal_dist_ (const SdaiLength_measure x)

{
    _focal_dist = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY parabola


/////////	 ENTITY rectangular_composite_surface

EntityDescriptor *config_control_designe_rectangular_composite_surface =0;
AttrDescriptor *a_200segments =0;
Derived_attribute *a_201Dn_u =0;
Derived_attribute *a_202Dn_v =0;
SdaiRectangular_composite_surface::SdaiRectangular_composite_surface( )
{

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rectangular_composite_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_200segments,  &_segments);
#else
    STEPattribute *a = new STEPattribute(*a_200segments,  &_segments);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("n_u");
    MakeDerived ("n_v");
}
SdaiRectangular_composite_surface::SdaiRectangular_composite_surface (SdaiRectangular_composite_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiRectangular_composite_surface::~SdaiRectangular_composite_surface () {  }

#ifdef __OSTORE__

void
SdaiRectangular_composite_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRectangular_composite_surface: virtual access function." << endl;
    SdaiRectangular_composite_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiRectangular_composite_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRectangular_composite_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiRectangular_composite_surface *ent = (SdaiRectangular_composite_surface *)sent;
//    SdaiRectangular_composite_surface *ent = (SdaiRectangular_composite_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_rectangular_composite_surface;
    ent->attributes[1].aDesc = a_200segments;
}

SCLP23(Application_instance_ptr)
create_SdaiRectangular_composite_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiRectangular_composite_surface::get_os_typespec())
                                   SdaiRectangular_composite_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiRectangular_composite_surface::get_os_typespec())
//                                   SdaiRectangular_composite_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiRectangular_composite_surface;
}
#endif

#ifdef __O3DB__
void
SdaiRectangular_composite_surface::oodb_reInit ()
{	eDesc = config_control_designe_rectangular_composite_surface;
	attributes [1].aDesc = a_200segments;
}
#endif

SdaiRectangular_composite_surface::SdaiRectangular_composite_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiBounded_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rectangular_composite_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_200segments,  &_segments);
#else
    STEPattribute *a = new STEPattribute(*a_200segments,  &_segments);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("n_u");
    MakeDerived ("n_v");
}

const GenericAggregate_ptr
SdaiRectangular_composite_surface::segments_() const
{
    return (GenericAggregate_ptr) &_segments;
}

void
SdaiRectangular_composite_surface::segments_ (const GenericAggregate_ptr x)

	{ _segments.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY rectangular_composite_surface


/////////	 ENTITY lot_effectivity

EntityDescriptor *config_control_designe_lot_effectivity =0;
AttrDescriptor *a_203effectivity_lot_id =0;
AttrDescriptor *a_204effectivity_lot_size =0;
SdaiLot_effectivity::SdaiLot_effectivity( )
{

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_lot_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_203effectivity_lot_id,  &_effectivity_lot_id);
#else
    STEPattribute *a = new STEPattribute(*a_203effectivity_lot_id,  &_effectivity_lot_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_204effectivity_lot_size, (SCLP23(Application_instance_ptr) *) &_effectivity_lot_size);
#else
    a = new STEPattribute(*a_204effectivity_lot_size, (SCLP23(Application_instance_ptr) *) &_effectivity_lot_size);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiLot_effectivity::SdaiLot_effectivity (SdaiLot_effectivity& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiLot_effectivity::~SdaiLot_effectivity () {  }

#ifdef __OSTORE__

void
SdaiLot_effectivity::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLot_effectivity: virtual access function." << endl;
    SdaiLot_effectivity_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiLot_effectivity_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLot_effectivity: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiLot_effectivity *ent = (SdaiLot_effectivity *)sent;
//    SdaiLot_effectivity *ent = (SdaiLot_effectivity *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_lot_effectivity;
    ent->attributes[1].aDesc = a_203effectivity_lot_id;
    ent->attributes[2].aDesc = a_204effectivity_lot_size;
    if(ent->_effectivity_lot_size == 0)
        ent->_effectivity_lot_size = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiLot_effectivity(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiLot_effectivity::get_os_typespec())
                                   SdaiLot_effectivity;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiLot_effectivity::get_os_typespec())
//                                   SdaiLot_effectivity;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiLot_effectivity;
}
#endif

#ifdef __O3DB__
void
SdaiLot_effectivity::oodb_reInit ()
{	eDesc = config_control_designe_lot_effectivity;
	attributes [1].aDesc = a_203effectivity_lot_id;
	attributes [2].aDesc = a_204effectivity_lot_size;
}
#endif

SdaiLot_effectivity::SdaiLot_effectivity (SCLP23(Application_instance) *se, int *addAttrs) : SdaiEffectivity(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_lot_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_203effectivity_lot_id,  &_effectivity_lot_id);
#else
    STEPattribute *a = new STEPattribute(*a_203effectivity_lot_id,  &_effectivity_lot_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_204effectivity_lot_size, (SCLP23(Application_instance_ptr) *) &_effectivity_lot_size);
#else
    a = new STEPattribute(*a_204effectivity_lot_size, (SCLP23(Application_instance_ptr) *) &_effectivity_lot_size);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiLot_effectivity::effectivity_lot_id_() const
{
    return (const SdaiIdentifier) _effectivity_lot_id;
}

void
SdaiLot_effectivity::effectivity_lot_id_ (const SdaiIdentifier x)

{
    _effectivity_lot_id = x;
}

const SdaiMeasure_with_unit_ptr
SdaiLot_effectivity::effectivity_lot_size_() const
{
    return (SdaiMeasure_with_unit_ptr) _effectivity_lot_size;
}

void
SdaiLot_effectivity::effectivity_lot_size_ (const SdaiMeasure_with_unit_ptr x)

{
    _effectivity_lot_size = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY lot_effectivity


/////////	 ENTITY surface_of_linear_extrusion

EntityDescriptor *config_control_designe_surface_of_linear_extrusion =0;
AttrDescriptor *a_205extrusion_axis =0;
SdaiSurface_of_linear_extrusion::SdaiSurface_of_linear_extrusion( )
{

	/*  parent: SdaiSwept_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_of_linear_extrusion;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_205extrusion_axis, (SCLP23(Application_instance_ptr) *) &_extrusion_axis);
#else
    STEPattribute *a = new STEPattribute(*a_205extrusion_axis, (SCLP23(Application_instance_ptr) *) &_extrusion_axis);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiSurface_of_linear_extrusion::SdaiSurface_of_linear_extrusion (SdaiSurface_of_linear_extrusion& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSurface_of_linear_extrusion::~SdaiSurface_of_linear_extrusion () {  }

#ifdef __OSTORE__

void
SdaiSurface_of_linear_extrusion::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface_of_linear_extrusion: virtual access function." << endl;
    SdaiSurface_of_linear_extrusion_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSurface_of_linear_extrusion_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface_of_linear_extrusion: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSurface_of_linear_extrusion *ent = (SdaiSurface_of_linear_extrusion *)sent;
//    SdaiSurface_of_linear_extrusion *ent = (SdaiSurface_of_linear_extrusion *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_surface_of_linear_extrusion;
    ent->attributes[2].aDesc = a_205extrusion_axis;
    if(ent->_extrusion_axis == 0)
        ent->_extrusion_axis = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiSurface_of_linear_extrusion(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSurface_of_linear_extrusion::get_os_typespec())
                                   SdaiSurface_of_linear_extrusion;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSurface_of_linear_extrusion::get_os_typespec())
//                                   SdaiSurface_of_linear_extrusion;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSurface_of_linear_extrusion;
}
#endif

#ifdef __O3DB__
void
SdaiSurface_of_linear_extrusion::oodb_reInit ()
{	eDesc = config_control_designe_surface_of_linear_extrusion;
	attributes [2].aDesc = a_205extrusion_axis;
}
#endif

SdaiSurface_of_linear_extrusion::SdaiSurface_of_linear_extrusion (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSwept_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSwept_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_of_linear_extrusion;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_205extrusion_axis, (SCLP23(Application_instance_ptr) *) &_extrusion_axis);
#else
    STEPattribute *a = new STEPattribute(*a_205extrusion_axis, (SCLP23(Application_instance_ptr) *) &_extrusion_axis);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiVector_ptr
SdaiSurface_of_linear_extrusion::extrusion_axis_() const
{
    return (SdaiVector_ptr) _extrusion_axis;
}

void
SdaiSurface_of_linear_extrusion::extrusion_axis_ (const SdaiVector_ptr x)

{
    _extrusion_axis = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY surface_of_linear_extrusion


/////////	 ENTITY shell_based_surface_model

EntityDescriptor *config_control_designe_shell_based_surface_model =0;
AttrDescriptor *a_206sbsm_boundary =0;
SdaiShell_based_surface_model::SdaiShell_based_surface_model( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_surface_model;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_206sbsm_boundary,  &_sbsm_boundary);
#else
    STEPattribute *a = new STEPattribute(*a_206sbsm_boundary,  &_sbsm_boundary);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiShell_based_surface_model::SdaiShell_based_surface_model (SdaiShell_based_surface_model& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiShell_based_surface_model::~SdaiShell_based_surface_model () {  }

#ifdef __OSTORE__

void
SdaiShell_based_surface_model::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShell_based_surface_model: virtual access function." << endl;
    SdaiShell_based_surface_model_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiShell_based_surface_model_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShell_based_surface_model: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiShell_based_surface_model *ent = (SdaiShell_based_surface_model *)sent;
//    SdaiShell_based_surface_model *ent = (SdaiShell_based_surface_model *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_shell_based_surface_model;
    ent->attributes[1].aDesc = a_206sbsm_boundary;
}

SCLP23(Application_instance_ptr)
create_SdaiShell_based_surface_model(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiShell_based_surface_model::get_os_typespec())
                                   SdaiShell_based_surface_model;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiShell_based_surface_model::get_os_typespec())
//                                   SdaiShell_based_surface_model;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiShell_based_surface_model;
}
#endif

#ifdef __O3DB__
void
SdaiShell_based_surface_model::oodb_reInit ()
{	eDesc = config_control_designe_shell_based_surface_model;
	attributes [1].aDesc = a_206sbsm_boundary;
}
#endif

SdaiShell_based_surface_model::SdaiShell_based_surface_model (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_surface_model;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_206sbsm_boundary,  &_sbsm_boundary);
#else
    STEPattribute *a = new STEPattribute(*a_206sbsm_boundary,  &_sbsm_boundary);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiShells_ptr
SdaiShell_based_surface_model::sbsm_boundary_() const
{
    return (SdaiShells_ptr) &_sbsm_boundary;
}

void
SdaiShell_based_surface_model::sbsm_boundary_ (const SdaiShells_ptr x)

	{ _sbsm_boundary.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shell_based_surface_model


/////////	 ENTITY uniform_curve

EntityDescriptor *config_control_designe_uniform_curve =0;
SdaiUniform_curve::SdaiUniform_curve( )
{

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uniform_curve;
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
}
SdaiUniform_curve::SdaiUniform_curve (SdaiUniform_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiUniform_curve::~SdaiUniform_curve () {  }

#ifdef __OSTORE__

void
SdaiUniform_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiUniform_curve: virtual access function." << endl;
    SdaiUniform_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiUniform_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiUniform_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiUniform_curve *ent = (SdaiUniform_curve *)sent;
//    SdaiUniform_curve *ent = (SdaiUniform_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_uniform_curve;
}

SCLP23(Application_instance_ptr)
create_SdaiUniform_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiUniform_curve::get_os_typespec())
                                   SdaiUniform_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiUniform_curve::get_os_typespec())
//                                   SdaiUniform_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiUniform_curve;
}
#endif

#ifdef __O3DB__
void
SdaiUniform_curve::oodb_reInit ()
{	eDesc = config_control_designe_uniform_curve;
}
#endif

SdaiUniform_curve::SdaiUniform_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiB_spline_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uniform_curve;
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY uniform_curve


/////////	 ENTITY bezier_curve

EntityDescriptor *config_control_designe_bezier_curve =0;
SdaiBezier_curve::SdaiBezier_curve( )
{

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bezier_curve;
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
}
SdaiBezier_curve::SdaiBezier_curve (SdaiBezier_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiBezier_curve::~SdaiBezier_curve () {  }

#ifdef __OSTORE__

void
SdaiBezier_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBezier_curve: virtual access function." << endl;
    SdaiBezier_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiBezier_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBezier_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiBezier_curve *ent = (SdaiBezier_curve *)sent;
//    SdaiBezier_curve *ent = (SdaiBezier_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_bezier_curve;
}

SCLP23(Application_instance_ptr)
create_SdaiBezier_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiBezier_curve::get_os_typespec())
                                   SdaiBezier_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiBezier_curve::get_os_typespec())
//                                   SdaiBezier_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiBezier_curve;
}
#endif

#ifdef __O3DB__
void
SdaiBezier_curve::oodb_reInit ()
{	eDesc = config_control_designe_bezier_curve;
}
#endif

SdaiBezier_curve::SdaiBezier_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiB_spline_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bezier_curve;
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY bezier_curve


/////////	 ENTITY loop

EntityDescriptor *config_control_designe_loop =0;
SdaiLoop::SdaiLoop( )
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_loop;
}
SdaiLoop::SdaiLoop (SdaiLoop& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiLoop::~SdaiLoop () {  }

#ifdef __OSTORE__

void
SdaiLoop::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLoop: virtual access function." << endl;
    SdaiLoop_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiLoop_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLoop: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiLoop *ent = (SdaiLoop *)sent;
//    SdaiLoop *ent = (SdaiLoop *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_loop;
}

SCLP23(Application_instance_ptr)
create_SdaiLoop(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiLoop::get_os_typespec())
                                   SdaiLoop;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiLoop::get_os_typespec())
//                                   SdaiLoop;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiLoop;
}
#endif

#ifdef __O3DB__
void
SdaiLoop::oodb_reInit ()
{	eDesc = config_control_designe_loop;
}
#endif

SdaiLoop::SdaiLoop (SCLP23(Application_instance) *se, int *addAttrs) : SdaiTopological_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_loop;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY loop


/////////	 ENTITY edge_loop

EntityDescriptor *config_control_designe_edge_loop =0;
Derived_attribute *a_207Dne =0;
SdaiEdge_loop::SdaiEdge_loop( )
{

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiPath  */
    HeadEntity(this);
#if 1
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 0; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    AppendMultInstance(new SdaiPath(this, attrFlags));
#else
    AppendMultInstance(new SdaiPath(this));
#endif
    eDesc = config_control_designe_edge_loop;
    MakeDerived ("ne");
}
SdaiEdge_loop::SdaiEdge_loop (SdaiEdge_loop& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiEdge_loop::~SdaiEdge_loop () {  }

#ifdef __OSTORE__

void
SdaiEdge_loop::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEdge_loop: virtual access function." << endl;
    SdaiEdge_loop_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiEdge_loop_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEdge_loop: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiEdge_loop *ent = (SdaiEdge_loop *)sent;
//    SdaiEdge_loop *ent = (SdaiEdge_loop *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_edge_loop;
}

SCLP23(Application_instance_ptr)
create_SdaiEdge_loop(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiEdge_loop::get_os_typespec())
                                   SdaiEdge_loop;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiEdge_loop::get_os_typespec())
//                                   SdaiEdge_loop;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiEdge_loop;
}
#endif

#ifdef __O3DB__
void
SdaiEdge_loop::oodb_reInit ()
{	eDesc = config_control_designe_edge_loop;
}
#endif

SdaiEdge_loop::SdaiEdge_loop (SCLP23(Application_instance) *se, int *addAttrs) : SdaiLoop(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiPath  */
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    se->AppendMultInstance(new SdaiPath(se, attrFlags));
#endif
    se->AppendMultInstance(new SdaiPath(se, 0));

    eDesc = config_control_designe_edge_loop;
    MakeDerived ("ne");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

const EntityAggregate_ptr
SdaiEdge_loop::edge_list_() const
{
    return (EntityAggregate_ptr) &_edge_list;
}

void
SdaiEdge_loop::edge_list_ (const EntityAggregate_ptr x)

	{ _edge_list.ShallowCopy (*x); }

#endif

/////////	 END_ENTITY edge_loop


/////////	 ENTITY date

EntityDescriptor *config_control_designe_date =0;
AttrDescriptor *a_208year_component =0;
SdaiDate::SdaiDate( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_date;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_208year_component,  &_year_component);
#else
    STEPattribute *a = new STEPattribute(*a_208year_component,  &_year_component);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDate::SdaiDate (SdaiDate& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDate::~SdaiDate () {  }

#ifdef __OSTORE__

void
SdaiDate::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDate: virtual access function." << endl;
    SdaiDate_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDate_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDate: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDate *ent = (SdaiDate *)sent;
//    SdaiDate *ent = (SdaiDate *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_date;
    ent->attributes[0].aDesc = a_208year_component;
}

SCLP23(Application_instance_ptr)
create_SdaiDate(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDate::get_os_typespec())
                                   SdaiDate;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDate::get_os_typespec())
//                                   SdaiDate;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDate;
}
#endif

#ifdef __O3DB__
void
SdaiDate::oodb_reInit ()
{	eDesc = config_control_designe_date;
	attributes [0].aDesc = a_208year_component;
}
#endif

SdaiDate::SdaiDate( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_date;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_208year_component,  &_year_component);
#else
    STEPattribute *a = new STEPattribute(*a_208year_component,  &_year_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiYear_number
SdaiDate::year_component_() const
{
    return (const SdaiYear_number) _year_component;
}

void
SdaiDate::year_component_ (const SdaiYear_number x)

{
    _year_component = x;
}

/////////	 END_ENTITY date


/////////	 ENTITY calendar_date

EntityDescriptor *config_control_designe_calendar_date =0;
AttrDescriptor *a_209day_component =0;
AttrDescriptor *a_210month_component =0;
SdaiCalendar_date::SdaiCalendar_date( )
{

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_calendar_date;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_209day_component,  &_day_component);
#else
    STEPattribute *a = new STEPattribute(*a_209day_component,  &_day_component);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_210month_component,  &_month_component);
#else
    a = new STEPattribute(*a_210month_component,  &_month_component);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCalendar_date::SdaiCalendar_date (SdaiCalendar_date& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCalendar_date::~SdaiCalendar_date () {  }

#ifdef __OSTORE__

void
SdaiCalendar_date::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCalendar_date: virtual access function." << endl;
    SdaiCalendar_date_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCalendar_date_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCalendar_date: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCalendar_date *ent = (SdaiCalendar_date *)sent;
//    SdaiCalendar_date *ent = (SdaiCalendar_date *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_calendar_date;
    ent->attributes[1].aDesc = a_209day_component;
    ent->attributes[2].aDesc = a_210month_component;
}

SCLP23(Application_instance_ptr)
create_SdaiCalendar_date(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCalendar_date::get_os_typespec())
                                   SdaiCalendar_date;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCalendar_date::get_os_typespec())
//                                   SdaiCalendar_date;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCalendar_date;
}
#endif

#ifdef __O3DB__
void
SdaiCalendar_date::oodb_reInit ()
{	eDesc = config_control_designe_calendar_date;
	attributes [1].aDesc = a_209day_component;
	attributes [2].aDesc = a_210month_component;
}
#endif

SdaiCalendar_date::SdaiCalendar_date (SCLP23(Application_instance) *se, int *addAttrs) : SdaiDate(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_calendar_date;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_209day_component,  &_day_component);
#else
    STEPattribute *a = new STEPattribute(*a_209day_component,  &_day_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_210month_component,  &_month_component);
#else
    a = new STEPattribute(*a_210month_component,  &_month_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiDay_in_month_number
SdaiCalendar_date::day_component_() const
{
    return (const SdaiDay_in_month_number) _day_component;
}

void
SdaiCalendar_date::day_component_ (const SdaiDay_in_month_number x)

{
    _day_component = x;
}

const SdaiMonth_in_year_number
SdaiCalendar_date::month_component_() const
{
    return (const SdaiMonth_in_year_number) _month_component;
}

void
SdaiCalendar_date::month_component_ (const SdaiMonth_in_year_number x)

{
    _month_component = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY calendar_date


/////////	 ENTITY toroidal_surface

EntityDescriptor *config_control_designe_toroidal_surface =0;
AttrDescriptor *a_211major_radius =0;
AttrDescriptor *a_212minor_radius =0;
SdaiToroidal_surface::SdaiToroidal_surface( )
{

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_toroidal_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_211major_radius,  &_major_radius);
#else
    STEPattribute *a = new STEPattribute(*a_211major_radius,  &_major_radius);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_212minor_radius,  &_minor_radius);
#else
    a = new STEPattribute(*a_212minor_radius,  &_minor_radius);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiToroidal_surface::SdaiToroidal_surface (SdaiToroidal_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiToroidal_surface::~SdaiToroidal_surface () {  }

#ifdef __OSTORE__

void
SdaiToroidal_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiToroidal_surface: virtual access function." << endl;
    SdaiToroidal_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiToroidal_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiToroidal_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiToroidal_surface *ent = (SdaiToroidal_surface *)sent;
//    SdaiToroidal_surface *ent = (SdaiToroidal_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_toroidal_surface;
    ent->attributes[2].aDesc = a_211major_radius;
    ent->attributes[3].aDesc = a_212minor_radius;
}

SCLP23(Application_instance_ptr)
create_SdaiToroidal_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiToroidal_surface::get_os_typespec())
                                   SdaiToroidal_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiToroidal_surface::get_os_typespec())
//                                   SdaiToroidal_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiToroidal_surface;
}
#endif

#ifdef __O3DB__
void
SdaiToroidal_surface::oodb_reInit ()
{	eDesc = config_control_designe_toroidal_surface;
	attributes [2].aDesc = a_211major_radius;
	attributes [3].aDesc = a_212minor_radius;
}
#endif

SdaiToroidal_surface::SdaiToroidal_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiElementary_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_toroidal_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_211major_radius,  &_major_radius);
#else
    STEPattribute *a = new STEPattribute(*a_211major_radius,  &_major_radius);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_212minor_radius,  &_minor_radius);
#else
    a = new STEPattribute(*a_212minor_radius,  &_minor_radius);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiPositive_length_measure
SdaiToroidal_surface::major_radius_() const
{
    return (const SdaiPositive_length_measure) _major_radius;
}

void
SdaiToroidal_surface::major_radius_ (const SdaiPositive_length_measure x)

{
    _major_radius = x;
}

const SdaiPositive_length_measure
SdaiToroidal_surface::minor_radius_() const
{
    return (const SdaiPositive_length_measure) _minor_radius;
}

void
SdaiToroidal_surface::minor_radius_ (const SdaiPositive_length_measure x)

{
    _minor_radius = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY toroidal_surface


/////////	 ENTITY promissory_usage_occurrence

EntityDescriptor *config_control_designe_promissory_usage_occurrence =0;
SdaiPromissory_usage_occurrence::SdaiPromissory_usage_occurrence( )
{

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_promissory_usage_occurrence;
}
SdaiPromissory_usage_occurrence::SdaiPromissory_usage_occurrence (SdaiPromissory_usage_occurrence& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPromissory_usage_occurrence::~SdaiPromissory_usage_occurrence () {  }

#ifdef __OSTORE__

void
SdaiPromissory_usage_occurrence::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPromissory_usage_occurrence: virtual access function." << endl;
    SdaiPromissory_usage_occurrence_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPromissory_usage_occurrence_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPromissory_usage_occurrence: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPromissory_usage_occurrence *ent = (SdaiPromissory_usage_occurrence *)sent;
//    SdaiPromissory_usage_occurrence *ent = (SdaiPromissory_usage_occurrence *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_promissory_usage_occurrence;
}

SCLP23(Application_instance_ptr)
create_SdaiPromissory_usage_occurrence(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPromissory_usage_occurrence::get_os_typespec())
                                   SdaiPromissory_usage_occurrence;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPromissory_usage_occurrence::get_os_typespec())
//                                   SdaiPromissory_usage_occurrence;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPromissory_usage_occurrence;
}
#endif

#ifdef __O3DB__
void
SdaiPromissory_usage_occurrence::oodb_reInit ()
{	eDesc = config_control_designe_promissory_usage_occurrence;
}
#endif

SdaiPromissory_usage_occurrence::SdaiPromissory_usage_occurrence (SCLP23(Application_instance) *se, int *addAttrs) : SdaiAssembly_component_usage(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_promissory_usage_occurrence;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY promissory_usage_occurrence


/////////	 ENTITY approval_assignment

EntityDescriptor *config_control_designe_approval_assignment =0;
AttrDescriptor *a_213assigned_approval =0;
SdaiApproval_assignment::SdaiApproval_assignment( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_213assigned_approval, (SCLP23(Application_instance_ptr) *) &_assigned_approval);
#else
    STEPattribute *a = new STEPattribute(*a_213assigned_approval, (SCLP23(Application_instance_ptr) *) &_assigned_approval);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_assignment::SdaiApproval_assignment (SdaiApproval_assignment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiApproval_assignment::~SdaiApproval_assignment () {  }

#ifdef __OSTORE__

void
SdaiApproval_assignment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_assignment: virtual access function." << endl;
    SdaiApproval_assignment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiApproval_assignment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_assignment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiApproval_assignment *ent = (SdaiApproval_assignment *)sent;
//    SdaiApproval_assignment *ent = (SdaiApproval_assignment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_approval_assignment;
    ent->attributes[0].aDesc = a_213assigned_approval;
    if(ent->_assigned_approval == 0)
        ent->_assigned_approval = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiApproval_assignment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiApproval_assignment::get_os_typespec())
                                   SdaiApproval_assignment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiApproval_assignment::get_os_typespec())
//                                   SdaiApproval_assignment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiApproval_assignment;
}
#endif

#ifdef __O3DB__
void
SdaiApproval_assignment::oodb_reInit ()
{	eDesc = config_control_designe_approval_assignment;
	attributes [0].aDesc = a_213assigned_approval;
}
#endif

SdaiApproval_assignment::SdaiApproval_assignment( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_213assigned_approval, (SCLP23(Application_instance_ptr) *) &_assigned_approval);
#else
    STEPattribute *a = new STEPattribute(*a_213assigned_approval, (SCLP23(Application_instance_ptr) *) &_assigned_approval);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiApproval_ptr
SdaiApproval_assignment::assigned_approval_() const
{
    return (SdaiApproval_ptr) _assigned_approval;
}

void
SdaiApproval_assignment::assigned_approval_ (const SdaiApproval_ptr x)

{
    _assigned_approval = x;
}

/////////	 END_ENTITY approval_assignment


/////////	 ENTITY configuration_item

EntityDescriptor *config_control_designe_configuration_item =0;
AttrDescriptor *a_214id =0;
AttrDescriptor *a_215name =0;
AttrDescriptor *a_216description =0;
AttrDescriptor *a_217item_concept =0;
AttrDescriptor *a_218purpose =0;
SdaiConfiguration_item::SdaiConfiguration_item( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_configuration_item;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_214id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_214id,  &_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_215name,  &_name);
#else
    a = new STEPattribute(*a_215name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_216description,  &_description);
#else
    a = new STEPattribute(*a_216description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_217item_concept, (SCLP23(Application_instance_ptr) *) &_item_concept);
#else
    a = new STEPattribute(*a_217item_concept, (SCLP23(Application_instance_ptr) *) &_item_concept);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_218purpose,  &_purpose);
#else
    a = new STEPattribute(*a_218purpose,  &_purpose);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiConfiguration_item::SdaiConfiguration_item (SdaiConfiguration_item& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiConfiguration_item::~SdaiConfiguration_item () {  }

#ifdef __OSTORE__

void
SdaiConfiguration_item::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConfiguration_item: virtual access function." << endl;
    SdaiConfiguration_item_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiConfiguration_item_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConfiguration_item: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiConfiguration_item *ent = (SdaiConfiguration_item *)sent;
//    SdaiConfiguration_item *ent = (SdaiConfiguration_item *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_configuration_item;
    ent->attributes[0].aDesc = a_214id;
    ent->attributes[1].aDesc = a_215name;
    ent->attributes[2].aDesc = a_216description;
    ent->attributes[3].aDesc = a_217item_concept;
    if(ent->_item_concept == 0)
        ent->_item_concept = S_ENTITY_NULL;
    ent->attributes[4].aDesc = a_218purpose;
}

SCLP23(Application_instance_ptr)
create_SdaiConfiguration_item(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiConfiguration_item::get_os_typespec())
                                   SdaiConfiguration_item;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiConfiguration_item::get_os_typespec())
//                                   SdaiConfiguration_item;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiConfiguration_item;
}
#endif

#ifdef __O3DB__
void
SdaiConfiguration_item::oodb_reInit ()
{	eDesc = config_control_designe_configuration_item;
	attributes [0].aDesc = a_214id;
	attributes [1].aDesc = a_215name;
	attributes [2].aDesc = a_216description;
	attributes [3].aDesc = a_217item_concept;
	attributes [4].aDesc = a_218purpose;
}
#endif

SdaiConfiguration_item::SdaiConfiguration_item( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_configuration_item;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_214id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_214id,  &_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_215name,  &_name);
#else
    a = new STEPattribute(*a_215name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_216description,  &_description);
#else
    a = new STEPattribute(*a_216description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_217item_concept, (SCLP23(Application_instance_ptr) *) &_item_concept);
#else
    a = new STEPattribute(*a_217item_concept, (SCLP23(Application_instance_ptr) *) &_item_concept);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_218purpose,  &_purpose);
#else
    a = new STEPattribute(*a_218purpose,  &_purpose);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiConfiguration_item::id_() const
{
    return (const SdaiIdentifier) _id;
}

void
SdaiConfiguration_item::id_ (const SdaiIdentifier x)

{
    _id = x;
}

const SdaiLabel
SdaiConfiguration_item::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiConfiguration_item::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiConfiguration_item::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiConfiguration_item::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiProduct_concept_ptr
SdaiConfiguration_item::item_concept_() const
{
    return (SdaiProduct_concept_ptr) _item_concept;
}

void
SdaiConfiguration_item::item_concept_ (const SdaiProduct_concept_ptr x)

{
    _item_concept = x;
}

const SdaiLabel
SdaiConfiguration_item::purpose_() const
{
    return (const SdaiLabel) _purpose;
}

void
SdaiConfiguration_item::purpose_ (const SdaiLabel x)

{
    _purpose = x;
}

/////////	 END_ENTITY configuration_item


/////////	 ENTITY contract_assignment

EntityDescriptor *config_control_designe_contract_assignment =0;
AttrDescriptor *a_219assigned_contract =0;
SdaiContract_assignment::SdaiContract_assignment( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_contract_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_219assigned_contract, (SCLP23(Application_instance_ptr) *) &_assigned_contract);
#else
    STEPattribute *a = new STEPattribute(*a_219assigned_contract, (SCLP23(Application_instance_ptr) *) &_assigned_contract);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiContract_assignment::SdaiContract_assignment (SdaiContract_assignment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiContract_assignment::~SdaiContract_assignment () {  }

#ifdef __OSTORE__

void
SdaiContract_assignment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiContract_assignment: virtual access function." << endl;
    SdaiContract_assignment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiContract_assignment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiContract_assignment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiContract_assignment *ent = (SdaiContract_assignment *)sent;
//    SdaiContract_assignment *ent = (SdaiContract_assignment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_contract_assignment;
    ent->attributes[0].aDesc = a_219assigned_contract;
    if(ent->_assigned_contract == 0)
        ent->_assigned_contract = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiContract_assignment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiContract_assignment::get_os_typespec())
                                   SdaiContract_assignment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiContract_assignment::get_os_typespec())
//                                   SdaiContract_assignment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiContract_assignment;
}
#endif

#ifdef __O3DB__
void
SdaiContract_assignment::oodb_reInit ()
{	eDesc = config_control_designe_contract_assignment;
	attributes [0].aDesc = a_219assigned_contract;
}
#endif

SdaiContract_assignment::SdaiContract_assignment( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_contract_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_219assigned_contract, (SCLP23(Application_instance_ptr) *) &_assigned_contract);
#else
    STEPattribute *a = new STEPattribute(*a_219assigned_contract, (SCLP23(Application_instance_ptr) *) &_assigned_contract);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiContract_ptr
SdaiContract_assignment::assigned_contract_() const
{
    return (SdaiContract_ptr) _assigned_contract;
}

void
SdaiContract_assignment::assigned_contract_ (const SdaiContract_ptr x)

{
    _assigned_contract = x;
}

/////////	 END_ENTITY contract_assignment


/////////	 ENTITY vector

EntityDescriptor *config_control_designe_vector =0;
AttrDescriptor *a_220orientation =0;
AttrDescriptor *a_221magnitude =0;
SdaiVector::SdaiVector( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vector;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_220orientation, (SCLP23(Application_instance_ptr) *) &_orientation);
#else
    STEPattribute *a = new STEPattribute(*a_220orientation, (SCLP23(Application_instance_ptr) *) &_orientation);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_221magnitude,  &_magnitude);
#else
    a = new STEPattribute(*a_221magnitude,  &_magnitude);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiVector::SdaiVector (SdaiVector& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiVector::~SdaiVector () {  }

#ifdef __OSTORE__

void
SdaiVector::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVector: virtual access function." << endl;
    SdaiVector_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiVector_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVector: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiVector *ent = (SdaiVector *)sent;
//    SdaiVector *ent = (SdaiVector *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_vector;
    ent->attributes[1].aDesc = a_220orientation;
    if(ent->_orientation == 0)
        ent->_orientation = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_221magnitude;
}

SCLP23(Application_instance_ptr)
create_SdaiVector(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiVector::get_os_typespec())
                                   SdaiVector;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiVector::get_os_typespec())
//                                   SdaiVector;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiVector;
}
#endif

#ifdef __O3DB__
void
SdaiVector::oodb_reInit ()
{	eDesc = config_control_designe_vector;
	attributes [1].aDesc = a_220orientation;
	attributes [2].aDesc = a_221magnitude;
}
#endif

SdaiVector::SdaiVector (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vector;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_220orientation, (SCLP23(Application_instance_ptr) *) &_orientation);
#else
    STEPattribute *a = new STEPattribute(*a_220orientation, (SCLP23(Application_instance_ptr) *) &_orientation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_221magnitude,  &_magnitude);
#else
    a = new STEPattribute(*a_221magnitude,  &_magnitude);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiDirection_ptr
SdaiVector::orientation_() const
{
    return (SdaiDirection_ptr) _orientation;
}

void
SdaiVector::orientation_ (const SdaiDirection_ptr x)

{
    _orientation = x;
}

const SdaiLength_measure
SdaiVector::magnitude_() const
{
    return (const SdaiLength_measure) _magnitude;
}

void
SdaiVector::magnitude_ (const SdaiLength_measure x)

{
    _magnitude = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY vector


/////////	 ENTITY pcurve

EntityDescriptor *config_control_designe_pcurve =0;
AttrDescriptor *a_222basis_surface =0;
AttrDescriptor *a_223reference_to_curve =0;
SdaiPcurve::SdaiPcurve( )
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_pcurve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_222basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_222basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_223reference_to_curve, (SCLP23(Application_instance_ptr) *) &_reference_to_curve);
#else
    a = new STEPattribute(*a_223reference_to_curve, (SCLP23(Application_instance_ptr) *) &_reference_to_curve);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiPcurve::SdaiPcurve (SdaiPcurve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPcurve::~SdaiPcurve () {  }

#ifdef __OSTORE__

void
SdaiPcurve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPcurve: virtual access function." << endl;
    SdaiPcurve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPcurve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPcurve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPcurve *ent = (SdaiPcurve *)sent;
//    SdaiPcurve *ent = (SdaiPcurve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_pcurve;
    ent->attributes[1].aDesc = a_222basis_surface;
    if(ent->_basis_surface == 0)
        ent->_basis_surface = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_223reference_to_curve;
    if(ent->_reference_to_curve == 0)
        ent->_reference_to_curve = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiPcurve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPcurve::get_os_typespec())
                                   SdaiPcurve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPcurve::get_os_typespec())
//                                   SdaiPcurve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPcurve;
}
#endif

#ifdef __O3DB__
void
SdaiPcurve::oodb_reInit ()
{	eDesc = config_control_designe_pcurve;
	attributes [1].aDesc = a_222basis_surface;
	attributes [2].aDesc = a_223reference_to_curve;
}
#endif

SdaiPcurve::SdaiPcurve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiCurve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_pcurve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_222basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_222basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_223reference_to_curve, (SCLP23(Application_instance_ptr) *) &_reference_to_curve);
#else
    a = new STEPattribute(*a_223reference_to_curve, (SCLP23(Application_instance_ptr) *) &_reference_to_curve);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiSurface_ptr
SdaiPcurve::basis_surface_() const
{
    return (SdaiSurface_ptr) _basis_surface;
}

void
SdaiPcurve::basis_surface_ (const SdaiSurface_ptr x)

{
    _basis_surface = x;
}

const SdaiDefinitional_representation_ptr
SdaiPcurve::reference_to_curve_() const
{
    return (SdaiDefinitional_representation_ptr) _reference_to_curve;
}

void
SdaiPcurve::reference_to_curve_ (const SdaiDefinitional_representation_ptr x)

{
    _reference_to_curve = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY pcurve


/////////	 ENTITY bounded_pcurve

EntityDescriptor *config_control_designe_bounded_pcurve =0;
SdaiBounded_pcurve::SdaiBounded_pcurve( )
{

	/*  parent: SdaiPcurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiBounded_curve  */
    HeadEntity(this);
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    AppendMultInstance(new SdaiBounded_curve(this, attrFlags));
#endif
    AppendMultInstance(new SdaiBounded_curve(this));

    eDesc = config_control_designe_bounded_pcurve;
    MakeDerived ("dim");
    MakeDerived ("dim");
}
SdaiBounded_pcurve::SdaiBounded_pcurve (SdaiBounded_pcurve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiBounded_pcurve::~SdaiBounded_pcurve () {  }

#ifdef __OSTORE__

void
SdaiBounded_pcurve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBounded_pcurve: virtual access function." << endl;
    SdaiBounded_pcurve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiBounded_pcurve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBounded_pcurve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiBounded_pcurve *ent = (SdaiBounded_pcurve *)sent;
//    SdaiBounded_pcurve *ent = (SdaiBounded_pcurve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_bounded_pcurve;
}

SCLP23(Application_instance_ptr)
create_SdaiBounded_pcurve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiBounded_pcurve::get_os_typespec())
                                   SdaiBounded_pcurve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiBounded_pcurve::get_os_typespec())
//                                   SdaiBounded_pcurve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiBounded_pcurve;
}
#endif

#ifdef __O3DB__
void
SdaiBounded_pcurve::oodb_reInit ()
{	eDesc = config_control_designe_bounded_pcurve;
}
#endif

SdaiBounded_pcurve::SdaiBounded_pcurve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiPcurve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiPcurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiBounded_curve  */
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    se->AppendMultInstance(new SdaiBounded_curve(se, attrFlags));
#endif
    se->AppendMultInstance(new SdaiBounded_curve(se, 0));

    eDesc = config_control_designe_bounded_pcurve;
    MakeDerived ("dim");
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

#endif

/////////	 END_ENTITY bounded_pcurve


/////////	 ENTITY intersection_curve

EntityDescriptor *config_control_designe_intersection_curve =0;
SdaiIntersection_curve::SdaiIntersection_curve( )
{

	/*  parent: SdaiSurface_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_intersection_curve;
    MakeDerived ("dim");
    MakeDerived ("basis_surface");
}
SdaiIntersection_curve::SdaiIntersection_curve (SdaiIntersection_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiIntersection_curve::~SdaiIntersection_curve () {  }

#ifdef __OSTORE__

void
SdaiIntersection_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiIntersection_curve: virtual access function." << endl;
    SdaiIntersection_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiIntersection_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiIntersection_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiIntersection_curve *ent = (SdaiIntersection_curve *)sent;
//    SdaiIntersection_curve *ent = (SdaiIntersection_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_intersection_curve;
}

SCLP23(Application_instance_ptr)
create_SdaiIntersection_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiIntersection_curve::get_os_typespec())
                                   SdaiIntersection_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiIntersection_curve::get_os_typespec())
//                                   SdaiIntersection_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiIntersection_curve;
}
#endif

#ifdef __O3DB__
void
SdaiIntersection_curve::oodb_reInit ()
{	eDesc = config_control_designe_intersection_curve;
}
#endif

SdaiIntersection_curve::SdaiIntersection_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSurface_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSurface_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_intersection_curve;
    MakeDerived ("dim");
    MakeDerived ("basis_surface");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY intersection_curve


/////////	 ENTITY trimmed_curve

EntityDescriptor *config_control_designe_trimmed_curve =0;
AttrDescriptor *a_224basis_curve =0;
AttrDescriptor *a_225trim_1 =0;
AttrDescriptor *a_226trim_2 =0;
AttrDescriptor *a_227sense_agreement =0;
AttrDescriptor *a_228master_representation =0;
SdaiTrimmed_curve::SdaiTrimmed_curve( )
{

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_trimmed_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_224basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#else
    STEPattribute *a = new STEPattribute(*a_224basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_225trim_1,  &_trim_1);
#else
    a = new STEPattribute(*a_225trim_1,  &_trim_1);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_226trim_2,  &_trim_2);
#else
    a = new STEPattribute(*a_226trim_2,  &_trim_2);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_227sense_agreement,  &_sense_agreement);
#else
    a = new STEPattribute(*a_227sense_agreement,  &_sense_agreement);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_228master_representation,  &_master_representation);
#else
    a = new STEPattribute(*a_228master_representation,  &_master_representation);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiTrimmed_curve::SdaiTrimmed_curve (SdaiTrimmed_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiTrimmed_curve::~SdaiTrimmed_curve () {  }

#ifdef __OSTORE__

void
SdaiTrimmed_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiTrimmed_curve: virtual access function." << endl;
    SdaiTrimmed_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiTrimmed_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiTrimmed_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiTrimmed_curve *ent = (SdaiTrimmed_curve *)sent;
//    SdaiTrimmed_curve *ent = (SdaiTrimmed_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_trimmed_curve;
    ent->attributes[1].aDesc = a_224basis_curve;
    if(ent->_basis_curve == 0)
        ent->_basis_curve = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_225trim_1;
    ent->attributes[3].aDesc = a_226trim_2;
    ent->attributes[4].aDesc = a_227sense_agreement;
    ent->attributes[5].aDesc = a_228master_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiTrimmed_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiTrimmed_curve::get_os_typespec())
                                   SdaiTrimmed_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiTrimmed_curve::get_os_typespec())
//                                   SdaiTrimmed_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiTrimmed_curve;
}
#endif

#ifdef __O3DB__
void
SdaiTrimmed_curve::oodb_reInit ()
{	eDesc = config_control_designe_trimmed_curve;
	attributes [1].aDesc = a_224basis_curve;
	attributes [2].aDesc = a_225trim_1;
	attributes [3].aDesc = a_226trim_2;
	attributes [4].aDesc = a_227sense_agreement;
	attributes [5].aDesc = a_228master_representation;
}
#endif

SdaiTrimmed_curve::SdaiTrimmed_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiBounded_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_trimmed_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_224basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#else
    STEPattribute *a = new STEPattribute(*a_224basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_225trim_1,  &_trim_1);
#else
    a = new STEPattribute(*a_225trim_1,  &_trim_1);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_226trim_2,  &_trim_2);
#else
    a = new STEPattribute(*a_226trim_2,  &_trim_2);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_227sense_agreement,  &_sense_agreement);
#else
    a = new STEPattribute(*a_227sense_agreement,  &_sense_agreement);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_228master_representation,  &_master_representation);
#else
    a = new STEPattribute(*a_228master_representation,  &_master_representation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiCurve_ptr
SdaiTrimmed_curve::basis_curve_() const
{
    return (SdaiCurve_ptr) _basis_curve;
}

void
SdaiTrimmed_curve::basis_curve_ (const SdaiCurve_ptr x)

{
    _basis_curve = x;
}

const SdaiTrimming_selects_ptr
SdaiTrimmed_curve::trim_1_() const
{
    return (SdaiTrimming_selects_ptr) &_trim_1;
}

void
SdaiTrimmed_curve::trim_1_ (const SdaiTrimming_selects_ptr x)

	{ _trim_1.ShallowCopy (*x); }

const SdaiTrimming_selects_ptr
SdaiTrimmed_curve::trim_2_() const
{
    return (SdaiTrimming_selects_ptr) &_trim_2;
}

void
SdaiTrimmed_curve::trim_2_ (const SdaiTrimming_selects_ptr x)

	{ _trim_2.ShallowCopy (*x); }

const SCLBOOL(Bool)
SdaiTrimmed_curve::sense_agreement_() const
{
    return (SCLBOOL(Bool)) _sense_agreement;
}

void
SdaiTrimmed_curve::sense_agreement_ (const SCLBOOL(Bool) x)

{
    _sense_agreement.put (x);
}

const SdaiTrimming_preference_var
SdaiTrimmed_curve::master_representation_() const
{
    return (Trimming_preference) _master_representation;
}

void
SdaiTrimmed_curve::master_representation_ (const SdaiTrimming_preference_var x)

{
    _master_representation.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY trimmed_curve


/////////	 ENTITY product_definition_context

EntityDescriptor *config_control_designe_product_definition_context =0;
AttrDescriptor *a_229life_cycle_stage =0;
SdaiProduct_definition_context::SdaiProduct_definition_context( )
{

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_229life_cycle_stage,  &_life_cycle_stage);
#else
    STEPattribute *a = new STEPattribute(*a_229life_cycle_stage,  &_life_cycle_stage);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_context::SdaiProduct_definition_context (SdaiProduct_definition_context& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_definition_context::~SdaiProduct_definition_context () {  }

#ifdef __OSTORE__

void
SdaiProduct_definition_context::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_context: virtual access function." << endl;
    SdaiProduct_definition_context_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_definition_context_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_context: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_definition_context *ent = (SdaiProduct_definition_context *)sent;
//    SdaiProduct_definition_context *ent = (SdaiProduct_definition_context *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_definition_context;
    ent->attributes[2].aDesc = a_229life_cycle_stage;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_definition_context(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_definition_context::get_os_typespec())
                                   SdaiProduct_definition_context;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_definition_context::get_os_typespec())
//                                   SdaiProduct_definition_context;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_definition_context;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_definition_context::oodb_reInit ()
{	eDesc = config_control_designe_product_definition_context;
	attributes [2].aDesc = a_229life_cycle_stage;
}
#endif

SdaiProduct_definition_context::SdaiProduct_definition_context (SCLP23(Application_instance) *se, int *addAttrs) : SdaiApplication_context_element(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_229life_cycle_stage,  &_life_cycle_stage);
#else
    STEPattribute *a = new STEPattribute(*a_229life_cycle_stage,  &_life_cycle_stage);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiProduct_definition_context::life_cycle_stage_() const
{
    return (const SdaiLabel) _life_cycle_stage;
}

void
SdaiProduct_definition_context::life_cycle_stage_ (const SdaiLabel x)

{
    _life_cycle_stage = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_context


/////////	 ENTITY bounded_surface_curve

EntityDescriptor *config_control_designe_bounded_surface_curve =0;
SdaiBounded_surface_curve::SdaiBounded_surface_curve( )
{

	/*  parent: SdaiSurface_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiBounded_curve  */
    HeadEntity(this);
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    AppendMultInstance(new SdaiBounded_curve(this, attrFlags));
#endif
    AppendMultInstance(new SdaiBounded_curve(this));

    eDesc = config_control_designe_bounded_surface_curve;
    MakeDerived ("dim");
    MakeDerived ("basis_surface");
    MakeDerived ("dim");
}
SdaiBounded_surface_curve::SdaiBounded_surface_curve (SdaiBounded_surface_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiBounded_surface_curve::~SdaiBounded_surface_curve () {  }

#ifdef __OSTORE__

void
SdaiBounded_surface_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBounded_surface_curve: virtual access function." << endl;
    SdaiBounded_surface_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiBounded_surface_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBounded_surface_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiBounded_surface_curve *ent = (SdaiBounded_surface_curve *)sent;
//    SdaiBounded_surface_curve *ent = (SdaiBounded_surface_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_bounded_surface_curve;
}

SCLP23(Application_instance_ptr)
create_SdaiBounded_surface_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiBounded_surface_curve::get_os_typespec())
                                   SdaiBounded_surface_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiBounded_surface_curve::get_os_typespec())
//                                   SdaiBounded_surface_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiBounded_surface_curve;
}
#endif

#ifdef __O3DB__
void
SdaiBounded_surface_curve::oodb_reInit ()
{	eDesc = config_control_designe_bounded_surface_curve;
}
#endif

SdaiBounded_surface_curve::SdaiBounded_surface_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSurface_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSurface_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiBounded_curve  */
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    se->AppendMultInstance(new SdaiBounded_curve(se, attrFlags));
#endif
    se->AppendMultInstance(new SdaiBounded_curve(se, 0));

    eDesc = config_control_designe_bounded_surface_curve;
    MakeDerived ("dim");
    MakeDerived ("basis_surface");
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

#endif

/////////	 END_ENTITY bounded_surface_curve


/////////	 ENTITY item_defined_transformation

EntityDescriptor *config_control_designe_item_defined_transformation =0;
AttrDescriptor *a_230name =0;
AttrDescriptor *a_231description =0;
AttrDescriptor *a_232transform_item_1 =0;
AttrDescriptor *a_233transform_item_2 =0;
SdaiItem_defined_transformation::SdaiItem_defined_transformation( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_item_defined_transformation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_230name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_230name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_231description,  &_description);
#else
    a = new STEPattribute(*a_231description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_232transform_item_1, (SCLP23(Application_instance_ptr) *) &_transform_item_1);
#else
    a = new STEPattribute(*a_232transform_item_1, (SCLP23(Application_instance_ptr) *) &_transform_item_1);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_233transform_item_2, (SCLP23(Application_instance_ptr) *) &_transform_item_2);
#else
    a = new STEPattribute(*a_233transform_item_2, (SCLP23(Application_instance_ptr) *) &_transform_item_2);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiItem_defined_transformation::SdaiItem_defined_transformation (SdaiItem_defined_transformation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiItem_defined_transformation::~SdaiItem_defined_transformation () {  }

#ifdef __OSTORE__

void
SdaiItem_defined_transformation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiItem_defined_transformation: virtual access function." << endl;
    SdaiItem_defined_transformation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiItem_defined_transformation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiItem_defined_transformation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiItem_defined_transformation *ent = (SdaiItem_defined_transformation *)sent;
//    SdaiItem_defined_transformation *ent = (SdaiItem_defined_transformation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_item_defined_transformation;
    ent->attributes[0].aDesc = a_230name;
    ent->attributes[1].aDesc = a_231description;
    ent->attributes[2].aDesc = a_232transform_item_1;
    if(ent->_transform_item_1 == 0)
        ent->_transform_item_1 = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_233transform_item_2;
    if(ent->_transform_item_2 == 0)
        ent->_transform_item_2 = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiItem_defined_transformation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiItem_defined_transformation::get_os_typespec())
                                   SdaiItem_defined_transformation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiItem_defined_transformation::get_os_typespec())
//                                   SdaiItem_defined_transformation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiItem_defined_transformation;
}
#endif

#ifdef __O3DB__
void
SdaiItem_defined_transformation::oodb_reInit ()
{	eDesc = config_control_designe_item_defined_transformation;
	attributes [0].aDesc = a_230name;
	attributes [1].aDesc = a_231description;
	attributes [2].aDesc = a_232transform_item_1;
	attributes [3].aDesc = a_233transform_item_2;
}
#endif

SdaiItem_defined_transformation::SdaiItem_defined_transformation( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_item_defined_transformation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_230name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_230name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_231description,  &_description);
#else
    a = new STEPattribute(*a_231description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_232transform_item_1, (SCLP23(Application_instance_ptr) *) &_transform_item_1);
#else
    a = new STEPattribute(*a_232transform_item_1, (SCLP23(Application_instance_ptr) *) &_transform_item_1);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_233transform_item_2, (SCLP23(Application_instance_ptr) *) &_transform_item_2);
#else
    a = new STEPattribute(*a_233transform_item_2, (SCLP23(Application_instance_ptr) *) &_transform_item_2);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiItem_defined_transformation::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiItem_defined_transformation::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiItem_defined_transformation::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiItem_defined_transformation::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiRepresentation_item_ptr
SdaiItem_defined_transformation::transform_item_1_() const
{
    return (SdaiRepresentation_item_ptr) _transform_item_1;
}

void
SdaiItem_defined_transformation::transform_item_1_ (const SdaiRepresentation_item_ptr x)

{
    _transform_item_1 = x;
}

const SdaiRepresentation_item_ptr
SdaiItem_defined_transformation::transform_item_2_() const
{
    return (SdaiRepresentation_item_ptr) _transform_item_2;
}

void
SdaiItem_defined_transformation::transform_item_2_ (const SdaiRepresentation_item_ptr x)

{
    _transform_item_2 = x;
}

/////////	 END_ENTITY item_defined_transformation


/////////	 ENTITY action_method

EntityDescriptor *config_control_designe_action_method =0;
AttrDescriptor *a_234name =0;
AttrDescriptor *a_235description =0;
AttrDescriptor *a_236consequence =0;
AttrDescriptor *a_237purpose =0;
SdaiAction_method::SdaiAction_method( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_method;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_234name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_234name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_235description,  &_description);
#else
    a = new STEPattribute(*a_235description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_236consequence,  &_consequence);
#else
    a = new STEPattribute(*a_236consequence,  &_consequence);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_237purpose,  &_purpose);
#else
    a = new STEPattribute(*a_237purpose,  &_purpose);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_method::SdaiAction_method (SdaiAction_method& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAction_method::~SdaiAction_method () {  }

#ifdef __OSTORE__

void
SdaiAction_method::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_method: virtual access function." << endl;
    SdaiAction_method_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAction_method_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_method: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAction_method *ent = (SdaiAction_method *)sent;
//    SdaiAction_method *ent = (SdaiAction_method *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_action_method;
    ent->attributes[0].aDesc = a_234name;
    ent->attributes[1].aDesc = a_235description;
    ent->attributes[2].aDesc = a_236consequence;
    ent->attributes[3].aDesc = a_237purpose;
}

SCLP23(Application_instance_ptr)
create_SdaiAction_method(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAction_method::get_os_typespec())
                                   SdaiAction_method;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAction_method::get_os_typespec())
//                                   SdaiAction_method;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAction_method;
}
#endif

#ifdef __O3DB__
void
SdaiAction_method::oodb_reInit ()
{	eDesc = config_control_designe_action_method;
	attributes [0].aDesc = a_234name;
	attributes [1].aDesc = a_235description;
	attributes [2].aDesc = a_236consequence;
	attributes [3].aDesc = a_237purpose;
}
#endif

SdaiAction_method::SdaiAction_method( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_action_method;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_234name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_234name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_235description,  &_description);
#else
    a = new STEPattribute(*a_235description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_236consequence,  &_consequence);
#else
    a = new STEPattribute(*a_236consequence,  &_consequence);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_237purpose,  &_purpose);
#else
    a = new STEPattribute(*a_237purpose,  &_purpose);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiAction_method::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiAction_method::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiAction_method::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiAction_method::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiText
SdaiAction_method::consequence_() const
{
    return (const SdaiText) _consequence;
}

void
SdaiAction_method::consequence_ (const SdaiText x)

{
    _consequence = x;
}

const SdaiText
SdaiAction_method::purpose_() const
{
    return (const SdaiText) _purpose;
}

void
SdaiAction_method::purpose_ (const SdaiText x)

{
    _purpose = x;
}

/////////	 END_ENTITY action_method


/////////	 ENTITY product_category_relationship

EntityDescriptor *config_control_designe_product_category_relationship =0;
AttrDescriptor *a_238name =0;
AttrDescriptor *a_239description =0;
AttrDescriptor *a_240category =0;
AttrDescriptor *a_241sub_category =0;
SdaiProduct_category_relationship::SdaiProduct_category_relationship( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_category_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_238name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_238name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_239description,  &_description);
#else
    a = new STEPattribute(*a_239description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_240category, (SCLP23(Application_instance_ptr) *) &_category);
#else
    a = new STEPattribute(*a_240category, (SCLP23(Application_instance_ptr) *) &_category);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_241sub_category, (SCLP23(Application_instance_ptr) *) &_sub_category);
#else
    a = new STEPattribute(*a_241sub_category, (SCLP23(Application_instance_ptr) *) &_sub_category);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_category_relationship::SdaiProduct_category_relationship (SdaiProduct_category_relationship& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_category_relationship::~SdaiProduct_category_relationship () {  }

#ifdef __OSTORE__

void
SdaiProduct_category_relationship::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_category_relationship: virtual access function." << endl;
    SdaiProduct_category_relationship_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_category_relationship_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_category_relationship: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_category_relationship *ent = (SdaiProduct_category_relationship *)sent;
//    SdaiProduct_category_relationship *ent = (SdaiProduct_category_relationship *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_category_relationship;
    ent->attributes[0].aDesc = a_238name;
    ent->attributes[1].aDesc = a_239description;
    ent->attributes[2].aDesc = a_240category;
    if(ent->_category == 0)
        ent->_category = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_241sub_category;
    if(ent->_sub_category == 0)
        ent->_sub_category = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_category_relationship(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_category_relationship::get_os_typespec())
                                   SdaiProduct_category_relationship;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_category_relationship::get_os_typespec())
//                                   SdaiProduct_category_relationship;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_category_relationship;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_category_relationship::oodb_reInit ()
{	eDesc = config_control_designe_product_category_relationship;
	attributes [0].aDesc = a_238name;
	attributes [1].aDesc = a_239description;
	attributes [2].aDesc = a_240category;
	attributes [3].aDesc = a_241sub_category;
}
#endif

SdaiProduct_category_relationship::SdaiProduct_category_relationship( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_product_category_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_238name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_238name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_239description,  &_description);
#else
    a = new STEPattribute(*a_239description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_240category, (SCLP23(Application_instance_ptr) *) &_category);
#else
    a = new STEPattribute(*a_240category, (SCLP23(Application_instance_ptr) *) &_category);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_241sub_category, (SCLP23(Application_instance_ptr) *) &_sub_category);
#else
    a = new STEPattribute(*a_241sub_category, (SCLP23(Application_instance_ptr) *) &_sub_category);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiProduct_category_relationship::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiProduct_category_relationship::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiProduct_category_relationship::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiProduct_category_relationship::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiProduct_category_ptr
SdaiProduct_category_relationship::category_() const
{
    return (SdaiProduct_category_ptr) _category;
}

void
SdaiProduct_category_relationship::category_ (const SdaiProduct_category_ptr x)

{
    _category = x;
}

const SdaiProduct_category_ptr
SdaiProduct_category_relationship::sub_category_() const
{
    return (SdaiProduct_category_ptr) _sub_category;
}

void
SdaiProduct_category_relationship::sub_category_ (const SdaiProduct_category_ptr x)

{
    _sub_category = x;
}

/////////	 END_ENTITY product_category_relationship


/////////	 ENTITY plane_angle_measure_with_unit

EntityDescriptor *config_control_designe_plane_angle_measure_with_unit =0;
SdaiPlane_angle_measure_with_unit::SdaiPlane_angle_measure_with_unit( )
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane_angle_measure_with_unit;
}
SdaiPlane_angle_measure_with_unit::SdaiPlane_angle_measure_with_unit (SdaiPlane_angle_measure_with_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPlane_angle_measure_with_unit::~SdaiPlane_angle_measure_with_unit () {  }

#ifdef __OSTORE__

void
SdaiPlane_angle_measure_with_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPlane_angle_measure_with_unit: virtual access function." << endl;
    SdaiPlane_angle_measure_with_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPlane_angle_measure_with_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPlane_angle_measure_with_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPlane_angle_measure_with_unit *ent = (SdaiPlane_angle_measure_with_unit *)sent;
//    SdaiPlane_angle_measure_with_unit *ent = (SdaiPlane_angle_measure_with_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_plane_angle_measure_with_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiPlane_angle_measure_with_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPlane_angle_measure_with_unit::get_os_typespec())
                                   SdaiPlane_angle_measure_with_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPlane_angle_measure_with_unit::get_os_typespec())
//                                   SdaiPlane_angle_measure_with_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPlane_angle_measure_with_unit;
}
#endif

#ifdef __O3DB__
void
SdaiPlane_angle_measure_with_unit::oodb_reInit ()
{	eDesc = config_control_designe_plane_angle_measure_with_unit;
}
#endif

SdaiPlane_angle_measure_with_unit::SdaiPlane_angle_measure_with_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiMeasure_with_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane_angle_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY plane_angle_measure_with_unit


/////////	 ENTITY vertex

EntityDescriptor *config_control_designe_vertex =0;
SdaiVertex::SdaiVertex( )
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex;
    //cout << "Vertex" << endl;
    //PrintSTEPattributes ();
}
SdaiVertex::SdaiVertex (SdaiVertex& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiVertex::~SdaiVertex () {  }

#ifdef __OSTORE__

void
SdaiVertex::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVertex: virtual access function." << endl;
    SdaiVertex_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiVertex_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVertex: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiVertex *ent = (SdaiVertex *)sent;
//    SdaiVertex *ent = (SdaiVertex *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_vertex;
}

SCLP23(Application_instance_ptr)
create_SdaiVertex(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiVertex::get_os_typespec())
                                   SdaiVertex;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiVertex::get_os_typespec())
//                                   SdaiVertex;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiVertex;
}
#endif

#ifdef __O3DB__
void
SdaiVertex::oodb_reInit ()
{	eDesc = config_control_designe_vertex;
}
#endif

SdaiVertex::SdaiVertex (SCLP23(Application_instance) *se, int *addAttrs) : SdaiTopological_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY vertex


/////////	 ENTITY representation_map

EntityDescriptor *config_control_designe_representation_map =0;
AttrDescriptor *a_242mapping_origin =0;
AttrDescriptor *a_243mapped_representation =0;
Inverse_attribute *a_244Imap_usage =0;
SdaiRepresentation_map::SdaiRepresentation_map( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_map;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_242mapping_origin, (SCLP23(Application_instance_ptr) *) &_mapping_origin);
#else
    STEPattribute *a = new STEPattribute(*a_242mapping_origin, (SCLP23(Application_instance_ptr) *) &_mapping_origin);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_243mapped_representation, (SCLP23(Application_instance_ptr) *) &_mapped_representation);
#else
    a = new STEPattribute(*a_243mapped_representation, (SCLP23(Application_instance_ptr) *) &_mapped_representation);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiRepresentation_map::SdaiRepresentation_map (SdaiRepresentation_map& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiRepresentation_map::~SdaiRepresentation_map () {  }

#ifdef __OSTORE__

void
SdaiRepresentation_map::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation_map: virtual access function." << endl;
    SdaiRepresentation_map_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiRepresentation_map_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRepresentation_map: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiRepresentation_map *ent = (SdaiRepresentation_map *)sent;
//    SdaiRepresentation_map *ent = (SdaiRepresentation_map *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_representation_map;
    ent->attributes[0].aDesc = a_242mapping_origin;
    if(ent->_mapping_origin == 0)
        ent->_mapping_origin = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_243mapped_representation;
    if(ent->_mapped_representation == 0)
        ent->_mapped_representation = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiRepresentation_map(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiRepresentation_map::get_os_typespec())
                                   SdaiRepresentation_map;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiRepresentation_map::get_os_typespec())
//                                   SdaiRepresentation_map;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiRepresentation_map;
}
#endif

#ifdef __O3DB__
void
SdaiRepresentation_map::oodb_reInit ()
{	eDesc = config_control_designe_representation_map;
	attributes [0].aDesc = a_242mapping_origin;
	attributes [1].aDesc = a_243mapped_representation;
}
#endif

SdaiRepresentation_map::SdaiRepresentation_map( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_map;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_242mapping_origin, (SCLP23(Application_instance_ptr) *) &_mapping_origin);
#else
    STEPattribute *a = new STEPattribute(*a_242mapping_origin, (SCLP23(Application_instance_ptr) *) &_mapping_origin);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_243mapped_representation, (SCLP23(Application_instance_ptr) *) &_mapped_representation);
#else
    a = new STEPattribute(*a_243mapped_representation, (SCLP23(Application_instance_ptr) *) &_mapped_representation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiRepresentation_item_ptr
SdaiRepresentation_map::mapping_origin_() const
{
    return (SdaiRepresentation_item_ptr) _mapping_origin;
}

void
SdaiRepresentation_map::mapping_origin_ (const SdaiRepresentation_item_ptr x)

{
    _mapping_origin = x;
}

const SdaiRepresentation_ptr
SdaiRepresentation_map::mapped_representation_() const
{
    return (SdaiRepresentation_ptr) _mapped_representation;
}

void
SdaiRepresentation_map::mapped_representation_ (const SdaiRepresentation_ptr x)

{
    _mapped_representation = x;
}

const EntityAggregate_ptr
SdaiRepresentation_map::map_usage_() const
{
    return (EntityAggregate_ptr) &_map_usage;
}

void
SdaiRepresentation_map::map_usage_ (const EntityAggregate_ptr x)

	{ _map_usage.ShallowCopy (*x); }

/////////	 END_ENTITY representation_map


/////////	 ENTITY product_definition_effectivity

EntityDescriptor *config_control_designe_product_definition_effectivity =0;
AttrDescriptor *a_245usage =0;
SdaiProduct_definition_effectivity::SdaiProduct_definition_effectivity( )
{

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_245usage, (SCLP23(Application_instance_ptr) *) &_usage);
#else
    STEPattribute *a = new STEPattribute(*a_245usage, (SCLP23(Application_instance_ptr) *) &_usage);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_effectivity::SdaiProduct_definition_effectivity (SdaiProduct_definition_effectivity& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_definition_effectivity::~SdaiProduct_definition_effectivity () {  }

#ifdef __OSTORE__

void
SdaiProduct_definition_effectivity::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_effectivity: virtual access function." << endl;
    SdaiProduct_definition_effectivity_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_definition_effectivity_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_effectivity: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_definition_effectivity *ent = (SdaiProduct_definition_effectivity *)sent;
//    SdaiProduct_definition_effectivity *ent = (SdaiProduct_definition_effectivity *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_definition_effectivity;
    ent->attributes[1].aDesc = a_245usage;
    if(ent->_usage == 0)
        ent->_usage = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_definition_effectivity(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_definition_effectivity::get_os_typespec())
                                   SdaiProduct_definition_effectivity;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_definition_effectivity::get_os_typespec())
//                                   SdaiProduct_definition_effectivity;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_definition_effectivity;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_definition_effectivity::oodb_reInit ()
{	eDesc = config_control_designe_product_definition_effectivity;
	attributes [1].aDesc = a_245usage;
}
#endif

SdaiProduct_definition_effectivity::SdaiProduct_definition_effectivity (SCLP23(Application_instance) *se, int *addAttrs) : SdaiEffectivity(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_245usage, (SCLP23(Application_instance_ptr) *) &_usage);
#else
    STEPattribute *a = new STEPattribute(*a_245usage, (SCLP23(Application_instance_ptr) *) &_usage);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiProduct_definition_relationship_ptr
SdaiProduct_definition_effectivity::usage_() const
{
    return (SdaiProduct_definition_relationship_ptr) _usage;
}

void
SdaiProduct_definition_effectivity::usage_ (const SdaiProduct_definition_relationship_ptr x)

{
    _usage = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_effectivity


/////////	 ENTITY configuration_effectivity

EntityDescriptor *config_control_designe_configuration_effectivity =0;
AttrDescriptor *a_246configuration =0;
SdaiConfiguration_effectivity::SdaiConfiguration_effectivity( )
{

	/*  parent: SdaiProduct_definition_effectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_configuration_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_246configuration, (SCLP23(Application_instance_ptr) *) &_configuration);
#else
    STEPattribute *a = new STEPattribute(*a_246configuration, (SCLP23(Application_instance_ptr) *) &_configuration);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiConfiguration_effectivity::SdaiConfiguration_effectivity (SdaiConfiguration_effectivity& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiConfiguration_effectivity::~SdaiConfiguration_effectivity () {  }

#ifdef __OSTORE__

void
SdaiConfiguration_effectivity::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConfiguration_effectivity: virtual access function." << endl;
    SdaiConfiguration_effectivity_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiConfiguration_effectivity_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConfiguration_effectivity: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiConfiguration_effectivity *ent = (SdaiConfiguration_effectivity *)sent;
//    SdaiConfiguration_effectivity *ent = (SdaiConfiguration_effectivity *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_configuration_effectivity;
    ent->attributes[2].aDesc = a_246configuration;
    if(ent->_configuration == 0)
        ent->_configuration = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiConfiguration_effectivity(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiConfiguration_effectivity::get_os_typespec())
                                   SdaiConfiguration_effectivity;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiConfiguration_effectivity::get_os_typespec())
//                                   SdaiConfiguration_effectivity;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiConfiguration_effectivity;
}
#endif

#ifdef __O3DB__
void
SdaiConfiguration_effectivity::oodb_reInit ()
{	eDesc = config_control_designe_configuration_effectivity;
	attributes [2].aDesc = a_246configuration;
}
#endif

SdaiConfiguration_effectivity::SdaiConfiguration_effectivity (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProduct_definition_effectivity(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProduct_definition_effectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_configuration_effectivity;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_246configuration, (SCLP23(Application_instance_ptr) *) &_configuration);
#else
    STEPattribute *a = new STEPattribute(*a_246configuration, (SCLP23(Application_instance_ptr) *) &_configuration);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiConfiguration_design_ptr
SdaiConfiguration_effectivity::configuration_() const
{
    return (SdaiConfiguration_design_ptr) _configuration;
}

void
SdaiConfiguration_effectivity::configuration_ (const SdaiConfiguration_design_ptr x)

{
    _configuration = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY configuration_effectivity


/////////	 ENTITY ellipse

EntityDescriptor *config_control_designe_ellipse =0;
AttrDescriptor *a_247semi_axis_1 =0;
AttrDescriptor *a_248semi_axis_2 =0;
SdaiEllipse::SdaiEllipse( )
{

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_ellipse;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_247semi_axis_1,  &_semi_axis_1);
#else
    STEPattribute *a = new STEPattribute(*a_247semi_axis_1,  &_semi_axis_1);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_248semi_axis_2,  &_semi_axis_2);
#else
    a = new STEPattribute(*a_248semi_axis_2,  &_semi_axis_2);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiEllipse::SdaiEllipse (SdaiEllipse& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiEllipse::~SdaiEllipse () {  }

#ifdef __OSTORE__

void
SdaiEllipse::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEllipse: virtual access function." << endl;
    SdaiEllipse_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiEllipse_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEllipse: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiEllipse *ent = (SdaiEllipse *)sent;
//    SdaiEllipse *ent = (SdaiEllipse *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_ellipse;
    ent->attributes[2].aDesc = a_247semi_axis_1;
    ent->attributes[3].aDesc = a_248semi_axis_2;
}

SCLP23(Application_instance_ptr)
create_SdaiEllipse(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiEllipse::get_os_typespec())
                                   SdaiEllipse;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiEllipse::get_os_typespec())
//                                   SdaiEllipse;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiEllipse;
}
#endif

#ifdef __O3DB__
void
SdaiEllipse::oodb_reInit ()
{	eDesc = config_control_designe_ellipse;
	attributes [2].aDesc = a_247semi_axis_1;
	attributes [3].aDesc = a_248semi_axis_2;
}
#endif

SdaiEllipse::SdaiEllipse (SCLP23(Application_instance) *se, int *addAttrs) : SdaiConic(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_ellipse;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_247semi_axis_1,  &_semi_axis_1);
#else
    STEPattribute *a = new STEPattribute(*a_247semi_axis_1,  &_semi_axis_1);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_248semi_axis_2,  &_semi_axis_2);
#else
    a = new STEPattribute(*a_248semi_axis_2,  &_semi_axis_2);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiPositive_length_measure
SdaiEllipse::semi_axis_1_() const
{
    return (const SdaiPositive_length_measure) _semi_axis_1;
}

void
SdaiEllipse::semi_axis_1_ (const SdaiPositive_length_measure x)

{
    _semi_axis_1 = x;
}

const SdaiPositive_length_measure
SdaiEllipse::semi_axis_2_() const
{
    return (const SdaiPositive_length_measure) _semi_axis_2;
}

void
SdaiEllipse::semi_axis_2_ (const SdaiPositive_length_measure x)

{
    _semi_axis_2 = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY ellipse


/////////	 ENTITY context_dependent_unit

EntityDescriptor *config_control_designe_context_dependent_unit =0;
AttrDescriptor *a_249name =0;
SdaiContext_dependent_unit::SdaiContext_dependent_unit( )
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_context_dependent_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_249name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_249name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiContext_dependent_unit::SdaiContext_dependent_unit (SdaiContext_dependent_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiContext_dependent_unit::~SdaiContext_dependent_unit () {  }

#ifdef __OSTORE__

void
SdaiContext_dependent_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiContext_dependent_unit: virtual access function." << endl;
    SdaiContext_dependent_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiContext_dependent_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiContext_dependent_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiContext_dependent_unit *ent = (SdaiContext_dependent_unit *)sent;
//    SdaiContext_dependent_unit *ent = (SdaiContext_dependent_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_context_dependent_unit;
    ent->attributes[1].aDesc = a_249name;
}

SCLP23(Application_instance_ptr)
create_SdaiContext_dependent_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiContext_dependent_unit::get_os_typespec())
                                   SdaiContext_dependent_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiContext_dependent_unit::get_os_typespec())
//                                   SdaiContext_dependent_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiContext_dependent_unit;
}
#endif

#ifdef __O3DB__
void
SdaiContext_dependent_unit::oodb_reInit ()
{	eDesc = config_control_designe_context_dependent_unit;
	attributes [1].aDesc = a_249name;
}
#endif

SdaiContext_dependent_unit::SdaiContext_dependent_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiNamed_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_context_dependent_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_249name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_249name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiContext_dependent_unit::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiContext_dependent_unit::name_ (const SdaiLabel x)

{
    _name = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY context_dependent_unit


/////////	 ENTITY alternate_product_relationship

EntityDescriptor *config_control_designe_alternate_product_relationship =0;
AttrDescriptor *a_250name =0;
AttrDescriptor *a_251definition =0;
AttrDescriptor *a_252alternate =0;
AttrDescriptor *a_253base =0;
AttrDescriptor *a_254basis =0;
SdaiAlternate_product_relationship::SdaiAlternate_product_relationship( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_alternate_product_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_250name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_250name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_251definition,  &_definition);
#else
    a = new STEPattribute(*a_251definition,  &_definition);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_252alternate, (SCLP23(Application_instance_ptr) *) &_alternate);
#else
    a = new STEPattribute(*a_252alternate, (SCLP23(Application_instance_ptr) *) &_alternate);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_253base, (SCLP23(Application_instance_ptr) *) &_base);
#else
    a = new STEPattribute(*a_253base, (SCLP23(Application_instance_ptr) *) &_base);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_254basis,  &_basis);
#else
    a = new STEPattribute(*a_254basis,  &_basis);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAlternate_product_relationship::SdaiAlternate_product_relationship (SdaiAlternate_product_relationship& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAlternate_product_relationship::~SdaiAlternate_product_relationship () {  }

#ifdef __OSTORE__

void
SdaiAlternate_product_relationship::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAlternate_product_relationship: virtual access function." << endl;
    SdaiAlternate_product_relationship_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAlternate_product_relationship_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAlternate_product_relationship: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAlternate_product_relationship *ent = (SdaiAlternate_product_relationship *)sent;
//    SdaiAlternate_product_relationship *ent = (SdaiAlternate_product_relationship *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_alternate_product_relationship;
    ent->attributes[0].aDesc = a_250name;
    ent->attributes[1].aDesc = a_251definition;
    ent->attributes[2].aDesc = a_252alternate;
    if(ent->_alternate == 0)
        ent->_alternate = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_253base;
    if(ent->_base == 0)
        ent->_base = S_ENTITY_NULL;
    ent->attributes[4].aDesc = a_254basis;
}

SCLP23(Application_instance_ptr)
create_SdaiAlternate_product_relationship(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAlternate_product_relationship::get_os_typespec())
                                   SdaiAlternate_product_relationship;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAlternate_product_relationship::get_os_typespec())
//                                   SdaiAlternate_product_relationship;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAlternate_product_relationship;
}
#endif

#ifdef __O3DB__
void
SdaiAlternate_product_relationship::oodb_reInit ()
{	eDesc = config_control_designe_alternate_product_relationship;
	attributes [0].aDesc = a_250name;
	attributes [1].aDesc = a_251definition;
	attributes [2].aDesc = a_252alternate;
	attributes [3].aDesc = a_253base;
	attributes [4].aDesc = a_254basis;
}
#endif

SdaiAlternate_product_relationship::SdaiAlternate_product_relationship( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_alternate_product_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_250name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_250name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_251definition,  &_definition);
#else
    a = new STEPattribute(*a_251definition,  &_definition);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_252alternate, (SCLP23(Application_instance_ptr) *) &_alternate);
#else
    a = new STEPattribute(*a_252alternate, (SCLP23(Application_instance_ptr) *) &_alternate);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_253base, (SCLP23(Application_instance_ptr) *) &_base);
#else
    a = new STEPattribute(*a_253base, (SCLP23(Application_instance_ptr) *) &_base);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_254basis,  &_basis);
#else
    a = new STEPattribute(*a_254basis,  &_basis);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiAlternate_product_relationship::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiAlternate_product_relationship::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiAlternate_product_relationship::definition_() const
{
    return (const SdaiText) _definition;
}

void
SdaiAlternate_product_relationship::definition_ (const SdaiText x)

{
    _definition = x;
}

const SdaiProduct_ptr
SdaiAlternate_product_relationship::alternate_() const
{
    return (SdaiProduct_ptr) _alternate;
}

void
SdaiAlternate_product_relationship::alternate_ (const SdaiProduct_ptr x)

{
    _alternate = x;
}

const SdaiProduct_ptr
SdaiAlternate_product_relationship::base_() const
{
    return (SdaiProduct_ptr) _base;
}

void
SdaiAlternate_product_relationship::base_ (const SdaiProduct_ptr x)

{
    _base = x;
}

const SdaiText
SdaiAlternate_product_relationship::basis_() const
{
    return (const SdaiText) _basis;
}

void
SdaiAlternate_product_relationship::basis_ (const SdaiText x)

{
    _basis = x;
}

/////////	 END_ENTITY alternate_product_relationship


/////////	 ENTITY document_type

EntityDescriptor *config_control_designe_document_type =0;
AttrDescriptor *a_255product_data_type =0;
SdaiDocument_type::SdaiDocument_type( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_document_type;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_255product_data_type,  &_product_data_type);
#else
    STEPattribute *a = new STEPattribute(*a_255product_data_type,  &_product_data_type);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument_type::SdaiDocument_type (SdaiDocument_type& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDocument_type::~SdaiDocument_type () {  }

#ifdef __OSTORE__

void
SdaiDocument_type::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument_type: virtual access function." << endl;
    SdaiDocument_type_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDocument_type_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument_type: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDocument_type *ent = (SdaiDocument_type *)sent;
//    SdaiDocument_type *ent = (SdaiDocument_type *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_document_type;
    ent->attributes[0].aDesc = a_255product_data_type;
}

SCLP23(Application_instance_ptr)
create_SdaiDocument_type(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDocument_type::get_os_typespec())
                                   SdaiDocument_type;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDocument_type::get_os_typespec())
//                                   SdaiDocument_type;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDocument_type;
}
#endif

#ifdef __O3DB__
void
SdaiDocument_type::oodb_reInit ()
{	eDesc = config_control_designe_document_type;
	attributes [0].aDesc = a_255product_data_type;
}
#endif

SdaiDocument_type::SdaiDocument_type( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_document_type;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_255product_data_type,  &_product_data_type);
#else
    STEPattribute *a = new STEPattribute(*a_255product_data_type,  &_product_data_type);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiDocument_type::product_data_type_() const
{
    return (const SdaiLabel) _product_data_type;
}

void
SdaiDocument_type::product_data_type_ (const SdaiLabel x)

{
    _product_data_type = x;
}

/////////	 END_ENTITY document_type


/////////	 ENTITY document_reference

EntityDescriptor *config_control_designe_document_reference =0;
AttrDescriptor *a_256assigned_document =0;
AttrDescriptor *a_257source =0;
SdaiDocument_reference::SdaiDocument_reference( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_document_reference;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_256assigned_document, (SCLP23(Application_instance_ptr) *) &_assigned_document);
#else
    STEPattribute *a = new STEPattribute(*a_256assigned_document, (SCLP23(Application_instance_ptr) *) &_assigned_document);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_257source,  &_source);
#else
    a = new STEPattribute(*a_257source,  &_source);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument_reference::SdaiDocument_reference (SdaiDocument_reference& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDocument_reference::~SdaiDocument_reference () {  }

#ifdef __OSTORE__

void
SdaiDocument_reference::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument_reference: virtual access function." << endl;
    SdaiDocument_reference_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDocument_reference_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument_reference: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDocument_reference *ent = (SdaiDocument_reference *)sent;
//    SdaiDocument_reference *ent = (SdaiDocument_reference *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_document_reference;
    ent->attributes[0].aDesc = a_256assigned_document;
    if(ent->_assigned_document == 0)
        ent->_assigned_document = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_257source;
}

SCLP23(Application_instance_ptr)
create_SdaiDocument_reference(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDocument_reference::get_os_typespec())
                                   SdaiDocument_reference;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDocument_reference::get_os_typespec())
//                                   SdaiDocument_reference;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDocument_reference;
}
#endif

#ifdef __O3DB__
void
SdaiDocument_reference::oodb_reInit ()
{	eDesc = config_control_designe_document_reference;
	attributes [0].aDesc = a_256assigned_document;
	attributes [1].aDesc = a_257source;
}
#endif

SdaiDocument_reference::SdaiDocument_reference( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_document_reference;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_256assigned_document, (SCLP23(Application_instance_ptr) *) &_assigned_document);
#else
    STEPattribute *a = new STEPattribute(*a_256assigned_document, (SCLP23(Application_instance_ptr) *) &_assigned_document);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_257source,  &_source);
#else
    a = new STEPattribute(*a_257source,  &_source);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiDocument_ptr
SdaiDocument_reference::assigned_document_() const
{
    return (SdaiDocument_ptr) _assigned_document;
}

void
SdaiDocument_reference::assigned_document_ (const SdaiDocument_ptr x)

{
    _assigned_document = x;
}

const SdaiLabel
SdaiDocument_reference::source_() const
{
    return (const SdaiLabel) _source;
}

void
SdaiDocument_reference::source_ (const SdaiLabel x)

{
    _source = x;
}

/////////	 END_ENTITY document_reference


/////////	 ENTITY mechanical_context

EntityDescriptor *config_control_designe_mechanical_context =0;
SdaiMechanical_context::SdaiMechanical_context( )
{

	/*  parent: SdaiProduct_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mechanical_context;
}
SdaiMechanical_context::SdaiMechanical_context (SdaiMechanical_context& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiMechanical_context::~SdaiMechanical_context () {  }

#ifdef __OSTORE__

void
SdaiMechanical_context::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiMechanical_context: virtual access function." << endl;
    SdaiMechanical_context_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiMechanical_context_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiMechanical_context: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiMechanical_context *ent = (SdaiMechanical_context *)sent;
//    SdaiMechanical_context *ent = (SdaiMechanical_context *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_mechanical_context;
}

SCLP23(Application_instance_ptr)
create_SdaiMechanical_context(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiMechanical_context::get_os_typespec())
                                   SdaiMechanical_context;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiMechanical_context::get_os_typespec())
//                                   SdaiMechanical_context;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiMechanical_context;
}
#endif

#ifdef __O3DB__
void
SdaiMechanical_context::oodb_reInit ()
{	eDesc = config_control_designe_mechanical_context;
}
#endif

SdaiMechanical_context::SdaiMechanical_context (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProduct_context(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProduct_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mechanical_context;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY mechanical_context


/////////	 ENTITY shell_based_wireframe_model

EntityDescriptor *config_control_designe_shell_based_wireframe_model =0;
AttrDescriptor *a_258sbwm_boundary =0;
SdaiShell_based_wireframe_model::SdaiShell_based_wireframe_model( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_wireframe_model;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_258sbwm_boundary,  &_sbwm_boundary);
#else
    STEPattribute *a = new STEPattribute(*a_258sbwm_boundary,  &_sbwm_boundary);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiShell_based_wireframe_model::SdaiShell_based_wireframe_model (SdaiShell_based_wireframe_model& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiShell_based_wireframe_model::~SdaiShell_based_wireframe_model () {  }

#ifdef __OSTORE__

void
SdaiShell_based_wireframe_model::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShell_based_wireframe_model: virtual access function." << endl;
    SdaiShell_based_wireframe_model_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiShell_based_wireframe_model_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShell_based_wireframe_model: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiShell_based_wireframe_model *ent = (SdaiShell_based_wireframe_model *)sent;
//    SdaiShell_based_wireframe_model *ent = (SdaiShell_based_wireframe_model *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_shell_based_wireframe_model;
    ent->attributes[1].aDesc = a_258sbwm_boundary;
}

SCLP23(Application_instance_ptr)
create_SdaiShell_based_wireframe_model(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiShell_based_wireframe_model::get_os_typespec())
                                   SdaiShell_based_wireframe_model;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiShell_based_wireframe_model::get_os_typespec())
//                                   SdaiShell_based_wireframe_model;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiShell_based_wireframe_model;
}
#endif

#ifdef __O3DB__
void
SdaiShell_based_wireframe_model::oodb_reInit ()
{	eDesc = config_control_designe_shell_based_wireframe_model;
	attributes [1].aDesc = a_258sbwm_boundary;
}
#endif

SdaiShell_based_wireframe_model::SdaiShell_based_wireframe_model (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_wireframe_model;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_258sbwm_boundary,  &_sbwm_boundary);
#else
    STEPattribute *a = new STEPattribute(*a_258sbwm_boundary,  &_sbwm_boundary);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiShells_ptr
SdaiShell_based_wireframe_model::sbwm_boundary_() const
{
    return (SdaiShells_ptr) &_sbwm_boundary;
}

void
SdaiShell_based_wireframe_model::sbwm_boundary_ (const SdaiShells_ptr x)

	{ _sbwm_boundary.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shell_based_wireframe_model


/////////	 ENTITY contract

EntityDescriptor *config_control_designe_contract =0;
AttrDescriptor *a_259name =0;
AttrDescriptor *a_260purpose =0;
AttrDescriptor *a_261kind =0;
SdaiContract::SdaiContract( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_contract;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_259name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_259name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_260purpose,  &_purpose);
#else
    a = new STEPattribute(*a_260purpose,  &_purpose);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_261kind, (SCLP23(Application_instance_ptr) *) &_kind);
#else
    a = new STEPattribute(*a_261kind, (SCLP23(Application_instance_ptr) *) &_kind);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiContract::SdaiContract (SdaiContract& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiContract::~SdaiContract () {  }

#ifdef __OSTORE__

void
SdaiContract::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiContract: virtual access function." << endl;
    SdaiContract_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiContract_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiContract: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiContract *ent = (SdaiContract *)sent;
//    SdaiContract *ent = (SdaiContract *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_contract;
    ent->attributes[0].aDesc = a_259name;
    ent->attributes[1].aDesc = a_260purpose;
    ent->attributes[2].aDesc = a_261kind;
    if(ent->_kind == 0)
        ent->_kind = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiContract(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiContract::get_os_typespec())
                                   SdaiContract;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiContract::get_os_typespec())
//                                   SdaiContract;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiContract;
}
#endif

#ifdef __O3DB__
void
SdaiContract::oodb_reInit ()
{	eDesc = config_control_designe_contract;
	attributes [0].aDesc = a_259name;
	attributes [1].aDesc = a_260purpose;
	attributes [2].aDesc = a_261kind;
}
#endif

SdaiContract::SdaiContract( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_contract;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_259name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_259name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_260purpose,  &_purpose);
#else
    a = new STEPattribute(*a_260purpose,  &_purpose);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_261kind, (SCLP23(Application_instance_ptr) *) &_kind);
#else
    a = new STEPattribute(*a_261kind, (SCLP23(Application_instance_ptr) *) &_kind);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiContract::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiContract::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiContract::purpose_() const
{
    return (const SdaiText) _purpose;
}

void
SdaiContract::purpose_ (const SdaiText x)

{
    _purpose = x;
}

const SdaiContract_type_ptr
SdaiContract::kind_() const
{
    return (SdaiContract_type_ptr) _kind;
}

void
SdaiContract::kind_ (const SdaiContract_type_ptr x)

{
    _kind = x;
}

/////////	 END_ENTITY contract


/////////	 ENTITY dimensional_exponents

EntityDescriptor *config_control_designe_dimensional_exponents =0;
AttrDescriptor *a_262length_exponent =0;
AttrDescriptor *a_263mass_exponent =0;
AttrDescriptor *a_264time_exponent =0;
AttrDescriptor *a_265electric_current_exponent =0;
AttrDescriptor *a_266thermodynamic_temperature_exponent =0;
AttrDescriptor *a_267amount_of_substance_exponent =0;
AttrDescriptor *a_268luminous_intensity_exponent =0;
SdaiDimensional_exponents::SdaiDimensional_exponents( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_dimensional_exponents;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_262length_exponent,  &_length_exponent);
#else
    STEPattribute *a = new STEPattribute(*a_262length_exponent,  &_length_exponent);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_263mass_exponent,  &_mass_exponent);
#else
    a = new STEPattribute(*a_263mass_exponent,  &_mass_exponent);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_264time_exponent,  &_time_exponent);
#else
    a = new STEPattribute(*a_264time_exponent,  &_time_exponent);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_265electric_current_exponent,  &_electric_current_exponent);
#else
    a = new STEPattribute(*a_265electric_current_exponent,  &_electric_current_exponent);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_266thermodynamic_temperature_exponent,  &_thermodynamic_temperature_exponent);
#else
    a = new STEPattribute(*a_266thermodynamic_temperature_exponent,  &_thermodynamic_temperature_exponent);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_267amount_of_substance_exponent,  &_amount_of_substance_exponent);
#else
    a = new STEPattribute(*a_267amount_of_substance_exponent,  &_amount_of_substance_exponent);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_268luminous_intensity_exponent,  &_luminous_intensity_exponent);
#else
    a = new STEPattribute(*a_268luminous_intensity_exponent,  &_luminous_intensity_exponent);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDimensional_exponents::SdaiDimensional_exponents (SdaiDimensional_exponents& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDimensional_exponents::~SdaiDimensional_exponents () {  }

#ifdef __OSTORE__

void
SdaiDimensional_exponents::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDimensional_exponents: virtual access function." << endl;
    SdaiDimensional_exponents_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDimensional_exponents_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDimensional_exponents: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDimensional_exponents *ent = (SdaiDimensional_exponents *)sent;
//    SdaiDimensional_exponents *ent = (SdaiDimensional_exponents *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_dimensional_exponents;
    ent->attributes[0].aDesc = a_262length_exponent;
    ent->attributes[1].aDesc = a_263mass_exponent;
    ent->attributes[2].aDesc = a_264time_exponent;
    ent->attributes[3].aDesc = a_265electric_current_exponent;
    ent->attributes[4].aDesc = a_266thermodynamic_temperature_exponent;
    ent->attributes[5].aDesc = a_267amount_of_substance_exponent;
    ent->attributes[6].aDesc = a_268luminous_intensity_exponent;
}

SCLP23(Application_instance_ptr)
create_SdaiDimensional_exponents(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDimensional_exponents::get_os_typespec())
                                   SdaiDimensional_exponents;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDimensional_exponents::get_os_typespec())
//                                   SdaiDimensional_exponents;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDimensional_exponents;
}
#endif

#ifdef __O3DB__
void
SdaiDimensional_exponents::oodb_reInit ()
{	eDesc = config_control_designe_dimensional_exponents;
	attributes [0].aDesc = a_262length_exponent;
	attributes [1].aDesc = a_263mass_exponent;
	attributes [2].aDesc = a_264time_exponent;
	attributes [3].aDesc = a_265electric_current_exponent;
	attributes [4].aDesc = a_266thermodynamic_temperature_exponent;
	attributes [5].aDesc = a_267amount_of_substance_exponent;
	attributes [6].aDesc = a_268luminous_intensity_exponent;
}
#endif

SdaiDimensional_exponents::SdaiDimensional_exponents( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_dimensional_exponents;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_262length_exponent,  &_length_exponent);
#else
    STEPattribute *a = new STEPattribute(*a_262length_exponent,  &_length_exponent);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_263mass_exponent,  &_mass_exponent);
#else
    a = new STEPattribute(*a_263mass_exponent,  &_mass_exponent);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_264time_exponent,  &_time_exponent);
#else
    a = new STEPattribute(*a_264time_exponent,  &_time_exponent);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_265electric_current_exponent,  &_electric_current_exponent);
#else
    a = new STEPattribute(*a_265electric_current_exponent,  &_electric_current_exponent);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_266thermodynamic_temperature_exponent,  &_thermodynamic_temperature_exponent);
#else
    a = new STEPattribute(*a_266thermodynamic_temperature_exponent,  &_thermodynamic_temperature_exponent);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_267amount_of_substance_exponent,  &_amount_of_substance_exponent);
#else
    a = new STEPattribute(*a_267amount_of_substance_exponent,  &_amount_of_substance_exponent);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_268luminous_intensity_exponent,  &_luminous_intensity_exponent);
#else
    a = new STEPattribute(*a_268luminous_intensity_exponent,  &_luminous_intensity_exponent);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SCLP23(Real)
SdaiDimensional_exponents::length_exponent_() const
{
    return (const SCLP23(Real)) _length_exponent;
}

void
SdaiDimensional_exponents::length_exponent_ (const SCLP23(Real) x)

{
    _length_exponent = x;
}

const SCLP23(Real)
SdaiDimensional_exponents::mass_exponent_() const
{
    return (const SCLP23(Real)) _mass_exponent;
}

void
SdaiDimensional_exponents::mass_exponent_ (const SCLP23(Real) x)

{
    _mass_exponent = x;
}

const SCLP23(Real)
SdaiDimensional_exponents::time_exponent_() const
{
    return (const SCLP23(Real)) _time_exponent;
}

void
SdaiDimensional_exponents::time_exponent_ (const SCLP23(Real) x)

{
    _time_exponent = x;
}

const SCLP23(Real)
SdaiDimensional_exponents::electric_current_exponent_() const
{
    return (const SCLP23(Real)) _electric_current_exponent;
}

void
SdaiDimensional_exponents::electric_current_exponent_ (const SCLP23(Real) x)

{
    _electric_current_exponent = x;
}

const SCLP23(Real)
SdaiDimensional_exponents::thermodynamic_temperature_exponent_() const
{
    return (const SCLP23(Real)) _thermodynamic_temperature_exponent;
}

void
SdaiDimensional_exponents::thermodynamic_temperature_exponent_ (const SCLP23(Real) x)

{
    _thermodynamic_temperature_exponent = x;
}

const SCLP23(Real)
SdaiDimensional_exponents::amount_of_substance_exponent_() const
{
    return (const SCLP23(Real)) _amount_of_substance_exponent;
}

void
SdaiDimensional_exponents::amount_of_substance_exponent_ (const SCLP23(Real) x)

{
    _amount_of_substance_exponent = x;
}

const SCLP23(Real)
SdaiDimensional_exponents::luminous_intensity_exponent_() const
{
    return (const SCLP23(Real)) _luminous_intensity_exponent;
}

void
SdaiDimensional_exponents::luminous_intensity_exponent_ (const SCLP23(Real) x)

{
    _luminous_intensity_exponent = x;
}

/////////	 END_ENTITY dimensional_exponents


/////////	 ENTITY start_request

EntityDescriptor *config_control_designe_start_request =0;
AttrDescriptor *a_269items =0;
SdaiStart_request::SdaiStart_request( )
{

	/*  parent: SdaiAction_request_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_start_request;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_269items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_269items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiStart_request::SdaiStart_request (SdaiStart_request& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiStart_request::~SdaiStart_request () {  }

#ifdef __OSTORE__

void
SdaiStart_request::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiStart_request: virtual access function." << endl;
    SdaiStart_request_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiStart_request_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiStart_request: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiStart_request *ent = (SdaiStart_request *)sent;
//    SdaiStart_request *ent = (SdaiStart_request *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_start_request;
    ent->attributes[1].aDesc = a_269items;
}

SCLP23(Application_instance_ptr)
create_SdaiStart_request(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiStart_request::get_os_typespec())
                                   SdaiStart_request;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiStart_request::get_os_typespec())
//                                   SdaiStart_request;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiStart_request;
}
#endif

#ifdef __O3DB__
void
SdaiStart_request::oodb_reInit ()
{	eDesc = config_control_designe_start_request;
	attributes [1].aDesc = a_269items;
}
#endif

SdaiStart_request::SdaiStart_request (SCLP23(Application_instance) *se, int *addAttrs) : SdaiAction_request_assignment(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiAction_request_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_start_request;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_269items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_269items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiStart_request_items_ptr
SdaiStart_request::items_() const
{
    return (SdaiStart_request_items_ptr) &_items;
}

void
SdaiStart_request::items_ (const SdaiStart_request_items_ptr x)

	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY start_request


/////////	 ENTITY cc_design_specification_reference

EntityDescriptor *config_control_designe_cc_design_specification_reference =0;
AttrDescriptor *a_270items =0;
SdaiCc_design_specification_reference::SdaiCc_design_specification_reference( )
{

	/*  parent: SdaiDocument_reference  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_specification_reference;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_270items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_270items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_specification_reference::SdaiCc_design_specification_reference (SdaiCc_design_specification_reference& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCc_design_specification_reference::~SdaiCc_design_specification_reference () {  }

#ifdef __OSTORE__

void
SdaiCc_design_specification_reference::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_specification_reference: virtual access function." << endl;
    SdaiCc_design_specification_reference_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCc_design_specification_reference_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_specification_reference: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCc_design_specification_reference *ent = (SdaiCc_design_specification_reference *)sent;
//    SdaiCc_design_specification_reference *ent = (SdaiCc_design_specification_reference *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_cc_design_specification_reference;
    ent->attributes[2].aDesc = a_270items;
}

SCLP23(Application_instance_ptr)
create_SdaiCc_design_specification_reference(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCc_design_specification_reference::get_os_typespec())
                                   SdaiCc_design_specification_reference;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCc_design_specification_reference::get_os_typespec())
//                                   SdaiCc_design_specification_reference;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCc_design_specification_reference;
}
#endif

#ifdef __O3DB__
void
SdaiCc_design_specification_reference::oodb_reInit ()
{	eDesc = config_control_designe_cc_design_specification_reference;
	attributes [2].aDesc = a_270items;
}
#endif

SdaiCc_design_specification_reference::SdaiCc_design_specification_reference (SCLP23(Application_instance) *se, int *addAttrs) : SdaiDocument_reference(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiDocument_reference  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_specification_reference;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_270items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_270items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiSpecified_items_ptr
SdaiCc_design_specification_reference::items_() const
{
    return (SdaiSpecified_items_ptr) &_items;
}

void
SdaiCc_design_specification_reference::items_ (const SdaiSpecified_items_ptr x)

	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_specification_reference


/////////	 ENTITY supplied_part_relationship

EntityDescriptor *config_control_designe_supplied_part_relationship =0;
SdaiSupplied_part_relationship::SdaiSupplied_part_relationship( )
{

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_supplied_part_relationship;
}
SdaiSupplied_part_relationship::SdaiSupplied_part_relationship (SdaiSupplied_part_relationship& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSupplied_part_relationship::~SdaiSupplied_part_relationship () {  }

#ifdef __OSTORE__

void
SdaiSupplied_part_relationship::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSupplied_part_relationship: virtual access function." << endl;
    SdaiSupplied_part_relationship_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSupplied_part_relationship_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSupplied_part_relationship: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSupplied_part_relationship *ent = (SdaiSupplied_part_relationship *)sent;
//    SdaiSupplied_part_relationship *ent = (SdaiSupplied_part_relationship *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_supplied_part_relationship;
}

SCLP23(Application_instance_ptr)
create_SdaiSupplied_part_relationship(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSupplied_part_relationship::get_os_typespec())
                                   SdaiSupplied_part_relationship;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSupplied_part_relationship::get_os_typespec())
//                                   SdaiSupplied_part_relationship;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSupplied_part_relationship;
}
#endif

#ifdef __O3DB__
void
SdaiSupplied_part_relationship::oodb_reInit ()
{	eDesc = config_control_designe_supplied_part_relationship;
}
#endif

SdaiSupplied_part_relationship::SdaiSupplied_part_relationship (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProduct_definition_relationship(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_supplied_part_relationship;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY supplied_part_relationship


/////////	 ENTITY context_dependent_shape_representation

EntityDescriptor *config_control_designe_context_dependent_shape_representation =0;
AttrDescriptor *a_271representation_relation =0;
AttrDescriptor *a_272represented_product_relation =0;
SdaiContext_dependent_shape_representation::SdaiContext_dependent_shape_representation( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_context_dependent_shape_representation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_271representation_relation, (SCLP23(Application_instance_ptr) *) &_representation_relation);
#else
    STEPattribute *a = new STEPattribute(*a_271representation_relation, (SCLP23(Application_instance_ptr) *) &_representation_relation);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_272represented_product_relation, (SCLP23(Application_instance_ptr) *) &_represented_product_relation);
#else
    a = new STEPattribute(*a_272represented_product_relation, (SCLP23(Application_instance_ptr) *) &_represented_product_relation);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiContext_dependent_shape_representation::SdaiContext_dependent_shape_representation (SdaiContext_dependent_shape_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiContext_dependent_shape_representation::~SdaiContext_dependent_shape_representation () {  }

#ifdef __OSTORE__

void
SdaiContext_dependent_shape_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiContext_dependent_shape_representation: virtual access function." << endl;
    SdaiContext_dependent_shape_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiContext_dependent_shape_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiContext_dependent_shape_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiContext_dependent_shape_representation *ent = (SdaiContext_dependent_shape_representation *)sent;
//    SdaiContext_dependent_shape_representation *ent = (SdaiContext_dependent_shape_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_context_dependent_shape_representation;
    ent->attributes[0].aDesc = a_271representation_relation;
    if(ent->_representation_relation == 0)
        ent->_representation_relation = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_272represented_product_relation;
    if(ent->_represented_product_relation == 0)
        ent->_represented_product_relation = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiContext_dependent_shape_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiContext_dependent_shape_representation::get_os_typespec())
                                   SdaiContext_dependent_shape_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiContext_dependent_shape_representation::get_os_typespec())
//                                   SdaiContext_dependent_shape_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiContext_dependent_shape_representation;
}
#endif

#ifdef __O3DB__
void
SdaiContext_dependent_shape_representation::oodb_reInit ()
{	eDesc = config_control_designe_context_dependent_shape_representation;
	attributes [0].aDesc = a_271representation_relation;
	attributes [1].aDesc = a_272represented_product_relation;
}
#endif

SdaiContext_dependent_shape_representation::SdaiContext_dependent_shape_representation( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_context_dependent_shape_representation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_271representation_relation, (SCLP23(Application_instance_ptr) *) &_representation_relation);
#else
    STEPattribute *a = new STEPattribute(*a_271representation_relation, (SCLP23(Application_instance_ptr) *) &_representation_relation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_272represented_product_relation, (SCLP23(Application_instance_ptr) *) &_represented_product_relation);
#else
    a = new STEPattribute(*a_272represented_product_relation, (SCLP23(Application_instance_ptr) *) &_represented_product_relation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiShape_representation_relationship_ptr
SdaiContext_dependent_shape_representation::representation_relation_() const
{
    return (SdaiShape_representation_relationship_ptr) _representation_relation;
}

void
SdaiContext_dependent_shape_representation::representation_relation_ (const SdaiShape_representation_relationship_ptr x)

{
    _representation_relation = x;
}

const SdaiProduct_definition_shape_ptr
SdaiContext_dependent_shape_representation::represented_product_relation_() const
{
    return (SdaiProduct_definition_shape_ptr) _represented_product_relation;
}

void
SdaiContext_dependent_shape_representation::represented_product_relation_ (const SdaiProduct_definition_shape_ptr x)

{
    _represented_product_relation = x;
}

/////////	 END_ENTITY context_dependent_shape_representation


/////////	 ENTITY degenerate_toroidal_surface

EntityDescriptor *config_control_designe_degenerate_toroidal_surface =0;
AttrDescriptor *a_273select_outer =0;
SdaiDegenerate_toroidal_surface::SdaiDegenerate_toroidal_surface( )
{

	/*  parent: SdaiToroidal_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_degenerate_toroidal_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_273select_outer,  &_select_outer);
#else
    STEPattribute *a = new STEPattribute(*a_273select_outer,  &_select_outer);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiDegenerate_toroidal_surface::SdaiDegenerate_toroidal_surface (SdaiDegenerate_toroidal_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDegenerate_toroidal_surface::~SdaiDegenerate_toroidal_surface () {  }

#ifdef __OSTORE__

void
SdaiDegenerate_toroidal_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDegenerate_toroidal_surface: virtual access function." << endl;
    SdaiDegenerate_toroidal_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDegenerate_toroidal_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDegenerate_toroidal_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDegenerate_toroidal_surface *ent = (SdaiDegenerate_toroidal_surface *)sent;
//    SdaiDegenerate_toroidal_surface *ent = (SdaiDegenerate_toroidal_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_degenerate_toroidal_surface;
    ent->attributes[4].aDesc = a_273select_outer;
}

SCLP23(Application_instance_ptr)
create_SdaiDegenerate_toroidal_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDegenerate_toroidal_surface::get_os_typespec())
                                   SdaiDegenerate_toroidal_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDegenerate_toroidal_surface::get_os_typespec())
//                                   SdaiDegenerate_toroidal_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDegenerate_toroidal_surface;
}
#endif

#ifdef __O3DB__
void
SdaiDegenerate_toroidal_surface::oodb_reInit ()
{	eDesc = config_control_designe_degenerate_toroidal_surface;
	attributes [4].aDesc = a_273select_outer;
}
#endif

SdaiDegenerate_toroidal_surface::SdaiDegenerate_toroidal_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiToroidal_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiToroidal_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_degenerate_toroidal_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_273select_outer,  &_select_outer);
#else
    STEPattribute *a = new STEPattribute(*a_273select_outer,  &_select_outer);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SCLBOOL(Bool)
SdaiDegenerate_toroidal_surface::select_outer_() const
{
    return (SCLBOOL(Bool)) _select_outer;
}

void
SdaiDegenerate_toroidal_surface::select_outer_ (const SCLBOOL(Bool) x)

{
    _select_outer.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY degenerate_toroidal_surface


/////////	 ENTITY ordinal_date

EntityDescriptor *config_control_designe_ordinal_date =0;
AttrDescriptor *a_274day_component =0;
SdaiOrdinal_date::SdaiOrdinal_date( )
{

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_ordinal_date;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_274day_component,  &_day_component);
#else
    STEPattribute *a = new STEPattribute(*a_274day_component,  &_day_component);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiOrdinal_date::SdaiOrdinal_date (SdaiOrdinal_date& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOrdinal_date::~SdaiOrdinal_date () {  }

#ifdef __OSTORE__

void
SdaiOrdinal_date::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOrdinal_date: virtual access function." << endl;
    SdaiOrdinal_date_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOrdinal_date_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOrdinal_date: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOrdinal_date *ent = (SdaiOrdinal_date *)sent;
//    SdaiOrdinal_date *ent = (SdaiOrdinal_date *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_ordinal_date;
    ent->attributes[1].aDesc = a_274day_component;
}

SCLP23(Application_instance_ptr)
create_SdaiOrdinal_date(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOrdinal_date::get_os_typespec())
                                   SdaiOrdinal_date;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOrdinal_date::get_os_typespec())
//                                   SdaiOrdinal_date;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOrdinal_date;
}
#endif

#ifdef __O3DB__
void
SdaiOrdinal_date::oodb_reInit ()
{	eDesc = config_control_designe_ordinal_date;
	attributes [1].aDesc = a_274day_component;
}
#endif

SdaiOrdinal_date::SdaiOrdinal_date (SCLP23(Application_instance) *se, int *addAttrs) : SdaiDate(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_ordinal_date;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_274day_component,  &_day_component);
#else
    STEPattribute *a = new STEPattribute(*a_274day_component,  &_day_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiDay_in_year_number
SdaiOrdinal_date::day_component_() const
{
    return (const SdaiDay_in_year_number) _day_component;
}

void
SdaiOrdinal_date::day_component_ (const SdaiDay_in_year_number x)

{
    _day_component = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY ordinal_date


/////////	 ENTITY face_outer_bound

EntityDescriptor *config_control_designe_face_outer_bound =0;
SdaiFace_outer_bound::SdaiFace_outer_bound( )
{

	/*  parent: SdaiFace_bound  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face_outer_bound;
}
SdaiFace_outer_bound::SdaiFace_outer_bound (SdaiFace_outer_bound& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiFace_outer_bound::~SdaiFace_outer_bound () {  }

#ifdef __OSTORE__

void
SdaiFace_outer_bound::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFace_outer_bound: virtual access function." << endl;
    SdaiFace_outer_bound_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiFace_outer_bound_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFace_outer_bound: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiFace_outer_bound *ent = (SdaiFace_outer_bound *)sent;
//    SdaiFace_outer_bound *ent = (SdaiFace_outer_bound *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_face_outer_bound;
}

SCLP23(Application_instance_ptr)
create_SdaiFace_outer_bound(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiFace_outer_bound::get_os_typespec())
                                   SdaiFace_outer_bound;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiFace_outer_bound::get_os_typespec())
//                                   SdaiFace_outer_bound;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiFace_outer_bound;
}
#endif

#ifdef __O3DB__
void
SdaiFace_outer_bound::oodb_reInit ()
{	eDesc = config_control_designe_face_outer_bound;
}
#endif

SdaiFace_outer_bound::SdaiFace_outer_bound (SCLP23(Application_instance) *se, int *addAttrs) : SdaiFace_bound(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiFace_bound  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face_outer_bound;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY face_outer_bound


/////////	 ENTITY mass_measure_with_unit

EntityDescriptor *config_control_designe_mass_measure_with_unit =0;
SdaiMass_measure_with_unit::SdaiMass_measure_with_unit( )
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mass_measure_with_unit;
}
SdaiMass_measure_with_unit::SdaiMass_measure_with_unit (SdaiMass_measure_with_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiMass_measure_with_unit::~SdaiMass_measure_with_unit () {  }

#ifdef __OSTORE__

void
SdaiMass_measure_with_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiMass_measure_with_unit: virtual access function." << endl;
    SdaiMass_measure_with_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiMass_measure_with_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiMass_measure_with_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiMass_measure_with_unit *ent = (SdaiMass_measure_with_unit *)sent;
//    SdaiMass_measure_with_unit *ent = (SdaiMass_measure_with_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_mass_measure_with_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiMass_measure_with_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiMass_measure_with_unit::get_os_typespec())
                                   SdaiMass_measure_with_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiMass_measure_with_unit::get_os_typespec())
//                                   SdaiMass_measure_with_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiMass_measure_with_unit;
}
#endif

#ifdef __O3DB__
void
SdaiMass_measure_with_unit::oodb_reInit ()
{	eDesc = config_control_designe_mass_measure_with_unit;
}
#endif

SdaiMass_measure_with_unit::SdaiMass_measure_with_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiMeasure_with_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mass_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY mass_measure_with_unit


/////////	 ENTITY brep_with_voids

EntityDescriptor *config_control_designe_brep_with_voids =0;
AttrDescriptor *a_275voids =0;
SdaiBrep_with_voids::SdaiBrep_with_voids( )
{

	/*  parent: SdaiManifold_solid_brep  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_brep_with_voids;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_275voids,  &_voids);
#else
    STEPattribute *a = new STEPattribute(*a_275voids,  &_voids);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiBrep_with_voids::SdaiBrep_with_voids (SdaiBrep_with_voids& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiBrep_with_voids::~SdaiBrep_with_voids () {  }

#ifdef __OSTORE__

void
SdaiBrep_with_voids::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBrep_with_voids: virtual access function." << endl;
    SdaiBrep_with_voids_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiBrep_with_voids_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBrep_with_voids: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiBrep_with_voids *ent = (SdaiBrep_with_voids *)sent;
//    SdaiBrep_with_voids *ent = (SdaiBrep_with_voids *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_brep_with_voids;
    ent->attributes[2].aDesc = a_275voids;
}

SCLP23(Application_instance_ptr)
create_SdaiBrep_with_voids(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiBrep_with_voids::get_os_typespec())
                                   SdaiBrep_with_voids;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiBrep_with_voids::get_os_typespec())
//                                   SdaiBrep_with_voids;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiBrep_with_voids;
}
#endif

#ifdef __O3DB__
void
SdaiBrep_with_voids::oodb_reInit ()
{	eDesc = config_control_designe_brep_with_voids;
	attributes [2].aDesc = a_275voids;
}
#endif

SdaiBrep_with_voids::SdaiBrep_with_voids (SCLP23(Application_instance) *se, int *addAttrs) : SdaiManifold_solid_brep(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiManifold_solid_brep  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_brep_with_voids;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_275voids,  &_voids);
#else
    STEPattribute *a = new STEPattribute(*a_275voids,  &_voids);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const EntityAggregate_ptr
SdaiBrep_with_voids::voids_() const
{
    return (EntityAggregate_ptr) &_voids;
}

void
SdaiBrep_with_voids::voids_ (const EntityAggregate_ptr x)

	{ _voids.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY brep_with_voids


/////////	 ENTITY week_of_year_and_day_date

EntityDescriptor *config_control_designe_week_of_year_and_day_date =0;
AttrDescriptor *a_276week_component =0;
AttrDescriptor *a_277day_component =0;
SdaiWeek_of_year_and_day_date::SdaiWeek_of_year_and_day_date( )
{

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_week_of_year_and_day_date;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_276week_component,  &_week_component);
#else
    STEPattribute *a = new STEPattribute(*a_276week_component,  &_week_component);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_277day_component,  &_day_component);
#else
    a = new STEPattribute(*a_277day_component,  &_day_component);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiWeek_of_year_and_day_date::SdaiWeek_of_year_and_day_date (SdaiWeek_of_year_and_day_date& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiWeek_of_year_and_day_date::~SdaiWeek_of_year_and_day_date () {  }

#ifdef __OSTORE__

void
SdaiWeek_of_year_and_day_date::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiWeek_of_year_and_day_date: virtual access function." << endl;
    SdaiWeek_of_year_and_day_date_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiWeek_of_year_and_day_date_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiWeek_of_year_and_day_date: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiWeek_of_year_and_day_date *ent = (SdaiWeek_of_year_and_day_date *)sent;
//    SdaiWeek_of_year_and_day_date *ent = (SdaiWeek_of_year_and_day_date *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_week_of_year_and_day_date;
    ent->attributes[1].aDesc = a_276week_component;
    ent->attributes[2].aDesc = a_277day_component;
}

SCLP23(Application_instance_ptr)
create_SdaiWeek_of_year_and_day_date(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiWeek_of_year_and_day_date::get_os_typespec())
                                   SdaiWeek_of_year_and_day_date;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiWeek_of_year_and_day_date::get_os_typespec())
//                                   SdaiWeek_of_year_and_day_date;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiWeek_of_year_and_day_date;
}
#endif

#ifdef __O3DB__
void
SdaiWeek_of_year_and_day_date::oodb_reInit ()
{	eDesc = config_control_designe_week_of_year_and_day_date;
	attributes [1].aDesc = a_276week_component;
	attributes [2].aDesc = a_277day_component;
}
#endif

SdaiWeek_of_year_and_day_date::SdaiWeek_of_year_and_day_date (SCLP23(Application_instance) *se, int *addAttrs) : SdaiDate(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_week_of_year_and_day_date;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_276week_component,  &_week_component);
#else
    STEPattribute *a = new STEPattribute(*a_276week_component,  &_week_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_277day_component,  &_day_component);
#else
    a = new STEPattribute(*a_277day_component,  &_day_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiWeek_in_year_number
SdaiWeek_of_year_and_day_date::week_component_() const
{
    return (const SdaiWeek_in_year_number) _week_component;
}

void
SdaiWeek_of_year_and_day_date::week_component_ (const SdaiWeek_in_year_number x)

{
    _week_component = x;
}

const SdaiDay_in_week_number
SdaiWeek_of_year_and_day_date::day_component_() const
{
    return (const SdaiDay_in_week_number) _day_component;
}

void
SdaiWeek_of_year_and_day_date::day_component_ (const SdaiDay_in_week_number x)

{
    _day_component = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY week_of_year_and_day_date


/////////	 ENTITY point_on_curve

EntityDescriptor *config_control_designe_point_on_curve =0;
AttrDescriptor *a_278basis_curve =0;
AttrDescriptor *a_279point_parameter =0;
SdaiPoint_on_curve::SdaiPoint_on_curve( )
{

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_on_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_278basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#else
    STEPattribute *a = new STEPattribute(*a_278basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_279point_parameter,  &_point_parameter);
#else
    a = new STEPattribute(*a_279point_parameter,  &_point_parameter);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiPoint_on_curve::SdaiPoint_on_curve (SdaiPoint_on_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPoint_on_curve::~SdaiPoint_on_curve () {  }

#ifdef __OSTORE__

void
SdaiPoint_on_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPoint_on_curve: virtual access function." << endl;
    SdaiPoint_on_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPoint_on_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPoint_on_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPoint_on_curve *ent = (SdaiPoint_on_curve *)sent;
//    SdaiPoint_on_curve *ent = (SdaiPoint_on_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_point_on_curve;
    ent->attributes[1].aDesc = a_278basis_curve;
    if(ent->_basis_curve == 0)
        ent->_basis_curve = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_279point_parameter;
}

SCLP23(Application_instance_ptr)
create_SdaiPoint_on_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPoint_on_curve::get_os_typespec())
                                   SdaiPoint_on_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPoint_on_curve::get_os_typespec())
//                                   SdaiPoint_on_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPoint_on_curve;
}
#endif

#ifdef __O3DB__
void
SdaiPoint_on_curve::oodb_reInit ()
{	eDesc = config_control_designe_point_on_curve;
	attributes [1].aDesc = a_278basis_curve;
	attributes [2].aDesc = a_279point_parameter;
}
#endif

SdaiPoint_on_curve::SdaiPoint_on_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiPoint(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_on_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_278basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#else
    STEPattribute *a = new STEPattribute(*a_278basis_curve, (SCLP23(Application_instance_ptr) *) &_basis_curve);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_279point_parameter,  &_point_parameter);
#else
    a = new STEPattribute(*a_279point_parameter,  &_point_parameter);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiCurve_ptr
SdaiPoint_on_curve::basis_curve_() const
{
    return (SdaiCurve_ptr) _basis_curve;
}

void
SdaiPoint_on_curve::basis_curve_ (const SdaiCurve_ptr x)

{
    _basis_curve = x;
}

const SdaiParameter_value
SdaiPoint_on_curve::point_parameter_() const
{
    return (const SdaiParameter_value) _point_parameter;
}

void
SdaiPoint_on_curve::point_parameter_ (const SdaiParameter_value x)

{
    _point_parameter = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY point_on_curve


/////////	 ENTITY shell_based_wireframe_shape_representation

EntityDescriptor *config_control_designe_shell_based_wireframe_shape_representation =0;
SdaiShell_based_wireframe_shape_representation::SdaiShell_based_wireframe_shape_representation( )
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_wireframe_shape_representation;
}
SdaiShell_based_wireframe_shape_representation::SdaiShell_based_wireframe_shape_representation (SdaiShell_based_wireframe_shape_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiShell_based_wireframe_shape_representation::~SdaiShell_based_wireframe_shape_representation () {  }

#ifdef __OSTORE__

void
SdaiShell_based_wireframe_shape_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShell_based_wireframe_shape_representation: virtual access function." << endl;
    SdaiShell_based_wireframe_shape_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiShell_based_wireframe_shape_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShell_based_wireframe_shape_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiShell_based_wireframe_shape_representation *ent = (SdaiShell_based_wireframe_shape_representation *)sent;
//    SdaiShell_based_wireframe_shape_representation *ent = (SdaiShell_based_wireframe_shape_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_shell_based_wireframe_shape_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiShell_based_wireframe_shape_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiShell_based_wireframe_shape_representation::get_os_typespec())
                                   SdaiShell_based_wireframe_shape_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiShell_based_wireframe_shape_representation::get_os_typespec())
//                                   SdaiShell_based_wireframe_shape_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiShell_based_wireframe_shape_representation;
}
#endif

#ifdef __O3DB__
void
SdaiShell_based_wireframe_shape_representation::oodb_reInit ()
{	eDesc = config_control_designe_shell_based_wireframe_shape_representation;
}
#endif

SdaiShell_based_wireframe_shape_representation::SdaiShell_based_wireframe_shape_representation (SCLP23(Application_instance) *se, int *addAttrs) : SdaiShape_representation(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_wireframe_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shell_based_wireframe_shape_representation


/////////	 ENTITY face

EntityDescriptor *config_control_designe_face =0;
AttrDescriptor *a_280bounds =0;
SdaiFace::SdaiFace( )
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_280bounds,  &_bounds);
#else
    STEPattribute *a = new STEPattribute(*a_280bounds,  &_bounds);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiFace::SdaiFace (SdaiFace& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiFace::~SdaiFace () {  }

#ifdef __OSTORE__

void
SdaiFace::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFace: virtual access function." << endl;
    SdaiFace_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiFace_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFace: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiFace *ent = (SdaiFace *)sent;
//    SdaiFace *ent = (SdaiFace *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_face;
    ent->attributes[1].aDesc = a_280bounds;
}

SCLP23(Application_instance_ptr)
create_SdaiFace(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiFace::get_os_typespec())
                                   SdaiFace;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiFace::get_os_typespec())
//                                   SdaiFace;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiFace;
}
#endif

#ifdef __O3DB__
void
SdaiFace::oodb_reInit ()
{	eDesc = config_control_designe_face;
	attributes [1].aDesc = a_280bounds;
}
#endif

SdaiFace::SdaiFace (SCLP23(Application_instance) *se, int *addAttrs) : SdaiTopological_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_280bounds,  &_bounds);
#else
    STEPattribute *a = new STEPattribute(*a_280bounds,  &_bounds);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const EntityAggregate_ptr
SdaiFace::bounds_() const
{
    return (EntityAggregate_ptr) &_bounds;
}

void
SdaiFace::bounds_ (const EntityAggregate_ptr x)

	{ _bounds.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY face


/////////	 ENTITY face_surface

EntityDescriptor *config_control_designe_face_surface =0;
AttrDescriptor *a_281face_geometry =0;
AttrDescriptor *a_282same_sense =0;
SdaiFace_surface::SdaiFace_surface( )
{

	/*  parent: SdaiFace  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    HeadEntity(this);
//    cout << "**** face_surface ****" << endl;
//    PrintSTEPattributes();
#if 1
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 0; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    AppendMultInstance(new SdaiGeometric_representation_item(this, attrFlags));
#else
    AppendMultInstance(new SdaiGeometric_representation_item(this));
#endif
//    cout << "**** face_surface - after append****" << endl;
//    PrintSTEPattributes();

    eDesc = config_control_designe_face_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_281face_geometry, (SCLP23(Application_instance_ptr) *) &_face_geometry);
#else
    STEPattribute *a = new STEPattribute(*a_281face_geometry, (SCLP23(Application_instance_ptr) *) &_face_geometry);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_282same_sense,  &_same_sense);
#else
    a = new STEPattribute(*a_282same_sense,  &_same_sense);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
//    cout << "**** face_surface - at end ****" << endl;
//    PrintSTEPattributes();
}
SdaiFace_surface::SdaiFace_surface (SdaiFace_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiFace_surface::~SdaiFace_surface () {  }

#ifdef __OSTORE__

void
SdaiFace_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFace_surface: virtual access function." << endl;
    SdaiFace_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiFace_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFace_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiFace_surface *ent = (SdaiFace_surface *)sent;
//    SdaiFace_surface *ent = (SdaiFace_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_face_surface;
    ent->attributes[3].aDesc = a_281face_geometry;
    if(ent->_face_geometry == 0)
        ent->_face_geometry = S_ENTITY_NULL;
    ent->attributes[4].aDesc = a_282same_sense;
}

SCLP23(Application_instance_ptr)
create_SdaiFace_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiFace_surface::get_os_typespec())
                                   SdaiFace_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiFace_surface::get_os_typespec())
//                                   SdaiFace_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiFace_surface;
}
#endif

#ifdef __O3DB__
void
SdaiFace_surface::oodb_reInit ()
{	eDesc = config_control_designe_face_surface;
	attributes [3].aDesc = a_281face_geometry;
	attributes [4].aDesc = a_282same_sense;
}
#endif

SdaiFace_surface::SdaiFace_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiFace(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiFace  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    se->AppendMultInstance(new SdaiGeometric_representation_item(se, attrFlags));
#endif
    se->AppendMultInstance(new SdaiGeometric_representation_item(se, 0));

    eDesc = config_control_designe_face_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_281face_geometry, (SCLP23(Application_instance_ptr) *) &_face_geometry);
#else
    STEPattribute *a = new STEPattribute(*a_281face_geometry, (SCLP23(Application_instance_ptr) *) &_face_geometry);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_282same_sense,  &_same_sense);
#else
    a = new STEPattribute(*a_282same_sense,  &_same_sense);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiSurface_ptr
SdaiFace_surface::face_geometry_() const
{
    return (SdaiSurface_ptr) _face_geometry;
}

void
SdaiFace_surface::face_geometry_ (const SdaiSurface_ptr x)

{
    _face_geometry = x;
}

const SCLBOOL(Bool)
SdaiFace_surface::same_sense_() const
{
    return (SCLBOOL(Bool)) _same_sense;
}

void
SdaiFace_surface::same_sense_ (const SCLBOOL(Bool) x)

{
    _same_sense.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

#endif

/////////	 END_ENTITY face_surface


/////////	 ENTITY oriented_face

EntityDescriptor *config_control_designe_oriented_face =0;
AttrDescriptor *a_283face_element =0;
AttrDescriptor *a_284orientation =0;
Derived_attribute *a_285Dface_bounds =0;
SdaiOriented_face::SdaiOriented_face( )
{

	/*  parent: SdaiFace  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_face;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_283face_element, (SCLP23(Application_instance_ptr) *) &_face_element);
#else
    STEPattribute *a = new STEPattribute(*a_283face_element, (SCLP23(Application_instance_ptr) *) &_face_element);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_284orientation,  &_orientation);
#else
    a = new STEPattribute(*a_284orientation,  &_orientation);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("bounds");
}
SdaiOriented_face::SdaiOriented_face (SdaiOriented_face& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOriented_face::~SdaiOriented_face () {  }

#ifdef __OSTORE__

void
SdaiOriented_face::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOriented_face: virtual access function." << endl;
    SdaiOriented_face_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOriented_face_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOriented_face: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOriented_face *ent = (SdaiOriented_face *)sent;
//    SdaiOriented_face *ent = (SdaiOriented_face *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_oriented_face;
    ent->attributes[2].aDesc = a_283face_element;
    if(ent->_face_element == 0)
        ent->_face_element = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_284orientation;
}

SCLP23(Application_instance_ptr)
create_SdaiOriented_face(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOriented_face::get_os_typespec())
                                   SdaiOriented_face;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOriented_face::get_os_typespec())
//                                   SdaiOriented_face;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOriented_face;
}
#endif

#ifdef __O3DB__
void
SdaiOriented_face::oodb_reInit ()
{	eDesc = config_control_designe_oriented_face;
	attributes [2].aDesc = a_283face_element;
	attributes [3].aDesc = a_284orientation;
}
#endif

SdaiOriented_face::SdaiOriented_face (SCLP23(Application_instance) *se, int *addAttrs) : SdaiFace(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiFace  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_face;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_283face_element, (SCLP23(Application_instance_ptr) *) &_face_element);
#else
    STEPattribute *a = new STEPattribute(*a_283face_element, (SCLP23(Application_instance_ptr) *) &_face_element);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_284orientation,  &_orientation);
#else
    a = new STEPattribute(*a_284orientation,  &_orientation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("bounds");
}

const SdaiFace_ptr
SdaiOriented_face::face_element_() const
{
    return (SdaiFace_ptr) _face_element;
}

void
SdaiOriented_face::face_element_ (const SdaiFace_ptr x)

{
    _face_element = x;
}

const SCLBOOL(Bool)
SdaiOriented_face::orientation_() const
{
    return (SCLBOOL(Bool)) _orientation;
}

void
SdaiOriented_face::orientation_ (const SCLBOOL(Bool) x)

{
    _orientation.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY oriented_face


/////////	 ENTITY surface_of_revolution

EntityDescriptor *config_control_designe_surface_of_revolution =0;
AttrDescriptor *a_286axis_position =0;
Derived_attribute *a_287Daxis_line =0;
SdaiSurface_of_revolution::SdaiSurface_of_revolution( )
{

	/*  parent: SdaiSwept_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_of_revolution;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_286axis_position, (SCLP23(Application_instance_ptr) *) &_axis_position);
#else
    STEPattribute *a = new STEPattribute(*a_286axis_position, (SCLP23(Application_instance_ptr) *) &_axis_position);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("axis_line");
}
SdaiSurface_of_revolution::SdaiSurface_of_revolution (SdaiSurface_of_revolution& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSurface_of_revolution::~SdaiSurface_of_revolution () {  }

#ifdef __OSTORE__

void
SdaiSurface_of_revolution::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface_of_revolution: virtual access function." << endl;
    SdaiSurface_of_revolution_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSurface_of_revolution_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface_of_revolution: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSurface_of_revolution *ent = (SdaiSurface_of_revolution *)sent;
//    SdaiSurface_of_revolution *ent = (SdaiSurface_of_revolution *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_surface_of_revolution;
    ent->attributes[2].aDesc = a_286axis_position;
    if(ent->_axis_position == 0)
        ent->_axis_position = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiSurface_of_revolution(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSurface_of_revolution::get_os_typespec())
                                   SdaiSurface_of_revolution;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSurface_of_revolution::get_os_typespec())
//                                   SdaiSurface_of_revolution;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSurface_of_revolution;
}
#endif

#ifdef __O3DB__
void
SdaiSurface_of_revolution::oodb_reInit ()
{	eDesc = config_control_designe_surface_of_revolution;
	attributes [2].aDesc = a_286axis_position;
}
#endif

SdaiSurface_of_revolution::SdaiSurface_of_revolution (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSwept_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSwept_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_of_revolution;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_286axis_position, (SCLP23(Application_instance_ptr) *) &_axis_position);
#else
    STEPattribute *a = new STEPattribute(*a_286axis_position, (SCLP23(Application_instance_ptr) *) &_axis_position);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("axis_line");
}

const SdaiAxis1_placement_ptr
SdaiSurface_of_revolution::axis_position_() const
{
    return (SdaiAxis1_placement_ptr) _axis_position;
}

void
SdaiSurface_of_revolution::axis_position_ (const SdaiAxis1_placement_ptr x)

{
    _axis_position = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY surface_of_revolution


/////////	 ENTITY advanced_brep_shape_representation

EntityDescriptor *config_control_designe_advanced_brep_shape_representation =0;
SdaiAdvanced_brep_shape_representation::SdaiAdvanced_brep_shape_representation( )
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_advanced_brep_shape_representation;
}
SdaiAdvanced_brep_shape_representation::SdaiAdvanced_brep_shape_representation (SdaiAdvanced_brep_shape_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAdvanced_brep_shape_representation::~SdaiAdvanced_brep_shape_representation () {  }

#ifdef __OSTORE__

void
SdaiAdvanced_brep_shape_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAdvanced_brep_shape_representation: virtual access function." << endl;
    SdaiAdvanced_brep_shape_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAdvanced_brep_shape_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAdvanced_brep_shape_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAdvanced_brep_shape_representation *ent = (SdaiAdvanced_brep_shape_representation *)sent;
//    SdaiAdvanced_brep_shape_representation *ent = (SdaiAdvanced_brep_shape_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_advanced_brep_shape_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiAdvanced_brep_shape_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAdvanced_brep_shape_representation::get_os_typespec())
                                   SdaiAdvanced_brep_shape_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAdvanced_brep_shape_representation::get_os_typespec())
//                                   SdaiAdvanced_brep_shape_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAdvanced_brep_shape_representation;
}
#endif

#ifdef __O3DB__
void
SdaiAdvanced_brep_shape_representation::oodb_reInit ()
{	eDesc = config_control_designe_advanced_brep_shape_representation;
}
#endif

SdaiAdvanced_brep_shape_representation::SdaiAdvanced_brep_shape_representation (SCLP23(Application_instance) *se, int *addAttrs) : SdaiShape_representation(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_advanced_brep_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY advanced_brep_shape_representation


/////////	 ENTITY edge_curve

EntityDescriptor *config_control_designe_edge_curve =0;
AttrDescriptor *a_288edge_geometry =0;
AttrDescriptor *a_289same_sense =0;
SdaiEdge_curve::SdaiEdge_curve( )
{

	/*  parent: SdaiEdge  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    HeadEntity(this);
#if 1
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 0; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    AppendMultInstance(new SdaiGeometric_representation_item(this, attrFlags));
#else
    AppendMultInstance(new SdaiGeometric_representation_item(this));
#endif

    eDesc = config_control_designe_edge_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_288edge_geometry, (SCLP23(Application_instance_ptr) *) &_edge_geometry);
#else
    STEPattribute *a = new STEPattribute(*a_288edge_geometry, (SCLP23(Application_instance_ptr) *) &_edge_geometry);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_289same_sense,  &_same_sense);
#else
    a = new STEPattribute(*a_289same_sense,  &_same_sense);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiEdge_curve::SdaiEdge_curve (SdaiEdge_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiEdge_curve::~SdaiEdge_curve () {  }

#ifdef __OSTORE__

void
SdaiEdge_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEdge_curve: virtual access function." << endl;
    SdaiEdge_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiEdge_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEdge_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiEdge_curve *ent = (SdaiEdge_curve *)sent;
//    SdaiEdge_curve *ent = (SdaiEdge_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_edge_curve;
    ent->attributes[4].aDesc = a_288edge_geometry;
    if(ent->_edge_geometry == 0)
        ent->_edge_geometry = S_ENTITY_NULL;
    ent->attributes[5].aDesc = a_289same_sense;
}

SCLP23(Application_instance_ptr)
create_SdaiEdge_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiEdge_curve::get_os_typespec())
                                   SdaiEdge_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiEdge_curve::get_os_typespec())
//                                   SdaiEdge_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiEdge_curve;
}
#endif

#ifdef __O3DB__
void
SdaiEdge_curve::oodb_reInit ()
{	eDesc = config_control_designe_edge_curve;
	attributes [4].aDesc = a_288edge_geometry;
	attributes [5].aDesc = a_289same_sense;
}
#endif

SdaiEdge_curve::SdaiEdge_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiEdge(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiEdge  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    se->AppendMultInstance(new SdaiGeometric_representation_item(se, attrFlags));
#endif
    se->AppendMultInstance(new SdaiGeometric_representation_item(se, 0));

    eDesc = config_control_designe_edge_curve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_288edge_geometry, (SCLP23(Application_instance_ptr) *) &_edge_geometry);
#else
    STEPattribute *a = new STEPattribute(*a_288edge_geometry, (SCLP23(Application_instance_ptr) *) &_edge_geometry);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_289same_sense,  &_same_sense);
#else
    a = new STEPattribute(*a_289same_sense,  &_same_sense);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiCurve_ptr
SdaiEdge_curve::edge_geometry_() const
{
    return (SdaiCurve_ptr) _edge_geometry;
}

void
SdaiEdge_curve::edge_geometry_ (const SdaiCurve_ptr x)

{
    _edge_geometry = x;
}

const SCLBOOL(Bool)
SdaiEdge_curve::same_sense_() const
{
    return (SCLBOOL(Bool)) _same_sense;
}

void
SdaiEdge_curve::same_sense_ (const SCLBOOL(Bool) x)

{
    _same_sense.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

#endif

/////////	 END_ENTITY edge_curve


/////////	 ENTITY point_replica

EntityDescriptor *config_control_designe_point_replica =0;
AttrDescriptor *a_290parent_pt =0;
AttrDescriptor *a_291transformation =0;
SdaiPoint_replica::SdaiPoint_replica( )
{

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_replica;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_290parent_pt, (SCLP23(Application_instance_ptr) *) &_parent_pt);
#else
    STEPattribute *a = new STEPattribute(*a_290parent_pt, (SCLP23(Application_instance_ptr) *) &_parent_pt);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_291transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#else
    a = new STEPattribute(*a_291transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiPoint_replica::SdaiPoint_replica (SdaiPoint_replica& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPoint_replica::~SdaiPoint_replica () {  }

#ifdef __OSTORE__

void
SdaiPoint_replica::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPoint_replica: virtual access function." << endl;
    SdaiPoint_replica_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPoint_replica_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPoint_replica: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPoint_replica *ent = (SdaiPoint_replica *)sent;
//    SdaiPoint_replica *ent = (SdaiPoint_replica *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_point_replica;
    ent->attributes[1].aDesc = a_290parent_pt;
    if(ent->_parent_pt == 0)
        ent->_parent_pt = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_291transformation;
    if(ent->_transformation == 0)
        ent->_transformation = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiPoint_replica(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPoint_replica::get_os_typespec())
                                   SdaiPoint_replica;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPoint_replica::get_os_typespec())
//                                   SdaiPoint_replica;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPoint_replica;
}
#endif

#ifdef __O3DB__
void
SdaiPoint_replica::oodb_reInit ()
{	eDesc = config_control_designe_point_replica;
	attributes [1].aDesc = a_290parent_pt;
	attributes [2].aDesc = a_291transformation;
}
#endif

SdaiPoint_replica::SdaiPoint_replica (SCLP23(Application_instance) *se, int *addAttrs) : SdaiPoint(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_replica;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_290parent_pt, (SCLP23(Application_instance_ptr) *) &_parent_pt);
#else
    STEPattribute *a = new STEPattribute(*a_290parent_pt, (SCLP23(Application_instance_ptr) *) &_parent_pt);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_291transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#else
    a = new STEPattribute(*a_291transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiPoint_ptr
SdaiPoint_replica::parent_pt_() const
{
    return (SdaiPoint_ptr) _parent_pt;
}

void
SdaiPoint_replica::parent_pt_ (const SdaiPoint_ptr x)

{
    _parent_pt = x;
}

const SdaiCartesian_transformation_operator_ptr
SdaiPoint_replica::transformation_() const
{
    return (SdaiCartesian_transformation_operator_ptr) _transformation;
}

void
SdaiPoint_replica::transformation_ (const SdaiCartesian_transformation_operator_ptr x)

{
    _transformation = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY point_replica


/////////	 ENTITY product

EntityDescriptor *config_control_designe_product =0;
AttrDescriptor *a_292id =0;
AttrDescriptor *a_293name =0;
AttrDescriptor *a_294description =0;
AttrDescriptor *a_295frame_of_reference =0;
SdaiProduct::SdaiProduct( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_292id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_292id,  &_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_293name,  &_name);
#else
    a = new STEPattribute(*a_293name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_294description,  &_description);
#else
    a = new STEPattribute(*a_294description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_295frame_of_reference,  &_frame_of_reference);
#else
    a = new STEPattribute(*a_295frame_of_reference,  &_frame_of_reference);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct::SdaiProduct (SdaiProduct& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct::~SdaiProduct () {  }

#ifdef __OSTORE__

void
SdaiProduct::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct: virtual access function." << endl;
    SdaiProduct_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct *ent = (SdaiProduct *)sent;
//    SdaiProduct *ent = (SdaiProduct *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product;
    ent->attributes[0].aDesc = a_292id;
    ent->attributes[1].aDesc = a_293name;
    ent->attributes[2].aDesc = a_294description;
    ent->attributes[3].aDesc = a_295frame_of_reference;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct::get_os_typespec())
                                   SdaiProduct;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct::get_os_typespec())
//                                   SdaiProduct;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct;
}
#endif

#ifdef __O3DB__
void
SdaiProduct::oodb_reInit ()
{	eDesc = config_control_designe_product;
	attributes [0].aDesc = a_292id;
	attributes [1].aDesc = a_293name;
	attributes [2].aDesc = a_294description;
	attributes [3].aDesc = a_295frame_of_reference;
}
#endif

SdaiProduct::SdaiProduct( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_product;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_292id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_292id,  &_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_293name,  &_name);
#else
    a = new STEPattribute(*a_293name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_294description,  &_description);
#else
    a = new STEPattribute(*a_294description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_295frame_of_reference,  &_frame_of_reference);
#else
    a = new STEPattribute(*a_295frame_of_reference,  &_frame_of_reference);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiProduct::id_() const
{
    return (const SdaiIdentifier) _id;
}

void
SdaiProduct::id_ (const SdaiIdentifier x)

{
    _id = x;
}

const SdaiLabel
SdaiProduct::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiProduct::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiProduct::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiProduct::description_ (const SdaiText x)

{
    _description = x;
}

const EntityAggregate_ptr
SdaiProduct::frame_of_reference_() const
{
    return (EntityAggregate_ptr) &_frame_of_reference;
}

void
SdaiProduct::frame_of_reference_ (const EntityAggregate_ptr x)

	{ _frame_of_reference.ShallowCopy (*x); }

/////////	 END_ENTITY product


/////////	 ENTITY shape_aspect_relationship

EntityDescriptor *config_control_designe_shape_aspect_relationship =0;
AttrDescriptor *a_296name =0;
AttrDescriptor *a_297description =0;
AttrDescriptor *a_298relating_shape_aspect =0;
AttrDescriptor *a_299related_shape_aspect =0;
SdaiShape_aspect_relationship::SdaiShape_aspect_relationship( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_shape_aspect_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_296name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_296name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_297description,  &_description);
#else
    a = new STEPattribute(*a_297description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_298relating_shape_aspect, (SCLP23(Application_instance_ptr) *) &_relating_shape_aspect);
#else
    a = new STEPattribute(*a_298relating_shape_aspect, (SCLP23(Application_instance_ptr) *) &_relating_shape_aspect);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_299related_shape_aspect, (SCLP23(Application_instance_ptr) *) &_related_shape_aspect);
#else
    a = new STEPattribute(*a_299related_shape_aspect, (SCLP23(Application_instance_ptr) *) &_related_shape_aspect);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiShape_aspect_relationship::SdaiShape_aspect_relationship (SdaiShape_aspect_relationship& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiShape_aspect_relationship::~SdaiShape_aspect_relationship () {  }

#ifdef __OSTORE__

void
SdaiShape_aspect_relationship::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShape_aspect_relationship: virtual access function." << endl;
    SdaiShape_aspect_relationship_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiShape_aspect_relationship_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShape_aspect_relationship: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiShape_aspect_relationship *ent = (SdaiShape_aspect_relationship *)sent;
//    SdaiShape_aspect_relationship *ent = (SdaiShape_aspect_relationship *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_shape_aspect_relationship;
    ent->attributes[0].aDesc = a_296name;
    ent->attributes[1].aDesc = a_297description;
    ent->attributes[2].aDesc = a_298relating_shape_aspect;
    if(ent->_relating_shape_aspect == 0)
        ent->_relating_shape_aspect = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_299related_shape_aspect;
    if(ent->_related_shape_aspect == 0)
        ent->_related_shape_aspect = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiShape_aspect_relationship(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiShape_aspect_relationship::get_os_typespec())
                                   SdaiShape_aspect_relationship;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiShape_aspect_relationship::get_os_typespec())
//                                   SdaiShape_aspect_relationship;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiShape_aspect_relationship;
}
#endif

#ifdef __O3DB__
void
SdaiShape_aspect_relationship::oodb_reInit ()
{	eDesc = config_control_designe_shape_aspect_relationship;
	attributes [0].aDesc = a_296name;
	attributes [1].aDesc = a_297description;
	attributes [2].aDesc = a_298relating_shape_aspect;
	attributes [3].aDesc = a_299related_shape_aspect;
}
#endif

SdaiShape_aspect_relationship::SdaiShape_aspect_relationship( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_shape_aspect_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_296name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_296name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_297description,  &_description);
#else
    a = new STEPattribute(*a_297description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_298relating_shape_aspect, (SCLP23(Application_instance_ptr) *) &_relating_shape_aspect);
#else
    a = new STEPattribute(*a_298relating_shape_aspect, (SCLP23(Application_instance_ptr) *) &_relating_shape_aspect);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_299related_shape_aspect, (SCLP23(Application_instance_ptr) *) &_related_shape_aspect);
#else
    a = new STEPattribute(*a_299related_shape_aspect, (SCLP23(Application_instance_ptr) *) &_related_shape_aspect);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiShape_aspect_relationship::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiShape_aspect_relationship::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiShape_aspect_relationship::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiShape_aspect_relationship::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiShape_aspect_ptr
SdaiShape_aspect_relationship::relating_shape_aspect_() const
{
    return (SdaiShape_aspect_ptr) _relating_shape_aspect;
}

void
SdaiShape_aspect_relationship::relating_shape_aspect_ (const SdaiShape_aspect_ptr x)

{
    _relating_shape_aspect = x;
}

const SdaiShape_aspect_ptr
SdaiShape_aspect_relationship::related_shape_aspect_() const
{
    return (SdaiShape_aspect_ptr) _related_shape_aspect;
}

void
SdaiShape_aspect_relationship::related_shape_aspect_ (const SdaiShape_aspect_ptr x)

{
    _related_shape_aspect = x;
}

/////////	 END_ENTITY shape_aspect_relationship


/////////	 ENTITY rectangular_trimmed_surface

EntityDescriptor *config_control_designe_rectangular_trimmed_surface =0;
AttrDescriptor *a_300basis_surface =0;
AttrDescriptor *a_301u1 =0;
AttrDescriptor *a_302u2 =0;
AttrDescriptor *a_303v1 =0;
AttrDescriptor *a_304v2 =0;
AttrDescriptor *a_305usense =0;
AttrDescriptor *a_306vsense =0;
SdaiRectangular_trimmed_surface::SdaiRectangular_trimmed_surface( )
{

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rectangular_trimmed_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_300basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_300basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_301u1,  &_u1);
#else
    a = new STEPattribute(*a_301u1,  &_u1);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_302u2,  &_u2);
#else
    a = new STEPattribute(*a_302u2,  &_u2);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_303v1,  &_v1);
#else
    a = new STEPattribute(*a_303v1,  &_v1);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_304v2,  &_v2);
#else
    a = new STEPattribute(*a_304v2,  &_v2);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_305usense,  &_usense);
#else
    a = new STEPattribute(*a_305usense,  &_usense);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_306vsense,  &_vsense);
#else
    a = new STEPattribute(*a_306vsense,  &_vsense);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiRectangular_trimmed_surface::SdaiRectangular_trimmed_surface (SdaiRectangular_trimmed_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiRectangular_trimmed_surface::~SdaiRectangular_trimmed_surface () {  }

#ifdef __OSTORE__

void
SdaiRectangular_trimmed_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRectangular_trimmed_surface: virtual access function." << endl;
    SdaiRectangular_trimmed_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiRectangular_trimmed_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRectangular_trimmed_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiRectangular_trimmed_surface *ent = (SdaiRectangular_trimmed_surface *)sent;
//    SdaiRectangular_trimmed_surface *ent = (SdaiRectangular_trimmed_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_rectangular_trimmed_surface;
    ent->attributes[1].aDesc = a_300basis_surface;
    if(ent->_basis_surface == 0)
        ent->_basis_surface = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_301u1;
    ent->attributes[3].aDesc = a_302u2;
    ent->attributes[4].aDesc = a_303v1;
    ent->attributes[5].aDesc = a_304v2;
    ent->attributes[6].aDesc = a_305usense;
    ent->attributes[7].aDesc = a_306vsense;
}

SCLP23(Application_instance_ptr)
create_SdaiRectangular_trimmed_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiRectangular_trimmed_surface::get_os_typespec())
                                   SdaiRectangular_trimmed_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiRectangular_trimmed_surface::get_os_typespec())
//                                   SdaiRectangular_trimmed_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiRectangular_trimmed_surface;
}
#endif

#ifdef __O3DB__
void
SdaiRectangular_trimmed_surface::oodb_reInit ()
{	eDesc = config_control_designe_rectangular_trimmed_surface;
	attributes [1].aDesc = a_300basis_surface;
	attributes [2].aDesc = a_301u1;
	attributes [3].aDesc = a_302u2;
	attributes [4].aDesc = a_303v1;
	attributes [5].aDesc = a_304v2;
	attributes [6].aDesc = a_305usense;
	attributes [7].aDesc = a_306vsense;
}
#endif

SdaiRectangular_trimmed_surface::SdaiRectangular_trimmed_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiBounded_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rectangular_trimmed_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_300basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_300basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_301u1,  &_u1);
#else
    a = new STEPattribute(*a_301u1,  &_u1);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_302u2,  &_u2);
#else
    a = new STEPattribute(*a_302u2,  &_u2);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_303v1,  &_v1);
#else
    a = new STEPattribute(*a_303v1,  &_v1);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_304v2,  &_v2);
#else
    a = new STEPattribute(*a_304v2,  &_v2);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_305usense,  &_usense);
#else
    a = new STEPattribute(*a_305usense,  &_usense);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_306vsense,  &_vsense);
#else
    a = new STEPattribute(*a_306vsense,  &_vsense);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiSurface_ptr
SdaiRectangular_trimmed_surface::basis_surface_() const
{
    return (SdaiSurface_ptr) _basis_surface;
}

void
SdaiRectangular_trimmed_surface::basis_surface_ (const SdaiSurface_ptr x)

{
    _basis_surface = x;
}

const SdaiParameter_value
SdaiRectangular_trimmed_surface::u1_() const
{
    return (const SdaiParameter_value) _u1;
}

void
SdaiRectangular_trimmed_surface::u1_ (const SdaiParameter_value x)

{
    _u1 = x;
}

const SdaiParameter_value
SdaiRectangular_trimmed_surface::u2_() const
{
    return (const SdaiParameter_value) _u2;
}

void
SdaiRectangular_trimmed_surface::u2_ (const SdaiParameter_value x)

{
    _u2 = x;
}

const SdaiParameter_value
SdaiRectangular_trimmed_surface::v1_() const
{
    return (const SdaiParameter_value) _v1;
}

void
SdaiRectangular_trimmed_surface::v1_ (const SdaiParameter_value x)

{
    _v1 = x;
}

const SdaiParameter_value
SdaiRectangular_trimmed_surface::v2_() const
{
    return (const SdaiParameter_value) _v2;
}

void
SdaiRectangular_trimmed_surface::v2_ (const SdaiParameter_value x)

{
    _v2 = x;
}

const SCLBOOL(Bool)
SdaiRectangular_trimmed_surface::usense_() const
{
    return (SCLBOOL(Bool)) _usense;
}

void
SdaiRectangular_trimmed_surface::usense_ (const SCLBOOL(Bool) x)

{
    _usense.put (x);
}

const SCLBOOL(Bool)
SdaiRectangular_trimmed_surface::vsense_() const
{
    return (SCLBOOL(Bool)) _vsense;
}

void
SdaiRectangular_trimmed_surface::vsense_ (const SCLBOOL(Bool) x)

{
    _vsense.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY rectangular_trimmed_surface


/////////	 ENTITY plane

EntityDescriptor *config_control_designe_plane =0;
SdaiPlane::SdaiPlane( )
{

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane;
    MakeDerived ("dim");
}
SdaiPlane::SdaiPlane (SdaiPlane& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPlane::~SdaiPlane () {  }

#ifdef __OSTORE__

void
SdaiPlane::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPlane: virtual access function." << endl;
    SdaiPlane_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPlane_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPlane: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPlane *ent = (SdaiPlane *)sent;
//    SdaiPlane *ent = (SdaiPlane *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_plane;
}

SCLP23(Application_instance_ptr)
create_SdaiPlane(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPlane::get_os_typespec())
                                   SdaiPlane;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPlane::get_os_typespec())
//                                   SdaiPlane;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPlane;
}
#endif

#ifdef __O3DB__
void
SdaiPlane::oodb_reInit ()
{	eDesc = config_control_designe_plane;
}
#endif

SdaiPlane::SdaiPlane (SCLP23(Application_instance) *se, int *addAttrs) : SdaiElementary_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane;
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY plane


/////////	 ENTITY action_assignment

EntityDescriptor *config_control_designe_action_assignment =0;
AttrDescriptor *a_307assigned_action =0;
SdaiAction_assignment::SdaiAction_assignment( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_307assigned_action, (SCLP23(Application_instance_ptr) *) &_assigned_action);
#else
    STEPattribute *a = new STEPattribute(*a_307assigned_action, (SCLP23(Application_instance_ptr) *) &_assigned_action);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_assignment::SdaiAction_assignment (SdaiAction_assignment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAction_assignment::~SdaiAction_assignment () {  }

#ifdef __OSTORE__

void
SdaiAction_assignment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_assignment: virtual access function." << endl;
    SdaiAction_assignment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAction_assignment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction_assignment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAction_assignment *ent = (SdaiAction_assignment *)sent;
//    SdaiAction_assignment *ent = (SdaiAction_assignment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_action_assignment;
    ent->attributes[0].aDesc = a_307assigned_action;
    if(ent->_assigned_action == 0)
        ent->_assigned_action = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiAction_assignment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAction_assignment::get_os_typespec())
                                   SdaiAction_assignment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAction_assignment::get_os_typespec())
//                                   SdaiAction_assignment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAction_assignment;
}
#endif

#ifdef __O3DB__
void
SdaiAction_assignment::oodb_reInit ()
{	eDesc = config_control_designe_action_assignment;
	attributes [0].aDesc = a_307assigned_action;
}
#endif

SdaiAction_assignment::SdaiAction_assignment( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_action_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_307assigned_action, (SCLP23(Application_instance_ptr) *) &_assigned_action);
#else
    STEPattribute *a = new STEPattribute(*a_307assigned_action, (SCLP23(Application_instance_ptr) *) &_assigned_action);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiAction_ptr
SdaiAction_assignment::assigned_action_() const
{
    return (SdaiAction_ptr) _assigned_action;
}

void
SdaiAction_assignment::assigned_action_ (const SdaiAction_ptr x)

{
    _assigned_action = x;
}

/////////	 END_ENTITY action_assignment


/////////	 ENTITY change

EntityDescriptor *config_control_designe_change =0;
AttrDescriptor *a_308items =0;
SdaiChange::SdaiChange( )
{

	/*  parent: SdaiAction_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_change;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_308items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_308items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiChange::SdaiChange (SdaiChange& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiChange::~SdaiChange () {  }

#ifdef __OSTORE__

void
SdaiChange::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiChange: virtual access function." << endl;
    SdaiChange_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiChange_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiChange: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiChange *ent = (SdaiChange *)sent;
//    SdaiChange *ent = (SdaiChange *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_change;
    ent->attributes[1].aDesc = a_308items;
}

SCLP23(Application_instance_ptr)
create_SdaiChange(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiChange::get_os_typespec())
                                   SdaiChange;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiChange::get_os_typespec())
//                                   SdaiChange;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiChange;
}
#endif

#ifdef __O3DB__
void
SdaiChange::oodb_reInit ()
{	eDesc = config_control_designe_change;
	attributes [1].aDesc = a_308items;
}
#endif

SdaiChange::SdaiChange (SCLP23(Application_instance) *se, int *addAttrs) : SdaiAction_assignment(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiAction_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_change;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_308items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_308items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiWork_items_ptr
SdaiChange::items_() const
{
    return (SdaiWork_items_ptr) &_items;
}

void
SdaiChange::items_ (const SdaiWork_items_ptr x)

	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY change


/////////	 ENTITY circle

EntityDescriptor *config_control_designe_circle =0;
AttrDescriptor *a_309radius =0;
SdaiCircle::SdaiCircle( )
{

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_circle;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_309radius,  &_radius);
#else
    STEPattribute *a = new STEPattribute(*a_309radius,  &_radius);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiCircle::SdaiCircle (SdaiCircle& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCircle::~SdaiCircle () {  }

#ifdef __OSTORE__

void
SdaiCircle::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCircle: virtual access function." << endl;
    SdaiCircle_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCircle_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCircle: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCircle *ent = (SdaiCircle *)sent;
//    SdaiCircle *ent = (SdaiCircle *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_circle;
    ent->attributes[2].aDesc = a_309radius;
}

SCLP23(Application_instance_ptr)
create_SdaiCircle(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCircle::get_os_typespec())
                                   SdaiCircle;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCircle::get_os_typespec())
//                                   SdaiCircle;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCircle;
}
#endif

#ifdef __O3DB__
void
SdaiCircle::oodb_reInit ()
{	eDesc = config_control_designe_circle;
	attributes [2].aDesc = a_309radius;
}
#endif

SdaiCircle::SdaiCircle (SCLP23(Application_instance) *se, int *addAttrs) : SdaiConic(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_circle;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_309radius,  &_radius);
#else
    STEPattribute *a = new STEPattribute(*a_309radius,  &_radius);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiPositive_length_measure
SdaiCircle::radius_() const
{
    return (const SdaiPositive_length_measure) _radius;
}

void
SdaiCircle::radius_ (const SdaiPositive_length_measure x)

{
    _radius = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY circle


/////////	 ENTITY line

EntityDescriptor *config_control_designe_line =0;
AttrDescriptor *a_310pnt =0;
AttrDescriptor *a_311dir =0;
SdaiLine::SdaiLine( )
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_line;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_310pnt, (SCLP23(Application_instance_ptr) *) &_pnt);
#else
    STEPattribute *a = new STEPattribute(*a_310pnt, (SCLP23(Application_instance_ptr) *) &_pnt);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_311dir, (SCLP23(Application_instance_ptr) *) &_dir);
#else
    a = new STEPattribute(*a_311dir, (SCLP23(Application_instance_ptr) *) &_dir);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiLine::SdaiLine (SdaiLine& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiLine::~SdaiLine () {  }

#ifdef __OSTORE__

void
SdaiLine::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLine: virtual access function." << endl;
    SdaiLine_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiLine_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLine: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiLine *ent = (SdaiLine *)sent;
//    SdaiLine *ent = (SdaiLine *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_line;
    ent->attributes[1].aDesc = a_310pnt;
    if(ent->_pnt == 0)
        ent->_pnt = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_311dir;
    if(ent->_dir == 0)
        ent->_dir = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiLine(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiLine::get_os_typespec())
                                   SdaiLine;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiLine::get_os_typespec())
//                                   SdaiLine;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiLine;
}
#endif

#ifdef __O3DB__
void
SdaiLine::oodb_reInit ()
{	eDesc = config_control_designe_line;
	attributes [1].aDesc = a_310pnt;
	attributes [2].aDesc = a_311dir;
}
#endif

SdaiLine::SdaiLine (SCLP23(Application_instance) *se, int *addAttrs) : SdaiCurve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_line;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_310pnt, (SCLP23(Application_instance_ptr) *) &_pnt);
#else
    STEPattribute *a = new STEPattribute(*a_310pnt, (SCLP23(Application_instance_ptr) *) &_pnt);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_311dir, (SCLP23(Application_instance_ptr) *) &_dir);
#else
    a = new STEPattribute(*a_311dir, (SCLP23(Application_instance_ptr) *) &_dir);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiCartesian_point_ptr
SdaiLine::pnt_() const
{
    return (SdaiCartesian_point_ptr) _pnt;
}

void
SdaiLine::pnt_ (const SdaiCartesian_point_ptr x)

{
    _pnt = x;
}

const SdaiVector_ptr
SdaiLine::dir_() const
{
    return (SdaiVector_ptr) _dir;
}

void
SdaiLine::dir_ (const SdaiVector_ptr x)

{
    _dir = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY line


/////////	 ENTITY property_definition_representation

EntityDescriptor *config_control_designe_property_definition_representation =0;
AttrDescriptor *a_312definition =0;
AttrDescriptor *a_313used_representation =0;
SdaiProperty_definition_representation::SdaiProperty_definition_representation( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_property_definition_representation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_312definition, (SCLP23(Application_instance_ptr) *) &_definition);
#else
    STEPattribute *a = new STEPattribute(*a_312definition, (SCLP23(Application_instance_ptr) *) &_definition);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_313used_representation, (SCLP23(Application_instance_ptr) *) &_used_representation);
#else
    a = new STEPattribute(*a_313used_representation, (SCLP23(Application_instance_ptr) *) &_used_representation);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProperty_definition_representation::SdaiProperty_definition_representation (SdaiProperty_definition_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProperty_definition_representation::~SdaiProperty_definition_representation () {  }

#ifdef __OSTORE__

void
SdaiProperty_definition_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProperty_definition_representation: virtual access function." << endl;
    SdaiProperty_definition_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProperty_definition_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProperty_definition_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProperty_definition_representation *ent = (SdaiProperty_definition_representation *)sent;
//    SdaiProperty_definition_representation *ent = (SdaiProperty_definition_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_property_definition_representation;
    ent->attributes[0].aDesc = a_312definition;
    if(ent->_definition == 0)
        ent->_definition = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_313used_representation;
    if(ent->_used_representation == 0)
        ent->_used_representation = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiProperty_definition_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProperty_definition_representation::get_os_typespec())
                                   SdaiProperty_definition_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProperty_definition_representation::get_os_typespec())
//                                   SdaiProperty_definition_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProperty_definition_representation;
}
#endif

#ifdef __O3DB__
void
SdaiProperty_definition_representation::oodb_reInit ()
{	eDesc = config_control_designe_property_definition_representation;
	attributes [0].aDesc = a_312definition;
	attributes [1].aDesc = a_313used_representation;
}
#endif

SdaiProperty_definition_representation::SdaiProperty_definition_representation( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_property_definition_representation;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_312definition, (SCLP23(Application_instance_ptr) *) &_definition);
#else
    STEPattribute *a = new STEPattribute(*a_312definition, (SCLP23(Application_instance_ptr) *) &_definition);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_313used_representation, (SCLP23(Application_instance_ptr) *) &_used_representation);
#else
    a = new STEPattribute(*a_313used_representation, (SCLP23(Application_instance_ptr) *) &_used_representation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiProperty_definition_ptr
SdaiProperty_definition_representation::definition_() const
{
    return (SdaiProperty_definition_ptr) _definition;
}

void
SdaiProperty_definition_representation::definition_ (const SdaiProperty_definition_ptr x)

{
    _definition = x;
}

const SdaiRepresentation_ptr
SdaiProperty_definition_representation::used_representation_() const
{
    return (SdaiRepresentation_ptr) _used_representation;
}

void
SdaiProperty_definition_representation::used_representation_ (const SdaiRepresentation_ptr x)

{
    _used_representation = x;
}

/////////	 END_ENTITY property_definition_representation


/////////	 ENTITY geometric_set

EntityDescriptor *config_control_designe_geometric_set =0;
AttrDescriptor *a_314elements =0;
SdaiGeometric_set::SdaiGeometric_set( )
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_set;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_314elements,  &_elements);
#else
    STEPattribute *a = new STEPattribute(*a_314elements,  &_elements);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiGeometric_set::SdaiGeometric_set (SdaiGeometric_set& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiGeometric_set::~SdaiGeometric_set () {  }

#ifdef __OSTORE__

void
SdaiGeometric_set::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometric_set: virtual access function." << endl;
    SdaiGeometric_set_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiGeometric_set_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometric_set: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiGeometric_set *ent = (SdaiGeometric_set *)sent;
//    SdaiGeometric_set *ent = (SdaiGeometric_set *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_geometric_set;
    ent->attributes[1].aDesc = a_314elements;
}

SCLP23(Application_instance_ptr)
create_SdaiGeometric_set(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiGeometric_set::get_os_typespec())
                                   SdaiGeometric_set;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiGeometric_set::get_os_typespec())
//                                   SdaiGeometric_set;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiGeometric_set;
}
#endif

#ifdef __O3DB__
void
SdaiGeometric_set::oodb_reInit ()
{	eDesc = config_control_designe_geometric_set;
	attributes [1].aDesc = a_314elements;
}
#endif

SdaiGeometric_set::SdaiGeometric_set (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_set;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_314elements,  &_elements);
#else
    STEPattribute *a = new STEPattribute(*a_314elements,  &_elements);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiGeometric_set_selects_ptr
SdaiGeometric_set::elements_() const
{
    return (SdaiGeometric_set_selects_ptr) &_elements;
}

void
SdaiGeometric_set::elements_ (const SdaiGeometric_set_selects_ptr x)

	{ _elements.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometric_set


/////////	 ENTITY geometric_curve_set

EntityDescriptor *config_control_designe_geometric_curve_set =0;
SdaiGeometric_curve_set::SdaiGeometric_curve_set( )
{

	/*  parent: SdaiGeometric_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_curve_set;
    MakeDerived ("dim");
}
SdaiGeometric_curve_set::SdaiGeometric_curve_set (SdaiGeometric_curve_set& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiGeometric_curve_set::~SdaiGeometric_curve_set () {  }

#ifdef __OSTORE__

void
SdaiGeometric_curve_set::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometric_curve_set: virtual access function." << endl;
    SdaiGeometric_curve_set_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiGeometric_curve_set_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometric_curve_set: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiGeometric_curve_set *ent = (SdaiGeometric_curve_set *)sent;
//    SdaiGeometric_curve_set *ent = (SdaiGeometric_curve_set *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_geometric_curve_set;
}

SCLP23(Application_instance_ptr)
create_SdaiGeometric_curve_set(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiGeometric_curve_set::get_os_typespec())
                                   SdaiGeometric_curve_set;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiGeometric_curve_set::get_os_typespec())
//                                   SdaiGeometric_curve_set;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiGeometric_curve_set;
}
#endif

#ifdef __O3DB__
void
SdaiGeometric_curve_set::oodb_reInit ()
{	eDesc = config_control_designe_geometric_curve_set;
}
#endif

SdaiGeometric_curve_set::SdaiGeometric_curve_set (SCLP23(Application_instance) *se, int *addAttrs) : SdaiGeometric_set(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiGeometric_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_curve_set;
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometric_curve_set


/////////	 ENTITY personal_address

EntityDescriptor *config_control_designe_personal_address =0;
AttrDescriptor *a_315people =0;
AttrDescriptor *a_316description =0;
SdaiPersonal_address::SdaiPersonal_address( )
{

	/*  parent: SdaiAddress  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_personal_address;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_315people,  &_people);
#else
    STEPattribute *a = new STEPattribute(*a_315people,  &_people);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_316description,  &_description);
#else
    a = new STEPattribute(*a_316description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiPersonal_address::SdaiPersonal_address (SdaiPersonal_address& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPersonal_address::~SdaiPersonal_address () {  }

#ifdef __OSTORE__

void
SdaiPersonal_address::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPersonal_address: virtual access function." << endl;
    SdaiPersonal_address_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPersonal_address_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPersonal_address: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPersonal_address *ent = (SdaiPersonal_address *)sent;
//    SdaiPersonal_address *ent = (SdaiPersonal_address *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_personal_address;
    ent->attributes[12].aDesc = a_315people;
    ent->attributes[13].aDesc = a_316description;
}

SCLP23(Application_instance_ptr)
create_SdaiPersonal_address(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPersonal_address::get_os_typespec())
                                   SdaiPersonal_address;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPersonal_address::get_os_typespec())
//                                   SdaiPersonal_address;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPersonal_address;
}
#endif

#ifdef __O3DB__
void
SdaiPersonal_address::oodb_reInit ()
{	eDesc = config_control_designe_personal_address;
	attributes [12].aDesc = a_315people;
	attributes [13].aDesc = a_316description;
}
#endif

SdaiPersonal_address::SdaiPersonal_address (SCLP23(Application_instance) *se, int *addAttrs) : SdaiAddress(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiAddress  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_personal_address;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_315people,  &_people);
#else
    STEPattribute *a = new STEPattribute(*a_315people,  &_people);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_316description,  &_description);
#else
    a = new STEPattribute(*a_316description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const EntityAggregate_ptr
SdaiPersonal_address::people_() const
{
    return (EntityAggregate_ptr) &_people;
}

void
SdaiPersonal_address::people_ (const EntityAggregate_ptr x)

	{ _people.ShallowCopy (*x); }

const SdaiText
SdaiPersonal_address::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiPersonal_address::description_ (const SdaiText x)

{
    _description = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY personal_address


/////////	 ENTITY document_relationship

EntityDescriptor *config_control_designe_document_relationship =0;
AttrDescriptor *a_317name =0;
AttrDescriptor *a_318description =0;
AttrDescriptor *a_319relating_document =0;
AttrDescriptor *a_320related_document =0;
SdaiDocument_relationship::SdaiDocument_relationship( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_document_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_317name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_317name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_318description,  &_description);
#else
    a = new STEPattribute(*a_318description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_319relating_document, (SCLP23(Application_instance_ptr) *) &_relating_document);
#else
    a = new STEPattribute(*a_319relating_document, (SCLP23(Application_instance_ptr) *) &_relating_document);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_320related_document, (SCLP23(Application_instance_ptr) *) &_related_document);
#else
    a = new STEPattribute(*a_320related_document, (SCLP23(Application_instance_ptr) *) &_related_document);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument_relationship::SdaiDocument_relationship (SdaiDocument_relationship& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDocument_relationship::~SdaiDocument_relationship () {  }

#ifdef __OSTORE__

void
SdaiDocument_relationship::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument_relationship: virtual access function." << endl;
    SdaiDocument_relationship_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDocument_relationship_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument_relationship: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDocument_relationship *ent = (SdaiDocument_relationship *)sent;
//    SdaiDocument_relationship *ent = (SdaiDocument_relationship *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_document_relationship;
    ent->attributes[0].aDesc = a_317name;
    ent->attributes[1].aDesc = a_318description;
    ent->attributes[2].aDesc = a_319relating_document;
    if(ent->_relating_document == 0)
        ent->_relating_document = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_320related_document;
    if(ent->_related_document == 0)
        ent->_related_document = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiDocument_relationship(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDocument_relationship::get_os_typespec())
                                   SdaiDocument_relationship;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDocument_relationship::get_os_typespec())
//                                   SdaiDocument_relationship;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDocument_relationship;
}
#endif

#ifdef __O3DB__
void
SdaiDocument_relationship::oodb_reInit ()
{	eDesc = config_control_designe_document_relationship;
	attributes [0].aDesc = a_317name;
	attributes [1].aDesc = a_318description;
	attributes [2].aDesc = a_319relating_document;
	attributes [3].aDesc = a_320related_document;
}
#endif

SdaiDocument_relationship::SdaiDocument_relationship( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_document_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_317name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_317name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_318description,  &_description);
#else
    a = new STEPattribute(*a_318description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_319relating_document, (SCLP23(Application_instance_ptr) *) &_relating_document);
#else
    a = new STEPattribute(*a_319relating_document, (SCLP23(Application_instance_ptr) *) &_relating_document);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_320related_document, (SCLP23(Application_instance_ptr) *) &_related_document);
#else
    a = new STEPattribute(*a_320related_document, (SCLP23(Application_instance_ptr) *) &_related_document);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiDocument_relationship::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiDocument_relationship::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiDocument_relationship::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiDocument_relationship::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiDocument_ptr
SdaiDocument_relationship::relating_document_() const
{
    return (SdaiDocument_ptr) _relating_document;
}

void
SdaiDocument_relationship::relating_document_ (const SdaiDocument_ptr x)

{
    _relating_document = x;
}

const SdaiDocument_ptr
SdaiDocument_relationship::related_document_() const
{
    return (SdaiDocument_ptr) _related_document;
}

void
SdaiDocument_relationship::related_document_ (const SdaiDocument_ptr x)

{
    _related_document = x;
}

/////////	 END_ENTITY document_relationship


/////////	 ENTITY outer_boundary_curve

EntityDescriptor *config_control_designe_outer_boundary_curve =0;
SdaiOuter_boundary_curve::SdaiOuter_boundary_curve( )
{

	/*  parent: SdaiBoundary_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_outer_boundary_curve;
    MakeDerived ("dim");
    MakeDerived ("n_segments");
    MakeDerived ("closed_curve");
    MakeDerived ("basis_surface");
}
SdaiOuter_boundary_curve::SdaiOuter_boundary_curve (SdaiOuter_boundary_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOuter_boundary_curve::~SdaiOuter_boundary_curve () {  }

#ifdef __OSTORE__

void
SdaiOuter_boundary_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOuter_boundary_curve: virtual access function." << endl;
    SdaiOuter_boundary_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOuter_boundary_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOuter_boundary_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOuter_boundary_curve *ent = (SdaiOuter_boundary_curve *)sent;
//    SdaiOuter_boundary_curve *ent = (SdaiOuter_boundary_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_outer_boundary_curve;
}

SCLP23(Application_instance_ptr)
create_SdaiOuter_boundary_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOuter_boundary_curve::get_os_typespec())
                                   SdaiOuter_boundary_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOuter_boundary_curve::get_os_typespec())
//                                   SdaiOuter_boundary_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOuter_boundary_curve;
}
#endif

#ifdef __O3DB__
void
SdaiOuter_boundary_curve::oodb_reInit ()
{	eDesc = config_control_designe_outer_boundary_curve;
}
#endif

SdaiOuter_boundary_curve::SdaiOuter_boundary_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiBoundary_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiBoundary_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_outer_boundary_curve;
    MakeDerived ("dim");
    MakeDerived ("n_segments");
    MakeDerived ("closed_curve");
    MakeDerived ("basis_surface");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY outer_boundary_curve


/////////	 ENTITY shape_representation_relationship

EntityDescriptor *config_control_designe_shape_representation_relationship =0;
SdaiShape_representation_relationship::SdaiShape_representation_relationship( )
{

	/*  parent: SdaiRepresentation_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_representation_relationship;
}
SdaiShape_representation_relationship::SdaiShape_representation_relationship (SdaiShape_representation_relationship& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiShape_representation_relationship::~SdaiShape_representation_relationship () {  }

#ifdef __OSTORE__

void
SdaiShape_representation_relationship::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShape_representation_relationship: virtual access function." << endl;
    SdaiShape_representation_relationship_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiShape_representation_relationship_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShape_representation_relationship: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiShape_representation_relationship *ent = (SdaiShape_representation_relationship *)sent;
//    SdaiShape_representation_relationship *ent = (SdaiShape_representation_relationship *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_shape_representation_relationship;
}

SCLP23(Application_instance_ptr)
create_SdaiShape_representation_relationship(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiShape_representation_relationship::get_os_typespec())
                                   SdaiShape_representation_relationship;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiShape_representation_relationship::get_os_typespec())
//                                   SdaiShape_representation_relationship;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiShape_representation_relationship;
}
#endif

#ifdef __O3DB__
void
SdaiShape_representation_relationship::oodb_reInit ()
{	eDesc = config_control_designe_shape_representation_relationship;
}
#endif

SdaiShape_representation_relationship::SdaiShape_representation_relationship (SCLP23(Application_instance) *se, int *addAttrs) : SdaiRepresentation_relationship(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiRepresentation_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_representation_relationship;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shape_representation_relationship


/////////	 ENTITY assembly_component_usage_substitute

EntityDescriptor *config_control_designe_assembly_component_usage_substitute =0;
AttrDescriptor *a_321name =0;
AttrDescriptor *a_322definition =0;
AttrDescriptor *a_323base =0;
AttrDescriptor *a_324substitute =0;
SdaiAssembly_component_usage_substitute::SdaiAssembly_component_usage_substitute( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_assembly_component_usage_substitute;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_321name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_321name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_322definition,  &_definition);
#else
    a = new STEPattribute(*a_322definition,  &_definition);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_323base, (SCLP23(Application_instance_ptr) *) &_base);
#else
    a = new STEPattribute(*a_323base, (SCLP23(Application_instance_ptr) *) &_base);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_324substitute, (SCLP23(Application_instance_ptr) *) &_substitute);
#else
    a = new STEPattribute(*a_324substitute, (SCLP23(Application_instance_ptr) *) &_substitute);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAssembly_component_usage_substitute::SdaiAssembly_component_usage_substitute (SdaiAssembly_component_usage_substitute& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAssembly_component_usage_substitute::~SdaiAssembly_component_usage_substitute () {  }

#ifdef __OSTORE__

void
SdaiAssembly_component_usage_substitute::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAssembly_component_usage_substitute: virtual access function." << endl;
    SdaiAssembly_component_usage_substitute_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAssembly_component_usage_substitute_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAssembly_component_usage_substitute: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAssembly_component_usage_substitute *ent = (SdaiAssembly_component_usage_substitute *)sent;
//    SdaiAssembly_component_usage_substitute *ent = (SdaiAssembly_component_usage_substitute *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_assembly_component_usage_substitute;
    ent->attributes[0].aDesc = a_321name;
    ent->attributes[1].aDesc = a_322definition;
    ent->attributes[2].aDesc = a_323base;
    if(ent->_base == 0)
        ent->_base = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_324substitute;
    if(ent->_substitute == 0)
        ent->_substitute = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiAssembly_component_usage_substitute(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAssembly_component_usage_substitute::get_os_typespec())
                                   SdaiAssembly_component_usage_substitute;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAssembly_component_usage_substitute::get_os_typespec())
//                                   SdaiAssembly_component_usage_substitute;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAssembly_component_usage_substitute;
}
#endif

#ifdef __O3DB__
void
SdaiAssembly_component_usage_substitute::oodb_reInit ()
{	eDesc = config_control_designe_assembly_component_usage_substitute;
	attributes [0].aDesc = a_321name;
	attributes [1].aDesc = a_322definition;
	attributes [2].aDesc = a_323base;
	attributes [3].aDesc = a_324substitute;
}
#endif

SdaiAssembly_component_usage_substitute::SdaiAssembly_component_usage_substitute( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_assembly_component_usage_substitute;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_321name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_321name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_322definition,  &_definition);
#else
    a = new STEPattribute(*a_322definition,  &_definition);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_323base, (SCLP23(Application_instance_ptr) *) &_base);
#else
    a = new STEPattribute(*a_323base, (SCLP23(Application_instance_ptr) *) &_base);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_324substitute, (SCLP23(Application_instance_ptr) *) &_substitute);
#else
    a = new STEPattribute(*a_324substitute, (SCLP23(Application_instance_ptr) *) &_substitute);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiAssembly_component_usage_substitute::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiAssembly_component_usage_substitute::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiAssembly_component_usage_substitute::definition_() const
{
    return (const SdaiText) _definition;
}

void
SdaiAssembly_component_usage_substitute::definition_ (const SdaiText x)

{
    _definition = x;
}

const SdaiAssembly_component_usage_ptr
SdaiAssembly_component_usage_substitute::base_() const
{
    return (SdaiAssembly_component_usage_ptr) _base;
}

void
SdaiAssembly_component_usage_substitute::base_ (const SdaiAssembly_component_usage_ptr x)

{
    _base = x;
}

const SdaiAssembly_component_usage_ptr
SdaiAssembly_component_usage_substitute::substitute_() const
{
    return (SdaiAssembly_component_usage_ptr) _substitute;
}

void
SdaiAssembly_component_usage_substitute::substitute_ (const SdaiAssembly_component_usage_ptr x)

{
    _substitute = x;
}

/////////	 END_ENTITY assembly_component_usage_substitute


/////////	 ENTITY degenerate_pcurve

EntityDescriptor *config_control_designe_degenerate_pcurve =0;
AttrDescriptor *a_325basis_surface =0;
AttrDescriptor *a_326reference_to_curve =0;
SdaiDegenerate_pcurve::SdaiDegenerate_pcurve( )
{

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_degenerate_pcurve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_325basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_325basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_326reference_to_curve, (SCLP23(Application_instance_ptr) *) &_reference_to_curve);
#else
    a = new STEPattribute(*a_326reference_to_curve, (SCLP23(Application_instance_ptr) *) &_reference_to_curve);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiDegenerate_pcurve::SdaiDegenerate_pcurve (SdaiDegenerate_pcurve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDegenerate_pcurve::~SdaiDegenerate_pcurve () {  }

#ifdef __OSTORE__

void
SdaiDegenerate_pcurve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDegenerate_pcurve: virtual access function." << endl;
    SdaiDegenerate_pcurve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDegenerate_pcurve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDegenerate_pcurve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDegenerate_pcurve *ent = (SdaiDegenerate_pcurve *)sent;
//    SdaiDegenerate_pcurve *ent = (SdaiDegenerate_pcurve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_degenerate_pcurve;
    ent->attributes[1].aDesc = a_325basis_surface;
    if(ent->_basis_surface == 0)
        ent->_basis_surface = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_326reference_to_curve;
    if(ent->_reference_to_curve == 0)
        ent->_reference_to_curve = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiDegenerate_pcurve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDegenerate_pcurve::get_os_typespec())
                                   SdaiDegenerate_pcurve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDegenerate_pcurve::get_os_typespec())
//                                   SdaiDegenerate_pcurve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDegenerate_pcurve;
}
#endif

#ifdef __O3DB__
void
SdaiDegenerate_pcurve::oodb_reInit ()
{	eDesc = config_control_designe_degenerate_pcurve;
	attributes [1].aDesc = a_325basis_surface;
	attributes [2].aDesc = a_326reference_to_curve;
}
#endif

SdaiDegenerate_pcurve::SdaiDegenerate_pcurve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiPoint(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_degenerate_pcurve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_325basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_325basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_326reference_to_curve, (SCLP23(Application_instance_ptr) *) &_reference_to_curve);
#else
    a = new STEPattribute(*a_326reference_to_curve, (SCLP23(Application_instance_ptr) *) &_reference_to_curve);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiSurface_ptr
SdaiDegenerate_pcurve::basis_surface_() const
{
    return (SdaiSurface_ptr) _basis_surface;
}

void
SdaiDegenerate_pcurve::basis_surface_ (const SdaiSurface_ptr x)

{
    _basis_surface = x;
}

const SdaiDefinitional_representation_ptr
SdaiDegenerate_pcurve::reference_to_curve_() const
{
    return (SdaiDefinitional_representation_ptr) _reference_to_curve;
}

void
SdaiDegenerate_pcurve::reference_to_curve_ (const SdaiDefinitional_representation_ptr x)

{
    _reference_to_curve = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY degenerate_pcurve


/////////	 ENTITY evaluated_degenerate_pcurve

EntityDescriptor *config_control_designe_evaluated_degenerate_pcurve =0;
AttrDescriptor *a_327equivalent_point =0;
SdaiEvaluated_degenerate_pcurve::SdaiEvaluated_degenerate_pcurve( )
{

	/*  parent: SdaiDegenerate_pcurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_evaluated_degenerate_pcurve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_327equivalent_point, (SCLP23(Application_instance_ptr) *) &_equivalent_point);
#else
    STEPattribute *a = new STEPattribute(*a_327equivalent_point, (SCLP23(Application_instance_ptr) *) &_equivalent_point);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiEvaluated_degenerate_pcurve::SdaiEvaluated_degenerate_pcurve (SdaiEvaluated_degenerate_pcurve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiEvaluated_degenerate_pcurve::~SdaiEvaluated_degenerate_pcurve () {  }

#ifdef __OSTORE__

void
SdaiEvaluated_degenerate_pcurve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEvaluated_degenerate_pcurve: virtual access function." << endl;
    SdaiEvaluated_degenerate_pcurve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiEvaluated_degenerate_pcurve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEvaluated_degenerate_pcurve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiEvaluated_degenerate_pcurve *ent = (SdaiEvaluated_degenerate_pcurve *)sent;
//    SdaiEvaluated_degenerate_pcurve *ent = (SdaiEvaluated_degenerate_pcurve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_evaluated_degenerate_pcurve;
    ent->attributes[3].aDesc = a_327equivalent_point;
    if(ent->_equivalent_point == 0)
        ent->_equivalent_point = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiEvaluated_degenerate_pcurve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiEvaluated_degenerate_pcurve::get_os_typespec())
                                   SdaiEvaluated_degenerate_pcurve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiEvaluated_degenerate_pcurve::get_os_typespec())
//                                   SdaiEvaluated_degenerate_pcurve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiEvaluated_degenerate_pcurve;
}
#endif

#ifdef __O3DB__
void
SdaiEvaluated_degenerate_pcurve::oodb_reInit ()
{	eDesc = config_control_designe_evaluated_degenerate_pcurve;
	attributes [3].aDesc = a_327equivalent_point;
}
#endif

SdaiEvaluated_degenerate_pcurve::SdaiEvaluated_degenerate_pcurve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiDegenerate_pcurve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiDegenerate_pcurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_evaluated_degenerate_pcurve;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_327equivalent_point, (SCLP23(Application_instance_ptr) *) &_equivalent_point);
#else
    STEPattribute *a = new STEPattribute(*a_327equivalent_point, (SCLP23(Application_instance_ptr) *) &_equivalent_point);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiCartesian_point_ptr
SdaiEvaluated_degenerate_pcurve::equivalent_point_() const
{
    return (SdaiCartesian_point_ptr) _equivalent_point;
}

void
SdaiEvaluated_degenerate_pcurve::equivalent_point_ (const SdaiCartesian_point_ptr x)

{
    _equivalent_point = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY evaluated_degenerate_pcurve


/////////	 ENTITY solid_angle_measure_with_unit

EntityDescriptor *config_control_designe_solid_angle_measure_with_unit =0;
SdaiSolid_angle_measure_with_unit::SdaiSolid_angle_measure_with_unit( )
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_angle_measure_with_unit;
}
SdaiSolid_angle_measure_with_unit::SdaiSolid_angle_measure_with_unit (SdaiSolid_angle_measure_with_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSolid_angle_measure_with_unit::~SdaiSolid_angle_measure_with_unit () {  }

#ifdef __OSTORE__

void
SdaiSolid_angle_measure_with_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSolid_angle_measure_with_unit: virtual access function." << endl;
    SdaiSolid_angle_measure_with_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSolid_angle_measure_with_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSolid_angle_measure_with_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSolid_angle_measure_with_unit *ent = (SdaiSolid_angle_measure_with_unit *)sent;
//    SdaiSolid_angle_measure_with_unit *ent = (SdaiSolid_angle_measure_with_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_solid_angle_measure_with_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiSolid_angle_measure_with_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSolid_angle_measure_with_unit::get_os_typespec())
                                   SdaiSolid_angle_measure_with_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSolid_angle_measure_with_unit::get_os_typespec())
//                                   SdaiSolid_angle_measure_with_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSolid_angle_measure_with_unit;
}
#endif

#ifdef __O3DB__
void
SdaiSolid_angle_measure_with_unit::oodb_reInit ()
{	eDesc = config_control_designe_solid_angle_measure_with_unit;
}
#endif

SdaiSolid_angle_measure_with_unit::SdaiSolid_angle_measure_with_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiMeasure_with_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_angle_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY solid_angle_measure_with_unit


/////////	 ENTITY connected_edge_set

EntityDescriptor *config_control_designe_connected_edge_set =0;
AttrDescriptor *a_328ces_edges =0;
SdaiConnected_edge_set::SdaiConnected_edge_set( )
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_connected_edge_set;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_328ces_edges,  &_ces_edges);
#else
    STEPattribute *a = new STEPattribute(*a_328ces_edges,  &_ces_edges);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiConnected_edge_set::SdaiConnected_edge_set (SdaiConnected_edge_set& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiConnected_edge_set::~SdaiConnected_edge_set () {  }

#ifdef __OSTORE__

void
SdaiConnected_edge_set::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConnected_edge_set: virtual access function." << endl;
    SdaiConnected_edge_set_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiConnected_edge_set_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConnected_edge_set: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiConnected_edge_set *ent = (SdaiConnected_edge_set *)sent;
//    SdaiConnected_edge_set *ent = (SdaiConnected_edge_set *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_connected_edge_set;
    ent->attributes[1].aDesc = a_328ces_edges;
}

SCLP23(Application_instance_ptr)
create_SdaiConnected_edge_set(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiConnected_edge_set::get_os_typespec())
                                   SdaiConnected_edge_set;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiConnected_edge_set::get_os_typespec())
//                                   SdaiConnected_edge_set;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiConnected_edge_set;
}
#endif

#ifdef __O3DB__
void
SdaiConnected_edge_set::oodb_reInit ()
{	eDesc = config_control_designe_connected_edge_set;
	attributes [1].aDesc = a_328ces_edges;
}
#endif

SdaiConnected_edge_set::SdaiConnected_edge_set (SCLP23(Application_instance) *se, int *addAttrs) : SdaiTopological_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_connected_edge_set;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_328ces_edges,  &_ces_edges);
#else
    STEPattribute *a = new STEPattribute(*a_328ces_edges,  &_ces_edges);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const EntityAggregate_ptr
SdaiConnected_edge_set::ces_edges_() const
{
    return (EntityAggregate_ptr) &_ces_edges;
}

void
SdaiConnected_edge_set::ces_edges_ (const EntityAggregate_ptr x)

	{ _ces_edges.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY connected_edge_set


/////////	 ENTITY action

EntityDescriptor *config_control_designe_action =0;
AttrDescriptor *a_329name =0;
AttrDescriptor *a_330description =0;
AttrDescriptor *a_331chosen_method =0;
SdaiAction::SdaiAction( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_329name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_329name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_330description,  &_description);
#else
    a = new STEPattribute(*a_330description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_331chosen_method, (SCLP23(Application_instance_ptr) *) &_chosen_method);
#else
    a = new STEPattribute(*a_331chosen_method, (SCLP23(Application_instance_ptr) *) &_chosen_method);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiAction::SdaiAction (SdaiAction& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAction::~SdaiAction () {  }

#ifdef __OSTORE__

void
SdaiAction::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction: virtual access function." << endl;
    SdaiAction_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAction_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAction: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAction *ent = (SdaiAction *)sent;
//    SdaiAction *ent = (SdaiAction *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_action;
    ent->attributes[0].aDesc = a_329name;
    ent->attributes[1].aDesc = a_330description;
    ent->attributes[2].aDesc = a_331chosen_method;
    if(ent->_chosen_method == 0)
        ent->_chosen_method = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiAction(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAction::get_os_typespec())
                                   SdaiAction;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAction::get_os_typespec())
//                                   SdaiAction;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAction;
}
#endif

#ifdef __O3DB__
void
SdaiAction::oodb_reInit ()
{	eDesc = config_control_designe_action;
	attributes [0].aDesc = a_329name;
	attributes [1].aDesc = a_330description;
	attributes [2].aDesc = a_331chosen_method;
}
#endif

SdaiAction::SdaiAction( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_action;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_329name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_329name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_330description,  &_description);
#else
    a = new STEPattribute(*a_330description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_331chosen_method, (SCLP23(Application_instance_ptr) *) &_chosen_method);
#else
    a = new STEPattribute(*a_331chosen_method, (SCLP23(Application_instance_ptr) *) &_chosen_method);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiAction::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiAction::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiAction::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiAction::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiAction_method_ptr
SdaiAction::chosen_method_() const
{
    return (SdaiAction_method_ptr) _chosen_method;
}

void
SdaiAction::chosen_method_ (const SdaiAction_method_ptr x)

{
    _chosen_method = x;
}

/////////	 END_ENTITY action


/////////	 ENTITY executed_action

EntityDescriptor *config_control_designe_executed_action =0;
SdaiExecuted_action::SdaiExecuted_action( )
{

	/*  parent: SdaiAction  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_executed_action;
}
SdaiExecuted_action::SdaiExecuted_action (SdaiExecuted_action& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiExecuted_action::~SdaiExecuted_action () {  }

#ifdef __OSTORE__

void
SdaiExecuted_action::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiExecuted_action: virtual access function." << endl;
    SdaiExecuted_action_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiExecuted_action_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiExecuted_action: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiExecuted_action *ent = (SdaiExecuted_action *)sent;
//    SdaiExecuted_action *ent = (SdaiExecuted_action *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_executed_action;
}

SCLP23(Application_instance_ptr)
create_SdaiExecuted_action(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiExecuted_action::get_os_typespec())
                                   SdaiExecuted_action;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiExecuted_action::get_os_typespec())
//                                   SdaiExecuted_action;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiExecuted_action;
}
#endif

#ifdef __O3DB__
void
SdaiExecuted_action::oodb_reInit ()
{	eDesc = config_control_designe_executed_action;
}
#endif

SdaiExecuted_action::SdaiExecuted_action (SCLP23(Application_instance) *se, int *addAttrs) : SdaiAction(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiAction  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_executed_action;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY executed_action


/////////	 ENTITY directed_action

EntityDescriptor *config_control_designe_directed_action =0;
AttrDescriptor *a_332directive =0;
SdaiDirected_action::SdaiDirected_action( )
{

	/*  parent: SdaiExecuted_action  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_directed_action;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_332directive, (SCLP23(Application_instance_ptr) *) &_directive);
#else
    STEPattribute *a = new STEPattribute(*a_332directive, (SCLP23(Application_instance_ptr) *) &_directive);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDirected_action::SdaiDirected_action (SdaiDirected_action& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDirected_action::~SdaiDirected_action () {  }

#ifdef __OSTORE__

void
SdaiDirected_action::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDirected_action: virtual access function." << endl;
    SdaiDirected_action_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDirected_action_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDirected_action: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDirected_action *ent = (SdaiDirected_action *)sent;
//    SdaiDirected_action *ent = (SdaiDirected_action *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_directed_action;
    ent->attributes[3].aDesc = a_332directive;
    if(ent->_directive == 0)
        ent->_directive = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiDirected_action(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDirected_action::get_os_typespec())
                                   SdaiDirected_action;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDirected_action::get_os_typespec())
//                                   SdaiDirected_action;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDirected_action;
}
#endif

#ifdef __O3DB__
void
SdaiDirected_action::oodb_reInit ()
{	eDesc = config_control_designe_directed_action;
	attributes [3].aDesc = a_332directive;
}
#endif

SdaiDirected_action::SdaiDirected_action (SCLP23(Application_instance) *se, int *addAttrs) : SdaiExecuted_action(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiExecuted_action  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_directed_action;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_332directive, (SCLP23(Application_instance_ptr) *) &_directive);
#else
    STEPattribute *a = new STEPattribute(*a_332directive, (SCLP23(Application_instance_ptr) *) &_directive);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiAction_directive_ptr
SdaiDirected_action::directive_() const
{
    return (SdaiAction_directive_ptr) _directive;
}

void
SdaiDirected_action::directive_ (const SdaiAction_directive_ptr x)

{
    _directive = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY directed_action


/////////	 ENTITY organizational_project

EntityDescriptor *config_control_designe_organizational_project =0;
AttrDescriptor *a_333name =0;
AttrDescriptor *a_334description =0;
AttrDescriptor *a_335responsible_organizations =0;
SdaiOrganizational_project::SdaiOrganizational_project( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_organizational_project;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_333name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_333name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_334description,  &_description);
#else
    a = new STEPattribute(*a_334description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_335responsible_organizations,  &_responsible_organizations);
#else
    a = new STEPattribute(*a_335responsible_organizations,  &_responsible_organizations);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiOrganizational_project::SdaiOrganizational_project (SdaiOrganizational_project& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOrganizational_project::~SdaiOrganizational_project () {  }

#ifdef __OSTORE__

void
SdaiOrganizational_project::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOrganizational_project: virtual access function." << endl;
    SdaiOrganizational_project_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOrganizational_project_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOrganizational_project: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOrganizational_project *ent = (SdaiOrganizational_project *)sent;
//    SdaiOrganizational_project *ent = (SdaiOrganizational_project *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_organizational_project;
    ent->attributes[0].aDesc = a_333name;
    ent->attributes[1].aDesc = a_334description;
    ent->attributes[2].aDesc = a_335responsible_organizations;
}

SCLP23(Application_instance_ptr)
create_SdaiOrganizational_project(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOrganizational_project::get_os_typespec())
                                   SdaiOrganizational_project;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOrganizational_project::get_os_typespec())
//                                   SdaiOrganizational_project;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOrganizational_project;
}
#endif

#ifdef __O3DB__
void
SdaiOrganizational_project::oodb_reInit ()
{	eDesc = config_control_designe_organizational_project;
	attributes [0].aDesc = a_333name;
	attributes [1].aDesc = a_334description;
	attributes [2].aDesc = a_335responsible_organizations;
}
#endif

SdaiOrganizational_project::SdaiOrganizational_project( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_organizational_project;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_333name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_333name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_334description,  &_description);
#else
    a = new STEPattribute(*a_334description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_335responsible_organizations,  &_responsible_organizations);
#else
    a = new STEPattribute(*a_335responsible_organizations,  &_responsible_organizations);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiOrganizational_project::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiOrganizational_project::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiOrganizational_project::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiOrganizational_project::description_ (const SdaiText x)

{
    _description = x;
}

const EntityAggregate_ptr
SdaiOrganizational_project::responsible_organizations_() const
{
    return (EntityAggregate_ptr) &_responsible_organizations;
}

void
SdaiOrganizational_project::responsible_organizations_ (const EntityAggregate_ptr x)

	{ _responsible_organizations.ShallowCopy (*x); }

/////////	 END_ENTITY organizational_project


/////////	 ENTITY date_time_role

EntityDescriptor *config_control_designe_date_time_role =0;
AttrDescriptor *a_336name =0;
SdaiDate_time_role::SdaiDate_time_role( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_date_time_role;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_336name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_336name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDate_time_role::SdaiDate_time_role (SdaiDate_time_role& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDate_time_role::~SdaiDate_time_role () {  }

#ifdef __OSTORE__

void
SdaiDate_time_role::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDate_time_role: virtual access function." << endl;
    SdaiDate_time_role_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDate_time_role_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDate_time_role: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDate_time_role *ent = (SdaiDate_time_role *)sent;
//    SdaiDate_time_role *ent = (SdaiDate_time_role *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_date_time_role;
    ent->attributes[0].aDesc = a_336name;
}

SCLP23(Application_instance_ptr)
create_SdaiDate_time_role(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDate_time_role::get_os_typespec())
                                   SdaiDate_time_role;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDate_time_role::get_os_typespec())
//                                   SdaiDate_time_role;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDate_time_role;
}
#endif

#ifdef __O3DB__
void
SdaiDate_time_role::oodb_reInit ()
{	eDesc = config_control_designe_date_time_role;
	attributes [0].aDesc = a_336name;
}
#endif

SdaiDate_time_role::SdaiDate_time_role( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_date_time_role;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_336name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_336name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiDate_time_role::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiDate_time_role::name_ (const SdaiLabel x)

{
    _name = x;
}

/////////	 END_ENTITY date_time_role


/////////	 ENTITY curve_bounded_surface

EntityDescriptor *config_control_designe_curve_bounded_surface =0;
AttrDescriptor *a_337basis_surface =0;
AttrDescriptor *a_338boundaries =0;
AttrDescriptor *a_339implicit_outer =0;
SdaiCurve_bounded_surface::SdaiCurve_bounded_surface( )
{

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve_bounded_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_337basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_337basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_338boundaries,  &_boundaries);
#else
    a = new STEPattribute(*a_338boundaries,  &_boundaries);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_339implicit_outer,  &_implicit_outer);
#else
    a = new STEPattribute(*a_339implicit_outer,  &_implicit_outer);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiCurve_bounded_surface::SdaiCurve_bounded_surface (SdaiCurve_bounded_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCurve_bounded_surface::~SdaiCurve_bounded_surface () {  }

#ifdef __OSTORE__

void
SdaiCurve_bounded_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCurve_bounded_surface: virtual access function." << endl;
    SdaiCurve_bounded_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCurve_bounded_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCurve_bounded_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCurve_bounded_surface *ent = (SdaiCurve_bounded_surface *)sent;
//    SdaiCurve_bounded_surface *ent = (SdaiCurve_bounded_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_curve_bounded_surface;
    ent->attributes[1].aDesc = a_337basis_surface;
    if(ent->_basis_surface == 0)
        ent->_basis_surface = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_338boundaries;
    ent->attributes[3].aDesc = a_339implicit_outer;
}

SCLP23(Application_instance_ptr)
create_SdaiCurve_bounded_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCurve_bounded_surface::get_os_typespec())
                                   SdaiCurve_bounded_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCurve_bounded_surface::get_os_typespec())
//                                   SdaiCurve_bounded_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCurve_bounded_surface;
}
#endif

#ifdef __O3DB__
void
SdaiCurve_bounded_surface::oodb_reInit ()
{	eDesc = config_control_designe_curve_bounded_surface;
	attributes [1].aDesc = a_337basis_surface;
	attributes [2].aDesc = a_338boundaries;
	attributes [3].aDesc = a_339implicit_outer;
}
#endif

SdaiCurve_bounded_surface::SdaiCurve_bounded_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiBounded_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve_bounded_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_337basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#else
    STEPattribute *a = new STEPattribute(*a_337basis_surface, (SCLP23(Application_instance_ptr) *) &_basis_surface);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_338boundaries,  &_boundaries);
#else
    a = new STEPattribute(*a_338boundaries,  &_boundaries);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_339implicit_outer,  &_implicit_outer);
#else
    a = new STEPattribute(*a_339implicit_outer,  &_implicit_outer);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiSurface_ptr
SdaiCurve_bounded_surface::basis_surface_() const
{
    return (SdaiSurface_ptr) _basis_surface;
}

void
SdaiCurve_bounded_surface::basis_surface_ (const SdaiSurface_ptr x)

{
    _basis_surface = x;
}

const EntityAggregate_ptr
SdaiCurve_bounded_surface::boundaries_() const
{
    return (EntityAggregate_ptr) &_boundaries;
}

void
SdaiCurve_bounded_surface::boundaries_ (const EntityAggregate_ptr x)

	{ _boundaries.ShallowCopy (*x); }

const SCLBOOL(Bool)
SdaiCurve_bounded_surface::implicit_outer_() const
{
    return (SCLBOOL(Bool)) _implicit_outer;
}

void
SdaiCurve_bounded_surface::implicit_outer_ (const SCLBOOL(Bool) x)

{
    _implicit_outer.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY curve_bounded_surface


/////////	 ENTITY closed_shell

EntityDescriptor *config_control_designe_closed_shell =0;
SdaiClosed_shell::SdaiClosed_shell( )
{

	/*  parent: SdaiConnected_face_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_closed_shell;
}
SdaiClosed_shell::SdaiClosed_shell (SdaiClosed_shell& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiClosed_shell::~SdaiClosed_shell () {  }

#ifdef __OSTORE__

void
SdaiClosed_shell::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiClosed_shell: virtual access function." << endl;
    SdaiClosed_shell_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiClosed_shell_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiClosed_shell: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiClosed_shell *ent = (SdaiClosed_shell *)sent;
//    SdaiClosed_shell *ent = (SdaiClosed_shell *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_closed_shell;
}

SCLP23(Application_instance_ptr)
create_SdaiClosed_shell(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiClosed_shell::get_os_typespec())
                                   SdaiClosed_shell;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiClosed_shell::get_os_typespec())
//                                   SdaiClosed_shell;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiClosed_shell;
}
#endif

#ifdef __O3DB__
void
SdaiClosed_shell::oodb_reInit ()
{	eDesc = config_control_designe_closed_shell;
}
#endif

SdaiClosed_shell::SdaiClosed_shell (SCLP23(Application_instance) *se, int *addAttrs) : SdaiConnected_face_set(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiConnected_face_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_closed_shell;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY closed_shell


/////////	 ENTITY design_make_from_relationship

EntityDescriptor *config_control_designe_design_make_from_relationship =0;
SdaiDesign_make_from_relationship::SdaiDesign_make_from_relationship( )
{

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_design_make_from_relationship;
}
SdaiDesign_make_from_relationship::SdaiDesign_make_from_relationship (SdaiDesign_make_from_relationship& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDesign_make_from_relationship::~SdaiDesign_make_from_relationship () {  }

#ifdef __OSTORE__

void
SdaiDesign_make_from_relationship::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDesign_make_from_relationship: virtual access function." << endl;
    SdaiDesign_make_from_relationship_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDesign_make_from_relationship_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDesign_make_from_relationship: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDesign_make_from_relationship *ent = (SdaiDesign_make_from_relationship *)sent;
//    SdaiDesign_make_from_relationship *ent = (SdaiDesign_make_from_relationship *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_design_make_from_relationship;
}

SCLP23(Application_instance_ptr)
create_SdaiDesign_make_from_relationship(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDesign_make_from_relationship::get_os_typespec())
                                   SdaiDesign_make_from_relationship;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDesign_make_from_relationship::get_os_typespec())
//                                   SdaiDesign_make_from_relationship;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDesign_make_from_relationship;
}
#endif

#ifdef __O3DB__
void
SdaiDesign_make_from_relationship::oodb_reInit ()
{	eDesc = config_control_designe_design_make_from_relationship;
}
#endif

SdaiDesign_make_from_relationship::SdaiDesign_make_from_relationship (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProduct_definition_relationship(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_design_make_from_relationship;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY design_make_from_relationship


/////////	 ENTITY definitional_representation

EntityDescriptor *config_control_designe_definitional_representation =0;
SdaiDefinitional_representation::SdaiDefinitional_representation( )
{

	/*  parent: SdaiRepresentation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_definitional_representation;
}
SdaiDefinitional_representation::SdaiDefinitional_representation (SdaiDefinitional_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDefinitional_representation::~SdaiDefinitional_representation () {  }

#ifdef __OSTORE__

void
SdaiDefinitional_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDefinitional_representation: virtual access function." << endl;
    SdaiDefinitional_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDefinitional_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDefinitional_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDefinitional_representation *ent = (SdaiDefinitional_representation *)sent;
//    SdaiDefinitional_representation *ent = (SdaiDefinitional_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_definitional_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiDefinitional_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDefinitional_representation::get_os_typespec())
                                   SdaiDefinitional_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDefinitional_representation::get_os_typespec())
//                                   SdaiDefinitional_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDefinitional_representation;
}
#endif

#ifdef __O3DB__
void
SdaiDefinitional_representation::oodb_reInit ()
{	eDesc = config_control_designe_definitional_representation;
}
#endif

SdaiDefinitional_representation::SdaiDefinitional_representation (SCLP23(Application_instance) *se, int *addAttrs) : SdaiRepresentation(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiRepresentation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_definitional_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY definitional_representation


/////////	 ENTITY product_definition_shape

EntityDescriptor *config_control_designe_product_definition_shape =0;
SdaiProduct_definition_shape::SdaiProduct_definition_shape( )
{

	/*  parent: SdaiProperty_definition  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_shape;
}
SdaiProduct_definition_shape::SdaiProduct_definition_shape (SdaiProduct_definition_shape& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_definition_shape::~SdaiProduct_definition_shape () {  }

#ifdef __OSTORE__

void
SdaiProduct_definition_shape::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_shape: virtual access function." << endl;
    SdaiProduct_definition_shape_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_definition_shape_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_shape: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_definition_shape *ent = (SdaiProduct_definition_shape *)sent;
//    SdaiProduct_definition_shape *ent = (SdaiProduct_definition_shape *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_definition_shape;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_definition_shape(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_definition_shape::get_os_typespec())
                                   SdaiProduct_definition_shape;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_definition_shape::get_os_typespec())
//                                   SdaiProduct_definition_shape;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_definition_shape;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_definition_shape::oodb_reInit ()
{	eDesc = config_control_designe_product_definition_shape;
}
#endif

SdaiProduct_definition_shape::SdaiProduct_definition_shape (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProperty_definition(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProperty_definition  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_shape;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_shape


/////////	 ENTITY si_unit

EntityDescriptor *config_control_designe_si_unit =0;
AttrDescriptor *a_340prefix =0;
AttrDescriptor *a_341name =0;
Derived_attribute *a_342Dnamed_unit_dimensions =0;
SdaiSi_unit::SdaiSi_unit( )
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_si_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_340prefix,  &_prefix);
#else
    STEPattribute *a = new STEPattribute(*a_340prefix,  &_prefix);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_341name,  &_name);
#else
    a = new STEPattribute(*a_341name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dimensions");
}
SdaiSi_unit::SdaiSi_unit (SdaiSi_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSi_unit::~SdaiSi_unit () {  }

#ifdef __OSTORE__

void
SdaiSi_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSi_unit: virtual access function." << endl;
    SdaiSi_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSi_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSi_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSi_unit *ent = (SdaiSi_unit *)sent;
//    SdaiSi_unit *ent = (SdaiSi_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_si_unit;
    ent->attributes[1].aDesc = a_340prefix;
    ent->attributes[2].aDesc = a_341name;
}

SCLP23(Application_instance_ptr)
create_SdaiSi_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSi_unit::get_os_typespec())
                                   SdaiSi_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSi_unit::get_os_typespec())
//                                   SdaiSi_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSi_unit;
}
#endif

#ifdef __O3DB__
void
SdaiSi_unit::oodb_reInit ()
{	eDesc = config_control_designe_si_unit;
	attributes [1].aDesc = a_340prefix;
	attributes [2].aDesc = a_341name;
}
#endif

SdaiSi_unit::SdaiSi_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiNamed_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_si_unit;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_340prefix,  &_prefix);
#else
    STEPattribute *a = new STEPattribute(*a_340prefix,  &_prefix);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_341name,  &_name);
#else
    a = new STEPattribute(*a_341name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dimensions");
}

const SdaiSi_prefix_var
SdaiSi_unit::prefix_() const
{
    return (Si_prefix) _prefix;
}

void
SdaiSi_unit::prefix_ (const SdaiSi_prefix_var x)

{
    _prefix.put (x);
}

const SdaiSi_unit_name_var
SdaiSi_unit::name_() const
{
    return (Si_unit_name) _name;
}

void
SdaiSi_unit::name_ (const SdaiSi_unit_name_var x)

{
    _name.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY si_unit


/////////	 ENTITY bezier_surface

EntityDescriptor *config_control_designe_bezier_surface =0;
SdaiBezier_surface::SdaiBezier_surface( )
{

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bezier_surface;
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
}
SdaiBezier_surface::SdaiBezier_surface (SdaiBezier_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiBezier_surface::~SdaiBezier_surface () {  }

#ifdef __OSTORE__

void
SdaiBezier_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBezier_surface: virtual access function." << endl;
    SdaiBezier_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiBezier_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiBezier_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiBezier_surface *ent = (SdaiBezier_surface *)sent;
//    SdaiBezier_surface *ent = (SdaiBezier_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_bezier_surface;
}

SCLP23(Application_instance_ptr)
create_SdaiBezier_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiBezier_surface::get_os_typespec())
                                   SdaiBezier_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiBezier_surface::get_os_typespec())
//                                   SdaiBezier_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiBezier_surface;
}
#endif

#ifdef __O3DB__
void
SdaiBezier_surface::oodb_reInit ()
{	eDesc = config_control_designe_bezier_surface;
}
#endif

SdaiBezier_surface::SdaiBezier_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiB_spline_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bezier_surface;
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY bezier_surface


/////////	 ENTITY certification_assignment

EntityDescriptor *config_control_designe_certification_assignment =0;
AttrDescriptor *a_343assigned_certification =0;
SdaiCertification_assignment::SdaiCertification_assignment( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_certification_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_343assigned_certification, (SCLP23(Application_instance_ptr) *) &_assigned_certification);
#else
    STEPattribute *a = new STEPattribute(*a_343assigned_certification, (SCLP23(Application_instance_ptr) *) &_assigned_certification);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCertification_assignment::SdaiCertification_assignment (SdaiCertification_assignment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCertification_assignment::~SdaiCertification_assignment () {  }

#ifdef __OSTORE__

void
SdaiCertification_assignment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCertification_assignment: virtual access function." << endl;
    SdaiCertification_assignment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCertification_assignment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCertification_assignment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCertification_assignment *ent = (SdaiCertification_assignment *)sent;
//    SdaiCertification_assignment *ent = (SdaiCertification_assignment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_certification_assignment;
    ent->attributes[0].aDesc = a_343assigned_certification;
    if(ent->_assigned_certification == 0)
        ent->_assigned_certification = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiCertification_assignment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCertification_assignment::get_os_typespec())
                                   SdaiCertification_assignment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCertification_assignment::get_os_typespec())
//                                   SdaiCertification_assignment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCertification_assignment;
}
#endif

#ifdef __O3DB__
void
SdaiCertification_assignment::oodb_reInit ()
{	eDesc = config_control_designe_certification_assignment;
	attributes [0].aDesc = a_343assigned_certification;
}
#endif

SdaiCertification_assignment::SdaiCertification_assignment( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_certification_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_343assigned_certification, (SCLP23(Application_instance_ptr) *) &_assigned_certification);
#else
    STEPattribute *a = new STEPattribute(*a_343assigned_certification, (SCLP23(Application_instance_ptr) *) &_assigned_certification);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiCertification_ptr
SdaiCertification_assignment::assigned_certification_() const
{
    return (SdaiCertification_ptr) _assigned_certification;
}

void
SdaiCertification_assignment::assigned_certification_ (const SdaiCertification_ptr x)

{
    _assigned_certification = x;
}

/////////	 END_ENTITY certification_assignment


/////////	 ENTITY start_work

EntityDescriptor *config_control_designe_start_work =0;
AttrDescriptor *a_344items =0;
SdaiStart_work::SdaiStart_work( )
{

	/*  parent: SdaiAction_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_start_work;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_344items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_344items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiStart_work::SdaiStart_work (SdaiStart_work& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiStart_work::~SdaiStart_work () {  }

#ifdef __OSTORE__

void
SdaiStart_work::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiStart_work: virtual access function." << endl;
    SdaiStart_work_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiStart_work_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiStart_work: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiStart_work *ent = (SdaiStart_work *)sent;
//    SdaiStart_work *ent = (SdaiStart_work *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_start_work;
    ent->attributes[1].aDesc = a_344items;
}

SCLP23(Application_instance_ptr)
create_SdaiStart_work(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiStart_work::get_os_typespec())
                                   SdaiStart_work;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiStart_work::get_os_typespec())
//                                   SdaiStart_work;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiStart_work;
}
#endif

#ifdef __O3DB__
void
SdaiStart_work::oodb_reInit ()
{	eDesc = config_control_designe_start_work;
	attributes [1].aDesc = a_344items;
}
#endif

SdaiStart_work::SdaiStart_work (SCLP23(Application_instance) *se, int *addAttrs) : SdaiAction_assignment(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiAction_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_start_work;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_344items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_344items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiWork_items_ptr
SdaiStart_work::items_() const
{
    return (SdaiWork_items_ptr) &_items;
}

void
SdaiStart_work::items_ (const SdaiWork_items_ptr x)

	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY start_work


/////////	 ENTITY contract_type

EntityDescriptor *config_control_designe_contract_type =0;
AttrDescriptor *a_345description =0;
SdaiContract_type::SdaiContract_type( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_contract_type;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_345description,  &_description);
#else
    STEPattribute *a = new STEPattribute(*a_345description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiContract_type::SdaiContract_type (SdaiContract_type& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiContract_type::~SdaiContract_type () {  }

#ifdef __OSTORE__

void
SdaiContract_type::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiContract_type: virtual access function." << endl;
    SdaiContract_type_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiContract_type_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiContract_type: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiContract_type *ent = (SdaiContract_type *)sent;
//    SdaiContract_type *ent = (SdaiContract_type *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_contract_type;
    ent->attributes[0].aDesc = a_345description;
}

SCLP23(Application_instance_ptr)
create_SdaiContract_type(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiContract_type::get_os_typespec())
                                   SdaiContract_type;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiContract_type::get_os_typespec())
//                                   SdaiContract_type;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiContract_type;
}
#endif

#ifdef __O3DB__
void
SdaiContract_type::oodb_reInit ()
{	eDesc = config_control_designe_contract_type;
	attributes [0].aDesc = a_345description;
}
#endif

SdaiContract_type::SdaiContract_type( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_contract_type;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_345description,  &_description);
#else
    STEPattribute *a = new STEPattribute(*a_345description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiContract_type::description_() const
{
    return (const SdaiLabel) _description;
}

void
SdaiContract_type::description_ (const SdaiLabel x)

{
    _description = x;
}

/////////	 END_ENTITY contract_type


/////////	 ENTITY b_spline_curve_with_knots

EntityDescriptor *config_control_designe_b_spline_curve_with_knots =0;
AttrDescriptor *a_346knot_multiplicities =0;
AttrDescriptor *a_347knots =0;
AttrDescriptor *a_348knot_spec =0;
Derived_attribute *a_349Dupper_index_on_knots =0;
SdaiB_spline_curve_with_knots::SdaiB_spline_curve_with_knots( )
{

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_curve_with_knots;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_346knot_multiplicities,  &_knot_multiplicities);
#else
    STEPattribute *a = new STEPattribute(*a_346knot_multiplicities,  &_knot_multiplicities);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_347knots,  &_knots);
#else
    a = new STEPattribute(*a_347knots,  &_knots);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_348knot_spec,  &_knot_spec);
#else
    a = new STEPattribute(*a_348knot_spec,  &_knot_spec);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
    MakeDerived ("upper_index_on_knots");
}
SdaiB_spline_curve_with_knots::SdaiB_spline_curve_with_knots (SdaiB_spline_curve_with_knots& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiB_spline_curve_with_knots::~SdaiB_spline_curve_with_knots () {  }

#ifdef __OSTORE__

void
SdaiB_spline_curve_with_knots::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiB_spline_curve_with_knots: virtual access function." << endl;
    SdaiB_spline_curve_with_knots_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiB_spline_curve_with_knots_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiB_spline_curve_with_knots: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiB_spline_curve_with_knots *ent = (SdaiB_spline_curve_with_knots *)sent;
//    SdaiB_spline_curve_with_knots *ent = (SdaiB_spline_curve_with_knots *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_b_spline_curve_with_knots;
    ent->attributes[6].aDesc = a_346knot_multiplicities;
    ent->attributes[7].aDesc = a_347knots;
    ent->attributes[8].aDesc = a_348knot_spec;
}

SCLP23(Application_instance_ptr)
create_SdaiB_spline_curve_with_knots(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiB_spline_curve_with_knots::get_os_typespec())
                                   SdaiB_spline_curve_with_knots;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiB_spline_curve_with_knots::get_os_typespec())
//                                   SdaiB_spline_curve_with_knots;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiB_spline_curve_with_knots;
}
#endif

#ifdef __O3DB__
void
SdaiB_spline_curve_with_knots::oodb_reInit ()
{	eDesc = config_control_designe_b_spline_curve_with_knots;
	attributes [6].aDesc = a_346knot_multiplicities;
	attributes [7].aDesc = a_347knots;
	attributes [8].aDesc = a_348knot_spec;
}
#endif

SdaiB_spline_curve_with_knots::SdaiB_spline_curve_with_knots (SCLP23(Application_instance) *se, int *addAttrs) : SdaiB_spline_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_curve_with_knots;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_346knot_multiplicities,  &_knot_multiplicities);
#else
    STEPattribute *a = new STEPattribute(*a_346knot_multiplicities,  &_knot_multiplicities);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_347knots,  &_knots);
#else
    a = new STEPattribute(*a_347knots,  &_knots);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_348knot_spec,  &_knot_spec);
#else
    a = new STEPattribute(*a_348knot_spec,  &_knot_spec);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("upper_index_on_control_points");
    MakeDerived ("control_points");
    MakeDerived ("upper_index_on_knots");
}

const IntAggregate_ptr
SdaiB_spline_curve_with_knots::knot_multiplicities_() const
{
    return (IntAggregate_ptr) &_knot_multiplicities;
}

void
SdaiB_spline_curve_with_knots::knot_multiplicities_ (const IntAggregate_ptr x)

	{ _knot_multiplicities.ShallowCopy (*x); }

const RealAggregate_ptr
SdaiB_spline_curve_with_knots::knots_() const
{
    return (RealAggregate_ptr) &_knots;
}

void
SdaiB_spline_curve_with_knots::knots_ (const RealAggregate_ptr x)

	{ _knots.ShallowCopy (*x); }

const SdaiKnot_type_var
SdaiB_spline_curve_with_knots::knot_spec_() const
{
    return (Knot_type) _knot_spec;
}

void
SdaiB_spline_curve_with_knots::knot_spec_ (const SdaiKnot_type_var x)

{
    _knot_spec.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY b_spline_curve_with_knots


/////////	 ENTITY cc_design_approval

EntityDescriptor *config_control_designe_cc_design_approval =0;
AttrDescriptor *a_350items =0;
SdaiCc_design_approval::SdaiCc_design_approval( )
{

	/*  parent: SdaiApproval_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_approval;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_350items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_350items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_approval::SdaiCc_design_approval (SdaiCc_design_approval& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCc_design_approval::~SdaiCc_design_approval () {  }

#ifdef __OSTORE__

void
SdaiCc_design_approval::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_approval: virtual access function." << endl;
    SdaiCc_design_approval_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCc_design_approval_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_approval: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCc_design_approval *ent = (SdaiCc_design_approval *)sent;
//    SdaiCc_design_approval *ent = (SdaiCc_design_approval *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_cc_design_approval;
    ent->attributes[1].aDesc = a_350items;
}

SCLP23(Application_instance_ptr)
create_SdaiCc_design_approval(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCc_design_approval::get_os_typespec())
                                   SdaiCc_design_approval;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCc_design_approval::get_os_typespec())
//                                   SdaiCc_design_approval;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCc_design_approval;
}
#endif

#ifdef __O3DB__
void
SdaiCc_design_approval::oodb_reInit ()
{	eDesc = config_control_designe_cc_design_approval;
	attributes [1].aDesc = a_350items;
}
#endif

SdaiCc_design_approval::SdaiCc_design_approval (SCLP23(Application_instance) *se, int *addAttrs) : SdaiApproval_assignment(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiApproval_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_approval;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_350items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_350items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiApproved_items_ptr
SdaiCc_design_approval::items_() const
{
    return (SdaiApproved_items_ptr) &_items;
}

void
SdaiCc_design_approval::items_ (const SdaiApproved_items_ptr x)

	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_approval


/////////	 ENTITY edge_based_wireframe_shape_representation

EntityDescriptor *config_control_designe_edge_based_wireframe_shape_representation =0;
SdaiEdge_based_wireframe_shape_representation::SdaiEdge_based_wireframe_shape_representation( )
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge_based_wireframe_shape_representation;
}
SdaiEdge_based_wireframe_shape_representation::SdaiEdge_based_wireframe_shape_representation (SdaiEdge_based_wireframe_shape_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiEdge_based_wireframe_shape_representation::~SdaiEdge_based_wireframe_shape_representation () {  }

#ifdef __OSTORE__

void
SdaiEdge_based_wireframe_shape_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEdge_based_wireframe_shape_representation: virtual access function." << endl;
    SdaiEdge_based_wireframe_shape_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiEdge_based_wireframe_shape_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiEdge_based_wireframe_shape_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiEdge_based_wireframe_shape_representation *ent = (SdaiEdge_based_wireframe_shape_representation *)sent;
//    SdaiEdge_based_wireframe_shape_representation *ent = (SdaiEdge_based_wireframe_shape_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_edge_based_wireframe_shape_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiEdge_based_wireframe_shape_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiEdge_based_wireframe_shape_representation::get_os_typespec())
                                   SdaiEdge_based_wireframe_shape_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiEdge_based_wireframe_shape_representation::get_os_typespec())
//                                   SdaiEdge_based_wireframe_shape_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiEdge_based_wireframe_shape_representation;
}
#endif

#ifdef __O3DB__
void
SdaiEdge_based_wireframe_shape_representation::oodb_reInit ()
{	eDesc = config_control_designe_edge_based_wireframe_shape_representation;
}
#endif

SdaiEdge_based_wireframe_shape_representation::SdaiEdge_based_wireframe_shape_representation (SCLP23(Application_instance) *se, int *addAttrs) : SdaiShape_representation(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge_based_wireframe_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY edge_based_wireframe_shape_representation


/////////	 ENTITY geometrically_bounded_wireframe_shape_representation

EntityDescriptor *config_control_designe_geometrically_bounded_wireframe_shape_representation =0;
SdaiGeometrically_bounded_wireframe_shape_representation::SdaiGeometrically_bounded_wireframe_shape_representation( )
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometrically_bounded_wireframe_shape_representation;
}
SdaiGeometrically_bounded_wireframe_shape_representation::SdaiGeometrically_bounded_wireframe_shape_representation (SdaiGeometrically_bounded_wireframe_shape_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiGeometrically_bounded_wireframe_shape_representation::~SdaiGeometrically_bounded_wireframe_shape_representation () {  }

#ifdef __OSTORE__

void
SdaiGeometrically_bounded_wireframe_shape_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometrically_bounded_wireframe_shape_representation: virtual access function." << endl;
    SdaiGeometrically_bounded_wireframe_shape_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiGeometrically_bounded_wireframe_shape_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGeometrically_bounded_wireframe_shape_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiGeometrically_bounded_wireframe_shape_representation *ent = (SdaiGeometrically_bounded_wireframe_shape_representation *)sent;
//    SdaiGeometrically_bounded_wireframe_shape_representation *ent = (SdaiGeometrically_bounded_wireframe_shape_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_geometrically_bounded_wireframe_shape_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiGeometrically_bounded_wireframe_shape_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiGeometrically_bounded_wireframe_shape_representation::get_os_typespec())
                                   SdaiGeometrically_bounded_wireframe_shape_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiGeometrically_bounded_wireframe_shape_representation::get_os_typespec())
//                                   SdaiGeometrically_bounded_wireframe_shape_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiGeometrically_bounded_wireframe_shape_representation;
}
#endif

#ifdef __O3DB__
void
SdaiGeometrically_bounded_wireframe_shape_representation::oodb_reInit ()
{	eDesc = config_control_designe_geometrically_bounded_wireframe_shape_representation;
}
#endif

SdaiGeometrically_bounded_wireframe_shape_representation::SdaiGeometrically_bounded_wireframe_shape_representation (SCLP23(Application_instance) *se, int *addAttrs) : SdaiShape_representation(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometrically_bounded_wireframe_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometrically_bounded_wireframe_shape_representation


/////////	 ENTITY product_concept

EntityDescriptor *config_control_designe_product_concept =0;
AttrDescriptor *a_351id =0;
AttrDescriptor *a_352name =0;
AttrDescriptor *a_353description =0;
AttrDescriptor *a_354market_context =0;
SdaiProduct_concept::SdaiProduct_concept( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_concept;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_351id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_351id,  &_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_352name,  &_name);
#else
    a = new STEPattribute(*a_352name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_353description,  &_description);
#else
    a = new STEPattribute(*a_353description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_354market_context, (SCLP23(Application_instance_ptr) *) &_market_context);
#else
    a = new STEPattribute(*a_354market_context, (SCLP23(Application_instance_ptr) *) &_market_context);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_concept::SdaiProduct_concept (SdaiProduct_concept& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_concept::~SdaiProduct_concept () {  }

#ifdef __OSTORE__

void
SdaiProduct_concept::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_concept: virtual access function." << endl;
    SdaiProduct_concept_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_concept_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_concept: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_concept *ent = (SdaiProduct_concept *)sent;
//    SdaiProduct_concept *ent = (SdaiProduct_concept *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_concept;
    ent->attributes[0].aDesc = a_351id;
    ent->attributes[1].aDesc = a_352name;
    ent->attributes[2].aDesc = a_353description;
    ent->attributes[3].aDesc = a_354market_context;
    if(ent->_market_context == 0)
        ent->_market_context = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_concept(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_concept::get_os_typespec())
                                   SdaiProduct_concept;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_concept::get_os_typespec())
//                                   SdaiProduct_concept;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_concept;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_concept::oodb_reInit ()
{	eDesc = config_control_designe_product_concept;
	attributes [0].aDesc = a_351id;
	attributes [1].aDesc = a_352name;
	attributes [2].aDesc = a_353description;
	attributes [3].aDesc = a_354market_context;
}
#endif

SdaiProduct_concept::SdaiProduct_concept( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_product_concept;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_351id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_351id,  &_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_352name,  &_name);
#else
    a = new STEPattribute(*a_352name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_353description,  &_description);
#else
    a = new STEPattribute(*a_353description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_354market_context, (SCLP23(Application_instance_ptr) *) &_market_context);
#else
    a = new STEPattribute(*a_354market_context, (SCLP23(Application_instance_ptr) *) &_market_context);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiProduct_concept::id_() const
{
    return (const SdaiIdentifier) _id;
}

void
SdaiProduct_concept::id_ (const SdaiIdentifier x)

{
    _id = x;
}

const SdaiLabel
SdaiProduct_concept::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiProduct_concept::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiProduct_concept::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiProduct_concept::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiProduct_concept_context_ptr
SdaiProduct_concept::market_context_() const
{
    return (SdaiProduct_concept_context_ptr) _market_context;
}

void
SdaiProduct_concept::market_context_ (const SdaiProduct_concept_context_ptr x)

{
    _market_context = x;
}

/////////	 END_ENTITY product_concept


/////////	 ENTITY cc_design_contract

EntityDescriptor *config_control_designe_cc_design_contract =0;
AttrDescriptor *a_355items =0;
SdaiCc_design_contract::SdaiCc_design_contract( )
{

	/*  parent: SdaiContract_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_contract;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_355items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_355items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_contract::SdaiCc_design_contract (SdaiCc_design_contract& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCc_design_contract::~SdaiCc_design_contract () {  }

#ifdef __OSTORE__

void
SdaiCc_design_contract::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_contract: virtual access function." << endl;
    SdaiCc_design_contract_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCc_design_contract_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_contract: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCc_design_contract *ent = (SdaiCc_design_contract *)sent;
//    SdaiCc_design_contract *ent = (SdaiCc_design_contract *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_cc_design_contract;
    ent->attributes[1].aDesc = a_355items;
}

SCLP23(Application_instance_ptr)
create_SdaiCc_design_contract(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCc_design_contract::get_os_typespec())
                                   SdaiCc_design_contract;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCc_design_contract::get_os_typespec())
//                                   SdaiCc_design_contract;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCc_design_contract;
}
#endif

#ifdef __O3DB__
void
SdaiCc_design_contract::oodb_reInit ()
{	eDesc = config_control_designe_cc_design_contract;
	attributes [1].aDesc = a_355items;
}
#endif

SdaiCc_design_contract::SdaiCc_design_contract (SCLP23(Application_instance) *se, int *addAttrs) : SdaiContract_assignment(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiContract_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_contract;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_355items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_355items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiContracted_items_ptr
SdaiCc_design_contract::items_() const
{
    return (SdaiContracted_items_ptr) &_items;
}

void
SdaiCc_design_contract::items_ (const SdaiContracted_items_ptr x)

	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_contract


/////////	 ENTITY seam_curve

EntityDescriptor *config_control_designe_seam_curve =0;
SdaiSeam_curve::SdaiSeam_curve( )
{

	/*  parent: SdaiSurface_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_seam_curve;
    MakeDerived ("dim");
    MakeDerived ("basis_surface");
}
SdaiSeam_curve::SdaiSeam_curve (SdaiSeam_curve& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSeam_curve::~SdaiSeam_curve () {  }

#ifdef __OSTORE__

void
SdaiSeam_curve::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSeam_curve: virtual access function." << endl;
    SdaiSeam_curve_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSeam_curve_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSeam_curve: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSeam_curve *ent = (SdaiSeam_curve *)sent;
//    SdaiSeam_curve *ent = (SdaiSeam_curve *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_seam_curve;
}

SCLP23(Application_instance_ptr)
create_SdaiSeam_curve(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSeam_curve::get_os_typespec())
                                   SdaiSeam_curve;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSeam_curve::get_os_typespec())
//                                   SdaiSeam_curve;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSeam_curve;
}
#endif

#ifdef __O3DB__
void
SdaiSeam_curve::oodb_reInit ()
{	eDesc = config_control_designe_seam_curve;
}
#endif

SdaiSeam_curve::SdaiSeam_curve (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSurface_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSurface_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_seam_curve;
    MakeDerived ("dim");
    MakeDerived ("basis_surface");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY seam_curve


/////////	 ENTITY axis2_placement_3d

EntityDescriptor *config_control_designe_axis2_placement_3d =0;
AttrDescriptor *a_356axis =0;
AttrDescriptor *a_357ref_direction =0;
Derived_attribute *a_358Dp =0;
SdaiAxis2_placement_3d::SdaiAxis2_placement_3d( )
{

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis2_placement_3d;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_356axis, (SCLP23(Application_instance_ptr) *) &_axis);
#else
    STEPattribute *a = new STEPattribute(*a_356axis, (SCLP23(Application_instance_ptr) *) &_axis);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_357ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#else
    a = new STEPattribute(*a_357ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("p");
}
SdaiAxis2_placement_3d::SdaiAxis2_placement_3d (SdaiAxis2_placement_3d& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAxis2_placement_3d::~SdaiAxis2_placement_3d () {  }

#ifdef __OSTORE__

void
SdaiAxis2_placement_3d::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAxis2_placement_3d: virtual access function." << endl;
    SdaiAxis2_placement_3d_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAxis2_placement_3d_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAxis2_placement_3d: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAxis2_placement_3d *ent = (SdaiAxis2_placement_3d *)sent;
//    SdaiAxis2_placement_3d *ent = (SdaiAxis2_placement_3d *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_axis2_placement_3d;
    ent->attributes[2].aDesc = a_356axis;
    if(ent->_axis == 0)
        ent->_axis = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_357ref_direction;
    if(ent->_ref_direction == 0)
        ent->_ref_direction = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiAxis2_placement_3d(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAxis2_placement_3d::get_os_typespec())
                                   SdaiAxis2_placement_3d;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAxis2_placement_3d::get_os_typespec())
//                                   SdaiAxis2_placement_3d;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAxis2_placement_3d;
}
#endif

#ifdef __O3DB__
void
SdaiAxis2_placement_3d::oodb_reInit ()
{	eDesc = config_control_designe_axis2_placement_3d;
	attributes [2].aDesc = a_356axis;
	attributes [3].aDesc = a_357ref_direction;
}
#endif

SdaiAxis2_placement_3d::SdaiAxis2_placement_3d (SCLP23(Application_instance) *se, int *addAttrs) : SdaiPlacement(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis2_placement_3d;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_356axis, (SCLP23(Application_instance_ptr) *) &_axis);
#else
    STEPattribute *a = new STEPattribute(*a_356axis, (SCLP23(Application_instance_ptr) *) &_axis);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_357ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#else
    a = new STEPattribute(*a_357ref_direction, (SCLP23(Application_instance_ptr) *) &_ref_direction);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("p");
}

const SdaiDirection_ptr
SdaiAxis2_placement_3d::axis_() const
{
    return (SdaiDirection_ptr) _axis;
}

void
SdaiAxis2_placement_3d::axis_ (const SdaiDirection_ptr x)

{
    _axis = x;
}

const SdaiDirection_ptr
SdaiAxis2_placement_3d::ref_direction_() const
{
    return (SdaiDirection_ptr) _ref_direction;
}

void
SdaiAxis2_placement_3d::ref_direction_ (const SdaiDirection_ptr x)

{
    _ref_direction = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY axis2_placement_3d


/////////	 ENTITY rational_b_spline_surface

EntityDescriptor *config_control_designe_rational_b_spline_surface =0;
AttrDescriptor *a_359weights_data =0;
Derived_attribute *a_360Dweights =0;
SdaiRational_b_spline_surface::SdaiRational_b_spline_surface( )
{

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rational_b_spline_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_359weights_data,  &_weights_data);
#else
    STEPattribute *a = new STEPattribute(*a_359weights_data,  &_weights_data);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
    MakeDerived ("weights");
}
SdaiRational_b_spline_surface::SdaiRational_b_spline_surface (SdaiRational_b_spline_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiRational_b_spline_surface::~SdaiRational_b_spline_surface () {  }

#ifdef __OSTORE__

void
SdaiRational_b_spline_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRational_b_spline_surface: virtual access function." << endl;
    SdaiRational_b_spline_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiRational_b_spline_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiRational_b_spline_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiRational_b_spline_surface *ent = (SdaiRational_b_spline_surface *)sent;
//    SdaiRational_b_spline_surface *ent = (SdaiRational_b_spline_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_rational_b_spline_surface;
    ent->attributes[8].aDesc = a_359weights_data;
}

SCLP23(Application_instance_ptr)
create_SdaiRational_b_spline_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiRational_b_spline_surface::get_os_typespec())
                                   SdaiRational_b_spline_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiRational_b_spline_surface::get_os_typespec())
//                                   SdaiRational_b_spline_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiRational_b_spline_surface;
}
#endif

#ifdef __O3DB__
void
SdaiRational_b_spline_surface::oodb_reInit ()
{	eDesc = config_control_designe_rational_b_spline_surface;
	attributes [8].aDesc = a_359weights_data;
}
#endif

SdaiRational_b_spline_surface::SdaiRational_b_spline_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiB_spline_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rational_b_spline_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_359weights_data,  &_weights_data);
#else
    STEPattribute *a = new STEPattribute(*a_359weights_data,  &_weights_data);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
    MakeDerived ("weights");
}

const GenericAggregate_ptr
SdaiRational_b_spline_surface::weights_data_() const
{
    return (GenericAggregate_ptr) &_weights_data;
}

void
SdaiRational_b_spline_surface::weights_data_ (const GenericAggregate_ptr x)

	{ _weights_data.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY rational_b_spline_surface


/////////	 ENTITY configuration_design

EntityDescriptor *config_control_designe_configuration_design =0;
AttrDescriptor *a_361configuration =0;
AttrDescriptor *a_362design =0;
SdaiConfiguration_design::SdaiConfiguration_design( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_configuration_design;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_361configuration, (SCLP23(Application_instance_ptr) *) &_configuration);
#else
    STEPattribute *a = new STEPattribute(*a_361configuration, (SCLP23(Application_instance_ptr) *) &_configuration);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_362design, (SCLP23(Application_instance_ptr) *) &_design);
#else
    a = new STEPattribute(*a_362design, (SCLP23(Application_instance_ptr) *) &_design);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiConfiguration_design::SdaiConfiguration_design (SdaiConfiguration_design& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiConfiguration_design::~SdaiConfiguration_design () {  }

#ifdef __OSTORE__

void
SdaiConfiguration_design::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConfiguration_design: virtual access function." << endl;
    SdaiConfiguration_design_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiConfiguration_design_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConfiguration_design: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiConfiguration_design *ent = (SdaiConfiguration_design *)sent;
//    SdaiConfiguration_design *ent = (SdaiConfiguration_design *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_configuration_design;
    ent->attributes[0].aDesc = a_361configuration;
    if(ent->_configuration == 0)
        ent->_configuration = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_362design;
    if(ent->_design == 0)
        ent->_design = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiConfiguration_design(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiConfiguration_design::get_os_typespec())
                                   SdaiConfiguration_design;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiConfiguration_design::get_os_typespec())
//                                   SdaiConfiguration_design;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiConfiguration_design;
}
#endif

#ifdef __O3DB__
void
SdaiConfiguration_design::oodb_reInit ()
{	eDesc = config_control_designe_configuration_design;
	attributes [0].aDesc = a_361configuration;
	attributes [1].aDesc = a_362design;
}
#endif

SdaiConfiguration_design::SdaiConfiguration_design( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_configuration_design;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_361configuration, (SCLP23(Application_instance_ptr) *) &_configuration);
#else
    STEPattribute *a = new STEPattribute(*a_361configuration, (SCLP23(Application_instance_ptr) *) &_configuration);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_362design, (SCLP23(Application_instance_ptr) *) &_design);
#else
    a = new STEPattribute(*a_362design, (SCLP23(Application_instance_ptr) *) &_design);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiConfiguration_item_ptr
SdaiConfiguration_design::configuration_() const
{
    return (SdaiConfiguration_item_ptr) _configuration;
}

void
SdaiConfiguration_design::configuration_ (const SdaiConfiguration_item_ptr x)

{
    _configuration = x;
}

const SdaiProduct_definition_formation_ptr
SdaiConfiguration_design::design_() const
{
    return (SdaiProduct_definition_formation_ptr) _design;
}

void
SdaiConfiguration_design::design_ (const SdaiProduct_definition_formation_ptr x)

{
    _design = x;
}

/////////	 END_ENTITY configuration_design


/////////	 ENTITY design_context

EntityDescriptor *config_control_designe_design_context =0;
SdaiDesign_context::SdaiDesign_context( )
{

	/*  parent: SdaiProduct_definition_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_design_context;
}
SdaiDesign_context::SdaiDesign_context (SdaiDesign_context& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDesign_context::~SdaiDesign_context () {  }

#ifdef __OSTORE__

void
SdaiDesign_context::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDesign_context: virtual access function." << endl;
    SdaiDesign_context_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDesign_context_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDesign_context: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDesign_context *ent = (SdaiDesign_context *)sent;
//    SdaiDesign_context *ent = (SdaiDesign_context *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_design_context;
}

SCLP23(Application_instance_ptr)
create_SdaiDesign_context(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDesign_context::get_os_typespec())
                                   SdaiDesign_context;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDesign_context::get_os_typespec())
//                                   SdaiDesign_context;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDesign_context;
}
#endif

#ifdef __O3DB__
void
SdaiDesign_context::oodb_reInit ()
{	eDesc = config_control_designe_design_context;
}
#endif

SdaiDesign_context::SdaiDesign_context (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProduct_definition_context(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProduct_definition_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_design_context;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY design_context


/////////	 ENTITY product_definition

EntityDescriptor *config_control_designe_product_definition =0;
AttrDescriptor *a_363id =0;
AttrDescriptor *a_364description =0;
AttrDescriptor *a_365formation =0;
AttrDescriptor *a_366frame_of_reference =0;
SdaiProduct_definition::SdaiProduct_definition( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_363id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_363id,  &_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_364description,  &_description);
#else
    a = new STEPattribute(*a_364description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_365formation, (SCLP23(Application_instance_ptr) *) &_formation);
#else
    a = new STEPattribute(*a_365formation, (SCLP23(Application_instance_ptr) *) &_formation);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_366frame_of_reference, (SCLP23(Application_instance_ptr) *) &_frame_of_reference);
#else
    a = new STEPattribute(*a_366frame_of_reference, (SCLP23(Application_instance_ptr) *) &_frame_of_reference);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition::SdaiProduct_definition (SdaiProduct_definition& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_definition::~SdaiProduct_definition () {  }

#ifdef __OSTORE__

void
SdaiProduct_definition::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition: virtual access function." << endl;
    SdaiProduct_definition_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_definition_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_definition *ent = (SdaiProduct_definition *)sent;
//    SdaiProduct_definition *ent = (SdaiProduct_definition *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_definition;
    ent->attributes[0].aDesc = a_363id;
    ent->attributes[1].aDesc = a_364description;
    ent->attributes[2].aDesc = a_365formation;
    if(ent->_formation == 0)
        ent->_formation = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_366frame_of_reference;
    if(ent->_frame_of_reference == 0)
        ent->_frame_of_reference = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_definition(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_definition::get_os_typespec())
                                   SdaiProduct_definition;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_definition::get_os_typespec())
//                                   SdaiProduct_definition;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_definition;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_definition::oodb_reInit ()
{	eDesc = config_control_designe_product_definition;
	attributes [0].aDesc = a_363id;
	attributes [1].aDesc = a_364description;
	attributes [2].aDesc = a_365formation;
	attributes [3].aDesc = a_366frame_of_reference;
}
#endif

SdaiProduct_definition::SdaiProduct_definition( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_363id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_363id,  &_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_364description,  &_description);
#else
    a = new STEPattribute(*a_364description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_365formation, (SCLP23(Application_instance_ptr) *) &_formation);
#else
    a = new STEPattribute(*a_365formation, (SCLP23(Application_instance_ptr) *) &_formation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_366frame_of_reference, (SCLP23(Application_instance_ptr) *) &_frame_of_reference);
#else
    a = new STEPattribute(*a_366frame_of_reference, (SCLP23(Application_instance_ptr) *) &_frame_of_reference);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiProduct_definition::id_() const
{
    return (const SdaiIdentifier) _id;
}

void
SdaiProduct_definition::id_ (const SdaiIdentifier x)

{
    _id = x;
}

const SdaiText
SdaiProduct_definition::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiProduct_definition::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiProduct_definition_formation_ptr
SdaiProduct_definition::formation_() const
{
    return (SdaiProduct_definition_formation_ptr) _formation;
}

void
SdaiProduct_definition::formation_ (const SdaiProduct_definition_formation_ptr x)

{
    _formation = x;
}

const SdaiProduct_definition_context_ptr
SdaiProduct_definition::frame_of_reference_() const
{
    return (SdaiProduct_definition_context_ptr) _frame_of_reference;
}

void
SdaiProduct_definition::frame_of_reference_ (const SdaiProduct_definition_context_ptr x)

{
    _frame_of_reference = x;
}

/////////	 END_ENTITY product_definition


/////////	 ENTITY product_definition_with_associated_documents

EntityDescriptor *config_control_designe_product_definition_with_associated_documents =0;
AttrDescriptor *a_367documentation_ids =0;
SdaiProduct_definition_with_associated_documents::SdaiProduct_definition_with_associated_documents( )
{

	/*  parent: SdaiProduct_definition  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_with_associated_documents;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_367documentation_ids,  &_documentation_ids);
#else
    STEPattribute *a = new STEPattribute(*a_367documentation_ids,  &_documentation_ids);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_with_associated_documents::SdaiProduct_definition_with_associated_documents (SdaiProduct_definition_with_associated_documents& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_definition_with_associated_documents::~SdaiProduct_definition_with_associated_documents () {  }

#ifdef __OSTORE__

void
SdaiProduct_definition_with_associated_documents::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_with_associated_documents: virtual access function." << endl;
    SdaiProduct_definition_with_associated_documents_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_definition_with_associated_documents_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_definition_with_associated_documents: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_definition_with_associated_documents *ent = (SdaiProduct_definition_with_associated_documents *)sent;
//    SdaiProduct_definition_with_associated_documents *ent = (SdaiProduct_definition_with_associated_documents *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_definition_with_associated_documents;
    ent->attributes[4].aDesc = a_367documentation_ids;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_definition_with_associated_documents(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_definition_with_associated_documents::get_os_typespec())
                                   SdaiProduct_definition_with_associated_documents;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_definition_with_associated_documents::get_os_typespec())
//                                   SdaiProduct_definition_with_associated_documents;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_definition_with_associated_documents;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_definition_with_associated_documents::oodb_reInit ()
{	eDesc = config_control_designe_product_definition_with_associated_documents;
	attributes [4].aDesc = a_367documentation_ids;
}
#endif

SdaiProduct_definition_with_associated_documents::SdaiProduct_definition_with_associated_documents (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProduct_definition(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProduct_definition  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_with_associated_documents;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_367documentation_ids,  &_documentation_ids);
#else
    STEPattribute *a = new STEPattribute(*a_367documentation_ids,  &_documentation_ids);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const EntityAggregate_ptr
SdaiProduct_definition_with_associated_documents::documentation_ids_() const
{
    return (EntityAggregate_ptr) &_documentation_ids;
}

void
SdaiProduct_definition_with_associated_documents::documentation_ids_ (const EntityAggregate_ptr x)

	{ _documentation_ids.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_with_associated_documents


/////////	 ENTITY organization

EntityDescriptor *config_control_designe_organization =0;
AttrDescriptor *a_368id =0;
AttrDescriptor *a_369name =0;
AttrDescriptor *a_370description =0;
SdaiOrganization::SdaiOrganization( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_organization;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_368id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_368id,  &_id);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_369name,  &_name);
#else
    a = new STEPattribute(*a_369name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_370description,  &_description);
#else
    a = new STEPattribute(*a_370description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiOrganization::SdaiOrganization (SdaiOrganization& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOrganization::~SdaiOrganization () {  }

#ifdef __OSTORE__

void
SdaiOrganization::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOrganization: virtual access function." << endl;
    SdaiOrganization_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOrganization_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOrganization: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOrganization *ent = (SdaiOrganization *)sent;
//    SdaiOrganization *ent = (SdaiOrganization *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_organization;
    ent->attributes[0].aDesc = a_368id;
    ent->attributes[1].aDesc = a_369name;
    ent->attributes[2].aDesc = a_370description;
}

SCLP23(Application_instance_ptr)
create_SdaiOrganization(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOrganization::get_os_typespec())
                                   SdaiOrganization;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOrganization::get_os_typespec())
//                                   SdaiOrganization;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOrganization;
}
#endif

#ifdef __O3DB__
void
SdaiOrganization::oodb_reInit ()
{	eDesc = config_control_designe_organization;
	attributes [0].aDesc = a_368id;
	attributes [1].aDesc = a_369name;
	attributes [2].aDesc = a_370description;
}
#endif

SdaiOrganization::SdaiOrganization( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_organization;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_368id,  &_id);
#else
    STEPattribute *a = new STEPattribute(*a_368id,  &_id);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_369name,  &_name);
#else
    a = new STEPattribute(*a_369name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_370description,  &_description);
#else
    a = new STEPattribute(*a_370description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiIdentifier
SdaiOrganization::id_() const
{
    return (const SdaiIdentifier) _id;
}

void
SdaiOrganization::id_ (const SdaiIdentifier x)

{
    _id = x;
}

const SdaiLabel
SdaiOrganization::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiOrganization::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiOrganization::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiOrganization::description_ (const SdaiText x)

{
    _description = x;
}

/////////	 END_ENTITY organization


/////////	 ENTITY cc_design_certification

EntityDescriptor *config_control_designe_cc_design_certification =0;
AttrDescriptor *a_371items =0;
SdaiCc_design_certification::SdaiCc_design_certification( )
{

	/*  parent: SdaiCertification_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_certification;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_371items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_371items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_certification::SdaiCc_design_certification (SdaiCc_design_certification& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCc_design_certification::~SdaiCc_design_certification () {  }

#ifdef __OSTORE__

void
SdaiCc_design_certification::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_certification: virtual access function." << endl;
    SdaiCc_design_certification_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCc_design_certification_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_certification: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCc_design_certification *ent = (SdaiCc_design_certification *)sent;
//    SdaiCc_design_certification *ent = (SdaiCc_design_certification *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_cc_design_certification;
    ent->attributes[1].aDesc = a_371items;
}

SCLP23(Application_instance_ptr)
create_SdaiCc_design_certification(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCc_design_certification::get_os_typespec())
                                   SdaiCc_design_certification;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCc_design_certification::get_os_typespec())
//                                   SdaiCc_design_certification;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCc_design_certification;
}
#endif

#ifdef __O3DB__
void
SdaiCc_design_certification::oodb_reInit ()
{	eDesc = config_control_designe_cc_design_certification;
	attributes [1].aDesc = a_371items;
}
#endif

SdaiCc_design_certification::SdaiCc_design_certification (SCLP23(Application_instance) *se, int *addAttrs) : SdaiCertification_assignment(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiCertification_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_certification;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_371items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_371items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiCertified_items_ptr
SdaiCc_design_certification::items_() const
{
    return (SdaiCertified_items_ptr) &_items;
}

void
SdaiCc_design_certification::items_ (const SdaiCertified_items_ptr x)

	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_certification


/////////	 ENTITY b_spline_surface_with_knots

EntityDescriptor *config_control_designe_b_spline_surface_with_knots =0;
AttrDescriptor *a_372u_multiplicities =0;
AttrDescriptor *a_373v_multiplicities =0;
AttrDescriptor *a_374u_knots =0;
AttrDescriptor *a_375v_knots =0;
AttrDescriptor *a_376knot_spec =0;
Derived_attribute *a_377Dknot_u_upper =0;
Derived_attribute *a_378Dknot_v_upper =0;
SdaiB_spline_surface_with_knots::SdaiB_spline_surface_with_knots( )
{

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_surface_with_knots;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_372u_multiplicities,  &_u_multiplicities);
#else
    STEPattribute *a = new STEPattribute(*a_372u_multiplicities,  &_u_multiplicities);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_373v_multiplicities,  &_v_multiplicities);
#else
    a = new STEPattribute(*a_373v_multiplicities,  &_v_multiplicities);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_374u_knots,  &_u_knots);
#else
    a = new STEPattribute(*a_374u_knots,  &_u_knots);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_375v_knots,  &_v_knots);
#else
    a = new STEPattribute(*a_375v_knots,  &_v_knots);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_376knot_spec,  &_knot_spec);
#else
    a = new STEPattribute(*a_376knot_spec,  &_knot_spec);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
    MakeDerived ("knot_u_upper");
    MakeDerived ("knot_v_upper");
}
SdaiB_spline_surface_with_knots::SdaiB_spline_surface_with_knots (SdaiB_spline_surface_with_knots& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiB_spline_surface_with_knots::~SdaiB_spline_surface_with_knots () {  }

#ifdef __OSTORE__

void
SdaiB_spline_surface_with_knots::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiB_spline_surface_with_knots: virtual access function." << endl;
    SdaiB_spline_surface_with_knots_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiB_spline_surface_with_knots_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiB_spline_surface_with_knots: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiB_spline_surface_with_knots *ent = (SdaiB_spline_surface_with_knots *)sent;
//    SdaiB_spline_surface_with_knots *ent = (SdaiB_spline_surface_with_knots *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_b_spline_surface_with_knots;
    ent->attributes[8].aDesc = a_372u_multiplicities;
    ent->attributes[9].aDesc = a_373v_multiplicities;
    ent->attributes[10].aDesc = a_374u_knots;
    ent->attributes[11].aDesc = a_375v_knots;
    ent->attributes[12].aDesc = a_376knot_spec;
}

SCLP23(Application_instance_ptr)
create_SdaiB_spline_surface_with_knots(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiB_spline_surface_with_knots::get_os_typespec())
                                   SdaiB_spline_surface_with_knots;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiB_spline_surface_with_knots::get_os_typespec())
//                                   SdaiB_spline_surface_with_knots;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiB_spline_surface_with_knots;
}
#endif

#ifdef __O3DB__
void
SdaiB_spline_surface_with_knots::oodb_reInit ()
{	eDesc = config_control_designe_b_spline_surface_with_knots;
	attributes [8].aDesc = a_372u_multiplicities;
	attributes [9].aDesc = a_373v_multiplicities;
	attributes [10].aDesc = a_374u_knots;
	attributes [11].aDesc = a_375v_knots;
	attributes [12].aDesc = a_376knot_spec;
}
#endif

SdaiB_spline_surface_with_knots::SdaiB_spline_surface_with_knots (SCLP23(Application_instance) *se, int *addAttrs) : SdaiB_spline_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_surface_with_knots;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_372u_multiplicities,  &_u_multiplicities);
#else
    STEPattribute *a = new STEPattribute(*a_372u_multiplicities,  &_u_multiplicities);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_373v_multiplicities,  &_v_multiplicities);
#else
    a = new STEPattribute(*a_373v_multiplicities,  &_v_multiplicities);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_374u_knots,  &_u_knots);
#else
    a = new STEPattribute(*a_374u_knots,  &_u_knots);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_375v_knots,  &_v_knots);
#else
    a = new STEPattribute(*a_375v_knots,  &_v_knots);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_376knot_spec,  &_knot_spec);
#else
    a = new STEPattribute(*a_376knot_spec,  &_knot_spec);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
    MakeDerived ("u_upper");
    MakeDerived ("v_upper");
    MakeDerived ("control_points");
    MakeDerived ("knot_u_upper");
    MakeDerived ("knot_v_upper");
}

const IntAggregate_ptr
SdaiB_spline_surface_with_knots::u_multiplicities_() const
{
    return (IntAggregate_ptr) &_u_multiplicities;
}

void
SdaiB_spline_surface_with_knots::u_multiplicities_ (const IntAggregate_ptr x)

	{ _u_multiplicities.ShallowCopy (*x); }

const IntAggregate_ptr
SdaiB_spline_surface_with_knots::v_multiplicities_() const
{
    return (IntAggregate_ptr) &_v_multiplicities;
}

void
SdaiB_spline_surface_with_knots::v_multiplicities_ (const IntAggregate_ptr x)

	{ _v_multiplicities.ShallowCopy (*x); }

const RealAggregate_ptr
SdaiB_spline_surface_with_knots::u_knots_() const
{
    return (RealAggregate_ptr) &_u_knots;
}

void
SdaiB_spline_surface_with_knots::u_knots_ (const RealAggregate_ptr x)

	{ _u_knots.ShallowCopy (*x); }

const RealAggregate_ptr
SdaiB_spline_surface_with_knots::v_knots_() const
{
    return (RealAggregate_ptr) &_v_knots;
}

void
SdaiB_spline_surface_with_knots::v_knots_ (const RealAggregate_ptr x)

	{ _v_knots.ShallowCopy (*x); }

const SdaiKnot_type_var
SdaiB_spline_surface_with_knots::knot_spec_() const
{
    return (Knot_type) _knot_spec;
}

void
SdaiB_spline_surface_with_knots::knot_spec_ (const SdaiKnot_type_var x)

{
    _knot_spec.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY b_spline_surface_with_knots


/////////	 ENTITY certification_type

EntityDescriptor *config_control_designe_certification_type =0;
AttrDescriptor *a_379description =0;
SdaiCertification_type::SdaiCertification_type( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_certification_type;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_379description,  &_description);
#else
    STEPattribute *a = new STEPattribute(*a_379description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCertification_type::SdaiCertification_type (SdaiCertification_type& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCertification_type::~SdaiCertification_type () {  }

#ifdef __OSTORE__

void
SdaiCertification_type::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCertification_type: virtual access function." << endl;
    SdaiCertification_type_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCertification_type_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCertification_type: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCertification_type *ent = (SdaiCertification_type *)sent;
//    SdaiCertification_type *ent = (SdaiCertification_type *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_certification_type;
    ent->attributes[0].aDesc = a_379description;
}

SCLP23(Application_instance_ptr)
create_SdaiCertification_type(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCertification_type::get_os_typespec())
                                   SdaiCertification_type;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCertification_type::get_os_typespec())
//                                   SdaiCertification_type;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCertification_type;
}
#endif

#ifdef __O3DB__
void
SdaiCertification_type::oodb_reInit ()
{	eDesc = config_control_designe_certification_type;
	attributes [0].aDesc = a_379description;
}
#endif

SdaiCertification_type::SdaiCertification_type( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_certification_type;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_379description,  &_description);
#else
    STEPattribute *a = new STEPattribute(*a_379description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiCertification_type::description_() const
{
    return (const SdaiLabel) _description;
}

void
SdaiCertification_type::description_ (const SdaiLabel x)

{
    _description = x;
}

/////////	 END_ENTITY certification_type


/////////	 ENTITY oriented_path

EntityDescriptor *config_control_designe_oriented_path =0;
AttrDescriptor *a_380path_element =0;
AttrDescriptor *a_381orientation =0;
Derived_attribute *a_382Dpath_edge_list =0;
SdaiOriented_path::SdaiOriented_path( )
{

	/*  parent: SdaiPath  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_path;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_380path_element, (SCLP23(Application_instance_ptr) *) &_path_element);
#else
    STEPattribute *a = new STEPattribute(*a_380path_element, (SCLP23(Application_instance_ptr) *) &_path_element);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_381orientation,  &_orientation);
#else
    a = new STEPattribute(*a_381orientation,  &_orientation);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("edge_list");
}
SdaiOriented_path::SdaiOriented_path (SdaiOriented_path& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOriented_path::~SdaiOriented_path () {  }

#ifdef __OSTORE__

void
SdaiOriented_path::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOriented_path: virtual access function." << endl;
    SdaiOriented_path_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOriented_path_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOriented_path: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOriented_path *ent = (SdaiOriented_path *)sent;
//    SdaiOriented_path *ent = (SdaiOriented_path *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_oriented_path;
    ent->attributes[2].aDesc = a_380path_element;
    if(ent->_path_element == 0)
        ent->_path_element = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_381orientation;
}

SCLP23(Application_instance_ptr)
create_SdaiOriented_path(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOriented_path::get_os_typespec())
                                   SdaiOriented_path;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOriented_path::get_os_typespec())
//                                   SdaiOriented_path;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOriented_path;
}
#endif

#ifdef __O3DB__
void
SdaiOriented_path::oodb_reInit ()
{	eDesc = config_control_designe_oriented_path;
	attributes [2].aDesc = a_380path_element;
	attributes [3].aDesc = a_381orientation;
}
#endif

SdaiOriented_path::SdaiOriented_path (SCLP23(Application_instance) *se, int *addAttrs) : SdaiPath(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiPath  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_path;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_380path_element, (SCLP23(Application_instance_ptr) *) &_path_element);
#else
    STEPattribute *a = new STEPattribute(*a_380path_element, (SCLP23(Application_instance_ptr) *) &_path_element);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_381orientation,  &_orientation);
#else
    a = new STEPattribute(*a_381orientation,  &_orientation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("edge_list");
}

const SdaiPath_ptr
SdaiOriented_path::path_element_() const
{
    return (SdaiPath_ptr) _path_element;
}

void
SdaiOriented_path::path_element_ (const SdaiPath_ptr x)

{
    _path_element = x;
}

const SCLBOOL(Bool)
SdaiOriented_path::orientation_() const
{
    return (SCLBOOL(Bool)) _orientation;
}

void
SdaiOriented_path::orientation_ (const SCLBOOL(Bool) x)

{
    _orientation.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY oriented_path


/////////	 ENTITY security_classification

EntityDescriptor *config_control_designe_security_classification =0;
AttrDescriptor *a_383name =0;
AttrDescriptor *a_384purpose =0;
AttrDescriptor *a_385security_level =0;
SdaiSecurity_classification::SdaiSecurity_classification( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_383name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_383name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_384purpose,  &_purpose);
#else
    a = new STEPattribute(*a_384purpose,  &_purpose);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_385security_level, (SCLP23(Application_instance_ptr) *) &_security_level);
#else
    a = new STEPattribute(*a_385security_level, (SCLP23(Application_instance_ptr) *) &_security_level);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiSecurity_classification::SdaiSecurity_classification (SdaiSecurity_classification& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSecurity_classification::~SdaiSecurity_classification () {  }

#ifdef __OSTORE__

void
SdaiSecurity_classification::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSecurity_classification: virtual access function." << endl;
    SdaiSecurity_classification_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSecurity_classification_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSecurity_classification: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSecurity_classification *ent = (SdaiSecurity_classification *)sent;
//    SdaiSecurity_classification *ent = (SdaiSecurity_classification *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_security_classification;
    ent->attributes[0].aDesc = a_383name;
    ent->attributes[1].aDesc = a_384purpose;
    ent->attributes[2].aDesc = a_385security_level;
    if(ent->_security_level == 0)
        ent->_security_level = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiSecurity_classification(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSecurity_classification::get_os_typespec())
                                   SdaiSecurity_classification;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSecurity_classification::get_os_typespec())
//                                   SdaiSecurity_classification;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSecurity_classification;
}
#endif

#ifdef __O3DB__
void
SdaiSecurity_classification::oodb_reInit ()
{	eDesc = config_control_designe_security_classification;
	attributes [0].aDesc = a_383name;
	attributes [1].aDesc = a_384purpose;
	attributes [2].aDesc = a_385security_level;
}
#endif

SdaiSecurity_classification::SdaiSecurity_classification( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_383name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_383name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_384purpose,  &_purpose);
#else
    a = new STEPattribute(*a_384purpose,  &_purpose);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_385security_level, (SCLP23(Application_instance_ptr) *) &_security_level);
#else
    a = new STEPattribute(*a_385security_level, (SCLP23(Application_instance_ptr) *) &_security_level);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiSecurity_classification::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiSecurity_classification::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiSecurity_classification::purpose_() const
{
    return (const SdaiText) _purpose;
}

void
SdaiSecurity_classification::purpose_ (const SdaiText x)

{
    _purpose = x;
}

const SdaiSecurity_classification_level_ptr
SdaiSecurity_classification::security_level_() const
{
    return (SdaiSecurity_classification_level_ptr) _security_level;
}

void
SdaiSecurity_classification::security_level_ (const SdaiSecurity_classification_level_ptr x)

{
    _security_level = x;
}

/////////	 END_ENTITY security_classification


/////////	 ENTITY vertex_loop

EntityDescriptor *config_control_designe_vertex_loop =0;
AttrDescriptor *a_386loop_vertex =0;
SdaiVertex_loop::SdaiVertex_loop( )
{

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex_loop;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_386loop_vertex, (SCLP23(Application_instance_ptr) *) &_loop_vertex);
#else
    STEPattribute *a = new STEPattribute(*a_386loop_vertex, (SCLP23(Application_instance_ptr) *) &_loop_vertex);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiVertex_loop::SdaiVertex_loop (SdaiVertex_loop& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiVertex_loop::~SdaiVertex_loop () {  }

#ifdef __OSTORE__

void
SdaiVertex_loop::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVertex_loop: virtual access function." << endl;
    SdaiVertex_loop_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiVertex_loop_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVertex_loop: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiVertex_loop *ent = (SdaiVertex_loop *)sent;
//    SdaiVertex_loop *ent = (SdaiVertex_loop *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_vertex_loop;
    ent->attributes[1].aDesc = a_386loop_vertex;
    if(ent->_loop_vertex == 0)
        ent->_loop_vertex = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiVertex_loop(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiVertex_loop::get_os_typespec())
                                   SdaiVertex_loop;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiVertex_loop::get_os_typespec())
//                                   SdaiVertex_loop;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiVertex_loop;
}
#endif

#ifdef __O3DB__
void
SdaiVertex_loop::oodb_reInit ()
{	eDesc = config_control_designe_vertex_loop;
	attributes [1].aDesc = a_386loop_vertex;
}
#endif

SdaiVertex_loop::SdaiVertex_loop (SCLP23(Application_instance) *se, int *addAttrs) : SdaiLoop(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex_loop;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_386loop_vertex, (SCLP23(Application_instance_ptr) *) &_loop_vertex);
#else
    STEPattribute *a = new STEPattribute(*a_386loop_vertex, (SCLP23(Application_instance_ptr) *) &_loop_vertex);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiVertex_ptr
SdaiVertex_loop::loop_vertex_() const
{
    return (SdaiVertex_ptr) _loop_vertex;
}

void
SdaiVertex_loop::loop_vertex_ (const SdaiVertex_ptr x)

{
    _loop_vertex = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY vertex_loop


/////////	 ENTITY approval_status

EntityDescriptor *config_control_designe_approval_status =0;
AttrDescriptor *a_387name =0;
SdaiApproval_status::SdaiApproval_status( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_status;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_387name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_387name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_status::SdaiApproval_status (SdaiApproval_status& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiApproval_status::~SdaiApproval_status () {  }

#ifdef __OSTORE__

void
SdaiApproval_status::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_status: virtual access function." << endl;
    SdaiApproval_status_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiApproval_status_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_status: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiApproval_status *ent = (SdaiApproval_status *)sent;
//    SdaiApproval_status *ent = (SdaiApproval_status *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_approval_status;
    ent->attributes[0].aDesc = a_387name;
}

SCLP23(Application_instance_ptr)
create_SdaiApproval_status(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiApproval_status::get_os_typespec())
                                   SdaiApproval_status;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiApproval_status::get_os_typespec())
//                                   SdaiApproval_status;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiApproval_status;
}
#endif

#ifdef __O3DB__
void
SdaiApproval_status::oodb_reInit ()
{	eDesc = config_control_designe_approval_status;
	attributes [0].aDesc = a_387name;
}
#endif

SdaiApproval_status::SdaiApproval_status( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_status;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_387name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_387name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiApproval_status::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiApproval_status::name_ (const SdaiLabel x)

{
    _name = x;
}

/////////	 END_ENTITY approval_status


/////////	 ENTITY cartesian_point

EntityDescriptor *config_control_designe_cartesian_point =0;
AttrDescriptor *a_388coordinates =0;
SdaiCartesian_point::SdaiCartesian_point( )
{

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cartesian_point;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_388coordinates,  &_coordinates);
#else
    STEPattribute *a = new STEPattribute(*a_388coordinates,  &_coordinates);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiCartesian_point::SdaiCartesian_point (SdaiCartesian_point& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCartesian_point::~SdaiCartesian_point () {  }

#ifdef __OSTORE__

void
SdaiCartesian_point::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCartesian_point: virtual access function." << endl;
    SdaiCartesian_point_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCartesian_point_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCartesian_point: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCartesian_point *ent = (SdaiCartesian_point *)sent;
//    SdaiCartesian_point *ent = (SdaiCartesian_point *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_cartesian_point;
    ent->attributes[1].aDesc = a_388coordinates;
}

SCLP23(Application_instance_ptr)
create_SdaiCartesian_point(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCartesian_point::get_os_typespec())
                                   SdaiCartesian_point;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCartesian_point::get_os_typespec())
//                                   SdaiCartesian_point;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCartesian_point;
}
#endif

#ifdef __O3DB__
void
SdaiCartesian_point::oodb_reInit ()
{	eDesc = config_control_designe_cartesian_point;
	attributes [1].aDesc = a_388coordinates;
}
#endif

SdaiCartesian_point::SdaiCartesian_point (SCLP23(Application_instance) *se, int *addAttrs) : SdaiPoint(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cartesian_point;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_388coordinates,  &_coordinates);
#else
    STEPattribute *a = new STEPattribute(*a_388coordinates,  &_coordinates);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const RealAggregate_ptr
SdaiCartesian_point::coordinates_() const
{
    return (RealAggregate_ptr) &_coordinates;
}

void
SdaiCartesian_point::coordinates_ (const RealAggregate_ptr x)

	{ _coordinates.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cartesian_point


/////////	 ENTITY date_and_time_assignment

EntityDescriptor *config_control_designe_date_and_time_assignment =0;
AttrDescriptor *a_389assigned_date_and_time =0;
AttrDescriptor *a_390role =0;
SdaiDate_and_time_assignment::SdaiDate_and_time_assignment( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_date_and_time_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_389assigned_date_and_time, (SCLP23(Application_instance_ptr) *) &_assigned_date_and_time);
#else
    STEPattribute *a = new STEPattribute(*a_389assigned_date_and_time, (SCLP23(Application_instance_ptr) *) &_assigned_date_and_time);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_390role, (SCLP23(Application_instance_ptr) *) &_role);
#else
    a = new STEPattribute(*a_390role, (SCLP23(Application_instance_ptr) *) &_role);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDate_and_time_assignment::SdaiDate_and_time_assignment (SdaiDate_and_time_assignment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDate_and_time_assignment::~SdaiDate_and_time_assignment () {  }

#ifdef __OSTORE__

void
SdaiDate_and_time_assignment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDate_and_time_assignment: virtual access function." << endl;
    SdaiDate_and_time_assignment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDate_and_time_assignment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDate_and_time_assignment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDate_and_time_assignment *ent = (SdaiDate_and_time_assignment *)sent;
//    SdaiDate_and_time_assignment *ent = (SdaiDate_and_time_assignment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_date_and_time_assignment;
    ent->attributes[0].aDesc = a_389assigned_date_and_time;
    if(ent->_assigned_date_and_time == 0)
        ent->_assigned_date_and_time = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_390role;
    if(ent->_role == 0)
        ent->_role = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiDate_and_time_assignment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDate_and_time_assignment::get_os_typespec())
                                   SdaiDate_and_time_assignment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDate_and_time_assignment::get_os_typespec())
//                                   SdaiDate_and_time_assignment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDate_and_time_assignment;
}
#endif

#ifdef __O3DB__
void
SdaiDate_and_time_assignment::oodb_reInit ()
{	eDesc = config_control_designe_date_and_time_assignment;
	attributes [0].aDesc = a_389assigned_date_and_time;
	attributes [1].aDesc = a_390role;
}
#endif

SdaiDate_and_time_assignment::SdaiDate_and_time_assignment( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_date_and_time_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_389assigned_date_and_time, (SCLP23(Application_instance_ptr) *) &_assigned_date_and_time);
#else
    STEPattribute *a = new STEPattribute(*a_389assigned_date_and_time, (SCLP23(Application_instance_ptr) *) &_assigned_date_and_time);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_390role, (SCLP23(Application_instance_ptr) *) &_role);
#else
    a = new STEPattribute(*a_390role, (SCLP23(Application_instance_ptr) *) &_role);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiDate_and_time_ptr
SdaiDate_and_time_assignment::assigned_date_and_time_() const
{
    return (SdaiDate_and_time_ptr) _assigned_date_and_time;
}

void
SdaiDate_and_time_assignment::assigned_date_and_time_ (const SdaiDate_and_time_ptr x)

{
    _assigned_date_and_time = x;
}

const SdaiDate_time_role_ptr
SdaiDate_and_time_assignment::role_() const
{
    return (SdaiDate_time_role_ptr) _role;
}

void
SdaiDate_and_time_assignment::role_ (const SdaiDate_time_role_ptr x)

{
    _role = x;
}

/////////	 END_ENTITY date_and_time_assignment


/////////	 ENTITY parametric_representation_context

EntityDescriptor *config_control_designe_parametric_representation_context =0;
SdaiParametric_representation_context::SdaiParametric_representation_context( )
{

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_parametric_representation_context;
}
SdaiParametric_representation_context::SdaiParametric_representation_context (SdaiParametric_representation_context& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiParametric_representation_context::~SdaiParametric_representation_context () {  }

#ifdef __OSTORE__

void
SdaiParametric_representation_context::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiParametric_representation_context: virtual access function." << endl;
    SdaiParametric_representation_context_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiParametric_representation_context_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiParametric_representation_context: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiParametric_representation_context *ent = (SdaiParametric_representation_context *)sent;
//    SdaiParametric_representation_context *ent = (SdaiParametric_representation_context *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_parametric_representation_context;
}

SCLP23(Application_instance_ptr)
create_SdaiParametric_representation_context(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiParametric_representation_context::get_os_typespec())
                                   SdaiParametric_representation_context;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiParametric_representation_context::get_os_typespec())
//                                   SdaiParametric_representation_context;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiParametric_representation_context;
}
#endif

#ifdef __O3DB__
void
SdaiParametric_representation_context::oodb_reInit ()
{	eDesc = config_control_designe_parametric_representation_context;
}
#endif

SdaiParametric_representation_context::SdaiParametric_representation_context (SCLP23(Application_instance) *se, int *addAttrs) : SdaiRepresentation_context(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_parametric_representation_context;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY parametric_representation_context


/////////	 ENTITY product_concept_context

EntityDescriptor *config_control_designe_product_concept_context =0;
AttrDescriptor *a_391market_segment_type =0;
SdaiProduct_concept_context::SdaiProduct_concept_context( )
{

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_concept_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_391market_segment_type,  &_market_segment_type);
#else
    STEPattribute *a = new STEPattribute(*a_391market_segment_type,  &_market_segment_type);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_concept_context::SdaiProduct_concept_context (SdaiProduct_concept_context& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiProduct_concept_context::~SdaiProduct_concept_context () {  }

#ifdef __OSTORE__

void
SdaiProduct_concept_context::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_concept_context: virtual access function." << endl;
    SdaiProduct_concept_context_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiProduct_concept_context_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiProduct_concept_context: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiProduct_concept_context *ent = (SdaiProduct_concept_context *)sent;
//    SdaiProduct_concept_context *ent = (SdaiProduct_concept_context *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_product_concept_context;
    ent->attributes[2].aDesc = a_391market_segment_type;
}

SCLP23(Application_instance_ptr)
create_SdaiProduct_concept_context(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiProduct_concept_context::get_os_typespec())
                                   SdaiProduct_concept_context;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiProduct_concept_context::get_os_typespec())
//                                   SdaiProduct_concept_context;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiProduct_concept_context;
}
#endif

#ifdef __O3DB__
void
SdaiProduct_concept_context::oodb_reInit ()
{	eDesc = config_control_designe_product_concept_context;
	attributes [2].aDesc = a_391market_segment_type;
}
#endif

SdaiProduct_concept_context::SdaiProduct_concept_context (SCLP23(Application_instance) *se, int *addAttrs) : SdaiApplication_context_element(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_concept_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_391market_segment_type,  &_market_segment_type);
#else
    STEPattribute *a = new STEPattribute(*a_391market_segment_type,  &_market_segment_type);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiProduct_concept_context::market_segment_type_() const
{
    return (const SdaiLabel) _market_segment_type;
}

void
SdaiProduct_concept_context::market_segment_type_ (const SdaiLabel x)

{
    _market_segment_type = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_concept_context


/////////	 ENTITY surface_patch

EntityDescriptor *config_control_designe_surface_patch =0;
AttrDescriptor *a_392parent_surface =0;
AttrDescriptor *a_393u_transition =0;
AttrDescriptor *a_394v_transition =0;
AttrDescriptor *a_395u_sense =0;
AttrDescriptor *a_396v_sense =0;
Inverse_attribute *a_397Iusing_surfaces =0;
SdaiSurface_patch::SdaiSurface_patch( )
{

	/*  parent: SdaiFounded_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_patch;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_392parent_surface, (SCLP23(Application_instance_ptr) *) &_parent_surface);
#else
    STEPattribute *a = new STEPattribute(*a_392parent_surface, (SCLP23(Application_instance_ptr) *) &_parent_surface);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_393u_transition,  &_u_transition);
#else
    a = new STEPattribute(*a_393u_transition,  &_u_transition);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_394v_transition,  &_v_transition);
#else
    a = new STEPattribute(*a_394v_transition,  &_v_transition);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_395u_sense,  &_u_sense);
#else
    a = new STEPattribute(*a_395u_sense,  &_u_sense);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_396v_sense,  &_v_sense);
#else
    a = new STEPattribute(*a_396v_sense,  &_v_sense);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiSurface_patch::SdaiSurface_patch (SdaiSurface_patch& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSurface_patch::~SdaiSurface_patch () {  }

#ifdef __OSTORE__

void
SdaiSurface_patch::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface_patch: virtual access function." << endl;
    SdaiSurface_patch_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSurface_patch_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface_patch: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSurface_patch *ent = (SdaiSurface_patch *)sent;
//    SdaiSurface_patch *ent = (SdaiSurface_patch *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_surface_patch;
    ent->attributes[0].aDesc = a_392parent_surface;
    if(ent->_parent_surface == 0)
        ent->_parent_surface = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_393u_transition;
    ent->attributes[2].aDesc = a_394v_transition;
    ent->attributes[3].aDesc = a_395u_sense;
    ent->attributes[4].aDesc = a_396v_sense;
}

SCLP23(Application_instance_ptr)
create_SdaiSurface_patch(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSurface_patch::get_os_typespec())
                                   SdaiSurface_patch;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSurface_patch::get_os_typespec())
//                                   SdaiSurface_patch;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSurface_patch;
}
#endif

#ifdef __O3DB__
void
SdaiSurface_patch::oodb_reInit ()
{	eDesc = config_control_designe_surface_patch;
	attributes [0].aDesc = a_392parent_surface;
	attributes [1].aDesc = a_393u_transition;
	attributes [2].aDesc = a_394v_transition;
	attributes [3].aDesc = a_395u_sense;
	attributes [4].aDesc = a_396v_sense;
}
#endif

SdaiSurface_patch::SdaiSurface_patch (SCLP23(Application_instance) *se, int *addAttrs) : SdaiFounded_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiFounded_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_patch;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_392parent_surface, (SCLP23(Application_instance_ptr) *) &_parent_surface);
#else
    STEPattribute *a = new STEPattribute(*a_392parent_surface, (SCLP23(Application_instance_ptr) *) &_parent_surface);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_393u_transition,  &_u_transition);
#else
    a = new STEPattribute(*a_393u_transition,  &_u_transition);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_394v_transition,  &_v_transition);
#else
    a = new STEPattribute(*a_394v_transition,  &_v_transition);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_395u_sense,  &_u_sense);
#else
    a = new STEPattribute(*a_395u_sense,  &_u_sense);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_396v_sense,  &_v_sense);
#else
    a = new STEPattribute(*a_396v_sense,  &_v_sense);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiBounded_surface_ptr
SdaiSurface_patch::parent_surface_() const
{
    return (SdaiBounded_surface_ptr) _parent_surface;
}

void
SdaiSurface_patch::parent_surface_ (const SdaiBounded_surface_ptr x)

{
    _parent_surface = x;
}

const SdaiTransition_code_var
SdaiSurface_patch::u_transition_() const
{
    return (Transition_code) _u_transition;
}

void
SdaiSurface_patch::u_transition_ (const SdaiTransition_code_var x)

{
    _u_transition.put (x);
}

const SdaiTransition_code_var
SdaiSurface_patch::v_transition_() const
{
    return (Transition_code) _v_transition;
}

void
SdaiSurface_patch::v_transition_ (const SdaiTransition_code_var x)

{
    _v_transition.put (x);
}

const SCLBOOL(Bool)
SdaiSurface_patch::u_sense_() const
{
    return (SCLBOOL(Bool)) _u_sense;
}

void
SdaiSurface_patch::u_sense_ (const SCLBOOL(Bool) x)

{
    _u_sense.put (x);
}

const SCLBOOL(Bool)
SdaiSurface_patch::v_sense_() const
{
    return (SCLBOOL(Bool)) _v_sense;
}

void
SdaiSurface_patch::v_sense_ (const SCLBOOL(Bool) x)

{
    _v_sense.put (x);
}

const EntityAggregate_ptr
SdaiSurface_patch::using_surfaces_() const
{
    return (EntityAggregate_ptr) &_using_surfaces;
}

void
SdaiSurface_patch::using_surfaces_ (const EntityAggregate_ptr x)

	{ _using_surfaces.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY surface_patch


/////////	 ENTITY length_unit

EntityDescriptor *config_control_designe_length_unit =0;
SdaiLength_unit::SdaiLength_unit( )
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_length_unit;
}
SdaiLength_unit::SdaiLength_unit (SdaiLength_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiLength_unit::~SdaiLength_unit () {  }

#ifdef __OSTORE__

void
SdaiLength_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLength_unit: virtual access function." << endl;
    SdaiLength_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiLength_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLength_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiLength_unit *ent = (SdaiLength_unit *)sent;
//    SdaiLength_unit *ent = (SdaiLength_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_length_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiLength_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiLength_unit::get_os_typespec())
                                   SdaiLength_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiLength_unit::get_os_typespec())
//                                   SdaiLength_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiLength_unit;
}
#endif

#ifdef __O3DB__
void
SdaiLength_unit::oodb_reInit ()
{	eDesc = config_control_designe_length_unit;
}
#endif

SdaiLength_unit::SdaiLength_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiNamed_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_length_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY length_unit


/////////	 ENTITY shape_aspect

EntityDescriptor *config_control_designe_shape_aspect =0;
AttrDescriptor *a_398name =0;
AttrDescriptor *a_399description =0;
AttrDescriptor *a_400of_shape =0;
AttrDescriptor *a_401product_definitional =0;
SdaiShape_aspect::SdaiShape_aspect( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_shape_aspect;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_398name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_398name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_399description,  &_description);
#else
    a = new STEPattribute(*a_399description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_400of_shape, (SCLP23(Application_instance_ptr) *) &_of_shape);
#else
    a = new STEPattribute(*a_400of_shape, (SCLP23(Application_instance_ptr) *) &_of_shape);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_401product_definitional,  &_product_definitional);
#else
    a = new STEPattribute(*a_401product_definitional,  &_product_definitional);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiShape_aspect::SdaiShape_aspect (SdaiShape_aspect& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiShape_aspect::~SdaiShape_aspect () {  }

#ifdef __OSTORE__

void
SdaiShape_aspect::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShape_aspect: virtual access function." << endl;
    SdaiShape_aspect_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiShape_aspect_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShape_aspect: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiShape_aspect *ent = (SdaiShape_aspect *)sent;
//    SdaiShape_aspect *ent = (SdaiShape_aspect *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_shape_aspect;
    ent->attributes[0].aDesc = a_398name;
    ent->attributes[1].aDesc = a_399description;
    ent->attributes[2].aDesc = a_400of_shape;
    if(ent->_of_shape == 0)
        ent->_of_shape = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_401product_definitional;
}

SCLP23(Application_instance_ptr)
create_SdaiShape_aspect(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiShape_aspect::get_os_typespec())
                                   SdaiShape_aspect;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiShape_aspect::get_os_typespec())
//                                   SdaiShape_aspect;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiShape_aspect;
}
#endif

#ifdef __O3DB__
void
SdaiShape_aspect::oodb_reInit ()
{	eDesc = config_control_designe_shape_aspect;
	attributes [0].aDesc = a_398name;
	attributes [1].aDesc = a_399description;
	attributes [2].aDesc = a_400of_shape;
	attributes [3].aDesc = a_401product_definitional;
}
#endif

SdaiShape_aspect::SdaiShape_aspect( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_shape_aspect;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_398name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_398name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_399description,  &_description);
#else
    a = new STEPattribute(*a_399description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_400of_shape, (SCLP23(Application_instance_ptr) *) &_of_shape);
#else
    a = new STEPattribute(*a_400of_shape, (SCLP23(Application_instance_ptr) *) &_of_shape);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_401product_definitional,  &_product_definitional);
#else
    a = new STEPattribute(*a_401product_definitional,  &_product_definitional);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiShape_aspect::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiShape_aspect::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiShape_aspect::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiShape_aspect::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiProduct_definition_shape_ptr
SdaiShape_aspect::of_shape_() const
{
    return (SdaiProduct_definition_shape_ptr) _of_shape;
}

void
SdaiShape_aspect::of_shape_ (const SdaiProduct_definition_shape_ptr x)

{
    _of_shape = x;
}

const SCLLOG(Logical)
SdaiShape_aspect::product_definitional_() const
{
    return (SCLLOG(Logical)) _product_definitional;
}

void
SdaiShape_aspect::product_definitional_ (const SCLLOG(Logical) x)

{
    _product_definitional.put (x);
}

/////////	 END_ENTITY shape_aspect


/////////	 ENTITY volume_measure_with_unit

EntityDescriptor *config_control_designe_volume_measure_with_unit =0;
SdaiVolume_measure_with_unit::SdaiVolume_measure_with_unit( )
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_volume_measure_with_unit;
}
SdaiVolume_measure_with_unit::SdaiVolume_measure_with_unit (SdaiVolume_measure_with_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiVolume_measure_with_unit::~SdaiVolume_measure_with_unit () {  }

#ifdef __OSTORE__

void
SdaiVolume_measure_with_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVolume_measure_with_unit: virtual access function." << endl;
    SdaiVolume_measure_with_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiVolume_measure_with_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVolume_measure_with_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiVolume_measure_with_unit *ent = (SdaiVolume_measure_with_unit *)sent;
//    SdaiVolume_measure_with_unit *ent = (SdaiVolume_measure_with_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_volume_measure_with_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiVolume_measure_with_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiVolume_measure_with_unit::get_os_typespec())
                                   SdaiVolume_measure_with_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiVolume_measure_with_unit::get_os_typespec())
//                                   SdaiVolume_measure_with_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiVolume_measure_with_unit;
}
#endif

#ifdef __O3DB__
void
SdaiVolume_measure_with_unit::oodb_reInit ()
{	eDesc = config_control_designe_volume_measure_with_unit;
}
#endif

SdaiVolume_measure_with_unit::SdaiVolume_measure_with_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiMeasure_with_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_volume_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY volume_measure_with_unit


/////////	 ENTITY advanced_face

EntityDescriptor *config_control_designe_advanced_face =0;
SdaiAdvanced_face::SdaiAdvanced_face( )
{

	/*  parent: SdaiFace_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_advanced_face;
    MakeDerived ("dim");
    //cout << "***** Advanced Face *****" << endl;
    //PrintSTEPattributes();
}
SdaiAdvanced_face::SdaiAdvanced_face (SdaiAdvanced_face& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiAdvanced_face::~SdaiAdvanced_face () {  }

#ifdef __OSTORE__

void
SdaiAdvanced_face::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAdvanced_face: virtual access function." << endl;
    SdaiAdvanced_face_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiAdvanced_face_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiAdvanced_face: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiAdvanced_face *ent = (SdaiAdvanced_face *)sent;
//    SdaiAdvanced_face *ent = (SdaiAdvanced_face *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_advanced_face;
}

SCLP23(Application_instance_ptr)
create_SdaiAdvanced_face(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiAdvanced_face::get_os_typespec())
                                   SdaiAdvanced_face;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiAdvanced_face::get_os_typespec())
//                                   SdaiAdvanced_face;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiAdvanced_face;
}
#endif

#ifdef __O3DB__
void
SdaiAdvanced_face::oodb_reInit ()
{	eDesc = config_control_designe_advanced_face;
}
#endif

SdaiAdvanced_face::SdaiAdvanced_face (SCLP23(Application_instance) *se, int *addAttrs) : SdaiFace_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiFace_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_advanced_face;
    MakeDerived ("dim");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY advanced_face


/////////	 ENTITY security_classification_level

EntityDescriptor *config_control_designe_security_classification_level =0;
AttrDescriptor *a_402name =0;
SdaiSecurity_classification_level::SdaiSecurity_classification_level( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification_level;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_402name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_402name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiSecurity_classification_level::SdaiSecurity_classification_level (SdaiSecurity_classification_level& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSecurity_classification_level::~SdaiSecurity_classification_level () {  }

#ifdef __OSTORE__

void
SdaiSecurity_classification_level::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSecurity_classification_level: virtual access function." << endl;
    SdaiSecurity_classification_level_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSecurity_classification_level_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSecurity_classification_level: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSecurity_classification_level *ent = (SdaiSecurity_classification_level *)sent;
//    SdaiSecurity_classification_level *ent = (SdaiSecurity_classification_level *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_security_classification_level;
    ent->attributes[0].aDesc = a_402name;
}

SCLP23(Application_instance_ptr)
create_SdaiSecurity_classification_level(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSecurity_classification_level::get_os_typespec())
                                   SdaiSecurity_classification_level;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSecurity_classification_level::get_os_typespec())
//                                   SdaiSecurity_classification_level;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSecurity_classification_level;
}
#endif

#ifdef __O3DB__
void
SdaiSecurity_classification_level::oodb_reInit ()
{	eDesc = config_control_designe_security_classification_level;
	attributes [0].aDesc = a_402name;
}
#endif

SdaiSecurity_classification_level::SdaiSecurity_classification_level( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification_level;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_402name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_402name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiSecurity_classification_level::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiSecurity_classification_level::name_ (const SdaiLabel x)

{
    _name = x;
}

/////////	 END_ENTITY security_classification_level


/////////	 ENTITY approval_relationship

EntityDescriptor *config_control_designe_approval_relationship =0;
AttrDescriptor *a_403name =0;
AttrDescriptor *a_404description =0;
AttrDescriptor *a_405relating_approval =0;
AttrDescriptor *a_406related_approval =0;
SdaiApproval_relationship::SdaiApproval_relationship( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_403name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_403name,  &_name);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_404description,  &_description);
#else
    a = new STEPattribute(*a_404description,  &_description);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_405relating_approval, (SCLP23(Application_instance_ptr) *) &_relating_approval);
#else
    a = new STEPattribute(*a_405relating_approval, (SCLP23(Application_instance_ptr) *) &_relating_approval);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_406related_approval, (SCLP23(Application_instance_ptr) *) &_related_approval);
#else
    a = new STEPattribute(*a_406related_approval, (SCLP23(Application_instance_ptr) *) &_related_approval);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_relationship::SdaiApproval_relationship (SdaiApproval_relationship& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiApproval_relationship::~SdaiApproval_relationship () {  }

#ifdef __OSTORE__

void
SdaiApproval_relationship::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_relationship: virtual access function." << endl;
    SdaiApproval_relationship_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiApproval_relationship_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_relationship: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiApproval_relationship *ent = (SdaiApproval_relationship *)sent;
//    SdaiApproval_relationship *ent = (SdaiApproval_relationship *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_approval_relationship;
    ent->attributes[0].aDesc = a_403name;
    ent->attributes[1].aDesc = a_404description;
    ent->attributes[2].aDesc = a_405relating_approval;
    if(ent->_relating_approval == 0)
        ent->_relating_approval = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_406related_approval;
    if(ent->_related_approval == 0)
        ent->_related_approval = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiApproval_relationship(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiApproval_relationship::get_os_typespec())
                                   SdaiApproval_relationship;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiApproval_relationship::get_os_typespec())
//                                   SdaiApproval_relationship;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiApproval_relationship;
}
#endif

#ifdef __O3DB__
void
SdaiApproval_relationship::oodb_reInit ()
{	eDesc = config_control_designe_approval_relationship;
	attributes [0].aDesc = a_403name;
	attributes [1].aDesc = a_404description;
	attributes [2].aDesc = a_405relating_approval;
	attributes [3].aDesc = a_406related_approval;
}
#endif

SdaiApproval_relationship::SdaiApproval_relationship( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_relationship;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_403name,  &_name);
#else
    STEPattribute *a = new STEPattribute(*a_403name,  &_name);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_404description,  &_description);
#else
    a = new STEPattribute(*a_404description,  &_description);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_405relating_approval, (SCLP23(Application_instance_ptr) *) &_relating_approval);
#else
    a = new STEPattribute(*a_405relating_approval, (SCLP23(Application_instance_ptr) *) &_relating_approval);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_406related_approval, (SCLP23(Application_instance_ptr) *) &_related_approval);
#else
    a = new STEPattribute(*a_406related_approval, (SCLP23(Application_instance_ptr) *) &_related_approval);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiLabel
SdaiApproval_relationship::name_() const
{
    return (const SdaiLabel) _name;
}

void
SdaiApproval_relationship::name_ (const SdaiLabel x)

{
    _name = x;
}

const SdaiText
SdaiApproval_relationship::description_() const
{
    return (const SdaiText) _description;
}

void
SdaiApproval_relationship::description_ (const SdaiText x)

{
    _description = x;
}

const SdaiApproval_ptr
SdaiApproval_relationship::relating_approval_() const
{
    return (SdaiApproval_ptr) _relating_approval;
}

void
SdaiApproval_relationship::relating_approval_ (const SdaiApproval_ptr x)

{
    _relating_approval = x;
}

const SdaiApproval_ptr
SdaiApproval_relationship::related_approval_() const
{
    return (SdaiApproval_ptr) _related_approval;
}

void
SdaiApproval_relationship::related_approval_ (const SdaiApproval_ptr x)

{
    _related_approval = x;
}

/////////	 END_ENTITY approval_relationship


/////////	 ENTITY polyline

EntityDescriptor *config_control_designe_polyline =0;
AttrDescriptor *a_407points =0;
SdaiPolyline::SdaiPolyline( )
{

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_polyline;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_407points,  &_points);
#else
    STEPattribute *a = new STEPattribute(*a_407points,  &_points);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiPolyline::SdaiPolyline (SdaiPolyline& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPolyline::~SdaiPolyline () {  }

#ifdef __OSTORE__

void
SdaiPolyline::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPolyline: virtual access function." << endl;
    SdaiPolyline_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPolyline_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPolyline: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPolyline *ent = (SdaiPolyline *)sent;
//    SdaiPolyline *ent = (SdaiPolyline *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_polyline;
    ent->attributes[1].aDesc = a_407points;
}

SCLP23(Application_instance_ptr)
create_SdaiPolyline(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPolyline::get_os_typespec())
                                   SdaiPolyline;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPolyline::get_os_typespec())
//                                   SdaiPolyline;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPolyline;
}
#endif

#ifdef __O3DB__
void
SdaiPolyline::oodb_reInit ()
{	eDesc = config_control_designe_polyline;
	attributes [1].aDesc = a_407points;
}
#endif

SdaiPolyline::SdaiPolyline (SCLP23(Application_instance) *se, int *addAttrs) : SdaiBounded_curve(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_polyline;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_407points,  &_points);
#else
    STEPattribute *a = new STEPattribute(*a_407points,  &_points);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const EntityAggregate_ptr
SdaiPolyline::points_() const
{
    return (EntityAggregate_ptr) &_points;
}

void
SdaiPolyline::points_ (const EntityAggregate_ptr x)

	{ _points.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY polyline


/////////	 ENTITY approval_person_organization

EntityDescriptor *config_control_designe_approval_person_organization =0;
AttrDescriptor *a_408person_organization =0;
AttrDescriptor *a_409authorized_approval =0;
AttrDescriptor *a_410role =0;
SdaiApproval_person_organization::SdaiApproval_person_organization( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_person_organization;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_408person_organization,  &_person_organization);
#else
    STEPattribute *a = new STEPattribute(*a_408person_organization,  &_person_organization);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_409authorized_approval, (SCLP23(Application_instance_ptr) *) &_authorized_approval);
#else
    a = new STEPattribute(*a_409authorized_approval, (SCLP23(Application_instance_ptr) *) &_authorized_approval);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_410role, (SCLP23(Application_instance_ptr) *) &_role);
#else
    a = new STEPattribute(*a_410role, (SCLP23(Application_instance_ptr) *) &_role);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_person_organization::SdaiApproval_person_organization (SdaiApproval_person_organization& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiApproval_person_organization::~SdaiApproval_person_organization () {  }

#ifdef __OSTORE__

void
SdaiApproval_person_organization::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_person_organization: virtual access function." << endl;
    SdaiApproval_person_organization_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiApproval_person_organization_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiApproval_person_organization: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiApproval_person_organization *ent = (SdaiApproval_person_organization *)sent;
//    SdaiApproval_person_organization *ent = (SdaiApproval_person_organization *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_approval_person_organization;
    ent->attributes[0].aDesc = a_408person_organization;
    ent->attributes[1].aDesc = a_409authorized_approval;
    if(ent->_authorized_approval == 0)
        ent->_authorized_approval = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_410role;
    if(ent->_role == 0)
        ent->_role = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiApproval_person_organization(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiApproval_person_organization::get_os_typespec())
                                   SdaiApproval_person_organization;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiApproval_person_organization::get_os_typespec())
//                                   SdaiApproval_person_organization;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiApproval_person_organization;
}
#endif

#ifdef __O3DB__
void
SdaiApproval_person_organization::oodb_reInit ()
{	eDesc = config_control_designe_approval_person_organization;
	attributes [0].aDesc = a_408person_organization;
	attributes [1].aDesc = a_409authorized_approval;
	attributes [2].aDesc = a_410role;
}
#endif

SdaiApproval_person_organization::SdaiApproval_person_organization( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_person_organization;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_408person_organization,  &_person_organization);
#else
    STEPattribute *a = new STEPattribute(*a_408person_organization,  &_person_organization);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_409authorized_approval, (SCLP23(Application_instance_ptr) *) &_authorized_approval);
#else
    a = new STEPattribute(*a_409authorized_approval, (SCLP23(Application_instance_ptr) *) &_authorized_approval);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_410role, (SCLP23(Application_instance_ptr) *) &_role);
#else
    a = new STEPattribute(*a_410role, (SCLP23(Application_instance_ptr) *) &_role);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiPerson_organization_select_ptr
SdaiApproval_person_organization::person_organization_() const
	{ return (const SdaiPerson_organization_select_ptr) &_person_organization; }

void
SdaiApproval_person_organization::person_organization_ (const SdaiPerson_organization_select_ptr x)

	{ _person_organization = x; }

const SdaiApproval_ptr
SdaiApproval_person_organization::authorized_approval_() const
{
    return (SdaiApproval_ptr) _authorized_approval;
}

void
SdaiApproval_person_organization::authorized_approval_ (const SdaiApproval_ptr x)

{
    _authorized_approval = x;
}

const SdaiApproval_role_ptr
SdaiApproval_person_organization::role_() const
{
    return (SdaiApproval_role_ptr) _role;
}

void
SdaiApproval_person_organization::role_ (const SdaiApproval_role_ptr x)

{
    _role = x;
}

/////////	 END_ENTITY approval_person_organization


/////////	 ENTITY surface_replica

EntityDescriptor *config_control_designe_surface_replica =0;
AttrDescriptor *a_411parent_surface =0;
AttrDescriptor *a_412transformation =0;
SdaiSurface_replica::SdaiSurface_replica( )
{

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_replica;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_411parent_surface, (SCLP23(Application_instance_ptr) *) &_parent_surface);
#else
    STEPattribute *a = new STEPattribute(*a_411parent_surface, (SCLP23(Application_instance_ptr) *) &_parent_surface);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_412transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#else
    a = new STEPattribute(*a_412transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiSurface_replica::SdaiSurface_replica (SdaiSurface_replica& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSurface_replica::~SdaiSurface_replica () {  }

#ifdef __OSTORE__

void
SdaiSurface_replica::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface_replica: virtual access function." << endl;
    SdaiSurface_replica_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSurface_replica_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSurface_replica: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSurface_replica *ent = (SdaiSurface_replica *)sent;
//    SdaiSurface_replica *ent = (SdaiSurface_replica *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_surface_replica;
    ent->attributes[1].aDesc = a_411parent_surface;
    if(ent->_parent_surface == 0)
        ent->_parent_surface = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_412transformation;
    if(ent->_transformation == 0)
        ent->_transformation = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiSurface_replica(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSurface_replica::get_os_typespec())
                                   SdaiSurface_replica;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSurface_replica::get_os_typespec())
//                                   SdaiSurface_replica;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSurface_replica;
}
#endif

#ifdef __O3DB__
void
SdaiSurface_replica::oodb_reInit ()
{	eDesc = config_control_designe_surface_replica;
	attributes [1].aDesc = a_411parent_surface;
	attributes [2].aDesc = a_412transformation;
}
#endif

SdaiSurface_replica::SdaiSurface_replica (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSurface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_replica;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_411parent_surface, (SCLP23(Application_instance_ptr) *) &_parent_surface);
#else
    STEPattribute *a = new STEPattribute(*a_411parent_surface, (SCLP23(Application_instance_ptr) *) &_parent_surface);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_412transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#else
    a = new STEPattribute(*a_412transformation, (SCLP23(Application_instance_ptr) *) &_transformation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiSurface_ptr
SdaiSurface_replica::parent_surface_() const
{
    return (SdaiSurface_ptr) _parent_surface;
}

void
SdaiSurface_replica::parent_surface_ (const SdaiSurface_ptr x)

{
    _parent_surface = x;
}

const SdaiCartesian_transformation_operator_3d_ptr
SdaiSurface_replica::transformation_() const
{
    return (SdaiCartesian_transformation_operator_3d_ptr) _transformation;
}

void
SdaiSurface_replica::transformation_ (const SdaiCartesian_transformation_operator_3d_ptr x)

{
    _transformation = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY surface_replica


/////////	 ENTITY security_classification_assignment

EntityDescriptor *config_control_designe_security_classification_assignment =0;
AttrDescriptor *a_413assigned_security_classification =0;
SdaiSecurity_classification_assignment::SdaiSecurity_classification_assignment( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_413assigned_security_classification, (SCLP23(Application_instance_ptr) *) &_assigned_security_classification);
#else
    STEPattribute *a = new STEPattribute(*a_413assigned_security_classification, (SCLP23(Application_instance_ptr) *) &_assigned_security_classification);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiSecurity_classification_assignment::SdaiSecurity_classification_assignment (SdaiSecurity_classification_assignment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiSecurity_classification_assignment::~SdaiSecurity_classification_assignment () {  }

#ifdef __OSTORE__

void
SdaiSecurity_classification_assignment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSecurity_classification_assignment: virtual access function." << endl;
    SdaiSecurity_classification_assignment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiSecurity_classification_assignment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiSecurity_classification_assignment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiSecurity_classification_assignment *ent = (SdaiSecurity_classification_assignment *)sent;
//    SdaiSecurity_classification_assignment *ent = (SdaiSecurity_classification_assignment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_security_classification_assignment;
    ent->attributes[0].aDesc = a_413assigned_security_classification;
    if(ent->_assigned_security_classification == 0)
        ent->_assigned_security_classification = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiSecurity_classification_assignment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiSecurity_classification_assignment::get_os_typespec())
                                   SdaiSecurity_classification_assignment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiSecurity_classification_assignment::get_os_typespec())
//                                   SdaiSecurity_classification_assignment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiSecurity_classification_assignment;
}
#endif

#ifdef __O3DB__
void
SdaiSecurity_classification_assignment::oodb_reInit ()
{	eDesc = config_control_designe_security_classification_assignment;
	attributes [0].aDesc = a_413assigned_security_classification;
}
#endif

SdaiSecurity_classification_assignment::SdaiSecurity_classification_assignment( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_413assigned_security_classification, (SCLP23(Application_instance_ptr) *) &_assigned_security_classification);
#else
    STEPattribute *a = new STEPattribute(*a_413assigned_security_classification, (SCLP23(Application_instance_ptr) *) &_assigned_security_classification);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiSecurity_classification_ptr
SdaiSecurity_classification_assignment::assigned_security_classification_() const
{
    return (SdaiSecurity_classification_ptr) _assigned_security_classification;
}

void
SdaiSecurity_classification_assignment::assigned_security_classification_ (const SdaiSecurity_classification_ptr x)

{
    _assigned_security_classification = x;
}

/////////	 END_ENTITY security_classification_assignment


/////////	 ENTITY cc_design_security_classification

EntityDescriptor *config_control_designe_cc_design_security_classification =0;
AttrDescriptor *a_414items =0;
SdaiCc_design_security_classification::SdaiCc_design_security_classification( )
{

	/*  parent: SdaiSecurity_classification_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_security_classification;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_414items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_414items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_security_classification::SdaiCc_design_security_classification (SdaiCc_design_security_classification& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCc_design_security_classification::~SdaiCc_design_security_classification () {  }

#ifdef __OSTORE__

void
SdaiCc_design_security_classification::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_security_classification: virtual access function." << endl;
    SdaiCc_design_security_classification_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCc_design_security_classification_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_security_classification: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCc_design_security_classification *ent = (SdaiCc_design_security_classification *)sent;
//    SdaiCc_design_security_classification *ent = (SdaiCc_design_security_classification *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_cc_design_security_classification;
    ent->attributes[1].aDesc = a_414items;
}

SCLP23(Application_instance_ptr)
create_SdaiCc_design_security_classification(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCc_design_security_classification::get_os_typespec())
                                   SdaiCc_design_security_classification;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCc_design_security_classification::get_os_typespec())
//                                   SdaiCc_design_security_classification;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCc_design_security_classification;
}
#endif

#ifdef __O3DB__
void
SdaiCc_design_security_classification::oodb_reInit ()
{	eDesc = config_control_designe_cc_design_security_classification;
	attributes [1].aDesc = a_414items;
}
#endif

SdaiCc_design_security_classification::SdaiCc_design_security_classification (SCLP23(Application_instance) *se, int *addAttrs) : SdaiSecurity_classification_assignment(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiSecurity_classification_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_security_classification;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_414items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_414items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiClassified_items_ptr
SdaiCc_design_security_classification::items_() const
{
    return (SdaiClassified_items_ptr) &_items;
}

void
SdaiCc_design_security_classification::items_ (const SdaiClassified_items_ptr x)

	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_security_classification


/////////	 ENTITY faceted_brep_shape_representation

EntityDescriptor *config_control_designe_faceted_brep_shape_representation =0;
SdaiFaceted_brep_shape_representation::SdaiFaceted_brep_shape_representation( )
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_faceted_brep_shape_representation;
}
SdaiFaceted_brep_shape_representation::SdaiFaceted_brep_shape_representation (SdaiFaceted_brep_shape_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiFaceted_brep_shape_representation::~SdaiFaceted_brep_shape_representation () {  }

#ifdef __OSTORE__

void
SdaiFaceted_brep_shape_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFaceted_brep_shape_representation: virtual access function." << endl;
    SdaiFaceted_brep_shape_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiFaceted_brep_shape_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiFaceted_brep_shape_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiFaceted_brep_shape_representation *ent = (SdaiFaceted_brep_shape_representation *)sent;
//    SdaiFaceted_brep_shape_representation *ent = (SdaiFaceted_brep_shape_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_faceted_brep_shape_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiFaceted_brep_shape_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiFaceted_brep_shape_representation::get_os_typespec())
                                   SdaiFaceted_brep_shape_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiFaceted_brep_shape_representation::get_os_typespec())
//                                   SdaiFaceted_brep_shape_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiFaceted_brep_shape_representation;
}
#endif

#ifdef __O3DB__
void
SdaiFaceted_brep_shape_representation::oodb_reInit ()
{	eDesc = config_control_designe_faceted_brep_shape_representation;
}
#endif

SdaiFaceted_brep_shape_representation::SdaiFaceted_brep_shape_representation (SCLP23(Application_instance) *se, int *addAttrs) : SdaiShape_representation(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_faceted_brep_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY faceted_brep_shape_representation


/////////	 ENTITY document_usage_constraint

EntityDescriptor *config_control_designe_document_usage_constraint =0;
AttrDescriptor *a_415source =0;
AttrDescriptor *a_416subject_element =0;
AttrDescriptor *a_417subject_element_value =0;
SdaiDocument_usage_constraint::SdaiDocument_usage_constraint( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_document_usage_constraint;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_415source, (SCLP23(Application_instance_ptr) *) &_source);
#else
    STEPattribute *a = new STEPattribute(*a_415source, (SCLP23(Application_instance_ptr) *) &_source);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_416subject_element,  &_subject_element);
#else
    a = new STEPattribute(*a_416subject_element,  &_subject_element);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_417subject_element_value,  &_subject_element_value);
#else
    a = new STEPattribute(*a_417subject_element_value,  &_subject_element_value);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument_usage_constraint::SdaiDocument_usage_constraint (SdaiDocument_usage_constraint& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiDocument_usage_constraint::~SdaiDocument_usage_constraint () {  }

#ifdef __OSTORE__

void
SdaiDocument_usage_constraint::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument_usage_constraint: virtual access function." << endl;
    SdaiDocument_usage_constraint_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiDocument_usage_constraint_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiDocument_usage_constraint: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiDocument_usage_constraint *ent = (SdaiDocument_usage_constraint *)sent;
//    SdaiDocument_usage_constraint *ent = (SdaiDocument_usage_constraint *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_document_usage_constraint;
    ent->attributes[0].aDesc = a_415source;
    if(ent->_source == 0)
        ent->_source = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_416subject_element;
    ent->attributes[2].aDesc = a_417subject_element_value;
}

SCLP23(Application_instance_ptr)
create_SdaiDocument_usage_constraint(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiDocument_usage_constraint::get_os_typespec())
                                   SdaiDocument_usage_constraint;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiDocument_usage_constraint::get_os_typespec())
//                                   SdaiDocument_usage_constraint;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiDocument_usage_constraint;
}
#endif

#ifdef __O3DB__
void
SdaiDocument_usage_constraint::oodb_reInit ()
{	eDesc = config_control_designe_document_usage_constraint;
	attributes [0].aDesc = a_415source;
	attributes [1].aDesc = a_416subject_element;
	attributes [2].aDesc = a_417subject_element_value;
}
#endif

SdaiDocument_usage_constraint::SdaiDocument_usage_constraint( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_document_usage_constraint;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_415source, (SCLP23(Application_instance_ptr) *) &_source);
#else
    STEPattribute *a = new STEPattribute(*a_415source, (SCLP23(Application_instance_ptr) *) &_source);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_416subject_element,  &_subject_element);
#else
    a = new STEPattribute(*a_416subject_element,  &_subject_element);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_417subject_element_value,  &_subject_element_value);
#else
    a = new STEPattribute(*a_417subject_element_value,  &_subject_element_value);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiDocument_ptr
SdaiDocument_usage_constraint::source_() const
{
    return (SdaiDocument_ptr) _source;
}

void
SdaiDocument_usage_constraint::source_ (const SdaiDocument_ptr x)

{
    _source = x;
}

const SdaiLabel
SdaiDocument_usage_constraint::subject_element_() const
{
    return (const SdaiLabel) _subject_element;
}

void
SdaiDocument_usage_constraint::subject_element_ (const SdaiLabel x)

{
    _subject_element = x;
}

const SdaiText
SdaiDocument_usage_constraint::subject_element_value_() const
{
    return (const SdaiText) _subject_element_value;
}

void
SdaiDocument_usage_constraint::subject_element_value_ (const SdaiText x)

{
    _subject_element_value = x;
}

/////////	 END_ENTITY document_usage_constraint


/////////	 ENTITY vertex_point

EntityDescriptor *config_control_designe_vertex_point =0;
AttrDescriptor *a_418vertex_geometry =0;
SdaiVertex_point::SdaiVertex_point( )
{

	/*  parent: SdaiVertex  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    HeadEntity(this);
    //cout << "vertex_point - head" << endl;
    //PrintSTEPattributes ();
#if 1
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 0; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    AppendMultInstance(new SdaiGeometric_representation_item(this, attrFlags));
#else
    AppendMultInstance(new SdaiGeometric_representation_item(this));
#endif
    //cout << "vertex_point - after AppendMultInstance" << endl;
    //PrintSTEPattributes ();

    eDesc = config_control_designe_vertex_point;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_418vertex_geometry, (SCLP23(Application_instance_ptr) *) &_vertex_geometry);
#else
    STEPattribute *a = new STEPattribute(*a_418vertex_geometry, (SCLP23(Application_instance_ptr) *) &_vertex_geometry);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
    //cout << "vertex_point - after MakeDerived" << endl;
    //PrintSTEPattributes ();
}
SdaiVertex_point::SdaiVertex_point (SdaiVertex_point& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiVertex_point::~SdaiVertex_point () {  }

#ifdef __OSTORE__

void
SdaiVertex_point::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVertex_point: virtual access function." << endl;
    SdaiVertex_point_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiVertex_point_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVertex_point: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiVertex_point *ent = (SdaiVertex_point *)sent;
//    SdaiVertex_point *ent = (SdaiVertex_point *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_vertex_point;
    ent->attributes[2].aDesc = a_418vertex_geometry;
    if(ent->_vertex_geometry == 0)
        ent->_vertex_geometry = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiVertex_point(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiVertex_point::get_os_typespec())
                                   SdaiVertex_point;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiVertex_point::get_os_typespec())
//                                   SdaiVertex_point;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiVertex_point;
}
#endif

#ifdef __O3DB__
void
SdaiVertex_point::oodb_reInit ()
{	eDesc = config_control_designe_vertex_point;
	attributes [2].aDesc = a_418vertex_geometry;
}
#endif

SdaiVertex_point::SdaiVertex_point (SCLP23(Application_instance) *se, int *addAttrs) : SdaiVertex(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiVertex  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    se->AppendMultInstance(new SdaiGeometric_representation_item(se, attrFlags));
#endif
    se->AppendMultInstance(new SdaiGeometric_representation_item(se, 0));

    eDesc = config_control_designe_vertex_point;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_418vertex_geometry, (SCLP23(Application_instance_ptr) *) &_vertex_geometry);
#else
    STEPattribute *a = new STEPattribute(*a_418vertex_geometry, (SCLP23(Application_instance_ptr) *) &_vertex_geometry);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiPoint_ptr
SdaiVertex_point::vertex_geometry_() const
{
    return (SdaiPoint_ptr) _vertex_geometry;
}

void
SdaiVertex_point::vertex_geometry_ (const SdaiPoint_ptr x)

{
    _vertex_geometry = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

#endif

/////////	 END_ENTITY vertex_point


/////////	 ENTITY cc_design_date_and_time_assignment

EntityDescriptor *config_control_designe_cc_design_date_and_time_assignment =0;
AttrDescriptor *a_419items =0;
SdaiCc_design_date_and_time_assignment::SdaiCc_design_date_and_time_assignment( )
{

	/*  parent: SdaiDate_and_time_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_date_and_time_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_419items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_419items,  &_items);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_date_and_time_assignment::SdaiCc_design_date_and_time_assignment (SdaiCc_design_date_and_time_assignment& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCc_design_date_and_time_assignment::~SdaiCc_design_date_and_time_assignment () {  }

#ifdef __OSTORE__

void
SdaiCc_design_date_and_time_assignment::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_date_and_time_assignment: virtual access function." << endl;
    SdaiCc_design_date_and_time_assignment_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCc_design_date_and_time_assignment_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCc_design_date_and_time_assignment: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCc_design_date_and_time_assignment *ent = (SdaiCc_design_date_and_time_assignment *)sent;
//    SdaiCc_design_date_and_time_assignment *ent = (SdaiCc_design_date_and_time_assignment *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_cc_design_date_and_time_assignment;
    ent->attributes[2].aDesc = a_419items;
}

SCLP23(Application_instance_ptr)
create_SdaiCc_design_date_and_time_assignment(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCc_design_date_and_time_assignment::get_os_typespec())
                                   SdaiCc_design_date_and_time_assignment;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCc_design_date_and_time_assignment::get_os_typespec())
//                                   SdaiCc_design_date_and_time_assignment;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCc_design_date_and_time_assignment;
}
#endif

#ifdef __O3DB__
void
SdaiCc_design_date_and_time_assignment::oodb_reInit ()
{	eDesc = config_control_designe_cc_design_date_and_time_assignment;
	attributes [2].aDesc = a_419items;
}
#endif

SdaiCc_design_date_and_time_assignment::SdaiCc_design_date_and_time_assignment (SCLP23(Application_instance) *se, int *addAttrs) : SdaiDate_and_time_assignment(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiDate_and_time_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_date_and_time_assignment;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_419items,  &_items);
#else
    STEPattribute *a = new STEPattribute(*a_419items,  &_items);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiDate_time_items_ptr
SdaiCc_design_date_and_time_assignment::items_() const
{
    return (SdaiDate_time_items_ptr) &_items;
}

void
SdaiCc_design_date_and_time_assignment::items_ (const SdaiDate_time_items_ptr x)

	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_date_and_time_assignment


/////////	 ENTITY oriented_closed_shell

EntityDescriptor *config_control_designe_oriented_closed_shell =0;
AttrDescriptor *a_420closed_shell_element =0;
AttrDescriptor *a_421orientation =0;
Derived_attribute *a_422Dconnected_face_set_cfs_faces =0;
SdaiOriented_closed_shell::SdaiOriented_closed_shell( )
{

	/*  parent: SdaiClosed_shell  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_closed_shell;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_420closed_shell_element, (SCLP23(Application_instance_ptr) *) &_closed_shell_element);
#else
    STEPattribute *a = new STEPattribute(*a_420closed_shell_element, (SCLP23(Application_instance_ptr) *) &_closed_shell_element);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_421orientation,  &_orientation);
#else
    a = new STEPattribute(*a_421orientation,  &_orientation);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("cfs_faces");
}
SdaiOriented_closed_shell::SdaiOriented_closed_shell (SdaiOriented_closed_shell& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiOriented_closed_shell::~SdaiOriented_closed_shell () {  }

#ifdef __OSTORE__

void
SdaiOriented_closed_shell::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOriented_closed_shell: virtual access function." << endl;
    SdaiOriented_closed_shell_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiOriented_closed_shell_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiOriented_closed_shell: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiOriented_closed_shell *ent = (SdaiOriented_closed_shell *)sent;
//    SdaiOriented_closed_shell *ent = (SdaiOriented_closed_shell *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_oriented_closed_shell;
    ent->attributes[2].aDesc = a_420closed_shell_element;
    if(ent->_closed_shell_element == 0)
        ent->_closed_shell_element = S_ENTITY_NULL;
    ent->attributes[3].aDesc = a_421orientation;
}

SCLP23(Application_instance_ptr)
create_SdaiOriented_closed_shell(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiOriented_closed_shell::get_os_typespec())
                                   SdaiOriented_closed_shell;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiOriented_closed_shell::get_os_typespec())
//                                   SdaiOriented_closed_shell;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiOriented_closed_shell;
}
#endif

#ifdef __O3DB__
void
SdaiOriented_closed_shell::oodb_reInit ()
{	eDesc = config_control_designe_oriented_closed_shell;
	attributes [2].aDesc = a_420closed_shell_element;
	attributes [3].aDesc = a_421orientation;
}
#endif

SdaiOriented_closed_shell::SdaiOriented_closed_shell (SCLP23(Application_instance) *se, int *addAttrs) : SdaiClosed_shell(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiClosed_shell  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_closed_shell;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_420closed_shell_element, (SCLP23(Application_instance_ptr) *) &_closed_shell_element);
#else
    STEPattribute *a = new STEPattribute(*a_420closed_shell_element, (SCLP23(Application_instance_ptr) *) &_closed_shell_element);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_421orientation,  &_orientation);
#else
    a = new STEPattribute(*a_421orientation,  &_orientation);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("cfs_faces");
}

const SdaiClosed_shell_ptr
SdaiOriented_closed_shell::closed_shell_element_() const
{
    return (SdaiClosed_shell_ptr) _closed_shell_element;
}

void
SdaiOriented_closed_shell::closed_shell_element_ (const SdaiClosed_shell_ptr x)

{
    _closed_shell_element = x;
}

const SCLBOOL(Bool)
SdaiOriented_closed_shell::orientation_() const
{
    return (SCLBOOL(Bool)) _orientation;
}

void
SdaiOriented_closed_shell::orientation_ (const SCLBOOL(Bool) x)

{
    _orientation.put (x);
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY oriented_closed_shell


/////////	 ENTITY person_and_organization

EntityDescriptor *config_control_designe_person_and_organization =0;
AttrDescriptor *a_423the_person =0;
AttrDescriptor *a_424the_organization =0;
SdaiPerson_and_organization::SdaiPerson_and_organization( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_423the_person, (SCLP23(Application_instance_ptr) *) &_the_person);
#else
    STEPattribute *a = new STEPattribute(*a_423the_person, (SCLP23(Application_instance_ptr) *) &_the_person);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_424the_organization, (SCLP23(Application_instance_ptr) *) &_the_organization);
#else
    a = new STEPattribute(*a_424the_organization, (SCLP23(Application_instance_ptr) *) &_the_organization);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiPerson_and_organization::SdaiPerson_and_organization (SdaiPerson_and_organization& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPerson_and_organization::~SdaiPerson_and_organization () {  }

#ifdef __OSTORE__

void
SdaiPerson_and_organization::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPerson_and_organization: virtual access function." << endl;
    SdaiPerson_and_organization_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPerson_and_organization_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPerson_and_organization: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPerson_and_organization *ent = (SdaiPerson_and_organization *)sent;
//    SdaiPerson_and_organization *ent = (SdaiPerson_and_organization *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_person_and_organization;
    ent->attributes[0].aDesc = a_423the_person;
    if(ent->_the_person == 0)
        ent->_the_person = S_ENTITY_NULL;
    ent->attributes[1].aDesc = a_424the_organization;
    if(ent->_the_organization == 0)
        ent->_the_organization = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiPerson_and_organization(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPerson_and_organization::get_os_typespec())
                                   SdaiPerson_and_organization;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPerson_and_organization::get_os_typespec())
//                                   SdaiPerson_and_organization;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPerson_and_organization;
}
#endif

#ifdef __O3DB__
void
SdaiPerson_and_organization::oodb_reInit ()
{	eDesc = config_control_designe_person_and_organization;
	attributes [0].aDesc = a_423the_person;
	attributes [1].aDesc = a_424the_organization;
}
#endif

SdaiPerson_and_organization::SdaiPerson_and_organization( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_423the_person, (SCLP23(Application_instance_ptr) *) &_the_person);
#else
    STEPattribute *a = new STEPattribute(*a_423the_person, (SCLP23(Application_instance_ptr) *) &_the_person);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_424the_organization, (SCLP23(Application_instance_ptr) *) &_the_organization);
#else
    a = new STEPattribute(*a_424the_organization, (SCLP23(Application_instance_ptr) *) &_the_organization);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiPerson_ptr
SdaiPerson_and_organization::the_person_() const
{
    return (SdaiPerson_ptr) _the_person;
}

void
SdaiPerson_and_organization::the_person_ (const SdaiPerson_ptr x)

{
    _the_person = x;
}

const SdaiOrganization_ptr
SdaiPerson_and_organization::the_organization_() const
{
    return (SdaiOrganization_ptr) _the_organization;
}

void
SdaiPerson_and_organization::the_organization_ (const SdaiOrganization_ptr x)

{
    _the_organization = x;
}

/////////	 END_ENTITY person_and_organization


/////////	 ENTITY cylindrical_surface

EntityDescriptor *config_control_designe_cylindrical_surface =0;
AttrDescriptor *a_425radius =0;
SdaiCylindrical_surface::SdaiCylindrical_surface( )
{

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cylindrical_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_425radius,  &_radius);
#else
    STEPattribute *a = new STEPattribute(*a_425radius,  &_radius);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiCylindrical_surface::SdaiCylindrical_surface (SdaiCylindrical_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiCylindrical_surface::~SdaiCylindrical_surface () {  }

#ifdef __OSTORE__

void
SdaiCylindrical_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCylindrical_surface: virtual access function." << endl;
    SdaiCylindrical_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiCylindrical_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiCylindrical_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiCylindrical_surface *ent = (SdaiCylindrical_surface *)sent;
//    SdaiCylindrical_surface *ent = (SdaiCylindrical_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_cylindrical_surface;
    ent->attributes[2].aDesc = a_425radius;
}

SCLP23(Application_instance_ptr)
create_SdaiCylindrical_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiCylindrical_surface::get_os_typespec())
                                   SdaiCylindrical_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiCylindrical_surface::get_os_typespec())
//                                   SdaiCylindrical_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiCylindrical_surface;
}
#endif

#ifdef __O3DB__
void
SdaiCylindrical_surface::oodb_reInit ()
{	eDesc = config_control_designe_cylindrical_surface;
	attributes [2].aDesc = a_425radius;
}
#endif

SdaiCylindrical_surface::SdaiCylindrical_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiElementary_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cylindrical_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_425radius,  &_radius);
#else
    STEPattribute *a = new STEPattribute(*a_425radius,  &_radius);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiPositive_length_measure
SdaiCylindrical_surface::radius_() const
{
    return (const SdaiPositive_length_measure) _radius;
}

void
SdaiCylindrical_surface::radius_ (const SdaiPositive_length_measure x)

{
    _radius = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cylindrical_surface


/////////	 ENTITY local_time

EntityDescriptor *config_control_designe_local_time =0;
AttrDescriptor *a_426hour_component =0;
AttrDescriptor *a_427minute_component =0;
AttrDescriptor *a_428second_component =0;
AttrDescriptor *a_429zone =0;
SdaiLocal_time::SdaiLocal_time( )
{

	/*  no SuperTypes */

    eDesc = config_control_designe_local_time;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_426hour_component,  &_hour_component);
#else
    STEPattribute *a = new STEPattribute(*a_426hour_component,  &_hour_component);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_427minute_component,  &_minute_component);
#else
    a = new STEPattribute(*a_427minute_component,  &_minute_component);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_428second_component,  &_second_component);
#else
    a = new STEPattribute(*a_428second_component,  &_second_component);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_429zone, (SCLP23(Application_instance_ptr) *) &_zone);
#else
    a = new STEPattribute(*a_429zone, (SCLP23(Application_instance_ptr) *) &_zone);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiLocal_time::SdaiLocal_time (SdaiLocal_time& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiLocal_time::~SdaiLocal_time () {  }

#ifdef __OSTORE__

void
SdaiLocal_time::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLocal_time: virtual access function." << endl;
    SdaiLocal_time_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiLocal_time_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiLocal_time: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiLocal_time *ent = (SdaiLocal_time *)sent;
//    SdaiLocal_time *ent = (SdaiLocal_time *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_local_time;
    ent->attributes[0].aDesc = a_426hour_component;
    ent->attributes[1].aDesc = a_427minute_component;
    ent->attributes[2].aDesc = a_428second_component;
    ent->attributes[3].aDesc = a_429zone;
    if(ent->_zone == 0)
        ent->_zone = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiLocal_time(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiLocal_time::get_os_typespec())
                                   SdaiLocal_time;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiLocal_time::get_os_typespec())
//                                   SdaiLocal_time;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiLocal_time;
}
#endif

#ifdef __O3DB__
void
SdaiLocal_time::oodb_reInit ()
{	eDesc = config_control_designe_local_time;
	attributes [0].aDesc = a_426hour_component;
	attributes [1].aDesc = a_427minute_component;
	attributes [2].aDesc = a_428second_component;
	attributes [3].aDesc = a_429zone;
}
#endif

SdaiLocal_time::SdaiLocal_time( SCLP23(Application_instance) *se, int *addAttrs)
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  no SuperTypes */

    eDesc = config_control_designe_local_time;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_426hour_component,  &_hour_component);
#else
    STEPattribute *a = new STEPattribute(*a_426hour_component,  &_hour_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_427minute_component,  &_minute_component);
#else
    a = new STEPattribute(*a_427minute_component,  &_minute_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_428second_component,  &_second_component);
#else
    a = new STEPattribute(*a_428second_component,  &_second_component);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_429zone, (SCLP23(Application_instance_ptr) *) &_zone);
#else
    a = new STEPattribute(*a_429zone, (SCLP23(Application_instance_ptr) *) &_zone);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiHour_in_day
SdaiLocal_time::hour_component_() const
{
    return (const SdaiHour_in_day) _hour_component;
}

void
SdaiLocal_time::hour_component_ (const SdaiHour_in_day x)

{
    _hour_component = x;
}

const SdaiMinute_in_hour
SdaiLocal_time::minute_component_() const
{
    return (const SdaiMinute_in_hour) _minute_component;
}

void
SdaiLocal_time::minute_component_ (const SdaiMinute_in_hour x)

{
    _minute_component = x;
}

const SdaiSecond_in_minute
SdaiLocal_time::second_component_() const
{
    return (const SdaiSecond_in_minute) _second_component;
}

void
SdaiLocal_time::second_component_ (const SdaiSecond_in_minute x)

{
    _second_component = x;
}

const SdaiCoordinated_universal_time_offset_ptr
SdaiLocal_time::zone_() const
{
    return (SdaiCoordinated_universal_time_offset_ptr) _zone;
}

void
SdaiLocal_time::zone_ (const SdaiCoordinated_universal_time_offset_ptr x)

{
    _zone = x;
}

/////////	 END_ENTITY local_time


/////////	 ENTITY mass_unit

EntityDescriptor *config_control_designe_mass_unit =0;
SdaiMass_unit::SdaiMass_unit( )
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mass_unit;
}
SdaiMass_unit::SdaiMass_unit (SdaiMass_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiMass_unit::~SdaiMass_unit () {  }

#ifdef __OSTORE__

void
SdaiMass_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiMass_unit: virtual access function." << endl;
    SdaiMass_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiMass_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiMass_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiMass_unit *ent = (SdaiMass_unit *)sent;
//    SdaiMass_unit *ent = (SdaiMass_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_mass_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiMass_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiMass_unit::get_os_typespec())
                                   SdaiMass_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiMass_unit::get_os_typespec())
//                                   SdaiMass_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiMass_unit;
}
#endif

#ifdef __O3DB__
void
SdaiMass_unit::oodb_reInit ()
{	eDesc = config_control_designe_mass_unit;
}
#endif

SdaiMass_unit::SdaiMass_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiNamed_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mass_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY mass_unit


/////////	 ENTITY vertex_shell

EntityDescriptor *config_control_designe_vertex_shell =0;
AttrDescriptor *a_430vertex_shell_extent =0;
SdaiVertex_shell::SdaiVertex_shell( )
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex_shell;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_430vertex_shell_extent, (SCLP23(Application_instance_ptr) *) &_vertex_shell_extent);
#else
    STEPattribute *a = new STEPattribute(*a_430vertex_shell_extent, (SCLP23(Application_instance_ptr) *) &_vertex_shell_extent);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiVertex_shell::SdaiVertex_shell (SdaiVertex_shell& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiVertex_shell::~SdaiVertex_shell () {  }

#ifdef __OSTORE__

void
SdaiVertex_shell::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVertex_shell: virtual access function." << endl;
    SdaiVertex_shell_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiVertex_shell_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVertex_shell: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiVertex_shell *ent = (SdaiVertex_shell *)sent;
//    SdaiVertex_shell *ent = (SdaiVertex_shell *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_vertex_shell;
    ent->attributes[1].aDesc = a_430vertex_shell_extent;
    if(ent->_vertex_shell_extent == 0)
        ent->_vertex_shell_extent = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiVertex_shell(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiVertex_shell::get_os_typespec())
                                   SdaiVertex_shell;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiVertex_shell::get_os_typespec())
//                                   SdaiVertex_shell;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiVertex_shell;
}
#endif

#ifdef __O3DB__
void
SdaiVertex_shell::oodb_reInit ()
{	eDesc = config_control_designe_vertex_shell;
	attributes [1].aDesc = a_430vertex_shell_extent;
}
#endif

SdaiVertex_shell::SdaiVertex_shell (SCLP23(Application_instance) *se, int *addAttrs) : SdaiTopological_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex_shell;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_430vertex_shell_extent, (SCLP23(Application_instance_ptr) *) &_vertex_shell_extent);
#else
    STEPattribute *a = new STEPattribute(*a_430vertex_shell_extent, (SCLP23(Application_instance_ptr) *) &_vertex_shell_extent);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiVertex_loop_ptr
SdaiVertex_shell::vertex_shell_extent_() const
{
    return (SdaiVertex_loop_ptr) _vertex_shell_extent;
}

void
SdaiVertex_shell::vertex_shell_extent_ (const SdaiVertex_loop_ptr x)

{
    _vertex_shell_extent = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY vertex_shell


/////////	 ENTITY poly_loop

EntityDescriptor *config_control_designe_poly_loop =0;
AttrDescriptor *a_431polygon =0;
SdaiPoly_loop::SdaiPoly_loop( )
{

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    HeadEntity(this);
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    AppendMultInstance(new SdaiGeometric_representation_item(this, attrFlags));
#endif
    AppendMultInstance(new SdaiGeometric_representation_item(this));

    eDesc = config_control_designe_poly_loop;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_431polygon,  &_polygon);
#else
    STEPattribute *a = new STEPattribute(*a_431polygon,  &_polygon);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiPoly_loop::SdaiPoly_loop (SdaiPoly_loop& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiPoly_loop::~SdaiPoly_loop () {  }

#ifdef __OSTORE__

void
SdaiPoly_loop::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPoly_loop: virtual access function." << endl;
    SdaiPoly_loop_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiPoly_loop_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiPoly_loop: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiPoly_loop *ent = (SdaiPoly_loop *)sent;
//    SdaiPoly_loop *ent = (SdaiPoly_loop *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_poly_loop;
    ent->attributes[2].aDesc = a_431polygon;
}

SCLP23(Application_instance_ptr)
create_SdaiPoly_loop(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiPoly_loop::get_os_typespec())
                                   SdaiPoly_loop;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiPoly_loop::get_os_typespec())
//                                   SdaiPoly_loop;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiPoly_loop;
}
#endif

#ifdef __O3DB__
void
SdaiPoly_loop::oodb_reInit ()
{	eDesc = config_control_designe_poly_loop;
	attributes [2].aDesc = a_431polygon;
}
#endif

SdaiPoly_loop::SdaiPoly_loop (SCLP23(Application_instance) *se, int *addAttrs) : SdaiLoop(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
#if 0
	/* Optionally use the following to replace the line following
	   the endif. Use this to turn off adding attributes in
	   diamond shaped hierarchies for each additional parent at this
	   level. You currently must hand edit this for it to work. */
    int attrFlags[3]; // e.g.
    attrFlags[0] = 1; // add parents attrs
    attrFlags[1] = 1; // add parent of parents attrs
    attrFlags[2] = 0; // do not add parent of parent of parents attrs
      // In *imaginary* hierarchy turn off attrFlags[2] since it
      // would be the parent that has more than one path to it.
    se->AppendMultInstance(new SdaiGeometric_representation_item(se, attrFlags));
#endif
    se->AppendMultInstance(new SdaiGeometric_representation_item(se, 0));

    eDesc = config_control_designe_poly_loop;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_431polygon,  &_polygon);
#else
    STEPattribute *a = new STEPattribute(*a_431polygon,  &_polygon);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const EntityAggregate_ptr
SdaiPoly_loop::polygon_() const
{
    return (EntityAggregate_ptr) &_polygon;
}

void
SdaiPoly_loop::polygon_ (const EntityAggregate_ptr x)

	{ _polygon.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

#endif

/////////	 END_ENTITY poly_loop


/////////	 ENTITY wire_shell

EntityDescriptor *config_control_designe_wire_shell =0;
AttrDescriptor *a_432wire_shell_extent =0;
SdaiWire_shell::SdaiWire_shell( )
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_wire_shell;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_432wire_shell_extent,  &_wire_shell_extent);
#else
    STEPattribute *a = new STEPattribute(*a_432wire_shell_extent,  &_wire_shell_extent);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiWire_shell::SdaiWire_shell (SdaiWire_shell& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiWire_shell::~SdaiWire_shell () {  }

#ifdef __OSTORE__

void
SdaiWire_shell::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiWire_shell: virtual access function." << endl;
    SdaiWire_shell_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiWire_shell_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiWire_shell: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiWire_shell *ent = (SdaiWire_shell *)sent;
//    SdaiWire_shell *ent = (SdaiWire_shell *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_wire_shell;
    ent->attributes[1].aDesc = a_432wire_shell_extent;
}

SCLP23(Application_instance_ptr)
create_SdaiWire_shell(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiWire_shell::get_os_typespec())
                                   SdaiWire_shell;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiWire_shell::get_os_typespec())
//                                   SdaiWire_shell;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiWire_shell;
}
#endif

#ifdef __O3DB__
void
SdaiWire_shell::oodb_reInit ()
{	eDesc = config_control_designe_wire_shell;
	attributes [1].aDesc = a_432wire_shell_extent;
}
#endif

SdaiWire_shell::SdaiWire_shell (SCLP23(Application_instance) *se, int *addAttrs) : SdaiTopological_representation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_wire_shell;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_432wire_shell_extent,  &_wire_shell_extent);
#else
    STEPattribute *a = new STEPattribute(*a_432wire_shell_extent,  &_wire_shell_extent);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const EntityAggregate_ptr
SdaiWire_shell::wire_shell_extent_() const
{
    return (EntityAggregate_ptr) &_wire_shell_extent;
}

void
SdaiWire_shell::wire_shell_extent_ (const EntityAggregate_ptr x)

	{ _wire_shell_extent.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY wire_shell


/////////	 ENTITY area_unit

EntityDescriptor *config_control_designe_area_unit =0;
SdaiArea_unit::SdaiArea_unit( )
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_area_unit;
}
SdaiArea_unit::SdaiArea_unit (SdaiArea_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiArea_unit::~SdaiArea_unit () {  }

#ifdef __OSTORE__

void
SdaiArea_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiArea_unit: virtual access function." << endl;
    SdaiArea_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiArea_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiArea_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiArea_unit *ent = (SdaiArea_unit *)sent;
//    SdaiArea_unit *ent = (SdaiArea_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_area_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiArea_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiArea_unit::get_os_typespec())
                                   SdaiArea_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiArea_unit::get_os_typespec())
//                                   SdaiArea_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiArea_unit;
}
#endif

#ifdef __O3DB__
void
SdaiArea_unit::oodb_reInit ()
{	eDesc = config_control_designe_area_unit;
}
#endif

SdaiArea_unit::SdaiArea_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiNamed_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_area_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY area_unit


/////////	 ENTITY mapped_item

EntityDescriptor *config_control_designe_mapped_item =0;
AttrDescriptor *a_433mapping_source =0;
AttrDescriptor *a_434mapping_target =0;
SdaiMapped_item::SdaiMapped_item( )
{

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mapped_item;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_433mapping_source, (SCLP23(Application_instance_ptr) *) &_mapping_source);
#else
    STEPattribute *a = new STEPattribute(*a_433mapping_source, (SCLP23(Application_instance_ptr) *) &_mapping_source);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_434mapping_target, (SCLP23(Application_instance_ptr) *) &_mapping_target);
#else
    a = new STEPattribute(*a_434mapping_target, (SCLP23(Application_instance_ptr) *) &_mapping_target);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiMapped_item::SdaiMapped_item (SdaiMapped_item& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiMapped_item::~SdaiMapped_item () {  }

#ifdef __OSTORE__

void
SdaiMapped_item::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiMapped_item: virtual access function." << endl;
    SdaiMapped_item_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiMapped_item_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiMapped_item: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiMapped_item *ent = (SdaiMapped_item *)sent;
//    SdaiMapped_item *ent = (SdaiMapped_item *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_mapped_item;
    ent->attributes[1].aDesc = a_433mapping_source;
    if(ent->_mapping_source == 0)
        ent->_mapping_source = S_ENTITY_NULL;
    ent->attributes[2].aDesc = a_434mapping_target;
    if(ent->_mapping_target == 0)
        ent->_mapping_target = S_ENTITY_NULL;
}

SCLP23(Application_instance_ptr)
create_SdaiMapped_item(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiMapped_item::get_os_typespec())
                                   SdaiMapped_item;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiMapped_item::get_os_typespec())
//                                   SdaiMapped_item;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiMapped_item;
}
#endif

#ifdef __O3DB__
void
SdaiMapped_item::oodb_reInit ()
{	eDesc = config_control_designe_mapped_item;
	attributes [1].aDesc = a_433mapping_source;
	attributes [2].aDesc = a_434mapping_target;
}
#endif

SdaiMapped_item::SdaiMapped_item (SCLP23(Application_instance) *se, int *addAttrs) : SdaiRepresentation_item(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mapped_item;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_433mapping_source, (SCLP23(Application_instance_ptr) *) &_mapping_source);
#else
    STEPattribute *a = new STEPattribute(*a_433mapping_source, (SCLP23(Application_instance_ptr) *) &_mapping_source);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_434mapping_target, (SCLP23(Application_instance_ptr) *) &_mapping_target);
#else
    a = new STEPattribute(*a_434mapping_target, (SCLP23(Application_instance_ptr) *) &_mapping_target);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiRepresentation_map_ptr
SdaiMapped_item::mapping_source_() const
{
    return (SdaiRepresentation_map_ptr) _mapping_source;
}

void
SdaiMapped_item::mapping_source_ (const SdaiRepresentation_map_ptr x)

{
    _mapping_source = x;
}

const SdaiRepresentation_item_ptr
SdaiMapped_item::mapping_target_() const
{
    return (SdaiRepresentation_item_ptr) _mapping_target;
}

void
SdaiMapped_item::mapping_target_ (const SdaiRepresentation_item_ptr x)

{
    _mapping_target = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY mapped_item


/////////	 ENTITY shape_definition_representation

EntityDescriptor *config_control_designe_shape_definition_representation =0;
SdaiShape_definition_representation::SdaiShape_definition_representation( )
{

	/*  parent: SdaiProperty_definition_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_definition_representation;
}
SdaiShape_definition_representation::SdaiShape_definition_representation (SdaiShape_definition_representation& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiShape_definition_representation::~SdaiShape_definition_representation () {  }

#ifdef __OSTORE__

void
SdaiShape_definition_representation::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShape_definition_representation: virtual access function." << endl;
    SdaiShape_definition_representation_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiShape_definition_representation_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiShape_definition_representation: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiShape_definition_representation *ent = (SdaiShape_definition_representation *)sent;
//    SdaiShape_definition_representation *ent = (SdaiShape_definition_representation *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_shape_definition_representation;
}

SCLP23(Application_instance_ptr)
create_SdaiShape_definition_representation(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiShape_definition_representation::get_os_typespec())
                                   SdaiShape_definition_representation;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiShape_definition_representation::get_os_typespec())
//                                   SdaiShape_definition_representation;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiShape_definition_representation;
}
#endif

#ifdef __O3DB__
void
SdaiShape_definition_representation::oodb_reInit ()
{	eDesc = config_control_designe_shape_definition_representation;
}
#endif

SdaiShape_definition_representation::SdaiShape_definition_representation (SCLP23(Application_instance) *se, int *addAttrs) : SdaiProperty_definition_representation(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiProperty_definition_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_definition_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shape_definition_representation


/////////	 ENTITY volume_unit

EntityDescriptor *config_control_designe_volume_unit =0;
SdaiVolume_unit::SdaiVolume_unit( )
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_volume_unit;
}
SdaiVolume_unit::SdaiVolume_unit (SdaiVolume_unit& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiVolume_unit::~SdaiVolume_unit () {  }

#ifdef __OSTORE__

void
SdaiVolume_unit::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVolume_unit: virtual access function." << endl;
    SdaiVolume_unit_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiVolume_unit_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiVolume_unit: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiVolume_unit *ent = (SdaiVolume_unit *)sent;
//    SdaiVolume_unit *ent = (SdaiVolume_unit *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_volume_unit;
}

SCLP23(Application_instance_ptr)
create_SdaiVolume_unit(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiVolume_unit::get_os_typespec())
                                   SdaiVolume_unit;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiVolume_unit::get_os_typespec())
//                                   SdaiVolume_unit;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiVolume_unit;
}
#endif

#ifdef __O3DB__
void
SdaiVolume_unit::oodb_reInit ()
{	eDesc = config_control_designe_volume_unit;
}
#endif

SdaiVolume_unit::SdaiVolume_unit (SCLP23(Application_instance) *se, int *addAttrs) : SdaiNamed_unit(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_volume_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY volume_unit


/////////	 ENTITY conical_surface

EntityDescriptor *config_control_designe_conical_surface =0;
AttrDescriptor *a_435radius =0;
AttrDescriptor *a_436semi_angle =0;
SdaiConical_surface::SdaiConical_surface( )
{

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conical_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_435radius,  &_radius);
#else
    STEPattribute *a = new STEPattribute(*a_435radius,  &_radius);
#endif
    a -> set_null ();
    attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_436semi_angle,  &_semi_angle);
#else
    a = new STEPattribute(*a_436semi_angle,  &_semi_angle);
#endif
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dim");
}
SdaiConical_surface::SdaiConical_surface (SdaiConical_surface& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiConical_surface::~SdaiConical_surface () {  }

#ifdef __OSTORE__

void
SdaiConical_surface::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConical_surface: virtual access function." << endl;
    SdaiConical_surface_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiConical_surface_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiConical_surface: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiConical_surface *ent = (SdaiConical_surface *)sent;
//    SdaiConical_surface *ent = (SdaiConical_surface *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_conical_surface;
    ent->attributes[2].aDesc = a_435radius;
    ent->attributes[3].aDesc = a_436semi_angle;
}

SCLP23(Application_instance_ptr)
create_SdaiConical_surface(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiConical_surface::get_os_typespec())
                                   SdaiConical_surface;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiConical_surface::get_os_typespec())
//                                   SdaiConical_surface;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiConical_surface;
}
#endif

#ifdef __O3DB__
void
SdaiConical_surface::oodb_reInit ()
{	eDesc = config_control_designe_conical_surface;
	attributes [2].aDesc = a_435radius;
	attributes [3].aDesc = a_436semi_angle;
}
#endif

SdaiConical_surface::SdaiConical_surface (SCLP23(Application_instance) *se, int *addAttrs) : SdaiElementary_surface(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conical_surface;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_435radius,  &_radius);
#else
    STEPattribute *a = new STEPattribute(*a_435radius,  &_radius);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);

#ifdef __OSTORE__
    a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_436semi_angle,  &_semi_angle);
#else
    a = new STEPattribute(*a_436semi_angle,  &_semi_angle);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
    MakeDerived ("dim");
}

const SdaiLength_measure
SdaiConical_surface::radius_() const
{
    return (const SdaiLength_measure) _radius;
}

void
SdaiConical_surface::radius_ (const SdaiLength_measure x)

{
    _radius = x;
}

const SdaiPlane_angle_measure
SdaiConical_surface::semi_angle_() const
{
    return (const SdaiPlane_angle_measure) _semi_angle;
}

void
SdaiConical_surface::semi_angle_ (const SdaiPlane_angle_measure x)

{
    _semi_angle = x;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY conical_surface


/////////	 ENTITY global_unit_assigned_context

EntityDescriptor *config_control_designe_global_unit_assigned_context =0;
AttrDescriptor *a_437units =0;
SdaiGlobal_unit_assigned_context::SdaiGlobal_unit_assigned_context( )
{

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_global_unit_assigned_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_437units,  &_units);
#else
    STEPattribute *a = new STEPattribute(*a_437units,  &_units);
#endif
    a -> set_null ();
    attributes.push (a);
}
SdaiGlobal_unit_assigned_context::SdaiGlobal_unit_assigned_context (SdaiGlobal_unit_assigned_context& e )
	{  CopyAs((SCLP23(Application_instance_ptr)) &e);	}
SdaiGlobal_unit_assigned_context::~SdaiGlobal_unit_assigned_context () {  }

#ifdef __OSTORE__

void
SdaiGlobal_unit_assigned_context::Access_hook_in(void *object,
				enum os_access_reason reason, void *user_data,
				void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGlobal_unit_assigned_context: virtual access function." << endl;
    SdaiGlobal_unit_assigned_context_access_hook_in(object, reason, user_data, start_range, end_range);
}

void
SdaiGlobal_unit_assigned_context_access_hook_in(void *object,
	enum os_access_reason reason, void *user_data,
	void *start_range, void *end_range)
{
    if(debug_access_hooks)
        cout << "SdaiGlobal_unit_assigned_context: non-virtual access function." << endl;
    SCLP23(Application_instance) *sent = (SCLP23(Application_instance) *)object;
    if(debug_access_hooks)
        cout << "STEPfile_id: " << sent->STEPfile_id << endl;
    SdaiGlobal_unit_assigned_context *ent = (SdaiGlobal_unit_assigned_context *)sent;
//    SdaiGlobal_unit_assigned_context *ent = (SdaiGlobal_unit_assigned_context *)object;
    if(ent->eDesc == 0)
        ent->eDesc = config_control_designe_global_unit_assigned_context;
    ent->attributes[2].aDesc = a_437units;
}

SCLP23(Application_instance_ptr)
create_SdaiGlobal_unit_assigned_context(os_database *db)
{
    if(db)
    {
        SCLP23(DAObject_ptr) ap = new (db, SdaiGlobal_unit_assigned_context::get_os_typespec())
                                   SdaiGlobal_unit_assigned_context;
        return (SCLP23(Application_instance_ptr)) ap;
//        return (SCLP23(Application_instance_ptr)) new (db, SdaiGlobal_unit_assigned_context::get_os_typespec())
//                                   SdaiGlobal_unit_assigned_context;
    }
    else
        return (SCLP23(Application_instance_ptr)) new SdaiGlobal_unit_assigned_context;
}
#endif

#ifdef __O3DB__
void
SdaiGlobal_unit_assigned_context::oodb_reInit ()
{	eDesc = config_control_designe_global_unit_assigned_context;
	attributes [2].aDesc = a_437units;
}
#endif

SdaiGlobal_unit_assigned_context::SdaiGlobal_unit_assigned_context (SCLP23(Application_instance) *se, int *addAttrs) : SdaiRepresentation_context(se, (addAttrs ? &addAttrs[1] : 0))
{
	/* Set this to point to the head entity. */
    HeadEntity(se);

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_global_unit_assigned_context;

#ifdef __OSTORE__
    STEPattribute *a = new (os_segment::of(this),
			    STEPattribute::get_os_typespec())
				STEPattribute(*a_437units,  &_units);
#else
    STEPattribute *a = new STEPattribute(*a_437units,  &_units);
#endif
    a -> set_null ();
	/* Put attribute on this class' attributes list so the */
	/*access functions still work. */
    attributes.push (a);
	/* Put attribute on the attributes list for the */
	/* main inheritance heirarchy. */
    if(!addAttrs || addAttrs[0])
        se->attributes.push (a);
}

const SdaiUnits_ptr
SdaiGlobal_unit_assigned_context::units_() const
{
    return (SdaiUnits_ptr) &_units;
}

void
SdaiGlobal_unit_assigned_context::units_ (const SdaiUnits_ptr x)

	{ _units.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY global_unit_assigned_context


#ifdef __OSTORE__
SCLP23(Model_contents_ptr) create_SdaiModel_contents_config_control_design(os_database *db)
{
    if(db)
	return (SCLP23(Model_contents_ptr)) new (db, SdaiModel_contents_config_control_design::get_os_typespec())
			SdaiModel_contents_config_control_design(db);
    else{
	return (SCLP23(Model_contents_ptr)) new SdaiModel_contents_config_control_design(0);
    }
}
#else

SCLP23(Model_contents_ptr) create_SdaiModel_contents_config_control_design()
{ return new SdaiModel_contents_config_control_design ; }
#endif


#ifdef __OSTORE__
SdaiModel_contents_config_control_design::SdaiModel_contents_config_control_design(os_database *db)
#else
SdaiModel_contents_config_control_design::SdaiModel_contents_config_control_design()
#endif
{
    SCLP23(Entity_extent_ptr) eep = (SCLP23(Entity_extent_ptr))0;

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_representation_item);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_geometric_representation_item);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_functionally_defined_transformation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_cartesian_transformation_operator);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_cartesian_transformation_operator_3d);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_versioned_action_request);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_shape_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_manifold_surface_shape_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_certification);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_definition_relationship);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_definition_usage);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_assembly_component_usage);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_quantified_assembly_component_usage);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_solid_model);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_manifold_solid_brep);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_faceted_brep);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_action_directive);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_named_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_plane_angle_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_measure_with_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_area_measure_with_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_effectivity);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_serial_numbered_effectivity);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_offset_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_placement);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_axis2_placement_2d);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_category);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_related_product_category);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_conic);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_hyperbola);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_address);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_organizational_address);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_bounded_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_b_spline_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_uniform_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_geometrically_bounded_surface_shape_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_axis1_placement);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_bounded_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_b_spline_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_rational_b_spline_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_action_request_assignment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_topological_representation_item);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_face_bound);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_length_measure_with_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_dated_effectivity);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_direction);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_next_assembly_usage_occurrence);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_edge);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_oriented_edge);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_person);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_document);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_document_with_class);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_conversion_based_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_point);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_point_on_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_definition_formation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_person_and_organization_assignment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_cc_design_person_and_organization_assignment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_offset_curve_3d);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_approval);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_composite_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_composite_curve_on_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_boundary_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_representation_context);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_geometric_representation_context);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_action_status);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_application_context);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_change_request);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_date_and_time);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_approval_date_time);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_approval_role);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_application_context_element);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_context);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_elementary_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_spherical_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_application_protocol_definition);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_specified_higher_usage_occurrence);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_definition_formation_with_specified_source);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_action_request_solution);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_uncertainty_measure_with_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_edge_based_wireframe_model);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_path);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_connected_face_set);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_open_shell);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_oriented_open_shell);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_solid_angle_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_coordinated_universal_time_offset);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_curve_replica);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_quasi_uniform_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_surface_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_action_request_status);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_founded_item);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_composite_curve_segment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_reparametrised_composite_curve_segment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_representation_relationship);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_representation_relationship_with_transformation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_person_and_organization_role);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_quasi_uniform_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_swept_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_property_definition);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_global_uncertainty_assigned_context);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_organization_relationship);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_parabola);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_rectangular_composite_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_lot_effectivity);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_surface_of_linear_extrusion);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_shell_based_surface_model);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_uniform_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_bezier_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_loop);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_edge_loop);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_date);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_calendar_date);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_toroidal_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_promissory_usage_occurrence);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_approval_assignment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_configuration_item);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_contract_assignment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_vector);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_pcurve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_bounded_pcurve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_intersection_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_trimmed_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_definition_context);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_bounded_surface_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_item_defined_transformation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_action_method);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_category_relationship);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_plane_angle_measure_with_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_vertex);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_representation_map);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_definition_effectivity);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_configuration_effectivity);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_ellipse);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_context_dependent_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_alternate_product_relationship);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_document_type);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_document_reference);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_mechanical_context);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_shell_based_wireframe_model);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_contract);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_dimensional_exponents);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_start_request);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_cc_design_specification_reference);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_supplied_part_relationship);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_context_dependent_shape_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_degenerate_toroidal_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_ordinal_date);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_face_outer_bound);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_mass_measure_with_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_brep_with_voids);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_week_of_year_and_day_date);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_point_on_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_shell_based_wireframe_shape_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_face);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_face_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_oriented_face);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_surface_of_revolution);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_advanced_brep_shape_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_edge_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_point_replica);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_shape_aspect_relationship);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_rectangular_trimmed_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_plane);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_action_assignment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_change);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_circle);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_line);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_property_definition_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_geometric_set);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_geometric_curve_set);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_personal_address);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_document_relationship);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_outer_boundary_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_shape_representation_relationship);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_assembly_component_usage_substitute);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_degenerate_pcurve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_evaluated_degenerate_pcurve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_solid_angle_measure_with_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_connected_edge_set);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_action);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_executed_action);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_directed_action);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_organizational_project);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_date_time_role);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_curve_bounded_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_closed_shell);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_design_make_from_relationship);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_definitional_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_definition_shape);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_si_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_bezier_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_certification_assignment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_start_work);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_contract_type);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_b_spline_curve_with_knots);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_cc_design_approval);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_edge_based_wireframe_shape_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_geometrically_bounded_wireframe_shape_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_concept);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_cc_design_contract);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_seam_curve);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_axis2_placement_3d);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_rational_b_spline_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_configuration_design);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_design_context);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_definition);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_definition_with_associated_documents);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_organization);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_cc_design_certification);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_b_spline_surface_with_knots);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_certification_type);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_oriented_path);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_security_classification);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_vertex_loop);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_approval_status);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_cartesian_point);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_date_and_time_assignment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_parametric_representation_context);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_product_concept_context);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_surface_patch);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_length_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_shape_aspect);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_volume_measure_with_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_advanced_face);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_security_classification_level);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_approval_relationship);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_polyline);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_approval_person_organization);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_surface_replica);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_security_classification_assignment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_cc_design_security_classification);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_faceted_brep_shape_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_document_usage_constraint);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_vertex_point);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_cc_design_date_and_time_assignment);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_oriented_closed_shell);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_person_and_organization);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_cylindrical_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_local_time);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_mass_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_vertex_shell);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_poly_loop);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_wire_shell);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_area_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_mapped_item);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_shape_definition_representation);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_volume_unit);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_conical_surface);
    _folders.Append(eep);

#ifdef __OSTORE__
    if(db)
        eep = new (db,
              SCLP23(Entity_extent)::get_os_typespec()) SCLP23(Entity_extent);
    else
        eep = new SCLP23(Entity_extent);
#else
        eep = new SCLP23(Entity_extent);
#endif
    eep->definition_(config_control_designe_global_unit_assigned_context);
    _folders.Append(eep);

}

SdaiRepresentation_item__set_var SdaiModel_contents_config_control_design::SdaiRepresentation_item_get_extents()
{
    return (SdaiRepresentation_item__set_var)((_folders.retrieve(0))->instances_());
}

SdaiGeometric_representation_item__set_var SdaiModel_contents_config_control_design::SdaiGeometric_representation_item_get_extents()
{
    return (SdaiGeometric_representation_item__set_var)((_folders.retrieve(1))->instances_());
}

SdaiFunctionally_defined_transformation__set_var SdaiModel_contents_config_control_design::SdaiFunctionally_defined_transformation_get_extents()
{
    return (SdaiFunctionally_defined_transformation__set_var)((_folders.retrieve(2))->instances_());
}

SdaiCartesian_transformation_operator__set_var SdaiModel_contents_config_control_design::SdaiCartesian_transformation_operator_get_extents()
{
    return (SdaiCartesian_transformation_operator__set_var)((_folders.retrieve(3))->instances_());
}

SdaiCartesian_transformation_operator_3d__set_var SdaiModel_contents_config_control_design::SdaiCartesian_transformation_operator_3d_get_extents()
{
    return (SdaiCartesian_transformation_operator_3d__set_var)((_folders.retrieve(4))->instances_());
}

SdaiVersioned_action_request__set_var SdaiModel_contents_config_control_design::SdaiVersioned_action_request_get_extents()
{
    return (SdaiVersioned_action_request__set_var)((_folders.retrieve(5))->instances_());
}

SdaiRepresentation__set_var SdaiModel_contents_config_control_design::SdaiRepresentation_get_extents()
{
    return (SdaiRepresentation__set_var)((_folders.retrieve(6))->instances_());
}

SdaiShape_representation__set_var SdaiModel_contents_config_control_design::SdaiShape_representation_get_extents()
{
    return (SdaiShape_representation__set_var)((_folders.retrieve(7))->instances_());
}

SdaiManifold_surface_shape_representation__set_var SdaiModel_contents_config_control_design::SdaiManifold_surface_shape_representation_get_extents()
{
    return (SdaiManifold_surface_shape_representation__set_var)((_folders.retrieve(8))->instances_());
}

SdaiCertification__set_var SdaiModel_contents_config_control_design::SdaiCertification_get_extents()
{
    return (SdaiCertification__set_var)((_folders.retrieve(9))->instances_());
}

SdaiProduct_definition_relationship__set_var SdaiModel_contents_config_control_design::SdaiProduct_definition_relationship_get_extents()
{
    return (SdaiProduct_definition_relationship__set_var)((_folders.retrieve(10))->instances_());
}

SdaiProduct_definition_usage__set_var SdaiModel_contents_config_control_design::SdaiProduct_definition_usage_get_extents()
{
    return (SdaiProduct_definition_usage__set_var)((_folders.retrieve(11))->instances_());
}

SdaiAssembly_component_usage__set_var SdaiModel_contents_config_control_design::SdaiAssembly_component_usage_get_extents()
{
    return (SdaiAssembly_component_usage__set_var)((_folders.retrieve(12))->instances_());
}

SdaiQuantified_assembly_component_usage__set_var SdaiModel_contents_config_control_design::SdaiQuantified_assembly_component_usage_get_extents()
{
    return (SdaiQuantified_assembly_component_usage__set_var)((_folders.retrieve(13))->instances_());
}

SdaiSolid_model__set_var SdaiModel_contents_config_control_design::SdaiSolid_model_get_extents()
{
    return (SdaiSolid_model__set_var)((_folders.retrieve(14))->instances_());
}

SdaiManifold_solid_brep__set_var SdaiModel_contents_config_control_design::SdaiManifold_solid_brep_get_extents()
{
    return (SdaiManifold_solid_brep__set_var)((_folders.retrieve(15))->instances_());
}

SdaiFaceted_brep__set_var SdaiModel_contents_config_control_design::SdaiFaceted_brep_get_extents()
{
    return (SdaiFaceted_brep__set_var)((_folders.retrieve(16))->instances_());
}

SdaiAction_directive__set_var SdaiModel_contents_config_control_design::SdaiAction_directive_get_extents()
{
    return (SdaiAction_directive__set_var)((_folders.retrieve(17))->instances_());
}

SdaiNamed_unit__set_var SdaiModel_contents_config_control_design::SdaiNamed_unit_get_extents()
{
    return (SdaiNamed_unit__set_var)((_folders.retrieve(18))->instances_());
}

SdaiPlane_angle_unit__set_var SdaiModel_contents_config_control_design::SdaiPlane_angle_unit_get_extents()
{
    return (SdaiPlane_angle_unit__set_var)((_folders.retrieve(19))->instances_());
}

SdaiMeasure_with_unit__set_var SdaiModel_contents_config_control_design::SdaiMeasure_with_unit_get_extents()
{
    return (SdaiMeasure_with_unit__set_var)((_folders.retrieve(20))->instances_());
}

SdaiArea_measure_with_unit__set_var SdaiModel_contents_config_control_design::SdaiArea_measure_with_unit_get_extents()
{
    return (SdaiArea_measure_with_unit__set_var)((_folders.retrieve(21))->instances_());
}

SdaiEffectivity__set_var SdaiModel_contents_config_control_design::SdaiEffectivity_get_extents()
{
    return (SdaiEffectivity__set_var)((_folders.retrieve(22))->instances_());
}

SdaiSerial_numbered_effectivity__set_var SdaiModel_contents_config_control_design::SdaiSerial_numbered_effectivity_get_extents()
{
    return (SdaiSerial_numbered_effectivity__set_var)((_folders.retrieve(23))->instances_());
}

SdaiSurface__set_var SdaiModel_contents_config_control_design::SdaiSurface_get_extents()
{
    return (SdaiSurface__set_var)((_folders.retrieve(24))->instances_());
}

SdaiOffset_surface__set_var SdaiModel_contents_config_control_design::SdaiOffset_surface_get_extents()
{
    return (SdaiOffset_surface__set_var)((_folders.retrieve(25))->instances_());
}

SdaiPlacement__set_var SdaiModel_contents_config_control_design::SdaiPlacement_get_extents()
{
    return (SdaiPlacement__set_var)((_folders.retrieve(26))->instances_());
}

SdaiAxis2_placement_2d__set_var SdaiModel_contents_config_control_design::SdaiAxis2_placement_2d_get_extents()
{
    return (SdaiAxis2_placement_2d__set_var)((_folders.retrieve(27))->instances_());
}

SdaiProduct_category__set_var SdaiModel_contents_config_control_design::SdaiProduct_category_get_extents()
{
    return (SdaiProduct_category__set_var)((_folders.retrieve(28))->instances_());
}

SdaiProduct_related_product_category__set_var SdaiModel_contents_config_control_design::SdaiProduct_related_product_category_get_extents()
{
    return (SdaiProduct_related_product_category__set_var)((_folders.retrieve(29))->instances_());
}

SdaiCurve__set_var SdaiModel_contents_config_control_design::SdaiCurve_get_extents()
{
    return (SdaiCurve__set_var)((_folders.retrieve(30))->instances_());
}

SdaiConic__set_var SdaiModel_contents_config_control_design::SdaiConic_get_extents()
{
    return (SdaiConic__set_var)((_folders.retrieve(31))->instances_());
}

SdaiHyperbola__set_var SdaiModel_contents_config_control_design::SdaiHyperbola_get_extents()
{
    return (SdaiHyperbola__set_var)((_folders.retrieve(32))->instances_());
}

SdaiAddress__set_var SdaiModel_contents_config_control_design::SdaiAddress_get_extents()
{
    return (SdaiAddress__set_var)((_folders.retrieve(33))->instances_());
}

SdaiOrganizational_address__set_var SdaiModel_contents_config_control_design::SdaiOrganizational_address_get_extents()
{
    return (SdaiOrganizational_address__set_var)((_folders.retrieve(34))->instances_());
}

SdaiBounded_surface__set_var SdaiModel_contents_config_control_design::SdaiBounded_surface_get_extents()
{
    return (SdaiBounded_surface__set_var)((_folders.retrieve(35))->instances_());
}

SdaiB_spline_surface__set_var SdaiModel_contents_config_control_design::SdaiB_spline_surface_get_extents()
{
    return (SdaiB_spline_surface__set_var)((_folders.retrieve(36))->instances_());
}

SdaiUniform_surface__set_var SdaiModel_contents_config_control_design::SdaiUniform_surface_get_extents()
{
    return (SdaiUniform_surface__set_var)((_folders.retrieve(37))->instances_());
}

SdaiGeometrically_bounded_surface_shape_representation__set_var SdaiModel_contents_config_control_design::SdaiGeometrically_bounded_surface_shape_representation_get_extents()
{
    return (SdaiGeometrically_bounded_surface_shape_representation__set_var)((_folders.retrieve(38))->instances_());
}

SdaiAxis1_placement__set_var SdaiModel_contents_config_control_design::SdaiAxis1_placement_get_extents()
{
    return (SdaiAxis1_placement__set_var)((_folders.retrieve(39))->instances_());
}

SdaiBounded_curve__set_var SdaiModel_contents_config_control_design::SdaiBounded_curve_get_extents()
{
    return (SdaiBounded_curve__set_var)((_folders.retrieve(40))->instances_());
}

SdaiB_spline_curve__set_var SdaiModel_contents_config_control_design::SdaiB_spline_curve_get_extents()
{
    return (SdaiB_spline_curve__set_var)((_folders.retrieve(41))->instances_());
}

SdaiRational_b_spline_curve__set_var SdaiModel_contents_config_control_design::SdaiRational_b_spline_curve_get_extents()
{
    return (SdaiRational_b_spline_curve__set_var)((_folders.retrieve(42))->instances_());
}

SdaiAction_request_assignment__set_var SdaiModel_contents_config_control_design::SdaiAction_request_assignment_get_extents()
{
    return (SdaiAction_request_assignment__set_var)((_folders.retrieve(43))->instances_());
}

SdaiTopological_representation_item__set_var SdaiModel_contents_config_control_design::SdaiTopological_representation_item_get_extents()
{
    return (SdaiTopological_representation_item__set_var)((_folders.retrieve(44))->instances_());
}

SdaiFace_bound__set_var SdaiModel_contents_config_control_design::SdaiFace_bound_get_extents()
{
    return (SdaiFace_bound__set_var)((_folders.retrieve(45))->instances_());
}

SdaiLength_measure_with_unit__set_var SdaiModel_contents_config_control_design::SdaiLength_measure_with_unit_get_extents()
{
    return (SdaiLength_measure_with_unit__set_var)((_folders.retrieve(46))->instances_());
}

SdaiDated_effectivity__set_var SdaiModel_contents_config_control_design::SdaiDated_effectivity_get_extents()
{
    return (SdaiDated_effectivity__set_var)((_folders.retrieve(47))->instances_());
}

SdaiDirection__set_var SdaiModel_contents_config_control_design::SdaiDirection_get_extents()
{
    return (SdaiDirection__set_var)((_folders.retrieve(48))->instances_());
}

SdaiNext_assembly_usage_occurrence__set_var SdaiModel_contents_config_control_design::SdaiNext_assembly_usage_occurrence_get_extents()
{
    return (SdaiNext_assembly_usage_occurrence__set_var)((_folders.retrieve(49))->instances_());
}

SdaiEdge__set_var SdaiModel_contents_config_control_design::SdaiEdge_get_extents()
{
    return (SdaiEdge__set_var)((_folders.retrieve(50))->instances_());
}

SdaiOriented_edge__set_var SdaiModel_contents_config_control_design::SdaiOriented_edge_get_extents()
{
    return (SdaiOriented_edge__set_var)((_folders.retrieve(51))->instances_());
}

SdaiPerson__set_var SdaiModel_contents_config_control_design::SdaiPerson_get_extents()
{
    return (SdaiPerson__set_var)((_folders.retrieve(52))->instances_());
}

SdaiDocument__set_var SdaiModel_contents_config_control_design::SdaiDocument_get_extents()
{
    return (SdaiDocument__set_var)((_folders.retrieve(53))->instances_());
}

SdaiDocument_with_class__set_var SdaiModel_contents_config_control_design::SdaiDocument_with_class_get_extents()
{
    return (SdaiDocument_with_class__set_var)((_folders.retrieve(54))->instances_());
}

SdaiConversion_based_unit__set_var SdaiModel_contents_config_control_design::SdaiConversion_based_unit_get_extents()
{
    return (SdaiConversion_based_unit__set_var)((_folders.retrieve(55))->instances_());
}

SdaiPoint__set_var SdaiModel_contents_config_control_design::SdaiPoint_get_extents()
{
    return (SdaiPoint__set_var)((_folders.retrieve(56))->instances_());
}

SdaiPoint_on_surface__set_var SdaiModel_contents_config_control_design::SdaiPoint_on_surface_get_extents()
{
    return (SdaiPoint_on_surface__set_var)((_folders.retrieve(57))->instances_());
}

SdaiProduct_definition_formation__set_var SdaiModel_contents_config_control_design::SdaiProduct_definition_formation_get_extents()
{
    return (SdaiProduct_definition_formation__set_var)((_folders.retrieve(58))->instances_());
}

SdaiPerson_and_organization_assignment__set_var SdaiModel_contents_config_control_design::SdaiPerson_and_organization_assignment_get_extents()
{
    return (SdaiPerson_and_organization_assignment__set_var)((_folders.retrieve(59))->instances_());
}

SdaiCc_design_person_and_organization_assignment__set_var SdaiModel_contents_config_control_design::SdaiCc_design_person_and_organization_assignment_get_extents()
{
    return (SdaiCc_design_person_and_organization_assignment__set_var)((_folders.retrieve(60))->instances_());
}

SdaiOffset_curve_3d__set_var SdaiModel_contents_config_control_design::SdaiOffset_curve_3d_get_extents()
{
    return (SdaiOffset_curve_3d__set_var)((_folders.retrieve(61))->instances_());
}

SdaiApproval__set_var SdaiModel_contents_config_control_design::SdaiApproval_get_extents()
{
    return (SdaiApproval__set_var)((_folders.retrieve(62))->instances_());
}

SdaiComposite_curve__set_var SdaiModel_contents_config_control_design::SdaiComposite_curve_get_extents()
{
    return (SdaiComposite_curve__set_var)((_folders.retrieve(63))->instances_());
}

SdaiComposite_curve_on_surface__set_var SdaiModel_contents_config_control_design::SdaiComposite_curve_on_surface_get_extents()
{
    return (SdaiComposite_curve_on_surface__set_var)((_folders.retrieve(64))->instances_());
}

SdaiBoundary_curve__set_var SdaiModel_contents_config_control_design::SdaiBoundary_curve_get_extents()
{
    return (SdaiBoundary_curve__set_var)((_folders.retrieve(65))->instances_());
}

SdaiRepresentation_context__set_var SdaiModel_contents_config_control_design::SdaiRepresentation_context_get_extents()
{
    return (SdaiRepresentation_context__set_var)((_folders.retrieve(66))->instances_());
}

SdaiGeometric_representation_context__set_var SdaiModel_contents_config_control_design::SdaiGeometric_representation_context_get_extents()
{
    return (SdaiGeometric_representation_context__set_var)((_folders.retrieve(67))->instances_());
}

SdaiAction_status__set_var SdaiModel_contents_config_control_design::SdaiAction_status_get_extents()
{
    return (SdaiAction_status__set_var)((_folders.retrieve(68))->instances_());
}

SdaiApplication_context__set_var SdaiModel_contents_config_control_design::SdaiApplication_context_get_extents()
{
    return (SdaiApplication_context__set_var)((_folders.retrieve(69))->instances_());
}

SdaiChange_request__set_var SdaiModel_contents_config_control_design::SdaiChange_request_get_extents()
{
    return (SdaiChange_request__set_var)((_folders.retrieve(70))->instances_());
}

SdaiDate_and_time__set_var SdaiModel_contents_config_control_design::SdaiDate_and_time_get_extents()
{
    return (SdaiDate_and_time__set_var)((_folders.retrieve(71))->instances_());
}

SdaiApproval_date_time__set_var SdaiModel_contents_config_control_design::SdaiApproval_date_time_get_extents()
{
    return (SdaiApproval_date_time__set_var)((_folders.retrieve(72))->instances_());
}

SdaiApproval_role__set_var SdaiModel_contents_config_control_design::SdaiApproval_role_get_extents()
{
    return (SdaiApproval_role__set_var)((_folders.retrieve(73))->instances_());
}

SdaiApplication_context_element__set_var SdaiModel_contents_config_control_design::SdaiApplication_context_element_get_extents()
{
    return (SdaiApplication_context_element__set_var)((_folders.retrieve(74))->instances_());
}

SdaiProduct_context__set_var SdaiModel_contents_config_control_design::SdaiProduct_context_get_extents()
{
    return (SdaiProduct_context__set_var)((_folders.retrieve(75))->instances_());
}

SdaiElementary_surface__set_var SdaiModel_contents_config_control_design::SdaiElementary_surface_get_extents()
{
    return (SdaiElementary_surface__set_var)((_folders.retrieve(76))->instances_());
}

SdaiSpherical_surface__set_var SdaiModel_contents_config_control_design::SdaiSpherical_surface_get_extents()
{
    return (SdaiSpherical_surface__set_var)((_folders.retrieve(77))->instances_());
}

SdaiApplication_protocol_definition__set_var SdaiModel_contents_config_control_design::SdaiApplication_protocol_definition_get_extents()
{
    return (SdaiApplication_protocol_definition__set_var)((_folders.retrieve(78))->instances_());
}

SdaiSpecified_higher_usage_occurrence__set_var SdaiModel_contents_config_control_design::SdaiSpecified_higher_usage_occurrence_get_extents()
{
    return (SdaiSpecified_higher_usage_occurrence__set_var)((_folders.retrieve(79))->instances_());
}

SdaiProduct_definition_formation_with_specified_source__set_var SdaiModel_contents_config_control_design::SdaiProduct_definition_formation_with_specified_source_get_extents()
{
    return (SdaiProduct_definition_formation_with_specified_source__set_var)((_folders.retrieve(80))->instances_());
}

SdaiAction_request_solution__set_var SdaiModel_contents_config_control_design::SdaiAction_request_solution_get_extents()
{
    return (SdaiAction_request_solution__set_var)((_folders.retrieve(81))->instances_());
}

SdaiUncertainty_measure_with_unit__set_var SdaiModel_contents_config_control_design::SdaiUncertainty_measure_with_unit_get_extents()
{
    return (SdaiUncertainty_measure_with_unit__set_var)((_folders.retrieve(82))->instances_());
}

SdaiEdge_based_wireframe_model__set_var SdaiModel_contents_config_control_design::SdaiEdge_based_wireframe_model_get_extents()
{
    return (SdaiEdge_based_wireframe_model__set_var)((_folders.retrieve(83))->instances_());
}

SdaiPath__set_var SdaiModel_contents_config_control_design::SdaiPath_get_extents()
{
    return (SdaiPath__set_var)((_folders.retrieve(84))->instances_());
}

SdaiConnected_face_set__set_var SdaiModel_contents_config_control_design::SdaiConnected_face_set_get_extents()
{
    return (SdaiConnected_face_set__set_var)((_folders.retrieve(85))->instances_());
}

SdaiOpen_shell__set_var SdaiModel_contents_config_control_design::SdaiOpen_shell_get_extents()
{
    return (SdaiOpen_shell__set_var)((_folders.retrieve(86))->instances_());
}

SdaiOriented_open_shell__set_var SdaiModel_contents_config_control_design::SdaiOriented_open_shell_get_extents()
{
    return (SdaiOriented_open_shell__set_var)((_folders.retrieve(87))->instances_());
}

SdaiSolid_angle_unit__set_var SdaiModel_contents_config_control_design::SdaiSolid_angle_unit_get_extents()
{
    return (SdaiSolid_angle_unit__set_var)((_folders.retrieve(88))->instances_());
}

SdaiCoordinated_universal_time_offset__set_var SdaiModel_contents_config_control_design::SdaiCoordinated_universal_time_offset_get_extents()
{
    return (SdaiCoordinated_universal_time_offset__set_var)((_folders.retrieve(89))->instances_());
}

SdaiCurve_replica__set_var SdaiModel_contents_config_control_design::SdaiCurve_replica_get_extents()
{
    return (SdaiCurve_replica__set_var)((_folders.retrieve(90))->instances_());
}

SdaiQuasi_uniform_surface__set_var SdaiModel_contents_config_control_design::SdaiQuasi_uniform_surface_get_extents()
{
    return (SdaiQuasi_uniform_surface__set_var)((_folders.retrieve(91))->instances_());
}

SdaiSurface_curve__set_var SdaiModel_contents_config_control_design::SdaiSurface_curve_get_extents()
{
    return (SdaiSurface_curve__set_var)((_folders.retrieve(92))->instances_());
}

SdaiAction_request_status__set_var SdaiModel_contents_config_control_design::SdaiAction_request_status_get_extents()
{
    return (SdaiAction_request_status__set_var)((_folders.retrieve(93))->instances_());
}

SdaiFounded_item__set_var SdaiModel_contents_config_control_design::SdaiFounded_item_get_extents()
{
    return (SdaiFounded_item__set_var)((_folders.retrieve(94))->instances_());
}

SdaiComposite_curve_segment__set_var SdaiModel_contents_config_control_design::SdaiComposite_curve_segment_get_extents()
{
    return (SdaiComposite_curve_segment__set_var)((_folders.retrieve(95))->instances_());
}

SdaiReparametrised_composite_curve_segment__set_var SdaiModel_contents_config_control_design::SdaiReparametrised_composite_curve_segment_get_extents()
{
    return (SdaiReparametrised_composite_curve_segment__set_var)((_folders.retrieve(96))->instances_());
}

SdaiRepresentation_relationship__set_var SdaiModel_contents_config_control_design::SdaiRepresentation_relationship_get_extents()
{
    return (SdaiRepresentation_relationship__set_var)((_folders.retrieve(97))->instances_());
}

SdaiRepresentation_relationship_with_transformation__set_var SdaiModel_contents_config_control_design::SdaiRepresentation_relationship_with_transformation_get_extents()
{
    return (SdaiRepresentation_relationship_with_transformation__set_var)((_folders.retrieve(98))->instances_());
}

SdaiPerson_and_organization_role__set_var SdaiModel_contents_config_control_design::SdaiPerson_and_organization_role_get_extents()
{
    return (SdaiPerson_and_organization_role__set_var)((_folders.retrieve(99))->instances_());
}

SdaiQuasi_uniform_curve__set_var SdaiModel_contents_config_control_design::SdaiQuasi_uniform_curve_get_extents()
{
    return (SdaiQuasi_uniform_curve__set_var)((_folders.retrieve(100))->instances_());
}

SdaiSwept_surface__set_var SdaiModel_contents_config_control_design::SdaiSwept_surface_get_extents()
{
    return (SdaiSwept_surface__set_var)((_folders.retrieve(101))->instances_());
}

SdaiProperty_definition__set_var SdaiModel_contents_config_control_design::SdaiProperty_definition_get_extents()
{
    return (SdaiProperty_definition__set_var)((_folders.retrieve(102))->instances_());
}

SdaiGlobal_uncertainty_assigned_context__set_var SdaiModel_contents_config_control_design::SdaiGlobal_uncertainty_assigned_context_get_extents()
{
    return (SdaiGlobal_uncertainty_assigned_context__set_var)((_folders.retrieve(103))->instances_());
}

SdaiOrganization_relationship__set_var SdaiModel_contents_config_control_design::SdaiOrganization_relationship_get_extents()
{
    return (SdaiOrganization_relationship__set_var)((_folders.retrieve(104))->instances_());
}

SdaiParabola__set_var SdaiModel_contents_config_control_design::SdaiParabola_get_extents()
{
    return (SdaiParabola__set_var)((_folders.retrieve(105))->instances_());
}

SdaiRectangular_composite_surface__set_var SdaiModel_contents_config_control_design::SdaiRectangular_composite_surface_get_extents()
{
    return (SdaiRectangular_composite_surface__set_var)((_folders.retrieve(106))->instances_());
}

SdaiLot_effectivity__set_var SdaiModel_contents_config_control_design::SdaiLot_effectivity_get_extents()
{
    return (SdaiLot_effectivity__set_var)((_folders.retrieve(107))->instances_());
}

SdaiSurface_of_linear_extrusion__set_var SdaiModel_contents_config_control_design::SdaiSurface_of_linear_extrusion_get_extents()
{
    return (SdaiSurface_of_linear_extrusion__set_var)((_folders.retrieve(108))->instances_());
}

SdaiShell_based_surface_model__set_var SdaiModel_contents_config_control_design::SdaiShell_based_surface_model_get_extents()
{
    return (SdaiShell_based_surface_model__set_var)((_folders.retrieve(109))->instances_());
}

SdaiUniform_curve__set_var SdaiModel_contents_config_control_design::SdaiUniform_curve_get_extents()
{
    return (SdaiUniform_curve__set_var)((_folders.retrieve(110))->instances_());
}

SdaiBezier_curve__set_var SdaiModel_contents_config_control_design::SdaiBezier_curve_get_extents()
{
    return (SdaiBezier_curve__set_var)((_folders.retrieve(111))->instances_());
}

SdaiLoop__set_var SdaiModel_contents_config_control_design::SdaiLoop_get_extents()
{
    return (SdaiLoop__set_var)((_folders.retrieve(112))->instances_());
}

SdaiEdge_loop__set_var SdaiModel_contents_config_control_design::SdaiEdge_loop_get_extents()
{
    return (SdaiEdge_loop__set_var)((_folders.retrieve(113))->instances_());
}

SdaiDate__set_var SdaiModel_contents_config_control_design::SdaiDate_get_extents()
{
    return (SdaiDate__set_var)((_folders.retrieve(114))->instances_());
}

SdaiCalendar_date__set_var SdaiModel_contents_config_control_design::SdaiCalendar_date_get_extents()
{
    return (SdaiCalendar_date__set_var)((_folders.retrieve(115))->instances_());
}

SdaiToroidal_surface__set_var SdaiModel_contents_config_control_design::SdaiToroidal_surface_get_extents()
{
    return (SdaiToroidal_surface__set_var)((_folders.retrieve(116))->instances_());
}

SdaiPromissory_usage_occurrence__set_var SdaiModel_contents_config_control_design::SdaiPromissory_usage_occurrence_get_extents()
{
    return (SdaiPromissory_usage_occurrence__set_var)((_folders.retrieve(117))->instances_());
}

SdaiApproval_assignment__set_var SdaiModel_contents_config_control_design::SdaiApproval_assignment_get_extents()
{
    return (SdaiApproval_assignment__set_var)((_folders.retrieve(118))->instances_());
}

SdaiConfiguration_item__set_var SdaiModel_contents_config_control_design::SdaiConfiguration_item_get_extents()
{
    return (SdaiConfiguration_item__set_var)((_folders.retrieve(119))->instances_());
}

SdaiContract_assignment__set_var SdaiModel_contents_config_control_design::SdaiContract_assignment_get_extents()
{
    return (SdaiContract_assignment__set_var)((_folders.retrieve(120))->instances_());
}

SdaiVector__set_var SdaiModel_contents_config_control_design::SdaiVector_get_extents()
{
    return (SdaiVector__set_var)((_folders.retrieve(121))->instances_());
}

SdaiPcurve__set_var SdaiModel_contents_config_control_design::SdaiPcurve_get_extents()
{
    return (SdaiPcurve__set_var)((_folders.retrieve(122))->instances_());
}

SdaiBounded_pcurve__set_var SdaiModel_contents_config_control_design::SdaiBounded_pcurve_get_extents()
{
    return (SdaiBounded_pcurve__set_var)((_folders.retrieve(123))->instances_());
}

SdaiIntersection_curve__set_var SdaiModel_contents_config_control_design::SdaiIntersection_curve_get_extents()
{
    return (SdaiIntersection_curve__set_var)((_folders.retrieve(124))->instances_());
}

SdaiTrimmed_curve__set_var SdaiModel_contents_config_control_design::SdaiTrimmed_curve_get_extents()
{
    return (SdaiTrimmed_curve__set_var)((_folders.retrieve(125))->instances_());
}

SdaiProduct_definition_context__set_var SdaiModel_contents_config_control_design::SdaiProduct_definition_context_get_extents()
{
    return (SdaiProduct_definition_context__set_var)((_folders.retrieve(126))->instances_());
}

SdaiBounded_surface_curve__set_var SdaiModel_contents_config_control_design::SdaiBounded_surface_curve_get_extents()
{
    return (SdaiBounded_surface_curve__set_var)((_folders.retrieve(127))->instances_());
}

SdaiItem_defined_transformation__set_var SdaiModel_contents_config_control_design::SdaiItem_defined_transformation_get_extents()
{
    return (SdaiItem_defined_transformation__set_var)((_folders.retrieve(128))->instances_());
}

SdaiAction_method__set_var SdaiModel_contents_config_control_design::SdaiAction_method_get_extents()
{
    return (SdaiAction_method__set_var)((_folders.retrieve(129))->instances_());
}

SdaiProduct_category_relationship__set_var SdaiModel_contents_config_control_design::SdaiProduct_category_relationship_get_extents()
{
    return (SdaiProduct_category_relationship__set_var)((_folders.retrieve(130))->instances_());
}

SdaiPlane_angle_measure_with_unit__set_var SdaiModel_contents_config_control_design::SdaiPlane_angle_measure_with_unit_get_extents()
{
    return (SdaiPlane_angle_measure_with_unit__set_var)((_folders.retrieve(131))->instances_());
}

SdaiVertex__set_var SdaiModel_contents_config_control_design::SdaiVertex_get_extents()
{
    return (SdaiVertex__set_var)((_folders.retrieve(132))->instances_());
}

SdaiRepresentation_map__set_var SdaiModel_contents_config_control_design::SdaiRepresentation_map_get_extents()
{
    return (SdaiRepresentation_map__set_var)((_folders.retrieve(133))->instances_());
}

SdaiProduct_definition_effectivity__set_var SdaiModel_contents_config_control_design::SdaiProduct_definition_effectivity_get_extents()
{
    return (SdaiProduct_definition_effectivity__set_var)((_folders.retrieve(134))->instances_());
}

SdaiConfiguration_effectivity__set_var SdaiModel_contents_config_control_design::SdaiConfiguration_effectivity_get_extents()
{
    return (SdaiConfiguration_effectivity__set_var)((_folders.retrieve(135))->instances_());
}

SdaiEllipse__set_var SdaiModel_contents_config_control_design::SdaiEllipse_get_extents()
{
    return (SdaiEllipse__set_var)((_folders.retrieve(136))->instances_());
}

SdaiContext_dependent_unit__set_var SdaiModel_contents_config_control_design::SdaiContext_dependent_unit_get_extents()
{
    return (SdaiContext_dependent_unit__set_var)((_folders.retrieve(137))->instances_());
}

SdaiAlternate_product_relationship__set_var SdaiModel_contents_config_control_design::SdaiAlternate_product_relationship_get_extents()
{
    return (SdaiAlternate_product_relationship__set_var)((_folders.retrieve(138))->instances_());
}

SdaiDocument_type__set_var SdaiModel_contents_config_control_design::SdaiDocument_type_get_extents()
{
    return (SdaiDocument_type__set_var)((_folders.retrieve(139))->instances_());
}

SdaiDocument_reference__set_var SdaiModel_contents_config_control_design::SdaiDocument_reference_get_extents()
{
    return (SdaiDocument_reference__set_var)((_folders.retrieve(140))->instances_());
}

SdaiMechanical_context__set_var SdaiModel_contents_config_control_design::SdaiMechanical_context_get_extents()
{
    return (SdaiMechanical_context__set_var)((_folders.retrieve(141))->instances_());
}

SdaiShell_based_wireframe_model__set_var SdaiModel_contents_config_control_design::SdaiShell_based_wireframe_model_get_extents()
{
    return (SdaiShell_based_wireframe_model__set_var)((_folders.retrieve(142))->instances_());
}

SdaiContract__set_var SdaiModel_contents_config_control_design::SdaiContract_get_extents()
{
    return (SdaiContract__set_var)((_folders.retrieve(143))->instances_());
}

SdaiDimensional_exponents__set_var SdaiModel_contents_config_control_design::SdaiDimensional_exponents_get_extents()
{
    return (SdaiDimensional_exponents__set_var)((_folders.retrieve(144))->instances_());
}

SdaiStart_request__set_var SdaiModel_contents_config_control_design::SdaiStart_request_get_extents()
{
    return (SdaiStart_request__set_var)((_folders.retrieve(145))->instances_());
}

SdaiCc_design_specification_reference__set_var SdaiModel_contents_config_control_design::SdaiCc_design_specification_reference_get_extents()
{
    return (SdaiCc_design_specification_reference__set_var)((_folders.retrieve(146))->instances_());
}

SdaiSupplied_part_relationship__set_var SdaiModel_contents_config_control_design::SdaiSupplied_part_relationship_get_extents()
{
    return (SdaiSupplied_part_relationship__set_var)((_folders.retrieve(147))->instances_());
}

SdaiContext_dependent_shape_representation__set_var SdaiModel_contents_config_control_design::SdaiContext_dependent_shape_representation_get_extents()
{
    return (SdaiContext_dependent_shape_representation__set_var)((_folders.retrieve(148))->instances_());
}

SdaiDegenerate_toroidal_surface__set_var SdaiModel_contents_config_control_design::SdaiDegenerate_toroidal_surface_get_extents()
{
    return (SdaiDegenerate_toroidal_surface__set_var)((_folders.retrieve(149))->instances_());
}

SdaiOrdinal_date__set_var SdaiModel_contents_config_control_design::SdaiOrdinal_date_get_extents()
{
    return (SdaiOrdinal_date__set_var)((_folders.retrieve(150))->instances_());
}

SdaiFace_outer_bound__set_var SdaiModel_contents_config_control_design::SdaiFace_outer_bound_get_extents()
{
    return (SdaiFace_outer_bound__set_var)((_folders.retrieve(151))->instances_());
}

SdaiMass_measure_with_unit__set_var SdaiModel_contents_config_control_design::SdaiMass_measure_with_unit_get_extents()
{
    return (SdaiMass_measure_with_unit__set_var)((_folders.retrieve(152))->instances_());
}

SdaiBrep_with_voids__set_var SdaiModel_contents_config_control_design::SdaiBrep_with_voids_get_extents()
{
    return (SdaiBrep_with_voids__set_var)((_folders.retrieve(153))->instances_());
}

SdaiWeek_of_year_and_day_date__set_var SdaiModel_contents_config_control_design::SdaiWeek_of_year_and_day_date_get_extents()
{
    return (SdaiWeek_of_year_and_day_date__set_var)((_folders.retrieve(154))->instances_());
}

SdaiPoint_on_curve__set_var SdaiModel_contents_config_control_design::SdaiPoint_on_curve_get_extents()
{
    return (SdaiPoint_on_curve__set_var)((_folders.retrieve(155))->instances_());
}

SdaiShell_based_wireframe_shape_representation__set_var SdaiModel_contents_config_control_design::SdaiShell_based_wireframe_shape_representation_get_extents()
{
    return (SdaiShell_based_wireframe_shape_representation__set_var)((_folders.retrieve(156))->instances_());
}

SdaiFace__set_var SdaiModel_contents_config_control_design::SdaiFace_get_extents()
{
    return (SdaiFace__set_var)((_folders.retrieve(157))->instances_());
}

SdaiFace_surface__set_var SdaiModel_contents_config_control_design::SdaiFace_surface_get_extents()
{
    return (SdaiFace_surface__set_var)((_folders.retrieve(158))->instances_());
}

SdaiOriented_face__set_var SdaiModel_contents_config_control_design::SdaiOriented_face_get_extents()
{
    return (SdaiOriented_face__set_var)((_folders.retrieve(159))->instances_());
}

SdaiSurface_of_revolution__set_var SdaiModel_contents_config_control_design::SdaiSurface_of_revolution_get_extents()
{
    return (SdaiSurface_of_revolution__set_var)((_folders.retrieve(160))->instances_());
}

SdaiAdvanced_brep_shape_representation__set_var SdaiModel_contents_config_control_design::SdaiAdvanced_brep_shape_representation_get_extents()
{
    return (SdaiAdvanced_brep_shape_representation__set_var)((_folders.retrieve(161))->instances_());
}

SdaiEdge_curve__set_var SdaiModel_contents_config_control_design::SdaiEdge_curve_get_extents()
{
    return (SdaiEdge_curve__set_var)((_folders.retrieve(162))->instances_());
}

SdaiPoint_replica__set_var SdaiModel_contents_config_control_design::SdaiPoint_replica_get_extents()
{
    return (SdaiPoint_replica__set_var)((_folders.retrieve(163))->instances_());
}

SdaiProduct__set_var SdaiModel_contents_config_control_design::SdaiProduct_get_extents()
{
    return (SdaiProduct__set_var)((_folders.retrieve(164))->instances_());
}

SdaiShape_aspect_relationship__set_var SdaiModel_contents_config_control_design::SdaiShape_aspect_relationship_get_extents()
{
    return (SdaiShape_aspect_relationship__set_var)((_folders.retrieve(165))->instances_());
}

SdaiRectangular_trimmed_surface__set_var SdaiModel_contents_config_control_design::SdaiRectangular_trimmed_surface_get_extents()
{
    return (SdaiRectangular_trimmed_surface__set_var)((_folders.retrieve(166))->instances_());
}

SdaiPlane__set_var SdaiModel_contents_config_control_design::SdaiPlane_get_extents()
{
    return (SdaiPlane__set_var)((_folders.retrieve(167))->instances_());
}

SdaiAction_assignment__set_var SdaiModel_contents_config_control_design::SdaiAction_assignment_get_extents()
{
    return (SdaiAction_assignment__set_var)((_folders.retrieve(168))->instances_());
}

SdaiChange__set_var SdaiModel_contents_config_control_design::SdaiChange_get_extents()
{
    return (SdaiChange__set_var)((_folders.retrieve(169))->instances_());
}

SdaiCircle__set_var SdaiModel_contents_config_control_design::SdaiCircle_get_extents()
{
    return (SdaiCircle__set_var)((_folders.retrieve(170))->instances_());
}

SdaiLine__set_var SdaiModel_contents_config_control_design::SdaiLine_get_extents()
{
    return (SdaiLine__set_var)((_folders.retrieve(171))->instances_());
}

SdaiProperty_definition_representation__set_var SdaiModel_contents_config_control_design::SdaiProperty_definition_representation_get_extents()
{
    return (SdaiProperty_definition_representation__set_var)((_folders.retrieve(172))->instances_());
}

SdaiGeometric_set__set_var SdaiModel_contents_config_control_design::SdaiGeometric_set_get_extents()
{
    return (SdaiGeometric_set__set_var)((_folders.retrieve(173))->instances_());
}

SdaiGeometric_curve_set__set_var SdaiModel_contents_config_control_design::SdaiGeometric_curve_set_get_extents()
{
    return (SdaiGeometric_curve_set__set_var)((_folders.retrieve(174))->instances_());
}

SdaiPersonal_address__set_var SdaiModel_contents_config_control_design::SdaiPersonal_address_get_extents()
{
    return (SdaiPersonal_address__set_var)((_folders.retrieve(175))->instances_());
}

SdaiDocument_relationship__set_var SdaiModel_contents_config_control_design::SdaiDocument_relationship_get_extents()
{
    return (SdaiDocument_relationship__set_var)((_folders.retrieve(176))->instances_());
}

SdaiOuter_boundary_curve__set_var SdaiModel_contents_config_control_design::SdaiOuter_boundary_curve_get_extents()
{
    return (SdaiOuter_boundary_curve__set_var)((_folders.retrieve(177))->instances_());
}

SdaiShape_representation_relationship__set_var SdaiModel_contents_config_control_design::SdaiShape_representation_relationship_get_extents()
{
    return (SdaiShape_representation_relationship__set_var)((_folders.retrieve(178))->instances_());
}

SdaiAssembly_component_usage_substitute__set_var SdaiModel_contents_config_control_design::SdaiAssembly_component_usage_substitute_get_extents()
{
    return (SdaiAssembly_component_usage_substitute__set_var)((_folders.retrieve(179))->instances_());
}

SdaiDegenerate_pcurve__set_var SdaiModel_contents_config_control_design::SdaiDegenerate_pcurve_get_extents()
{
    return (SdaiDegenerate_pcurve__set_var)((_folders.retrieve(180))->instances_());
}

SdaiEvaluated_degenerate_pcurve__set_var SdaiModel_contents_config_control_design::SdaiEvaluated_degenerate_pcurve_get_extents()
{
    return (SdaiEvaluated_degenerate_pcurve__set_var)((_folders.retrieve(181))->instances_());
}

SdaiSolid_angle_measure_with_unit__set_var SdaiModel_contents_config_control_design::SdaiSolid_angle_measure_with_unit_get_extents()
{
    return (SdaiSolid_angle_measure_with_unit__set_var)((_folders.retrieve(182))->instances_());
}

SdaiConnected_edge_set__set_var SdaiModel_contents_config_control_design::SdaiConnected_edge_set_get_extents()
{
    return (SdaiConnected_edge_set__set_var)((_folders.retrieve(183))->instances_());
}

SdaiAction__set_var SdaiModel_contents_config_control_design::SdaiAction_get_extents()
{
    return (SdaiAction__set_var)((_folders.retrieve(184))->instances_());
}

SdaiExecuted_action__set_var SdaiModel_contents_config_control_design::SdaiExecuted_action_get_extents()
{
    return (SdaiExecuted_action__set_var)((_folders.retrieve(185))->instances_());
}

SdaiDirected_action__set_var SdaiModel_contents_config_control_design::SdaiDirected_action_get_extents()
{
    return (SdaiDirected_action__set_var)((_folders.retrieve(186))->instances_());
}

SdaiOrganizational_project__set_var SdaiModel_contents_config_control_design::SdaiOrganizational_project_get_extents()
{
    return (SdaiOrganizational_project__set_var)((_folders.retrieve(187))->instances_());
}

SdaiDate_time_role__set_var SdaiModel_contents_config_control_design::SdaiDate_time_role_get_extents()
{
    return (SdaiDate_time_role__set_var)((_folders.retrieve(188))->instances_());
}

SdaiCurve_bounded_surface__set_var SdaiModel_contents_config_control_design::SdaiCurve_bounded_surface_get_extents()
{
    return (SdaiCurve_bounded_surface__set_var)((_folders.retrieve(189))->instances_());
}

SdaiClosed_shell__set_var SdaiModel_contents_config_control_design::SdaiClosed_shell_get_extents()
{
    return (SdaiClosed_shell__set_var)((_folders.retrieve(190))->instances_());
}

SdaiDesign_make_from_relationship__set_var SdaiModel_contents_config_control_design::SdaiDesign_make_from_relationship_get_extents()
{
    return (SdaiDesign_make_from_relationship__set_var)((_folders.retrieve(191))->instances_());
}

SdaiDefinitional_representation__set_var SdaiModel_contents_config_control_design::SdaiDefinitional_representation_get_extents()
{
    return (SdaiDefinitional_representation__set_var)((_folders.retrieve(192))->instances_());
}

SdaiProduct_definition_shape__set_var SdaiModel_contents_config_control_design::SdaiProduct_definition_shape_get_extents()
{
    return (SdaiProduct_definition_shape__set_var)((_folders.retrieve(193))->instances_());
}

SdaiSi_unit__set_var SdaiModel_contents_config_control_design::SdaiSi_unit_get_extents()
{
    return (SdaiSi_unit__set_var)((_folders.retrieve(194))->instances_());
}

SdaiBezier_surface__set_var SdaiModel_contents_config_control_design::SdaiBezier_surface_get_extents()
{
    return (SdaiBezier_surface__set_var)((_folders.retrieve(195))->instances_());
}

SdaiCertification_assignment__set_var SdaiModel_contents_config_control_design::SdaiCertification_assignment_get_extents()
{
    return (SdaiCertification_assignment__set_var)((_folders.retrieve(196))->instances_());
}

SdaiStart_work__set_var SdaiModel_contents_config_control_design::SdaiStart_work_get_extents()
{
    return (SdaiStart_work__set_var)((_folders.retrieve(197))->instances_());
}

SdaiContract_type__set_var SdaiModel_contents_config_control_design::SdaiContract_type_get_extents()
{
    return (SdaiContract_type__set_var)((_folders.retrieve(198))->instances_());
}

SdaiB_spline_curve_with_knots__set_var SdaiModel_contents_config_control_design::SdaiB_spline_curve_with_knots_get_extents()
{
    return (SdaiB_spline_curve_with_knots__set_var)((_folders.retrieve(199))->instances_());
}

SdaiCc_design_approval__set_var SdaiModel_contents_config_control_design::SdaiCc_design_approval_get_extents()
{
    return (SdaiCc_design_approval__set_var)((_folders.retrieve(200))->instances_());
}

SdaiEdge_based_wireframe_shape_representation__set_var SdaiModel_contents_config_control_design::SdaiEdge_based_wireframe_shape_representation_get_extents()
{
    return (SdaiEdge_based_wireframe_shape_representation__set_var)((_folders.retrieve(201))->instances_());
}

SdaiGeometrically_bounded_wireframe_shape_representation__set_var SdaiModel_contents_config_control_design::SdaiGeometrically_bounded_wireframe_shape_representation_get_extents()
{
    return (SdaiGeometrically_bounded_wireframe_shape_representation__set_var)((_folders.retrieve(202))->instances_());
}

SdaiProduct_concept__set_var SdaiModel_contents_config_control_design::SdaiProduct_concept_get_extents()
{
    return (SdaiProduct_concept__set_var)((_folders.retrieve(203))->instances_());
}

SdaiCc_design_contract__set_var SdaiModel_contents_config_control_design::SdaiCc_design_contract_get_extents()
{
    return (SdaiCc_design_contract__set_var)((_folders.retrieve(204))->instances_());
}

SdaiSeam_curve__set_var SdaiModel_contents_config_control_design::SdaiSeam_curve_get_extents()
{
    return (SdaiSeam_curve__set_var)((_folders.retrieve(205))->instances_());
}

SdaiAxis2_placement_3d__set_var SdaiModel_contents_config_control_design::SdaiAxis2_placement_3d_get_extents()
{
    return (SdaiAxis2_placement_3d__set_var)((_folders.retrieve(206))->instances_());
}

SdaiRational_b_spline_surface__set_var SdaiModel_contents_config_control_design::SdaiRational_b_spline_surface_get_extents()
{
    return (SdaiRational_b_spline_surface__set_var)((_folders.retrieve(207))->instances_());
}

SdaiConfiguration_design__set_var SdaiModel_contents_config_control_design::SdaiConfiguration_design_get_extents()
{
    return (SdaiConfiguration_design__set_var)((_folders.retrieve(208))->instances_());
}

SdaiDesign_context__set_var SdaiModel_contents_config_control_design::SdaiDesign_context_get_extents()
{
    return (SdaiDesign_context__set_var)((_folders.retrieve(209))->instances_());
}

SdaiProduct_definition__set_var SdaiModel_contents_config_control_design::SdaiProduct_definition_get_extents()
{
    return (SdaiProduct_definition__set_var)((_folders.retrieve(210))->instances_());
}

SdaiProduct_definition_with_associated_documents__set_var SdaiModel_contents_config_control_design::SdaiProduct_definition_with_associated_documents_get_extents()
{
    return (SdaiProduct_definition_with_associated_documents__set_var)((_folders.retrieve(211))->instances_());
}

SdaiOrganization__set_var SdaiModel_contents_config_control_design::SdaiOrganization_get_extents()
{
    return (SdaiOrganization__set_var)((_folders.retrieve(212))->instances_());
}

SdaiCc_design_certification__set_var SdaiModel_contents_config_control_design::SdaiCc_design_certification_get_extents()
{
    return (SdaiCc_design_certification__set_var)((_folders.retrieve(213))->instances_());
}

SdaiB_spline_surface_with_knots__set_var SdaiModel_contents_config_control_design::SdaiB_spline_surface_with_knots_get_extents()
{
    return (SdaiB_spline_surface_with_knots__set_var)((_folders.retrieve(214))->instances_());
}

SdaiCertification_type__set_var SdaiModel_contents_config_control_design::SdaiCertification_type_get_extents()
{
    return (SdaiCertification_type__set_var)((_folders.retrieve(215))->instances_());
}

SdaiOriented_path__set_var SdaiModel_contents_config_control_design::SdaiOriented_path_get_extents()
{
    return (SdaiOriented_path__set_var)((_folders.retrieve(216))->instances_());
}

SdaiSecurity_classification__set_var SdaiModel_contents_config_control_design::SdaiSecurity_classification_get_extents()
{
    return (SdaiSecurity_classification__set_var)((_folders.retrieve(217))->instances_());
}

SdaiVertex_loop__set_var SdaiModel_contents_config_control_design::SdaiVertex_loop_get_extents()
{
    return (SdaiVertex_loop__set_var)((_folders.retrieve(218))->instances_());
}

SdaiApproval_status__set_var SdaiModel_contents_config_control_design::SdaiApproval_status_get_extents()
{
    return (SdaiApproval_status__set_var)((_folders.retrieve(219))->instances_());
}

SdaiCartesian_point__set_var SdaiModel_contents_config_control_design::SdaiCartesian_point_get_extents()
{
    return (SdaiCartesian_point__set_var)((_folders.retrieve(220))->instances_());
}

SdaiDate_and_time_assignment__set_var SdaiModel_contents_config_control_design::SdaiDate_and_time_assignment_get_extents()
{
    return (SdaiDate_and_time_assignment__set_var)((_folders.retrieve(221))->instances_());
}

SdaiParametric_representation_context__set_var SdaiModel_contents_config_control_design::SdaiParametric_representation_context_get_extents()
{
    return (SdaiParametric_representation_context__set_var)((_folders.retrieve(222))->instances_());
}

SdaiProduct_concept_context__set_var SdaiModel_contents_config_control_design::SdaiProduct_concept_context_get_extents()
{
    return (SdaiProduct_concept_context__set_var)((_folders.retrieve(223))->instances_());
}

SdaiSurface_patch__set_var SdaiModel_contents_config_control_design::SdaiSurface_patch_get_extents()
{
    return (SdaiSurface_patch__set_var)((_folders.retrieve(224))->instances_());
}

SdaiLength_unit__set_var SdaiModel_contents_config_control_design::SdaiLength_unit_get_extents()
{
    return (SdaiLength_unit__set_var)((_folders.retrieve(225))->instances_());
}

SdaiShape_aspect__set_var SdaiModel_contents_config_control_design::SdaiShape_aspect_get_extents()
{
    return (SdaiShape_aspect__set_var)((_folders.retrieve(226))->instances_());
}

SdaiVolume_measure_with_unit__set_var SdaiModel_contents_config_control_design::SdaiVolume_measure_with_unit_get_extents()
{
    return (SdaiVolume_measure_with_unit__set_var)((_folders.retrieve(227))->instances_());
}

SdaiAdvanced_face__set_var SdaiModel_contents_config_control_design::SdaiAdvanced_face_get_extents()
{
    return (SdaiAdvanced_face__set_var)((_folders.retrieve(228))->instances_());
}

SdaiSecurity_classification_level__set_var SdaiModel_contents_config_control_design::SdaiSecurity_classification_level_get_extents()
{
    return (SdaiSecurity_classification_level__set_var)((_folders.retrieve(229))->instances_());
}

SdaiApproval_relationship__set_var SdaiModel_contents_config_control_design::SdaiApproval_relationship_get_extents()
{
    return (SdaiApproval_relationship__set_var)((_folders.retrieve(230))->instances_());
}

SdaiPolyline__set_var SdaiModel_contents_config_control_design::SdaiPolyline_get_extents()
{
    return (SdaiPolyline__set_var)((_folders.retrieve(231))->instances_());
}

SdaiApproval_person_organization__set_var SdaiModel_contents_config_control_design::SdaiApproval_person_organization_get_extents()
{
    return (SdaiApproval_person_organization__set_var)((_folders.retrieve(232))->instances_());
}

SdaiSurface_replica__set_var SdaiModel_contents_config_control_design::SdaiSurface_replica_get_extents()
{
    return (SdaiSurface_replica__set_var)((_folders.retrieve(233))->instances_());
}

SdaiSecurity_classification_assignment__set_var SdaiModel_contents_config_control_design::SdaiSecurity_classification_assignment_get_extents()
{
    return (SdaiSecurity_classification_assignment__set_var)((_folders.retrieve(234))->instances_());
}

SdaiCc_design_security_classification__set_var SdaiModel_contents_config_control_design::SdaiCc_design_security_classification_get_extents()
{
    return (SdaiCc_design_security_classification__set_var)((_folders.retrieve(235))->instances_());
}

SdaiFaceted_brep_shape_representation__set_var SdaiModel_contents_config_control_design::SdaiFaceted_brep_shape_representation_get_extents()
{
    return (SdaiFaceted_brep_shape_representation__set_var)((_folders.retrieve(236))->instances_());
}

SdaiDocument_usage_constraint__set_var SdaiModel_contents_config_control_design::SdaiDocument_usage_constraint_get_extents()
{
    return (SdaiDocument_usage_constraint__set_var)((_folders.retrieve(237))->instances_());
}

SdaiVertex_point__set_var SdaiModel_contents_config_control_design::SdaiVertex_point_get_extents()
{
    return (SdaiVertex_point__set_var)((_folders.retrieve(238))->instances_());
}

SdaiCc_design_date_and_time_assignment__set_var SdaiModel_contents_config_control_design::SdaiCc_design_date_and_time_assignment_get_extents()
{
    return (SdaiCc_design_date_and_time_assignment__set_var)((_folders.retrieve(239))->instances_());
}

SdaiOriented_closed_shell__set_var SdaiModel_contents_config_control_design::SdaiOriented_closed_shell_get_extents()
{
    return (SdaiOriented_closed_shell__set_var)((_folders.retrieve(240))->instances_());
}

SdaiPerson_and_organization__set_var SdaiModel_contents_config_control_design::SdaiPerson_and_organization_get_extents()
{
    return (SdaiPerson_and_organization__set_var)((_folders.retrieve(241))->instances_());
}

SdaiCylindrical_surface__set_var SdaiModel_contents_config_control_design::SdaiCylindrical_surface_get_extents()
{
    return (SdaiCylindrical_surface__set_var)((_folders.retrieve(242))->instances_());
}

SdaiLocal_time__set_var SdaiModel_contents_config_control_design::SdaiLocal_time_get_extents()
{
    return (SdaiLocal_time__set_var)((_folders.retrieve(243))->instances_());
}

SdaiMass_unit__set_var SdaiModel_contents_config_control_design::SdaiMass_unit_get_extents()
{
    return (SdaiMass_unit__set_var)((_folders.retrieve(244))->instances_());
}

SdaiVertex_shell__set_var SdaiModel_contents_config_control_design::SdaiVertex_shell_get_extents()
{
    return (SdaiVertex_shell__set_var)((_folders.retrieve(245))->instances_());
}

SdaiPoly_loop__set_var SdaiModel_contents_config_control_design::SdaiPoly_loop_get_extents()
{
    return (SdaiPoly_loop__set_var)((_folders.retrieve(246))->instances_());
}

SdaiWire_shell__set_var SdaiModel_contents_config_control_design::SdaiWire_shell_get_extents()
{
    return (SdaiWire_shell__set_var)((_folders.retrieve(247))->instances_());
}

SdaiArea_unit__set_var SdaiModel_contents_config_control_design::SdaiArea_unit_get_extents()
{
    return (SdaiArea_unit__set_var)((_folders.retrieve(248))->instances_());
}

SdaiMapped_item__set_var SdaiModel_contents_config_control_design::SdaiMapped_item_get_extents()
{
    return (SdaiMapped_item__set_var)((_folders.retrieve(249))->instances_());
}

SdaiShape_definition_representation__set_var SdaiModel_contents_config_control_design::SdaiShape_definition_representation_get_extents()
{
    return (SdaiShape_definition_representation__set_var)((_folders.retrieve(250))->instances_());
}

SdaiVolume_unit__set_var SdaiModel_contents_config_control_design::SdaiVolume_unit_get_extents()
{
    return (SdaiVolume_unit__set_var)((_folders.retrieve(251))->instances_());
}

SdaiConical_surface__set_var SdaiModel_contents_config_control_design::SdaiConical_surface_get_extents()
{
    return (SdaiConical_surface__set_var)((_folders.retrieve(252))->instances_());
}

SdaiGlobal_unit_assigned_context__set_var SdaiModel_contents_config_control_design::SdaiGlobal_unit_assigned_context_get_extents()
{
    return (SdaiGlobal_unit_assigned_context__set_var)((_folders.retrieve(253))->instances_());
}
#endif
