#ifndef  SDAIALL_CC
#define  SDAIALL_CC
// This file was generated by fedex_plus.  You probably don't want to edit
// it since your modifications will be lost if fedex_plus is used to
// regenerate it.
/* $Id$  */ 
#include <schema.h>

void
InitSchemasAndEnts (Registry & reg)
{
    Uniqueness_rule_ptr ur;
    Where_rule_ptr wr;
    Global_rule_ptr gr;
	// Schema:  SdaiCONFIG_CONTROL_DESIGN
	s_config_control_design = new Schema("Config_Control_Design");
	s_config_control_design->AssignModelContentsCreator(
			(ModelContentsCreator) create_SdaiModel_contents_config_control_design);
	reg.AddSchema (*s_config_control_design);
	gr = new Global_rule("change_request_requires_approval",s_config_control_design,"RULE change_request_requires_approval FOR (change_request, \n           cc_design_approval);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(\n           QUERY ( ccda <* cc_design_approval | (cr IN ccda.items) )) = 1)) )) \n           = 0);\n\nEND_RULE; -- change_request_requires_approval\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE change_request_requires_approval FOR (change_request, 
           cc_design_approval);

WHERE
  wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(
           QUERY ( ccda <* cc_design_approval | (cr IN ccda.items) )) = 1)) )) 
           = 0);

END_RULE; -- change_request_requires_approval

*/
	gr = new Global_rule("restrict_date_time_role",s_config_control_design,"RULE restrict_date_time_role FOR (date_time_role);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( dtr <* date_time_role | (NOT (dtr.name IN [\n           'creation_date','request_date','release_date','start_date',\n           'contract_date','certification_date','sign_off_date',\n           'classification_date','declassification_date'])) )) = 0);\n\nEND_RULE; -- restrict_date_time_role\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE restrict_date_time_role FOR (date_time_role);

WHERE
  wr1: (SIZEOF(QUERY ( dtr <* date_time_role | (NOT (dtr.name IN [
           'creation_date','request_date','release_date','start_date',
           'contract_date','certification_date','sign_off_date',
           'classification_date','declassification_date'])) )) = 0);

END_RULE; -- restrict_date_time_role

*/
	gr = new Global_rule("versioned_action_request_requires_status",s_config_control_design,"RULE versioned_action_request_requires_status FOR (\n           versioned_action_request, action_request_status);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT (SIZEOF(\n           QUERY ( ars <* action_request_status | (ar :=: ars.\n           assigned_request) )) = 1)) )) = 0);\n\nEND_RULE; -- versioned_action_request_requires_status\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE versioned_action_request_requires_status FOR (
           versioned_action_request, action_request_status);

WHERE
  wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT (SIZEOF(
           QUERY ( ars <* action_request_status | (ar :=: ars.
           assigned_request) )) = 1)) )) = 0);

END_RULE; -- versioned_action_request_requires_status

*/
	gr = new Global_rule("acu_requires_security_classification",s_config_control_design,"RULE acu_requires_security_classification FOR (assembly_component_usage, \n           cc_design_security_classification);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( acu <* assembly_component_usage | (NOT (SIZEOF(\n           QUERY ( ccdsc <* cc_design_security_classification | (acu IN \n           ccdsc.items) )) = 1)) )) = 0);\n\nEND_RULE; -- acu_requires_security_classification\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE acu_requires_security_classification FOR (assembly_component_usage, 
           cc_design_security_classification);

WHERE
  wr1: (SIZEOF(QUERY ( acu <* assembly_component_usage | (NOT (SIZEOF(
           QUERY ( ccdsc <* cc_design_security_classification | (acu IN 
           ccdsc.items) )) = 1)) )) = 0);

END_RULE; -- acu_requires_security_classification

*/
	gr = new Global_rule("no_shape_for_supplied_part",s_config_control_design,"RULE no_shape_for_supplied_part FOR (supplied_part_relationship);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( spr <* supplied_part_relationship | (NOT (SIZEOF(\n           QUERY ( pd <* USEDIN(spr,'CONFIG_CONTROL_DESIGN.' + \n           'PROPERTY_DEFINITION.DEFINITION') | (\n           'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) )) \n           = 0)) )) = 0);\n\nEND_RULE; -- no_shape_for_supplied_part\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE no_shape_for_supplied_part FOR (supplied_part_relationship);

WHERE
  wr1: (SIZEOF(QUERY ( spr <* supplied_part_relationship | (NOT (SIZEOF(
           QUERY ( pd <* USEDIN(spr,'CONFIG_CONTROL_DESIGN.' + 
           'PROPERTY_DEFINITION.DEFINITION') | (
           'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) )) 
           = 0)) )) = 0);

END_RULE; -- no_shape_for_supplied_part

*/
	gr = new Global_rule("dependent_instantiable_person_and_organization_role",s_config_control_design,"RULE dependent_instantiable_person_and_organization_role FOR (\n           person_and_organization_role);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( poar <* person_and_organization_role | (NOT (\n           SIZEOF(USEDIN(poar,'')) >= 1)) )) = 0);\n\nEND_RULE; -- dependent_instantiable_person_and_organization_role\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_person_and_organization_role FOR (
           person_and_organization_role);

WHERE
  wr1: (SIZEOF(QUERY ( poar <* person_and_organization_role | (NOT (
           SIZEOF(USEDIN(poar,'')) >= 1)) )) = 0);

END_RULE; -- dependent_instantiable_person_and_organization_role

*/
	gr = new Global_rule("product_definition_requires_date_time",s_config_control_design,"RULE product_definition_requires_date_time FOR (product_definition, \n           cc_design_date_and_time_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(\n           QUERY ( ccdta <* cc_design_date_and_time_assignment | (pd IN \n           ccdta.items) )) = 1)) )) = 0);\n\nEND_RULE; -- product_definition_requires_date_time\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE product_definition_requires_date_time FOR (product_definition, 
           cc_design_date_and_time_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(
           QUERY ( ccdta <* cc_design_date_and_time_assignment | (pd IN 
           ccdta.items) )) = 1)) )) = 0);

END_RULE; -- product_definition_requires_date_time

*/
	gr = new Global_rule("compatible_dimension",s_config_control_design,"RULE compatible_dimension FOR (cartesian_point, direction, \n           representation_context, geometric_representation_context);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( x <* cartesian_point | (SIZEOF(QUERY ( y <* \n           geometric_representation_context | (item_in_context(x,y) AND (\n           HIINDEX(x.coordinates) <> y.coordinate_space_dimension)) )) > 0) )) \n           = 0);\n  wr2: (SIZEOF(QUERY ( x <* direction | (SIZEOF(QUERY ( y <* \n           geometric_representation_context | (item_in_context(x,y) AND (\n           HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)) )) \n           > 0) )) = 0);\n\nEND_RULE; -- compatible_dimension\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE compatible_dimension FOR (cartesian_point, direction, 
           representation_context, geometric_representation_context);

WHERE
  wr1: (SIZEOF(QUERY ( x <* cartesian_point | (SIZEOF(QUERY ( y <* 
           geometric_representation_context | (item_in_context(x,y) AND (
           HIINDEX(x.coordinates) <> y.coordinate_space_dimension)) )) > 0) )) 
           = 0);
  wr2: (SIZEOF(QUERY ( x <* direction | (SIZEOF(QUERY ( y <* 
           geometric_representation_context | (item_in_context(x,y) AND (
           HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)) )) 
           > 0) )) = 0);

END_RULE; -- compatible_dimension

*/
	gr = new Global_rule("product_version_requires_approval",s_config_control_design,"RULE product_version_requires_approval FOR (product_definition_formation, \n           cc_design_approval);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (SIZEOF(\n           QUERY ( ccda <* cc_design_approval | (pdf IN ccda.items) )) = 1)) )) \n           = 0);\n\nEND_RULE; -- product_version_requires_approval\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE product_version_requires_approval FOR (product_definition_formation, 
           cc_design_approval);

WHERE
  wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (SIZEOF(
           QUERY ( ccda <* cc_design_approval | (pdf IN ccda.items) )) = 1)) )) 
           = 0);

END_RULE; -- product_version_requires_approval

*/
	gr = new Global_rule("change_requires_approval",s_config_control_design,"RULE change_requires_approval FOR (change, cc_design_approval);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( chg <* change | (NOT (SIZEOF(QUERY ( ccda <* \n           cc_design_approval | (chg IN ccda.items) )) = 1)) )) = 0);\n\nEND_RULE; -- change_requires_approval\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE change_requires_approval FOR (change, cc_design_approval);

WHERE
  wr1: (SIZEOF(QUERY ( chg <* change | (NOT (SIZEOF(QUERY ( ccda <* 
           cc_design_approval | (chg IN ccda.items) )) = 1)) )) = 0);

END_RULE; -- change_requires_approval

*/
	gr = new Global_rule("product_requires_version",s_config_control_design,"RULE product_requires_version FOR (product, product_definition_formation);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( pdf <* \n           product_definition_formation | (prod :=: pdf.of_product) )) >= 1)) )) \n           = 0);\n\nEND_RULE; -- product_requires_version\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE product_requires_version FOR (product, product_definition_formation);

WHERE
  wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( pdf <* 
           product_definition_formation | (prod :=: pdf.of_product) )) >= 1)) )) 
           = 0);

END_RULE; -- product_requires_version

*/
	gr = new Global_rule("product_definition_requires_person_organization",s_config_control_design,"RULE product_definition_requires_person_organization FOR (\n           product_definition, cc_design_person_and_organization_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(\n           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment\n            | (pd IN ccdpoa.items) )) = 1)) )) = 0);\n\nEND_RULE; -- product_definition_requires_person_organization\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE product_definition_requires_person_organization FOR (
           product_definition, cc_design_person_and_organization_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(
           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
            | (pd IN ccdpoa.items) )) = 1)) )) = 0);

END_RULE; -- product_definition_requires_person_organization

*/
	gr = new Global_rule("product_concept_requires_configuration_item",s_config_control_design,"RULE product_concept_requires_configuration_item FOR (product_concept, \n           configuration_item);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( pc <* product_concept | (NOT (SIZEOF(QUERY ( ci <* \n           configuration_item | (pc :=: ci.item_concept) )) >= 1)) )) = 0);\n\nEND_RULE; -- product_concept_requires_configuration_item\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE product_concept_requires_configuration_item FOR (product_concept, 
           configuration_item);

WHERE
  wr1: (SIZEOF(QUERY ( pc <* product_concept | (NOT (SIZEOF(QUERY ( ci <* 
           configuration_item | (pc :=: ci.item_concept) )) >= 1)) )) = 0);

END_RULE; -- product_concept_requires_configuration_item

*/
	gr = new Global_rule("certification_requires_date_time",s_config_control_design,"RULE certification_requires_date_time FOR (certification, \n           cc_design_date_and_time_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( cert <* certification | (NOT (SIZEOF(\n           QUERY ( ccdta <* cc_design_date_and_time_assignment | (cert IN \n           ccdta.items) )) = 1)) )) = 0);\n\nEND_RULE; -- certification_requires_date_time\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE certification_requires_date_time FOR (certification, 
           cc_design_date_and_time_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( cert <* certification | (NOT (SIZEOF(
           QUERY ( ccdta <* cc_design_date_and_time_assignment | (cert IN 
           ccdta.items) )) = 1)) )) = 0);

END_RULE; -- certification_requires_date_time

*/
	gr = new Global_rule("certification_requires_approval",s_config_control_design,"RULE certification_requires_approval FOR (certification, \n           cc_design_approval);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( cert <* certification | (NOT (SIZEOF(\n           QUERY ( ccda <* cc_design_approval | (cert IN ccda.items) )) = 1)) )) \n           = 0);\n\nEND_RULE; -- certification_requires_approval\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE certification_requires_approval FOR (certification, 
           cc_design_approval);

WHERE
  wr1: (SIZEOF(QUERY ( cert <* certification | (NOT (SIZEOF(
           QUERY ( ccda <* cc_design_approval | (cert IN ccda.items) )) = 1)) )) 
           = 0);

END_RULE; -- certification_requires_approval

*/
	gr = new Global_rule("subtype_mandatory_effectivity",s_config_control_design,"RULE subtype_mandatory_effectivity FOR (effectivity);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( eff <* effectivity | (NOT ((SIZEOF([\n           'CONFIG_CONTROL_DESIGN.SERIAL_NUMBERED_EFFECTIVITY',\n           'CONFIG_CONTROL_DESIGN.LOT_EFFECTIVITY',\n           'CONFIG_CONTROL_DESIGN.DATED_EFFECTIVITY'] * TYPEOF(eff)) = 1) \n           AND ('CONFIG_CONTROL_DESIGN.CONFIGURATION_EFFECTIVITY' IN \n           TYPEOF(eff)))) )) = 0);\n\nEND_RULE; -- subtype_mandatory_effectivity\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE subtype_mandatory_effectivity FOR (effectivity);

WHERE
  wr1: (SIZEOF(QUERY ( eff <* effectivity | (NOT ((SIZEOF([
           'CONFIG_CONTROL_DESIGN.SERIAL_NUMBERED_EFFECTIVITY',
           'CONFIG_CONTROL_DESIGN.LOT_EFFECTIVITY',
           'CONFIG_CONTROL_DESIGN.DATED_EFFECTIVITY'] * TYPEOF(eff)) = 1) 
           AND ('CONFIG_CONTROL_DESIGN.CONFIGURATION_EFFECTIVITY' IN 
           TYPEOF(eff)))) )) = 0);

END_RULE; -- subtype_mandatory_effectivity

*/
	gr = new Global_rule("versioned_action_request_requires_solution",s_config_control_design,"RULE versioned_action_request_requires_solution FOR (\n           versioned_action_request, action_request_solution);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT (SIZEOF(\n           QUERY ( ars <* action_request_solution | (ar :=: ars.request) )) \n           >= 1)) )) = 0);\n\nEND_RULE; -- versioned_action_request_requires_solution\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE versioned_action_request_requires_solution FOR (
           versioned_action_request, action_request_solution);

WHERE
  wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT (SIZEOF(
           QUERY ( ars <* action_request_solution | (ar :=: ars.request) )) 
           >= 1)) )) = 0);

END_RULE; -- versioned_action_request_requires_solution

*/
	gr = new Global_rule("effectivity_requires_approval",s_config_control_design,"RULE effectivity_requires_approval FOR (effectivity, cc_design_approval);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( eff <* effectivity | (NOT (SIZEOF(QUERY ( ccda <* \n           cc_design_approval | (eff IN ccda.items) )) = 1)) )) = 0);\n\nEND_RULE; -- effectivity_requires_approval\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE effectivity_requires_approval FOR (effectivity, cc_design_approval);

WHERE
  wr1: (SIZEOF(QUERY ( eff <* effectivity | (NOT (SIZEOF(QUERY ( ccda <* 
           cc_design_approval | (eff IN ccda.items) )) = 1)) )) = 0);

END_RULE; -- effectivity_requires_approval

*/
	gr = new Global_rule("unique_version_change_order_rule",s_config_control_design,"RULE unique_version_change_order_rule FOR (change);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( c <* change | (NOT unique_version_change_order(c.\n           assigned_action)) )) = 0);\n\nEND_RULE; -- unique_version_change_order_rule\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE unique_version_change_order_rule FOR (change);

WHERE
  wr1: (SIZEOF(QUERY ( c <* change | (NOT unique_version_change_order(c.
           assigned_action)) )) = 0);

END_RULE; -- unique_version_change_order_rule

*/
	gr = new Global_rule("dependent_instantiable_named_unit",s_config_control_design,"RULE dependent_instantiable_named_unit FOR (named_unit);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( nu <* named_unit | (NOT (SIZEOF(USEDIN(nu,'')) >= 1)) )) \n           = 0);\n\nEND_RULE; -- dependent_instantiable_named_unit\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_named_unit FOR (named_unit);

WHERE
  wr1: (SIZEOF(QUERY ( nu <* named_unit | (NOT (SIZEOF(USEDIN(nu,'')) >= 1)) )) 
           = 0);

END_RULE; -- dependent_instantiable_named_unit

*/
	gr = new Global_rule("subtype_mandatory_product_definition_formation",s_config_control_design,"RULE subtype_mandatory_product_definition_formation FOR (\n           product_definition_formation);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT ((\n           'CONFIG_CONTROL_DESIGN.' + \n           'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE') IN TYPEOF(\n           pdf))) )) = 0);\n\nEND_RULE; -- subtype_mandatory_product_definition_formation\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE subtype_mandatory_product_definition_formation FOR (
           product_definition_formation);

WHERE
  wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT ((
           'CONFIG_CONTROL_DESIGN.' + 
           'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE') IN TYPEOF(
           pdf))) )) = 0);

END_RULE; -- subtype_mandatory_product_definition_formation

*/
	gr = new Global_rule("approval_requires_approval_person_organization",s_config_control_design,"RULE approval_requires_approval_person_organization FOR (approval, \n           approval_person_organization);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( apo <* \n           approval_person_organization | (app :=: apo.authorized_approval) )) \n           >= 1)) )) = 0);\n\nEND_RULE; -- approval_requires_approval_person_organization\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE approval_requires_approval_person_organization FOR (approval, 
           approval_person_organization);

WHERE
  wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( apo <* 
           approval_person_organization | (app :=: apo.authorized_approval) )) 
           >= 1)) )) = 0);

END_RULE; -- approval_requires_approval_person_organization

*/
	gr = new Global_rule("approvals_are_assigned",s_config_control_design,"RULE approvals_are_assigned FOR (approval, approval_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( aa <* \n           approval_assignment | (app :=: aa.assigned_approval) )) >= 1)) )) \n           = 0);\n\nEND_RULE; -- approvals_are_assigned\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE approvals_are_assigned FOR (approval, approval_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( aa <* 
           approval_assignment | (app :=: aa.assigned_approval) )) >= 1)) )) 
           = 0);

END_RULE; -- approvals_are_assigned

*/
	gr = new Global_rule("start_work_requires_approval",s_config_control_design,"RULE start_work_requires_approval FOR (start_work, cc_design_approval);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sw <* start_work | (NOT (SIZEOF(QUERY ( ccda <* \n           cc_design_approval | (sw IN ccda.items) )) = 1)) )) = 0);\n\nEND_RULE; -- start_work_requires_approval\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE start_work_requires_approval FOR (start_work, cc_design_approval);

WHERE
  wr1: (SIZEOF(QUERY ( sw <* start_work | (NOT (SIZEOF(QUERY ( ccda <* 
           cc_design_approval | (sw IN ccda.items) )) = 1)) )) = 0);

END_RULE; -- start_work_requires_approval

*/
	gr = new Global_rule("approval_person_organization_constraints",s_config_control_design,"RULE approval_person_organization_constraints FOR (\n           approval_person_organization);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( apo <* approval_person_organization | (NOT (SIZEOF(\n           TYPEOF(apo.person_organization) * [\n           'CONFIG_CONTROL_DESIGN.PERSON_AND_ORGANIZATION']) = 1)) )) = 0);\n\nEND_RULE; -- approval_person_organization_constraints\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE approval_person_organization_constraints FOR (
           approval_person_organization);

WHERE
  wr1: (SIZEOF(QUERY ( apo <* approval_person_organization | (NOT (SIZEOF(
           TYPEOF(apo.person_organization) * [
           'CONFIG_CONTROL_DESIGN.PERSON_AND_ORGANIZATION']) = 1)) )) = 0);

END_RULE; -- approval_person_organization_constraints

*/
	gr = new Global_rule("configuration_item_requires_approval",s_config_control_design,"RULE configuration_item_requires_approval FOR (configuration_item, \n           cc_design_approval);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ci <* configuration_item | (NOT (SIZEOF(\n           QUERY ( ccda <* cc_design_approval | (ci IN ccda.items) )) = 1)) )) \n           = 0);\n\nEND_RULE; -- configuration_item_requires_approval\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE configuration_item_requires_approval FOR (configuration_item, 
           cc_design_approval);

WHERE
  wr1: (SIZEOF(QUERY ( ci <* configuration_item | (NOT (SIZEOF(
           QUERY ( ccda <* cc_design_approval | (ci IN ccda.items) )) = 1)) )) 
           = 0);

END_RULE; -- configuration_item_requires_approval

*/
	gr = new Global_rule("contract_requires_person_organization",s_config_control_design,"RULE contract_requires_person_organization FOR (contract, \n           cc_design_person_and_organization_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( c <* contract | (NOT (SIZEOF(QUERY ( ccdpoa <* \n           cc_design_person_and_organization_assignment | (c IN ccdpoa.\n           items) )) = 1)) )) = 0);\n\nEND_RULE; -- contract_requires_person_organization\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE contract_requires_person_organization FOR (contract, 
           cc_design_person_and_organization_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( c <* contract | (NOT (SIZEOF(QUERY ( ccdpoa <* 
           cc_design_person_and_organization_assignment | (c IN ccdpoa.
           items) )) = 1)) )) = 0);

END_RULE; -- contract_requires_person_organization

*/
	gr = new Global_rule("dependent_instantiable_date_time_role",s_config_control_design,"RULE dependent_instantiable_date_time_role FOR (date_time_role);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( dtr <* date_time_role | (NOT (SIZEOF(USEDIN(dtr,'')) \n           >= 1)) )) = 0);\n\nEND_RULE; -- dependent_instantiable_date_time_role\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_date_time_role FOR (date_time_role);

WHERE
  wr1: (SIZEOF(QUERY ( dtr <* date_time_role | (NOT (SIZEOF(USEDIN(dtr,'')) 
           >= 1)) )) = 0);

END_RULE; -- dependent_instantiable_date_time_role

*/
	gr = new Global_rule("restrict_product_category_value",s_config_control_design,"RULE restrict_product_category_value FOR (product_related_product_category);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( prpc <* product_related_product_category | (NOT (\n           prpc.name IN ['assembly','detail','customer_furnished_equipment',\n           'inseparable_assembly','cast','coined','drawn','extruded',\n           'forged','formed','machined','molded','rolled','sheared'])) )) =\n            0);\n\nEND_RULE; -- restrict_product_category_value\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE restrict_product_category_value FOR (product_related_product_category);

WHERE
  wr1: (SIZEOF(QUERY ( prpc <* product_related_product_category | (NOT (
           prpc.name IN ['assembly','detail','customer_furnished_equipment',
           'inseparable_assembly','cast','coined','drawn','extruded',
           'forged','formed','machined','molded','rolled','sheared'])) )) =
            0);

END_RULE; -- restrict_product_category_value

*/
	gr = new Global_rule("start_work_requires_date_time",s_config_control_design,"RULE start_work_requires_date_time FOR (start_work, \n           cc_design_date_and_time_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sw <* start_work | (NOT (SIZEOF(QUERY ( ccdta <* \n           cc_design_date_and_time_assignment | ((sw IN ccdta.items) AND (\n           ccdta.role.name = 'start_date')) )) = 1)) )) = 0);\n\nEND_RULE; -- start_work_requires_date_time\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE start_work_requires_date_time FOR (start_work, 
           cc_design_date_and_time_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( sw <* start_work | (NOT (SIZEOF(QUERY ( ccdta <* 
           cc_design_date_and_time_assignment | ((sw IN ccdta.items) AND (
           ccdta.role.name = 'start_date')) )) = 1)) )) = 0);

END_RULE; -- start_work_requires_date_time

*/
	gr = new Global_rule("product_requires_product_category",s_config_control_design,"RULE product_requires_product_category FOR (product, \n           product_related_product_category);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( prpc <* \n           product_related_product_category | ((prod IN prpc.products) AND \n           (prpc.name IN ['assembly','inseparable_assembly','detail',\n           'customer_furnished_equipment'])) )) = 1)) )) = 0);\n\nEND_RULE; -- product_requires_product_category\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE product_requires_product_category FOR (product, 
           product_related_product_category);

WHERE
  wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( prpc <* 
           product_related_product_category | ((prod IN prpc.products) AND 
           (prpc.name IN ['assembly','inseparable_assembly','detail',
           'customer_furnished_equipment'])) )) = 1)) )) = 0);

END_RULE; -- product_requires_product_category

*/
	gr = new Global_rule("dependent_instantiable_representation_item",s_config_control_design,"RULE dependent_instantiable_representation_item FOR (representation_item);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ri <* representation_item | (NOT (SIZEOF(USEDIN(ri,\n           '')) >= 1)) )) = 0);\n\nEND_RULE; -- dependent_instantiable_representation_item\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_representation_item FOR (representation_item);

WHERE
  wr1: (SIZEOF(QUERY ( ri <* representation_item | (NOT (SIZEOF(USEDIN(ri,
           '')) >= 1)) )) = 0);

END_RULE; -- dependent_instantiable_representation_item

*/
	gr = new Global_rule("change_request_requires_person_organization",s_config_control_design,"RULE change_request_requires_person_organization FOR (change_request, \n           cc_design_person_and_organization_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(\n           QUERY ( ccpoa <* cc_design_person_and_organization_assignment | \n           (cr IN ccpoa.items) )) >= 1)) )) = 0);\n\nEND_RULE; -- change_request_requires_person_organization\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE change_request_requires_person_organization FOR (change_request, 
           cc_design_person_and_organization_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(
           QUERY ( ccpoa <* cc_design_person_and_organization_assignment | 
           (cr IN ccpoa.items) )) >= 1)) )) = 0);

END_RULE; -- change_request_requires_person_organization

*/
	gr = new Global_rule("product_definition_requires_approval",s_config_control_design,"RULE product_definition_requires_approval FOR (product_definition, \n           cc_design_approval);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(\n           QUERY ( ccda <* cc_design_approval | (pd IN ccda.items) )) = 1)) )) \n           = 0);\n\nEND_RULE; -- product_definition_requires_approval\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE product_definition_requires_approval FOR (product_definition, 
           cc_design_approval);

WHERE
  wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(
           QUERY ( ccda <* cc_design_approval | (pd IN ccda.items) )) = 1)) )) 
           = 0);

END_RULE; -- product_definition_requires_approval

*/
	gr = new Global_rule("subtype_mandatory_representation_context",s_config_control_design,"RULE subtype_mandatory_representation_context FOR (representation_context);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( rep_cntxt <* representation_context | (NOT (\n           'CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN \n           TYPEOF(rep_cntxt))) )) = 0);\n\nEND_RULE; -- subtype_mandatory_representation_context\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE subtype_mandatory_representation_context FOR (representation_context);

WHERE
  wr1: (SIZEOF(QUERY ( rep_cntxt <* representation_context | (NOT (
           'CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN 
           TYPEOF(rep_cntxt))) )) = 0);

END_RULE; -- subtype_mandatory_representation_context

*/
	gr = new Global_rule("security_classification_requires_date_time",s_config_control_design,"RULE security_classification_requires_date_time FOR (\n           security_classification, cc_design_date_and_time_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(\n           QUERY ( ccdta <* cc_design_date_and_time_assignment | ((sc IN \n           ccdta.items) AND ('classification_date' = ccdta.role.name)) )) =\n            1)) )) = 0);\n\nEND_RULE; -- security_classification_requires_date_time\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE security_classification_requires_date_time FOR (
           security_classification, cc_design_date_and_time_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
           QUERY ( ccdta <* cc_design_date_and_time_assignment | ((sc IN 
           ccdta.items) AND ('classification_date' = ccdta.role.name)) )) =
            1)) )) = 0);

END_RULE; -- security_classification_requires_date_time

*/
	gr = new Global_rule("security_classification_optional_date_time",s_config_control_design,"RULE security_classification_optional_date_time FOR (\n           security_classification, cc_design_date_and_time_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(\n           QUERY ( ccdta <* cc_design_date_and_time_assignment | ((sc IN \n           ccdta.items) AND ('declassification_date' = ccdta.role.name)) )) \n           <= 1)) )) = 0);\n\nEND_RULE; -- security_classification_optional_date_time\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE security_classification_optional_date_time FOR (
           security_classification, cc_design_date_and_time_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
           QUERY ( ccdta <* cc_design_date_and_time_assignment | ((sc IN 
           ccdta.items) AND ('declassification_date' = ccdta.role.name)) )) 
           <= 1)) )) = 0);

END_RULE; -- security_classification_optional_date_time

*/
	gr = new Global_rule("as_required_quantity",s_config_control_design,"RULE as_required_quantity FOR (measure_with_unit);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( m <* measure_with_unit | ((\n           'CONFIG_CONTROL_DESIGN.DESCRIPTIVE_MEASURE' IN TYPEOF(m.\n           value_component)) AND (NOT (m.value_component = 'as_required'))) )) \n           = 0);\n\nEND_RULE; -- as_required_quantity\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE as_required_quantity FOR (measure_with_unit);

WHERE
  wr1: (SIZEOF(QUERY ( m <* measure_with_unit | ((
           'CONFIG_CONTROL_DESIGN.DESCRIPTIVE_MEASURE' IN TYPEOF(m.
           value_component)) AND (NOT (m.value_component = 'as_required'))) )) 
           = 0);

END_RULE; -- as_required_quantity

*/
	gr = new Global_rule("start_request_requires_approval",s_config_control_design,"RULE start_request_requires_approval FOR (start_request, \n           cc_design_approval);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(QUERY ( ccda <* \n           cc_design_approval | (sr IN ccda.items) )) = 1)) )) = 0);\n\nEND_RULE; -- start_request_requires_approval\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE start_request_requires_approval FOR (start_request, 
           cc_design_approval);

WHERE
  wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(QUERY ( ccda <* 
           cc_design_approval | (sr IN ccda.items) )) = 1)) )) = 0);

END_RULE; -- start_request_requires_approval

*/
	gr = new Global_rule("geometric_representation_item_3d",s_config_control_design,"RULE geometric_representation_item_3d FOR (geometric_representation_item);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( gri <* geometric_representation_item | (NOT ((\n           dimension_of(gri) = 3) OR (SIZEOF(QUERY ( ur <* \n           using_representations(gri) | (\n           'CONFIG_CONTROL_DESIGN.DEFINITIONAL_REPRESENTATION' IN TYPEOF(ur)) )) \n           > 0))) )) = 0);\n\nEND_RULE; -- geometric_representation_item_3d\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE geometric_representation_item_3d FOR (geometric_representation_item);

WHERE
  wr1: (SIZEOF(QUERY ( gri <* geometric_representation_item | (NOT ((
           dimension_of(gri) = 3) OR (SIZEOF(QUERY ( ur <* 
           using_representations(gri) | (
           'CONFIG_CONTROL_DESIGN.DEFINITIONAL_REPRESENTATION' IN TYPEOF(ur)) )) 
           > 0))) )) = 0);

END_RULE; -- geometric_representation_item_3d

*/
	gr = new Global_rule("application_context_requires_ap_definition",s_config_control_design,"RULE application_context_requires_ap_definition FOR (application_context, \n           application_protocol_definition);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ac <* application_context | (NOT (SIZEOF(\n           QUERY ( apd <* application_protocol_definition | ((ac :=: apd.\n           application) AND (apd.application_interpreted_model_schema_name \n           = 'config_control_design')) )) = 1)) )) = 0);\n\nEND_RULE; -- application_context_requires_ap_definition\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE application_context_requires_ap_definition FOR (application_context, 
           application_protocol_definition);

WHERE
  wr1: (SIZEOF(QUERY ( ac <* application_context | (NOT (SIZEOF(
           QUERY ( apd <* application_protocol_definition | ((ac :=: apd.
           application) AND (apd.application_interpreted_model_schema_name 
           = 'config_control_design')) )) = 1)) )) = 0);

END_RULE; -- application_context_requires_ap_definition

*/
	gr = new Global_rule("subtype_mandatory_representation",s_config_control_design,"RULE subtype_mandatory_representation FOR (representation);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( rep <* representation | (NOT (\n           'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(rep))) )) \n           = 0);\n\nEND_RULE; -- subtype_mandatory_representation\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE subtype_mandatory_representation FOR (representation);

WHERE
  wr1: (SIZEOF(QUERY ( rep <* representation | (NOT (
           'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(rep))) )) 
           = 0);

END_RULE; -- subtype_mandatory_representation

*/
	gr = new Global_rule("change_requires_date_time",s_config_control_design,"RULE change_requires_date_time FOR (change, \n           cc_design_date_and_time_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( chg <* change | (NOT (SIZEOF(QUERY ( ccdta <* \n           cc_design_date_and_time_assignment | ((chg IN ccdta.items) AND (\n           ccdta.role.name = 'start_date')) )) = 1)) )) = 0);\n\nEND_RULE; -- change_requires_date_time\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE change_requires_date_time FOR (change, 
           cc_design_date_and_time_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( chg <* change | (NOT (SIZEOF(QUERY ( ccdta <* 
           cc_design_date_and_time_assignment | ((chg IN ccdta.items) AND (
           ccdta.role.name = 'start_date')) )) = 1)) )) = 0);

END_RULE; -- change_requires_date_time

*/
	gr = new Global_rule("dependent_instantiable_action_directive",s_config_control_design,"RULE dependent_instantiable_action_directive FOR (action_directive);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ad <* action_directive | (NOT (SIZEOF(USEDIN(ad,'')) \n           >= 1)) )) = 0);\n\nEND_RULE; -- dependent_instantiable_action_directive\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_action_directive FOR (action_directive);

WHERE
  wr1: (SIZEOF(QUERY ( ad <* action_directive | (NOT (SIZEOF(USEDIN(ad,'')) 
           >= 1)) )) = 0);

END_RULE; -- dependent_instantiable_action_directive

*/
	gr = new Global_rule("restrict_security_classification_level",s_config_control_design,"RULE restrict_security_classification_level FOR (\n           security_classification_level);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( scl <* security_classification_level | (NOT (scl.\n           name IN ['unclassified','classified','proprietary',\n           'confidential','secret','top_secret'])) )) = 0);\n\nEND_RULE; -- restrict_security_classification_level\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE restrict_security_classification_level FOR (
           security_classification_level);

WHERE
  wr1: (SIZEOF(QUERY ( scl <* security_classification_level | (NOT (scl.
           name IN ['unclassified','classified','proprietary',
           'confidential','secret','top_secret'])) )) = 0);

END_RULE; -- restrict_security_classification_level

*/
	gr = new Global_rule("approval_requires_approval_date_time",s_config_control_design,"RULE approval_requires_approval_date_time FOR (approval, \n           approval_date_time);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( adt <* \n           approval_date_time | (app :=: adt.dated_approval) )) = 1)) )) = \n           0);\n\nEND_RULE; -- approval_requires_approval_date_time\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE approval_requires_approval_date_time FOR (approval, 
           approval_date_time);

WHERE
  wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( adt <* 
           approval_date_time | (app :=: adt.dated_approval) )) = 1)) )) = 
           0);

END_RULE; -- approval_requires_approval_date_time

*/
	gr = new Global_rule("subtype_mandatory_product_definition_usage",s_config_control_design,"RULE subtype_mandatory_product_definition_usage FOR (\n           product_definition_usage);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( pdu <* product_definition_usage | (NOT ((\n           'CONFIG_CONTROL_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE') IN \n           TYPEOF(pdu))) )) = 0);\n\nEND_RULE; -- subtype_mandatory_product_definition_usage\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE subtype_mandatory_product_definition_usage FOR (
           product_definition_usage);

WHERE
  wr1: (SIZEOF(QUERY ( pdu <* product_definition_usage | (NOT ((
           'CONFIG_CONTROL_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE') IN 
           TYPEOF(pdu))) )) = 0);

END_RULE; -- subtype_mandatory_product_definition_usage

*/
	gr = new Global_rule("restrict_approval_status",s_config_control_design,"RULE restrict_approval_status FOR (approval_status);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (ast.name IN [\n           'approved','not_yet_approved','disapproved','withdrawn'])) )) = \n           0);\n\nEND_RULE; -- restrict_approval_status\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE restrict_approval_status FOR (approval_status);

WHERE
  wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (ast.name IN [
           'approved','not_yet_approved','disapproved','withdrawn'])) )) = 
           0);

END_RULE; -- restrict_approval_status

*/
	gr = new Global_rule("change_request_requires_date_time",s_config_control_design,"RULE change_request_requires_date_time FOR (change_request, \n           cc_design_date_and_time_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(\n           QUERY ( ccdta <* cc_design_date_and_time_assignment | (cr IN \n           ccdta.items) )) = 1)) )) = 0);\n\nEND_RULE; -- change_request_requires_date_time\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE change_request_requires_date_time FOR (change_request, 
           cc_design_date_and_time_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(
           QUERY ( ccdta <* cc_design_date_and_time_assignment | (cr IN 
           ccdta.items) )) = 1)) )) = 0);

END_RULE; -- change_request_requires_date_time

*/
	gr = new Global_rule("dependent_instantiable_contract_type",s_config_control_design,"RULE dependent_instantiable_contract_type FOR (contract_type);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ct <* contract_type | (NOT (SIZEOF(USEDIN(ct,'')) \n           >= 1)) )) = 0);\n\nEND_RULE; -- dependent_instantiable_contract_type\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_contract_type FOR (contract_type);

WHERE
  wr1: (SIZEOF(QUERY ( ct <* contract_type | (NOT (SIZEOF(USEDIN(ct,'')) 
           >= 1)) )) = 0);

END_RULE; -- dependent_instantiable_contract_type

*/
	gr = new Global_rule("contract_requires_approval",s_config_control_design,"RULE contract_requires_approval FOR (contract, cc_design_approval);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( c <* contract | (NOT (SIZEOF(QUERY ( ccda <* \n           cc_design_approval | (c IN ccda.items) )) = 1)) )) = 0);\n\nEND_RULE; -- contract_requires_approval\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE contract_requires_approval FOR (contract, cc_design_approval);

WHERE
  wr1: (SIZEOF(QUERY ( c <* contract | (NOT (SIZEOF(QUERY ( ccda <* 
           cc_design_approval | (c IN ccda.items) )) = 1)) )) = 0);

END_RULE; -- contract_requires_approval

*/
	gr = new Global_rule("restrict_document_type",s_config_control_design,"RULE restrict_document_type FOR (document_type);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( dt <* document_type | (NOT (dt.product_data_type IN\n            ['material_specification','process_specification',\n           'design_specification','surface_finish_specification',\n           'cad_filename','drawing'])) )) = 0);\n\nEND_RULE; -- restrict_document_type\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE restrict_document_type FOR (document_type);

WHERE
  wr1: (SIZEOF(QUERY ( dt <* document_type | (NOT (dt.product_data_type IN
            ['material_specification','process_specification',
           'design_specification','surface_finish_specification',
           'cad_filename','drawing'])) )) = 0);

END_RULE; -- restrict_document_type

*/
	gr = new Global_rule("dependent_instantiable_certification_type",s_config_control_design,"RULE dependent_instantiable_certification_type FOR (certification_type);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ct <* certification_type | (NOT (SIZEOF(USEDIN(ct,\n           '')) >= 1)) )) = 0);\n\nEND_RULE; -- dependent_instantiable_certification_type\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_certification_type FOR (certification_type);

WHERE
  wr1: (SIZEOF(QUERY ( ct <* certification_type | (NOT (SIZEOF(USEDIN(ct,
           '')) >= 1)) )) = 0);

END_RULE; -- dependent_instantiable_certification_type

*/
	gr = new Global_rule("design_context_for_property",s_config_control_design,"RULE design_context_for_property FOR (product_definition);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( pd <* product_definition | ((SIZEOF(USEDIN(pd,\n           'CONFIG_CONTROL_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION') + \n           QUERY ( pdr <* USEDIN(pd,'CONFIG_CONTROL_DESIGN.' + \n           'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | \n           (SIZEOF(USEDIN(pdr,'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION.' \n           + 'DEFINITION')) >= 1) )) >= 1) AND (NOT (\n           'CONFIG_CONTROL_DESIGN.DESIGN_CONTEXT' IN TYPEOF(pd.\n           frame_of_reference)))) )) = 0);\n\nEND_RULE; -- design_context_for_property\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE design_context_for_property FOR (product_definition);

WHERE
  wr1: (SIZEOF(QUERY ( pd <* product_definition | ((SIZEOF(USEDIN(pd,
           'CONFIG_CONTROL_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION') + 
           QUERY ( pdr <* USEDIN(pd,'CONFIG_CONTROL_DESIGN.' + 
           'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
           (SIZEOF(USEDIN(pdr,'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION.' 
           + 'DEFINITION')) >= 1) )) >= 1) AND (NOT (
           'CONFIG_CONTROL_DESIGN.DESIGN_CONTEXT' IN TYPEOF(pd.
           frame_of_reference)))) )) = 0);

END_RULE; -- design_context_for_property

*/
	gr = new Global_rule("product_version_requires_person_organization",s_config_control_design,"RULE product_version_requires_person_organization FOR (\n           product_definition_formation, \n           cc_design_person_and_organization_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (SIZEOF(\n           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment\n            | ((pdf IN ccdpoa.items) AND (ccdpoa.role.name = 'creator')) )) \n           = 1)) )) = 0);\n  wr2: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (SIZEOF(\n           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment\n            | ((pdf IN ccdpoa.items) AND (ccdpoa.role.name IN [\n           'design_supplier','part_supplier'])) )) >= 1)) )) = 0);\n\nEND_RULE; -- product_version_requires_person_organization\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE product_version_requires_person_organization FOR (
           product_definition_formation, 
           cc_design_person_and_organization_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (SIZEOF(
           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
            | ((pdf IN ccdpoa.items) AND (ccdpoa.role.name = 'creator')) )) 
           = 1)) )) = 0);
  wr2: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (SIZEOF(
           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
            | ((pdf IN ccdpoa.items) AND (ccdpoa.role.name IN [
           'design_supplier','part_supplier'])) )) >= 1)) )) = 0);

END_RULE; -- product_version_requires_person_organization

*/
	gr = new Global_rule("dependent_instantiable_approval_status",s_config_control_design,"RULE dependent_instantiable_approval_status FOR (approval_status);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (SIZEOF(USEDIN(ast,'')) \n           >= 1)) )) = 0);\n\nEND_RULE; -- dependent_instantiable_approval_status\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_approval_status FOR (approval_status);

WHERE
  wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (SIZEOF(USEDIN(ast,'')) 
           >= 1)) )) = 0);

END_RULE; -- dependent_instantiable_approval_status

*/
	gr = new Global_rule("subtype_mandatory_shape_representation",s_config_control_design,"RULE subtype_mandatory_shape_representation FOR (shape_representation);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT ((SIZEOF([\n           'CONFIG_CONTROL_DESIGN.' + 'ADVANCED_BREP_SHAPE_REPRESENTATION',\n           'CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION',\n           'CONFIG_CONTROL_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION',\n           'CONFIG_CONTROL_DESIGN.' + \n           'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION',\n           'CONFIG_CONTROL_DESIGN.' + \n           'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION',\n           'CONFIG_CONTROL_DESIGN.' + \n           'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',\n           'CONFIG_CONTROL_DESIGN.' + \n           'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION'] * \n           TYPEOF(sr)) = 1) OR (SIZEOF(QUERY ( it <* sr\\representation.\n           items | (NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN \n           TYPEOF(it))) )) = 0) OR (SIZEOF(QUERY ( sdr <* QUERY ( pdr <* \n           USEDIN(sr,\n           'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' + \n           'USED_REPRESENTATION') | (\n           'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN \n           TYPEOF(pdr)) ) | (NOT (SIZEOF([\n           'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT',\n           'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT_RELATIONSHIP'] * TYPEOF(sdr.\n           definition.definition)) = 1)) )) = 0))) )) = 0);\n\nEND_RULE; -- subtype_mandatory_shape_representation\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE subtype_mandatory_shape_representation FOR (shape_representation);

WHERE
  wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT ((SIZEOF([
           'CONFIG_CONTROL_DESIGN.' + 'ADVANCED_BREP_SHAPE_REPRESENTATION',
           'CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION',
           'CONFIG_CONTROL_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION',
           'CONFIG_CONTROL_DESIGN.' + 
           'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION',
           'CONFIG_CONTROL_DESIGN.' + 
           'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION',
           'CONFIG_CONTROL_DESIGN.' + 
           'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
           'CONFIG_CONTROL_DESIGN.' + 
           'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION'] * 
           TYPEOF(sr)) = 1) OR (SIZEOF(QUERY ( it <* sr\representation.
           items | (NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN 
           TYPEOF(it))) )) = 0) OR (SIZEOF(QUERY ( sdr <* QUERY ( pdr <* 
           USEDIN(sr,
           'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' + 
           'USED_REPRESENTATION') | (
           'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN 
           TYPEOF(pdr)) ) | (NOT (SIZEOF([
           'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT',
           'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT_RELATIONSHIP'] * TYPEOF(sdr.
           definition.definition)) = 1)) )) = 0))) )) = 0);

END_RULE; -- subtype_mandatory_shape_representation

*/
	gr = new Global_rule("dependent_instantiable_date",s_config_control_design,"RULE dependent_instantiable_date FOR (date);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( dt <* date | (NOT (SIZEOF(USEDIN(dt,'')) >= 1)) )) \n           = 0);\n\nEND_RULE; -- dependent_instantiable_date\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_date FOR (date);

WHERE
  wr1: (SIZEOF(QUERY ( dt <* date | (NOT (SIZEOF(USEDIN(dt,'')) >= 1)) )) 
           = 0);

END_RULE; -- dependent_instantiable_date

*/
	gr = new Global_rule("configuration_item_requires_person_organization",s_config_control_design,"RULE configuration_item_requires_person_organization FOR (\n           configuration_item, cc_design_person_and_organization_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ci <* configuration_item | (NOT (SIZEOF(\n           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment\n            | (ci IN ccdpoa.items) )) = 1)) )) = 0);\n\nEND_RULE; -- configuration_item_requires_person_organization\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE configuration_item_requires_person_organization FOR (
           configuration_item, cc_design_person_and_organization_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( ci <* configuration_item | (NOT (SIZEOF(
           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
            | (ci IN ccdpoa.items) )) = 1)) )) = 0);

END_RULE; -- configuration_item_requires_person_organization

*/
	gr = new Global_rule("dependent_instantiable_document_type",s_config_control_design,"RULE dependent_instantiable_document_type FOR (document_type);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( dt <* document_type | (NOT (SIZEOF(USEDIN(dt,'')) \n           >= 1)) )) = 0);\n\nEND_RULE; -- dependent_instantiable_document_type\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_document_type FOR (document_type);

WHERE
  wr1: (SIZEOF(QUERY ( dt <* document_type | (NOT (SIZEOF(USEDIN(dt,'')) 
           >= 1)) )) = 0);

END_RULE; -- dependent_instantiable_document_type

*/
	gr = new Global_rule("restrict_contract_type",s_config_control_design,"RULE restrict_contract_type FOR (contract_type);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ct <* contract_type | (NOT (ct.description IN [\n           'fixed_price','cost_plus'])) )) = 0);\n\nEND_RULE; -- restrict_contract_type\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE restrict_contract_type FOR (contract_type);

WHERE
  wr1: (SIZEOF(QUERY ( ct <* contract_type | (NOT (ct.description IN [
           'fixed_price','cost_plus'])) )) = 0);

END_RULE; -- restrict_contract_type

*/
	gr = new Global_rule("subtype_mandatory_product_context",s_config_control_design,"RULE subtype_mandatory_product_context FOR (product_context);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( pc <* product_context | (NOT (\n           'CONFIG_CONTROL_DESIGN.MECHANICAL_CONTEXT' IN TYPEOF(pc))) )) = \n           0);\n\nEND_RULE; -- subtype_mandatory_product_context\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE subtype_mandatory_product_context FOR (product_context);

WHERE
  wr1: (SIZEOF(QUERY ( pc <* product_context | (NOT (
           'CONFIG_CONTROL_DESIGN.MECHANICAL_CONTEXT' IN TYPEOF(pc))) )) = 
           0);

END_RULE; -- subtype_mandatory_product_context

*/
	gr = new Global_rule("dependent_instantiable_parametric_representation_context",s_config_control_design,"RULE dependent_instantiable_parametric_representation_context FOR (\n           parametric_representation_context);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( prc <* parametric_representation_context | (NOT (\n           SIZEOF(USEDIN(prc,'')) >= 1)) )) = 0);\n\nEND_RULE; -- dependent_instantiable_parametric_representation_context\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_parametric_representation_context FOR (
           parametric_representation_context);

WHERE
  wr1: (SIZEOF(QUERY ( prc <* parametric_representation_context | (NOT (
           SIZEOF(USEDIN(prc,'')) >= 1)) )) = 0);

END_RULE; -- dependent_instantiable_parametric_representation_context

*/
	gr = new Global_rule("security_classification_requires_person_organization",s_config_control_design,"RULE security_classification_requires_person_organization FOR (\n           security_classification, \n           cc_design_person_and_organization_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(\n           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment\n            | (sc IN ccdpoa.items) )) = 1)) )) = 0);\n\nEND_RULE; -- security_classification_requires_person_organization\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE security_classification_requires_person_organization FOR (
           security_classification, 
           cc_design_person_and_organization_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
            | (sc IN ccdpoa.items) )) = 1)) )) = 0);

END_RULE; -- security_classification_requires_person_organization

*/
	gr = new Global_rule("dependent_instantiable_shape_representation",s_config_control_design,"RULE dependent_instantiable_shape_representation FOR (shape_representation);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT (SIZEOF(USEDIN(sr,\n           '')) >= 1)) )) = 0);\n\nEND_RULE; -- dependent_instantiable_shape_representation\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_shape_representation FOR (shape_representation);

WHERE
  wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT (SIZEOF(USEDIN(sr,
           '')) >= 1)) )) = 0);

END_RULE; -- dependent_instantiable_shape_representation

*/
	gr = new Global_rule("restrict_action_request_status",s_config_control_design,"RULE restrict_action_request_status FOR (action_request_status);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ars <* action_request_status | (NOT (ars.status IN \n           ['proposed','in_work','issued','hold'])) )) = 0);\n\nEND_RULE; -- restrict_action_request_status\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE restrict_action_request_status FOR (action_request_status);

WHERE
  wr1: (SIZEOF(QUERY ( ars <* action_request_status | (NOT (ars.status IN 
           ['proposed','in_work','issued','hold'])) )) = 0);

END_RULE; -- restrict_action_request_status

*/
	gr = new Global_rule("restrict_certification_type",s_config_control_design,"RULE restrict_certification_type FOR (certification_type);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( ct <* certification_type | (NOT (ct.description IN \n           ['design_supplier','part_supplier'])) )) = 0);\n\nEND_RULE; -- restrict_certification_type\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE restrict_certification_type FOR (certification_type);

WHERE
  wr1: (SIZEOF(QUERY ( ct <* certification_type | (NOT (ct.description IN 
           ['design_supplier','part_supplier'])) )) = 0);

END_RULE; -- restrict_certification_type

*/
	gr = new Global_rule("subtype_mandatory_action",s_config_control_design,"RULE subtype_mandatory_action FOR (action);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( act <* action | (NOT (\n           'CONFIG_CONTROL_DESIGN.DIRECTED_ACTION' IN TYPEOF(act))) )) = 0);\n\nEND_RULE; -- subtype_mandatory_action\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE subtype_mandatory_action FOR (action);

WHERE
  wr1: (SIZEOF(QUERY ( act <* action | (NOT (
           'CONFIG_CONTROL_DESIGN.DIRECTED_ACTION' IN TYPEOF(act))) )) = 0);

END_RULE; -- subtype_mandatory_action

*/
	gr = new Global_rule("product_requires_person_organization",s_config_control_design,"RULE product_requires_person_organization FOR (product, \n           cc_design_person_and_organization_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( ccdpoa <* \n           cc_design_person_and_organization_assignment | (prod IN ccdpoa.\n           items) )) = 1)) )) = 0);\n\nEND_RULE; -- product_requires_person_organization\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE product_requires_person_organization FOR (product, 
           cc_design_person_and_organization_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( ccdpoa <* 
           cc_design_person_and_organization_assignment | (prod IN ccdpoa.
           items) )) = 1)) )) = 0);

END_RULE; -- product_requires_person_organization

*/
	gr = new Global_rule("product_version_requires_security_classification",s_config_control_design,"RULE product_version_requires_security_classification FOR (\n           product_definition_formation, cc_design_security_classification);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (SIZEOF(\n           QUERY ( ccdsc <* cc_design_security_classification | (pdf IN \n           ccdsc.items) )) = 1)) )) = 0);\n\nEND_RULE; -- product_version_requires_security_classification\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE product_version_requires_security_classification FOR (
           product_definition_formation, cc_design_security_classification);

WHERE
  wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (SIZEOF(
           QUERY ( ccdsc <* cc_design_security_classification | (pdf IN 
           ccdsc.items) )) = 1)) )) = 0);

END_RULE; -- product_version_requires_security_classification

*/
	gr = new Global_rule("document_to_product_definition",s_config_control_design,"RULE document_to_product_definition FOR (cc_design_specification_reference);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sp <* cc_design_specification_reference | (NOT ((((\n           'CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' + \n           'RELATING_DOCUMENT') IN ROLESOF(sp\\document_reference.\n           assigned_document)) AND (SIZEOF(QUERY ( it <* sp.items | (NOT (\n           'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION' IN TYPEOF(it))) )) = \n           0)) OR (NOT (('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' + \n           'RELATING_DOCUMENT') IN ROLESOF(sp\\document_reference.\n           assigned_document))))) )) = 0);\n\nEND_RULE; -- document_to_product_definition\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE document_to_product_definition FOR (cc_design_specification_reference);

WHERE
  wr1: (SIZEOF(QUERY ( sp <* cc_design_specification_reference | (NOT ((((
           'CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' + 
           'RELATING_DOCUMENT') IN ROLESOF(sp\document_reference.
           assigned_document)) AND (SIZEOF(QUERY ( it <* sp.items | (NOT (
           'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION' IN TYPEOF(it))) )) = 
           0)) OR (NOT (('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' + 
           'RELATING_DOCUMENT') IN ROLESOF(sp\document_reference.
           assigned_document))))) )) = 0);

END_RULE; -- document_to_product_definition

*/
	gr = new Global_rule("start_request_requires_date_time",s_config_control_design,"RULE start_request_requires_date_time FOR (start_request, \n           cc_design_date_and_time_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(\n           QUERY ( ccdta <* cc_design_date_and_time_assignment | (sr IN \n           ccdta.items) )) = 1)) )) = 0);\n\nEND_RULE; -- start_request_requires_date_time\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE start_request_requires_date_time FOR (start_request, 
           cc_design_date_and_time_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(
           QUERY ( ccdta <* cc_design_date_and_time_assignment | (sr IN 
           ccdta.items) )) = 1)) )) = 0);

END_RULE; -- start_request_requires_date_time

*/
	gr = new Global_rule("dependent_instantiable_security_classification_level",s_config_control_design,"RULE dependent_instantiable_security_classification_level FOR (\n           security_classification_level);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( scl <* security_classification_level | (NOT (\n           SIZEOF(USEDIN(scl,'')) >= 1)) )) = 0);\n\nEND_RULE; -- dependent_instantiable_security_classification_level\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE dependent_instantiable_security_classification_level FOR (
           security_classification_level);

WHERE
  wr1: (SIZEOF(QUERY ( scl <* security_classification_level | (NOT (
           SIZEOF(USEDIN(scl,'')) >= 1)) )) = 0);

END_RULE; -- dependent_instantiable_security_classification_level

*/
	gr = new Global_rule("global_unit_assignment",s_config_control_design,"RULE global_unit_assignment FOR (global_unit_assigned_context);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT (\n           SIZEOF(guac.units) = 3)) )) = 0);\n  wr2: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT ((\n           SIZEOF(QUERY ( u <* guac.units | (\n           'CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN TYPEOF(u)) )) = 1) AND (\n           SIZEOF(QUERY ( u <* guac.units | (\n           'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF(u)) )) = 1) \n           AND (SIZEOF(QUERY ( u <* guac.units | (\n           'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF(u)) )) = 1))) )) \n           = 0);\n\nEND_RULE; -- global_unit_assignment\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE global_unit_assignment FOR (global_unit_assigned_context);

WHERE
  wr1: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT (
           SIZEOF(guac.units) = 3)) )) = 0);
  wr2: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT ((
           SIZEOF(QUERY ( u <* guac.units | (
           'CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN TYPEOF(u)) )) = 1) AND (
           SIZEOF(QUERY ( u <* guac.units | (
           'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF(u)) )) = 1) 
           AND (SIZEOF(QUERY ( u <* guac.units | (
           'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF(u)) )) = 1))) )) 
           = 0);

END_RULE; -- global_unit_assignment

*/
	gr = new Global_rule("restrict_person_organization_role",s_config_control_design,"RULE restrict_person_organization_role FOR (person_and_organization_role);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( por <* person_and_organization_role | (NOT (por.\n           name IN ['request_recipient','initiator','part_supplier',\n           'design_supplier','configuration_manager','contractor',\n           'classification_officer','creator','design_owner'])) )) = 0);\n\nEND_RULE; -- restrict_person_organization_role\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE restrict_person_organization_role FOR (person_and_organization_role);

WHERE
  wr1: (SIZEOF(QUERY ( por <* person_and_organization_role | (NOT (por.
           name IN ['request_recipient','initiator','part_supplier',
           'design_supplier','configuration_manager','contractor',
           'classification_officer','creator','design_owner'])) )) = 0);

END_RULE; -- restrict_person_organization_role

*/
	gr = new Global_rule("coordinated_assembly_and_shape",s_config_control_design,"RULE coordinated_assembly_and_shape FOR (next_assembly_usage_occurrence);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( nauo <* next_assembly_usage_occurrence | (NOT \n           assembly_shape_is_defined(nauo,'CONFIG_CONTROL_DESIGN')) )) = 0);\n\nEND_RULE; -- coordinated_assembly_and_shape\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE coordinated_assembly_and_shape FOR (next_assembly_usage_occurrence);

WHERE
  wr1: (SIZEOF(QUERY ( nauo <* next_assembly_usage_occurrence | (NOT 
           assembly_shape_is_defined(nauo,'CONFIG_CONTROL_DESIGN')) )) = 0);

END_RULE; -- coordinated_assembly_and_shape

*/
	gr = new Global_rule("start_request_requires_person_organization",s_config_control_design,"RULE start_request_requires_person_organization FOR (start_request, \n           cc_design_person_and_organization_assignment);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(\n           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment\n            | (sr IN ccdpoa.items) )) >= 1)) )) = 0);\n\nEND_RULE; -- start_request_requires_person_organization\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE start_request_requires_person_organization FOR (start_request, 
           cc_design_person_and_organization_assignment);

WHERE
  wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(
           QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
            | (sr IN ccdpoa.items) )) >= 1)) )) = 0);

END_RULE; -- start_request_requires_person_organization

*/
	gr = new Global_rule("no_shape_for_make_from",s_config_control_design,"RULE no_shape_for_make_from FOR (design_make_from_relationship);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( dmfr <* design_make_from_relationship | (NOT (\n           SIZEOF(QUERY ( pd <* USEDIN(dmfr,'CONFIG_CONTROL_DESIGN.' + \n           'PROPERTY_DEFINITION.DEFINITION') | (\n           'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) )) \n           = 0)) )) = 0);\n\nEND_RULE; -- no_shape_for_make_from\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE no_shape_for_make_from FOR (design_make_from_relationship);

WHERE
  wr1: (SIZEOF(QUERY ( dmfr <* design_make_from_relationship | (NOT (
           SIZEOF(QUERY ( pd <* USEDIN(dmfr,'CONFIG_CONTROL_DESIGN.' + 
           'PROPERTY_DEFINITION.DEFINITION') | (
           'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) )) 
           = 0)) )) = 0);

END_RULE; -- no_shape_for_make_from

*/
	gr = new Global_rule("approval_date_time_constraints",s_config_control_design,"RULE approval_date_time_constraints FOR (approval_date_time);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( adt <* approval_date_time | (NOT (SIZEOF(TYPEOF(adt\n           .date_time) * ['CONFIG_CONTROL_DESIGN.DATE_AND_TIME']) = 1)) )) \n           = 0);\n\nEND_RULE; -- approval_date_time_constraints\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE approval_date_time_constraints FOR (approval_date_time);

WHERE
  wr1: (SIZEOF(QUERY ( adt <* approval_date_time | (NOT (SIZEOF(TYPEOF(adt
           .date_time) * ['CONFIG_CONTROL_DESIGN.DATE_AND_TIME']) = 1)) )) 
           = 0);

END_RULE; -- approval_date_time_constraints

*/
	gr = new Global_rule("security_classification_requires_approval",s_config_control_design,"RULE security_classification_requires_approval FOR (\n           security_classification, cc_design_approval);\n\nWHERE\n  wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(\n           QUERY ( ccda <* cc_design_approval | (sc IN ccda.items) )) = 1)) )) \n           = 0);\n\nEND_RULE; -- security_classification_requires_approval\n");
	s_config_control_design->AddGlobal_rule(gr);
/*
RULE security_classification_requires_approval FOR (
           security_classification, cc_design_approval);

WHERE
  wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
           QUERY ( ccda <* cc_design_approval | (sc IN ccda.items) )) = 1)) )) 
           = 0);

END_RULE; -- security_classification_requires_approval

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION build_2axes(\n             ref_direction: direction\n    ): LIST [2:2] OF direction;\n\n  LOCAL\n    d : direction := NVL(normalise(ref_direction),dummy_gri || direction([\n         1,0]));\n  END_LOCAL;\n  RETURN([d,orthogonal_complement(d)]);\n\nEND_FUNCTION; -- build_2axes\n");
#endif
/*
FUNCTION build_2axes(
             ref_direction: direction
    ): LIST [2:2] OF direction;

  LOCAL
    d : direction := NVL(normalise(ref_direction),dummy_gri || direction([
         1,0]));
  END_LOCAL;
  RETURN([d,orthogonal_complement(d)]);

END_FUNCTION; -- build_2axes

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION item_in_context(\n             item: representation_item;\n             cntxt: representation_context\n    ): BOOLEAN;\n\n  LOCAL\n    i : INTEGER;\n    y : BAG OF representation_item;\n  END_LOCAL;\n  IF SIZEOF(USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS') * \n      cntxt.representations_in_context) > 0 THEN\n    RETURN(TRUE);\n  ELSE\n    y := QUERY ( z <* USEDIN(item,'') | (\n        'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );\n    IF SIZEOF(y) > 0 THEN\n      REPEAT i := 1 TO HIINDEX(y) BY 1;\n        IF item_in_context(y[i],cntxt) THEN\n          RETURN(TRUE);\n        END_IF;\n      END_REPEAT;\n    END_IF;\n  END_IF;\n  RETURN(FALSE);\n\nEND_FUNCTION; -- item_in_context\n");
#endif
/*
FUNCTION item_in_context(
             item: representation_item;
             cntxt: representation_context
    ): BOOLEAN;

  LOCAL
    i : INTEGER;
    y : BAG OF representation_item;
  END_LOCAL;
  IF SIZEOF(USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS') * 
      cntxt.representations_in_context) > 0 THEN
    RETURN(TRUE);
  ELSE
    y := QUERY ( z <* USEDIN(item,'') | (
        'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
    IF SIZEOF(y) > 0 THEN
      REPEAT i := 1 TO HIINDEX(y) BY 1;
        IF item_in_context(y[i],cntxt) THEN
          RETURN(TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(FALSE);

END_FUNCTION; -- item_in_context

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION gbsf_check_point(\n             pnt: point\n    ): BOOLEAN;\n  IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN\n    RETURN(TRUE);\n  ELSE\n    IF 'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN\n      RETURN(gbsf_check_curve(pnt\\point_on_curve.basis_curve));\n    ELSE\n      IF 'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN\n        RETURN(gbsf_check_surface(pnt\\point_on_surface.basis_surface));\n      ELSE\n        IF 'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE' IN TYPEOF(pnt) THEN\n          RETURN(gbsf_check_curve(pnt\\degenerate_pcurve.reference_to_curve\n              \\representation.items[1]) AND gbsf_check_surface(pnt\\\n              degenerate_pcurve.basis_surface));\n        END_IF;\n      END_IF;\n    END_IF;\n  END_IF;\n  RETURN(FALSE);\n\nEND_FUNCTION; -- gbsf_check_point\n");
#endif
/*
FUNCTION gbsf_check_point(
             pnt: point
    ): BOOLEAN;
  IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
    RETURN(TRUE);
  ELSE
    IF 'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
      RETURN(gbsf_check_curve(pnt\point_on_curve.basis_curve));
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN
        RETURN(gbsf_check_surface(pnt\point_on_surface.basis_surface));
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE' IN TYPEOF(pnt) THEN
          RETURN(gbsf_check_curve(pnt\degenerate_pcurve.reference_to_curve
              \representation.items[1]) AND gbsf_check_surface(pnt\
              degenerate_pcurve.basis_surface));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);

END_FUNCTION; -- gbsf_check_point

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION build_axes(\n             axis, ref_direction: direction\n    ): LIST [3:3] OF direction;\n\n  LOCAL\n    d1 : direction;\n    d2 : direction;\n  END_LOCAL;\n  d1 := NVL(normalise(axis),dummy_gri || direction([0,0,1]));\n  d2 := first_proj_axis(d1,ref_direction);\n  RETURN([d2,normalise(cross_product(d1,d2)).orientation,d1]);\n\nEND_FUNCTION; -- build_axes\n");
#endif
/*
FUNCTION build_axes(
             axis, ref_direction: direction
    ): LIST [3:3] OF direction;

  LOCAL
    d1 : direction;
    d2 : direction;
  END_LOCAL;
  d1 := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
  d2 := first_proj_axis(d1,ref_direction);
  RETURN([d2,normalise(cross_product(d1,d2)).orientation,d1]);

END_FUNCTION; -- build_axes

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION edge_reversed(\n             an_edge: edge\n    ): oriented_edge;\n\n  LOCAL\n    the_reverse : oriented_edge;\n  END_LOCAL;\n  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN\n    the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) \n        || oriented_edge(an_edge\\oriented_edge.edge_element,NOT an_edge\\\n        oriented_edge.orientation);\n  ELSE\n    the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) \n        || oriented_edge(an_edge,FALSE);\n  END_IF;\n  RETURN(the_reverse);\n\nEND_FUNCTION; -- edge_reversed\n");
#endif
/*
FUNCTION edge_reversed(
             an_edge: edge
    ): oriented_edge;

  LOCAL
    the_reverse : oriented_edge;
  END_LOCAL;
  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
    the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
        || oriented_edge(an_edge\oriented_edge.edge_element,NOT an_edge\
        oriented_edge.orientation);
  ELSE
    the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
        || oriented_edge(an_edge,FALSE);
  END_IF;
  RETURN(the_reverse);

END_FUNCTION; -- edge_reversed

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION cc_design_person_and_organization_correlation(\n             e: cc_design_person_and_organization_assignment\n    ): BOOLEAN;\n\n  LOCAL\n    po_role : STRING;\n  END_LOCAL;\n  po_role := e\\person_and_organization_assignment.role.name;\n  CASE po_role OF\n    'request_recipient'     :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (SIZEOF(['CONFIG_CONTROL_DESIGN.' + \n          'CHANGE_REQUEST','CONFIG_CONTROL_DESIGN.' + 'START_REQUEST'] * \n          TYPEOF(x)) = 1) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'initiator'             :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (SIZEOF(['CONFIG_CONTROL_DESIGN.' + \n          'CHANGE_REQUEST','CONFIG_CONTROL_DESIGN.' + 'START_REQUEST',\n          'CONFIG_CONTROL_DESIGN.' + 'START_WORK','CONFIG_CONTROL_DESIGN.' \n          + 'CHANGE'] * TYPEOF(x)) = 1) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'creator'               :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (SIZEOF(['CONFIG_CONTROL_DESIGN.' + \n          'PRODUCT_DEFINITION_FORMATION','CONFIG_CONTROL_DESIGN.' + \n          'PRODUCT_DEFINITION'] * TYPEOF(x)) = 1) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'part_supplier'         :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + \n          'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'design_supplier'       :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + \n          'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'design_owner'          :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | ('CONFIG_CONTROL_DESIGN.PRODUCT' IN \n          TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'configuration_manager' :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + \n          'CONFIGURATION_ITEM') IN TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'contractor'            :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | ('CONFIG_CONTROL_DESIGN.CONTRACT' IN \n          TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'classification_officer'  :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + \n          'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    OTHERWISE               :       RETURN(TRUE);\n    END_CASE;\n  RETURN(TRUE);\n\nEND_FUNCTION; -- cc_design_person_and_organization_correlation\n");
#endif
/*
FUNCTION cc_design_person_and_organization_correlation(
             e: cc_design_person_and_organization_assignment
    ): BOOLEAN;

  LOCAL
    po_role : STRING;
  END_LOCAL;
  po_role := e\person_and_organization_assignment.role.name;
  CASE po_role OF
    'request_recipient'     :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (SIZEOF(['CONFIG_CONTROL_DESIGN.' + 
          'CHANGE_REQUEST','CONFIG_CONTROL_DESIGN.' + 'START_REQUEST'] * 
          TYPEOF(x)) = 1) )) THEN
        RETURN(FALSE);
      END_IF;
    'initiator'             :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (SIZEOF(['CONFIG_CONTROL_DESIGN.' + 
          'CHANGE_REQUEST','CONFIG_CONTROL_DESIGN.' + 'START_REQUEST',
          'CONFIG_CONTROL_DESIGN.' + 'START_WORK','CONFIG_CONTROL_DESIGN.' 
          + 'CHANGE'] * TYPEOF(x)) = 1) )) THEN
        RETURN(FALSE);
      END_IF;
    'creator'               :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (SIZEOF(['CONFIG_CONTROL_DESIGN.' + 
          'PRODUCT_DEFINITION_FORMATION','CONFIG_CONTROL_DESIGN.' + 
          'PRODUCT_DEFINITION'] * TYPEOF(x)) = 1) )) THEN
        RETURN(FALSE);
      END_IF;
    'part_supplier'         :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + 
          'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    'design_supplier'       :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + 
          'PRODUCT_DEFINITION_FORMATION') IN TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    'design_owner'          :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | ('CONFIG_CONTROL_DESIGN.PRODUCT' IN 
          TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    'configuration_manager' :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + 
          'CONFIGURATION_ITEM') IN TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    'contractor'            :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | ('CONFIG_CONTROL_DESIGN.CONTRACT' IN 
          TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    'classification_officer'  :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + 
          'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    OTHERWISE               :       RETURN(TRUE);
    END_CASE;
  RETURN(TRUE);

END_FUNCTION; -- cc_design_person_and_organization_correlation

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION constraints_composite_curve_on_surface(\n             c: composite_curve_on_surface\n    ): BOOLEAN;\n\n  LOCAL\n    n_segments : INTEGER := SIZEOF(c.segments);\n  END_LOCAL;\n  REPEAT k := 1 TO n_segments BY 1;\n    IF (NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c\\composite_curve.\n        segments[k].parent_curve))) AND (NOT (\n        'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c\\composite_curve.\n        segments[k].parent_curve))) AND (NOT (\n        'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\\\n        composite_curve.segments[k].parent_curve))) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_REPEAT;\n  RETURN(TRUE);\n\nEND_FUNCTION; -- constraints_composite_curve_on_surface\n");
#endif
/*
FUNCTION constraints_composite_curve_on_surface(
             c: composite_curve_on_surface
    ): BOOLEAN;

  LOCAL
    n_segments : INTEGER := SIZEOF(c.segments);
  END_LOCAL;
  REPEAT k := 1 TO n_segments BY 1;
    IF (NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c\composite_curve.
        segments[k].parent_curve))) AND (NOT (
        'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c\composite_curve.
        segments[k].parent_curve))) AND (NOT (
        'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\
        composite_curve.segments[k].parent_curve))) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);

END_FUNCTION; -- constraints_composite_curve_on_surface

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION acyclic_mapped_representation(\n             parent_set: SET OF representation;\n             children_set: SET OF representation_item\n    ): BOOLEAN;\n\n  LOCAL\n    i : INTEGER;\n    x : SET OF representation_item;\n    y : SET OF representation_item;\n  END_LOCAL;\n  x := QUERY ( z <* children_set | ('CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN\n       TYPEOF(z)) );\n  IF SIZEOF(x) > 0 THEN\n    REPEAT i := 1 TO HIINDEX(x) BY 1;\n      IF x[i]\\mapped_item.mapping_source.mapped_representation IN \n          parent_set THEN\n        RETURN(FALSE);\n      END_IF;\n      IF NOT acyclic_mapped_representation(parent_set + x[i]\\mapped_item.\n          mapping_source.mapped_representation,x[i]\\mapped_item.\n          mapping_source.mapped_representation.items) THEN\n        RETURN(FALSE);\n      END_IF;\n    END_REPEAT;\n  END_IF;\n  x := children_set - x;\n  IF SIZEOF(x) > 0 THEN\n    REPEAT i := 1 TO HIINDEX(x) BY 1;\n      y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | (\n          'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );\n      IF NOT acyclic_mapped_representation(parent_set,y) THEN\n        RETURN(FALSE);\n      END_IF;\n    END_REPEAT;\n  END_IF;\n  RETURN(TRUE);\n\nEND_FUNCTION; -- acyclic_mapped_representation\n");
#endif
/*
FUNCTION acyclic_mapped_representation(
             parent_set: SET OF representation;
             children_set: SET OF representation_item
    ): BOOLEAN;

  LOCAL
    i : INTEGER;
    x : SET OF representation_item;
    y : SET OF representation_item;
  END_LOCAL;
  x := QUERY ( z <* children_set | ('CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN
       TYPEOF(z)) );
  IF SIZEOF(x) > 0 THEN
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF x[i]\mapped_item.mapping_source.mapped_representation IN 
          parent_set THEN
        RETURN(FALSE);
      END_IF;
      IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item.
          mapping_source.mapped_representation,x[i]\mapped_item.
          mapping_source.mapped_representation.items) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  x := children_set - x;
  IF SIZEOF(x) > 0 THEN
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | (
          'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
      IF NOT acyclic_mapped_representation(parent_set,y) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(TRUE);

END_FUNCTION; -- acyclic_mapped_representation

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION conditional_reverse(\n             p: BOOLEAN;\n             an_item: reversible_topology\n    ): reversible_topology;\n  IF p THEN\n    RETURN(an_item);\n  ELSE\n    RETURN(topology_reversed(an_item));\n  END_IF;\n\nEND_FUNCTION; -- conditional_reverse\n");
#endif
/*
FUNCTION conditional_reverse(
             p: BOOLEAN;
             an_item: reversible_topology
    ): reversible_topology;
  IF p THEN
    RETURN(an_item);
  ELSE
    RETURN(topology_reversed(an_item));
  END_IF;

END_FUNCTION; -- conditional_reverse

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION valid_measure_value(\n             m: measure_value\n    ): BOOLEAN;\n  IF 'REAL' IN TYPEOF(m) THEN\n    RETURN(m > 0);\n  ELSE\n    IF 'INTEGER' IN TYPEOF(m) THEN\n      RETURN(m > 0);\n    ELSE\n      RETURN(TRUE);\n    END_IF;\n  END_IF;\n\nEND_FUNCTION; -- valid_measure_value\n");
#endif
/*
FUNCTION valid_measure_value(
             m: measure_value
    ): BOOLEAN;
  IF 'REAL' IN TYPEOF(m) THEN
    RETURN(m > 0);
  ELSE
    IF 'INTEGER' IN TYPEOF(m) THEN
      RETURN(m > 0);
    ELSE
      RETURN(TRUE);
    END_IF;
  END_IF;

END_FUNCTION; -- valid_measure_value

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION gbsf_check_curve(\n             cv: curve\n    ): BOOLEAN;\n  IF SIZEOF(['CONFIG_CONTROL_DESIGN.BOUNDED_CURVE',\n      'CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.CURVE_REPLICA',\n      'CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'] \n      * TYPEOF(cv)) > 1 THEN\n    RETURN(FALSE);\n  ELSE\n    IF SIZEOF(['CONFIG_CONTROL_DESIGN.CIRCLE',\n        'CONFIG_CONTROL_DESIGN.ELLIPSE'] * TYPEOF(cv)) = 1 THEN\n      RETURN(TRUE);\n    ELSE\n      IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\\\n          b_spline_curve.self_intersect = FALSE)) OR (cv\\b_spline_curve.\n          self_intersect = UNKNOWN) THEN\n        RETURN(TRUE);\n      ELSE\n        IF (('CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE' IN TYPEOF(cv)) AND (\n            cv\\composite_curve.self_intersect = FALSE)) OR (cv\\\n            composite_curve.self_intersect = UNKNOWN) THEN\n          RETURN(SIZEOF(QUERY ( seg <* cv\\composite_curve.segments | (NOT \n              gbsf_check_curve(seg.parent_curve)) )) = 0);\n        ELSE\n          IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(cv) THEN\n            RETURN(gbsf_check_curve(cv\\curve_replica.parent_curve));\n          ELSE\n            IF ('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND\n                 ((cv\\offset_curve_3d.self_intersect = FALSE) OR (cv\\\n                offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (\n                'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv.basis_curve)))\n                 THEN\n              RETURN(gbsf_check_curve(cv\\offset_curve_3d.basis_curve));\n            ELSE\n              IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv) THEN\n                RETURN(gbsf_check_curve(cv\\pcurve.reference_to_curve\\\n                    representation.items[1]) AND gbsf_check_surface(cv\\\n                    pcurve.basis_surface));\n              ELSE\n                IF 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv) THEN\n                  IF SIZEOF(cv\\polyline.points) >= 3 THEN\n                    RETURN(TRUE);\n                  END_IF;\n                ELSE\n                  IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(cv)\n                       THEN\n                    IF gbsf_check_curve(cv\\surface_curve.curve_3d) THEN\n                      REPEAT i := 1 TO SIZEOF(cv\\surface_curve.\n                          associated_geometry) BY 1;\n                        IF 'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(cv\\\n                            surface_curve.associated_geometry[i]) THEN\n                          IF NOT gbsf_check_surface(cv\\surface_curve.\n                              associated_geometry[i]) THEN\n                            RETURN(FALSE);\n                          END_IF;\n                        ELSE\n                          IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv\\\n                              surface_curve.associated_geometry[i]) THEN\n                            IF NOT gbsf_check_curve(cv\\surface_curve.\n                                associated_geometry[i]) THEN\n                              RETURN(FALSE);\n                            END_IF;\n                          END_IF;\n                        END_IF;\n                      END_REPEAT;\n                      RETURN(TRUE);\n                    END_IF;\n                  ELSE\n                    IF 'CONFIG_CONTROL_DESIGN.TRIMMED_CURVE' IN TYPEOF(cv)\n                         THEN\n                      IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',\n                          'CONFIG_CONTROL_DESIGN.PARABOLA',\n                          'CONFIG_CONTROL_DESIGN.HYPERBOLA'] * TYPEOF(cv\\\n                          trimmed_curve.basis_curve)) = 1 THEN\n                        RETURN(TRUE);\n                      ELSE\n                        RETURN(gbsf_check_curve(cv\\trimmed_curve.\n                            basis_curve));\n                      END_IF;\n                    END_IF;\n                  END_IF;\n                END_IF;\n              END_IF;\n            END_IF;\n          END_IF;\n        END_IF;\n      END_IF;\n    END_IF;\n  END_IF;\n  RETURN(FALSE);\n\nEND_FUNCTION; -- gbsf_check_curve\n");
#endif
/*
FUNCTION gbsf_check_curve(
             cv: curve
    ): BOOLEAN;
  IF SIZEOF(['CONFIG_CONTROL_DESIGN.BOUNDED_CURVE',
      'CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.CURVE_REPLICA',
      'CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'] 
      * TYPEOF(cv)) > 1 THEN
    RETURN(FALSE);
  ELSE
    IF SIZEOF(['CONFIG_CONTROL_DESIGN.CIRCLE',
        'CONFIG_CONTROL_DESIGN.ELLIPSE'] * TYPEOF(cv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\
          b_spline_curve.self_intersect = FALSE)) OR (cv\b_spline_curve.
          self_intersect = UNKNOWN) THEN
        RETURN(TRUE);
      ELSE
        IF (('CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE' IN TYPEOF(cv)) AND (
            cv\composite_curve.self_intersect = FALSE)) OR (cv\
            composite_curve.self_intersect = UNKNOWN) THEN
          RETURN(SIZEOF(QUERY ( seg <* cv\composite_curve.segments | (NOT 
              gbsf_check_curve(seg.parent_curve)) )) = 0);
        ELSE
          IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(cv) THEN
            RETURN(gbsf_check_curve(cv\curve_replica.parent_curve));
          ELSE
            IF ('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND
                 ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\
                offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (
                'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv.basis_curve)))
                 THEN
              RETURN(gbsf_check_curve(cv\offset_curve_3d.basis_curve));
            ELSE
              IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv) THEN
                RETURN(gbsf_check_curve(cv\pcurve.reference_to_curve\
                    representation.items[1]) AND gbsf_check_surface(cv\
                    pcurve.basis_surface));
              ELSE
                IF 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv) THEN
                  IF SIZEOF(cv\polyline.points) >= 3 THEN
                    RETURN(TRUE);
                  END_IF;
                ELSE
                  IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(cv)
                       THEN
                    IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                      REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                          associated_geometry) BY 1;
                        IF 'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(cv\
                            surface_curve.associated_geometry[i]) THEN
                          IF NOT gbsf_check_surface(cv\surface_curve.
                              associated_geometry[i]) THEN
                            RETURN(FALSE);
                          END_IF;
                        ELSE
                          IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv\
                              surface_curve.associated_geometry[i]) THEN
                            IF NOT gbsf_check_curve(cv\surface_curve.
                                associated_geometry[i]) THEN
                              RETURN(FALSE);
                            END_IF;
                          END_IF;
                        END_IF;
                      END_REPEAT;
                      RETURN(TRUE);
                    END_IF;
                  ELSE
                    IF 'CONFIG_CONTROL_DESIGN.TRIMMED_CURVE' IN TYPEOF(cv)
                         THEN
                      IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',
                          'CONFIG_CONTROL_DESIGN.PARABOLA',
                          'CONFIG_CONTROL_DESIGN.HYPERBOLA'] * TYPEOF(cv\
                          trimmed_curve.basis_curve)) = 1 THEN
                        RETURN(TRUE);
                      ELSE
                        RETURN(gbsf_check_curve(cv\trimmed_curve.
                            basis_curve));
                      END_IF;
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);

END_FUNCTION; -- gbsf_check_curve

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION unique_version_change_order(\n             c: action\n    ): BOOLEAN;\n\n  LOCAL\n    ords     : action_directive := c\\directed_action.directive;\n    assign   : SET OF change_request := [];\n    versions : SET OF product_definition_formation := [];\n  END_LOCAL;\n  REPEAT i := 1 TO SIZEOF(ords.requests) BY 1;\n    assign := assign + QUERY ( ara <* bag_to_set(USEDIN(ords.requests[i],\n        'CONFIG_CONTROL_DESIGN.ACTION_REQUEST_ASSIGNMENT.' + \n        'ASSIGNED_ACTION_REQUEST')) | (\n        'CONFIG_CONTROL_DESIGN.CHANGE_REQUEST' IN TYPEOF(ara)) );\n  END_REPEAT;\n  REPEAT k := 1 TO SIZEOF(assign) BY 1;\n    versions := versions + assign[k].items;\n  END_REPEAT;\n  RETURN(SIZEOF(QUERY ( vers <* versions | (NOT (SIZEOF(\n      QUERY ( other_vers <* (versions - vers) | (vers.of_product :=: \n      other_vers.of_product) )) = 0)) )) = 0);\n\nEND_FUNCTION; -- unique_version_change_order\n");
#endif
/*
FUNCTION unique_version_change_order(
             c: action
    ): BOOLEAN;

  LOCAL
    ords     : action_directive := c\directed_action.directive;
    assign   : SET OF change_request := [];
    versions : SET OF product_definition_formation := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF(ords.requests) BY 1;
    assign := assign + QUERY ( ara <* bag_to_set(USEDIN(ords.requests[i],
        'CONFIG_CONTROL_DESIGN.ACTION_REQUEST_ASSIGNMENT.' + 
        'ASSIGNED_ACTION_REQUEST')) | (
        'CONFIG_CONTROL_DESIGN.CHANGE_REQUEST' IN TYPEOF(ara)) );
  END_REPEAT;
  REPEAT k := 1 TO SIZEOF(assign) BY 1;
    versions := versions + assign[k].items;
  END_REPEAT;
  RETURN(SIZEOF(QUERY ( vers <* versions | (NOT (SIZEOF(
      QUERY ( other_vers <* (versions - vers) | (vers.of_product :=: 
      other_vers.of_product) )) = 0)) )) = 0);

END_FUNCTION; -- unique_version_change_order

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION base_axis(\n             dim: INTEGER;\n             axis1, axis2, axis3: direction\n    ): LIST [2:3] OF direction;\n\n  LOCAL\n    u      : LIST [2:3] OF direction;\n    d1     : direction;\n    d2     : direction;\n    factor : REAL;\n  END_LOCAL;\n  IF dim = 3 THEN\n    d1 := NVL(normalise(axis3),dummy_gri || direction([0,0,1]));\n    d2 := first_proj_axis(d1,axis1);\n    u := [d2,second_proj_axis(d1,d2,axis2),d1];\n  ELSE\n    IF EXISTS(axis1) THEN\n      d1 := normalise(axis1);\n      u := [d1,orthogonal_complement(d1)];\n      IF EXISTS(axis2) THEN\n        factor := dot_product(axis2,u[2]);\n        IF factor < 0 THEN\n          u[2].direction_ratios[1] := -u[2].direction_ratios[1];\n          u[2].direction_ratios[2] := -u[2].direction_ratios[2];\n        END_IF;\n      END_IF;\n    ELSE\n      IF EXISTS(axis2) THEN\n        d1 := normalise(axis2);\n        u := [orthogonal_complement(d1),d1];\n        u[1].direction_ratios[1] := -u[1].direction_ratios[1];\n        u[1].direction_ratios[2] := -u[1].direction_ratios[2];\n      ELSE\n        u := [dummy_gri || direction([1,0]),dummy_gri || direction([0,1])];\n      END_IF;\n    END_IF;\n  END_IF;\n  RETURN(u);\n\nEND_FUNCTION; -- base_axis\n");
#endif
/*
FUNCTION base_axis(
             dim: INTEGER;
             axis1, axis2, axis3: direction
    ): LIST [2:3] OF direction;

  LOCAL
    u      : LIST [2:3] OF direction;
    d1     : direction;
    d2     : direction;
    factor : REAL;
  END_LOCAL;
  IF dim = 3 THEN
    d1 := NVL(normalise(axis3),dummy_gri || direction([0,0,1]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2,second_proj_axis(d1,d2,axis2),d1];
  ELSE
    IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1,orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF factor < 0 THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1),d1];
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1,0]),dummy_gri || direction([0,1])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);

END_FUNCTION; -- base_axis

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION get_basis_surface(\n             c: curve_on_surface\n    ): SET [0:2] OF surface;\n\n  LOCAL\n    surfs : SET [0:2] OF surface;\n    n     : INTEGER;\n  END_LOCAL;\n  surfs := [];\n  IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c) THEN\n    surfs := [c\\pcurve.basis_surface];\n  ELSE\n    IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c) THEN\n      n := SIZEOF(c\\surface_curve.associated_geometry);\n      REPEAT i := 1 TO n BY 1;\n        surfs := surfs + associated_surface(c\\surface_curve.\n            associated_geometry[i]);\n      END_REPEAT;\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c) THEN\n    n := SIZEOF(c\\composite_curve.segments);\n    surfs := get_basis_surface(c\\composite_curve.segments[1].parent_curve);\n    IF n > 1 THEN\n      REPEAT i := 2 TO n BY 1;\n        surfs := surfs * get_basis_surface(c\\composite_curve.segments[i].\n            parent_curve);\n      END_REPEAT;\n    END_IF;\n  END_IF;\n  RETURN(surfs);\n\nEND_FUNCTION; -- get_basis_surface\n");
#endif
/*
FUNCTION get_basis_surface(
             c: curve_on_surface
    ): SET [0:2] OF surface;

  LOCAL
    surfs : SET [0:2] OF surface;
    n     : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n BY 1;
        surfs := surfs + associated_surface(c\surface_curve.
            associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c) THEN
    n := SIZEOF(c\composite_curve.segments);
    surfs := get_basis_surface(c\composite_curve.segments[1].parent_curve);
    IF n > 1 THEN
      REPEAT i := 2 TO n BY 1;
        surfs := surfs * get_basis_surface(c\composite_curve.segments[i].
            parent_curve);
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(surfs);

END_FUNCTION; -- get_basis_surface

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION cc_design_date_time_correlation(\n             e: cc_design_date_and_time_assignment\n    ): BOOLEAN;\n\n  LOCAL\n    dt_role : STRING;\n  END_LOCAL;\n  dt_role := e\\date_and_time_assignment.role.name;\n  CASE dt_role OF\n    'creation_date'        :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + \n          'PRODUCT_DEFINITION') IN TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'request_date'         :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (SIZEOF([\n          'CONFIG_CONTROL_DESIGN.CHANGE_REQUEST',\n          'CONFIG_CONTROL_DESIGN.START_REQUEST'] * TYPEOF(x)) = 1) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'release_date'         :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (SIZEOF(['CONFIG_CONTROL_DESIGN.CHANGE',\n          'CONFIG_CONTROL_DESIGN.START_WORK'] * TYPEOF(x)) = 1) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'start_date'           :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (SIZEOF(['CONFIG_CONTROL_DESIGN.CHANGE',\n          'CONFIG_CONTROL_DESIGN.START_WORK'] * TYPEOF(x)) = 1) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'sign_off_date'        :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + \n          'APPROVAL_PERSON_ORGANIZATION') IN TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'contract_date'        :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | ('CONFIG_CONTROL_DESIGN.CONTRACT' IN \n          TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'certification_date'   :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | ('CONFIG_CONTROL_DESIGN.CERTIFICATION' IN \n          TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'classification_date'  :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + \n          'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    'declassification_date'  :       IF SIZEOF(e.items) <> SIZEOF(\n          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + \n          'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN\n        RETURN(FALSE);\n      END_IF;\n    OTHERWISE              :       RETURN(TRUE);\n    END_CASE;\n  RETURN(TRUE);\n\nEND_FUNCTION; -- cc_design_date_time_correlation\n");
#endif
/*
FUNCTION cc_design_date_time_correlation(
             e: cc_design_date_and_time_assignment
    ): BOOLEAN;

  LOCAL
    dt_role : STRING;
  END_LOCAL;
  dt_role := e\date_and_time_assignment.role.name;
  CASE dt_role OF
    'creation_date'        :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + 
          'PRODUCT_DEFINITION') IN TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    'request_date'         :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (SIZEOF([
          'CONFIG_CONTROL_DESIGN.CHANGE_REQUEST',
          'CONFIG_CONTROL_DESIGN.START_REQUEST'] * TYPEOF(x)) = 1) )) THEN
        RETURN(FALSE);
      END_IF;
    'release_date'         :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (SIZEOF(['CONFIG_CONTROL_DESIGN.CHANGE',
          'CONFIG_CONTROL_DESIGN.START_WORK'] * TYPEOF(x)) = 1) )) THEN
        RETURN(FALSE);
      END_IF;
    'start_date'           :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (SIZEOF(['CONFIG_CONTROL_DESIGN.CHANGE',
          'CONFIG_CONTROL_DESIGN.START_WORK'] * TYPEOF(x)) = 1) )) THEN
        RETURN(FALSE);
      END_IF;
    'sign_off_date'        :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + 
          'APPROVAL_PERSON_ORGANIZATION') IN TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    'contract_date'        :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | ('CONFIG_CONTROL_DESIGN.CONTRACT' IN 
          TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    'certification_date'   :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | ('CONFIG_CONTROL_DESIGN.CERTIFICATION' IN 
          TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    'classification_date'  :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + 
          'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    'declassification_date'  :       IF SIZEOF(e.items) <> SIZEOF(
          QUERY ( x <* e.items | (('CONFIG_CONTROL_DESIGN.' + 
          'SECURITY_CLASSIFICATION') IN TYPEOF(x)) )) THEN
        RETURN(FALSE);
      END_IF;
    OTHERWISE              :       RETURN(TRUE);
    END_CASE;
  RETURN(TRUE);

END_FUNCTION; -- cc_design_date_time_correlation

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION list_face_loops(\n             f: face\n    ): LIST [0:?] OF loop;\n\n  LOCAL\n    loops : LIST [0:?] OF loop := [];\n  END_LOCAL;\n  REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;\n    loops := loops + f.bounds[i].bound;\n  END_REPEAT;\n  RETURN(loops);\n\nEND_FUNCTION; -- list_face_loops\n");
#endif
/*
FUNCTION list_face_loops(
             f: face
    ): LIST [0:?] OF loop;

  LOCAL
    loops : LIST [0:?] OF loop := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
    loops := loops + f.bounds[i].bound;
  END_REPEAT;
  RETURN(loops);

END_FUNCTION; -- list_face_loops

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION list_of_topology_reversed(\n             a_list: list_of_reversible_topology_item\n    ): list_of_reversible_topology_item;\n\n  LOCAL\n    the_reverse : list_of_reversible_topology_item;\n  END_LOCAL;\n  the_reverse := [];\n  REPEAT i := 1 TO SIZEOF(a_list) BY 1;\n    the_reverse := topology_reversed(a_list[i]) + the_reverse;\n  END_REPEAT;\n  RETURN(the_reverse);\n\nEND_FUNCTION; -- list_of_topology_reversed\n");
#endif
/*
FUNCTION list_of_topology_reversed(
             a_list: list_of_reversible_topology_item
    ): list_of_reversible_topology_item;

  LOCAL
    the_reverse : list_of_reversible_topology_item;
  END_LOCAL;
  the_reverse := [];
  REPEAT i := 1 TO SIZEOF(a_list) BY 1;
    the_reverse := topology_reversed(a_list[i]) + the_reverse;
  END_REPEAT;
  RETURN(the_reverse);

END_FUNCTION; -- list_of_topology_reversed

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION msf_curve_check(\n             cv: curve\n    ): BOOLEAN;\n  IF SIZEOF(['CONFIG_CONTROL_DESIGN.BOUNDED_CURVE',\n      'CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.CURVE_REPLICA',\n      'CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'] \n      * TYPEOF(cv)) > 1 THEN\n    RETURN(FALSE);\n  ELSE\n    IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\\\n        b_spline_curve.self_intersect = FALSE)) OR (cv\\b_spline_curve.\n        self_intersect = UNKNOWN) THEN\n      RETURN(TRUE);\n    ELSE\n      IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONIC',\n          'CONFIG_CONTROL_DESIGN.LINE'] * TYPEOF(cv)) = 1 THEN\n        RETURN(TRUE);\n      ELSE\n        IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(cv) THEN\n          RETURN(msf_curve_check(cv\\curve_replica.parent_curve));\n        ELSE\n          IF ('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND (\n              (cv\\offset_curve_3d.self_intersect = FALSE) OR (cv\\\n              offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (\n              'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv.basis_curve)))\n               THEN\n            RETURN(msf_curve_check(cv\\offset_curve_3d.basis_curve));\n          ELSE\n            IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv) THEN\n              RETURN(msf_curve_check(cv\\pcurve.reference_to_curve\\\n                  representation.items[1]) AND msf_surface_check(cv\\pcurve.\n                  basis_surface));\n            ELSE\n              IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(cv) THEN\n                IF msf_curve_check(cv\\surface_curve.curve_3d) THEN\n                  REPEAT i := 1 TO SIZEOF(cv\\surface_curve.\n                      associated_geometry) BY 1;\n                    IF 'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(cv\\\n                        surface_curve.associated_geometry[i]) THEN\n                      IF NOT msf_surface_check(cv\\surface_curve.\n                          associated_geometry[i]) THEN\n                        RETURN(FALSE);\n                      END_IF;\n                    ELSE\n                      IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv\\\n                          surface_curve.associated_geometry[i]) THEN\n                        IF NOT msf_curve_check(cv\\surface_curve.\n                            associated_geometry[i]) THEN\n                          RETURN(FALSE);\n                        END_IF;\n                      END_IF;\n                    END_IF;\n                  END_REPEAT;\n                  RETURN(TRUE);\n                END_IF;\n              ELSE\n                IF 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv) THEN\n                  IF SIZEOF(cv\\polyline.points) >= 3 THEN\n                    RETURN(TRUE);\n                  END_IF;\n                END_IF;\n              END_IF;\n            END_IF;\n          END_IF;\n        END_IF;\n      END_IF;\n    END_IF;\n  END_IF;\n  RETURN(FALSE);\n\nEND_FUNCTION; -- msf_curve_check\n");
#endif
/*
FUNCTION msf_curve_check(
             cv: curve
    ): BOOLEAN;
  IF SIZEOF(['CONFIG_CONTROL_DESIGN.BOUNDED_CURVE',
      'CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.CURVE_REPLICA',
      'CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'] 
      * TYPEOF(cv)) > 1 THEN
    RETURN(FALSE);
  ELSE
    IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\
        b_spline_curve.self_intersect = FALSE)) OR (cv\b_spline_curve.
        self_intersect = UNKNOWN) THEN
      RETURN(TRUE);
    ELSE
      IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONIC',
          'CONFIG_CONTROL_DESIGN.LINE'] * TYPEOF(cv)) = 1 THEN
        RETURN(TRUE);
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(cv) THEN
          RETURN(msf_curve_check(cv\curve_replica.parent_curve));
        ELSE
          IF ('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND (
              (cv\offset_curve_3d.self_intersect = FALSE) OR (cv\
              offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (
              'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv.basis_curve)))
               THEN
            RETURN(msf_curve_check(cv\offset_curve_3d.basis_curve));
          ELSE
            IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv) THEN
              RETURN(msf_curve_check(cv\pcurve.reference_to_curve\
                  representation.items[1]) AND msf_surface_check(cv\pcurve.
                  basis_surface));
            ELSE
              IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(cv) THEN
                IF msf_curve_check(cv\surface_curve.curve_3d) THEN
                  REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                      associated_geometry) BY 1;
                    IF 'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(cv\
                        surface_curve.associated_geometry[i]) THEN
                      IF NOT msf_surface_check(cv\surface_curve.
                          associated_geometry[i]) THEN
                        RETURN(FALSE);
                      END_IF;
                    ELSE
                      IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv\
                          surface_curve.associated_geometry[i]) THEN
                        IF NOT msf_curve_check(cv\surface_curve.
                            associated_geometry[i]) THEN
                          RETURN(FALSE);
                        END_IF;
                      END_IF;
                    END_IF;
                  END_REPEAT;
                  RETURN(TRUE);
                END_IF;
              ELSE
                IF 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv) THEN
                  IF SIZEOF(cv\polyline.points) >= 3 THEN
                    RETURN(TRUE);
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);

END_FUNCTION; -- msf_curve_check

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION shell_reversed(\n             a_shell: shell\n    ): shell;\n  IF 'CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(a_shell) THEN\n    RETURN(open_shell_reversed(a_shell));\n  ELSE\n    IF 'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(a_shell) THEN\n      RETURN(closed_shell_reversed(a_shell));\n    ELSE\n      RETURN(?);\n    END_IF;\n  END_IF;\n\nEND_FUNCTION; -- shell_reversed\n");
#endif
/*
FUNCTION shell_reversed(
             a_shell: shell
    ): shell;
  IF 'CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(a_shell) THEN
    RETURN(open_shell_reversed(a_shell));
  ELSE
    IF 'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
      RETURN(closed_shell_reversed(a_shell));
    ELSE
      RETURN(?);
    END_IF;
  END_IF;

END_FUNCTION; -- shell_reversed

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION topology_reversed(\n             an_item: reversible_topology\n    ): reversible_topology;\n  IF 'CONFIG_CONTROL_DESIGN.EDGE' IN TYPEOF(an_item) THEN\n    RETURN(edge_reversed(an_item));\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.PATH' IN TYPEOF(an_item) THEN\n    RETURN(path_reversed(an_item));\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.FACE_BOUND' IN TYPEOF(an_item) THEN\n    RETURN(face_bound_reversed(an_item));\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.FACE' IN TYPEOF(an_item) THEN\n    RETURN(face_reversed(an_item));\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.SHELL' IN TYPEOF(an_item) THEN\n    RETURN(shell_reversed(an_item));\n  END_IF;\n  IF 'SET' IN TYPEOF(an_item) THEN\n    RETURN(set_of_topology_reversed(an_item));\n  END_IF;\n  IF 'LIST' IN TYPEOF(an_item) THEN\n    RETURN(list_of_topology_reversed(an_item));\n  END_IF;\n  RETURN(?);\n\nEND_FUNCTION; -- topology_reversed\n");
#endif
/*
FUNCTION topology_reversed(
             an_item: reversible_topology
    ): reversible_topology;
  IF 'CONFIG_CONTROL_DESIGN.EDGE' IN TYPEOF(an_item) THEN
    RETURN(edge_reversed(an_item));
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.PATH' IN TYPEOF(an_item) THEN
    RETURN(path_reversed(an_item));
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.FACE_BOUND' IN TYPEOF(an_item) THEN
    RETURN(face_bound_reversed(an_item));
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.FACE' IN TYPEOF(an_item) THEN
    RETURN(face_reversed(an_item));
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.SHELL' IN TYPEOF(an_item) THEN
    RETURN(shell_reversed(an_item));
  END_IF;
  IF 'SET' IN TYPEOF(an_item) THEN
    RETURN(set_of_topology_reversed(an_item));
  END_IF;
  IF 'LIST' IN TYPEOF(an_item) THEN
    RETURN(list_of_topology_reversed(an_item));
  END_IF;
  RETURN(?);

END_FUNCTION; -- topology_reversed

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION first_proj_axis(\n             z_axis, arg: direction\n    ): direction;\n\n  LOCAL\n    x_vec  : vector;\n    v      : direction;\n    z      : direction;\n    x_axis : direction;\n  END_LOCAL;\n  IF NOT EXISTS(z_axis) THEN\n    RETURN(?);\n  ELSE\n    z := normalise(z_axis);\n    IF NOT EXISTS(arg) THEN\n      IF z.direction_ratios <> [1,0,0] THEN\n        v := dummy_gri || direction([1,0,0]);\n      ELSE\n        v := dummy_gri || direction([0,1,0]);\n      END_IF;\n    ELSE\n      IF arg.dim <> 3 THEN\n        RETURN(?);\n      END_IF;\n      IF cross_product(arg,z).magnitude = 0 THEN\n        RETURN(?);\n      ELSE\n        v := normalise(arg);\n      END_IF;\n    END_IF;\n    x_vec := scalar_times_vector(dot_product(v,z),z);\n    x_axis := vector_difference(v,x_vec).orientation;\n    x_axis := normalise(x_axis);\n  END_IF;\n  RETURN(x_axis);\n\nEND_FUNCTION; -- first_proj_axis\n");
#endif
/*
FUNCTION first_proj_axis(
             z_axis, arg: direction
    ): direction;

  LOCAL
    x_vec  : vector;
    v      : direction;
    z      : direction;
    x_axis : direction;
  END_LOCAL;
  IF NOT EXISTS(z_axis) THEN
    RETURN(?);
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF z.direction_ratios <> [1,0,0] THEN
        v := dummy_gri || direction([1,0,0]);
      ELSE
        v := dummy_gri || direction([0,1,0]);
      END_IF;
    ELSE
      IF arg.dim <> 3 THEN
        RETURN(?);
      END_IF;
      IF cross_product(arg,z).magnitude = 0 THEN
        RETURN(?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v,z),z);
    x_axis := vector_difference(v,x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);

END_FUNCTION; -- first_proj_axis

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION orthogonal_complement(\n             vec: direction\n    ): direction;\n\n  LOCAL\n    result : direction;\n  END_LOCAL;\n  IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN\n    RETURN(?);\n  ELSE\n    result := dummy_gri || direction([-vec.direction_ratios[2],vec.\n        direction_ratios[1]]);\n    RETURN(result);\n  END_IF;\n\nEND_FUNCTION; -- orthogonal_complement\n");
#endif
/*
FUNCTION orthogonal_complement(
             vec: direction
    ): direction;

  LOCAL
    result : direction;
  END_LOCAL;
  IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN
    RETURN(?);
  ELSE
    result := dummy_gri || direction([-vec.direction_ratios[2],vec.
        direction_ratios[1]]);
    RETURN(result);
  END_IF;

END_FUNCTION; -- orthogonal_complement

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION make_array_of_array(\n             lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;\n             low1, u1, low2, u2: INTEGER\n    ): ARRAY OF ARRAY OF GENERIC:t;\n\n  LOCAL\n    res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;\n  END_LOCAL;\n  IF ((u1 - low1) + 1) <> SIZEOF(lis) THEN\n    RETURN(?);\n  END_IF;\n  IF ((u2 - low2) + 1) <> SIZEOF(lis[1]) THEN\n    RETURN(?);\n  END_IF;\n  res := [list_to_array(lis[1],low2,u2),(u1 - low1) + 1];\n  REPEAT i := 2 TO HIINDEX(lis) BY 1;\n    IF ((u2 - low2) + 1) <> SIZEOF(lis[i]) THEN\n      RETURN(?);\n    END_IF;\n    res[(low1 + i) - 1] := list_to_array(lis[i],low2,u2);\n  END_REPEAT;\n  RETURN(res);\n\nEND_FUNCTION; -- make_array_of_array\n");
#endif
/*
FUNCTION make_array_of_array(
             lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;
             low1, u1, low2, u2: INTEGER
    ): ARRAY OF ARRAY OF GENERIC:t;

  LOCAL
    res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
  END_LOCAL;
  IF ((u1 - low1) + 1) <> SIZEOF(lis) THEN
    RETURN(?);
  END_IF;
  IF ((u2 - low2) + 1) <> SIZEOF(lis[1]) THEN
    RETURN(?);
  END_IF;
  res := [list_to_array(lis[1],low2,u2),(u1 - low1) + 1];
  REPEAT i := 2 TO HIINDEX(lis) BY 1;
    IF ((u2 - low2) + 1) <> SIZEOF(lis[i]) THEN
      RETURN(?);
    END_IF;
    res[(low1 + i) - 1] := list_to_array(lis[i],low2,u2);
  END_REPEAT;
  RETURN(res);

END_FUNCTION; -- make_array_of_array

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION second_proj_axis(\n             z_axis, x_axis, arg: direction\n    ): direction;\n\n  LOCAL\n    temp   : vector;\n    v      : direction;\n    y_axis : vector;\n  END_LOCAL;\n  IF NOT EXISTS(arg) THEN\n    v := dummy_gri || direction([0,1,0]);\n  ELSE\n    v := arg;\n  END_IF;\n  temp := scalar_times_vector(dot_product(v,z_axis),z_axis);\n  y_axis := vector_difference(v,temp);\n  temp := scalar_times_vector(dot_product(v,x_axis),x_axis);\n  y_axis := vector_difference(y_axis,temp);\n  y_axis := normalise(y_axis);\n  RETURN(y_axis.orientation);\n\nEND_FUNCTION; -- second_proj_axis\n");
#endif
/*
FUNCTION second_proj_axis(
             z_axis, x_axis, arg: direction
    ): direction;

  LOCAL
    temp   : vector;
    v      : direction;
    y_axis : vector;
  END_LOCAL;
  IF NOT EXISTS(arg) THEN
    v := dummy_gri || direction([0,1,0]);
  ELSE
    v := arg;
  END_IF;
  temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
  y_axis := vector_difference(v,temp);
  temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
  y_axis := vector_difference(y_axis,temp);
  y_axis := normalise(y_axis);
  RETURN(y_axis.orientation);

END_FUNCTION; -- second_proj_axis

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION bag_to_set(\n             the_bag: BAG OF GENERIC:intype\n    ): SET OF GENERIC:intype;\n\n  LOCAL\n    i       : INTEGER;\n    the_set : SET OF GENERIC:intype := [];\n  END_LOCAL;\n  IF SIZEOF(the_bag) > 0 THEN\n    REPEAT i := 1 TO HIINDEX(the_bag) BY 1;\n      the_set := the_set + the_bag[i];\n    END_REPEAT;\n  END_IF;\n  RETURN(the_set);\n\nEND_FUNCTION; -- bag_to_set\n");
#endif
/*
FUNCTION bag_to_set(
             the_bag: BAG OF GENERIC:intype
    ): SET OF GENERIC:intype;

  LOCAL
    i       : INTEGER;
    the_set : SET OF GENERIC:intype := [];
  END_LOCAL;
  IF SIZEOF(the_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
      the_set := the_set + the_bag[i];
    END_REPEAT;
  END_IF;
  RETURN(the_set);

END_FUNCTION; -- bag_to_set

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION valid_wireframe_edge_curve(\n             crv: curve\n    ): BOOLEAN;\n  IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.CONIC',\n      'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE',\n      'CONFIG_CONTROL_DESIGN.POLYLINE'] * TYPEOF(crv)) = 1 THEN\n    RETURN(TRUE);\n  ELSE\n    IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN\n      RETURN(valid_wireframe_edge_curve(crv\\curve_replica.parent_curve));\n    ELSE\n      IF 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN\n        RETURN(valid_wireframe_edge_curve(crv\\offset_curve_3d.basis_curve));\n      END_IF;\n    END_IF;\n  END_IF;\n  RETURN(FALSE);\n\nEND_FUNCTION; -- valid_wireframe_edge_curve\n");
#endif
/*
FUNCTION valid_wireframe_edge_curve(
             crv: curve
    ): BOOLEAN;
  IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.CONIC',
      'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE',
      'CONFIG_CONTROL_DESIGN.POLYLINE'] * TYPEOF(crv)) = 1 THEN
    RETURN(TRUE);
  ELSE
    IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN
      RETURN(valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
        RETURN(valid_wireframe_edge_curve(crv\offset_curve_3d.basis_curve));
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);

END_FUNCTION; -- valid_wireframe_edge_curve

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION acyclic_product_category_relationship(\n             relation: product_category_relationship;\n             children: SET OF product_category\n    ): LOGICAL;\n\n  LOCAL\n    i              : INTEGER;\n    x              : SET OF product_category_relationship;\n    local_children : SET OF product_category;\n  END_LOCAL;\n  REPEAT i := 1 TO HIINDEX(children) BY 1;\n    IF relation.category :=: children[i] THEN\n      RETURN(FALSE);\n    END_IF;\n  END_REPEAT;\n  x := bag_to_set(USEDIN(relation.category,'CONFIG_CONTROL_DESIGN.' + \n      'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));\n  local_children := children + relation.category;\n  IF SIZEOF(x) > 0 THEN\n    REPEAT i := 1 TO HIINDEX(x) BY 1;\n      IF NOT acyclic_product_category_relationship(x[i],local_children)\n           THEN\n        RETURN(FALSE);\n      END_IF;\n    END_REPEAT;\n  END_IF;\n  RETURN(TRUE);\n\nEND_FUNCTION; -- acyclic_product_category_relationship\n");
#endif
/*
FUNCTION acyclic_product_category_relationship(
             relation: product_category_relationship;
             children: SET OF product_category
    ): LOGICAL;

  LOCAL
    i              : INTEGER;
    x              : SET OF product_category_relationship;
    local_children : SET OF product_category;
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(children) BY 1;
    IF relation.category :=: children[i] THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  x := bag_to_set(USEDIN(relation.category,'CONFIG_CONTROL_DESIGN.' + 
      'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
  local_children := children + relation.category;
  IF SIZEOF(x) > 0 THEN
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_product_category_relationship(x[i],local_children)
           THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(TRUE);

END_FUNCTION; -- acyclic_product_category_relationship

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION surface_weights_positive(\n             b: rational_b_spline_surface\n    ): BOOLEAN;\n\n  LOCAL\n    result : BOOLEAN := TRUE;\n  END_LOCAL;\n  REPEAT i := 0 TO b.u_upper BY 1;\n    REPEAT j := 0 TO b.v_upper BY 1;\n      IF b.weights[i][j] <= 0 THEN\n        result := FALSE;\n        RETURN(result);\n      END_IF;\n    END_REPEAT;\n  END_REPEAT;\n  RETURN(result);\n\nEND_FUNCTION; -- surface_weights_positive\n");
#endif
/*
FUNCTION surface_weights_positive(
             b: rational_b_spline_surface
    ): BOOLEAN;

  LOCAL
    result : BOOLEAN := TRUE;
  END_LOCAL;
  REPEAT i := 0 TO b.u_upper BY 1;
    REPEAT j := 0 TO b.v_upper BY 1;
      IF b.weights[i][j] <= 0 THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN(result);

END_FUNCTION; -- surface_weights_positive

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION vector_difference(\n             arg1, arg2: vector_or_direction\n    ): vector;\n\n  LOCAL\n    ndim   : INTEGER;\n    mag2   : REAL;\n    mag1   : REAL;\n    mag    : REAL;\n    res    : direction;\n    vec1   : direction;\n    vec2   : direction;\n    result : vector;\n  END_LOCAL;\n  IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)\n       THEN\n    RETURN(?);\n  ELSE\n    BEGIN\n      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg1) THEN\n        mag1 := arg1.magnitude;\n        vec1 := arg1.orientation;\n      ELSE\n        mag1 := 1;\n        vec1 := arg1;\n      END_IF;\n      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg2) THEN\n        mag2 := arg2.magnitude;\n        vec2 := arg2.orientation;\n      ELSE\n        mag2 := 1;\n        vec2 := arg2;\n      END_IF;\n      vec1 := normalise(vec1);\n      vec2 := normalise(vec2);\n      ndim := SIZEOF(vec1.direction_ratios);\n      mag := 0;\n      res := dummy_gri || direction(vec1.direction_ratios);\n      REPEAT i := 1 TO ndim BY 1;\n        res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + (\n            mag2 * vec2.direction_ratios[i]);\n        mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);\n      END_REPEAT;\n      IF mag > 0 THEN\n        result := dummy_gri || vector(res,SQRT(mag));\n      ELSE\n        result := dummy_gri || vector(vec1,0);\n      END_IF;\n    END;\n  END_IF;\n  RETURN(result);\n\nEND_FUNCTION; -- vector_difference\n");
#endif
/*
FUNCTION vector_difference(
             arg1, arg2: vector_or_direction
    ): vector;

  LOCAL
    ndim   : INTEGER;
    mag2   : REAL;
    mag1   : REAL;
    mag    : REAL;
    res    : direction;
    vec1   : direction;
    vec2   : direction;
    result : vector;
  END_LOCAL;
  IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
       THEN
    RETURN(?);
  ELSE
    BEGIN
      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg1) THEN
        mag1 := arg1.magnitude;
        vec1 := arg1.orientation;
      ELSE
        mag1 := 1;
        vec1 := arg1;
      END_IF;
      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg2) THEN
        mag2 := arg2.magnitude;
        vec2 := arg2.orientation;
      ELSE
        mag2 := 1;
        vec2 := arg2;
      END_IF;
      vec1 := normalise(vec1);
      vec2 := normalise(vec2);
      ndim := SIZEOF(vec1.direction_ratios);
      mag := 0;
      res := dummy_gri || direction(vec1.direction_ratios);
      REPEAT i := 1 TO ndim BY 1;
        res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + (
            mag2 * vec2.direction_ratios[i]);
        mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        result := dummy_gri || vector(res,SQRT(mag));
      ELSE
        result := dummy_gri || vector(vec1,0);
      END_IF;
    END;
  END_IF;
  RETURN(result);

END_FUNCTION; -- vector_difference

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION acyclic_product_definition_relationship(\n             relation: product_definition_relationship;\n             relatives: SET [1:?] OF product_definition;\n             specific_relation: STRING\n    ): LOGICAL;\n\n  LOCAL\n    x : SET OF product_definition_relationship;\n  END_LOCAL;\n  IF relation.relating_product_definition IN relatives THEN\n    RETURN(FALSE);\n  END_IF;\n  x := QUERY ( pd <* bag_to_set(USEDIN(relation.\n      relating_product_definition,'CONFIG_CONTROL_DESIGN.' + \n      'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))\n       | (specific_relation IN TYPEOF(pd)) );\n  REPEAT i := 1 TO HIINDEX(x) BY 1;\n    IF NOT acyclic_product_definition_relationship(x[i],relatives + \n        relation.relating_product_definition,specific_relation) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_REPEAT;\n  RETURN(TRUE);\n\nEND_FUNCTION; -- acyclic_product_definition_relationship\n");
#endif
/*
FUNCTION acyclic_product_definition_relationship(
             relation: product_definition_relationship;
             relatives: SET [1:?] OF product_definition;
             specific_relation: STRING
    ): LOGICAL;

  LOCAL
    x : SET OF product_definition_relationship;
  END_LOCAL;
  IF relation.relating_product_definition IN relatives THEN
    RETURN(FALSE);
  END_IF;
  x := QUERY ( pd <* bag_to_set(USEDIN(relation.
      relating_product_definition,'CONFIG_CONTROL_DESIGN.' + 
      'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))
       | (specific_relation IN TYPEOF(pd)) );
  REPEAT i := 1 TO HIINDEX(x) BY 1;
    IF NOT acyclic_product_definition_relationship(x[i],relatives + 
        relation.relating_product_definition,specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);

END_FUNCTION; -- acyclic_product_definition_relationship

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION constraints_geometry_shell_based_wireframe_model(\n             m: shell_based_wireframe_model\n    ): BOOLEAN;\n\n  LOCAL\n    result : BOOLEAN := TRUE;\n  END_LOCAL;\n  REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;\n    IF (NOT ('CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(m.sbwm_boundary[\n        j]))) AND (NOT ('CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF(m.\n        sbwm_boundary[j]))) THEN\n      result := FALSE;\n      RETURN(result);\n    END_IF;\n  END_REPEAT;\n  RETURN(result);\n\nEND_FUNCTION; -- constraints_geometry_shell_based_wireframe_model\n");
#endif
/*
FUNCTION constraints_geometry_shell_based_wireframe_model(
             m: shell_based_wireframe_model
    ): BOOLEAN;

  LOCAL
    result : BOOLEAN := TRUE;
  END_LOCAL;
  REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
    IF (NOT ('CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(m.sbwm_boundary[
        j]))) AND (NOT ('CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF(m.
        sbwm_boundary[j]))) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);

END_FUNCTION; -- constraints_geometry_shell_based_wireframe_model

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION list_to_set(\n             l: LIST [0:?] OF GENERIC:t\n    ): SET OF GENERIC:t;\n\n  LOCAL\n    s : SET OF GENERIC:t := [];\n  END_LOCAL;\n  REPEAT i := 1 TO SIZEOF(l) BY 1;\n    s := s + l[i];\n  END_REPEAT;\n  RETURN(s);\n\nEND_FUNCTION; -- list_to_set\n");
#endif
/*
FUNCTION list_to_set(
             l: LIST [0:?] OF GENERIC:t
    ): SET OF GENERIC:t;

  LOCAL
    s : SET OF GENERIC:t := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF(l) BY 1;
    s := s + l[i];
  END_REPEAT;
  RETURN(s);

END_FUNCTION; -- list_to_set

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION valid_calendar_date(\n             date: calendar_date\n    ): LOGICAL;\n  IF NOT ((1 <= date.day_component) AND (date.day_component <= 31)) THEN\n    RETURN(FALSE);\n  END_IF;\n  CASE date.month_component OF\n    4        :       RETURN((1 <= date.day_component) AND (date.\n          day_component <= 30));\n    6        :       RETURN((1 <= date.day_component) AND (date.\n          day_component <= 30));\n    9        :       RETURN((1 <= date.day_component) AND (date.\n          day_component <= 30));\n    11       :       RETURN((1 <= date.day_component) AND (date.\n          day_component <= 30));\n    2        :       BEGIN\n        IF leap_year(date.year_component) THEN\n          RETURN((1 <= date.day_component) AND (date.day_component <= 29));\n        ELSE\n          RETURN((1 <= date.day_component) AND (date.day_component <= 28));\n        END_IF;\n      END;\n    OTHERWISE  :       RETURN(TRUE);\n    END_CASE;\n\nEND_FUNCTION; -- valid_calendar_date\n");
#endif
/*
FUNCTION valid_calendar_date(
             date: calendar_date
    ): LOGICAL;
  IF NOT ((1 <= date.day_component) AND (date.day_component <= 31)) THEN
    RETURN(FALSE);
  END_IF;
  CASE date.month_component OF
    4        :       RETURN((1 <= date.day_component) AND (date.
          day_component <= 30));
    6        :       RETURN((1 <= date.day_component) AND (date.
          day_component <= 30));
    9        :       RETURN((1 <= date.day_component) AND (date.
          day_component <= 30));
    11       :       RETURN((1 <= date.day_component) AND (date.
          day_component <= 30));
    2        :       BEGIN
        IF leap_year(date.year_component) THEN
          RETURN((1 <= date.day_component) AND (date.day_component <= 29));
        ELSE
          RETURN((1 <= date.day_component) AND (date.day_component <= 28));
        END_IF;
      END;
    OTHERWISE  :       RETURN(TRUE);
    END_CASE;

END_FUNCTION; -- valid_calendar_date

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION valid_wireframe_vertex_point(\n             pnt: point\n    ): BOOLEAN;\n  IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN\n    RETURN(TRUE);\n  ELSE\n    IF 'CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN\n      RETURN(valid_wireframe_vertex_point(pnt\\point_replica.parent_pt));\n    END_IF;\n  END_IF;\n  RETURN(FALSE);\n\nEND_FUNCTION; -- valid_wireframe_vertex_point\n");
#endif
/*
FUNCTION valid_wireframe_vertex_point(
             pnt: point
    ): BOOLEAN;
  IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
    RETURN(TRUE);
  ELSE
    IF 'CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN
      RETURN(valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
    END_IF;
  END_IF;
  RETURN(FALSE);

END_FUNCTION; -- valid_wireframe_vertex_point

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION list_to_array(\n             lis: LIST [0:?] OF GENERIC:t;\n             low, u: INTEGER\n    ): ARRAY OF GENERIC:t;\n\n  LOCAL\n    n   : INTEGER;\n    res : ARRAY [low:u] OF GENERIC:t;\n  END_LOCAL;\n  n := SIZEOF(lis);\n  IF n <> ((u - low) + 1) THEN\n    RETURN(?);\n  ELSE\n    res := [lis[1],n];\n    REPEAT i := 2 TO n BY 1;\n      res[(low + i) - 1] := lis[i];\n    END_REPEAT;\n    RETURN(res);\n  END_IF;\n\nEND_FUNCTION; -- list_to_array\n");
#endif
/*
FUNCTION list_to_array(
             lis: LIST [0:?] OF GENERIC:t;
             low, u: INTEGER
    ): ARRAY OF GENERIC:t;

  LOCAL
    n   : INTEGER;
    res : ARRAY [low:u] OF GENERIC:t;
  END_LOCAL;
  n := SIZEOF(lis);
  IF n <> ((u - low) + 1) THEN
    RETURN(?);
  ELSE
    res := [lis[1],n];
    REPEAT i := 2 TO n BY 1;
      res[(low + i) - 1] := lis[i];
    END_REPEAT;
    RETURN(res);
  END_IF;

END_FUNCTION; -- list_to_array

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION using_items(\n             item: founded_item_select;\n             checked_items: SET OF founded_item_select\n    ): SET OF founded_item_select;\n\n  LOCAL\n    next_items      : SET OF founded_item_select;\n    new_check_items : SET OF founded_item_select;\n    result_items    : SET OF founded_item_select;\n  END_LOCAL;\n  result_items := [];\n  new_check_items := checked_items + item;\n  next_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | ((\n      'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) OR (\n      'CONFIG_CONTROL_DESIGN.FOUNDED_ITEM' IN TYPEOF(z))) );\n  IF SIZEOF(next_items) > 0 THEN\n    REPEAT i := 1 TO HIINDEX(next_items) BY 1;\n      IF NOT (next_items[i] IN new_check_items) THEN\n        result_items := result_items + next_items[i] + using_items(\n            next_items[i],new_check_items);\n      END_IF;\n    END_REPEAT;\n  END_IF;\n  RETURN(result_items);\n\nEND_FUNCTION; -- using_items\n");
#endif
/*
FUNCTION using_items(
             item: founded_item_select;
             checked_items: SET OF founded_item_select
    ): SET OF founded_item_select;

  LOCAL
    next_items      : SET OF founded_item_select;
    new_check_items : SET OF founded_item_select;
    result_items    : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  next_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | ((
      'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) OR (
      'CONFIG_CONTROL_DESIGN.FOUNDED_ITEM' IN TYPEOF(z))) );
  IF SIZEOF(next_items) > 0 THEN
    REPEAT i := 1 TO HIINDEX(next_items) BY 1;
      IF NOT (next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] + using_items(
            next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(result_items);

END_FUNCTION; -- using_items

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION constraints_geometry_shell_based_surface_model(\n             m: shell_based_surface_model\n    ): BOOLEAN;\n\n  LOCAL\n    result : BOOLEAN := TRUE;\n  END_LOCAL;\n  REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;\n    IF (NOT ('CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(m.sbsm_boundary[\n        j]))) AND (NOT ('CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(m.\n        sbsm_boundary[j]))) THEN\n      result := FALSE;\n      RETURN(result);\n    END_IF;\n  END_REPEAT;\n  RETURN(result);\n\nEND_FUNCTION; -- constraints_geometry_shell_based_surface_model\n");
#endif
/*
FUNCTION constraints_geometry_shell_based_surface_model(
             m: shell_based_surface_model
    ): BOOLEAN;

  LOCAL
    result : BOOLEAN := TRUE;
  END_LOCAL;
  REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
    IF (NOT ('CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(m.sbsm_boundary[
        j]))) AND (NOT ('CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(m.
        sbsm_boundary[j]))) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);

END_FUNCTION; -- constraints_geometry_shell_based_surface_model

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION face_bound_reversed(\n             a_face_bound: face_bound\n    ): face_bound;\n\n  LOCAL\n    the_reverse : face_bound;\n  END_LOCAL;\n  IF 'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)\n       THEN\n    the_reverse := dummy_tri || face_bound(a_face_bound\\face_bound.bound,\n        NOT a_face_bound\\face_bound.orientation) || face_outer_bound();\n  ELSE\n    the_reverse := dummy_tri || face_bound(a_face_bound.bound,NOT \n        a_face_bound.orientation);\n  END_IF;\n  RETURN(the_reverse);\n\nEND_FUNCTION; -- face_bound_reversed\n");
#endif
/*
FUNCTION face_bound_reversed(
             a_face_bound: face_bound
    ): face_bound;

  LOCAL
    the_reverse : face_bound;
  END_LOCAL;
  IF 'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)
       THEN
    the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound,
        NOT a_face_bound\face_bound.orientation) || face_outer_bound();
  ELSE
    the_reverse := dummy_tri || face_bound(a_face_bound.bound,NOT 
        a_face_bound.orientation);
  END_IF;
  RETURN(the_reverse);

END_FUNCTION; -- face_bound_reversed

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION set_of_topology_reversed(\n             a_set: set_of_reversible_topology_item\n    ): set_of_reversible_topology_item;\n\n  LOCAL\n    the_reverse : set_of_reversible_topology_item;\n  END_LOCAL;\n  the_reverse := [];\n  REPEAT i := 1 TO SIZEOF(a_set) BY 1;\n    the_reverse := the_reverse + topology_reversed(a_set[i]);\n  END_REPEAT;\n  RETURN(the_reverse);\n\nEND_FUNCTION; -- set_of_topology_reversed\n");
#endif
/*
FUNCTION set_of_topology_reversed(
             a_set: set_of_reversible_topology_item
    ): set_of_reversible_topology_item;

  LOCAL
    the_reverse : set_of_reversible_topology_item;
  END_LOCAL;
  the_reverse := [];
  REPEAT i := 1 TO SIZEOF(a_set) BY 1;
    the_reverse := the_reverse + topology_reversed(a_set[i]);
  END_REPEAT;
  RETURN(the_reverse);

END_FUNCTION; -- set_of_topology_reversed

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION dimension_of(\n             item: geometric_representation_item\n    ): dimension_count;\n\n  LOCAL\n    x : SET OF representation;\n    y : representation_context;\n  END_LOCAL;\n  x := using_representations(item);\n  y := x[1].context_of_items;\n  RETURN(y\\geometric_representation_context.coordinate_space_dimension);\n\nEND_FUNCTION; -- dimension_of\n");
#endif
/*
FUNCTION dimension_of(
             item: geometric_representation_item
    ): dimension_count;

  LOCAL
    x : SET OF representation;
    y : representation_context;
  END_LOCAL;
  x := using_representations(item);
  y := x[1].context_of_items;
  RETURN(y\geometric_representation_context.coordinate_space_dimension);

END_FUNCTION; -- dimension_of

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION scalar_times_vector(\n             scalar: REAL;\n             vec: vector_or_direction\n    ): vector;\n\n  LOCAL\n    v      : direction;\n    mag    : REAL;\n    result : vector;\n  END_LOCAL;\n  IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN\n    RETURN(?);\n  ELSE\n    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(vec) THEN\n      v := dummy_gri || direction(vec.orientation.direction_ratios);\n      mag := scalar * vec.magnitude;\n    ELSE\n      v := dummy_gri || direction(vec.direction_ratios);\n      mag := scalar;\n    END_IF;\n    IF mag < 0 THEN\n      REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;\n        v.direction_ratios[i] := -v.direction_ratios[i];\n      END_REPEAT;\n      mag := -mag;\n    END_IF;\n    result := dummy_gri || vector(normalise(v),mag);\n  END_IF;\n  RETURN(result);\n\nEND_FUNCTION; -- scalar_times_vector\n");
#endif
/*
FUNCTION scalar_times_vector(
             scalar: REAL;
             vec: vector_or_direction
    ): vector;

  LOCAL
    v      : direction;
    mag    : REAL;
    result : vector;
  END_LOCAL;
  IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
    RETURN(?);
  ELSE
    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(vec) THEN
      v := dummy_gri || direction(vec.orientation.direction_ratios);
      mag := scalar * vec.magnitude;
    ELSE
      v := dummy_gri || direction(vec.direction_ratios);
      mag := scalar;
    END_IF;
    IF mag < 0 THEN
      REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
        v.direction_ratios[i] := -v.direction_ratios[i];
      END_REPEAT;
      mag := -mag;
    END_IF;
    result := dummy_gri || vector(normalise(v),mag);
  END_IF;
  RETURN(result);

END_FUNCTION; -- scalar_times_vector

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION dimensions_for_si_unit(\n             n: si_unit_name\n    ): dimensional_exponents;\n  CASE n OF\n    metre         :       RETURN(dimensional_exponents(1,0,0,0,0,0,0));\n    gram          :       RETURN(dimensional_exponents(0,1,0,0,0,0,0));\n    second        :       RETURN(dimensional_exponents(0,0,1,0,0,0,0));\n    ampere        :       RETURN(dimensional_exponents(0,0,0,1,0,0,0));\n    kelvin        :       RETURN(dimensional_exponents(0,0,0,0,1,0,0));\n    mole          :       RETURN(dimensional_exponents(0,0,0,0,0,1,0));\n    candela       :       RETURN(dimensional_exponents(0,0,0,0,0,0,1));\n    radian        :       RETURN(dimensional_exponents(0,0,0,0,0,0,0));\n    steradian     :       RETURN(dimensional_exponents(0,0,0,0,0,0,0));\n    hertz         :       RETURN(dimensional_exponents(0,0,-1,0,0,0,0));\n    newton        :       RETURN(dimensional_exponents(1,1,-2,0,0,0,0));\n    pascal        :       RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));\n    joule         :       RETURN(dimensional_exponents(2,1,-2,0,0,0,0));\n    watt          :       RETURN(dimensional_exponents(2,1,-3,0,0,0,0));\n    coulomb       :       RETURN(dimensional_exponents(0,0,1,1,0,0,0));\n    volt          :       RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));\n    farad         :       RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));\n    ohm           :       RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));\n    siemens       :       RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));\n    weber         :       RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));\n    tesla         :       RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));\n    henry         :       RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));\n    degree_celsius  :       RETURN(dimensional_exponents(0,0,0,0,1,0,0));\n    lumen         :       RETURN(dimensional_exponents(0,0,0,0,0,0,1));\n    lux           :       RETURN(dimensional_exponents(-2,0,0,0,0,0,1));\n    becquerel     :       RETURN(dimensional_exponents(0,0,-1,0,0,0,0));\n    gray          :       RETURN(dimensional_exponents(2,0,-2,0,0,0,0));\n    sievert       :       RETURN(dimensional_exponents(2,0,-2,0,0,0,0));\n    END_CASE;\n\nEND_FUNCTION; -- dimensions_for_si_unit\n");
#endif
/*
FUNCTION dimensions_for_si_unit(
             n: si_unit_name
    ): dimensional_exponents;
  CASE n OF
    metre         :       RETURN(dimensional_exponents(1,0,0,0,0,0,0));
    gram          :       RETURN(dimensional_exponents(0,1,0,0,0,0,0));
    second        :       RETURN(dimensional_exponents(0,0,1,0,0,0,0));
    ampere        :       RETURN(dimensional_exponents(0,0,0,1,0,0,0));
    kelvin        :       RETURN(dimensional_exponents(0,0,0,0,1,0,0));
    mole          :       RETURN(dimensional_exponents(0,0,0,0,0,1,0));
    candela       :       RETURN(dimensional_exponents(0,0,0,0,0,0,1));
    radian        :       RETURN(dimensional_exponents(0,0,0,0,0,0,0));
    steradian     :       RETURN(dimensional_exponents(0,0,0,0,0,0,0));
    hertz         :       RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
    newton        :       RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
    pascal        :       RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
    joule         :       RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
    watt          :       RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
    coulomb       :       RETURN(dimensional_exponents(0,0,1,1,0,0,0));
    volt          :       RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
    farad         :       RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
    ohm           :       RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
    siemens       :       RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
    weber         :       RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
    tesla         :       RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
    henry         :       RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
    degree_celsius  :       RETURN(dimensional_exponents(0,0,0,0,1,0,0));
    lumen         :       RETURN(dimensional_exponents(0,0,0,0,0,0,1));
    lux           :       RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
    becquerel     :       RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
    gray          :       RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
    sievert       :       RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
    END_CASE;

END_FUNCTION; -- dimensions_for_si_unit

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION assembly_shape_is_defined(\n             assy: next_assembly_usage_occurrence;\n             schma: STRING\n    ): BOOLEAN;\n\n  LOCAL\n    srr_set   : SET OF shape_representation_relationship := [];\n    i         : INTEGER;\n    j         : INTEGER;\n    sdr_set   : SET OF shape_definition_representation := [];\n    pr1_set   : SET OF property_definition := [];\n    pdrel_set : SET OF product_definition_relationship := [];\n    pr2_set   : SET OF property_definition := [];\n  END_LOCAL;\n  pr1_set := bag_to_set(USEDIN(assy.related_product_definition,schma + \n      '.PROPERTY_DEFINITION.DEFINITION'));\n  REPEAT i := 1 TO HIINDEX(pr1_set) BY 1;\n    sdr_set := sdr_set + QUERY ( pdr <* USEDIN(pr1_set[i],schma + \n        '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((schma + \n        '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) );\n  END_REPEAT;\n  pdrel_set := bag_to_set(USEDIN(assy.related_product_definition,schma + \n      '.PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'));\n  REPEAT j := 1 TO HIINDEX(pdrel_set) BY 1;\n    pr2_set := pr2_set + USEDIN(pdrel_set[j],schma + \n        '.PROPERTY_DEFINITION.DEFINITION');\n  END_REPEAT;\n  REPEAT i := 1 TO HIINDEX(pr2_set) BY 1;\n    sdr_set := sdr_set + QUERY ( pdr <* USEDIN(pr2_set[i],schma + \n        '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((schma + \n        '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) );\n  END_REPEAT;\n  IF SIZEOF(sdr_set) > 0 THEN\n    REPEAT i := 1 TO HIINDEX(sdr_set) BY 1;\n      srr_set := QUERY ( rr <* bag_to_set(USEDIN(sdr_set[i]\\\n          property_definition_representation.used_representation,schma + \n          '.REPRESENTATION_RELATIONSHIP.REP_2')) | ((schma + \n          '.SHAPE_REPRESENTATION_RELATIONSHIP') IN TYPEOF(rr)) );\n      IF SIZEOF(srr_set) > 0 THEN\n        REPEAT j := 1 TO HIINDEX(srr_set) BY 1;\n          IF SIZEOF(QUERY ( pdr <* bag_to_set(USEDIN(srr_set[j]\\\n              representation_relationship.rep_1,schma + \n              '.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))\n               | ((schma + '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(\n              pdr)) ) * QUERY ( pdr <* bag_to_set(USEDIN(assy.\n              relating_product_definition,schma + \n              '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) | ((schma \n              + '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) )) >= 1\n               THEN\n            IF SIZEOF(QUERY ( cdsr <* USEDIN(srr_set[j],schma + \n                '.CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' + \n                'REPRESENTATION_RELATION') | (NOT (cdsr\\\n                context_dependent_shape_representation.\n                represented_product_relation\\property_definition.definition \n                :=: assy)) )) > 0 THEN\n              RETURN(FALSE);\n            END_IF;\n          END_IF;\n        END_REPEAT;\n      END_IF;\n    END_REPEAT;\n  END_IF;\n  RETURN(TRUE);\n\nEND_FUNCTION; -- assembly_shape_is_defined\n");
#endif
/*
FUNCTION assembly_shape_is_defined(
             assy: next_assembly_usage_occurrence;
             schma: STRING
    ): BOOLEAN;

  LOCAL
    srr_set   : SET OF shape_representation_relationship := [];
    i         : INTEGER;
    j         : INTEGER;
    sdr_set   : SET OF shape_definition_representation := [];
    pr1_set   : SET OF property_definition := [];
    pdrel_set : SET OF product_definition_relationship := [];
    pr2_set   : SET OF property_definition := [];
  END_LOCAL;
  pr1_set := bag_to_set(USEDIN(assy.related_product_definition,schma + 
      '.PROPERTY_DEFINITION.DEFINITION'));
  REPEAT i := 1 TO HIINDEX(pr1_set) BY 1;
    sdr_set := sdr_set + QUERY ( pdr <* USEDIN(pr1_set[i],schma + 
        '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((schma + 
        '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) );
  END_REPEAT;
  pdrel_set := bag_to_set(USEDIN(assy.related_product_definition,schma + 
      '.PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'));
  REPEAT j := 1 TO HIINDEX(pdrel_set) BY 1;
    pr2_set := pr2_set + USEDIN(pdrel_set[j],schma + 
        '.PROPERTY_DEFINITION.DEFINITION');
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(pr2_set) BY 1;
    sdr_set := sdr_set + QUERY ( pdr <* USEDIN(pr2_set[i],schma + 
        '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((schma + 
        '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) );
  END_REPEAT;
  IF SIZEOF(sdr_set) > 0 THEN
    REPEAT i := 1 TO HIINDEX(sdr_set) BY 1;
      srr_set := QUERY ( rr <* bag_to_set(USEDIN(sdr_set[i]\
          property_definition_representation.used_representation,schma + 
          '.REPRESENTATION_RELATIONSHIP.REP_2')) | ((schma + 
          '.SHAPE_REPRESENTATION_RELATIONSHIP') IN TYPEOF(rr)) );
      IF SIZEOF(srr_set) > 0 THEN
        REPEAT j := 1 TO HIINDEX(srr_set) BY 1;
          IF SIZEOF(QUERY ( pdr <* bag_to_set(USEDIN(srr_set[j]\
              representation_relationship.rep_1,schma + 
              '.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
               | ((schma + '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(
              pdr)) ) * QUERY ( pdr <* bag_to_set(USEDIN(assy.
              relating_product_definition,schma + 
              '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) | ((schma 
              + '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) )) >= 1
               THEN
            IF SIZEOF(QUERY ( cdsr <* USEDIN(srr_set[j],schma + 
                '.CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' + 
                'REPRESENTATION_RELATION') | (NOT (cdsr\
                context_dependent_shape_representation.
                represented_product_relation\property_definition.definition 
                :=: assy)) )) > 0 THEN
              RETURN(FALSE);
            END_IF;
          END_IF;
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(TRUE);

END_FUNCTION; -- assembly_shape_is_defined

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION open_shell_reversed(\n             a_shell: open_shell\n    ): oriented_open_shell;\n\n  LOCAL\n    the_reverse : oriented_open_shell;\n  END_LOCAL;\n  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell) THEN\n    the_reverse := dummy_tri || connected_face_set(a_shell\\\n        connected_face_set.cfs_faces) || open_shell() || \n        oriented_open_shell(a_shell\\oriented_open_shell.open_shell_element,\n        NOT a_shell\\oriented_open_shell.orientation);\n  ELSE\n    the_reverse := dummy_tri || connected_face_set(a_shell\\\n        connected_face_set.cfs_faces) || open_shell() || \n        oriented_open_shell(a_shell,FALSE);\n  END_IF;\n  RETURN(the_reverse);\n\nEND_FUNCTION; -- open_shell_reversed\n");
#endif
/*
FUNCTION open_shell_reversed(
             a_shell: open_shell
    ): oriented_open_shell;

  LOCAL
    the_reverse : oriented_open_shell;
  END_LOCAL;
  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell) THEN
    the_reverse := dummy_tri || connected_face_set(a_shell\
        connected_face_set.cfs_faces) || open_shell() || 
        oriented_open_shell(a_shell\oriented_open_shell.open_shell_element,
        NOT a_shell\oriented_open_shell.orientation);
  ELSE
    the_reverse := dummy_tri || connected_face_set(a_shell\
        connected_face_set.cfs_faces) || open_shell() || 
        oriented_open_shell(a_shell,FALSE);
  END_IF;
  RETURN(the_reverse);

END_FUNCTION; -- open_shell_reversed

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION acyclic_surface_replica(\n             rep: surface_replica;\n             parent: surface\n    ): BOOLEAN;\n  IF NOT ('CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(parent)) THEN\n    RETURN(TRUE);\n  END_IF;\n  IF parent :=: rep THEN\n    RETURN(FALSE);\n  ELSE\n    RETURN(acyclic_surface_replica(rep,parent\\surface_replica.\n        parent_surface));\n  END_IF;\n\nEND_FUNCTION; -- acyclic_surface_replica\n");
#endif
/*
FUNCTION acyclic_surface_replica(
             rep: surface_replica;
             parent: surface
    ): BOOLEAN;
  IF NOT ('CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(parent)) THEN
    RETURN(TRUE);
  END_IF;
  IF parent :=: rep THEN
    RETURN(FALSE);
  ELSE
    RETURN(acyclic_surface_replica(rep,parent\surface_replica.
        parent_surface));
  END_IF;

END_FUNCTION; -- acyclic_surface_replica

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION gbsf_check_surface(\n             sf: surface\n    ): BOOLEAN;\n  IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\\\n      b_spline_surface.self_intersect = FALSE)) OR (sf\\b_spline_surface.\n      self_intersect = UNKNOWN) THEN\n    RETURN(TRUE);\n  ELSE\n    IF SIZEOF(['CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE',\n        'CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 1 THEN\n      RETURN(TRUE);\n    ELSE\n      IF 'CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf) THEN\n        IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONICAL_SURFACE',\n            'CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE',\n            'CONFIG_CONTROL_DESIGN.PLANE'] * TYPEOF(sf\\\n            curve_bounded_surface.basis_surface)) = 1 THEN\n          RETURN(SIZEOF(QUERY ( bcurve <* sf\\curve_bounded_surface.\n              boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);\n        ELSE\n          IF gbsf_check_surface(sf\\curve_bounded_surface.basis_surface)\n               THEN\n            RETURN(SIZEOF(QUERY ( bcurve <* sf\\curve_bounded_surface.\n                boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);\n          END_IF;\n        END_IF;\n      ELSE\n        IF (('CONFIG_CONTROL_DESIGN.OFFSET_SURFACE' IN TYPEOF(sf)) AND (sf\n            \\offset_surface.self_intersect = FALSE)) OR (sf\\offset_surface.\n            self_intersect = UNKNOWN) THEN\n          RETURN(gbsf_check_surface(sf\\offset_surface.basis_surface));\n        ELSE\n          IF 'CONFIG_CONTROL_DESIGN.RECTANGULAR_COMPOSITE_SURFACE' IN \n              TYPEOF(sf) THEN\n            REPEAT i := 1 TO SIZEOF(sf\\rectangular_composite_surface.\n                segments) BY 1;\n              REPEAT j := 1 TO SIZEOF(sf\\rectangular_composite_surface.\n                  segments[i]) BY 1;\n                IF NOT gbsf_check_surface(sf\\rectangular_composite_surface\n                    .segments[i][j].parent_surface) THEN\n                  RETURN(FALSE);\n                END_IF;\n              END_REPEAT;\n            END_REPEAT;\n            RETURN(TRUE);\n          ELSE\n            IF 'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN \n                TYPEOF(sf) THEN\n              IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONICAL_SURFACE',\n                  'CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE',\n                  'CONFIG_CONTROL_DESIGN.PLANE'] * TYPEOF(sf\\\n                  rectangular_trimmed_surface.basis_surface)) = 1 THEN\n                RETURN(TRUE);\n              ELSE\n                RETURN(gbsf_check_surface(sf\\rectangular_trimmed_surface.\n                    basis_surface));\n              END_IF;\n            ELSE\n              IF 'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(sf)\n                   THEN\n                RETURN(gbsf_check_surface(sf\\surface_replica.\n                    parent_surface));\n              ELSE\n                IF 'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(sf)\n                     THEN\n                  RETURN(gbsf_check_curve(sf\\swept_surface.swept_curve));\n                END_IF;\n              END_IF;\n            END_IF;\n          END_IF;\n        END_IF;\n      END_IF;\n    END_IF;\n  END_IF;\n  RETURN(FALSE);\n\nEND_FUNCTION; -- gbsf_check_surface\n");
#endif
/*
FUNCTION gbsf_check_surface(
             sf: surface
    ): BOOLEAN;
  IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\
      b_spline_surface.self_intersect = FALSE)) OR (sf\b_spline_surface.
      self_intersect = UNKNOWN) THEN
    RETURN(TRUE);
  ELSE
    IF SIZEOF(['CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE',
        'CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf) THEN
        IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONICAL_SURFACE',
            'CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE',
            'CONFIG_CONTROL_DESIGN.PLANE'] * TYPEOF(sf\
            curve_bounded_surface.basis_surface)) = 1 THEN
          RETURN(SIZEOF(QUERY ( bcurve <* sf\curve_bounded_surface.
              boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);
        ELSE
          IF gbsf_check_surface(sf\curve_bounded_surface.basis_surface)
               THEN
            RETURN(SIZEOF(QUERY ( bcurve <* sf\curve_bounded_surface.
                boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);
          END_IF;
        END_IF;
      ELSE
        IF (('CONFIG_CONTROL_DESIGN.OFFSET_SURFACE' IN TYPEOF(sf)) AND (sf
            \offset_surface.self_intersect = FALSE)) OR (sf\offset_surface.
            self_intersect = UNKNOWN) THEN
          RETURN(gbsf_check_surface(sf\offset_surface.basis_surface));
        ELSE
          IF 'CONFIG_CONTROL_DESIGN.RECTANGULAR_COMPOSITE_SURFACE' IN 
              TYPEOF(sf) THEN
            REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.
                segments) BY 1;
              REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.
                  segments[i]) BY 1;
                IF NOT gbsf_check_surface(sf\rectangular_composite_surface
                    .segments[i][j].parent_surface) THEN
                  RETURN(FALSE);
                END_IF;
              END_REPEAT;
            END_REPEAT;
            RETURN(TRUE);
          ELSE
            IF 'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN 
                TYPEOF(sf) THEN
              IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONICAL_SURFACE',
                  'CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE',
                  'CONFIG_CONTROL_DESIGN.PLANE'] * TYPEOF(sf\
                  rectangular_trimmed_surface.basis_surface)) = 1 THEN
                RETURN(TRUE);
              ELSE
                RETURN(gbsf_check_surface(sf\rectangular_trimmed_surface.
                    basis_surface));
              END_IF;
            ELSE
              IF 'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(sf)
                   THEN
                RETURN(gbsf_check_surface(sf\surface_replica.
                    parent_surface));
              ELSE
                IF 'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(sf)
                     THEN
                  RETURN(gbsf_check_curve(sf\swept_surface.swept_curve));
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);

END_FUNCTION; -- gbsf_check_surface

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION msf_surface_check(\n             surf: surface\n    ): BOOLEAN;\n  IF 'CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN\n    RETURN(TRUE);\n  ELSE\n    IF 'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(surf) THEN\n      RETURN(msf_curve_check(surf\\swept_surface.swept_curve));\n    ELSE\n      IF (('CONFIG_CONTROL_DESIGN.OFFSET_SURFACE' IN TYPEOF(surf)) AND (\n          surf\\offset_surface.self_intersect = FALSE)) OR (surf\\\n          offset_surface.self_intersect = UNKNOWN) THEN\n        RETURN(msf_surface_check(surf\\offset_surface.basis_surface));\n      ELSE\n        IF 'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(surf) THEN\n          RETURN(msf_surface_check(surf\\surface_replica.parent_surface));\n        ELSE\n          IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(surf)) \n              AND (surf\\b_spline_surface.self_intersect = FALSE)) OR (surf\\\n              b_spline_surface.self_intersect = UNKNOWN) THEN\n            RETURN(TRUE);\n          END_IF;\n        END_IF;\n      END_IF;\n    END_IF;\n  END_IF;\n  RETURN(FALSE);\n\nEND_FUNCTION; -- msf_surface_check\n");
#endif
/*
FUNCTION msf_surface_check(
             surf: surface
    ): BOOLEAN;
  IF 'CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE
    IF 'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(surf) THEN
      RETURN(msf_curve_check(surf\swept_surface.swept_curve));
    ELSE
      IF (('CONFIG_CONTROL_DESIGN.OFFSET_SURFACE' IN TYPEOF(surf)) AND (
          surf\offset_surface.self_intersect = FALSE)) OR (surf\
          offset_surface.self_intersect = UNKNOWN) THEN
        RETURN(msf_surface_check(surf\offset_surface.basis_surface));
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(surf) THEN
          RETURN(msf_surface_check(surf\surface_replica.parent_surface));
        ELSE
          IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(surf)) 
              AND (surf\b_spline_surface.self_intersect = FALSE)) OR (surf\
              b_spline_surface.self_intersect = UNKNOWN) THEN
            RETURN(TRUE);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);

END_FUNCTION; -- msf_surface_check

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION normalise(\n             arg: vector_or_direction\n    ): vector_or_direction;\n\n  LOCAL\n    ndim   : INTEGER;\n    v      : direction;\n    vec    : vector;\n    mag    : REAL;\n    result : vector_or_direction;\n  END_LOCAL;\n  IF NOT EXISTS(arg) THEN\n    result := ?;\n  ELSE\n    ndim := arg.dim;\n    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN\n      BEGIN\n        v := dummy_gri || direction(arg.orientation.direction_ratios);\n        IF arg.magnitude = 0 THEN\n          RETURN(?);\n        ELSE\n          vec := dummy_gri || vector(v,1);\n        END_IF;\n      END;\n    ELSE\n      v := dummy_gri || direction(arg.direction_ratios);\n    END_IF;\n    mag := 0;\n    REPEAT i := 1 TO ndim BY 1;\n      mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);\n    END_REPEAT;\n    IF mag > 0 THEN\n      mag := SQRT(mag);\n      REPEAT i := 1 TO ndim BY 1;\n        v.direction_ratios[i] := v.direction_ratios[i] / mag;\n      END_REPEAT;\n      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN\n        vec.orientation := v;\n        result := vec;\n      ELSE\n        result := v;\n      END_IF;\n    ELSE\n      RETURN(?);\n    END_IF;\n  END_IF;\n  RETURN(result);\n\nEND_FUNCTION; -- normalise\n");
#endif
/*
FUNCTION normalise(
             arg: vector_or_direction
    ): vector_or_direction;

  LOCAL
    ndim   : INTEGER;
    v      : direction;
    vec    : vector;
    mag    : REAL;
    result : vector_or_direction;
  END_LOCAL;
  IF NOT EXISTS(arg) THEN
    result := ?;
  ELSE
    ndim := arg.dim;
    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
      BEGIN
        v := dummy_gri || direction(arg.orientation.direction_ratios);
        IF arg.magnitude = 0 THEN
          RETURN(?);
        ELSE
          vec := dummy_gri || vector(v,1);
        END_IF;
      END;
    ELSE
      v := dummy_gri || direction(arg.direction_ratios);
    END_IF;
    mag := 0;
    REPEAT i := 1 TO ndim BY 1;
      mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
    END_REPEAT;
    IF mag > 0 THEN
      mag := SQRT(mag);
      REPEAT i := 1 TO ndim BY 1;
        v.direction_ratios[i] := v.direction_ratios[i] / mag;
      END_REPEAT;
      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
        vec.orientation := v;
        result := vec;
      ELSE
        result := v;
      END_IF;
    ELSE
      RETURN(?);
    END_IF;
  END_IF;
  RETURN(result);

END_FUNCTION; -- normalise

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION msb_shells(\n             brep: manifold_solid_brep\n    ): SET [1:?] OF closed_shell;\n  IF SIZEOF(QUERY ( msbtype <* TYPEOF(brep) | (msbtype LIKE \n      '*BREP_WITH_VOIDS') )) >= 1 THEN\n    RETURN(brep\\brep_with_voids.voids + brep.outer);\n  ELSE\n    RETURN([brep.outer]);\n  END_IF;\n\nEND_FUNCTION; -- msb_shells\n");
#endif
/*
FUNCTION msb_shells(
             brep: manifold_solid_brep
    ): SET [1:?] OF closed_shell;
  IF SIZEOF(QUERY ( msbtype <* TYPEOF(brep) | (msbtype LIKE 
      '*BREP_WITH_VOIDS') )) >= 1 THEN
    RETURN(brep\brep_with_voids.voids + brep.outer);
  ELSE
    RETURN([brep.outer]);
  END_IF;

END_FUNCTION; -- msb_shells

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION mixed_loop_type_set(\n             l: SET [0:?] OF loop\n    ): LOGICAL;\n\n  LOCAL\n    poly_loop_type : LOGICAL;\n  END_LOCAL;\n  IF SIZEOF(l) <= 1 THEN\n    RETURN(FALSE);\n  END_IF;\n  poly_loop_type := 'CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[1]);\n  REPEAT i := 2 TO SIZEOF(l) BY 1;\n    IF ('CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[i])) <> \n        poly_loop_type THEN\n      RETURN(TRUE);\n    END_IF;\n  END_REPEAT;\n  RETURN(FALSE);\n\nEND_FUNCTION; -- mixed_loop_type_set\n");
#endif
/*
FUNCTION mixed_loop_type_set(
             l: SET [0:?] OF loop
    ): LOGICAL;

  LOCAL
    poly_loop_type : LOGICAL;
  END_LOCAL;
  IF SIZEOF(l) <= 1 THEN
    RETURN(FALSE);
  END_IF;
  poly_loop_type := 'CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[1]);
  REPEAT i := 2 TO SIZEOF(l) BY 1;
    IF ('CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[i])) <> 
        poly_loop_type THEN
      RETURN(TRUE);
    END_IF;
  END_REPEAT;
  RETURN(FALSE);

END_FUNCTION; -- mixed_loop_type_set

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION derive_dimensional_exponents(\n             x: unit\n    ): dimensional_exponents;\n\n  LOCAL\n    i      : INTEGER;\n    result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,0);\n  END_LOCAL;\n  result := x.dimensions;\n  RETURN(result);\n\nEND_FUNCTION; -- derive_dimensional_exponents\n");
#endif
/*
FUNCTION derive_dimensional_exponents(
             x: unit
    ): dimensional_exponents;

  LOCAL
    i      : INTEGER;
    result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,0);
  END_LOCAL;
  result := x.dimensions;
  RETURN(result);

END_FUNCTION; -- derive_dimensional_exponents

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION curve_weights_positive(\n             b: rational_b_spline_curve\n    ): BOOLEAN;\n\n  LOCAL\n    result : BOOLEAN := TRUE;\n  END_LOCAL;\n  REPEAT i := 0 TO b.upper_index_on_control_points BY 1;\n    IF b.weights[i] <= 0 THEN\n      result := FALSE;\n      RETURN(result);\n    END_IF;\n  END_REPEAT;\n  RETURN(result);\n\nEND_FUNCTION; -- curve_weights_positive\n");
#endif
/*
FUNCTION curve_weights_positive(
             b: rational_b_spline_curve
    ): BOOLEAN;

  LOCAL
    result : BOOLEAN := TRUE;
  END_LOCAL;
  REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
    IF b.weights[i] <= 0 THEN
      result := FALSE;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);

END_FUNCTION; -- curve_weights_positive

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION valid_geometrically_bounded_wf_point(\n             pnt: point\n    ): BOOLEAN;\n  IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN\n    RETURN(TRUE);\n  ELSE\n    IF 'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN\n      RETURN(valid_geometrically_bounded_wf_curve(pnt\\point_on_curve.\n          basis_curve));\n    ELSE\n      IF 'CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN\n        RETURN(valid_geometrically_bounded_wf_point(pnt\\point_replica.\n            parent_pt));\n      END_IF;\n    END_IF;\n  END_IF;\n  RETURN(FALSE);\n\nEND_FUNCTION; -- valid_geometrically_bounded_wf_point\n");
#endif
/*
FUNCTION valid_geometrically_bounded_wf_point(
             pnt: point
    ): BOOLEAN;
  IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
    RETURN(TRUE);
  ELSE
    IF 'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
      RETURN(valid_geometrically_bounded_wf_curve(pnt\point_on_curve.
          basis_curve));
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN
        RETURN(valid_geometrically_bounded_wf_point(pnt\point_replica.
            parent_pt));
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);

END_FUNCTION; -- valid_geometrically_bounded_wf_point

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION path_head_to_tail(\n             a_path: path\n    ): LOGICAL;\n\n  LOCAL\n    n : INTEGER;\n    p : BOOLEAN := TRUE;\n  END_LOCAL;\n  n := SIZEOF(a_path.edge_list);\n  REPEAT i := 2 TO n BY 1;\n    p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i].\n        edge_start);\n  END_REPEAT;\n  RETURN(p);\n\nEND_FUNCTION; -- path_head_to_tail\n");
#endif
/*
FUNCTION path_head_to_tail(
             a_path: path
    ): LOGICAL;

  LOCAL
    n : INTEGER;
    p : BOOLEAN := TRUE;
  END_LOCAL;
  n := SIZEOF(a_path.edge_list);
  REPEAT i := 2 TO n BY 1;
    p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i].
        edge_start);
  END_REPEAT;
  RETURN(p);

END_FUNCTION; -- path_head_to_tail

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION path_reversed(\n             a_path: path\n    ): oriented_path;\n\n  LOCAL\n    the_reverse : oriented_path;\n  END_LOCAL;\n  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF(a_path) THEN\n    the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.\n        edge_list)) || oriented_path(a_path\\oriented_path.path_element,NOT \n        a_path\\oriented_path.orientation);\n  ELSE\n    the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.\n        edge_list)) || oriented_path(a_path,FALSE);\n  END_IF;\n  RETURN(the_reverse);\n\nEND_FUNCTION; -- path_reversed\n");
#endif
/*
FUNCTION path_reversed(
             a_path: path
    ): oriented_path;

  LOCAL
    the_reverse : oriented_path;
  END_LOCAL;
  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF(a_path) THEN
    the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
        edge_list)) || oriented_path(a_path\oriented_path.path_element,NOT 
        a_path\oriented_path.orientation);
  ELSE
    the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
        edge_list)) || oriented_path(a_path,FALSE);
  END_IF;
  RETURN(the_reverse);

END_FUNCTION; -- path_reversed

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION leap_year(\n             year: year_number\n    ): BOOLEAN;\n  IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)\n       THEN\n    RETURN(TRUE);\n  ELSE\n    RETURN(FALSE);\n  END_IF;\n\nEND_FUNCTION; -- leap_year\n");
#endif
/*
FUNCTION leap_year(
             year: year_number
    ): BOOLEAN;
  IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)
       THEN
    RETURN(TRUE);
  ELSE
    RETURN(FALSE);
  END_IF;

END_FUNCTION; -- leap_year

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION face_reversed(\n             a_face: face\n    ): oriented_face;\n\n  LOCAL\n    the_reverse : oriented_face;\n  END_LOCAL;\n  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF(a_face) THEN\n    the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.\n        bounds)) || oriented_face(a_face\\oriented_face.face_element,NOT \n        a_face\\oriented_face.orientation);\n  ELSE\n    the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.\n        bounds)) || oriented_face(a_face,FALSE);\n  END_IF;\n  RETURN(the_reverse);\n\nEND_FUNCTION; -- face_reversed\n");
#endif
/*
FUNCTION face_reversed(
             a_face: face
    ): oriented_face;

  LOCAL
    the_reverse : oriented_face;
  END_LOCAL;
  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF(a_face) THEN
    the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
        bounds)) || oriented_face(a_face\oriented_face.face_element,NOT 
        a_face\oriented_face.orientation);
  ELSE
    the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
        bounds)) || oriented_face(a_face,FALSE);
  END_IF;
  RETURN(the_reverse);

END_FUNCTION; -- face_reversed

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION constraints_param_b_spline(\n             degree, up_knots, up_cp: INTEGER;\n             knot_mult: LIST OF INTEGER;\n             knots: LIST OF parameter_value\n    ): BOOLEAN;\n\n  LOCAL\n    k      : INTEGER;\n    sum    : INTEGER;\n    result : BOOLEAN := TRUE;\n  END_LOCAL;\n  sum := knot_mult[1];\n  REPEAT i := 2 TO up_knots BY 1;\n    sum := sum + knot_mult[i];\n  END_REPEAT;\n  IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (degree \n      + up_cp + 2)) THEN\n    result := FALSE;\n    RETURN(result);\n  END_IF;\n  k := knot_mult[1];\n  IF (k < 1) OR (k > (degree + 1)) THEN\n    result := FALSE;\n    RETURN(result);\n  END_IF;\n  REPEAT i := 2 TO up_knots BY 1;\n    IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN\n      result := FALSE;\n      RETURN(result);\n    END_IF;\n    k := knot_mult[i];\n    IF (i < up_knots) AND (k > degree) THEN\n      result := FALSE;\n      RETURN(result);\n    END_IF;\n    IF (i = up_knots) AND (k > (degree + 1)) THEN\n      result := FALSE;\n      RETURN(result);\n    END_IF;\n  END_REPEAT;\n  RETURN(result);\n\nEND_FUNCTION; -- constraints_param_b_spline\n");
#endif
/*
FUNCTION constraints_param_b_spline(
             degree, up_knots, up_cp: INTEGER;
             knot_mult: LIST OF INTEGER;
             knots: LIST OF parameter_value
    ): BOOLEAN;

  LOCAL
    k      : INTEGER;
    sum    : INTEGER;
    result : BOOLEAN := TRUE;
  END_LOCAL;
  sum := knot_mult[1];
  REPEAT i := 2 TO up_knots BY 1;
    sum := sum + knot_mult[i];
  END_REPEAT;
  IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (degree 
      + up_cp + 2)) THEN
    result := FALSE;
    RETURN(result);
  END_IF;
  k := knot_mult[1];
  IF (k < 1) OR (k > (degree + 1)) THEN
    result := FALSE;
    RETURN(result);
  END_IF;
  REPEAT i := 2 TO up_knots BY 1;
    IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[i];
    IF (i < up_knots) AND (k > degree) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    IF (i = up_knots) AND (k > (degree + 1)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);

END_FUNCTION; -- constraints_param_b_spline

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION using_representations(\n             item: founded_item_select\n    ): SET OF representation;\n\n  LOCAL\n    results            : SET OF representation;\n    intermediate_items : SET OF founded_item_select;\n    result_bag         : BAG OF representation;\n  END_LOCAL;\n  results := [];\n  result_bag := USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS');\n  IF SIZEOF(result_bag) > 0 THEN\n    REPEAT i := 1 TO HIINDEX(result_bag) BY 1;\n      results := results + result_bag[i];\n    END_REPEAT;\n  END_IF;\n  intermediate_items := using_items(item,[]);\n  IF SIZEOF(intermediate_items) > 0 THEN\n    REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;\n      result_bag := USEDIN(intermediate_items[i],\n          'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS');\n      IF SIZEOF(result_bag) > 0 THEN\n        REPEAT j := 1 TO HIINDEX(result_bag) BY 1;\n          results := results + result_bag[j];\n        END_REPEAT;\n      END_IF;\n    END_REPEAT;\n  END_IF;\n  RETURN(results);\n\nEND_FUNCTION; -- using_representations\n");
#endif
/*
FUNCTION using_representations(
             item: founded_item_select
    ): SET OF representation;

  LOCAL
    results            : SET OF representation;
    intermediate_items : SET OF founded_item_select;
    result_bag         : BAG OF representation;
  END_LOCAL;
  results := [];
  result_bag := USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  intermediate_items := using_items(item,[]);
  IF SIZEOF(intermediate_items) > 0 THEN
    REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
      result_bag := USEDIN(intermediate_items[i],
          'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(results);

END_FUNCTION; -- using_representations

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION associated_surface(\n             arg: pcurve_or_surface\n    ): surface;\n\n  LOCAL\n    surf : surface;\n  END_LOCAL;\n  IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(arg) THEN\n    surf := arg.basis_surface;\n  ELSE\n    surf := arg;\n  END_IF;\n  RETURN(surf);\n\nEND_FUNCTION; -- associated_surface\n");
#endif
/*
FUNCTION associated_surface(
             arg: pcurve_or_surface
    ): surface;

  LOCAL
    surf : surface;
  END_LOCAL;
  IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(arg) THEN
    surf := arg.basis_surface;
  ELSE
    surf := arg;
  END_IF;
  RETURN(surf);

END_FUNCTION; -- associated_surface

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION acyclic_point_replica(\n             rep: point_replica;\n             parent: point\n    ): BOOLEAN;\n  IF NOT ('CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(parent)) THEN\n    RETURN(TRUE);\n  END_IF;\n  IF parent :=: rep THEN\n    RETURN(FALSE);\n  ELSE\n    RETURN(acyclic_point_replica(rep,parent\\point_replica.parent_pt));\n  END_IF;\n\nEND_FUNCTION; -- acyclic_point_replica\n");
#endif
/*
FUNCTION acyclic_point_replica(
             rep: point_replica;
             parent: point
    ): BOOLEAN;
  IF NOT ('CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(parent)) THEN
    RETURN(TRUE);
  END_IF;
  IF parent :=: rep THEN
    RETURN(FALSE);
  ELSE
    RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
  END_IF;

END_FUNCTION; -- acyclic_point_replica

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION cross_product(\n             arg1, arg2: direction\n    ): vector;\n\n  LOCAL\n    v2     : LIST [3:3] OF REAL;\n    v1     : LIST [3:3] OF REAL;\n    mag    : REAL;\n    res    : direction;\n    result : vector;\n  END_LOCAL;\n  IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2.\n      dim = 2) THEN\n    RETURN(?);\n  ELSE\n    BEGIN\n      v1 := normalise(arg1).direction_ratios;\n      v2 := normalise(arg2).direction_ratios;\n      res := dummy_gri || direction([(v1[2] * v2[3]) - (v1[3] * v2[2]),(v1\n          [3] * v2[1]) - (v1[1] * v2[3]),(v1[1] * v2[2]) - (v1[2] * v2[1])]);\n      mag := 0;\n      REPEAT i := 1 TO 3 BY 1;\n        mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);\n      END_REPEAT;\n      IF mag > 0 THEN\n        result := dummy_gri || vector(res,SQRT(mag));\n      ELSE\n        result := dummy_gri || vector(arg1,0);\n      END_IF;\n      RETURN(result);\n    END;\n  END_IF;\n\nEND_FUNCTION; -- cross_product\n");
#endif
/*
FUNCTION cross_product(
             arg1, arg2: direction
    ): vector;

  LOCAL
    v2     : LIST [3:3] OF REAL;
    v1     : LIST [3:3] OF REAL;
    mag    : REAL;
    res    : direction;
    result : vector;
  END_LOCAL;
  IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2.
      dim = 2) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1 := normalise(arg1).direction_ratios;
      v2 := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2] * v2[3]) - (v1[3] * v2[2]),(v1
          [3] * v2[1]) - (v1[1] * v2[3]),(v1[1] * v2[2]) - (v1[2] * v2[1])]);
      mag := 0;
      REPEAT i := 1 TO 3 BY 1;
        mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        result := dummy_gri || vector(res,SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1,0);
      END_IF;
      RETURN(result);
    END;
  END_IF;

END_FUNCTION; -- cross_product

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION valid_units(\n             m: measure_with_unit\n    ): BOOLEAN;\n  IF 'CONFIG_CONTROL_DESIGN.LENGTH_MEASURE' IN TYPEOF(m.value_component)\n       THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(1,0,0,0,0,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.MASS_MEASURE' IN TYPEOF(m.value_component)\n       THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(0,1,0,0,0,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.TIME_MEASURE' IN TYPEOF(m.value_component)\n       THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(0,0,1,0,0,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.\n      value_component) THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(0,0,0,1,0,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m\n      .value_component) THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(0,0,0,0,1,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.\n      value_component) THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(0,0,0,0,0,1,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.\n      value_component) THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(0,0,0,0,0,0,1) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_MEASURE' IN TYPEOF(m.\n      value_component) THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(0,0,0,0,0,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_MEASURE' IN TYPEOF(m.\n      value_component) THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(0,0,0,0,0,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.AREA_MEASURE' IN TYPEOF(m.value_component)\n       THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(2,0,0,0,0,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.VOLUME_MEASURE' IN TYPEOF(m.value_component)\n       THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(3,0,0,0,0,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.RATIO_MEASURE' IN TYPEOF(m.value_component)\n       THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(0,0,0,0,0,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.\n      value_component) THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(1,0,0,0,0,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  IF 'CONFIG_CONTROL_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.\n      value_component) THEN\n    IF derive_dimensional_exponents(m.unit_component) <> \n        dimensional_exponents(0,0,0,0,0,0,0) THEN\n      RETURN(FALSE);\n    END_IF;\n  END_IF;\n  RETURN(TRUE);\n\nEND_FUNCTION; -- valid_units\n");
#endif
/*
FUNCTION valid_units(
             m: measure_with_unit
    ): BOOLEAN;
  IF 'CONFIG_CONTROL_DESIGN.LENGTH_MEASURE' IN TYPEOF(m.value_component)
       THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(1,0,0,0,0,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.MASS_MEASURE' IN TYPEOF(m.value_component)
       THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0,1,0,0,0,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.TIME_MEASURE' IN TYPEOF(m.value_component)
       THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0,0,1,0,0,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
      value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0,0,0,1,0,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m
      .value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0,0,0,0,1,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
      value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0,0,0,0,0,1,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
      value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0,0,0,0,0,0,1) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
      value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0,0,0,0,0,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
      value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0,0,0,0,0,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.AREA_MEASURE' IN TYPEOF(m.value_component)
       THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(2,0,0,0,0,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.VOLUME_MEASURE' IN TYPEOF(m.value_component)
       THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(3,0,0,0,0,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.RATIO_MEASURE' IN TYPEOF(m.value_component)
       THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0,0,0,0,0,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
      value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(1,0,0,0,0,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  IF 'CONFIG_CONTROL_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
      value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0,0,0,0,0,0,0) THEN
      RETURN(FALSE);
    END_IF;
  END_IF;
  RETURN(TRUE);

END_FUNCTION; -- valid_units

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION constraints_rectangular_composite_surface(\n             s: rectangular_composite_surface\n    ): BOOLEAN;\n  REPEAT i := 1 TO s.n_u BY 1;\n    REPEAT j := 1 TO s.n_v BY 1;\n      IF NOT (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(s.\n          segments[i][j].parent_surface)) OR (\n          'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s.\n          segments[i][j].parent_surface))) THEN\n        RETURN(FALSE);\n      END_IF;\n    END_REPEAT;\n  END_REPEAT;\n  REPEAT i := 1 TO s.n_u - 1 BY 1;\n    REPEAT j := 1 TO s.n_v BY 1;\n      IF s.segments[i][j].u_transition = discontinuous THEN\n        RETURN(FALSE);\n      END_IF;\n    END_REPEAT;\n  END_REPEAT;\n  REPEAT i := 1 TO s.n_u BY 1;\n    REPEAT j := 1 TO s.n_v - 1 BY 1;\n      IF s.segments[i][j].v_transition = discontinuous THEN\n        RETURN(FALSE);\n      END_IF;\n    END_REPEAT;\n  END_REPEAT;\n  RETURN(TRUE);\n\nEND_FUNCTION; -- constraints_rectangular_composite_surface\n");
#endif
/*
FUNCTION constraints_rectangular_composite_surface(
             s: rectangular_composite_surface
    ): BOOLEAN;
  REPEAT i := 1 TO s.n_u BY 1;
    REPEAT j := 1 TO s.n_v BY 1;
      IF NOT (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(s.
          segments[i][j].parent_surface)) OR (
          'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s.
          segments[i][j].parent_surface))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  REPEAT i := 1 TO s.n_u - 1 BY 1;
    REPEAT j := 1 TO s.n_v BY 1;
      IF s.segments[i][j].u_transition = discontinuous THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  REPEAT i := 1 TO s.n_u BY 1;
    REPEAT j := 1 TO s.n_v - 1 BY 1;
      IF s.segments[i][j].v_transition = discontinuous THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN(TRUE);

END_FUNCTION; -- constraints_rectangular_composite_surface

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION closed_shell_reversed(\n             a_shell: closed_shell\n    ): oriented_closed_shell;\n\n  LOCAL\n    the_reverse : oriented_closed_shell;\n  END_LOCAL;\n  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell)\n       THEN\n    the_reverse := dummy_tri || connected_face_set(a_shell\\\n        connected_face_set.cfs_faces) || closed_shell() || \n        oriented_closed_shell(a_shell\\oriented_closed_shell.\n        closed_shell_element,NOT a_shell\\oriented_closed_shell.orientation);\n  ELSE\n    the_reverse := dummy_tri || connected_face_set(a_shell\\\n        connected_face_set.cfs_faces) || closed_shell() || \n        oriented_closed_shell(a_shell,FALSE);\n  END_IF;\n  RETURN(the_reverse);\n\nEND_FUNCTION; -- closed_shell_reversed\n");
#endif
/*
FUNCTION closed_shell_reversed(
             a_shell: closed_shell
    ): oriented_closed_shell;

  LOCAL
    the_reverse : oriented_closed_shell;
  END_LOCAL;
  IF 'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell)
       THEN
    the_reverse := dummy_tri || connected_face_set(a_shell\
        connected_face_set.cfs_faces) || closed_shell() || 
        oriented_closed_shell(a_shell\oriented_closed_shell.
        closed_shell_element,NOT a_shell\oriented_closed_shell.orientation);
  ELSE
    the_reverse := dummy_tri || connected_face_set(a_shell\
        connected_face_set.cfs_faces) || closed_shell() || 
        oriented_closed_shell(a_shell,FALSE);
  END_IF;
  RETURN(the_reverse);

END_FUNCTION; -- closed_shell_reversed

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION boolean_choose(\n             b: BOOLEAN;\n             choice1, choice2: GENERIC:item\n    ): GENERIC:item;\n  IF b THEN\n    RETURN(choice1);\n  ELSE\n    RETURN(choice2);\n  END_IF;\n\nEND_FUNCTION; -- boolean_choose\n");
#endif
/*
FUNCTION boolean_choose(
             b: BOOLEAN;
             choice1, choice2: GENERIC:item
    ): GENERIC:item;
  IF b THEN
    RETURN(choice1);
  ELSE
    RETURN(choice2);
  END_IF;

END_FUNCTION; -- boolean_choose

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION valid_time(\n             time: local_time\n    ): BOOLEAN;\n  IF EXISTS(time.second_component) THEN\n    RETURN(EXISTS(time.minute_component));\n  ELSE\n    RETURN(TRUE);\n  END_IF;\n\nEND_FUNCTION; -- valid_time\n");
#endif
/*
FUNCTION valid_time(
             time: local_time
    ): BOOLEAN;
  IF EXISTS(time.second_component) THEN
    RETURN(EXISTS(time.minute_component));
  ELSE
    RETURN(TRUE);
  END_IF;

END_FUNCTION; -- valid_time

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION valid_geometrically_bounded_wf_curve(\n             crv: curve\n    ): BOOLEAN;\n  IF SIZEOF(['CONFIG_CONTROL_DESIGN.POLYLINE',\n      'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE',\n      'CONFIG_CONTROL_DESIGN.ELLIPSE','CONFIG_CONTROL_DESIGN.CIRCLE'] * \n      TYPEOF(crv)) = 1 THEN\n    RETURN(TRUE);\n  ELSE\n    IF 'CONFIG_CONTROL_DESIGN.TRIMMED_CURVE' IN TYPEOF(crv) THEN\n      IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',\n          'CONFIG_CONTROL_DESIGN.PARABOLA',\n          'CONFIG_CONTROL_DESIGN.HYPERBOLA'] * TYPEOF(crv\\trimmed_curve.\n          basis_curve)) = 1 THEN\n        RETURN(TRUE);\n      ELSE\n        RETURN(valid_geometrically_bounded_wf_curve(crv\\trimmed_curve.\n            basis_curve));\n      END_IF;\n    ELSE\n      IF 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN\n        RETURN(valid_geometrically_bounded_wf_curve(crv\\offset_curve_3d.\n            basis_curve));\n      ELSE\n        IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN\n          RETURN(valid_geometrically_bounded_wf_curve(crv\\curve_replica.\n              parent_curve));\n        ELSE\n          IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE' IN TYPEOF(crv) THEN\n            RETURN(SIZEOF(QUERY ( ccs <* crv\\composite_curve.segments | (\n                NOT valid_geometrically_bounded_wf_curve(ccs.parent_curve)) )) \n                = 0);\n          END_IF;\n        END_IF;\n      END_IF;\n    END_IF;\n  END_IF;\n  RETURN(FALSE);\n\nEND_FUNCTION; -- valid_geometrically_bounded_wf_curve\n");
#endif
/*
FUNCTION valid_geometrically_bounded_wf_curve(
             crv: curve
    ): BOOLEAN;
  IF SIZEOF(['CONFIG_CONTROL_DESIGN.POLYLINE',
      'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE',
      'CONFIG_CONTROL_DESIGN.ELLIPSE','CONFIG_CONTROL_DESIGN.CIRCLE'] * 
      TYPEOF(crv)) = 1 THEN
    RETURN(TRUE);
  ELSE
    IF 'CONFIG_CONTROL_DESIGN.TRIMMED_CURVE' IN TYPEOF(crv) THEN
      IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',
          'CONFIG_CONTROL_DESIGN.PARABOLA',
          'CONFIG_CONTROL_DESIGN.HYPERBOLA'] * TYPEOF(crv\trimmed_curve.
          basis_curve)) = 1 THEN
        RETURN(TRUE);
      ELSE
        RETURN(valid_geometrically_bounded_wf_curve(crv\trimmed_curve.
            basis_curve));
      END_IF;
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
        RETURN(valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.
            basis_curve));
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN
          RETURN(valid_geometrically_bounded_wf_curve(crv\curve_replica.
              parent_curve));
        ELSE
          IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE' IN TYPEOF(crv) THEN
            RETURN(SIZEOF(QUERY ( ccs <* crv\composite_curve.segments | (
                NOT valid_geometrically_bounded_wf_curve(ccs.parent_curve)) )) 
                = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);

END_FUNCTION; -- valid_geometrically_bounded_wf_curve

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION dot_product(\n             arg1, arg2: direction\n    ): REAL;\n\n  LOCAL\n    ndim   : INTEGER;\n    scalar : REAL;\n    vec1   : direction;\n    vec2   : direction;\n  END_LOCAL;\n  IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN\n    scalar := ?;\n  ELSE\n    IF arg1.dim <> arg2.dim THEN\n      scalar := ?;\n    ELSE\n      BEGIN\n        vec1 := normalise(arg1);\n        vec2 := normalise(arg2);\n        ndim := arg1.dim;\n        scalar := 0;\n        REPEAT i := 1 TO ndim BY 1;\n          scalar := scalar + (vec1.direction_ratios[i] * vec2.\n              direction_ratios[i]);\n        END_REPEAT;\n      END;\n    END_IF;\n  END_IF;\n  RETURN(scalar);\n\nEND_FUNCTION; -- dot_product\n");
#endif
/*
FUNCTION dot_product(
             arg1, arg2: direction
    ): REAL;

  LOCAL
    ndim   : INTEGER;
    scalar : REAL;
    vec1   : direction;
    vec2   : direction;
  END_LOCAL;
  IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
    scalar := ?;
  ELSE
    IF arg1.dim <> arg2.dim THEN
      scalar := ?;
    ELSE
      BEGIN
        vec1 := normalise(arg1);
        vec2 := normalise(arg2);
        ndim := arg1.dim;
        scalar := 0;
        REPEAT i := 1 TO ndim BY 1;
          scalar := scalar + (vec1.direction_ratios[i] * vec2.
              direction_ratios[i]);
        END_REPEAT;
      END;
    END_IF;
  END_IF;
  RETURN(scalar);

END_FUNCTION; -- dot_product

*/
#ifndef MSWIN
	s_config_control_design->AddFunction("FUNCTION acyclic_curve_replica(\n             rep: curve_replica;\n             parent: curve\n    ): BOOLEAN;\n  IF NOT ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(parent)) THEN\n    RETURN(TRUE);\n  END_IF;\n  IF parent :=: rep THEN\n    RETURN(FALSE);\n  ELSE\n    RETURN(acyclic_curve_replica(rep,parent\\curve_replica.parent_curve));\n  END_IF;\n\nEND_FUNCTION; -- acyclic_curve_replica\n");
#endif
/*
FUNCTION acyclic_curve_replica(
             rep: curve_replica;
             parent: curve
    ): BOOLEAN;
  IF NOT ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(parent)) THEN
    RETURN(TRUE);
  END_IF;
  IF parent :=: rep THEN
    RETURN(FALSE);
  ELSE
    RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
  END_IF;

END_FUNCTION; -- acyclic_curve_replica

*/

	//	*****  Initialize the Types
	config_control_designt_characterized_definition = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Characterized_Definition",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Characterized_Product_Definition, Shape_Definition)",	// Description
		  (SelectCreator) create_SdaiCharacterized_definition);	// Creator function
	s_config_control_design->AddType(config_control_designt_characterized_definition);
	config_control_designt_parameter_value = new TypeDescriptor (
		  "Parameter_Value",	// Name
		  sdaiREAL,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "REAL");	// Description
	s_config_control_design->AddType(config_control_designt_parameter_value);
	config_control_designt_plane_angle_measure = new TypeDescriptor (
		  "Plane_Angle_Measure",	// Name
		  sdaiREAL,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "REAL");	// Description
	s_config_control_design->AddType(config_control_designt_plane_angle_measure);
	config_control_designt_change_request_item = new SelectTypeDescriptor (
		  ~(0),	//unique elements,
		  "Change_Request_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Product_Definition_Formation)",	// Description
		  (SelectCreator) create_SdaiChange_request_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_change_request_item);
	config_control_designt_text = new TypeDescriptor (
		  "Text",	// Name
		  sdaiSTRING,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "STRING");	// Description
	s_config_control_design->AddType(config_control_designt_text);
	config_control_designt_year_number = new TypeDescriptor (
		  "Year_Number",	// Name
		  sdaiINTEGER,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "INTEGER");	// Description
	s_config_control_design->AddType(config_control_designt_year_number);
	config_control_designt_characterized_product_definition = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Characterized_Product_Definition",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Product_Definition, Product_Definition_Relationship)",	// Description
		  (SelectCreator) create_SdaiCharacterized_product_definition);	// Creator function
	s_config_control_design->AddType(config_control_designt_characterized_product_definition);
	config_control_designt_reversible_topology_item = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Reversible_Topology_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Edge, Path, Face, Face_Bound, Closed_Shell, Open_Shell)",	// Description
		  (SelectCreator) create_SdaiReversible_topology_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_reversible_topology_item);
	config_control_designt_axis2_placement = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Axis2_Placement",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Axis2_Placement_2d, Axis2_Placement_3d)",	// Description
		  (SelectCreator) create_SdaiAxis2_placement);	// Creator function
	s_config_control_design->AddType(config_control_designt_axis2_placement);

	config_control_designt_set_of_reversible_topology_item = new SetTypeDescriptor (
		  "Set_Of_Reversible_Topology_Item",	// Name
		  SET_TYPE,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SET [0:?] OF reversible_topology_item",	// Description
		  (AggregateCreator) create_SdaiSet_of_reversible_topology_item);	// Creator function

	s_config_control_design->AddType(config_control_designt_set_of_reversible_topology_item);
	config_control_designt_week_in_year_number = new TypeDescriptor (
		  "Week_In_Year_Number",	// Name
		  sdaiINTEGER,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "INTEGER");	// Description
	s_config_control_design->AddType(config_control_designt_week_in_year_number);
	config_control_designt_week_in_year_number->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ((1 <= SELF) AND (SELF <= 53));\n");
	config_control_designt_week_in_year_number->_where_rules->Append(wr);
	config_control_designt_knot_type = new EnumTypeDescriptor (
		  "Knot_Type",	// Name
		  sdaiENUMERATION,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "ENUMERATION of (uniform_knots, unspecified, quasi_uniform_knots, piecewise_bezier_knots)",	// Description
		  (EnumCreator) create_SdaiKnot_type_var);	// Creator function
	s_config_control_design->AddType(config_control_designt_knot_type);
	config_control_designt_specified_item = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Specified_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Product_Definition, Shape_Aspect)",	// Description
		  (SelectCreator) create_SdaiSpecified_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_specified_item);
	config_control_designt_minute_in_hour = new TypeDescriptor (
		  "Minute_In_Hour",	// Name
		  sdaiINTEGER,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "INTEGER");	// Description
	s_config_control_design->AddType(config_control_designt_minute_in_hour);
	config_control_designt_minute_in_hour->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ((0 <= SELF) AND (SELF <= 59));\n");
	config_control_designt_minute_in_hour->_where_rules->Append(wr);
	config_control_designt_transition_code = new EnumTypeDescriptor (
		  "Transition_Code",	// Name
		  sdaiENUMERATION,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "ENUMERATION of (discontinuous, continuous, cont_same_gradient, cont_same_gradient_same_curvature)",	// Description
		  (EnumCreator) create_SdaiTransition_code_var);	// Creator function
	s_config_control_design->AddType(config_control_designt_transition_code);
	config_control_designt_identifier = new TypeDescriptor (
		  "Identifier",	// Name
		  sdaiSTRING,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "STRING");	// Description
	s_config_control_design->AddType(config_control_designt_identifier);
	config_control_designt_measure_value = new SelectTypeDescriptor (
		  ~(sdaiREAL),	//unique elements,
		  "Measure_Value",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Length_Measure, Mass_Measure, Plane_Angle_Measure, Solid_Angle_Measure, Area_Measure, Volume_Measure, Parameter_Value, Context_Dependent_Measure, Descriptive_Measure, Positive_Length_Measure, Positive_Plane_Angle_Measure, Count_Measure)",	// Description
		  (SelectCreator) create_SdaiMeasure_value);	// Creator function
	s_config_control_design->AddType(config_control_designt_measure_value);
	config_control_designt_person_organization_select = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Person_Organization_Select",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Person, Organization, Person_And_Organization)",	// Description
		  (SelectCreator) create_SdaiPerson_organization_select);	// Creator function
	s_config_control_design->AddType(config_control_designt_person_organization_select);
	config_control_designt_preferred_surface_curve_representation = new EnumTypeDescriptor (
		  "Preferred_Surface_Curve_Representation",	// Name
		  sdaiENUMERATION,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "ENUMERATION of (curve_3d, pcurve_s1, pcurve_s2)",	// Description
		  (EnumCreator) create_SdaiPreferred_surface_curve_representation_var);	// Creator function
	s_config_control_design->AddType(config_control_designt_preferred_surface_curve_representation);
	config_control_designt_dimension_count = new TypeDescriptor (
		  "Dimension_Count",	// Name
		  sdaiINTEGER,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "INTEGER");	// Description
	s_config_control_design->AddType(config_control_designt_dimension_count);
	config_control_designt_dimension_count->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF > 0);\n");
	config_control_designt_dimension_count->_where_rules->Append(wr);
	config_control_designt_pcurve_or_surface = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Pcurve_Or_Surface",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Pcurve, Surface)",	// Description
		  (SelectCreator) create_SdaiPcurve_or_surface);	// Creator function
	s_config_control_design->AddType(config_control_designt_pcurve_or_surface);
	config_control_designt_positive_length_measure = new TypeDescriptor (
		  "Positive_Length_Measure",	// Name
		  REFERENCE_TYPE,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "length_measure");	// Description
	s_config_control_design->AddType(config_control_designt_positive_length_measure);
	config_control_designt_positive_length_measure->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF > 0);\n");
	config_control_designt_positive_length_measure->_where_rules->Append(wr);
	config_control_designt_b_spline_curve_form = new EnumTypeDescriptor (
		  "B_Spline_Curve_Form",	// Name
		  sdaiENUMERATION,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "ENUMERATION of (polyline_form, circular_arc, elliptic_arc, parabolic_arc, hyperbolic_arc, unspecified)",	// Description
		  (EnumCreator) create_SdaiB_spline_curve_form_var);	// Creator function
	s_config_control_design->AddType(config_control_designt_b_spline_curve_form);
	config_control_designt_hour_in_day = new TypeDescriptor (
		  "Hour_In_Day",	// Name
		  sdaiINTEGER,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "INTEGER");	// Description
	s_config_control_design->AddType(config_control_designt_hour_in_day);
	config_control_designt_hour_in_day->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ((0 <= SELF) AND (SELF < 24));\n");
	config_control_designt_hour_in_day->_where_rules->Append(wr);
	config_control_designt_classified_item = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Classified_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Product_Definition_Formation, Assembly_Component_Usage)",	// Description
		  (SelectCreator) create_SdaiClassified_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_classified_item);
	config_control_designt_si_unit_name = new EnumTypeDescriptor (
		  "Si_Unit_Name",	// Name
		  sdaiENUMERATION,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "ENUMERATION of (metre, gram, second, ampere, kelvin, mole, candela, radian, steradian, hertz, newton, pascal, joule, watt, coulomb, volt, farad, ohm, siemens, weber, tesla, henry, degree_celsius, lumen, lux, becquerel, gray, sievert)",	// Description
		  (EnumCreator) create_SdaiSi_unit_name_var);	// Creator function
	s_config_control_design->AddType(config_control_designt_si_unit_name);
	config_control_designt_day_in_month_number = new TypeDescriptor (
		  "Day_In_Month_Number",	// Name
		  sdaiINTEGER,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "INTEGER");	// Description
	s_config_control_design->AddType(config_control_designt_day_in_month_number);
	config_control_designt_founded_item_select = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Founded_Item_Select",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Founded_Item, Representation_Item)",	// Description
		  (SelectCreator) create_SdaiFounded_item_select);	// Creator function
	s_config_control_design->AddType(config_control_designt_founded_item_select);
	config_control_designt_trimming_preference = new EnumTypeDescriptor (
		  "Trimming_Preference",	// Name
		  sdaiENUMERATION,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "ENUMERATION of (cartesian, parameter, unspecified)",	// Description
		  (EnumCreator) create_SdaiTrimming_preference_var);	// Creator function
	s_config_control_design->AddType(config_control_designt_trimming_preference);
	config_control_designt_vector_or_direction = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Vector_Or_Direction",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Vector, Direction)",	// Description
		  (SelectCreator) create_SdaiVector_or_direction);	// Creator function
	s_config_control_design->AddType(config_control_designt_vector_or_direction);
	config_control_designt_wireframe_model = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Wireframe_Model",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Shell_Based_Wireframe_Model, Edge_Based_Wireframe_Model)",	// Description
		  (SelectCreator) create_SdaiWireframe_model);	// Creator function
	s_config_control_design->AddType(config_control_designt_wireframe_model);
	config_control_designt_volume_measure = new TypeDescriptor (
		  "Volume_Measure",	// Name
		  sdaiREAL,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "REAL");	// Description
	s_config_control_design->AddType(config_control_designt_volume_measure);
	config_control_designt_geometric_set_select = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Geometric_Set_Select",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Point, Curve, Surface)",	// Description
		  (SelectCreator) create_SdaiGeometric_set_select);	// Creator function
	s_config_control_design->AddType(config_control_designt_geometric_set_select);
	config_control_designt_positive_plane_angle_measure = new TypeDescriptor (
		  "Positive_Plane_Angle_Measure",	// Name
		  REFERENCE_TYPE,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "plane_angle_measure");	// Description
	s_config_control_design->AddType(config_control_designt_positive_plane_angle_measure);
	config_control_designt_positive_plane_angle_measure->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF > 0);\n");
	config_control_designt_positive_plane_angle_measure->_where_rules->Append(wr);
	config_control_designt_start_request_item = new SelectTypeDescriptor (
		  ~(0),	//unique elements,
		  "Start_Request_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Product_Definition_Formation)",	// Description
		  (SelectCreator) create_SdaiStart_request_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_start_request_item);
	config_control_designt_b_spline_surface_form = new EnumTypeDescriptor (
		  "B_Spline_Surface_Form",	// Name
		  sdaiENUMERATION,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "ENUMERATION of (plane_surf, cylindrical_surf, conical_surf, spherical_surf, toroidal_surf, surf_of_revolution, ruled_surf, generalised_cone, quadric_surf, surf_of_linear_extrusion, unspecified)",	// Description
		  (EnumCreator) create_SdaiB_spline_surface_form_var);	// Creator function
	s_config_control_design->AddType(config_control_designt_b_spline_surface_form);
	config_control_designt_person_organization_item = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Person_Organization_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Change, Start_Work, Change_Request, Start_Request, Configuration_Item, Product, Product_Definition_Formation, Product_Definition, Contract, Security_Classification)",	// Description
		  (SelectCreator) create_SdaiPerson_organization_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_person_organization_item);
	config_control_designt_date_time_item = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Date_Time_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Product_Definition, Change_Request, Start_Request, Change, Start_Work, Approval_Person_Organization, Contract, Security_Classification, Certification)",	// Description
		  (SelectCreator) create_SdaiDate_time_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_date_time_item);
	config_control_designt_shell = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Shell",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Vertex_Shell, Wire_Shell, Open_Shell, Closed_Shell)",	// Description
		  (SelectCreator) create_SdaiShell);	// Creator function
	s_config_control_design->AddType(config_control_designt_shell);
	config_control_designt_transformation = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Transformation",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Item_Defined_Transformation, Functionally_Defined_Transformation)",	// Description
		  (SelectCreator) create_SdaiTransformation);	// Creator function
	s_config_control_design->AddType(config_control_designt_transformation);
	config_control_designt_day_in_week_number = new TypeDescriptor (
		  "Day_In_Week_Number",	// Name
		  sdaiINTEGER,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "INTEGER");	// Description
	s_config_control_design->AddType(config_control_designt_day_in_week_number);
	config_control_designt_day_in_week_number->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ((1 <= SELF) AND (SELF <= 7));\n");
	config_control_designt_day_in_week_number->_where_rules->Append(wr);
	config_control_designt_boolean_operand = new SelectTypeDescriptor (
		  ~(0),	//unique elements,
		  "Boolean_Operand",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Solid_Model)",	// Description
		  (SelectCreator) create_SdaiBoolean_operand);	// Creator function
	s_config_control_design->AddType(config_control_designt_boolean_operand);
	config_control_designt_certified_item = new SelectTypeDescriptor (
		  ~(0),	//unique elements,
		  "Certified_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Supplied_Part_Relationship)",	// Description
		  (SelectCreator) create_SdaiCertified_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_certified_item);
	config_control_designt_date_time_select = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Date_Time_Select",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Date, Local_Time, Date_And_Time)",	// Description
		  (SelectCreator) create_SdaiDate_time_select);	// Creator function
	s_config_control_design->AddType(config_control_designt_date_time_select);
	config_control_designt_solid_angle_measure = new TypeDescriptor (
		  "Solid_Angle_Measure",	// Name
		  sdaiREAL,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "REAL");	// Description
	s_config_control_design->AddType(config_control_designt_solid_angle_measure);
	config_control_designt_curve_on_surface = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Curve_On_Surface",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Pcurve, Surface_Curve, Composite_Curve_On_Surface)",	// Description
		  (SelectCreator) create_SdaiCurve_on_surface);	// Creator function
	s_config_control_design->AddType(config_control_designt_curve_on_surface);
	config_control_designt_trimming_select = new SelectTypeDescriptor (
		  ~(0),	//unique elements,
		  "Trimming_Select",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Cartesian_Point, Parameter_Value)",	// Description
		  (SelectCreator) create_SdaiTrimming_select);	// Creator function
	s_config_control_design->AddType(config_control_designt_trimming_select);
	config_control_designt_ahead_or_behind = new EnumTypeDescriptor (
		  "Ahead_Or_Behind",	// Name
		  sdaiENUMERATION,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "ENUMERATION of (ahead, behind)",	// Description
		  (EnumCreator) create_SdaiAhead_or_behind_var);	// Creator function
	s_config_control_design->AddType(config_control_designt_ahead_or_behind);
	config_control_designt_contracted_item = new SelectTypeDescriptor (
		  ~(0),	//unique elements,
		  "Contracted_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Product_Definition_Formation)",	// Description
		  (SelectCreator) create_SdaiContracted_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_contracted_item);
	config_control_designt_day_in_year_number = new TypeDescriptor (
		  "Day_In_Year_Number",	// Name
		  sdaiINTEGER,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "INTEGER");	// Description
	s_config_control_design->AddType(config_control_designt_day_in_year_number);
	config_control_designt_mass_measure = new TypeDescriptor (
		  "Mass_Measure",	// Name
		  sdaiREAL,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "REAL");	// Description
	s_config_control_design->AddType(config_control_designt_mass_measure);
	config_control_designt_descriptive_measure = new TypeDescriptor (
		  "Descriptive_Measure",	// Name
		  sdaiSTRING,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "STRING");	// Description
	s_config_control_design->AddType(config_control_designt_descriptive_measure);
	config_control_designt_area_measure = new TypeDescriptor (
		  "Area_Measure",	// Name
		  sdaiREAL,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "REAL");	// Description
	s_config_control_design->AddType(config_control_designt_area_measure);
	config_control_designt_month_in_year_number = new TypeDescriptor (
		  "Month_In_Year_Number",	// Name
		  sdaiINTEGER,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "INTEGER");	// Description
	s_config_control_design->AddType(config_control_designt_month_in_year_number);
	config_control_designt_month_in_year_number->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ((1 <= SELF) AND (SELF <= 12));\n");
	config_control_designt_month_in_year_number->_where_rules->Append(wr);
	config_control_designt_source = new EnumTypeDescriptor (
		  "Source",	// Name
		  sdaiENUMERATION,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "ENUMERATION of (made, bought, not_known)",	// Description
		  (EnumCreator) create_SdaiSource_var);	// Creator function
	s_config_control_design->AddType(config_control_designt_source);
	config_control_designt_unit = new SelectTypeDescriptor (
		  ~(0),	//unique elements,
		  "Unit",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Named_Unit)",	// Description
		  (SelectCreator) create_SdaiUnit);	// Creator function
	s_config_control_design->AddType(config_control_designt_unit);
	config_control_designt_reversible_topology = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE | sdaiAGGR),	//unique elements,
		  "Reversible_Topology",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Reversible_Topology_Item, List_Of_Reversible_Topology_Item, Set_Of_Reversible_Topology_Item)",	// Description
		  (SelectCreator) create_SdaiReversible_topology);	// Creator function
	s_config_control_design->AddType(config_control_designt_reversible_topology);
	config_control_designt_work_item = new SelectTypeDescriptor (
		  ~(0),	//unique elements,
		  "Work_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Product_Definition_Formation)",	// Description
		  (SelectCreator) create_SdaiWork_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_work_item);
	config_control_designt_shape_definition = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Shape_Definition",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Product_Definition_Shape, Shape_Aspect, Shape_Aspect_Relationship)",	// Description
		  (SelectCreator) create_SdaiShape_definition);	// Creator function
	s_config_control_design->AddType(config_control_designt_shape_definition);
	config_control_designt_second_in_minute = new TypeDescriptor (
		  "Second_In_Minute",	// Name
		  sdaiREAL,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "REAL");	// Description
	s_config_control_design->AddType(config_control_designt_second_in_minute);
	config_control_designt_second_in_minute->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ((0 <= SELF) AND (SELF < 60));\n");
	config_control_designt_second_in_minute->_where_rules->Append(wr);
	config_control_designt_label = new TypeDescriptor (
		  "Label",	// Name
		  sdaiSTRING,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "STRING");	// Description
	s_config_control_design->AddType(config_control_designt_label);
	config_control_designt_context_dependent_measure = new TypeDescriptor (
		  "Context_Dependent_Measure",	// Name
		  sdaiREAL,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "REAL");	// Description
	s_config_control_design->AddType(config_control_designt_context_dependent_measure);
	config_control_designt_supported_item = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Supported_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Action_Directive, Action, Action_Method)",	// Description
		  (SelectCreator) create_SdaiSupported_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_supported_item);
	config_control_designt_si_prefix = new EnumTypeDescriptor (
		  "Si_Prefix",	// Name
		  sdaiENUMERATION,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "ENUMERATION of (exa, peta, tera, giga, mega, kilo, hecto, deca, deci, centi, milli, micro, nano, pico, femto, atto)",	// Description
		  (EnumCreator) create_SdaiSi_prefix_var);	// Creator function
	s_config_control_design->AddType(config_control_designt_si_prefix);
	config_control_designt_length_measure = new TypeDescriptor (
		  "Length_Measure",	// Name
		  sdaiREAL,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "REAL");	// Description
	s_config_control_design->AddType(config_control_designt_length_measure);
	config_control_designt_approved_item = new SelectTypeDescriptor (
		  ~(sdaiINSTANCE),	//unique elements,
		  "Approved_Item",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Product_Definition_Formation, Product_Definition, Configuration_Effectivity, Configuration_Item, Security_Classification, Change_Request, Change, Start_Request, Start_Work, Certification, Contract)",	// Description
		  (SelectCreator) create_SdaiApproved_item);	// Creator function
	s_config_control_design->AddType(config_control_designt_approved_item);
	config_control_designt_count_measure = new TypeDescriptor (
		  "Count_Measure",	// Name
		  sdaiNUMBER,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "NUMBER");	// Description
	s_config_control_design->AddType(config_control_designt_count_measure);
	config_control_designt_surface_model = new SelectTypeDescriptor (
		  ~(0),	//unique elements,
		  "Surface_Model",	// Name
		  sdaiSELECT,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "SELECT (Shell_Based_Surface_Model)",	// Description
		  (SelectCreator) create_SdaiSurface_model);	// Creator function
	s_config_control_design->AddType(config_control_designt_surface_model);

	config_control_designt_list_of_reversible_topology_item = new ListTypeDescriptor (
		  "List_Of_Reversible_Topology_Item",	// Name
		  LIST_TYPE,	// FundamentalType
		  s_config_control_design,	// Originating Schema
		  "LIST [0:?] OF reversible_topology_item",	// Description
		  (AggregateCreator) create_SdaiList_of_reversible_topology_item);	// Creator function

	s_config_control_design->AddType(config_control_designt_list_of_reversible_topology_item);

	//	*****  Initialize the Entities
	config_control_designe_representation_item = new EntityDescriptor(
		  "Representation_Item", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiRepresentation_item );
	s_config_control_design->AddEntity(config_control_designe_representation_item);
	config_control_designe_representation_item->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(using_representations\n\t(SELF)) > 0);\n");
	config_control_designe_representation_item->_where_rules->Append(wr);
	config_control_designe_geometric_representation_item = new EntityDescriptor(
		  "Geometric_Representation_Item", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiGeometric_representation_item );
	s_config_control_design->AddEntity(config_control_designe_geometric_representation_item);
	config_control_designe_geometric_representation_item->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(QUERY \n\t( using_rep <* using_representations\n\t(SELF) | \n\t(NOT \n\t(        'CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF\n\t(        using_rep.context_of_items))) )) = 0);\n");
	config_control_designe_geometric_representation_item->_where_rules->Append(wr);
	config_control_designe_functionally_defined_transformation = new EntityDescriptor(
		  "Functionally_Defined_Transformation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiFunctionally_defined_transformation );
	s_config_control_design->AddEntity(config_control_designe_functionally_defined_transformation);
	config_control_designe_cartesian_transformation_operator = new EntityDescriptor(
		  "Cartesian_Transformation_Operator", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCartesian_transformation_operator );
	s_config_control_design->AddEntity(config_control_designe_cartesian_transformation_operator);
	config_control_designe_cartesian_transformation_operator->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (scl > 0);\n");
	config_control_designe_cartesian_transformation_operator->_where_rules->Append(wr);
	config_control_designe_cartesian_transformation_operator_3d = new EntityDescriptor(
		  "Cartesian_Transformation_Operator_3d", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCartesian_transformation_operator_3d );
	s_config_control_design->AddEntity(config_control_designe_cartesian_transformation_operator_3d);
	config_control_designe_cartesian_transformation_operator_3d->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF\\geometric_representation_item.dim = 3);\n");
	config_control_designe_cartesian_transformation_operator_3d->_where_rules->Append(wr);
	config_control_designe_versioned_action_request = new EntityDescriptor(
		  "Versioned_Action_Request", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiVersioned_action_request );
	s_config_control_design->AddEntity(config_control_designe_versioned_action_request);
	config_control_designe_representation = new EntityDescriptor(
		  "Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiRepresentation );
	s_config_control_design->AddEntity(config_control_designe_representation);
	config_control_designe_shape_representation = new EntityDescriptor(
		  "Shape_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiShape_representation );
	s_config_control_design->AddEntity(config_control_designe_shape_representation);
	config_control_designe_manifold_surface_shape_representation = new EntityDescriptor(
		  "Manifold_Surface_Shape_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiManifold_surface_shape_representation );
	s_config_control_design->AddEntity(config_control_designe_manifold_surface_shape_representation);
	config_control_designe_manifold_surface_shape_representation->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(NOT \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',        'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF\n\t(it)) = 1)) ))         = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF\n\t(it)) = 1) )) > 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (SIZEOF\n\t(QUERY \n\t( mi <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(\n\t(\n\t(        'CONFIG_CONTROL_DESIGN.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION')         IN TYPEOF\n\t(mi\\mapped_item.mapping_source.mapped_representation)) AND         \n\t(SIZEOF\n\t(QUERY \n\t( mr_it <* mi\\mapped_item.mapping_source.        mapped_representation.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(mr_it)) ))         > 0))) )) = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( sh <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(['CONFIG_CONTROL_DESIGN.OPEN_SHELL',        'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL',        'CONFIG_CONTROL_DESIGN.CLOSED_SHELL'] * TYPEOF\n\t(sh)) = 1)) )) = 0)) ))         = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr5: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( cfs <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( fa <* cfs\\connected_face_set.        cfs_faces | \n\t(NOT \n\t(SIZEOF\n\t(['CONFIG_CONTROL_DESIGN.FACE_SURFACE',        'CONFIG_CONTROL_DESIGN.ORIENTED_FACE'] * TYPEOF\n\t(fa)) = 1)) )) = 0)) ))         = 0)) )) = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr6: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( cfs <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( f_sf <* QUERY \n\t( fa <* cfs\\        connected_face_set.cfs_faces | \n\t(        'CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN TYPEOF\n\t(fa)) ) | \n\t(NOT \n\t(\n\t(        'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF\n\t(f_sf)) OR \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE',        'CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE',        'CONFIG_CONTROL_DESIGN.OFFSET_SURFACE',        'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA',        'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'] * TYPEOF\n\t(f_sf\\face_surface.        face_geometry)) = 1))) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr7: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( cfs <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( fa <* cfs\\connected_face_set.        cfs_faces | \n\t(NOT \n\t(\n\t('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF\n\t(        fa)) OR msf_surface_check\n\t(fa\\face_surface.face_geometry))) )) = 0)) ))         = 0)) )) = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr8: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( cfs <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( fa <* cfs\\connected_face_set.        cfs_faces | \n\t(NOT \n\t(\n\t('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF\n\t(        fa)) OR \n\t(SIZEOF\n\t(QUERY \n\t( bnds <* fa.bounds | \n\t(NOT \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.EDGE_LOOP',        'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'] * TYPEOF\n\t(bnds.bound)) = 1)) ))         = 0))) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr9: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( cfs <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( fa <* cfs\\connected_face_set.        cfs_faces | \n\t(NOT \n\t(\n\t('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF\n\t(        fa)) OR \n\t(SIZEOF\n\t(QUERY \n\t( elp_fbnds <* QUERY \n\t( bnds <* fa.bounds | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( oe <* elp_fbnds\\path.edge_list | \n\t(NOT \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF\n\t(oe.edge_element))) ))         = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr10: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( cfs <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( fa <* cfs\\connected_face_set.        cfs_faces | \n\t(NOT \n\t(\n\t('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF\n\t(        fa)) OR \n\t(SIZEOF\n\t(QUERY \n\t( elp_fbnds <* QUERY \n\t( bnds <* fa.bounds | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( oe_cv <* QUERY \n\t( oe <* elp_fbnds\\path.edge_list | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF\n\t(oe.edge_element)) ) |         \n\t(NOT \n\t(SIZEOF\n\t(['CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE',        'CONFIG_CONTROL_DESIGN.CONIC','CONFIG_CONTROL_DESIGN.CURVE_REPLICA',        'CONFIG_CONTROL_DESIGN.LINE',        'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D',        'CONFIG_CONTROL_DESIGN.PCURVE','CONFIG_CONTROL_DESIGN.POLYLINE',        'CONFIG_CONTROL_DESIGN.SURFACE_CURVE'] * TYPEOF\n\t(oe_cv.edge_element\\        edge_curve.edge_geometry)) = 1)) )) = 0)) )) = 0))) )) = 0)) )) = 0)) ))         = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr11: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( cfs <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( fa <* cfs\\connected_face_set.        cfs_faces | \n\t(NOT \n\t(\n\t('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF\n\t(        fa)) OR \n\t(SIZEOF\n\t(QUERY \n\t( elp_fbnds <* QUERY \n\t( bnds <* fa.bounds | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( oe <* elp_fbnds\\path.edge_list | \n\t(NOT         msf_curve_check\n\t(oe.edge_element\\edge_curve.edge_geometry)) )) = 0)) ))         = 0))) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr12: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( cfs <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( fa <* cfs\\connected_face_set.        cfs_faces | \n\t(NOT \n\t(\n\t('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF\n\t(        fa)) OR \n\t(SIZEOF\n\t(QUERY \n\t( elp_fbnds <* QUERY \n\t( bnds <* fa.bounds | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( oe <* elp_fbnds\\path.edge_list | \n\t(NOT \n\t(\n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(oe.edge_element.        edge_start)) AND \n\t('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(oe        .edge_element.edge_end)))) )) = 0)) )) = 0))) )) = 0)) )) = 0)) ))         = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr13: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( cfs <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( fa <* cfs\\connected_face_set.        cfs_faces | \n\t(NOT \n\t(\n\t('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF\n\t(        fa)) OR \n\t(SIZEOF\n\t(QUERY \n\t( elp_fbnds <* QUERY \n\t( bnds <* fa.bounds | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( oe <* elp_fbnds\\path.edge_list | \n\t(NOT \n\t(\n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',        'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',        'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',        'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF\n\t(oe.edge_element.        edge_start\\vertex_point.vertex_geometry)) = 1) AND \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',        'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',        'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',        'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF\n\t(oe.edge_element.        edge_end\\vertex_point.vertex_geometry)) = 1))) )) = 0)) )) = 0))) ))         = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr14: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( cfs <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( fa <* cfs\\connected_face_set.        cfs_faces | \n\t(NOT \n\t(\n\t('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF\n\t(        fa)) OR \n\t(SIZEOF\n\t(QUERY \n\t( vlp_fbnds <* QUERY \n\t( bnds <* fa.bounds | \n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(        NOT \n\t('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(vlp_fbnds\\        vertex_loop.loop_vertex))) )) = 0))) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr15: (SIZEOF\n\t(QUERY \n\t( sbsm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( cfs <* sbsm\\shell_based_surface_model.        sbsm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( fa <* cfs\\connected_face_set.        cfs_faces | \n\t(NOT \n\t(\n\t('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF\n\t(        fa)) OR \n\t(SIZEOF\n\t(QUERY \n\t( vlp_fbnds <* QUERY \n\t( bnds <* fa.bounds | \n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(        NOT \n\t(SIZEOF\n\t(['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',        'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',        'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',        'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF\n\t(vlp_fbnds\\        vertex_loop.loop_vertex\\vertex_point.vertex_geometry)) = 1)) )) = 0))) ))         = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_manifold_surface_shape_representation->_where_rules->Append(wr);
	config_control_designe_certification = new EntityDescriptor(
		  "Certification", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCertification );
	s_config_control_design->AddEntity(config_control_designe_certification);
	config_control_designe_product_definition_relationship = new EntityDescriptor(
		  "Product_Definition_Relationship", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_definition_relationship );
	s_config_control_design->AddEntity(config_control_designe_product_definition_relationship);
	config_control_designe_product_definition_usage = new EntityDescriptor(
		  "Product_Definition_Usage", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_definition_usage );
	s_config_control_design->AddEntity(config_control_designe_product_definition_usage);
	config_control_designe_product_definition_usage->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (acyclic_product_definition_relationship\n\t(SELF,[SELF\\        product_definition_relationship.related_product_definition],        'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE'));\n");
	config_control_designe_product_definition_usage->_where_rules->Append(wr);
	config_control_designe_product_definition_usage->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : id, relating_product_definition, related_product_definition;\n");
	config_control_designe_product_definition_usage->_uniqueness_rules->Append(ur);
	config_control_designe_assembly_component_usage = new EntityDescriptor(
		  "Assembly_Component_Usage", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAssembly_component_usage );
	s_config_control_design->AddEntity(config_control_designe_assembly_component_usage);
	config_control_designe_quantified_assembly_component_usage = new EntityDescriptor(
		  "Quantified_Assembly_Component_Usage", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiQuantified_assembly_component_usage );
	s_config_control_design->AddEntity(config_control_designe_quantified_assembly_component_usage);
	config_control_designe_solid_model = new EntityDescriptor(
		  "Solid_Model", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSolid_model );
	s_config_control_design->AddEntity(config_control_designe_solid_model);
	config_control_designe_manifold_solid_brep = new EntityDescriptor(
		  "Manifold_Solid_Brep", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiManifold_solid_brep );
	s_config_control_design->AddEntity(config_control_designe_manifold_solid_brep);
	config_control_designe_faceted_brep = new EntityDescriptor(
		  "Faceted_Brep", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiFaceted_brep );
	s_config_control_design->AddEntity(config_control_designe_faceted_brep);
	config_control_designe_action_directive = new EntityDescriptor(
		  "Action_Directive", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAction_directive );
	s_config_control_design->AddEntity(config_control_designe_action_directive);
	config_control_designe_named_unit = new EntityDescriptor(
		  "Named_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiNamed_unit );
	s_config_control_design->AddEntity(config_control_designe_named_unit);
	config_control_designe_plane_angle_unit = new EntityDescriptor(
		  "Plane_Angle_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPlane_angle_unit );
	s_config_control_design->AddEntity(config_control_designe_plane_angle_unit);
	config_control_designe_plane_angle_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t(SELF\\named_unit.dimensions.length_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.mass_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        time_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        electric_current_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        thermodynamic_temperature_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.amount_of_substance_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.luminous_intensity_exponent = 0));\n");
	config_control_designe_plane_angle_unit->_where_rules->Append(wr);
	config_control_designe_measure_with_unit = new EntityDescriptor(
		  "Measure_With_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiMeasure_with_unit );
	s_config_control_design->AddEntity(config_control_designe_measure_with_unit);
	config_control_designe_measure_with_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (valid_units\n\t(SELF));\n");
	config_control_designe_measure_with_unit->_where_rules->Append(wr);
	config_control_designe_area_measure_with_unit = new EntityDescriptor(
		  "Area_Measure_With_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiArea_measure_with_unit );
	s_config_control_design->AddEntity(config_control_designe_area_measure_with_unit);
	config_control_designe_area_measure_with_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.AREA_UNIT' IN TYPEOF\n\t(SELF\\measure_with_unit.        unit_component));\n");
	config_control_designe_area_measure_with_unit->_where_rules->Append(wr);
	config_control_designe_effectivity = new EntityDescriptor(
		  "Effectivity", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiEffectivity );
	s_config_control_design->AddEntity(config_control_designe_effectivity);
	config_control_designe_serial_numbered_effectivity = new EntityDescriptor(
		  "Serial_Numbered_Effectivity", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSerial_numbered_effectivity );
	s_config_control_design->AddEntity(config_control_designe_serial_numbered_effectivity);
	config_control_designe_surface = new EntityDescriptor(
		  "Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSurface );
	s_config_control_design->AddEntity(config_control_designe_surface);
	config_control_designe_offset_surface = new EntityDescriptor(
		  "Offset_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOffset_surface );
	s_config_control_design->AddEntity(config_control_designe_offset_surface);
	config_control_designe_placement = new EntityDescriptor(
		  "Placement", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPlacement );
	s_config_control_design->AddEntity(config_control_designe_placement);
	config_control_designe_axis2_placement_2d = new EntityDescriptor(
		  "Axis2_Placement_2d", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAxis2_placement_2d );
	s_config_control_design->AddEntity(config_control_designe_axis2_placement_2d);
	config_control_designe_axis2_placement_2d->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF\\geometric_representation_item.dim = 2);\n");
	config_control_designe_axis2_placement_2d->_where_rules->Append(wr);
	config_control_designe_product_category = new EntityDescriptor(
		  "Product_Category", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_category );
	s_config_control_design->AddEntity(config_control_designe_product_category);
	config_control_designe_product_related_product_category = new EntityDescriptor(
		  "Product_Related_Product_Category", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_related_product_category );
	s_config_control_design->AddEntity(config_control_designe_product_related_product_category);
	config_control_designe_curve = new EntityDescriptor(
		  "Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCurve );
	s_config_control_design->AddEntity(config_control_designe_curve);
	config_control_designe_conic = new EntityDescriptor(
		  "Conic", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiConic );
	s_config_control_design->AddEntity(config_control_designe_conic);
	config_control_designe_hyperbola = new EntityDescriptor(
		  "Hyperbola", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiHyperbola );
	s_config_control_design->AddEntity(config_control_designe_hyperbola);
	config_control_designe_address = new EntityDescriptor(
		  "Address", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAddress );
	s_config_control_design->AddEntity(config_control_designe_address);
	config_control_designe_address->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (EXISTS\n\t(internal_location) OR EXISTS\n\t(street_number) OR EXISTS\n\t(street) OR         EXISTS\n\t(postal_box) OR EXISTS\n\t(town) OR EXISTS\n\t(region) OR EXISTS\n\t(        postal_code) OR EXISTS\n\t(country) OR EXISTS\n\t(facsimile_number) OR         EXISTS\n\t(telephone_number) OR EXISTS\n\t(electronic_mail_address) OR         EXISTS\n\t(telex_number));\n");
	config_control_designe_address->_where_rules->Append(wr);
	config_control_designe_organizational_address = new EntityDescriptor(
		  "Organizational_Address", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOrganizational_address );
	s_config_control_design->AddEntity(config_control_designe_organizational_address);
	config_control_designe_bounded_surface = new EntityDescriptor(
		  "Bounded_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiBounded_surface );
	s_config_control_design->AddEntity(config_control_designe_bounded_surface);
	config_control_designe_b_spline_surface = new EntityDescriptor(
		  "B_Spline_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiB_spline_surface );
	s_config_control_design->AddEntity(config_control_designe_b_spline_surface);
	config_control_designe_b_spline_surface->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t('CONFIG_CONTROL_DESIGN.UNIFORM_SURFACE' IN TYPEOF\n\t(SELF)) OR \n\t(        'CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_SURFACE' IN TYPEOF\n\t(SELF)) OR \n\t(        'CONFIG_CONTROL_DESIGN.BEZIER_SURFACE' IN TYPEOF\n\t(SELF)) OR \n\t(        'CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF\n\t(SELF)));\n");
	config_control_designe_b_spline_surface->_where_rules->Append(wr);
	config_control_designe_uniform_surface = new EntityDescriptor(
		  "Uniform_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiUniform_surface );
	s_config_control_design->AddEntity(config_control_designe_uniform_surface);
	config_control_designe_geometrically_bounded_surface_shape_representation = new EntityDescriptor(
		  "Geometrically_Bounded_Surface_Shape_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiGeometrically_bounded_surface_shape_representation );
	s_config_control_design->AddEntity(config_control_designe_geometrically_bounded_surface_shape_representation);
	config_control_designe_geometrically_bounded_surface_shape_representation->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(NOT \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',        'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF\n\t(it)) = 1)) ))         = 0);\n");
	config_control_designe_geometrically_bounded_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF\n\t(it)) = 1) )) > 0);\n");
	config_control_designe_geometrically_bounded_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (SIZEOF\n\t(QUERY \n\t( mi <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(\n\t(\n\t(        'CONFIG_CONTROL_DESIGN.' +         'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION') IN TYPEOF\n\t(mi\\        mapped_item.mapping_source.mapped_representation)) AND \n\t(SIZEOF\n\t(        QUERY \n\t( mr_it <* mi\\mapped_item.mapping_source.        mapped_representation.items | \n\t(        'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF\n\t(mr_it)) )) > 0))) ))         = 0);\n");
	config_control_designe_geometrically_bounded_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (SIZEOF\n\t(QUERY \n\t( gs <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( pnt <* QUERY \n\t( gsel <* gs\\geometric_set.elements | \n\t(        'CONFIG_CONTROL_DESIGN.POINT' IN TYPEOF\n\t(gsel)) ) | \n\t(NOT         gbsf_check_point\n\t(pnt)) )) = 0)) )) = 0);\n");
	config_control_designe_geometrically_bounded_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr5: (SIZEOF\n\t(QUERY \n\t( gs <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( cv <* QUERY \n\t( gsel <* gs\\geometric_set.elements | \n\t(        'CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF\n\t(gsel)) ) | \n\t(NOT         gbsf_check_curve\n\t(cv)) )) = 0)) )) = 0);\n");
	config_control_designe_geometrically_bounded_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr6: (SIZEOF\n\t(QUERY \n\t( gs <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( sf <* QUERY \n\t( gsel <* gs\\geometric_set.elements | \n\t(        'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF\n\t(gsel)) ) | \n\t(NOT         gbsf_check_surface\n\t(sf)) )) = 0)) )) = 0);\n");
	config_control_designe_geometrically_bounded_surface_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr7: (SIZEOF\n\t(QUERY \n\t( gs <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF\n\t(it)) ) | \n\t(SIZEOF\n\t(        QUERY \n\t( gsel <* gs\\geometric_set.elements | \n\t(        'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF\n\t(gsel)) )) > 0) )) > 0);\n");
	config_control_designe_geometrically_bounded_surface_shape_representation->_where_rules->Append(wr);
	config_control_designe_axis1_placement = new EntityDescriptor(
		  "Axis1_Placement", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAxis1_placement );
	s_config_control_design->AddEntity(config_control_designe_axis1_placement);
	config_control_designe_axis1_placement->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF\\geometric_representation_item.dim = 3);\n");
	config_control_designe_axis1_placement->_where_rules->Append(wr);
	config_control_designe_bounded_curve = new EntityDescriptor(
		  "Bounded_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiBounded_curve );
	s_config_control_design->AddEntity(config_control_designe_bounded_curve);
	config_control_designe_b_spline_curve = new EntityDescriptor(
		  "B_Spline_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiB_spline_curve );
	s_config_control_design->AddEntity(config_control_designe_b_spline_curve);
	config_control_designe_b_spline_curve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t('CONFIG_CONTROL_DESIGN.UNIFORM_CURVE' IN TYPEOF\n\t(SELF)) OR \n\t(        'CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_CURVE' IN TYPEOF\n\t(SELF)) OR \n\t(        'CONFIG_CONTROL_DESIGN.BEZIER_CURVE' IN TYPEOF\n\t(SELF)) OR \n\t(        'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF\n\t(SELF)));\n");
	config_control_designe_b_spline_curve->_where_rules->Append(wr);
	config_control_designe_rational_b_spline_curve = new EntityDescriptor(
		  "Rational_B_Spline_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiRational_b_spline_curve );
	s_config_control_design->AddEntity(config_control_designe_rational_b_spline_curve);
	config_control_designe_rational_b_spline_curve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(weights_data) = SIZEOF\n\t(SELF\\b_spline_curve.control_points_list));\n");
	config_control_designe_rational_b_spline_curve->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (curve_weights_positive\n\t(SELF));\n");
	config_control_designe_rational_b_spline_curve->_where_rules->Append(wr);
	config_control_designe_action_request_assignment = new EntityDescriptor(
		  "Action_Request_Assignment", s_config_control_design, SCLLOG(LTrue), SCLLOG(LFalse),
		  (Creator) create_SdaiAction_request_assignment );
	s_config_control_design->AddEntity(config_control_designe_action_request_assignment);
	config_control_designe_topological_representation_item = new EntityDescriptor(
		  "Topological_Representation_Item", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiTopological_representation_item );
	s_config_control_design->AddEntity(config_control_designe_topological_representation_item);
	config_control_designe_face_bound = new EntityDescriptor(
		  "Face_Bound", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiFace_bound );
	s_config_control_design->AddEntity(config_control_designe_face_bound);
	config_control_designe_length_measure_with_unit = new EntityDescriptor(
		  "Length_Measure_With_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiLength_measure_with_unit );
	s_config_control_design->AddEntity(config_control_designe_length_measure_with_unit);
	config_control_designe_length_measure_with_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN TYPEOF\n\t(SELF\\measure_with_unit.        unit_component));\n");
	config_control_designe_length_measure_with_unit->_where_rules->Append(wr);
	config_control_designe_dated_effectivity = new EntityDescriptor(
		  "Dated_Effectivity", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDated_effectivity );
	s_config_control_design->AddEntity(config_control_designe_dated_effectivity);
	config_control_designe_direction = new EntityDescriptor(
		  "Direction", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDirection );
	s_config_control_design->AddEntity(config_control_designe_direction);
	config_control_designe_direction->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(QUERY \n\t( tmp <* direction_ratios | \n\t(tmp <> 0) )) > 0);\n");
	config_control_designe_direction->_where_rules->Append(wr);
	config_control_designe_next_assembly_usage_occurrence = new EntityDescriptor(
		  "Next_Assembly_Usage_Occurrence", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiNext_assembly_usage_occurrence );
	s_config_control_design->AddEntity(config_control_designe_next_assembly_usage_occurrence);
	config_control_designe_edge = new EntityDescriptor(
		  "Edge", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiEdge );
	s_config_control_design->AddEntity(config_control_designe_edge);
	config_control_designe_oriented_edge = new EntityDescriptor(
		  "Oriented_Edge", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOriented_edge );
	s_config_control_design->AddEntity(config_control_designe_oriented_edge);
	config_control_designe_oriented_edge->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (NOT \n\t('CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF\n\t(SELF.edge_element)));\n");
	config_control_designe_oriented_edge->_where_rules->Append(wr);
	config_control_designe_person = new EntityDescriptor(
		  "Person", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPerson );
	s_config_control_design->AddEntity(config_control_designe_person);
	config_control_designe_person->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (EXISTS\n\t(last_name) OR EXISTS\n\t(first_name));\n");
	config_control_designe_person->_where_rules->Append(wr);
	config_control_designe_person->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : id;\n");
	config_control_designe_person->_uniqueness_rules->Append(ur);
	config_control_designe_document = new EntityDescriptor(
		  "Document", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDocument );
	s_config_control_design->AddEntity(config_control_designe_document);
	config_control_designe_document->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : id;\n");
	config_control_designe_document->_uniqueness_rules->Append(ur);
	config_control_designe_document_with_class = new EntityDescriptor(
		  "Document_With_Class", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDocument_with_class );
	s_config_control_design->AddEntity(config_control_designe_document_with_class);
	config_control_designe_conversion_based_unit = new EntityDescriptor(
		  "Conversion_Based_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiConversion_based_unit );
	s_config_control_design->AddEntity(config_control_designe_conversion_based_unit);
	config_control_designe_point = new EntityDescriptor(
		  "Point", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPoint );
	s_config_control_design->AddEntity(config_control_designe_point);
	config_control_designe_point_on_surface = new EntityDescriptor(
		  "Point_On_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPoint_on_surface );
	s_config_control_design->AddEntity(config_control_designe_point_on_surface);
	config_control_designe_product_definition_formation = new EntityDescriptor(
		  "Product_Definition_Formation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_definition_formation );
	s_config_control_design->AddEntity(config_control_designe_product_definition_formation);
	config_control_designe_product_definition_formation->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : id, of_product;\n");
	config_control_designe_product_definition_formation->_uniqueness_rules->Append(ur);
	config_control_designe_person_and_organization_assignment = new EntityDescriptor(
		  "Person_And_Organization_Assignment", s_config_control_design, SCLLOG(LTrue), SCLLOG(LFalse),
		  (Creator) create_SdaiPerson_and_organization_assignment );
	s_config_control_design->AddEntity(config_control_designe_person_and_organization_assignment);
	config_control_designe_cc_design_person_and_organization_assignment = new EntityDescriptor(
		  "Cc_Design_Person_And_Organization_Assignment", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCc_design_person_and_organization_assignment );
	s_config_control_design->AddEntity(config_control_designe_cc_design_person_and_organization_assignment);
	config_control_designe_cc_design_person_and_organization_assignment->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (cc_design_person_and_organization_correlation\n\t(SELF));\n");
	config_control_designe_cc_design_person_and_organization_assignment->_where_rules->Append(wr);
	config_control_designe_offset_curve_3d = new EntityDescriptor(
		  "Offset_Curve_3d", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOffset_curve_3d );
	s_config_control_design->AddEntity(config_control_designe_offset_curve_3d);
	config_control_designe_offset_curve_3d->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t(basis_curve.dim = 3) AND \n\t(ref_direction.dim = 3));\n");
	config_control_designe_offset_curve_3d->_where_rules->Append(wr);
	config_control_designe_approval = new EntityDescriptor(
		  "Approval", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiApproval );
	s_config_control_design->AddEntity(config_control_designe_approval);
	config_control_designe_composite_curve = new EntityDescriptor(
		  "Composite_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiComposite_curve );
	s_config_control_design->AddEntity(config_control_designe_composite_curve);
	config_control_designe_composite_curve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t(\n\t(NOT closed_curve) AND \n\t(SIZEOF\n\t(QUERY \n\t( temp <* segments | \n\t(temp.        transition = discontinuous) )) = 1)) OR \n\t(closed_curve AND \n\t(SIZEOF\n\t(        QUERY \n\t( temp <* segments | \n\t(temp.transition = discontinuous) )) = 0)));\n");
	config_control_designe_composite_curve->_where_rules->Append(wr);
	config_control_designe_composite_curve_on_surface = new EntityDescriptor(
		  "Composite_Curve_On_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiComposite_curve_on_surface );
	s_config_control_design->AddEntity(config_control_designe_composite_curve_on_surface);
	config_control_designe_composite_curve_on_surface->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(basis_surface) > 0);\n");
	config_control_designe_composite_curve_on_surface->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (constraints_composite_curve_on_surface\n\t(SELF));\n");
	config_control_designe_composite_curve_on_surface->_where_rules->Append(wr);
	config_control_designe_boundary_curve = new EntityDescriptor(
		  "Boundary_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiBoundary_curve );
	s_config_control_design->AddEntity(config_control_designe_boundary_curve);
	config_control_designe_boundary_curve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF\\composite_curve.closed_curve);\n");
	config_control_designe_boundary_curve->_where_rules->Append(wr);
	config_control_designe_representation_context = new EntityDescriptor(
		  "Representation_Context", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiRepresentation_context );
	s_config_control_design->AddEntity(config_control_designe_representation_context);
	config_control_designe_geometric_representation_context = new EntityDescriptor(
		  "Geometric_Representation_Context", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiGeometric_representation_context );
	s_config_control_design->AddEntity(config_control_designe_geometric_representation_context);
	config_control_designe_action_status = new EntityDescriptor(
		  "Action_Status", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAction_status );
	s_config_control_design->AddEntity(config_control_designe_action_status);
	config_control_designe_application_context = new EntityDescriptor(
		  "Application_Context", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiApplication_context );
	s_config_control_design->AddEntity(config_control_designe_application_context);
	config_control_designe_change_request = new EntityDescriptor(
		  "Change_Request", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiChange_request );
	s_config_control_design->AddEntity(config_control_designe_change_request);
	config_control_designe_date_and_time = new EntityDescriptor(
		  "Date_And_Time", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDate_and_time );
	s_config_control_design->AddEntity(config_control_designe_date_and_time);
	config_control_designe_approval_date_time = new EntityDescriptor(
		  "Approval_Date_Time", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiApproval_date_time );
	s_config_control_design->AddEntity(config_control_designe_approval_date_time);
	config_control_designe_approval_role = new EntityDescriptor(
		  "Approval_Role", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiApproval_role );
	s_config_control_design->AddEntity(config_control_designe_approval_role);
	config_control_designe_application_context_element = new EntityDescriptor(
		  "Application_Context_Element", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiApplication_context_element );
	s_config_control_design->AddEntity(config_control_designe_application_context_element);
	config_control_designe_product_context = new EntityDescriptor(
		  "Product_Context", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_context );
	s_config_control_design->AddEntity(config_control_designe_product_context);
	config_control_designe_elementary_surface = new EntityDescriptor(
		  "Elementary_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiElementary_surface );
	s_config_control_design->AddEntity(config_control_designe_elementary_surface);
	config_control_designe_spherical_surface = new EntityDescriptor(
		  "Spherical_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSpherical_surface );
	s_config_control_design->AddEntity(config_control_designe_spherical_surface);
	config_control_designe_application_protocol_definition = new EntityDescriptor(
		  "Application_Protocol_Definition", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiApplication_protocol_definition );
	s_config_control_design->AddEntity(config_control_designe_application_protocol_definition);
	config_control_designe_specified_higher_usage_occurrence = new EntityDescriptor(
		  "Specified_Higher_Usage_Occurrence", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSpecified_higher_usage_occurrence );
	s_config_control_design->AddEntity(config_control_designe_specified_higher_usage_occurrence);
	config_control_designe_specified_higher_usage_occurrence->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF :<>: upper_usage);\n");
	config_control_designe_specified_higher_usage_occurrence->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (SELF\\product_definition_relationship.relating_product_definition :=:         upper_usage.relating_product_definition);\n");
	config_control_designe_specified_higher_usage_occurrence->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (SELF\\product_definition_relationship.related_product_definition :=:         next_usage.related_product_definition);\n");
	config_control_designe_specified_higher_usage_occurrence->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (upper_usage.related_product_definition :=: next_usage.        relating_product_definition);\n");
	config_control_designe_specified_higher_usage_occurrence->_where_rules->Append(wr);
	wr = new Where_rule("wr5: (NOT \n\t('CONFIG_CONTROL_DESIGN.PROMISSORY_USAGE_OCCURRENCE' IN TYPEOF\n\t(        upper_usage)));\n");
	config_control_designe_specified_higher_usage_occurrence->_where_rules->Append(wr);
	config_control_designe_specified_higher_usage_occurrence->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : upper_usage, next_usage;\n");
	config_control_designe_specified_higher_usage_occurrence->_uniqueness_rules->Append(ur);
	config_control_designe_product_definition_formation_with_specified_source = new EntityDescriptor(
		  "Product_Definition_Formation_With_Specified_Source", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_definition_formation_with_specified_source );
	s_config_control_design->AddEntity(config_control_designe_product_definition_formation_with_specified_source);
	config_control_designe_action_request_solution = new EntityDescriptor(
		  "Action_Request_Solution", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAction_request_solution );
	s_config_control_design->AddEntity(config_control_designe_action_request_solution);
	config_control_designe_uncertainty_measure_with_unit = new EntityDescriptor(
		  "Uncertainty_Measure_With_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiUncertainty_measure_with_unit );
	s_config_control_design->AddEntity(config_control_designe_uncertainty_measure_with_unit);
	config_control_designe_uncertainty_measure_with_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (valid_measure_value\n\t(SELF\\measure_with_unit.value_component));\n");
	config_control_designe_uncertainty_measure_with_unit->_where_rules->Append(wr);
	config_control_designe_edge_based_wireframe_model = new EntityDescriptor(
		  "Edge_Based_Wireframe_Model", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiEdge_based_wireframe_model );
	s_config_control_design->AddEntity(config_control_designe_edge_based_wireframe_model);
	config_control_designe_path = new EntityDescriptor(
		  "Path", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPath );
	s_config_control_design->AddEntity(config_control_designe_path);
	config_control_designe_path->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (path_head_to_tail\n\t(SELF));\n");
	config_control_designe_path->_where_rules->Append(wr);
	config_control_designe_connected_face_set = new EntityDescriptor(
		  "Connected_Face_Set", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiConnected_face_set );
	s_config_control_design->AddEntity(config_control_designe_connected_face_set);
	config_control_designe_open_shell = new EntityDescriptor(
		  "Open_Shell", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOpen_shell );
	s_config_control_design->AddEntity(config_control_designe_open_shell);
	config_control_designe_oriented_open_shell = new EntityDescriptor(
		  "Oriented_Open_Shell", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOriented_open_shell );
	s_config_control_design->AddEntity(config_control_designe_oriented_open_shell);
	config_control_designe_oriented_open_shell->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (NOT \n\t('CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF\n\t(SELF.        open_shell_element)));\n");
	config_control_designe_oriented_open_shell->_where_rules->Append(wr);
	config_control_designe_solid_angle_unit = new EntityDescriptor(
		  "Solid_Angle_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSolid_angle_unit );
	s_config_control_design->AddEntity(config_control_designe_solid_angle_unit);
	config_control_designe_solid_angle_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t(SELF\\named_unit.dimensions.length_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.mass_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        time_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        electric_current_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        thermodynamic_temperature_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.amount_of_substance_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.luminous_intensity_exponent = 0));\n");
	config_control_designe_solid_angle_unit->_where_rules->Append(wr);
	config_control_designe_coordinated_universal_time_offset = new EntityDescriptor(
		  "Coordinated_Universal_Time_Offset", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCoordinated_universal_time_offset );
	s_config_control_design->AddEntity(config_control_designe_coordinated_universal_time_offset);
	config_control_designe_curve_replica = new EntityDescriptor(
		  "Curve_Replica", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCurve_replica );
	s_config_control_design->AddEntity(config_control_designe_curve_replica);
	config_control_designe_curve_replica->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (transformation.dim = parent_curve.dim);\n");
	config_control_designe_curve_replica->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (acyclic_curve_replica\n\t(SELF,parent_curve));\n");
	config_control_designe_curve_replica->_where_rules->Append(wr);
	config_control_designe_quasi_uniform_surface = new EntityDescriptor(
		  "Quasi_Uniform_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiQuasi_uniform_surface );
	s_config_control_design->AddEntity(config_control_designe_quasi_uniform_surface);
	config_control_designe_surface_curve = new EntityDescriptor(
		  "Surface_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSurface_curve );
	s_config_control_design->AddEntity(config_control_designe_surface_curve);
	config_control_designe_surface_curve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (curve_3d.dim = 3);\n");
	config_control_designe_surface_curve->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (\n\t('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF\n\t(associated_geometry[1])) OR \n\t(        master_representation <> pcurve_s1));\n");
	config_control_designe_surface_curve->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (\n\t('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF\n\t(associated_geometry[2])) OR \n\t(        master_representation <> pcurve_s2));\n");
	config_control_designe_surface_curve->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (NOT \n\t('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF\n\t(curve_3d)));\n");
	config_control_designe_surface_curve->_where_rules->Append(wr);
	config_control_designe_action_request_status = new EntityDescriptor(
		  "Action_Request_Status", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAction_request_status );
	s_config_control_design->AddEntity(config_control_designe_action_request_status);
	config_control_designe_founded_item = new EntityDescriptor(
		  "Founded_Item", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiFounded_item );
	s_config_control_design->AddEntity(config_control_designe_founded_item);
	config_control_designe_composite_curve_segment = new EntityDescriptor(
		  "Composite_Curve_Segment", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiComposite_curve_segment );
	s_config_control_design->AddEntity(config_control_designe_composite_curve_segment);
	config_control_designe_composite_curve_segment->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF\n\t(parent_curve));\n");
	config_control_designe_composite_curve_segment->_where_rules->Append(wr);
	config_control_designe_reparametrised_composite_curve_segment = new EntityDescriptor(
		  "Reparametrised_Composite_Curve_Segment", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiReparametrised_composite_curve_segment );
	s_config_control_design->AddEntity(config_control_designe_reparametrised_composite_curve_segment);
	config_control_designe_reparametrised_composite_curve_segment->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (param_length > 0);\n");
	config_control_designe_reparametrised_composite_curve_segment->_where_rules->Append(wr);
	config_control_designe_representation_relationship = new EntityDescriptor(
		  "Representation_Relationship", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiRepresentation_relationship );
	s_config_control_design->AddEntity(config_control_designe_representation_relationship);
	config_control_designe_representation_relationship_with_transformation = new EntityDescriptor(
		  "Representation_Relationship_With_Transformation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiRepresentation_relationship_with_transformation );
	s_config_control_design->AddEntity(config_control_designe_representation_relationship_with_transformation);
	config_control_designe_representation_relationship_with_transformation->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF\\representation_relationship.rep_1.context_of_items :<>: SELF\\        representation_relationship.rep_2.context_of_items);\n");
	config_control_designe_representation_relationship_with_transformation->_where_rules->Append(wr);
	config_control_designe_person_and_organization_role = new EntityDescriptor(
		  "Person_And_Organization_Role", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPerson_and_organization_role );
	s_config_control_design->AddEntity(config_control_designe_person_and_organization_role);
	config_control_designe_quasi_uniform_curve = new EntityDescriptor(
		  "Quasi_Uniform_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiQuasi_uniform_curve );
	s_config_control_design->AddEntity(config_control_designe_quasi_uniform_curve);
	config_control_designe_swept_surface = new EntityDescriptor(
		  "Swept_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSwept_surface );
	s_config_control_design->AddEntity(config_control_designe_swept_surface);
	config_control_designe_property_definition = new EntityDescriptor(
		  "Property_Definition", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProperty_definition );
	s_config_control_design->AddEntity(config_control_designe_property_definition);
	config_control_designe_global_uncertainty_assigned_context = new EntityDescriptor(
		  "Global_Uncertainty_Assigned_Context", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiGlobal_uncertainty_assigned_context );
	s_config_control_design->AddEntity(config_control_designe_global_uncertainty_assigned_context);
	config_control_designe_organization_relationship = new EntityDescriptor(
		  "Organization_Relationship", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOrganization_relationship );
	s_config_control_design->AddEntity(config_control_designe_organization_relationship);
	config_control_designe_parabola = new EntityDescriptor(
		  "Parabola", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiParabola );
	s_config_control_design->AddEntity(config_control_designe_parabola);
	config_control_designe_parabola->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (focal_dist <> 0);\n");
	config_control_designe_parabola->_where_rules->Append(wr);
	config_control_designe_rectangular_composite_surface = new EntityDescriptor(
		  "Rectangular_Composite_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiRectangular_composite_surface );
	s_config_control_design->AddEntity(config_control_designe_rectangular_composite_surface);
	config_control_designe_rectangular_composite_surface->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ([] = QUERY \n\t( s <* segments | \n\t(n_v <> SIZEOF\n\t(s)) ));\n");
	config_control_designe_rectangular_composite_surface->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (constraints_rectangular_composite_surface\n\t(SELF));\n");
	config_control_designe_rectangular_composite_surface->_where_rules->Append(wr);
	config_control_designe_lot_effectivity = new EntityDescriptor(
		  "Lot_Effectivity", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiLot_effectivity );
	s_config_control_design->AddEntity(config_control_designe_lot_effectivity);
	config_control_designe_surface_of_linear_extrusion = new EntityDescriptor(
		  "Surface_Of_Linear_Extrusion", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSurface_of_linear_extrusion );
	s_config_control_design->AddEntity(config_control_designe_surface_of_linear_extrusion);
	config_control_designe_shell_based_surface_model = new EntityDescriptor(
		  "Shell_Based_Surface_Model", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiShell_based_surface_model );
	s_config_control_design->AddEntity(config_control_designe_shell_based_surface_model);
	config_control_designe_shell_based_surface_model->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (constraints_geometry_shell_based_surface_model\n\t(SELF));\n");
	config_control_designe_shell_based_surface_model->_where_rules->Append(wr);
	config_control_designe_uniform_curve = new EntityDescriptor(
		  "Uniform_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiUniform_curve );
	s_config_control_design->AddEntity(config_control_designe_uniform_curve);
	config_control_designe_bezier_curve = new EntityDescriptor(
		  "Bezier_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiBezier_curve );
	s_config_control_design->AddEntity(config_control_designe_bezier_curve);
	config_control_designe_loop = new EntityDescriptor(
		  "Loop", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiLoop );
	s_config_control_design->AddEntity(config_control_designe_loop);
	config_control_designe_edge_loop = new EntityDescriptor(
		  "Edge_Loop", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiEdge_loop );
	s_config_control_design->AddEntity(config_control_designe_edge_loop);
	config_control_designe_edge_loop->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF\\path.edge_list[1].edge_start :=: SELF\\path.edge_list[ne].edge_end);\n");
	config_control_designe_edge_loop->_where_rules->Append(wr);
	config_control_designe_date = new EntityDescriptor(
		  "Date", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDate );
	s_config_control_design->AddEntity(config_control_designe_date);
	config_control_designe_calendar_date = new EntityDescriptor(
		  "Calendar_Date", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCalendar_date );
	s_config_control_design->AddEntity(config_control_designe_calendar_date);
	config_control_designe_calendar_date->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (valid_calendar_date\n\t(SELF));\n");
	config_control_designe_calendar_date->_where_rules->Append(wr);
	config_control_designe_toroidal_surface = new EntityDescriptor(
		  "Toroidal_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiToroidal_surface );
	s_config_control_design->AddEntity(config_control_designe_toroidal_surface);
	config_control_designe_promissory_usage_occurrence = new EntityDescriptor(
		  "Promissory_Usage_Occurrence", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPromissory_usage_occurrence );
	s_config_control_design->AddEntity(config_control_designe_promissory_usage_occurrence);
	config_control_designe_approval_assignment = new EntityDescriptor(
		  "Approval_Assignment", s_config_control_design, SCLLOG(LTrue), SCLLOG(LFalse),
		  (Creator) create_SdaiApproval_assignment );
	s_config_control_design->AddEntity(config_control_designe_approval_assignment);
	config_control_designe_configuration_item = new EntityDescriptor(
		  "Configuration_Item", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiConfiguration_item );
	s_config_control_design->AddEntity(config_control_designe_configuration_item);
	config_control_designe_configuration_item->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : id;\n");
	config_control_designe_configuration_item->_uniqueness_rules->Append(ur);
	config_control_designe_contract_assignment = new EntityDescriptor(
		  "Contract_Assignment", s_config_control_design, SCLLOG(LTrue), SCLLOG(LFalse),
		  (Creator) create_SdaiContract_assignment );
	s_config_control_design->AddEntity(config_control_designe_contract_assignment);
	config_control_designe_vector = new EntityDescriptor(
		  "Vector", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiVector );
	s_config_control_design->AddEntity(config_control_designe_vector);
	config_control_designe_vector->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (magnitude >= 0);\n");
	config_control_designe_vector->_where_rules->Append(wr);
	config_control_designe_pcurve = new EntityDescriptor(
		  "Pcurve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPcurve );
	s_config_control_design->AddEntity(config_control_designe_pcurve);
	config_control_designe_pcurve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(reference_to_curve\\representation.items) = 1);\n");
	config_control_designe_pcurve->_where_rules->Append(wr);
	wr = new Where_rule("wr2: ('CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF\n\t(reference_to_curve\\representation.        items[1]));\n");
	config_control_designe_pcurve->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (reference_to_curve\\representation.items[1]\\geometric_representation_item.        dim = 2);\n");
	config_control_designe_pcurve->_where_rules->Append(wr);
	config_control_designe_bounded_pcurve = new EntityDescriptor(
		  "Bounded_Pcurve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiBounded_pcurve );
	s_config_control_design->AddEntity(config_control_designe_bounded_pcurve);
	config_control_designe_bounded_pcurve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF\n\t(SELF\\pcurve.        reference_to_curve.items[1]));\n");
	config_control_designe_bounded_pcurve->_where_rules->Append(wr);
	config_control_designe_intersection_curve = new EntityDescriptor(
		  "Intersection_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiIntersection_curve );
	s_config_control_design->AddEntity(config_control_designe_intersection_curve);
	config_control_designe_intersection_curve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(SELF\\surface_curve.associated_geometry) = 2);\n");
	config_control_designe_intersection_curve->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (associated_surface\n\t(SELF\\surface_curve.associated_geometry[1]) <>         associated_surface\n\t(SELF\\surface_curve.associated_geometry[2]));\n");
	config_control_designe_intersection_curve->_where_rules->Append(wr);
	config_control_designe_trimmed_curve = new EntityDescriptor(
		  "Trimmed_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiTrimmed_curve );
	s_config_control_design->AddEntity(config_control_designe_trimmed_curve);
	config_control_designe_trimmed_curve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t(HIINDEX\n\t(trim_1) = 1) OR \n\t(TYPEOF\n\t(trim_1[1]) <> TYPEOF\n\t(trim_1[2])));\n");
	config_control_designe_trimmed_curve->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (\n\t(HIINDEX\n\t(trim_2) = 1) OR \n\t(TYPEOF\n\t(trim_2[1]) <> TYPEOF\n\t(trim_2[2])));\n");
	config_control_designe_trimmed_curve->_where_rules->Append(wr);
	config_control_designe_product_definition_context = new EntityDescriptor(
		  "Product_Definition_Context", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_definition_context );
	s_config_control_design->AddEntity(config_control_designe_product_definition_context);
	config_control_designe_bounded_surface_curve = new EntityDescriptor(
		  "Bounded_Surface_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiBounded_surface_curve );
	s_config_control_design->AddEntity(config_control_designe_bounded_surface_curve);
	config_control_designe_bounded_surface_curve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF\n\t(SELF\\surface_curve.        curve_3d));\n");
	config_control_designe_bounded_surface_curve->_where_rules->Append(wr);
	config_control_designe_item_defined_transformation = new EntityDescriptor(
		  "Item_Defined_Transformation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiItem_defined_transformation );
	s_config_control_design->AddEntity(config_control_designe_item_defined_transformation);
	config_control_designe_action_method = new EntityDescriptor(
		  "Action_Method", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAction_method );
	s_config_control_design->AddEntity(config_control_designe_action_method);
	config_control_designe_product_category_relationship = new EntityDescriptor(
		  "Product_Category_Relationship", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_category_relationship );
	s_config_control_design->AddEntity(config_control_designe_product_category_relationship);
	config_control_designe_product_category_relationship->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (acyclic_product_category_relationship\n\t(SELF,[SELF.sub_category]));\n");
	config_control_designe_product_category_relationship->_where_rules->Append(wr);
	config_control_designe_plane_angle_measure_with_unit = new EntityDescriptor(
		  "Plane_Angle_Measure_With_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPlane_angle_measure_with_unit );
	s_config_control_design->AddEntity(config_control_designe_plane_angle_measure_with_unit);
	config_control_designe_plane_angle_measure_with_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF\n\t(SELF\\measure_with_unit.        unit_component));\n");
	config_control_designe_plane_angle_measure_with_unit->_where_rules->Append(wr);
	config_control_designe_vertex = new EntityDescriptor(
		  "Vertex", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiVertex );
	s_config_control_design->AddEntity(config_control_designe_vertex);
	config_control_designe_representation_map = new EntityDescriptor(
		  "Representation_Map", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiRepresentation_map );
	s_config_control_design->AddEntity(config_control_designe_representation_map);
	config_control_designe_representation_map->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (item_in_context\n\t(SELF.mapping_origin,SELF.mapped_representation.        context_of_items));\n");
	config_control_designe_representation_map->_where_rules->Append(wr);
	config_control_designe_product_definition_effectivity = new EntityDescriptor(
		  "Product_Definition_Effectivity", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_definition_effectivity );
	s_config_control_design->AddEntity(config_control_designe_product_definition_effectivity);
	config_control_designe_product_definition_effectivity->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : usage, id;\n");
	config_control_designe_product_definition_effectivity->_uniqueness_rules->Append(ur);
	config_control_designe_configuration_effectivity = new EntityDescriptor(
		  "Configuration_Effectivity", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiConfiguration_effectivity );
	s_config_control_design->AddEntity(config_control_designe_configuration_effectivity);
	config_control_designe_configuration_effectivity->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE' IN TYPEOF\n\t(SELF\\        product_definition_effectivity.usage));\n");
	config_control_designe_configuration_effectivity->_where_rules->Append(wr);
	config_control_designe_configuration_effectivity->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : configuration, usage, id;\n");
	config_control_designe_configuration_effectivity->_uniqueness_rules->Append(ur);
	config_control_designe_ellipse = new EntityDescriptor(
		  "Ellipse", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiEllipse );
	s_config_control_design->AddEntity(config_control_designe_ellipse);
	config_control_designe_context_dependent_unit = new EntityDescriptor(
		  "Context_Dependent_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiContext_dependent_unit );
	s_config_control_design->AddEntity(config_control_designe_context_dependent_unit);
	config_control_designe_alternate_product_relationship = new EntityDescriptor(
		  "Alternate_Product_Relationship", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAlternate_product_relationship );
	s_config_control_design->AddEntity(config_control_designe_alternate_product_relationship);
	config_control_designe_alternate_product_relationship->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (alternate :<>: base);\n");
	config_control_designe_alternate_product_relationship->_where_rules->Append(wr);
	config_control_designe_alternate_product_relationship->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : alternate, base;\n");
	config_control_designe_alternate_product_relationship->_uniqueness_rules->Append(ur);
	config_control_designe_document_type = new EntityDescriptor(
		  "Document_Type", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDocument_type );
	s_config_control_design->AddEntity(config_control_designe_document_type);
	config_control_designe_document_reference = new EntityDescriptor(
		  "Document_Reference", s_config_control_design, SCLLOG(LTrue), SCLLOG(LFalse),
		  (Creator) create_SdaiDocument_reference );
	s_config_control_design->AddEntity(config_control_designe_document_reference);
	config_control_designe_mechanical_context = new EntityDescriptor(
		  "Mechanical_Context", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiMechanical_context );
	s_config_control_design->AddEntity(config_control_designe_mechanical_context);
	config_control_designe_mechanical_context->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF.discipline_type = 'mechanical');\n");
	config_control_designe_mechanical_context->_where_rules->Append(wr);
	config_control_designe_shell_based_wireframe_model = new EntityDescriptor(
		  "Shell_Based_Wireframe_Model", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiShell_based_wireframe_model );
	s_config_control_design->AddEntity(config_control_designe_shell_based_wireframe_model);
	config_control_designe_shell_based_wireframe_model->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (constraints_geometry_shell_based_wireframe_model\n\t(SELF));\n");
	config_control_designe_shell_based_wireframe_model->_where_rules->Append(wr);
	config_control_designe_contract = new EntityDescriptor(
		  "Contract", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiContract );
	s_config_control_design->AddEntity(config_control_designe_contract);
	config_control_designe_dimensional_exponents = new EntityDescriptor(
		  "Dimensional_Exponents", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDimensional_exponents );
	s_config_control_design->AddEntity(config_control_designe_dimensional_exponents);
	config_control_designe_start_request = new EntityDescriptor(
		  "Start_Request", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiStart_request );
	s_config_control_design->AddEntity(config_control_designe_start_request);
	config_control_designe_cc_design_specification_reference = new EntityDescriptor(
		  "Cc_Design_Specification_Reference", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCc_design_specification_reference );
	s_config_control_design->AddEntity(config_control_designe_cc_design_specification_reference);
	config_control_designe_supplied_part_relationship = new EntityDescriptor(
		  "Supplied_Part_Relationship", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSupplied_part_relationship );
	s_config_control_design->AddEntity(config_control_designe_supplied_part_relationship);
	config_control_designe_context_dependent_shape_representation = new EntityDescriptor(
		  "Context_Dependent_Shape_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiContext_dependent_shape_representation );
	s_config_control_design->AddEntity(config_control_designe_context_dependent_shape_representation);
	config_control_designe_context_dependent_shape_representation->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF\n\t(SELF.        represented_product_relation.definition));\n");
	config_control_designe_context_dependent_shape_representation->_where_rules->Append(wr);
	config_control_designe_degenerate_toroidal_surface = new EntityDescriptor(
		  "Degenerate_Toroidal_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDegenerate_toroidal_surface );
	s_config_control_design->AddEntity(config_control_designe_degenerate_toroidal_surface);
	config_control_designe_degenerate_toroidal_surface->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (major_radius < minor_radius);\n");
	config_control_designe_degenerate_toroidal_surface->_where_rules->Append(wr);
	config_control_designe_ordinal_date = new EntityDescriptor(
		  "Ordinal_Date", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOrdinal_date );
	s_config_control_design->AddEntity(config_control_designe_ordinal_date);
	config_control_designe_ordinal_date->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t(\n\t(NOT leap_year\n\t(SELF.year_component)) AND \n\t(1 <= day_component) AND \n\t(        day_component <= 365)) OR \n\t(leap_year\n\t(SELF.year_component) AND \n\t(1 <=         day_component) AND \n\t(day_component <= 366)));\n");
	config_control_designe_ordinal_date->_where_rules->Append(wr);
	config_control_designe_face_outer_bound = new EntityDescriptor(
		  "Face_Outer_Bound", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiFace_outer_bound );
	s_config_control_design->AddEntity(config_control_designe_face_outer_bound);
	config_control_designe_mass_measure_with_unit = new EntityDescriptor(
		  "Mass_Measure_With_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiMass_measure_with_unit );
	s_config_control_design->AddEntity(config_control_designe_mass_measure_with_unit);
	config_control_designe_mass_measure_with_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.MASS_UNIT' IN TYPEOF\n\t(SELF\\measure_with_unit.        unit_component));\n");
	config_control_designe_mass_measure_with_unit->_where_rules->Append(wr);
	config_control_designe_brep_with_voids = new EntityDescriptor(
		  "Brep_With_Voids", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiBrep_with_voids );
	s_config_control_design->AddEntity(config_control_designe_brep_with_voids);
	config_control_designe_week_of_year_and_day_date = new EntityDescriptor(
		  "Week_Of_Year_And_Day_Date", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiWeek_of_year_and_day_date );
	s_config_control_design->AddEntity(config_control_designe_week_of_year_and_day_date);
	config_control_designe_point_on_curve = new EntityDescriptor(
		  "Point_On_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPoint_on_curve );
	s_config_control_design->AddEntity(config_control_designe_point_on_curve);
	config_control_designe_shell_based_wireframe_shape_representation = new EntityDescriptor(
		  "Shell_Based_Wireframe_Shape_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiShell_based_wireframe_shape_representation );
	s_config_control_design->AddEntity(config_control_designe_shell_based_wireframe_shape_representation);
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(NOT \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',        'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF\n\t(it)) = 1)) ))         = 0);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF\n\t(it)) = 1) )) >= 1);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (SIZEOF\n\t(QUERY \n\t( sbwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( ws <* QUERY \n\t( sb <* sbwm\\        shell_based_wireframe_model.sbwm_boundary | \n\t(        'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF\n\t(sb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( eloop <* QUERY \n\t( wsb <* ws\\wire_shell.wire_shell_extent | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(wsb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( el <* eloop\\path.edge_list | \n\t(NOT \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF\n\t(el.edge_element))) ))         = 0)) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (SIZEOF\n\t(QUERY \n\t( sbwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( ws <* QUERY \n\t( sb <* sbwm\\        shell_based_wireframe_model.sbwm_boundary | \n\t(        'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF\n\t(sb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( eloop <* QUERY \n\t( wsb <* ws\\wire_shell.wire_shell_extent | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(wsb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( pline_el <* QUERY \n\t( el <* eloop\\path.edge_list | \n\t(        'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF\n\t(el.edge_element\\        edge_curve.edge_geometry)) ) | \n\t(NOT \n\t(SIZEOF\n\t(pline_el.edge_element\\        edge_curve.edge_geometry\\polyline.points) > 2)) )) = 0)) )) = 0)) ))         = 0)) )) = 0);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr5: (SIZEOF\n\t(QUERY \n\t( sbwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( ws <* QUERY \n\t( sb <* sbwm\\        shell_based_wireframe_model.sbwm_boundary | \n\t(        'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF\n\t(sb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( eloop <* QUERY \n\t( wsb <* ws\\wire_shell.wire_shell_extent | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(wsb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( el <* eloop\\path.edge_list | \n\t(NOT         valid_wireframe_edge_curve\n\t(el.edge_element\\edge_curve.edge_geometry)) ))         = 0)) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr6: (SIZEOF\n\t(QUERY \n\t( sbwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( ws <* QUERY \n\t( sb <* sbwm\\        shell_based_wireframe_model.sbwm_boundary | \n\t(        'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF\n\t(sb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( eloop <* QUERY \n\t( wsb <* ws\\wire_shell.wire_shell_extent | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(wsb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( el <* eloop\\path.edge_list | \n\t(NOT \n\t(\n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(el.edge_element.        edge_start)) AND \n\t('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(el        .edge_element.edge_end)))) )) = 0)) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr7: (SIZEOF\n\t(QUERY \n\t( sbwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( ws <* QUERY \n\t( sb <* sbwm\\        shell_based_wireframe_model.sbwm_boundary | \n\t(        'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF\n\t(sb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( eloop <* QUERY \n\t( wsb <* ws\\wire_shell.wire_shell_extent | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(wsb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( el <* eloop\\path.edge_list | \n\t(NOT \n\t(        valid_wireframe_vertex_point\n\t(el.edge_element.edge_start\\        vertex_point.vertex_geometry) AND valid_wireframe_vertex_point\n\t(el.        edge_element.edge_end\\vertex_point.vertex_geometry))) )) = 0)) )) =         0)) )) = 0)) )) = 0);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr8: (SIZEOF\n\t(QUERY \n\t( sbwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( ws <* QUERY \n\t( sb <* sbwm\\        shell_based_wireframe_model.sbwm_boundary | \n\t(        'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF\n\t(sb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( vloop <* QUERY \n\t( wsb <* ws\\wire_shell.wire_shell_extent | \n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF\n\t(wsb)) ) | \n\t(NOT \n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(vloop\\vertex_loop.        loop_vertex))) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr9: (SIZEOF\n\t(QUERY \n\t( sbwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( ws <* QUERY \n\t( sb <* sbwm\\        shell_based_wireframe_model.sbwm_boundary | \n\t(        'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF\n\t(sb)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( vloop <* QUERY \n\t( wsb <* ws\\wire_shell.wire_shell_extent | \n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF\n\t(wsb)) ) | \n\t(NOT         valid_wireframe_vertex_point\n\t(vloop\\vertex_loop.loop_vertex\\        vertex_point.vertex_geometry)) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr10: (SIZEOF\n\t(QUERY \n\t( sbwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( vs <* QUERY \n\t( sb <* sbwm\\        shell_based_wireframe_model.sbwm_boundary | \n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF\n\t(sb)) ) | \n\t(NOT \n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(vs\\vertex_shell.        vertex_shell_extent.loop_vertex))) )) = 0)) )) = 0);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr11: (SIZEOF\n\t(QUERY \n\t( sbwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( vs <* QUERY \n\t( sb <* sbwm\\        shell_based_wireframe_model.sbwm_boundary | \n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF\n\t(sb)) ) | \n\t(NOT         valid_wireframe_vertex_point\n\t(vs\\vertex_shell.vertex_shell_extent.        loop_vertex\\vertex_point.vertex_geometry)) )) = 0)) )) = 0);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr12: (SIZEOF\n\t(QUERY \n\t( mi <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(\n\t(        'CONFIG_CONTROL_DESIGN.' +         'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF\n\t(mi\\        mapped_item.mapping_source.mapped_representation))) )) = 0);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr13: (SELF.context_of_items\\geometric_representation_context.        coordinate_space_dimension = 3);\n");
	config_control_designe_shell_based_wireframe_shape_representation->_where_rules->Append(wr);
	config_control_designe_face = new EntityDescriptor(
		  "Face", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiFace );
	s_config_control_design->AddEntity(config_control_designe_face);
	config_control_designe_face->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (NOT mixed_loop_type_set\n\t(list_to_set\n\t(list_face_loops\n\t(SELF))));\n");
	config_control_designe_face->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (SIZEOF\n\t(QUERY \n\t( temp <* bounds | \n\t('CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND'         IN TYPEOF\n\t(temp)) )) <= 1);\n");
	config_control_designe_face->_where_rules->Append(wr);
	config_control_designe_face_surface = new EntityDescriptor(
		  "Face_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiFace_surface );
	s_config_control_design->AddEntity(config_control_designe_face_surface);
	config_control_designe_oriented_face = new EntityDescriptor(
		  "Oriented_Face", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOriented_face );
	s_config_control_design->AddEntity(config_control_designe_oriented_face);
	config_control_designe_oriented_face->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (NOT \n\t('CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF\n\t(SELF.face_element)));\n");
	config_control_designe_oriented_face->_where_rules->Append(wr);
	config_control_designe_surface_of_revolution = new EntityDescriptor(
		  "Surface_Of_Revolution", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSurface_of_revolution );
	s_config_control_design->AddEntity(config_control_designe_surface_of_revolution);
	config_control_designe_advanced_brep_shape_representation = new EntityDescriptor(
		  "Advanced_Brep_Shape_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAdvanced_brep_shape_representation );
	s_config_control_design->AddEntity(config_control_designe_advanced_brep_shape_representation);
	config_control_designe_advanced_brep_shape_representation->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(NOT \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP',        'CONFIG_CONTROL_DESIGN.FACETED_BREP',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',        'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF\n\t(it)) = 1)) ))         = 0);\n");
	config_control_designe_advanced_brep_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF\n\t(it)) = 1) )) > 0);\n");
	config_control_designe_advanced_brep_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (SIZEOF\n\t(QUERY \n\t( msb <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF\n\t(it)) ) | \n\t(        NOT \n\t(SIZEOF\n\t(QUERY \n\t( csh <* msb_shells\n\t(msb) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( fcs <* csh\\connected_face_set.cfs_faces | \n\t(NOT \n\t(        'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF\n\t(fcs))) )) = 0)) ))         = 0)) )) = 0);\n");
	config_control_designe_advanced_brep_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (SIZEOF\n\t(QUERY \n\t( msb <* QUERY \n\t( it <* items | \n\t(        'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF\n\t(it)) ) | \n\t(        'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF\n\t(msb\\        manifold_solid_brep.outer)) )) = 0);\n");
	config_control_designe_advanced_brep_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr5: (SIZEOF\n\t(QUERY \n\t( brv <* QUERY \n\t( it <* items | \n\t(        'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( csh <* brv\\brep_with_voids.voids | csh\\        oriented_closed_shell.orientation )) = 0)) )) = 0);\n");
	config_control_designe_advanced_brep_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr6: (SIZEOF\n\t(QUERY \n\t( mi <* QUERY \n\t( it <* items | \n\t(        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(        'CONFIG_CONTROL_DESIGN.ADVANCED_BREP_SHAPE_REPRESENTATION' IN         TYPEOF\n\t(mi\\mapped_item.mapping_source.mapped_representation))) )) =         0);\n");
	config_control_designe_advanced_brep_shape_representation->_where_rules->Append(wr);
	config_control_designe_edge_curve = new EntityDescriptor(
		  "Edge_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiEdge_curve );
	s_config_control_design->AddEntity(config_control_designe_edge_curve);
	config_control_designe_point_replica = new EntityDescriptor(
		  "Point_Replica", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPoint_replica );
	s_config_control_design->AddEntity(config_control_designe_point_replica);
	config_control_designe_point_replica->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (transformation.dim = parent_pt.dim);\n");
	config_control_designe_point_replica->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (acyclic_point_replica\n\t(SELF,parent_pt));\n");
	config_control_designe_point_replica->_where_rules->Append(wr);
	config_control_designe_product = new EntityDescriptor(
		  "Product", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct );
	s_config_control_design->AddEntity(config_control_designe_product);
	config_control_designe_product->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : id;\n");
	config_control_designe_product->_uniqueness_rules->Append(ur);
	config_control_designe_shape_aspect_relationship = new EntityDescriptor(
		  "Shape_Aspect_Relationship", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiShape_aspect_relationship );
	s_config_control_design->AddEntity(config_control_designe_shape_aspect_relationship);
	config_control_designe_rectangular_trimmed_surface = new EntityDescriptor(
		  "Rectangular_Trimmed_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiRectangular_trimmed_surface );
	s_config_control_design->AddEntity(config_control_designe_rectangular_trimmed_surface);
	config_control_designe_rectangular_trimmed_surface->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (u1 <> u2);\n");
	config_control_designe_rectangular_trimmed_surface->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (v1 <> v2);\n");
	config_control_designe_rectangular_trimmed_surface->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (\n\t(\n\t('CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF\n\t(basis_surface)) AND         \n\t(NOT \n\t('CONFIG_CONTROL_DESIGN.PLANE' IN TYPEOF\n\t(basis_surface)))) OR         \n\t('CONFIG_CONTROL_DESIGN.SURFACE_OF_REVOLUTION' IN TYPEOF\n\t(        basis_surface)) OR \n\t(usense = \n\t(u2 > u1)));\n");
	config_control_designe_rectangular_trimmed_surface->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (\n\t('CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE' IN TYPEOF\n\t(basis_surface)) OR \n\t(        'CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE' IN TYPEOF\n\t(basis_surface))         OR \n\t(vsense = \n\t(v2 > v1)));\n");
	config_control_designe_rectangular_trimmed_surface->_where_rules->Append(wr);
	config_control_designe_plane = new EntityDescriptor(
		  "Plane", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPlane );
	s_config_control_design->AddEntity(config_control_designe_plane);
	config_control_designe_action_assignment = new EntityDescriptor(
		  "Action_Assignment", s_config_control_design, SCLLOG(LTrue), SCLLOG(LFalse),
		  (Creator) create_SdaiAction_assignment );
	s_config_control_design->AddEntity(config_control_designe_action_assignment);
	config_control_designe_change = new EntityDescriptor(
		  "Change", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiChange );
	s_config_control_design->AddEntity(config_control_designe_change);
	config_control_designe_circle = new EntityDescriptor(
		  "Circle", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCircle );
	s_config_control_design->AddEntity(config_control_designe_circle);
	config_control_designe_line = new EntityDescriptor(
		  "Line", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiLine );
	s_config_control_design->AddEntity(config_control_designe_line);
	config_control_designe_line->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (dir.dim = pnt.dim);\n");
	config_control_designe_line->_where_rules->Append(wr);
	config_control_designe_property_definition_representation = new EntityDescriptor(
		  "Property_Definition_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProperty_definition_representation );
	s_config_control_design->AddEntity(config_control_designe_property_definition_representation);
	config_control_designe_geometric_set = new EntityDescriptor(
		  "Geometric_Set", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiGeometric_set );
	s_config_control_design->AddEntity(config_control_designe_geometric_set);
	config_control_designe_geometric_curve_set = new EntityDescriptor(
		  "Geometric_Curve_Set", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiGeometric_curve_set );
	s_config_control_design->AddEntity(config_control_designe_geometric_curve_set);
	config_control_designe_geometric_curve_set->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(QUERY \n\t( temp <* SELF\\geometric_set.elements | \n\t(        'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF\n\t(temp)) )) = 0);\n");
	config_control_designe_geometric_curve_set->_where_rules->Append(wr);
	config_control_designe_personal_address = new EntityDescriptor(
		  "Personal_Address", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPersonal_address );
	s_config_control_design->AddEntity(config_control_designe_personal_address);
	config_control_designe_document_relationship = new EntityDescriptor(
		  "Document_Relationship", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDocument_relationship );
	s_config_control_design->AddEntity(config_control_designe_document_relationship);
	config_control_designe_outer_boundary_curve = new EntityDescriptor(
		  "Outer_Boundary_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOuter_boundary_curve );
	s_config_control_design->AddEntity(config_control_designe_outer_boundary_curve);
	config_control_designe_shape_representation_relationship = new EntityDescriptor(
		  "Shape_Representation_Relationship", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiShape_representation_relationship );
	s_config_control_design->AddEntity(config_control_designe_shape_representation_relationship);
	config_control_designe_shape_representation_relationship->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN \n\t(TYPEOF\n\t(SELF\\        representation_relationship.rep_1) + TYPEOF\n\t(SELF\\        representation_relationship.rep_2)));\n");
	config_control_designe_shape_representation_relationship->_where_rules->Append(wr);
	config_control_designe_assembly_component_usage_substitute = new EntityDescriptor(
		  "Assembly_Component_Usage_Substitute", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAssembly_component_usage_substitute );
	s_config_control_design->AddEntity(config_control_designe_assembly_component_usage_substitute);
	config_control_designe_assembly_component_usage_substitute->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (base.relating_product_definition :=: substitute.        relating_product_definition);\n");
	config_control_designe_assembly_component_usage_substitute->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (base :<>: substitute);\n");
	config_control_designe_assembly_component_usage_substitute->_where_rules->Append(wr);
	config_control_designe_assembly_component_usage_substitute->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : base, substitute;\n");
	config_control_designe_assembly_component_usage_substitute->_uniqueness_rules->Append(ur);
	config_control_designe_degenerate_pcurve = new EntityDescriptor(
		  "Degenerate_Pcurve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDegenerate_pcurve );
	s_config_control_design->AddEntity(config_control_designe_degenerate_pcurve);
	config_control_designe_degenerate_pcurve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(reference_to_curve\\representation.items) = 1);\n");
	config_control_designe_degenerate_pcurve->_where_rules->Append(wr);
	wr = new Where_rule("wr2: ('CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF\n\t(reference_to_curve\\representation.        items[1]));\n");
	config_control_designe_degenerate_pcurve->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (reference_to_curve\\representation.items[1]\\geometric_representation_item.        dim = 2);\n");
	config_control_designe_degenerate_pcurve->_where_rules->Append(wr);
	config_control_designe_evaluated_degenerate_pcurve = new EntityDescriptor(
		  "Evaluated_Degenerate_Pcurve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiEvaluated_degenerate_pcurve );
	s_config_control_design->AddEntity(config_control_designe_evaluated_degenerate_pcurve);
	config_control_designe_solid_angle_measure_with_unit = new EntityDescriptor(
		  "Solid_Angle_Measure_With_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSolid_angle_measure_with_unit );
	s_config_control_design->AddEntity(config_control_designe_solid_angle_measure_with_unit);
	config_control_designe_solid_angle_measure_with_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF\n\t(SELF\\measure_with_unit.        unit_component));\n");
	config_control_designe_solid_angle_measure_with_unit->_where_rules->Append(wr);
	config_control_designe_connected_edge_set = new EntityDescriptor(
		  "Connected_Edge_Set", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiConnected_edge_set );
	s_config_control_design->AddEntity(config_control_designe_connected_edge_set);
	config_control_designe_action = new EntityDescriptor(
		  "Action", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAction );
	s_config_control_design->AddEntity(config_control_designe_action);
	config_control_designe_executed_action = new EntityDescriptor(
		  "Executed_Action", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiExecuted_action );
	s_config_control_design->AddEntity(config_control_designe_executed_action);
	config_control_designe_directed_action = new EntityDescriptor(
		  "Directed_Action", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDirected_action );
	s_config_control_design->AddEntity(config_control_designe_directed_action);
	config_control_designe_organizational_project = new EntityDescriptor(
		  "Organizational_Project", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOrganizational_project );
	s_config_control_design->AddEntity(config_control_designe_organizational_project);
	config_control_designe_date_time_role = new EntityDescriptor(
		  "Date_Time_Role", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDate_time_role );
	s_config_control_design->AddEntity(config_control_designe_date_time_role);
	config_control_designe_curve_bounded_surface = new EntityDescriptor(
		  "Curve_Bounded_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCurve_bounded_surface );
	s_config_control_design->AddEntity(config_control_designe_curve_bounded_surface);
	config_control_designe_curve_bounded_surface->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (NOT \n\t(implicit_outer AND \n\t('CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE' IN         TYPEOF\n\t(boundaries))));\n");
	config_control_designe_curve_bounded_surface->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (\n\t(NOT implicit_outer) OR \n\t('CONFIG_CONTROL_DESIGN.BOUNDED_SURFACE' IN         TYPEOF\n\t(basis_surface)));\n");
	config_control_designe_curve_bounded_surface->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (SIZEOF\n\t(QUERY \n\t( temp <* boundaries | \n\t(        'CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF\n\t(temp)) )) <=         1);\n");
	config_control_designe_curve_bounded_surface->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (SIZEOF\n\t(QUERY \n\t( temp <* boundaries | \n\t(temp\\composite_curve_on_surface.        basis_surface[1] <> SELF.basis_surface) )) = 0);\n");
	config_control_designe_curve_bounded_surface->_where_rules->Append(wr);
	config_control_designe_closed_shell = new EntityDescriptor(
		  "Closed_Shell", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiClosed_shell );
	s_config_control_design->AddEntity(config_control_designe_closed_shell);
	config_control_designe_design_make_from_relationship = new EntityDescriptor(
		  "Design_Make_From_Relationship", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDesign_make_from_relationship );
	s_config_control_design->AddEntity(config_control_designe_design_make_from_relationship);
	config_control_designe_definitional_representation = new EntityDescriptor(
		  "Definitional_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDefinitional_representation );
	s_config_control_design->AddEntity(config_control_designe_definitional_representation);
	config_control_designe_definitional_representation->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF\n\t(SELF\\        representation.context_of_items));\n");
	config_control_designe_definitional_representation->_where_rules->Append(wr);
	config_control_designe_product_definition_shape = new EntityDescriptor(
		  "Product_Definition_Shape", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_definition_shape );
	s_config_control_design->AddEntity(config_control_designe_product_definition_shape);
	config_control_designe_product_definition_shape->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (NOT \n\t('CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION' IN TYPEOF\n\t(SELF\\        property_definition.definition)));\n");
	config_control_designe_product_definition_shape->_where_rules->Append(wr);
	config_control_designe_product_definition_shape->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : definition;\n");
	config_control_designe_product_definition_shape->_uniqueness_rules->Append(ur);
	config_control_designe_si_unit = new EntityDescriptor(
		  "Si_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSi_unit );
	s_config_control_design->AddEntity(config_control_designe_si_unit);
	config_control_designe_bezier_surface = new EntityDescriptor(
		  "Bezier_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiBezier_surface );
	s_config_control_design->AddEntity(config_control_designe_bezier_surface);
	config_control_designe_certification_assignment = new EntityDescriptor(
		  "Certification_Assignment", s_config_control_design, SCLLOG(LTrue), SCLLOG(LFalse),
		  (Creator) create_SdaiCertification_assignment );
	s_config_control_design->AddEntity(config_control_designe_certification_assignment);
	config_control_designe_start_work = new EntityDescriptor(
		  "Start_Work", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiStart_work );
	s_config_control_design->AddEntity(config_control_designe_start_work);
	config_control_designe_contract_type = new EntityDescriptor(
		  "Contract_Type", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiContract_type );
	s_config_control_design->AddEntity(config_control_designe_contract_type);
	config_control_designe_b_spline_curve_with_knots = new EntityDescriptor(
		  "B_Spline_Curve_With_Knots", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiB_spline_curve_with_knots );
	s_config_control_design->AddEntity(config_control_designe_b_spline_curve_with_knots);
	config_control_designe_b_spline_curve_with_knots->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (constraints_param_b_spline\n\t(degree,upper_index_on_knots,        upper_index_on_control_points,knot_multiplicities,knots));\n");
	config_control_designe_b_spline_curve_with_knots->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (SIZEOF\n\t(knot_multiplicities) = upper_index_on_knots);\n");
	config_control_designe_b_spline_curve_with_knots->_where_rules->Append(wr);
	config_control_designe_cc_design_approval = new EntityDescriptor(
		  "Cc_Design_Approval", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCc_design_approval );
	s_config_control_design->AddEntity(config_control_designe_cc_design_approval);
	config_control_designe_edge_based_wireframe_shape_representation = new EntityDescriptor(
		  "Edge_Based_Wireframe_Shape_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiEdge_based_wireframe_shape_representation );
	s_config_control_design->AddEntity(config_control_designe_edge_based_wireframe_shape_representation);
	config_control_designe_edge_based_wireframe_shape_representation->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(NOT \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',        'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF\n\t(it)) = 1)) ))         = 0);\n");
	config_control_designe_edge_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF\n\t(it)) = 1) )) >= 1);\n");
	config_control_designe_edge_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (SIZEOF\n\t(QUERY \n\t( ebwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( eb <* ebwm\\edge_based_wireframe_model.        ebwm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( edges <* eb.ces_edges | \n\t(NOT \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF\n\t(edges))) )) = 0)) )) =         0)) )) = 0);\n");
	config_control_designe_edge_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (SIZEOF\n\t(QUERY \n\t( ebwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( eb <* ebwm\\edge_based_wireframe_model.        ebwm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( pline_edges <*         QUERY \n\t( edges <* eb.ces_edges | \n\t('CONFIG_CONTROL_DESIGN.POLYLINE'         IN TYPEOF\n\t(edges\\edge_curve.edge_geometry)) ) | \n\t(NOT \n\t(SIZEOF\n\t(        pline_edges\\edge_curve.edge_geometry\\polyline.points) > 2)) )) = 0)) ))         = 0)) )) = 0);\n");
	config_control_designe_edge_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr5: (SIZEOF\n\t(QUERY \n\t( ebwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( eb <* ebwm\\edge_based_wireframe_model.        ebwm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( edges <* eb.ces_edges | \n\t(NOT \n\t(        \n\t('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(edges.edge_start))         AND \n\t('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(edges.edge_end)))) ))         = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_edge_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr6: (SIZEOF\n\t(QUERY \n\t( ebwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( eb <* ebwm\\edge_based_wireframe_model.        ebwm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( edges <* eb.ces_edges | \n\t(NOT         valid_wireframe_edge_curve\n\t(edges\\edge_curve.edge_geometry)) )) = 0)) ))         = 0)) )) = 0);\n");
	config_control_designe_edge_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr7: (SIZEOF\n\t(QUERY \n\t( ebwm <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF\n\t(it)) )         | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( eb <* ebwm\\edge_based_wireframe_model.        ebwm_boundary | \n\t(NOT \n\t(SIZEOF\n\t(QUERY \n\t( edges <* eb.ces_edges | \n\t(NOT \n\t(        valid_wireframe_vertex_point\n\t(edges.edge_start\\vertex_point.        vertex_geometry) AND valid_wireframe_vertex_point\n\t(edges.edge_end\\        vertex_point.vertex_geometry))) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_edge_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr8: (SIZEOF\n\t(QUERY \n\t( mi <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(\n\t(        'CONFIG_CONTROL_DESIGN.' +         'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF\n\t(mi\\        mapped_item.mapping_source.mapped_representation))) )) = 0);\n");
	config_control_designe_edge_based_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr9: (SELF.context_of_items\\geometric_representation_context.        coordinate_space_dimension = 3);\n");
	config_control_designe_edge_based_wireframe_shape_representation->_where_rules->Append(wr);
	config_control_designe_geometrically_bounded_wireframe_shape_representation = new EntityDescriptor(
		  "Geometrically_Bounded_Wireframe_Shape_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiGeometrically_bounded_wireframe_shape_representation );
	s_config_control_design->AddEntity(config_control_designe_geometrically_bounded_wireframe_shape_representation);
	config_control_designe_geometrically_bounded_wireframe_shape_representation->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(NOT \n\t(SIZEOF\n\t(TYPEOF\n\t(it) * [        'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET',        'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM']) = 1)) )) = 0);\n");
	config_control_designe_geometrically_bounded_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (SIZEOF\n\t(QUERY \n\t( it <* SELF.items | \n\t(SIZEOF\n\t(TYPEOF\n\t(it) * [        'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM']) = 1) )) >= 1);\n");
	config_control_designe_geometrically_bounded_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (SIZEOF\n\t(QUERY \n\t( gcs <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF\n\t(it)) ) | \n\t(        NOT \n\t(SIZEOF\n\t(QUERY \n\t( crv <* QUERY \n\t( elem <* gcs\\geometric_set.        elements | \n\t('CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF\n\t(elem)) ) | \n\t(        NOT valid_geometrically_bounded_wf_curve\n\t(crv)) )) = 0)) )) = 0);\n");
	config_control_designe_geometrically_bounded_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (SIZEOF\n\t(QUERY \n\t( gcs <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF\n\t(it)) ) | \n\t(        NOT \n\t(SIZEOF\n\t(QUERY \n\t( pnts <* QUERY \n\t( elem <* gcs\\geometric_set.        elements | \n\t('CONFIG_CONTROL_DESIGN.POINT' IN TYPEOF\n\t(elem)) ) | \n\t(        NOT valid_geometrically_bounded_wf_point\n\t(pnts)) )) = 0)) )) = 0);\n");
	config_control_designe_geometrically_bounded_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr5: (SIZEOF\n\t(QUERY \n\t( gcs <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF\n\t(it)) ) | \n\t(        NOT \n\t(SIZEOF\n\t(QUERY \n\t( cnc <* QUERY \n\t( elem <* gcs\\geometric_set.        elements | \n\t('CONFIG_CONTROL_DESIGN.CONIC' IN TYPEOF\n\t(elem)) ) | \n\t(        NOT \n\t('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF\n\t(cnc\\conic        .position))) )) = 0)) )) = 0);\n");
	config_control_designe_geometrically_bounded_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr6: (SIZEOF\n\t(QUERY \n\t( gcs <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF\n\t(it)) ) | \n\t(        NOT \n\t(SIZEOF\n\t(QUERY \n\t( pline <* QUERY \n\t( elem <* gcs\\geometric_set.        elements | \n\t('CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF\n\t(elem)) ) | \n\t(        NOT \n\t(SIZEOF\n\t(pline\\polyline.points) > 2)) )) = 0)) )) = 0);\n");
	config_control_designe_geometrically_bounded_wireframe_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr7: (SIZEOF\n\t(QUERY \n\t( mi <* QUERY \n\t( it <* SELF.items | \n\t(        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(\n\t(        'CONFIG_CONTROL_DESIGN.' +         'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF\n\t(        mi\\mapped_item.mapping_source.mapped_representation))) )) = 0);\n");
	config_control_designe_geometrically_bounded_wireframe_shape_representation->_where_rules->Append(wr);
	config_control_designe_product_concept = new EntityDescriptor(
		  "Product_Concept", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_concept );
	s_config_control_design->AddEntity(config_control_designe_product_concept);
	config_control_designe_product_concept->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : id;\n");
	config_control_designe_product_concept->_uniqueness_rules->Append(ur);
	config_control_designe_cc_design_contract = new EntityDescriptor(
		  "Cc_Design_Contract", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCc_design_contract );
	s_config_control_design->AddEntity(config_control_designe_cc_design_contract);
	config_control_designe_seam_curve = new EntityDescriptor(
		  "Seam_Curve", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSeam_curve );
	s_config_control_design->AddEntity(config_control_designe_seam_curve);
	config_control_designe_seam_curve->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(SELF\\surface_curve.associated_geometry) = 2);\n");
	config_control_designe_seam_curve->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (associated_surface\n\t(SELF\\surface_curve.associated_geometry[1]) =         associated_surface\n\t(SELF\\surface_curve.associated_geometry[2]));\n");
	config_control_designe_seam_curve->_where_rules->Append(wr);
	wr = new Where_rule("wr3: ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF\n\t(SELF\\surface_curve.        associated_geometry[1]));\n");
	config_control_designe_seam_curve->_where_rules->Append(wr);
	wr = new Where_rule("wr4: ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF\n\t(SELF\\surface_curve.        associated_geometry[2]));\n");
	config_control_designe_seam_curve->_where_rules->Append(wr);
	config_control_designe_axis2_placement_3d = new EntityDescriptor(
		  "Axis2_Placement_3d", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAxis2_placement_3d );
	s_config_control_design->AddEntity(config_control_designe_axis2_placement_3d);
	config_control_designe_axis2_placement_3d->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF\\placement.location.dim = 3);\n");
	config_control_designe_axis2_placement_3d->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (\n\t(NOT EXISTS\n\t(axis)) OR \n\t(axis.dim = 3));\n");
	config_control_designe_axis2_placement_3d->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (\n\t(NOT EXISTS\n\t(ref_direction)) OR \n\t(ref_direction.dim = 3));\n");
	config_control_designe_axis2_placement_3d->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (\n\t(NOT EXISTS\n\t(axis)) OR \n\t(NOT EXISTS\n\t(ref_direction)) OR \n\t(cross_product\n\t(axis,        ref_direction).magnitude > 0));\n");
	config_control_designe_axis2_placement_3d->_where_rules->Append(wr);
	config_control_designe_rational_b_spline_surface = new EntityDescriptor(
		  "Rational_B_Spline_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiRational_b_spline_surface );
	s_config_control_design->AddEntity(config_control_designe_rational_b_spline_surface);
	config_control_designe_rational_b_spline_surface->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t(SIZEOF\n\t(weights_data) = SIZEOF\n\t(SELF\\b_spline_surface.control_points_list))         AND \n\t(SIZEOF\n\t(weights_data[1]) = SIZEOF\n\t(SELF\\b_spline_surface.        control_points_list[1])));\n");
	config_control_designe_rational_b_spline_surface->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (surface_weights_positive\n\t(SELF));\n");
	config_control_designe_rational_b_spline_surface->_where_rules->Append(wr);
	config_control_designe_configuration_design = new EntityDescriptor(
		  "Configuration_Design", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiConfiguration_design );
	s_config_control_design->AddEntity(config_control_designe_configuration_design);
	config_control_designe_configuration_design->_uniqueness_rules = new Uniqueness_rule__set;
	ur = new Uniqueness_rule("UR1 : configuration, design;\n");
	config_control_designe_configuration_design->_uniqueness_rules->Append(ur);
	config_control_designe_design_context = new EntityDescriptor(
		  "Design_Context", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDesign_context );
	s_config_control_design->AddEntity(config_control_designe_design_context);
	config_control_designe_design_context->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SELF.life_cycle_stage = 'design');\n");
	config_control_designe_design_context->_where_rules->Append(wr);
	config_control_designe_product_definition = new EntityDescriptor(
		  "Product_Definition", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_definition );
	s_config_control_design->AddEntity(config_control_designe_product_definition);
	config_control_designe_product_definition_with_associated_documents = new EntityDescriptor(
		  "Product_Definition_With_Associated_Documents", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_definition_with_associated_documents );
	s_config_control_design->AddEntity(config_control_designe_product_definition_with_associated_documents);
	config_control_designe_organization = new EntityDescriptor(
		  "Organization", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOrganization );
	s_config_control_design->AddEntity(config_control_designe_organization);
	config_control_designe_cc_design_certification = new EntityDescriptor(
		  "Cc_Design_Certification", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCc_design_certification );
	s_config_control_design->AddEntity(config_control_designe_cc_design_certification);
	config_control_designe_b_spline_surface_with_knots = new EntityDescriptor(
		  "B_Spline_Surface_With_Knots", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiB_spline_surface_with_knots );
	s_config_control_design->AddEntity(config_control_designe_b_spline_surface_with_knots);
	config_control_designe_b_spline_surface_with_knots->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (constraints_param_b_spline\n\t(SELF\\b_spline_surface.u_degree,knot_u_upper,        SELF\\b_spline_surface.u_upper,u_multiplicities,u_knots));\n");
	config_control_designe_b_spline_surface_with_knots->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (constraints_param_b_spline\n\t(SELF\\b_spline_surface.v_degree,knot_v_upper,        SELF\\b_spline_surface.v_upper,v_multiplicities,v_knots));\n");
	config_control_designe_b_spline_surface_with_knots->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (SIZEOF\n\t(u_multiplicities) = knot_u_upper);\n");
	config_control_designe_b_spline_surface_with_knots->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (SIZEOF\n\t(v_multiplicities) = knot_v_upper);\n");
	config_control_designe_b_spline_surface_with_knots->_where_rules->Append(wr);
	config_control_designe_certification_type = new EntityDescriptor(
		  "Certification_Type", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCertification_type );
	s_config_control_design->AddEntity(config_control_designe_certification_type);
	config_control_designe_oriented_path = new EntityDescriptor(
		  "Oriented_Path", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOriented_path );
	s_config_control_design->AddEntity(config_control_designe_oriented_path);
	config_control_designe_oriented_path->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (NOT \n\t('CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF\n\t(SELF.path_element)));\n");
	config_control_designe_oriented_path->_where_rules->Append(wr);
	config_control_designe_security_classification = new EntityDescriptor(
		  "Security_Classification", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSecurity_classification );
	s_config_control_design->AddEntity(config_control_designe_security_classification);
	config_control_designe_vertex_loop = new EntityDescriptor(
		  "Vertex_Loop", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiVertex_loop );
	s_config_control_design->AddEntity(config_control_designe_vertex_loop);
	config_control_designe_approval_status = new EntityDescriptor(
		  "Approval_Status", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiApproval_status );
	s_config_control_design->AddEntity(config_control_designe_approval_status);
	config_control_designe_cartesian_point = new EntityDescriptor(
		  "Cartesian_Point", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCartesian_point );
	s_config_control_design->AddEntity(config_control_designe_cartesian_point);
	config_control_designe_date_and_time_assignment = new EntityDescriptor(
		  "Date_And_Time_Assignment", s_config_control_design, SCLLOG(LTrue), SCLLOG(LFalse),
		  (Creator) create_SdaiDate_and_time_assignment );
	s_config_control_design->AddEntity(config_control_designe_date_and_time_assignment);
	config_control_designe_parametric_representation_context = new EntityDescriptor(
		  "Parametric_Representation_Context", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiParametric_representation_context );
	s_config_control_design->AddEntity(config_control_designe_parametric_representation_context);
	config_control_designe_product_concept_context = new EntityDescriptor(
		  "Product_Concept_Context", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiProduct_concept_context );
	s_config_control_design->AddEntity(config_control_designe_product_concept_context);
	config_control_designe_surface_patch = new EntityDescriptor(
		  "Surface_Patch", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSurface_patch );
	s_config_control_design->AddEntity(config_control_designe_surface_patch);
	config_control_designe_surface_patch->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (NOT \n\t('CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF\n\t(        parent_surface)));\n");
	config_control_designe_surface_patch->_where_rules->Append(wr);
	config_control_designe_length_unit = new EntityDescriptor(
		  "Length_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiLength_unit );
	s_config_control_design->AddEntity(config_control_designe_length_unit);
	config_control_designe_length_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t(SELF\\named_unit.dimensions.length_exponent = 1) AND \n\t(SELF\\named_unit.        dimensions.mass_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        time_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        electric_current_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        thermodynamic_temperature_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.amount_of_substance_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.luminous_intensity_exponent = 0));\n");
	config_control_designe_length_unit->_where_rules->Append(wr);
	config_control_designe_shape_aspect = new EntityDescriptor(
		  "Shape_Aspect", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiShape_aspect );
	s_config_control_design->AddEntity(config_control_designe_shape_aspect);
	config_control_designe_volume_measure_with_unit = new EntityDescriptor(
		  "Volume_Measure_With_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiVolume_measure_with_unit );
	s_config_control_design->AddEntity(config_control_designe_volume_measure_with_unit);
	config_control_designe_volume_measure_with_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: ('CONFIG_CONTROL_DESIGN.VOLUME_UNIT' IN TYPEOF\n\t(SELF\\measure_with_unit.        unit_component));\n");
	config_control_designe_volume_measure_with_unit->_where_rules->Append(wr);
	config_control_designe_advanced_face = new EntityDescriptor(
		  "Advanced_Face", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiAdvanced_face );
	s_config_control_design->AddEntity(config_control_designe_advanced_face);
	config_control_designe_advanced_face->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(['CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE',        'CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE',        'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'] * TYPEOF\n\t(face_geometry)) = 1);\n");
	config_control_designe_advanced_face->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (SIZEOF\n\t(QUERY \n\t( elp_fbnds <* QUERY \n\t( bnds <* bounds | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( oe <* elp_fbnds.bound\\path.edge_list | \n\t(NOT \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF\n\t(oe\\oriented_edge.        edge_element))) )) = 0)) )) = 0);\n");
	config_control_designe_advanced_face->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (SIZEOF\n\t(QUERY \n\t( elp_fbnds <* QUERY \n\t( bnds <* bounds | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( oe <* elp_fbnds.bound\\path.edge_list | \n\t(NOT \n\t(SIZEOF\n\t(        ['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.CONIC',        'CONFIG_CONTROL_DESIGN.POLYLINE',        'CONFIG_CONTROL_DESIGN.SURFACE_CURVE',        'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] * TYPEOF\n\t(oe.edge_element\\        edge_curve.edge_geometry)) = 1)) )) = 0)) )) = 0);\n");
	config_control_designe_advanced_face->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (SIZEOF\n\t(QUERY \n\t( elp_fbnds <* QUERY \n\t( bnds <* bounds | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( oe <* elp_fbnds.bound\\path.edge_list | \n\t(NOT \n\t(\n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(oe\\edge.edge_start))         AND \n\t('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF\n\t(oe\\edge.        edge_start\\vertex_point.vertex_geometry)) AND \n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(oe\\edge.edge_end))         AND \n\t('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF\n\t(oe\\edge.        edge_end\\vertex_point.vertex_geometry)))) )) = 0)) )) = 0);\n");
	config_control_designe_advanced_face->_where_rules->Append(wr);
	wr = new Where_rule("wr5: (SIZEOF\n\t(QUERY \n\t( elp_fbnds <* QUERY \n\t( bnds <* bounds | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(        'CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF\n\t(elp_fbnds.bound)) ))         = 0);\n");
	config_control_designe_advanced_face->_where_rules->Append(wr);
	wr = new Where_rule("wr6: (\n\t(NOT \n\t('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF\n\t(face_geometry))) OR         \n\t(SIZEOF\n\t(['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.CONIC',        'CONFIG_CONTROL_DESIGN.POLYLINE',        'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] * TYPEOF\n\t(face_geometry\\        swept_surface.swept_curve)) = 1));\n");
	config_control_designe_advanced_face->_where_rules->Append(wr);
	wr = new Where_rule("wr7: (SIZEOF\n\t(QUERY \n\t( vlp_fbnds <* QUERY \n\t( bnds <* bounds | \n\t(        'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(        NOT \n\t(\n\t('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF\n\t(vlp_fbnds\\        face_bound.bound\\vertex_loop.loop_vertex)) AND \n\t(        'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF\n\t(vlp_fbnds\\        face_bound.bound\\vertex_loop.loop_vertex\\vertex_point.        vertex_geometry)))) )) = 0);\n");
	config_control_designe_advanced_face->_where_rules->Append(wr);
	wr = new Where_rule("wr8: (SIZEOF\n\t(QUERY \n\t( bnd <* bounds | \n\t(NOT \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.EDGE_LOOP',        'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'] * TYPEOF\n\t(bnd.bound)) = 1)) ))         = 0);\n");
	config_control_designe_advanced_face->_where_rules->Append(wr);
	wr = new Where_rule("wr9: (SIZEOF\n\t(QUERY \n\t( elp_fbnds <* QUERY \n\t( bnds <* bounds | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( oe <* elp_fbnds.bound\\path.edge_list | \n\t(\n\t(        'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF\n\t(oe\\oriented_edge.        edge_element\\edge_curve.edge_geometry)) AND \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( sc_ag <* oe.edge_element\\edge_curve.edge_geometry\\        surface_curve.associated_geometry | \n\t(NOT \n\t(        'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF\n\t(sc_ag))) )) = 0))) )) = 0)) ))         = 0);\n");
	config_control_designe_advanced_face->_where_rules->Append(wr);
	wr = new Where_rule("wr10: (\n\t(\n\t(NOT \n\t('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF\n\t(face_geometry))) OR         \n\t(NOT \n\t('CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF\n\t(face_geometry\\        swept_surface.swept_curve))) OR \n\t(SIZEOF\n\t(face_geometry\\swept_surface        .swept_curve\\polyline.points) >= 3)) AND \n\t(SIZEOF\n\t(        QUERY \n\t( elp_fbnds <* QUERY \n\t( bnds <* bounds | \n\t(        'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF\n\t(bnds.bound)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( oe <* elp_fbnds.bound\\path.edge_list | \n\t(\n\t(        'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF\n\t(oe\\oriented_edge.        edge_element\\edge_curve.edge_geometry)) AND \n\t(NOT \n\t(SIZEOF\n\t(oe\\        oriented_edge.edge_element\\edge_curve.edge_geometry\\polyline.points)         >= 3))) )) = 0)) )) = 0));\n");
	config_control_designe_advanced_face->_where_rules->Append(wr);
	config_control_designe_security_classification_level = new EntityDescriptor(
		  "Security_Classification_Level", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSecurity_classification_level );
	s_config_control_design->AddEntity(config_control_designe_security_classification_level);
	config_control_designe_approval_relationship = new EntityDescriptor(
		  "Approval_Relationship", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiApproval_relationship );
	s_config_control_design->AddEntity(config_control_designe_approval_relationship);
	config_control_designe_polyline = new EntityDescriptor(
		  "Polyline", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPolyline );
	s_config_control_design->AddEntity(config_control_designe_polyline);
	config_control_designe_approval_person_organization = new EntityDescriptor(
		  "Approval_Person_Organization", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiApproval_person_organization );
	s_config_control_design->AddEntity(config_control_designe_approval_person_organization);
	config_control_designe_surface_replica = new EntityDescriptor(
		  "Surface_Replica", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiSurface_replica );
	s_config_control_design->AddEntity(config_control_designe_surface_replica);
	config_control_designe_surface_replica->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (acyclic_surface_replica\n\t(SELF,parent_surface));\n");
	config_control_designe_surface_replica->_where_rules->Append(wr);
	config_control_designe_security_classification_assignment = new EntityDescriptor(
		  "Security_Classification_Assignment", s_config_control_design, SCLLOG(LTrue), SCLLOG(LFalse),
		  (Creator) create_SdaiSecurity_classification_assignment );
	s_config_control_design->AddEntity(config_control_designe_security_classification_assignment);
	config_control_designe_cc_design_security_classification = new EntityDescriptor(
		  "Cc_Design_Security_Classification", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCc_design_security_classification );
	s_config_control_design->AddEntity(config_control_designe_cc_design_security_classification);
	config_control_designe_faceted_brep_shape_representation = new EntityDescriptor(
		  "Faceted_Brep_Shape_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiFaceted_brep_shape_representation );
	s_config_control_design->AddEntity(config_control_designe_faceted_brep_shape_representation);
	config_control_designe_faceted_brep_shape_representation->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (SIZEOF\n\t(QUERY \n\t( it <* items | \n\t(NOT \n\t(SIZEOF\n\t([        'CONFIG_CONTROL_DESIGN.FACETED_BREP',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',        'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF\n\t(it)) = 1)) ))         = 0);\n");
	config_control_designe_faceted_brep_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr2: (SIZEOF\n\t(QUERY \n\t( it <* items | \n\t(SIZEOF\n\t(['CONFIG_CONTROL_DESIGN.FACETED_BREP',        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF\n\t(it)) = 1) )) > 0);\n");
	config_control_designe_faceted_brep_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr3: (SIZEOF\n\t(QUERY \n\t( fbrep <* QUERY \n\t( it <* items | \n\t(        'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( csh <* msb_shells\n\t(fbrep) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( fcs <* csh\\connected_face_set.cfs_faces | \n\t(NOT \n\t(\n\t(        'CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN TYPEOF\n\t(fcs)) AND \n\t(        'CONFIG_CONTROL_DESIGN.PLANE' IN TYPEOF\n\t(fcs\\face_surface.        face_geometry)) AND \n\t('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN         TYPEOF\n\t(fcs\\face_surface.face_geometry\\elementary_surface.position.        location)))) )) = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_faceted_brep_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr4: (SIZEOF\n\t(QUERY \n\t( fbrep <* QUERY \n\t( it <* items | \n\t(        'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( csh <* msb_shells\n\t(fbrep) | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( fcs <* csh\\connected_face_set.cfs_faces | \n\t(NOT \n\t(SIZEOF\n\t(        QUERY \n\t( bnds <* fcs.bounds | \n\t(        'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF\n\t(bnds)) )) = 1)) ))         = 0)) )) = 0)) )) = 0);\n");
	config_control_designe_faceted_brep_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr5: (SIZEOF\n\t(QUERY \n\t( msb <* QUERY \n\t( it <* items | \n\t(        'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF\n\t(it)) ) | \n\t(        'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF\n\t(msb\\        manifold_solid_brep.outer)) )) = 0);\n");
	config_control_designe_faceted_brep_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr6: (SIZEOF\n\t(QUERY \n\t( brv <* QUERY \n\t( it <* items | \n\t(        'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(        SIZEOF\n\t(QUERY \n\t( csh <* brv\\brep_with_voids.voids | csh\\        oriented_closed_shell.orientation )) = 0)) )) = 0);\n");
	config_control_designe_faceted_brep_shape_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr7: (SIZEOF\n\t(QUERY \n\t( mi <* QUERY \n\t( it <* items | \n\t(        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF\n\t(it)) ) | \n\t(NOT \n\t(        'CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION' IN         TYPEOF\n\t(mi\\mapped_item.mapping_source.mapped_representation))) )) =         0);\n");
	config_control_designe_faceted_brep_shape_representation->_where_rules->Append(wr);
	config_control_designe_document_usage_constraint = new EntityDescriptor(
		  "Document_Usage_Constraint", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiDocument_usage_constraint );
	s_config_control_design->AddEntity(config_control_designe_document_usage_constraint);
	config_control_designe_vertex_point = new EntityDescriptor(
		  "Vertex_Point", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiVertex_point );
	s_config_control_design->AddEntity(config_control_designe_vertex_point);
	config_control_designe_cc_design_date_and_time_assignment = new EntityDescriptor(
		  "Cc_Design_Date_And_Time_Assignment", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCc_design_date_and_time_assignment );
	s_config_control_design->AddEntity(config_control_designe_cc_design_date_and_time_assignment);
	config_control_designe_cc_design_date_and_time_assignment->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (cc_design_date_time_correlation\n\t(SELF));\n");
	config_control_designe_cc_design_date_and_time_assignment->_where_rules->Append(wr);
	config_control_designe_oriented_closed_shell = new EntityDescriptor(
		  "Oriented_Closed_Shell", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiOriented_closed_shell );
	s_config_control_design->AddEntity(config_control_designe_oriented_closed_shell);
	config_control_designe_oriented_closed_shell->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (NOT \n\t('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF\n\t(SELF.        closed_shell_element)));\n");
	config_control_designe_oriented_closed_shell->_where_rules->Append(wr);
	config_control_designe_person_and_organization = new EntityDescriptor(
		  "Person_And_Organization", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPerson_and_organization );
	s_config_control_design->AddEntity(config_control_designe_person_and_organization);
	config_control_designe_cylindrical_surface = new EntityDescriptor(
		  "Cylindrical_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiCylindrical_surface );
	s_config_control_design->AddEntity(config_control_designe_cylindrical_surface);
	config_control_designe_local_time = new EntityDescriptor(
		  "Local_Time", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiLocal_time );
	s_config_control_design->AddEntity(config_control_designe_local_time);
	config_control_designe_local_time->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (valid_time\n\t(SELF));\n");
	config_control_designe_local_time->_where_rules->Append(wr);
	config_control_designe_mass_unit = new EntityDescriptor(
		  "Mass_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiMass_unit );
	s_config_control_design->AddEntity(config_control_designe_mass_unit);
	config_control_designe_mass_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t(SELF\\named_unit.dimensions.length_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.mass_exponent = 1) AND \n\t(SELF\\named_unit.dimensions.        time_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        electric_current_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        thermodynamic_temperature_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.amount_of_substance_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.luminous_intensity_exponent = 0));\n");
	config_control_designe_mass_unit->_where_rules->Append(wr);
	config_control_designe_vertex_shell = new EntityDescriptor(
		  "Vertex_Shell", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiVertex_shell );
	s_config_control_design->AddEntity(config_control_designe_vertex_shell);
	config_control_designe_poly_loop = new EntityDescriptor(
		  "Poly_Loop", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiPoly_loop );
	s_config_control_design->AddEntity(config_control_designe_poly_loop);
	config_control_designe_wire_shell = new EntityDescriptor(
		  "Wire_Shell", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiWire_shell );
	s_config_control_design->AddEntity(config_control_designe_wire_shell);
	config_control_designe_wire_shell->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (NOT mixed_loop_type_set\n\t(wire_shell_extent));\n");
	config_control_designe_wire_shell->_where_rules->Append(wr);
	config_control_designe_area_unit = new EntityDescriptor(
		  "Area_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiArea_unit );
	s_config_control_design->AddEntity(config_control_designe_area_unit);
	config_control_designe_area_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t(SELF\\named_unit.dimensions.length_exponent = 2) AND \n\t(SELF\\named_unit.        dimensions.mass_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        time_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        electric_current_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        thermodynamic_temperature_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.amount_of_substance_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.luminous_intensity_exponent = 0));\n");
	config_control_designe_area_unit->_where_rules->Append(wr);
	config_control_designe_mapped_item = new EntityDescriptor(
		  "Mapped_Item", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiMapped_item );
	s_config_control_design->AddEntity(config_control_designe_mapped_item);
	config_control_designe_mapped_item->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (acyclic_mapped_representation\n\t(using_representations\n\t(SELF),[SELF]));\n");
	config_control_designe_mapped_item->_where_rules->Append(wr);
	config_control_designe_shape_definition_representation = new EntityDescriptor(
		  "Shape_Definition_Representation", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiShape_definition_representation );
	s_config_control_design->AddEntity(config_control_designe_shape_definition_representation);
	config_control_designe_shape_definition_representation->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t('CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION' IN TYPEOF\n\t(SELF.definition.        definition)) OR \n\t('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE'         IN TYPEOF\n\t(SELF.definition)));\n");
	config_control_designe_shape_definition_representation->_where_rules->Append(wr);
	wr = new Where_rule("wr2: ('CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF\n\t(SELF.        used_representation));\n");
	config_control_designe_shape_definition_representation->_where_rules->Append(wr);
	config_control_designe_volume_unit = new EntityDescriptor(
		  "Volume_Unit", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiVolume_unit );
	s_config_control_design->AddEntity(config_control_designe_volume_unit);
	config_control_designe_volume_unit->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (\n\t(SELF\\named_unit.dimensions.length_exponent = 3) AND \n\t(SELF\\named_unit.        dimensions.mass_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        time_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        electric_current_exponent = 0) AND \n\t(SELF\\named_unit.dimensions.        thermodynamic_temperature_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.amount_of_substance_exponent = 0) AND \n\t(SELF\\named_unit.        dimensions.luminous_intensity_exponent = 0));\n");
	config_control_designe_volume_unit->_where_rules->Append(wr);
	config_control_designe_conical_surface = new EntityDescriptor(
		  "Conical_Surface", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiConical_surface );
	s_config_control_design->AddEntity(config_control_designe_conical_surface);
	config_control_designe_conical_surface->_where_rules = new Where_rule__list;
	wr = new Where_rule("wr1: (radius >= 0);\n");
	config_control_designe_conical_surface->_where_rules->Append(wr);
	config_control_designe_global_unit_assigned_context = new EntityDescriptor(
		  "Global_Unit_Assigned_Context", s_config_control_design, SCLLOG(LFalse), SCLLOG(LFalse),
		  (Creator) create_SdaiGlobal_unit_assigned_context );
	s_config_control_design->AddEntity(config_control_designe_global_unit_assigned_context);

	//////////////// USE statements
	//////////////// REFERENCE statements
}

#endif
