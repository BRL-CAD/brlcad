/*
 * This file contains instantiation statements to create complex
 * support structures.  The structures will be used in the SCL to
 * validate user requests to instantiate complex entities.
 */

#include "complexSupport.h"

ComplexCollect *gencomplex()
    /*
     * This function contains instantiation statments for all the
     * ComplexLists and EntLists in a ComplexCollect.  The instan-
     * stiation statements were generated in order of lower to
     * higher, and last to first to simplify creating some of the
     * links between structures.  Because of this, the code is not
     * very readable, but does the trick.
     */
{
    ComplexCollect *cc;
    ComplexList *cl;
    EntList *node, *child, *next1, *next2, *next3, *next4,
            *next5, *next6, *next7, *next8, *next9, *next10,
            *next11, *next12, *next13, *next14, *next15,
            *next16, *next17, *next18;

    cc = new ComplexCollect;

    // ComplexList with supertype "action":
    node = new SimpleList( "directed_action" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next4 = node;
    node = new SimpleList( "executed_action" );
    next4->prev = node;
    node->next = next4;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next3 = node;
    node = new SimpleList( "executed_action" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "action" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "action_assignment":
    node = new SimpleList( "start_work" );
    next2 = node;
    node = new SimpleList( "change" );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "action_assignment" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "action_request_assignment":
    node = new SimpleList( "start_request" );
    next2 = node;
    node = new SimpleList( "change_request" );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "action_request_assignment" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "address":
    node = new SimpleList( "personal_address" );
    next2 = node;
    node = new SimpleList( "organizational_address" );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "address" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "application_context_element":
    node = new SimpleList( "product_concept_context" );
    next2 = node;
    node = new SimpleList( "design_context" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next4 = node;
    node = new SimpleList( "product_definition_context" );
    next4->prev = node;
    node->next = next4;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next3 = node;
    node = new SimpleList( "product_definition_context" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2->prev = node;
    node->next = next2;
    next2 = node;
    node = new SimpleList( "mechanical_context" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next4 = node;
    node = new SimpleList( "product_context" );
    next4->prev = node;
    node->next = next4;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next3 = node;
    node = new SimpleList( "product_context" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "application_context_element" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "approval_assignment":
    node = new SimpleList( "cc_design_approval" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "approval_assignment" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "certification_assignment":
    node = new SimpleList( "cc_design_certification" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "certification_assignment" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "contract_assignment":
    node = new SimpleList( "cc_design_contract" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "contract_assignment" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "date":
    node = new SimpleList( "week_of_year_and_day_date" );
    next2 = node;
    node = new SimpleList( "ordinal_date" );
    next2->prev = node;
    node->next = next2;
    next2 = node;
    node = new SimpleList( "calendar_date" );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "date" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "date_and_time_assignment":
    node = new SimpleList( "cc_design_date_and_time_assignment" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "date_and_time_assignment" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "document":
    node = new SimpleList( "document_with_class" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "document" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "document_reference":
    node = new SimpleList( "cc_design_specification_reference" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "document_reference" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "effectivity":
    node = new SimpleList( "configuration_effectivity" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next4 = node;
    node = new SimpleList( "product_definition_effectivity" );
    next4->prev = node;
    node->next = next4;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next3 = node;
    node = new SimpleList( "product_definition_effectivity" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2 = node;
    node = new SimpleList( "lot_effectivity" );
    next3 = node;
    node = new SimpleList( "dated_effectivity" );
    next3->prev = node;
    node->next = next3;
    next3 = node;
    node = new SimpleList( "serial_numbered_effectivity" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "effectivity" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "founded_item":
    node = new SimpleList( "surface_patch" );
    next2 = node;
    node = new SimpleList( "reparametrised_composite_curve_segment" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next4 = node;
    node = new SimpleList( "composite_curve_segment" );
    next4->prev = node;
    node->next = next4;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next3 = node;
    node = new SimpleList( "composite_curve_segment" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "founded_item" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "functionally_defined_transformation":
    node = new SimpleList( "cartesian_transformation_operator_3d" );
    next4 = node;
    node = new SimpleList( "cartesian_transformation_operator" );
    next4->prev = node;
    node->next = next4;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next3 = node;
    node = new SimpleList( "cartesian_transformation_operator" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "functionally_defined_transformation" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "measure_with_unit":
    node = new SimpleList( "uncertainty_measure_with_unit" );
    next2 = node;
    node = new SimpleList( "volume_measure_with_unit" );
    next3 = node;
    node = new SimpleList( "area_measure_with_unit" );
    next3->prev = node;
    node->next = next3;
    next3 = node;
    node = new SimpleList( "solid_angle_measure_with_unit" );
    next3->prev = node;
    node->next = next3;
    next3 = node;
    node = new SimpleList( "plane_angle_measure_with_unit" );
    next3->prev = node;
    node->next = next3;
    next3 = node;
    node = new SimpleList( "mass_measure_with_unit" );
    next3->prev = node;
    node->next = next3;
    next3 = node;
    node = new SimpleList( "length_measure_with_unit" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "measure_with_unit" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "named_unit":
    node = new SimpleList( "volume_unit" );
    next3 = node;
    node = new SimpleList( "area_unit" );
    next3->prev = node;
    node->next = next3;
    next3 = node;
    node = new SimpleList( "solid_angle_unit" );
    next3->prev = node;
    node->next = next3;
    next3 = node;
    node = new SimpleList( "plane_angle_unit" );
    next3->prev = node;
    node->next = next3;
    next3 = node;
    node = new SimpleList( "mass_unit" );
    next3->prev = node;
    node->next = next3;
    next3 = node;
    node = new SimpleList( "length_unit" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2 = node;
    node = new SimpleList( "context_dependent_unit" );
    next3 = node;
    node = new SimpleList( "conversion_based_unit" );
    next3->prev = node;
    node->next = next3;
    next3 = node;
    node = new SimpleList( "si_unit" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "named_unit" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "person_and_organization_assignment":
    node = new SimpleList( "cc_design_person_and_organization_assignment" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "person_and_organization_assignment" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "product_category":
    node = new SimpleList( "product_related_product_category" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "product_category" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "product_definition":
    node = new SimpleList( "product_definition_with_associated_documents" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "product_definition" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "product_definition_formation":
    node = new SimpleList( "product_definition_formation_with_specified_source" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "product_definition_formation" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "product_definition_relationship":
    node = new SimpleList( "quantified_assembly_component_usage" );
    next7 = node;
    node = new SimpleList( "promissory_usage_occurrence" );
    next8 = node;
    node = new SimpleList( "specified_higher_usage_occurrence" );
    next8->prev = node;
    node->next = next8;
    next8 = node;
    node = new SimpleList( "next_assembly_usage_occurrence" );
    next8->prev = node;
    node->next = next8;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "assembly_component_usage" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next5 = node;
    node = new SimpleList( "assembly_component_usage" );
    next5->prev = node;
    node->next = next5;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next4 = node;
    node = new SimpleList( "product_definition_usage" );
    next4->prev = node;
    node->next = next4;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next3 = node;
    node = new SimpleList( "product_definition_usage" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2 = node;
    node = new SimpleList( "design_make_from_relationship" );
    next2->prev = node;
    node->next = next2;
    next2 = node;
    node = new SimpleList( "supplied_part_relationship" );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "product_definition_relationship" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "property_definition":
    node = new SimpleList( "product_definition_shape" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "property_definition" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "property_definition_representation":
    node = new SimpleList( "shape_definition_representation" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "property_definition_representation" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "representation":
    node = new SimpleList( "faceted_brep_shape_representation" );
    next5 = node;
    node = new SimpleList( "geometrically_bounded_wireframe_shape_representation" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "edge_based_wireframe_shape_representation" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "advanced_brep_shape_representation" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "shell_based_wireframe_shape_representation" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "geometrically_bounded_surface_shape_representation" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "manifold_surface_shape_representation" );
    next5->prev = node;
    node->next = next5;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next4 = node;
    node = new SimpleList( "shape_representation" );
    next4->prev = node;
    node->next = next4;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next3 = node;
    node = new SimpleList( "shape_representation" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2 = node;
    node = new SimpleList( "definitional_representation" );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "representation" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "representation_context":
    node = new SimpleList( "global_unit_assigned_context" );
    next2 = node;
    node = new SimpleList( "parametric_representation_context" );
    next2->prev = node;
    node->next = next2;
    next2 = node;
    node = new SimpleList( "global_uncertainty_assigned_context" );
    next2->prev = node;
    node->next = next2;
    next2 = node;
    node = new SimpleList( "geometric_representation_context" );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "representation_context" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "representation_item":
    node = new SimpleList( "mapped_item" );
    next2 = node;
    node = new SimpleList( "geometric_curve_set" );
    next7 = node;
    node = new SimpleList( "geometric_set" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "geometric_set" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5 = node;
    node = new SimpleList( "edge_based_wireframe_model" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "shell_based_wireframe_model" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "shell_based_surface_model" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "brep_with_voids" );
    next10 = node;
    node = new SimpleList( "faceted_brep" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next9 = node;
    node = new SimpleList( "manifold_solid_brep" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next8 = node;
    node = new SimpleList( "manifold_solid_brep" );
    next8->prev = node;
    node->next = next8;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "solid_model" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "solid_model" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "vertex_point" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "poly_loop" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "advanced_face" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "face_surface" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "face_surface" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "edge_curve" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "surface_replica" );
    next8 = node;
    node = new SimpleList( "offset_surface" );
    next8->prev = node;
    node->next = next8;
    next8 = node;
    node = new SimpleList( "rectangular_composite_surface" );
    next11 = node;
    node = new SimpleList( "curve_bounded_surface" );
    next11->prev = node;
    node->next = next11;
    next11 = node;
    node = new SimpleList( "rectangular_trimmed_surface" );
    next11->prev = node;
    node->next = next11;
    next11 = node;
    node = new SimpleList( "rational_b_spline_surface" );
    next14 = node;
    node = new SimpleList( "bezier_surface" );
    next15 = node;
    node = new SimpleList( "quasi_uniform_surface" );
    next15->prev = node;
    node->next = next15;
    next15 = node;
    node = new SimpleList( "uniform_surface" );
    next15->prev = node;
    node->next = next15;
    next15 = node;
    node = new SimpleList( "b_spline_surface_with_knots" );
    next15->prev = node;
    node->next = next15;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next14->prev = node;
    node->next = next14;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next13 = node;
    node = new SimpleList( "b_spline_surface" );
    next13->prev = node;
    node->next = next13;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next12 = node;
    node = new SimpleList( "b_spline_surface" );
    next12->prev = node;
    node->next = next12;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next11->prev = node;
    node->next = next11;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next10 = node;
    node = new SimpleList( "bounded_surface" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next9 = node;
    node = new SimpleList( "bounded_surface" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next8->prev = node;
    node->next = next8;
    next8 = node;
    node = new SimpleList( "surface_of_revolution" );
    next11 = node;
    node = new SimpleList( "surface_of_linear_extrusion" );
    next11->prev = node;
    node->next = next11;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next10 = node;
    node = new SimpleList( "swept_surface" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next9 = node;
    node = new SimpleList( "swept_surface" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next8->prev = node;
    node->next = next8;
    next8 = node;
    node = new SimpleList( "degenerate_toroidal_surface" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next13 = node;
    node = new SimpleList( "toroidal_surface" );
    next13->prev = node;
    node->next = next13;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next12 = node;
    node = new SimpleList( "toroidal_surface" );
    next12->prev = node;
    node->next = next12;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next11 = node;
    node = new SimpleList( "spherical_surface" );
    next11->prev = node;
    node->next = next11;
    next11 = node;
    node = new SimpleList( "conical_surface" );
    next11->prev = node;
    node->next = next11;
    next11 = node;
    node = new SimpleList( "cylindrical_surface" );
    next11->prev = node;
    node->next = next11;
    next11 = node;
    node = new SimpleList( "plane" );
    next11->prev = node;
    node->next = next11;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next10 = node;
    node = new SimpleList( "elementary_surface" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next9 = node;
    node = new SimpleList( "elementary_surface" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next8->prev = node;
    node->next = next8;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "surface" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "surface" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "outer_boundary_curve" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next18 = node;
    node = new SimpleList( "boundary_curve" );
    next18->prev = node;
    node->next = next18;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next17 = node;
    node = new SimpleList( "boundary_curve" );
    next17->prev = node;
    node->next = next17;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next16 = node;
    node = new SimpleList( "composite_curve_on_surface" );
    next16->prev = node;
    node->next = next16;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next15 = node;
    node = new SimpleList( "composite_curve_on_surface" );
    next15->prev = node;
    node->next = next15;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next13 = node;
    node = new SimpleList( "composite_curve" );
    next13->prev = node;
    node->next = next13;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next12 = node;
    node = new SimpleList( "composite_curve" );
    next12->prev = node;
    node->next = next12;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next11 = node;
    node = new SimpleList( "bounded_surface_curve" );
    next11->prev = node;
    node->next = next11;
    next11 = node;
    node = new SimpleList( "bounded_pcurve" );
    next11->prev = node;
    node->next = next11;
    next11 = node;
    node = new SimpleList( "trimmed_curve" );
    next11->prev = node;
    node->next = next11;
    next11 = node;
    node = new SimpleList( "rational_b_spline_curve" );
    next14 = node;
    node = new SimpleList( "bezier_curve" );
    next15 = node;
    node = new SimpleList( "quasi_uniform_curve" );
    next15->prev = node;
    node->next = next15;
    next15 = node;
    node = new SimpleList( "b_spline_curve_with_knots" );
    next15->prev = node;
    node->next = next15;
    next15 = node;
    node = new SimpleList( "uniform_curve" );
    next15->prev = node;
    node->next = next15;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next14->prev = node;
    node->next = next14;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next13 = node;
    node = new SimpleList( "b_spline_curve" );
    next13->prev = node;
    node->next = next13;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next12 = node;
    node = new SimpleList( "b_spline_curve" );
    next12->prev = node;
    node->next = next12;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next11->prev = node;
    node->next = next11;
    next11 = node;
    node = new SimpleList( "polyline" );
    next11->prev = node;
    node->next = next11;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next10 = node;
    node = new SimpleList( "bounded_curve" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next9 = node;
    node = new SimpleList( "bounded_curve" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next8 = node;
    node = new SimpleList( "curve_replica" );
    next9 = node;
    node = new SimpleList( "offset_curve_3d" );
    next9->prev = node;
    node->next = next9;
    next9 = node;
    node = new SimpleList( "bounded_surface_curve" );
    next12 = node;
    node = new SimpleList( "seam_curve" );
    next13 = node;
    node = new SimpleList( "intersection_curve" );
    next13->prev = node;
    node->next = next13;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next12->prev = node;
    node->next = next12;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next11 = node;
    node = new SimpleList( "surface_curve" );
    next11->prev = node;
    node->next = next11;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next10 = node;
    node = new SimpleList( "surface_curve" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next9->prev = node;
    node->next = next9;
    next9 = node;
    node = new SimpleList( "bounded_pcurve" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next11 = node;
    node = new SimpleList( "pcurve" );
    next11->prev = node;
    node->next = next11;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next10 = node;
    node = new SimpleList( "pcurve" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next9->prev = node;
    node->next = next9;
    next9 = node;
    node = new SimpleList( "parabola" );
    next12 = node;
    node = new SimpleList( "hyperbola" );
    next12->prev = node;
    node->next = next12;
    next12 = node;
    node = new SimpleList( "ellipse" );
    next12->prev = node;
    node->next = next12;
    next12 = node;
    node = new SimpleList( "circle" );
    next12->prev = node;
    node->next = next12;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next11 = node;
    node = new SimpleList( "conic" );
    next11->prev = node;
    node->next = next11;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next10 = node;
    node = new SimpleList( "conic" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next9->prev = node;
    node->next = next9;
    next9 = node;
    node = new SimpleList( "line" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next8->prev = node;
    node->next = next8;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "curve" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "curve" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "cartesian_transformation_operator_3d" );
    next7 = node;
    node = new SimpleList( "cartesian_transformation_operator" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "cartesian_transformation_operator" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "axis2_placement_3d" );
    next8 = node;
    node = new SimpleList( "axis2_placement_2d" );
    next8->prev = node;
    node->next = next8;
    next8 = node;
    node = new SimpleList( "axis1_placement" );
    next8->prev = node;
    node->next = next8;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "placement" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "placement" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "vector" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "direction" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "evaluated_degenerate_pcurve" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next10 = node;
    node = new SimpleList( "degenerate_pcurve" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next9 = node;
    node = new SimpleList( "degenerate_pcurve" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next8 = node;
    node = new SimpleList( "point_replica" );
    next8->prev = node;
    node->next = next8;
    next8 = node;
    node = new SimpleList( "point_on_surface" );
    next8->prev = node;
    node->next = next8;
    next8 = node;
    node = new SimpleList( "point_on_curve" );
    next8->prev = node;
    node->next = next8;
    next8 = node;
    node = new SimpleList( "cartesian_point" );
    next8->prev = node;
    node->next = next8;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "point" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "point" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next4 = node;
    node = new SimpleList( "geometric_representation_item" );
    next4->prev = node;
    node->next = next4;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next3 = node;
    node = new SimpleList( "geometric_representation_item" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2->prev = node;
    node->next = next2;
    next2 = node;
    node = new SimpleList( "oriented_path" );
    next9 = node;
    node = new SimpleList( "edge_loop" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next8 = node;
    node = new SimpleList( "path" );
    next8->prev = node;
    node->next = next8;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "path" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "poly_loop" );
    next9 = node;
    node = new SimpleList( "edge_loop" );
    next9->prev = node;
    node->next = next9;
    next9 = node;
    node = new SimpleList( "vertex_loop" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next8 = node;
    node = new SimpleList( "loop" );
    next8->prev = node;
    node->next = next8;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "loop" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next5 = node;
    node = new SimpleList( "oriented_open_shell" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next10 = node;
    node = new SimpleList( "open_shell" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next9 = node;
    node = new SimpleList( "open_shell" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next8 = node;
    node = new SimpleList( "oriented_closed_shell" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next10 = node;
    node = new SimpleList( "closed_shell" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next9 = node;
    node = new SimpleList( "closed_shell" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next8->prev = node;
    node->next = next8;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "connected_face_set" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "connected_face_set" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "connected_edge_set" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "wire_shell" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "vertex_shell" );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "oriented_face" );
    next8 = node;
    node = new SimpleList( "advanced_face" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next10 = node;
    node = new SimpleList( "face_surface" );
    next10->prev = node;
    node->next = next10;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next9 = node;
    node = new SimpleList( "face_surface" );
    next9->prev = node;
    node->next = next9;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next8->prev = node;
    node->next = next8;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "face" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "face" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "face_outer_bound" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "face_bound" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "face_bound" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "oriented_edge" );
    next8 = node;
    node = new SimpleList( "edge_curve" );
    next8->prev = node;
    node->next = next8;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "edge" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "edge" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    next5 = node;
    node = new SimpleList( "vertex_point" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next7 = node;
    node = new SimpleList( "vertex" );
    next7->prev = node;
    node->next = next7;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next6 = node;
    node = new SimpleList( "vertex" );
    next6->prev = node;
    node->next = next6;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next5->prev = node;
    node->next = next5;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next4 = node;
    node = new SimpleList( "topological_representation_item" );
    next4->prev = node;
    node->next = next4;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    next3 = node;
    node = new SimpleList( "topological_representation_item" );
    next3->prev = node;
    node->next = next3;
    child = node;
    node = new OrList;
    ((MultList *)node)->appendList( child );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "representation_item" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "representation_relationship":
    node = new SimpleList( "shape_representation_relationship" );
    next2 = node;
    node = new SimpleList( "representation_relationship_with_transformation" );
    next2->prev = node;
    node->next = next2;
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "representation_relationship" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    // ComplexList with supertype "security_classification_assignment":
    node = new SimpleList( "cc_design_security_classification" );
    child = node;
    node = new AndOrList;
    ((MultList *)node)->appendList( child );
    next1 = node;
    node = new SimpleList( "security_classification_assignment" );
    next1->prev = node;
    node->next = next1;
    child = node;
    node = new AndList;
    ((MultList *)node)->appendList( child );
    cl = new ComplexList((AndList *)node);
    cl->buildList();
    cl->head->setLevel( 0 );
    cc->insert( cl );

    return cc;
}
