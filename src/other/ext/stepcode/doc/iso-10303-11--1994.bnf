;; iso-10303-11:1994

  0 ABS = 'abs' .
  1 ABSTRACT = 'abstract' .
  2 ACOS = 'acos' .
  3 AGGREGATE = 'aggregate' .
  4 ALIAS = 'alias' .
  5 AND = 'and' .
  6 ANDOR = 'andor' .
  7 ARRAY = 'array' .
  8 AS = 'as' .
  9 ASIN = 'asin' .
 10 ATAN = 'atan' .
 11 BAG = 'bag' .
 12 BEGIN = 'begin' .
 13 BINARY = 'binary' .
 14 BLENGTH = 'blength' .
 15 BOOLEAN = 'boolean' .
 16 BY = 'by' .
 17 CASE = 'case' .
 18 CONSTANT = 'constant' .
 19 CONST_E = 'const_e' .
 20 CONTEXT = 'context' .
 21 COS = 'cos' .
 22 DERIVE = 'derive' .
 23 DIV = 'div' .
 24 ELSE = 'else' .
 25 END = 'end' .
 26 END_ALIAS = 'end_alias' .
 27 END_CASE = 'end_case' .
 28 END_CONSTANT = 'end_constant' .
 29 END_CONTEXT = 'end_context' .
 30 END_ENTITY = 'end_entity' .
 31 END_FUNCTION = 'end_function' .
 32 END_IF = 'end_if' .
 33 END_LOCAL = 'end_local' .
 34 END_MODEL = 'end_model' .
 35 END_PROCEDURE = 'end_procedure' .
 36 END_REPEAT = 'end_repeat' .
 37 END_RULE = 'end_rule' .
 38 END_SCHEMA = 'end_schema' .
 39 END_TYPE = 'end_type' .
 40 ENTITY = 'entity' .
 41 ENUMERATION = 'enumeration' .
 42 ESCAPE = 'escape' .
 43 EXISTS = 'exists' .
 44 EXP = 'exp' .
 45 FALSE = 'false' .
 46 FIXED = 'fixed' .
 47 FOR = 'for' .
 48 FORMAT = 'format' .
 49 FROM = 'from' .
 50 FUNCTION = 'function' .
 51 GENERIC = 'generic' .
 52 HIBOUND = 'hibound' .
 53 HIINDEX = 'hiindex' .
 54 IF = 'if' .
 55 IN = 'in' .
 56 INSERT = 'insert' .
 57 INTEGER = 'integer' .
 58 INVERSE = 'inverse' .
 59 LENGTH = 'length' .
 60 LIKE = 'like' .
 61 LIST = 'list' .
 62 LOBOUND = 'lobound' .
 63 LOCAL = 'local' .
 64 LOG = 'log' .
 65 LOG10 = 'log10' .
 66 LOG2 = 'log2' .
 67 LOGICAL = 'logical' .
 68 LOINDEX = 'loindex' .
 69 MOD = 'mod' .
 70 MODEL = 'model' .
 71 NOT = 'not' .
 72 NUMBER = 'number' .
 73 NVL = 'nvl' .
 74 ODD = 'odd' .
 75 OF = 'of' .
 76 ONEOF = 'oneof' .
 77 OPTIONAL = 'optional' .
 78 OR = 'or' .
 79 OTHERWISE = 'otherwise' .
 80 PI = 'pi' .
 81 PROCEDURE = 'procedure' .
 82 QUERY = 'query' .
 83 REAL = 'real' .
 84 REFERENCE = 'reference' .
 85 REMOVE = 'remove' .
 86 REPEAT = 'repeat' .
 87 RETURN = 'return' .
 88 ROLESOF = 'rolesof' .
 89 RULE = 'rule' .
 90 SCHEMA = 'schema' .
 91 SELECT = 'select' .
 92 SELF = 'self' .
 93 SET = 'set' .
 94 SIN = 'sin' .
 95 SIZEOF = 'sizeof' .
 96 SKIP = 'skip' .
 97 SQRT = 'sqrt' .
 98 STRING = 'string' .
 99 SUBTYPE = 'subtype' .
100 SUPERTYPE = 'supertype' .
101 TAN = 'tan' .
102 THEN = 'then' .
103 TO = 'to' .
104 TRUE = 'true' .
105 TYPE = 'type' .
106 TYPEOF = 'typeof' .
107 UNIQUE = 'unique' .
108 UNKNOWN = 'unknown' .
109 UNTIL = 'until' .
110 USE = 'use' .
111 USEDIN = 'usedin' .
112 VALUE = 'value' .
113 VALUE_IN = 'value_in' .
114 VALUE_UNIQUE = 'value_unique' .
115 VAR = 'var' .
116 WHERE = 'where' .
117 WHILE = 'while' .
118 XOR = 'xor' .
119 bit = '0' | '1' .
120 digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .
121 digits = digit { digit } .
122 encoded_character = octet octet octet octet .
123 hex_digit = digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' .
124 letter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' .
125 lparen_not_star = '(' not_star .
126 not_lparen_star = not_paren_star | ')' .
127 not_paren_star = letter | digit | not_paren_star_special .
128 not_paren_star_quote_special = '!' | '"' | '#' | '$' | '%' | '&' | '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | '[' | '\' | ']' | '^' | '_' | '`' | '{' | '|' | '}' | '~' .
129 not_paren_star_special = not_paren_star_quote_special | '''' .
130 not_quote = not_paren_star_quote_special | letter | digit | '(' | ')' | '*' .
131 not_rparen = not_paren_star | '*' | '(' .
132 not_star = not_paren_star | '(' | ')' .
133 octet = hex_digit hex_digit .
134 special = not_paren_star_quote_special | '(' | ')' | '*' | '''' .
135 star_not_rparen = '*' not_rparen .
136 binary_literal = '%' bit { bit } .
137 encoded_string_literal = '"' encoded_character { encoded_character } '"' .
138 integer_literal = digits .
139 real_literal = digits '.' [ digits ] [ 'e' [ sign ] digits ] .
140 simple_id = letter { letter | digit | '_' } .
141 simple_string_literal = \q { ( \q \q ) | not_quote | \s | \o } \q .
142 embedded_remark = '(*' { not_lparen_star | lparen_not_star | star_not_rparen | embedded_remark } '*)' .
143 remark = embedded_remark | tail_remark .
144 tail_remark = '--' { \a | \s | \o } \n .
145 attribute_ref = attribute_id .
146 constant_ref = constant_id .
147 entity_ref = entity_id .
148 enumeration_ref = enumeration_id .
149 function_ref = function_id .
150 parameter_ref = parameter_id .
151 procedure_ref = procedure_id .
152 schema_ref = schema_id .
153 type_label_ref = type_label_id .
154 type_ref = type_id .
155 variable_ref = variable_id .
156 abstract_supertype_declaration = ABSTRACT SUPERTYPE [ subtype_constraint ] .
157 actual_parameter_list = '(' parameter { ',' parameter } ')' .
158 add_like_op = '+' | '-' | OR | XOR .
159 aggregate_initializer = '[' [ element { ',' element } ] ']' .
160 aggregate_source = simple_expression .
161 aggregate_type = AGGREGATE [ ':' type_label ] OF parameter_type .
162 aggregation_types = array_type | bag_type | list_type | set_type .
163 algorithm_head = { declaration } [ constant_decl ] [ local_decl ] .
164 alias_stmt = ALIAS variable_id FOR general_ref { qualifier } ';' stmt { stmt } END_ALIAS ';' .
165 array_type = ARRAY bound_spec OF [ OPTIONAL ] [ UNIQUE ] base_type .
166 assignment_stmt = general_ref { qualifier } ':=' expression ';' .
167 attribute_decl = attribute_id | qualified_attribute .
168 attribute_id = simple_id .
169 attribute_qualifier = '.' attribute_ref .
170 bag_type = BAG [ bound_spec ] OF base_type .
171 base_type = aggregation_types | simple_types | named_types .
172 binary_type = BINARY [ width_spec ] .
173 boolean_type = BOOLEAN .
174 bound_1 = numeric_expression .
175 bound_2 = numeric_expression .
176 bound_spec = '[' bound_1 ':' bound_2 ']' .
177 built_in_constant = CONST_E | PI | SELF | '?' .
178 built_in_function = ABS | ACOS | ASIN | ATAN | BLENGTH | COS | EXISTS | EXP | FORMAT | HIBOUND | HIINDEX | LENGTH | LOBOUND | LOINDEX | LOG | LOG2 | LOG10 | NVL | ODD | ROLESOF | SIN | SIZEOF | SQRT | TAN | TYPEOF | USEDIN | VALUE | VALUE_IN | VALUE_UNIQUE .
179 built_in_procedure = INSERT | REMOVE .
180 case_action = case_label { ',' case_label } ':' stmt .
181 case_label = expression .
182 case_stmt = CASE selector OF { case_action } [ OTHERWISE ':' stmt ] END_CASE ';' .
183 compound_stmt = BEGIN stmt { stmt } END ';' .
184 constant_body = constant_id ':' base_type ':=' expression ';' .
185 constant_decl = CONSTANT constant_body { constant_body } END_CONSTANT ';' .
186 constant_factor = built_in_constant | constant_ref .
187 constant_id = simple_id .
188 constructed_types = enumeration_type | select_type .
189 declaration = entity_decl | function_decl | procedure_decl | type_decl .
190 derived_attr = attribute_decl ':' base_type ':=' expression ';' .
191 derive_clause = DERIVE derived_attr { derived_attr } .
192 domain_rule = [ label ':' ] logical_expression .
193 element = expression [ ':' repetition ] .
194 entity_body = { explicit_attr } [ derive_clause ] [ inverse_clause ] [ unique_clause ] [ where_clause ] .
195 entity_constructor = entity_ref '(' [ expression { ',' expression } ] ')' .
196 entity_decl = entity_head entity_body END_ENTITY ';' .
197 entity_head = ENTITY entity_id [ subsuper ] ';' .
198 entity_id = simple_id .
199 enumeration_id = simple_id .
200 enumeration_reference = [ type_ref '.' ] enumeration_ref .
201 enumeration_type = ENUMERATION OF '(' enumeration_id { ',' enumeration_id } ')' .
202 escape_stmt = ESCAPE ';' .
203 explicit_attr = attribute_decl { ',' attribute_decl } ':' [ OPTIONAL ] base_type ';' .
204 expression = simple_expression [ rel_op_extended simple_expression ] .
205 factor = simple_factor [ '**' simple_factor ] .
206 formal_parameter = parameter_id { ',' parameter_id } ':' parameter_type .
207 function_call = ( built_in_function | function_ref ) [ actual_parameter_list ] .
208 function_decl = function_head [ algorithm_head ] stmt { stmt } END_FUNCTION ';' .
209 function_head = FUNCTION function_id [ '(' formal_parameter { ';' formal_parameter } ')' ] ':' parameter_type ';' .
210 function_id = simple_id .
211 generalized_types = aggregate_type | general_aggregation_types | generic_type .
212 general_aggregation_types = general_array_type | general_bag_type | general_list_type | general_set_type .
213 general_array_type = ARRAY [ bound_spec ] OF [ OPTIONAL ] [ UNIQUE ] parameter_type .
214 general_bag_type = BAG [ bound_spec ] OF parameter_type .
215 general_list_type = LIST [ bound_spec ] OF [ UNIQUE ] parameter_type .
216 general_ref = parameter_ref | variable_ref .
217 general_set_type = SET [ bound_spec ] OF parameter_type .
218 generic_type = GENERIC [ ':' type_label ] .
219 group_qualifier = '\' entity_ref .
220 if_stmt = IF logical_expression THEN stmt { stmt } [ ELSE stmt { stmt } ] END_IF ';' .
221 increment = numeric_expression .
222 increment_control = variable_id ':=' bound_1 TO bound_2 [ BY increment ] .
223 index = numeric_expression .
224 index_1 = index .
225 index_2 = index .
226 index_qualifier = '[' index_1 [ ':' index_2 ] ']' .
227 integer_type = INTEGER .
228 interface_specification = reference_clause | use_clause .
229 interval = '{' interval_low interval_op interval_item interval_op interval_high '}' .
230 interval_high = simple_expression .
231 interval_item = simple_expression .
232 interval_low = simple_expression .
233 interval_op = '<' | '<=' .
234 inverse_attr = attribute_decl ':' [ ( SET | BAG ) [ bound_spec ] OF ] entity_ref FOR attribute_ref ';' .
235 inverse_clause = INVERSE inverse_attr { inverse_attr } .
236 label = simple_id .
237 list_type = LIST [ bound_spec ] OF [ UNIQUE ] base_type .
238 literal = binary_literal | integer_literal | logical_literal | real_literal | string_literal .
239 local_decl = LOCAL local_variable { local_variable } END_LOCAL ';' .
240 local_variable = variable_id { ',' variable_id } ':' parameter_type [ ':=' expression ] ';' .
241 logical_expression = expression .
242 logical_literal = FALSE | TRUE | UNKNOWN .
243 logical_type = LOGICAL .
244 multiplication_like_op = '*' | '/' | DIV | MOD | AND | '||' .
245 named_types = entity_ref | type_ref .
246 named_type_or_rename = named_types [ AS ( entity_id | type_id ) ] .
247 null_stmt = ';' .
248 number_type = NUMBER .
249 numeric_expression = simple_expression .
250 one_of = ONEOF '(' supertype_expression { ',' supertype_expression } ')' .
251 parameter = expression .
252 parameter_id = simple_id .
253 parameter_type = generalized_types | named_types | simple_types .
254 population = entity_ref .
255 precision_spec = numeric_expression .
256 primary = literal | ( qualifiable_factor { qualifier } ) .
257 procedure_call_stmt = ( built_in_procedure | procedure_ref ) [ actual_parameter_list ] ';' .
258 procedure_decl = procedure_head [ algorithm_head ] { stmt } END_PROCEDURE ';' .
259 procedure_head = PROCEDURE procedure_id [ '(' [ VAR ] formal_parameter { ';' [ VAR ] formal_parameter } ')' ] ';' .
260 procedure_id = simple_id .
261 qualifiable_factor = attribute_ref | constant_factor | function_call | general_ref | population .
262 qualified_attribute = SELF group_qualifier attribute_qualifier .
263 qualifier = attribute_qualifier | group_qualifier | index_qualifier .
264 query_expression = QUERY '(' variable_id '<*' aggregate_source '|' logical_expression ')' .
265 real_type = REAL [ '(' precision_spec ')' ] .
266 referenced_attribute = attribute_ref | qualified_attribute .
267 reference_clause = REFERENCE FROM schema_ref [ '(' resource_or_rename { ',' resource_or_rename } ')' ] ';' .
268 rel_op = '<' | '>' | '<=' | '>=' | '<>' | '=' | ':<>:' | ':=:' .
269 rel_op_extended = rel_op | IN | LIKE .
270 rename_id = constant_id | entity_id | function_id | procedure_id | type_id .
271 repeat_control = [ increment_control ] [ while_control ] [ until_control ] .
272 repeat_stmt = REPEAT repeat_control ';' stmt { stmt } END_REPEAT ';' .
273 repetition = numeric_expression .
274 resource_or_rename = resource_ref [ AS rename_id ] .
275 resource_ref = constant_ref | entity_ref | function_ref | procedure_ref | type_ref .
276 return_stmt = RETURN [ '(' expression ')' ] ';' .
277 rule_decl = rule_head [ algorithm_head ] { stmt } where_clause END_RULE ';' .
278 rule_head = RULE rule_id FOR '(' entity_ref { ',' entity_ref } ')' ';' .
279 rule_id = simple_id .
280 schema_body = { interface_specification } [ constant_decl ] { declaration | rule_decl } .
281 schema_decl = SCHEMA schema_id ';' schema_body END_SCHEMA ';' .
282 schema_id = simple_id .
283 selector = expression .
284 select_type = SELECT '(' named_types { ',' named_types } ')' .
285 set_type = SET [ bound_spec ] OF base_type .
286 sign = '+' | '-' .
287 simple_expression = term { add_like_op term } .
288 simple_factor = aggregate_initializer | entity_constructor | enumeration_reference | interval | query_expression | ( [ unary_op ] ( '(' expression ')' | primary ) ) .
289 simple_types = binary_type | boolean_type | integer_type | logical_type | number_type | real_type | string_type .
290 skip_stmt = SKIP ';' .
291 stmt = alias_stmt | assignment_stmt | case_stmt | compound_stmt | escape_stmt | if_stmt | null_stmt | procedure_call_stmt | repeat_stmt | return_stmt | skip_stmt .
292 string_literal = simple_string_literal | encoded_string_literal .
293 string_type = STRING [ width_spec ] .
294 subsuper = [ supertype_constraint ] [ subtype_declaration ] .
295 subtype_constraint = OF '(' supertype_expression ')' .
296 subtype_declaration = SUBTYPE OF '(' entity_ref { ',' entity_ref } ')' .
297 supertype_constraint = abstract_supertype_declaration | supertype_rule .
298 supertype_expression = supertype_factor { ANDOR supertype_factor } .
299 supertype_factor = supertype_term { AND supertype_term } .
300 supertype_rule = SUPERTYPE subtype_constraint .
301 supertype_term = entity_ref | one_of | '(' supertype_expression ')' .
302 syntax = schema_decl { schema_decl } .
303 term = factor { multiplication_like_op factor } .
304 type_decl = TYPE type_id '=' underlying_type ';' [ where_clause ] END_TYPE ';' .
305 type_id = simple_id .
306 type_label = type_label_id | type_label_ref .
307 type_label_id = simple_id .
308 unary_op = '+' | '-' | NOT .
309 underlying_type = constructed_types | aggregation_types | simple_types | type_ref .
310 unique_clause = UNIQUE unique_rule ';' { unique_rule ';' } .
311 unique_rule = [ label ':' ] referenced_attribute { ',' referenced_attribute } .
312 until_control = UNTIL logical_expression .
313 use_clause = USE FROM schema_ref [ '(' named_type_or_rename { ',' named_type_or_rename } ')' ] ';' .
314 variable_id = simple_id .
315 where_clause = WHERE domain_rule ';' { domain_rule ';' } .
316 while_control = WHILE logical_expression .
317 width = numeric_expression .
318 width_spec = '(' width ')' [ FIXED ] .
