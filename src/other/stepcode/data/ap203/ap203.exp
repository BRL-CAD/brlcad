(* This is a MODIFIED version of AP203 Amd. 1.
   The change was to remove a useless IF...ELSE...ENDIF statement that always evaluated
   the same way. Statements in the branch that were never executed caused problems with
   libexpress, and it was easier to modify the schema than to come up with a generic
   fix for libexpress. This change does *not* affect the behavior of the schema.

   Based on:
   AIM long form for ISO 10303-203 amendment 1
   ISO TC184/SC4/WG3 N916
   Larry McKee
   2000-05-04
*)

SCHEMA config_control_design;

  CONSTANT
(* FIXME: gcc error on next statement with c99/POSIX:
     Syntax error: "(" unexpected
*)
  dummy_gri : geometric_representation_item := representation_item('') ||
                 geometric_representation_item();
  dummy_tri : topological_representation_item := representation_item('')
                 || topological_representation_item();
  END_CONSTANT;

  TYPE ahead_or_behind = ENUMERATION OF
    (ahead,
     behind);
  END_TYPE; -- ahead_or_behind

  TYPE approved_item = SELECT
    (product_definition_formation,
     product_definition,
     configuration_effectivity,
     configuration_item,
     security_classification,
     change_request,
     change,
     start_request,
     start_work,
     certification,
     contract);
  END_TYPE; -- approved_item

  TYPE area_measure = REAL;
  END_TYPE; -- area_measure

  TYPE axis2_placement = SELECT
    (axis2_placement_2d,
     axis2_placement_3d);
  END_TYPE; -- axis2_placement

  TYPE b_spline_curve_form = ENUMERATION OF
    (polyline_form,
     circular_arc,
     elliptic_arc,
     parabolic_arc,
     hyperbolic_arc,
     unspecified);
  END_TYPE; -- b_spline_curve_form

  TYPE b_spline_surface_form = ENUMERATION OF
    (plane_surf,
     cylindrical_surf,
     conical_surf,
     spherical_surf,
     toroidal_surf,
     surf_of_revolution,
     ruled_surf,
     generalised_cone,
     quadric_surf,
     surf_of_linear_extrusion,
     unspecified);
  END_TYPE; -- b_spline_surface_form

  TYPE boolean_operand = SELECT
    (solid_model);
  END_TYPE; -- boolean_operand

  TYPE certified_item = SELECT
    (supplied_part_relationship);
  END_TYPE; -- certified_item

  TYPE change_request_item = SELECT
    (product_definition_formation);
  END_TYPE; -- change_request_item

  TYPE characterized_definition = SELECT
    (characterized_product_definition,
     shape_definition);
  END_TYPE; -- characterized_definition

  TYPE characterized_product_definition = SELECT
    (product_definition,
     product_definition_relationship);
  END_TYPE; -- characterized_product_definition

  TYPE classified_item = SELECT
    (product_definition_formation,
     assembly_component_usage);
  END_TYPE; -- classified_item

  TYPE context_dependent_measure = REAL;
  END_TYPE; -- context_dependent_measure

  TYPE contracted_item = SELECT
    (product_definition_formation);
  END_TYPE; -- contracted_item

  TYPE count_measure = NUMBER;
  END_TYPE; -- count_measure

  TYPE curve_on_surface = SELECT
    (pcurve,
     surface_curve,
     composite_curve_on_surface);
  END_TYPE; -- curve_on_surface

  TYPE date_time_item = SELECT
    (product_definition,
     change_request,
     start_request,
     change,
     start_work,
     approval_person_organization,
     contract,
     security_classification,
     certification);
  END_TYPE; -- date_time_item

  TYPE date_time_select = SELECT
    (date,
     local_time,
     date_and_time);
  END_TYPE; -- date_time_select

  TYPE day_in_month_number = INTEGER;
  END_TYPE; -- day_in_month_number

  TYPE day_in_week_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 7));
  END_TYPE; -- day_in_week_number

  TYPE day_in_year_number = INTEGER;
  END_TYPE; -- day_in_year_number

  TYPE descriptive_measure = STRING;
  END_TYPE; -- descriptive_measure

  TYPE dimension_count = INTEGER;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- dimension_count

  TYPE founded_item_select = SELECT
    (founded_item,
     representation_item);
  END_TYPE; -- founded_item_select

  TYPE geometric_set_select = SELECT
    (point,
     curve,
     surface);
  END_TYPE; -- geometric_set_select

  TYPE hour_in_day = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF < 24));
  END_TYPE; -- hour_in_day

  TYPE identifier = STRING;
  END_TYPE; -- identifier

  TYPE knot_type = ENUMERATION OF
    (uniform_knots,
     unspecified,
     quasi_uniform_knots,
     piecewise_bezier_knots);
  END_TYPE; -- knot_type

  TYPE label = STRING;
  END_TYPE; -- label

  TYPE length_measure = REAL;
  END_TYPE; -- length_measure

  TYPE list_of_reversible_topology_item = LIST [0:?] OF
              reversible_topology_item;
  END_TYPE; -- list_of_reversible_topology_item

  TYPE mass_measure = REAL;
  END_TYPE; -- mass_measure

  TYPE measure_value = SELECT
    (length_measure,
     mass_measure,
     plane_angle_measure,
     solid_angle_measure,
     area_measure,
     volume_measure,
     parameter_value,
     context_dependent_measure,
     descriptive_measure,
     positive_length_measure,
     positive_plane_angle_measure,
     count_measure);
  END_TYPE; -- measure_value

  TYPE minute_in_hour = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 59));
  END_TYPE; -- minute_in_hour

  TYPE month_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 12));
  END_TYPE; -- month_in_year_number

  TYPE parameter_value = REAL;
  END_TYPE; -- parameter_value

  TYPE pcurve_or_surface = SELECT
    (pcurve,
     surface);
  END_TYPE; -- pcurve_or_surface

  TYPE person_organization_item = SELECT
    (change,
     start_work,
     change_request,
     start_request,
     configuration_item,
     product,
     product_definition_formation,
     product_definition,
     contract,
     security_classification);
  END_TYPE; -- person_organization_item

  TYPE person_organization_select = SELECT
    (person,
     organization,
     person_and_organization);
  END_TYPE; -- person_organization_select

  TYPE plane_angle_measure = REAL;
  END_TYPE; -- plane_angle_measure

  TYPE positive_length_measure = length_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_length_measure

  TYPE positive_plane_angle_measure = plane_angle_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_plane_angle_measure

  TYPE preferred_surface_curve_representation = ENUMERATION OF
    (curve_3d,
     pcurve_s1,
     pcurve_s2);
  END_TYPE; -- preferred_surface_curve_representation

  TYPE reversible_topology = SELECT
    (reversible_topology_item,
     list_of_reversible_topology_item,
     set_of_reversible_topology_item);
  END_TYPE; -- reversible_topology

  TYPE reversible_topology_item = SELECT
    (edge,
     path,
     face,
     face_bound,
     closed_shell,
     open_shell);
  END_TYPE; -- reversible_topology_item

  TYPE second_in_minute = REAL;
  WHERE
    wr1: ((0 <= SELF) AND (SELF < 60));
  END_TYPE; -- second_in_minute

  TYPE set_of_reversible_topology_item = SET [0:?] OF
              reversible_topology_item;
  END_TYPE; -- set_of_reversible_topology_item

  TYPE shape_definition = SELECT
    (product_definition_shape,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE; -- shape_definition

  TYPE shell = SELECT
    (vertex_shell,
     wire_shell,
     open_shell,
     closed_shell);
  END_TYPE; -- shell

  TYPE si_prefix = ENUMERATION OF
    (exa,
     peta,
     tera,
     giga,
     mega,
     kilo,
     hecto,
     deca,
     deci,
     centi,
     milli,
     micro,
     nano,
     pico,
     femto,
     atto);
  END_TYPE; -- si_prefix

  TYPE si_unit_name = ENUMERATION OF
    (metre,
     gram,
     second,
     ampere,
     kelvin,
     mole,
     candela,
     radian,
     steradian,
     hertz,
     newton,
     pascal,
     joule,
     watt,
     coulomb,
     volt,
     farad,
     ohm,
     siemens,
     weber,
     tesla,
     henry,
     degree_celsius,
     lumen,
     lux,
     becquerel,
     gray,
     sievert);
  END_TYPE; -- si_unit_name

  TYPE solid_angle_measure = REAL;
  END_TYPE; -- solid_angle_measure

  TYPE source = ENUMERATION OF
    (made,
     bought,
     not_known);
  END_TYPE; -- source

  TYPE specified_item = SELECT
    (product_definition,
     shape_aspect);
  END_TYPE; -- specified_item

  TYPE start_request_item = SELECT
    (product_definition_formation);
  END_TYPE; -- start_request_item

  TYPE supported_item = SELECT
    (action_directive,
     action,
     action_method);
  END_TYPE; -- supported_item

  TYPE surface_model = SELECT
    (shell_based_surface_model);
  END_TYPE; -- surface_model

  TYPE text = STRING;
  END_TYPE; -- text

  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation);
  END_TYPE; -- transformation

  TYPE transition_code = ENUMERATION OF
    (discontinuous,
     continuous,
     cont_same_gradient,
     cont_same_gradient_same_curvature);
  END_TYPE; -- transition_code

  TYPE trimming_preference = ENUMERATION OF
    (cartesian,
     parameter,
     unspecified);
  END_TYPE; -- trimming_preference

  TYPE trimming_select = SELECT
    (cartesian_point,
     parameter_value);
  END_TYPE; -- trimming_select

  TYPE unit = SELECT
    (named_unit);
  END_TYPE; -- unit

  TYPE vector_or_direction = SELECT
    (vector,
     direction);
  END_TYPE; -- vector_or_direction

  TYPE volume_measure = REAL;
  END_TYPE; -- volume_measure

  TYPE week_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 53));
  END_TYPE; -- week_in_year_number

  TYPE wireframe_model = SELECT
    (shell_based_wireframe_model,
     edge_based_wireframe_model);
  END_TYPE; -- wireframe_model

  TYPE work_item = SELECT
    (product_definition_formation);
  END_TYPE; -- work_item

  TYPE year_number = INTEGER;
  END_TYPE; -- year_number

  ENTITY action;
      name          : label;
      description   : text;
      chosen_method : action_method;
  END_ENTITY; -- action

  ENTITY action_assignment
    ABSTRACT SUPERTYPE;
      assigned_action : action;
  END_ENTITY; -- action_assignment

  ENTITY action_directive;
      name        : label;
      description : text;
      analysis    : text;
      comment     : text;
      requests    : SET [1:?] OF versioned_action_request;
  END_ENTITY; -- action_directive

  ENTITY action_method;
      name        : label;
      description : text;
      consequence : text;
      purpose     : text;
  END_ENTITY; -- action_method

  ENTITY action_request_assignment
    ABSTRACT SUPERTYPE;
      assigned_action_request : versioned_action_request;
  END_ENTITY; -- action_request_assignment

  ENTITY action_request_solution;
      method  : action_method;
      request : versioned_action_request;
  END_ENTITY; -- action_request_solution

  ENTITY action_request_status;
      status           : label;
      assigned_request : versioned_action_request;
  END_ENTITY; -- action_request_status

  ENTITY action_status;
      status          : label;
      assigned_action : executed_action;
  END_ENTITY; -- action_status

  ENTITY address;
      internal_location       : OPTIONAL label;
      street_number           : OPTIONAL label;
      street                  : OPTIONAL label;
      postal_box              : OPTIONAL label;
      town                    : OPTIONAL label;
      region                  : OPTIONAL label;
      postal_code             : OPTIONAL label;
      country                 : OPTIONAL label;
      facsimile_number        : OPTIONAL label;
      telephone_number        : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number            : OPTIONAL label;
    WHERE
      wr1: (EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(
               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(
               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(
               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(
               electronic_mail_address) OR EXISTS(telex_number));
  END_ENTITY; -- address

  ENTITY advanced_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP',
               'CONFIG_CONTROL_DESIGN.FACETED_BREP',
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
               1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP',
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) >
                0);
      wr3: (SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (
               SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
               NOT ('CONFIG_CONTROL_DESIGN.ADVANCED_FACE'
               IN TYPEOF(fcs))) )) = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( msb <* QUERY ( it <* items | (
               'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | ('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(
               msb\manifold_solid_brep.outer)) )) = 0);
      wr5: (SIZEOF(QUERY ( brv <* QUERY ( it <* items | (
               'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids | csh\
               oriented_closed_shell.orientation )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( mi <* QUERY ( it <* items | (
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT
               ('CONFIG_CONTROL_DESIGN.ADVANCED_BREP_SHAPE_REPRESENTATION'
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0);
  END_ENTITY; -- advanced_brep_shape_representation

  ENTITY advanced_face
    SUBTYPE OF (face_surface);
    WHERE
      wr1 : (SIZEOF(['CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE',
                'CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE',
                'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'] * TYPEOF(
                face_geometry)) = 1);
      wr2 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN
                TYPEOF(oe\oriented_edge.edge_element))) )) = 0)) )) = 0);
      wr3 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',
                'CONFIG_CONTROL_DESIGN.CONIC',
                'CONFIG_CONTROL_DESIGN.POLYLINE',
                'CONFIG_CONTROL_DESIGN.SURFACE_CURVE',
                'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] * TYPEOF(oe.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0);
      wr4 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN
                TYPEOF(oe\edge.edge_start)) AND (
                'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(oe\edge.
                edge_start\vertex_point.vertex_geometry)) AND (
                'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(oe\edge.
                edge_end)) AND ('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN
                TYPEOF(oe\edge.edge_end\vertex_point.vertex_geometry)))) ))
                = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF(
                elp_fbnds.bound)) )) = 0);
      wr6 : ((NOT ('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',
                'CONFIG_CONTROL_DESIGN.CONIC',
                'CONFIG_CONTROL_DESIGN.POLYLINE',
                'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] * TYPEOF(
                face_geometry\swept_surface.swept_curve)) = 1));
      wr7 : (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* bounds | (
                'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'
                IN TYPEOF(bnds.bound)) )
                 | (NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND (
                'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds
                \face_bound.bound\vertex_loop.loop_vertex\vertex_point.
                vertex_geometry)))) )) = 0);
      wr8 : (SIZEOF(QUERY ( bnd <* bounds | (NOT (SIZEOF([
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP',
                'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'] * TYPEOF(bnd.bound)) =
                 1)) )) = 0);
      wr9 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (('CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN
                TYPEOF(oe\oriented_edge.edge_element\edge_curve.
                edge_geometry)) AND (NOT (SIZEOF(QUERY ( sc_ag <* oe.
                edge_element\edge_curve.edge_geometry\surface_curve.
                associated_geometry | (NOT ('CONFIG_CONTROL_DESIGN.PCURVE'
                IN TYPEOF(sc_ag))) )) = 0))) )) = 0)) )) = 0);
      wr10: (((NOT ('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (NOT ('CONFIG_CONTROL_DESIGN.POLYLINE'
                IN TYPEOF(face_geometry\swept_surface.swept_curve))) OR (
                SIZEOF(face_geometry\swept_surface.swept_curve\polyline.
                points) >= 3)) AND (SIZEOF(QUERY ( elp_fbnds <*
                QUERY ( bnds <* bounds | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP'
                IN TYPEOF(bnds.bound)) ) | (NOT (SIZEOF(QUERY ( oe <*
                elp_fbnds.bound\path.edge_list | ((
                'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(oe\oriented_edge
                .edge_element\edge_curve.edge_geometry)) AND (NOT (SIZEOF(
                oe\oriented_edge.edge_element\edge_curve.edge_geometry\
                polyline.points) >= 3))) )) = 0)) )) = 0));
  END_ENTITY; -- advanced_face

  ENTITY alternate_product_relationship;
      name       : label;
      definition : text;
      alternate  : product;
      base       : product;
      basis      : text;
    UNIQUE
      ur1 : alternate, base;
    WHERE
      wr1: (alternate :<>: base);
  END_ENTITY; -- alternate_product_relationship

  ENTITY application_context;
      application : text;
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR
                            frame_of_reference;
  END_ENTITY; -- application_context

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (product_context,product_definition_context,
        product_concept_context));
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY; -- application_context_element

  ENTITY application_protocol_definition;
      status                                    : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year                 : year_number;
      application                               : application_context;
  END_ENTITY; -- application_protocol_definition

  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY; -- approval

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
      assigned_approval : approval;
  END_ENTITY; -- approval_assignment

  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
  END_ENTITY; -- approval_date_time

  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY; -- approval_person_organization

  ENTITY approval_relationship;
      name              : label;
      description       : text;
      relating_approval : approval;
      related_approval  : approval;
  END_ENTITY; -- approval_relationship

  ENTITY approval_role;
      role : label;
  END_ENTITY; -- approval_role

  ENTITY approval_status;
      name : label;
  END_ENTITY; -- approval_status

  ENTITY area_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.AREA_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- area_measure_with_unit

  ENTITY area_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 2) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- area_unit

  ENTITY assembly_component_usage
    SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence,
        specified_higher_usage_occurrence,promissory_usage_occurrence))
    SUBTYPE OF (product_definition_usage);
      reference_designator : OPTIONAL identifier;
  END_ENTITY; -- assembly_component_usage

  ENTITY assembly_component_usage_substitute;
      name       : label;
      definition : text;
      base       : assembly_component_usage;
      substitute : assembly_component_usage;
    UNIQUE
      ur1 : base, substitute;
    WHERE
      wr1: (base.relating_product_definition :=: substitute.
               relating_product_definition);
      wr2: (base :<>: substitute);
  END_ENTITY; -- assembly_component_usage_substitute

  ENTITY axis1_placement
    SUBTYPE OF (placement);
      axis : OPTIONAL direction;
    DERIVE
      z : direction := NVL(normalise(axis),dummy_gri ||
             direction([0,0,1]));
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- axis1_placement

  ENTITY axis2_placement_2d
    SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- axis2_placement_2d

  ENTITY axis2_placement_3d
    SUBTYPE OF (placement);
      axis          : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
    WHERE
      wr1: (SELF\placement.location.dim = 3);
      wr2: ((NOT EXISTS(axis)) OR (axis.dim = 3));
      wr3: ((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3));
      wr4: ((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (
               cross_product(axis,ref_direction).magnitude > 0));
  END_ENTITY; -- axis2_placement_3d

  ENTITY b_spline_curve
    SUPERTYPE OF (ONEOF (uniform_curve,b_spline_curve_with_knots,
        quasi_uniform_curve,bezier_curve) ANDOR rational_b_spline_curve)
    SUBTYPE OF (bounded_curve);
      degree              : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form          : b_spline_curve_form;
      closed_curve        : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(
                                         control_points_list) - 1;
      control_points                : ARRAY [0:
                                         upper_index_on_control_points] OF
                                          cartesian_point := list_to_array(
                                         control_points_list,0,
                                         upper_index_on_control_points);
    WHERE
      wr1: (('CONFIG_CONTROL_DESIGN.UNIFORM_CURVE' IN TYPEOF(SELF)) OR (
               'CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF))
               OR ('CONFIG_CONTROL_DESIGN.BEZIER_CURVE' IN TYPEOF(SELF)) OR
                ('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE_WITH_KNOTS' IN
               TYPEOF(SELF)));
  END_ENTITY; -- b_spline_curve

  ENTITY b_spline_curve_with_knots
    SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots               : LIST [2:?] OF parameter_value;
      knot_spec           : knot_type;
    DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
    WHERE
      wr1: constraints_param_b_spline(degree,upper_index_on_knots,
               upper_index_on_control_points,knot_multiplicities,knots);
      wr2: (SIZEOF(knot_multiplicities) = upper_index_on_knots);
  END_ENTITY; -- b_spline_curve_with_knots

  ENTITY b_spline_surface
    SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,uniform_surface,
        quasi_uniform_surface,bezier_surface) ANDOR
        rational_b_spline_surface)
    SUBTYPE OF (bounded_surface);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form        : b_spline_surface_form;
      u_closed            : LOGICAL;
      v_closed            : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      u_upper        : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF
                           cartesian_point := make_array_of_array(
                          control_points_list,0,u_upper,0,v_upper);
    WHERE
      wr1: (('CONFIG_CONTROL_DESIGN.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR (
               'CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_SURFACE' IN
               TYPEOF(SELF))
               OR ('CONFIG_CONTROL_DESIGN.BEZIER_SURFACE' IN TYPEOF(SELF))
               OR ('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS' IN
               TYPEOF(SELF)));
  END_ENTITY; -- b_spline_surface

  ENTITY b_spline_surface_with_knots
    SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      knot_spec        : knot_type;
    DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
    WHERE
      wr1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
               knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,
               u_knots);
      wr2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
               knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,
               v_knots);
      wr3: (SIZEOF(u_multiplicities) = knot_u_upper);
      wr4: (SIZEOF(v_multiplicities) = knot_v_upper);
  END_ENTITY; -- b_spline_surface_with_knots

  ENTITY bezier_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- bezier_curve

  ENTITY bezier_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- bezier_surface

  ENTITY boundary_curve
    SUBTYPE OF (composite_curve_on_surface);
    WHERE
      wr1: SELF\composite_curve.closed_curve;
  END_ENTITY; -- boundary_curve

  ENTITY bounded_curve
    SUPERTYPE OF (ONEOF (polyline,b_spline_curve,trimmed_curve,
        bounded_pcurve,bounded_surface_curve,composite_curve))
    SUBTYPE OF (curve);
  END_ENTITY; -- bounded_curve

  ENTITY bounded_pcurve
    SUBTYPE OF (pcurve, bounded_curve);
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.
               reference_to_curve.items[1]));
  END_ENTITY; -- bounded_pcurve

  ENTITY bounded_surface
    SUPERTYPE OF (ONEOF (b_spline_surface,rectangular_trimmed_surface,
        curve_bounded_surface,rectangular_composite_surface))
    SUBTYPE OF (surface);
  END_ENTITY; -- bounded_surface

  ENTITY bounded_surface_curve
    SUBTYPE OF (surface_curve, bounded_curve);
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF(SELF\
               surface_curve.curve_3d));
  END_ENTITY; -- bounded_surface_curve

  ENTITY brep_with_voids
    SUBTYPE OF (manifold_solid_brep);
      voids : SET [1:?] OF oriented_closed_shell;
  END_ENTITY; -- brep_with_voids

  ENTITY calendar_date
    SUBTYPE OF (date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      wr1: valid_calendar_date(SELF);
  END_ENTITY; -- calendar_date

  ENTITY cartesian_point
    SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
  END_ENTITY; -- cartesian_point

  ENTITY cartesian_transformation_operator
    SUPERTYPE OF (cartesian_transformation_operator_3d)
    SUBTYPE OF (geometric_representation_item,
        functionally_defined_transformation);
      axis1        : OPTIONAL direction;
      axis2        : OPTIONAL direction;
      local_origin : cartesian_point;
      scale        : OPTIONAL REAL;
    DERIVE
      scl : REAL := NVL(scale,1);
    WHERE
      wr1: (scl > 0);
  END_ENTITY; -- cartesian_transformation_operator

  ENTITY cartesian_transformation_operator_3d
    SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
    DERIVE
      u : LIST [3:3] OF direction := base_axis(3,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,axis3);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- cartesian_transformation_operator_3d

  ENTITY cc_design_approval
    SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approved_item;
  END_ENTITY; -- cc_design_approval

  ENTITY cc_design_certification
    SUBTYPE OF (certification_assignment);
      items : SET [1:?] OF certified_item;
  END_ENTITY; -- cc_design_certification

  ENTITY cc_design_contract
    SUBTYPE OF (contract_assignment);
      items : SET [1:?] OF contracted_item;
  END_ENTITY; -- cc_design_contract

  ENTITY cc_design_date_and_time_assignment
    SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_time_item;
    WHERE
      wr1: cc_design_date_time_correlation(SELF);
  END_ENTITY; -- cc_design_date_and_time_assignment

  ENTITY cc_design_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_organization_item;
    WHERE
      wr1: cc_design_person_and_organization_correlation(SELF);
  END_ENTITY; -- cc_design_person_and_organization_assignment

  ENTITY cc_design_security_classification
    SUBTYPE OF (security_classification_assignment);
      items : SET [1:?] OF classified_item;
  END_ENTITY; -- cc_design_security_classification

  ENTITY cc_design_specification_reference
    SUBTYPE OF (document_reference);
      items : SET [1:?] OF specified_item;
  END_ENTITY; -- cc_design_specification_reference

  ENTITY certification;
      name    : label;
      purpose : text;
      kind    : certification_type;
  END_ENTITY; -- certification

  ENTITY certification_assignment
    ABSTRACT SUPERTYPE;
      assigned_certification : certification;
  END_ENTITY; -- certification_assignment

  ENTITY certification_type;
      description : label;
  END_ENTITY; -- certification_type

  ENTITY change
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF work_item;
  END_ENTITY; -- change

  ENTITY change_request
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF change_request_item;
  END_ENTITY; -- change_request

  ENTITY circle
    SUBTYPE OF (conic);
      radius : positive_length_measure;
  END_ENTITY; -- circle

  ENTITY closed_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- closed_shell

  ENTITY composite_curve
    SUBTYPE OF (bounded_curve);
      segments       : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
    DERIVE
      n_segments   : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <>
                        discontinuous;
    WHERE
      wr1: (((NOT closed_curve) AND (SIZEOF(QUERY ( temp <* segments | (
               temp.transition = discontinuous) )) = 1)) OR (closed_curve
               AND (SIZEOF(QUERY ( temp <* segments | (temp.transition =
               discontinuous) )) = 0)));
  END_ENTITY; -- composite_curve

  ENTITY composite_curve_on_surface
    SUPERTYPE OF (boundary_curve)
    SUBTYPE OF (composite_curve);
    DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (SIZEOF(basis_surface) > 0);
      wr2: constraints_composite_curve_on_surface(SELF);
  END_ENTITY; -- composite_curve_on_surface

  ENTITY composite_curve_segment
    SUBTYPE OF (founded_item);
      transition   : transition_code;
      same_sense   : BOOLEAN;
      parent_curve : curve;
    INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF(parent_curve));
  END_ENTITY; -- composite_curve_segment

  ENTITY configuration_design;
      configuration : configuration_item;
      design        : product_definition_formation;
    UNIQUE
      ur1 : configuration, design;
  END_ENTITY; -- configuration_design

  ENTITY configuration_effectivity
    SUBTYPE OF (product_definition_effectivity);
      configuration : configuration_design;
    UNIQUE
      ur1 : configuration, usage, id;
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE' IN TYPEOF(
               SELF\product_definition_effectivity.usage));
  END_ENTITY; -- configuration_effectivity

  ENTITY configuration_item;
      id           : identifier;
      name         : label;
      description  : OPTIONAL text;
      item_concept : product_concept;
      purpose      : OPTIONAL label;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- configuration_item

  ENTITY conic
    SUPERTYPE OF (ONEOF (circle,ellipse,hyperbola,parabola))
    SUBTYPE OF (curve);
      position : axis2_placement;
  END_ENTITY; -- conic

  ENTITY conical_surface
    SUBTYPE OF (elementary_surface);
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: (radius >= 0);
  END_ENTITY; -- conical_surface

  ENTITY connected_edge_set
    SUBTYPE OF (topological_representation_item);
      ces_edges : SET [1:?] OF edge;
  END_ENTITY; -- connected_edge_set

  ENTITY connected_face_set
    SUPERTYPE OF (ONEOF (closed_shell,open_shell))
    SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
  END_ENTITY; -- connected_face_set

  ENTITY context_dependent_shape_representation;
      representation_relation      : shape_representation_relationship;
      represented_product_relation : product_definition_shape;
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP' IN
               TYPEOF(SELF.represented_product_relation.definition));
  END_ENTITY; -- context_dependent_shape_representation

  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
      name : label;
  END_ENTITY; -- context_dependent_unit

  ENTITY contract;
      name    : label;
      purpose : text;
      kind    : contract_type;
  END_ENTITY; -- contract

  ENTITY contract_assignment
    ABSTRACT SUPERTYPE;
      assigned_contract : contract;
  END_ENTITY; -- contract_assignment

  ENTITY contract_type;
      description : label;
  END_ENTITY; -- contract_type

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
      name              : label;
      conversion_factor : measure_with_unit;
  END_ENTITY; -- conversion_based_unit

  ENTITY coordinated_universal_time_offset;
      hour_offset   : hour_in_day;
      minute_offset : OPTIONAL minute_in_hour;
      sense         : ahead_or_behind;
  END_ENTITY; -- coordinated_universal_time_offset

  ENTITY curve
    SUPERTYPE OF (ONEOF (line,conic,pcurve,surface_curve,offset_curve_3d,
        curve_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- curve

  ENTITY curve_bounded_surface
    SUBTYPE OF (bounded_surface);
      basis_surface  : surface;
      boundaries     : SET [1:?] OF boundary_curve;
      implicit_outer : BOOLEAN;
    WHERE
      wr1: (NOT (implicit_outer AND (
               'CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(
               boundaries))));
      wr2: ((NOT implicit_outer) OR (
               'CONFIG_CONTROL_DESIGN.BOUNDED_SURFACE' IN TYPEOF(
               basis_surface)));
      wr3: (SIZEOF(QUERY ( temp <* boundaries | (
               'CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE'
               IN TYPEOF(temp)) )) <= 1);
      wr4: (SIZEOF(QUERY ( temp <* boundaries | (temp\
               composite_curve_on_surface.basis_surface[1] <> SELF.
               basis_surface) )) = 0);
  END_ENTITY; -- curve_bounded_surface

  ENTITY curve_replica
    SUBTYPE OF (curve);
      parent_curve   : curve;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_curve.dim);
      wr2: acyclic_curve_replica(SELF,parent_curve);
  END_ENTITY; -- curve_replica

  ENTITY cylindrical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- cylindrical_surface

  ENTITY date
    SUPERTYPE OF (ONEOF (calendar_date,ordinal_date,
        week_of_year_and_day_date));
      year_component : year_number;
  END_ENTITY; -- date

  ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
  END_ENTITY; -- date_and_time

  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role                   : date_time_role;
  END_ENTITY; -- date_and_time_assignment

  ENTITY date_time_role;
      name : label;
  END_ENTITY; -- date_time_role

  ENTITY dated_effectivity
    SUBTYPE OF (effectivity);
      effectivity_start_date : date_and_time;
      effectivity_end_date   : OPTIONAL date_and_time;
  END_ENTITY; -- dated_effectivity

  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' IN
               TYPEOF(SELF\representation.context_of_items));
  END_ENTITY; -- definitional_representation

  ENTITY degenerate_pcurve
    SUBTYPE OF (point);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF(reference_to_curve\
               representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- degenerate_pcurve

  ENTITY degenerate_toroidal_surface
    SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
    WHERE
      wr1: (major_radius < minor_radius);
  END_ENTITY; -- degenerate_toroidal_surface

  ENTITY design_context
    SUBTYPE OF (product_definition_context);
    WHERE
      wr1: (SELF.life_cycle_stage = 'design');
  END_ENTITY; -- design_context

  ENTITY design_make_from_relationship
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- design_make_from_relationship

  ENTITY dimensional_exponents;
      length_exponent                    : REAL;
      mass_exponent                      : REAL;
      time_exponent                      : REAL;
      electric_current_exponent          : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent       : REAL;
      luminous_intensity_exponent        : REAL;
  END_ENTITY; -- dimensional_exponents

  ENTITY directed_action
    SUBTYPE OF (executed_action);
      directive : action_directive;
  END_ENTITY; -- directed_action

  ENTITY direction
    SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
    WHERE
      wr1: (SIZEOF(QUERY ( tmp <* direction_ratios | (tmp <> 0) )) > 0);
  END_ENTITY; -- direction

  ENTITY document;
      id          : identifier;
      name        : label;
      description : text;
      kind        : document_type;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- document

  ENTITY document_reference
    ABSTRACT SUPERTYPE;
      assigned_document : document;
      source            : label;
  END_ENTITY; -- document_reference

  ENTITY document_relationship;
      name              : label;
      description       : text;
      relating_document : document;
      related_document  : document;
  END_ENTITY; -- document_relationship

  ENTITY document_type;
      product_data_type : label;
  END_ENTITY; -- document_type

  ENTITY document_usage_constraint;
      source                : document;
      subject_element       : label;
      subject_element_value : text;
  END_ENTITY; -- document_usage_constraint

  ENTITY document_with_class
    SUBTYPE OF (document);
      class : identifier;
  END_ENTITY; -- document_with_class

  ENTITY edge
    SUPERTYPE OF (ONEOF (edge_curve,oriented_edge))
    SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end   : vertex;
  END_ENTITY; -- edge

  ENTITY edge_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      ebwm_boundary : SET [1:?] OF connected_edge_set;
  END_ENTITY; -- edge_based_wireframe_model

  ENTITY edge_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL',
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
               1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL',
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) ))
               >= 1);
      wr3: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (
               'CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF(edges))) ))
               = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( pline_edges <* QUERY ( edges <* eb.ces_edges | (
               'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(edges\edge_curve.
               edge_geometry)) ) | (NOT (SIZEOF(pline_edges\edge_curve.
               edge_geometry\polyline.points) > 2)) )) = 0)) )) = 0)) )) =
               0);
      wr5: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT ((
               'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(edges.
               edge_start)) AND ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN
               TYPEOF(edges.edge_end)))) )) = 0)) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT
               valid_wireframe_edge_curve(edges\edge_curve.edge_geometry))
               )) = 0)) )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (
               valid_wireframe_vertex_point(edges.edge_start\vertex_point.
               vertex_geometry) AND valid_wireframe_vertex_point(edges.
               edge_end\vertex_point.vertex_geometry))) )) = 0)) )) = 0))
               )) = 0);
      wr8: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT
               (('CONFIG_CONTROL_DESIGN.' +
               'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation))) )) = 0);
      wr9: (SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3);
  END_ENTITY; -- edge_based_wireframe_shape_representation

  ENTITY edge_curve
    SUBTYPE OF (edge, geometric_representation_item);
      edge_geometry : curve;
      same_sense    : BOOLEAN;
  END_ENTITY; -- edge_curve

  ENTITY edge_loop
    SUBTYPE OF (loop, path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      wr1: (SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].
               edge_end);
  END_ENTITY; -- edge_loop

  ENTITY effectivity
    SUPERTYPE OF (ONEOF (serial_numbered_effectivity,dated_effectivity,
        lot_effectivity));
      id : identifier;
  END_ENTITY; -- effectivity

  ENTITY elementary_surface
    SUPERTYPE OF (ONEOF (plane,cylindrical_surface,conical_surface,
        spherical_surface,toroidal_surface))
    SUBTYPE OF (surface);
      position : axis2_placement_3d;
  END_ENTITY; -- elementary_surface

  ENTITY ellipse
    SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY; -- ellipse

  ENTITY evaluated_degenerate_pcurve
    SUBTYPE OF (degenerate_pcurve);
      equivalent_point : cartesian_point;
  END_ENTITY; -- evaluated_degenerate_pcurve

  ENTITY executed_action
    SUBTYPE OF (action);
  END_ENTITY; -- executed_action

  ENTITY face
    SUPERTYPE OF (ONEOF (face_surface,oriented_face))
    SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
    WHERE
      wr1: (NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
      wr2: (SIZEOF(QUERY ( temp <* bounds | (
               'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(temp)) ))
               <= 1);
  END_ENTITY; -- face

  ENTITY face_bound
    SUBTYPE OF (topological_representation_item);
      bound       : loop;
      orientation : BOOLEAN;
  END_ENTITY; -- face_bound

  ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
  END_ENTITY; -- face_outer_bound

  ENTITY face_surface
    SUBTYPE OF (face, geometric_representation_item);
      face_geometry : surface;
      same_sense    : BOOLEAN;
  END_ENTITY; -- face_surface

  ENTITY faceted_brep
    SUBTYPE OF (manifold_solid_brep);
  END_ENTITY; -- faceted_brep

  ENTITY faceted_brep_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* items | (NOT (SIZEOF([
               'CONFIG_CONTROL_DESIGN.FACETED_BREP',
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
               1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* items | (SIZEOF([
               'CONFIG_CONTROL_DESIGN.FACETED_BREP',
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) >
                0);
      wr3: (SIZEOF(QUERY ( fbrep <* QUERY ( it <* items | (
               'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( csh <* msb_shells(fbrep) | (NOT (SIZEOF(
               QUERY ( fcs <* csh\connected_face_set.cfs_faces | (NOT ((
               'CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN TYPEOF(fcs)) AND (
               'CONFIG_CONTROL_DESIGN.PLANE' IN TYPEOF(fcs\face_surface.
               face_geometry)) AND ('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT'
               IN TYPEOF(fcs\face_surface.face_geometry\elementary_surface.
               position.location)))) )) = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( fbrep <* QUERY ( it <* items | (
               'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( csh <* msb_shells(fbrep) | (NOT (SIZEOF(
               QUERY ( fcs <* csh\connected_face_set.cfs_faces | (NOT (
               SIZEOF(QUERY ( bnds <* fcs.bounds | (
               'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(bnds)) ))
               = 1)) )) = 0)) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( msb <* QUERY ( it <* items | (
               'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | ('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(
               msb\manifold_solid_brep.outer)) )) = 0);
      wr6: (SIZEOF(QUERY ( brv <* QUERY ( it <* items | (
               'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids | csh\
               oriented_closed_shell.orientation )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( mi <* QUERY ( it <* items | (
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT
               ('CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION'
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0);
  END_ENTITY; -- faceted_brep_shape_representation

  ENTITY founded_item;
  END_ENTITY; -- founded_item

  ENTITY functionally_defined_transformation;
      name        : label;
      description : text;
  END_ENTITY; -- functionally_defined_transformation

  ENTITY geometric_curve_set
    SUBTYPE OF (geometric_set);
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* SELF\geometric_set.elements | (
               'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(temp)) )) = 0);
  END_ENTITY; -- geometric_curve_set

  ENTITY geometric_representation_context
    SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
  END_ENTITY; -- geometric_representation_context

  ENTITY geometric_representation_item
    SUPERTYPE OF (ONEOF (point,direction,vector,placement,
        cartesian_transformation_operator,curve,surface,edge_curve,
        face_surface,poly_loop,vertex_point,solid_model,
        shell_based_surface_model,shell_based_wireframe_model,
        edge_based_wireframe_model,geometric_set))
    SUBTYPE OF (representation_item);
    DERIVE
      dim : dimension_count := dimension_of(SELF);
    WHERE
      wr1: (SIZEOF(QUERY ( using_rep <* using_representations(SELF) | (
               NOT (
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN
               TYPEOF(using_rep.context_of_items))) )) = 0);
  END_ENTITY; -- geometric_representation_item

  ENTITY geometric_set
    SUPERTYPE OF (geometric_curve_set)
    SUBTYPE OF (geometric_representation_item);
      elements : SET [1:?] OF geometric_set_select;
  END_ENTITY; -- geometric_set

  ENTITY geometrically_bounded_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET',
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
               1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET',
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) >
                0);
      wr3: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT
               ((('CONFIG_CONTROL_DESIGN.' +
               'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION') IN
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation))
               AND (SIZEOF(QUERY ( mr_it <* mi\mapped_item.mapping_source.
               mapped_representation.items | (
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF(mr_it)) )) >
                0))) )) = 0);
      wr4: (SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( pnt <* QUERY ( gsel <* gs\geometric_set.
               elements | ('CONFIG_CONTROL_DESIGN.POINT' IN TYPEOF(gsel)) )
                | (NOT gbsf_check_point(pnt)) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( cv <* QUERY ( gsel <* gs\geometric_set.
               elements | ('CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF(gsel)) )
                | (NOT gbsf_check_curve(cv)) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) ) | (
               NOT (SIZEOF(QUERY ( sf <* QUERY ( gsel <* gs\geometric_set.
               elements | ('CONFIG_CONTROL_DESIGN.SURFACE' IN
               TYPEOF(gsel)) ) | (NOT gbsf_check_surface(sf)) ))
               = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( gs <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF(it)) ) | (
               SIZEOF(QUERY ( gsel <* gs\geometric_set.elements | (
               'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(gsel)) )) > 0) ))
               > 0);
  END_ENTITY; -- geometrically_bounded_surface_shape_representation

  ENTITY geometrically_bounded_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF(TYPEOF(it) * [
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET',
               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D',
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM']) = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF(TYPEOF(it) * [
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET',
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM']) = 1) )) >= 1);
      wr3: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( crv <* QUERY ( elem <* gcs\
               geometric_set.elements | ('CONFIG_CONTROL_DESIGN.CURVE' IN
               TYPEOF(elem)) ) | (NOT valid_geometrically_bounded_wf_curve(
               crv)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( pnts <* QUERY ( elem <* gcs\
               geometric_set.elements | ('CONFIG_CONTROL_DESIGN.POINT' IN
               TYPEOF(elem)) ) | (NOT valid_geometrically_bounded_wf_point(
               pnts)) )) = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( cnc <* QUERY ( elem <* gcs\
               geometric_set.elements | ('CONFIG_CONTROL_DESIGN.CONIC' IN
               TYPEOF(elem)) ) | (NOT (
               'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(cnc\
               conic.position))) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( gcs <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( pline <* QUERY ( elem <* gcs\
               geometric_set.elements | ('CONFIG_CONTROL_DESIGN.POLYLINE'
               IN TYPEOF(elem)) ) | (NOT (SIZEOF(pline\polyline.points)
               > 2)) )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (NOT
               (('CONFIG_CONTROL_DESIGN.' +
               'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION') IN
               TYPEOF(mi\mapped_item.mapping_source.mapped_representation)
               )) )) = 0);
  END_ENTITY; -- geometrically_bounded_wireframe_shape_representation

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY; -- global_uncertainty_assigned_context

  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
  END_ENTITY; -- global_unit_assigned_context

  ENTITY hyperbola
    SUBTYPE OF (conic);
      semi_axis      : positive_length_measure;
      semi_imag_axis : positive_length_measure;
  END_ENTITY; -- hyperbola

  ENTITY intersection_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1])
               <> associated_surface(SELF\surface_curve.associated_geometry
               [2]));
  END_ENTITY; -- intersection_curve

  ENTITY item_defined_transformation;
      name             : label;
      description      : text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
  END_ENTITY; -- item_defined_transformation

  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- length_measure_with_unit

  ENTITY length_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- length_unit

  ENTITY line
    SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
    WHERE
      wr1: (dir.dim = pnt.dim);
  END_ENTITY; -- line

  ENTITY local_time;
      hour_component   : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone             : coordinated_universal_time_offset;
    WHERE
      wr1: valid_time(SELF);
  END_ENTITY; -- local_time

  ENTITY loop
    SUPERTYPE OF (ONEOF (vertex_loop,edge_loop,poly_loop))
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- loop

  ENTITY lot_effectivity
    SUBTYPE OF (effectivity);
      effectivity_lot_id   : identifier;
      effectivity_lot_size : measure_with_unit;
  END_ENTITY; -- lot_effectivity

  ENTITY manifold_solid_brep
    SUBTYPE OF (solid_model);
      outer : closed_shell;
  END_ENTITY; -- manifold_solid_brep

  ENTITY manifold_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL',
                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
                'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
                 1)) )) = 0);
      wr2 : (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL',
                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) ))
                > 0);
      wr3 : (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (
                NOT (('CONFIG_CONTROL_DESIGN.'+
               'MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
                IN TYPEOF(mi\mapped_item.mapping_source.
                mapped_representation)) AND (SIZEOF(QUERY ( mr_it <* mi\
                mapped_item.mapping_source.mapped_representation.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(mr_it)) )) > 0))) )) = 0);
      wr4 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( sh <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF([
                'CONFIG_CONTROL_DESIGN.OPEN_SHELL',
                'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL',
                'CONFIG_CONTROL_DESIGN.CLOSED_SHELL'] * TYPEOF(sh)) = 1))
                )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT (
                SIZEOF(['CONFIG_CONTROL_DESIGN.FACE_SURFACE',
                'CONFIG_CONTROL_DESIGN.ORIENTED_FACE'] * TYPEOF(fa)) = 1))
                )) = 0)) )) = 0)) )) = 0);
      wr6 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( f_sf <* QUERY ( fa <* cfs\connected_face_set.
                cfs_faces | ('CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN
                TYPEOF(fa)) ) | (NOT ((
                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(f_sf)) OR (
                SIZEOF(['CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE',
                'CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE',
                'CONFIG_CONTROL_DESIGN.OFFSET_SURFACE',
                'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA',
                'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'] * TYPEOF(f_sf\
                face_surface.face_geometry)) = 1))) )) = 0)) )) = 0)) )) =
                0);
      wr7 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR
                msf_surface_check(fa\face_surface.face_geometry))) ))
                = 0)) )) = 0)) )) = 0);
      wr8 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( bnds <* fa.bounds | (NOT (SIZEOF([
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP',
                'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'] * TYPEOF(bnds.bound))
                = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr9 : (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF(oe.
                edge_element))))) = 0)))) = 0))))) = 0)) )) = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe_cv <* QUERY ( oe <* elp_fbnds\
                path.edge_list | ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN
                TYPEOF(oe.edge_element)) ) | (NOT (SIZEOF([
                'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE',
                'CONFIG_CONTROL_DESIGN.CONIC',
                'CONFIG_CONTROL_DESIGN.CURVE_REPLICA',
                'CONFIG_CONTROL_DESIGN.LINE',
                'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D',
                'CONFIG_CONTROL_DESIGN.PCURVE',
                'CONFIG_CONTROL_DESIGN.POLYLINE',
                'CONFIG_CONTROL_DESIGN.SURFACE_CURVE'] * TYPEOF(oe_cv.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0))) )) = 0)) )) = 0)) )) = 0);
      wr11: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT msf_curve_check(oe.edge_element\edge_curve.
                edge_geometry)) )) = 0)) )) = 0))) ))
                = 0)) )) = 0)) )) = 0);
      wr12: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_start)) AND (
                'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_end)))) )) = 0)) )) = 0))) )) = 0)) )) =
                0)) )) = 0);
      wr13: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT ((SIZEOF(['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',
                'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',
                'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',
                'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF(oe.
                edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
                AND (SIZEOF(['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',
                'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',
                'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',
                'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF(oe.
                edge_element.edge_end\vertex_point.vertex_geometry))
                = 1))) )) = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr14: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'
                IN TYPEOF(bnds.bound)) )
                 | (NOT ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(
                vlp_fbnds\vertex_loop.loop_vertex))) )) = 0))) )) = 0)) ))
                = 0)) )) = 0);
      wr15: (SIZEOF(QUERY ( sbsm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* sbsm\
                shell_based_surface_model.sbsm_boundary | (NOT (SIZEOF(
                QUERY ( fa <* cfs\connected_face_set.cfs_faces | (NOT ((
                'CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(fa)) OR (
                SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'
                IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',
                'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',
                'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',
                'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF(
                vlp_fbnds\vertex_loop.loop_vertex\vertex_point.
                vertex_geometry)) = 1)) )) = 0))) ))
                = 0)) )) = 0)) )) = 0);
  END_ENTITY; -- manifold_surface_shape_representation

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      wr1: acyclic_mapped_representation(using_representations(SELF),
           [SELF]);
  END_ENTITY; -- mapped_item

  ENTITY mass_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.MASS_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- mass_measure_with_unit

  ENTITY mass_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 1) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- mass_unit

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF (length_measure_with_unit,mass_measure_with_unit,
        plane_angle_measure_with_unit,solid_angle_measure_with_unit,
        area_measure_with_unit,volume_measure_with_unit));
      value_component : measure_value;
      unit_component  : unit;
    WHERE
      wr1: valid_units(SELF);
  END_ENTITY; -- measure_with_unit

  ENTITY mechanical_context
    SUBTYPE OF (product_context);
    WHERE
      wr1: (SELF.discipline_type = 'mechanical');
  END_ENTITY; -- mechanical_context

  ENTITY named_unit
    SUPERTYPE OF (ONEOF (si_unit,conversion_based_unit,
        context_dependent_unit) ANDOR ONEOF (length_unit,mass_unit,
        plane_angle_unit,solid_angle_unit,area_unit,volume_unit));
      dimensions : dimensional_exponents;
  END_ENTITY; -- named_unit

  ENTITY next_assembly_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY; -- next_assembly_usage_occurrence

  ENTITY offset_curve_3d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
      ref_direction  : direction;
    WHERE
      wr1: ((basis_curve.dim = 3) AND (ref_direction.dim = 3));
  END_ENTITY; -- offset_curve_3d

  ENTITY offset_surface
    SUBTYPE OF (surface);
      basis_surface  : surface;
      distance       : length_measure;
      self_intersect : LOGICAL;
  END_ENTITY; -- offset_surface

  ENTITY open_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- open_shell

  ENTITY ordinal_date
    SUBTYPE OF (date);
      day_component : day_in_year_number;
    WHERE
      wr1: (((NOT leap_year(SELF.year_component)) AND (1 <= day_component)
               AND (day_component <= 365)) OR (leap_year(SELF.
               year_component) AND (1 <= day_component) AND (day_component
               <= 366)));
  END_ENTITY; -- ordinal_date

  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : text;
  END_ENTITY; -- organization

  ENTITY organization_relationship;
      name                  : label;
      description           : text;
      relating_organization : organization;
      related_organization  : organization;
  END_ENTITY; -- organization_relationship

  ENTITY organizational_address
    SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description   : text;
  END_ENTITY; -- organizational_address

  ENTITY organizational_project;
      name                      : label;
      description               : text;
      responsible_organizations : SET [1:?] OF organization;
  END_ENTITY; -- organizational_project

  ENTITY oriented_closed_shell
    SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation          : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face :=
          conditional_reverse(SELF.orientation,SELF.
          closed_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(
               SELF.closed_shell_element)));
  END_ENTITY; -- oriented_closed_shell

  ENTITY oriented_edge
    SUBTYPE OF (edge);
      edge_element : edge;
      orientation  : BOOLEAN;
    DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_start,SELF.
                                edge_element.edge_end);
      SELF\edge.edge_end   : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_end,SELF.
                                edge_element.edge_start);
    WHERE
      wr1: (NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF(SELF.
               edge_element)));
  END_ENTITY; -- oriented_edge

  ENTITY oriented_face
    SUBTYPE OF (face);
      face_element : face;
      orientation  : BOOLEAN;
    DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(
                            SELF.orientation,SELF.face_element.bounds);
    WHERE
      wr1: (NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF(SELF.
               face_element)));
  END_ENTITY; -- oriented_face

  ENTITY oriented_open_shell
    SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation        : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face :=
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             open_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(
               SELF.open_shell_element)));
  END_ENTITY; -- oriented_open_shell

  ENTITY oriented_path
    SUBTYPE OF (path);
      path_element : path;
      orientation  : BOOLEAN;
    DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge :=
                               conditional_reverse(SELF.orientation,SELF.
                               path_element.edge_list);
    WHERE
      wr1: (NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF(SELF.
               path_element)));
  END_ENTITY; -- oriented_path

  ENTITY outer_boundary_curve
    SUBTYPE OF (boundary_curve);
  END_ENTITY; -- outer_boundary_curve

  ENTITY parabola
    SUBTYPE OF (conic);
      focal_dist : length_measure;
    WHERE
      wr1: (focal_dist <> 0);
  END_ENTITY; -- parabola

  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY; -- parametric_representation_context

  ENTITY path
    SUPERTYPE OF (ONEOF (edge_loop,oriented_path))
    SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
    WHERE
      wr1: path_head_to_tail(SELF);
  END_ENTITY; -- path

  ENTITY pcurve
    SUBTYPE OF (curve);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF(reference_to_curve\
               representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- pcurve

  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    UNIQUE
      ur1 : id;
    WHERE
      wr1: (EXISTS(last_name) OR EXISTS(first_name));
  END_ENTITY; -- person

  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
  END_ENTITY; -- person_and_organization

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role                             : person_and_organization_role;
  END_ENTITY; -- person_and_organization_assignment

  ENTITY person_and_organization_role;
      name : label;
  END_ENTITY; -- person_and_organization_role

  ENTITY personal_address
    SUBTYPE OF (address);
      people      : SET [1:?] OF person;
      description : text;
  END_ENTITY; -- personal_address

  ENTITY placement
    SUPERTYPE OF (ONEOF (axis1_placement,axis2_placement_2d,
        axis2_placement_3d))
    SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
  END_ENTITY; -- placement

  ENTITY plane
    SUBTYPE OF (elementary_surface);
  END_ENTITY; -- plane

  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- plane_angle_measure_with_unit

  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- plane_angle_unit

  ENTITY point
    SUPERTYPE OF (ONEOF (cartesian_point,point_on_curve,point_on_surface,
        point_replica,degenerate_pcurve))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- point

  ENTITY point_on_curve
    SUBTYPE OF (point);
      basis_curve     : curve;
      point_parameter : parameter_value;
  END_ENTITY; -- point_on_curve

  ENTITY point_on_surface
    SUBTYPE OF (point);
      basis_surface     : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
  END_ENTITY; -- point_on_surface

  ENTITY point_replica
    SUBTYPE OF (point);
      parent_pt      : point;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_pt.dim);
      wr2: acyclic_point_replica(SELF,parent_pt);
  END_ENTITY; -- point_replica

  ENTITY poly_loop
    SUBTYPE OF (loop, geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
  END_ENTITY; -- poly_loop

  ENTITY polyline
    SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
  END_ENTITY; -- polyline

  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : text;
      frame_of_reference : SET [1:?] OF product_context;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- product

  ENTITY product_category;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- product_category

  ENTITY product_category_relationship;
      name         : label;
      description  : text;
      category     : product_category;
      sub_category : product_category;
    WHERE
      wr1: acyclic_product_category_relationship(SELF,[SELF.sub_category]);
  END_ENTITY; -- product_category_relationship

  ENTITY product_concept;
      id             : identifier;
      name           : label;
      description    : text;
      market_context : product_concept_context;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- product_concept

  ENTITY product_concept_context
    SUBTYPE OF (application_context_element);
      market_segment_type : label;
  END_ENTITY; -- product_concept_context

  ENTITY product_context
    SUBTYPE OF (application_context_element);
      discipline_type : label;
  END_ENTITY; -- product_context

  ENTITY product_definition;
      id                 : identifier;
      description        : text;
      formation          : product_definition_formation;
      frame_of_reference : product_definition_context;
  END_ENTITY; -- product_definition

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
  END_ENTITY; -- product_definition_context

  ENTITY product_definition_effectivity
    SUBTYPE OF (effectivity);
      usage : product_definition_relationship;
    UNIQUE
      ur1 : usage, id;
  END_ENTITY; -- product_definition_effectivity

  ENTITY product_definition_formation;
      id          : identifier;
      description : text;
      of_product  : product;
    UNIQUE
      ur1 : id, of_product;
  END_ENTITY; -- product_definition_formation

  ENTITY product_definition_formation_with_specified_source
    SUBTYPE OF (product_definition_formation);
      make_or_buy : source;
  END_ENTITY; -- product_definition_formation_with_specified_source

  ENTITY product_definition_relationship;
      id                          : identifier;
      name                        : label;
      description                 : text;
      relating_product_definition : product_definition;
      related_product_definition  : product_definition;
  END_ENTITY; -- product_definition_relationship

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : definition;
    WHERE
      wr1: (NOT ('CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION' IN TYPEOF(SELF\
               property_definition.definition)));
  END_ENTITY; -- product_definition_shape

  ENTITY product_definition_usage
    SUPERTYPE OF (assembly_component_usage)
    SUBTYPE OF (product_definition_relationship);
    UNIQUE
      ur1 : id, relating_product_definition, related_product_definition;
    WHERE
      wr1: acyclic_product_definition_relationship(SELF,[SELF\
               product_definition_relationship.related_product_definition],
               'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE');
  END_ENTITY; -- product_definition_usage

  ENTITY product_definition_with_associated_documents
    SUBTYPE OF (product_definition);
      documentation_ids : SET [1:?] OF document;
  END_ENTITY; -- product_definition_with_associated_documents

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
  END_ENTITY; -- product_related_product_category

  ENTITY promissory_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
  END_ENTITY; -- promissory_usage_occurrence

  ENTITY property_definition;
      name        : label;
      description : text;
      definition  : characterized_definition;
  END_ENTITY; -- property_definition

  ENTITY property_definition_representation;
      definition          : property_definition;
      used_representation : representation;
  END_ENTITY; -- property_definition_representation

  ENTITY quantified_assembly_component_usage
    SUBTYPE OF (assembly_component_usage);
      quantity : measure_with_unit;
  END_ENTITY; -- quantified_assembly_component_usage

  ENTITY quasi_uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- quasi_uniform_curve

  ENTITY quasi_uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- quasi_uniform_surface

  ENTITY rational_b_spline_curve
    SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL :=
                   list_to_array(weights_data,0,
                   upper_index_on_control_points);
    WHERE
      wr1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
               control_points_list));
      wr2: curve_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_curve

  ENTITY rational_b_spline_surface
    SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL :=
                   make_array_of_array(weights_data,0,u_upper,0,v_upper);
    WHERE
      wr1: ((SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.
               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(
               SELF\b_spline_surface.control_points_list[1])));
      wr2: surface_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_surface

  ENTITY rectangular_composite_surface
    SUBTYPE OF (bounded_surface);
      segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
    DERIVE
      n_u : INTEGER := SIZEOF(segments);
      n_v : INTEGER := SIZEOF(segments[1]);
    WHERE
      wr1: ([] = QUERY ( s <* segments | (n_v <> SIZEOF(s)) ));
      wr2: constraints_rectangular_composite_surface(SELF);
  END_ENTITY; -- rectangular_composite_surface

  ENTITY rectangular_trimmed_surface
    SUBTYPE OF (bounded_surface);
      basis_surface : surface;
      u1            : parameter_value;
      u2            : parameter_value;
      v1            : parameter_value;
      v2            : parameter_value;
      usense        : BOOLEAN;
      vsense        : BOOLEAN;
    WHERE
      wr1: (u1 <> u2);
      wr2: (v1 <> v2);
      wr3: ((('CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(
               basis_surface)) AND (NOT ('CONFIG_CONTROL_DESIGN.PLANE' IN
               TYPEOF(basis_surface)))) OR (
               'CONFIG_CONTROL_DESIGN.SURFACE_OF_REVOLUTION' IN TYPEOF(
               basis_surface)) OR (usense = (u2 > u1)));
      wr4: (('CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE' IN TYPEOF(
               basis_surface)) OR ('CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE'
               IN TYPEOF(basis_surface)) OR (vsense = (v2 > v1)));
  END_ENTITY; -- rectangular_trimmed_surface

  ENTITY reparametrised_composite_curve_segment
    SUBTYPE OF (composite_curve_segment);
      param_length : parameter_value;
    WHERE
      wr1: (param_length > 0);
  END_ENTITY; -- reparametrised_composite_curve_segment

  ENTITY representation;
      name             : label;
      items            : SET [1:?] OF representation_item;
      context_of_items : representation_context;
  END_ENTITY; -- representation

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR
                                      context_of_items;
  END_ENTITY; -- representation_context

  ENTITY representation_item;
      name : label;
    WHERE
      wr1: (SIZEOF(using_representations(SELF)) > 0);
  END_ENTITY; -- representation_item

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
    WHERE
      wr1: item_in_context(SELF.mapping_origin,SELF.mapped_representation.
               context_of_items);
  END_ENTITY; -- representation_map

  ENTITY representation_relationship;
      name        : label;
      description : text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY; -- representation_relationship

  ENTITY representation_relationship_with_transformation
    SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
    WHERE
      wr1: (SELF\representation_relationship.rep_1.context_of_items :<>:
               SELF\representation_relationship.rep_2.context_of_items);
  END_ENTITY; -- representation_relationship_with_transformation

  ENTITY seam_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1])
               = associated_surface(SELF\surface_curve.associated_geometry[
               2]));
      wr3: ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(SELF\surface_curve.
               associated_geometry[1]));
      wr4: ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(SELF\surface_curve.
               associated_geometry[2]));
  END_ENTITY; -- seam_curve

  ENTITY security_classification;
      name           : label;
      purpose        : text;
      security_level : security_classification_level;
  END_ENTITY; -- security_classification

  ENTITY security_classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_security_classification : security_classification;
  END_ENTITY; -- security_classification_assignment

  ENTITY security_classification_level;
      name : label;
  END_ENTITY; -- security_classification_level

  ENTITY serial_numbered_effectivity
    SUBTYPE OF (effectivity);
      effectivity_start_id : identifier;
      effectivity_end_id   : OPTIONAL identifier;
  END_ENTITY; -- serial_numbered_effectivity

  ENTITY shape_aspect;
      name                 : label;
      description          : text;
      of_shape             : product_definition_shape;
      product_definitional : LOGICAL;
  END_ENTITY; -- shape_aspect

  ENTITY shape_aspect_relationship;
      name                  : label;
      description           : text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect  : shape_aspect;
  END_ENTITY; -- shape_aspect_relationship

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: (('CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION' IN TYPEOF(SELF.
               definition.definition)) OR (
               'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
               SELF.definition)));
      wr2: ('CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(SELF.
               used_representation));
  END_ENTITY; -- shape_definition_representation

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY; -- shape_representation

  ENTITY shape_representation_relationship
    SUBTYPE OF (representation_relationship);
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\
               representation_relationship.rep_1) + TYPEOF(SELF\
               representation_relationship.rep_2)));
  END_ENTITY; -- shape_representation_relationship

  ENTITY shell_based_surface_model
    SUBTYPE OF (geometric_representation_item);
      sbsm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_surface_model(SELF);
  END_ENTITY; -- shell_based_surface_model

  ENTITY shell_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      sbwm_boundary : SET [1:?] OF shell;
    WHERE
      wr1: constraints_geometry_shell_based_wireframe_model(SELF);
  END_ENTITY; -- shell_based_wireframe_model

  ENTITY shell_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL',
                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
                'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
                 1)) )) = 0);
      wr2 : (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL',
                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1) ))
                >= 1);
      wr3 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <*
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT
                (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN
                TYPEOF(el.edge_element))) )) = 0)) ))
                = 0)) )) = 0)) )) = 0);
      wr4 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <*
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT
                (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( pline_el <*
                QUERY ( el <* eloop\path.edge_list | (
                'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(el.edge_element\
                edge_curve.edge_geometry)) ) | (NOT (SIZEOF(pline_el.
                edge_element\edge_curve.edge_geometry\polyline.points)
                > 2)) )) = 0)) )) = 0)) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <*
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT
                (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT valid_wireframe_edge_curve(el.edge_element
                \edge_curve.edge_geometry)) )) = 0)) )) = 0)) )) = 0)) )) =
                 0);
      wr6 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <*
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT
                (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN
                TYPEOF(el.edge_element.edge_start)) AND (
                'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(el.
                edge_element.edge_end)))) )) = 0)) ))
                = 0)) )) = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <*
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT
                (SIZEOF(QUERY ( eloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN
                TYPEOF(wsb)) ) | (NOT (SIZEOF(QUERY ( el <* eloop\path.
                edge_list | (NOT (valid_wireframe_vertex_point(el.
                edge_element.edge_start\vertex_point.vertex_geometry) AND
                valid_wireframe_vertex_point(el.edge_element.edge_end\
                vertex_point.vertex_geometry))) )) = 0)) ))
                = 0)) )) = 0)) )) = 0);
      wr8 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <*
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT
                (SIZEOF(QUERY ( vloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN
                 TYPEOF(wsb)) ) | (NOT (
                'CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(vloop\
                vertex_loop.loop_vertex))) )) = 0)) )) = 0)) )) = 0);
      wr9 : (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( ws <* QUERY ( sb <*
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(sb)) ) | (NOT
                (SIZEOF(QUERY ( vloop <* QUERY ( wsb <* ws\wire_shell.
                wire_shell_extent | ('CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN
                 TYPEOF(wsb)) ) | (NOT valid_wireframe_vertex_point(vloop\
                vertex_loop.loop_vertex\vertex_point.vertex_geometry)) )) =
                 0)) )) = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* QUERY ( sb <*
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF(sb)) ) | (
                NOT ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF(vs\
                vertex_shell.vertex_shell_extent.loop_vertex))) )) = 0)) ))
                = 0);
      wr11: (SIZEOF(QUERY ( sbwm <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( vs <* QUERY ( sb <*
                sbwm\shell_based_wireframe_model.sbwm_boundary | (
                'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF(sb)) ) | (
                NOT valid_wireframe_vertex_point(vs\vertex_shell.
                vertex_shell_extent.loop_vertex\vertex_point.
                vertex_geometry)) )) = 0)) )) = 0);
      wr12: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
                'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) ) | (
                NOT (('CONFIG_CONTROL_DESIGN.' +
                'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\
                mapped_item.mapping_source.mapped_representation))) ))
                = 0);
      wr13: (SELF.context_of_items\geometric_representation_context.
                coordinate_space_dimension = 3);
  END_ENTITY; -- shell_based_wireframe_shape_representation

  ENTITY si_unit
    SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name   : si_unit_name;
    DERIVE
      SELF\named_unit.dimensions : dimensional_exponents :=
                                      dimensions_for_si_unit(SELF.name);
  END_ENTITY; -- si_unit

  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- solid_angle_measure_with_unit

  ENTITY solid_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- solid_angle_unit

  ENTITY solid_model
    SUPERTYPE OF (manifold_solid_brep)
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- solid_model

  ENTITY specified_higher_usage_occurrence
    SUBTYPE OF (assembly_component_usage);
      upper_usage : assembly_component_usage;
      next_usage  : next_assembly_usage_occurrence;
    UNIQUE
      ur1 : upper_usage, next_usage;
    WHERE
      wr1: (SELF :<>: upper_usage);
      wr2: (SELF\product_definition_relationship.
               relating_product_definition :=: upper_usage.
               relating_product_definition);
      wr3: (SELF\product_definition_relationship.
               related_product_definition :=: next_usage.
               related_product_definition);
      wr4: (upper_usage.related_product_definition :=: next_usage.
               relating_product_definition);
      wr5: (NOT ('CONFIG_CONTROL_DESIGN.PROMISSORY_USAGE_OCCURRENCE' IN
               TYPEOF(upper_usage)));
  END_ENTITY; -- specified_higher_usage_occurrence

  ENTITY spherical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- spherical_surface

  ENTITY start_request
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF start_request_item;
  END_ENTITY; -- start_request

  ENTITY start_work
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF work_item;
  END_ENTITY; -- start_work

  ENTITY supplied_part_relationship
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY; -- supplied_part_relationship

  ENTITY surface
    SUPERTYPE OF (ONEOF (elementary_surface,swept_surface,bounded_surface,
        offset_surface,surface_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- surface

  ENTITY surface_curve
    SUPERTYPE OF (ONEOF (intersection_curve,seam_curve) ANDOR
        bounded_surface_curve)
    SUBTYPE OF (curve);
      curve_3d              : curve;
      associated_geometry   : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
    DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (curve_3d.dim = 3);
      wr2: (('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(associated_geometry[
               1])) OR (master_representation <> pcurve_s1));
      wr3: (('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(associated_geometry[
               2])) OR (master_representation <> pcurve_s2));
      wr4: (NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(curve_3d)));
  END_ENTITY; -- surface_curve

  ENTITY surface_of_linear_extrusion
    SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
  END_ENTITY; -- surface_of_linear_extrusion

  ENTITY surface_of_revolution
    SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
    DERIVE
      axis_line : line := dummy_gri || curve() || line(axis_position.
                     location,dummy_gri || vector(axis_position.z,1));
  END_ENTITY; -- surface_of_revolution

  ENTITY surface_patch
    SUBTYPE OF (founded_item);
      parent_surface : bounded_surface;
      u_transition   : transition_code;
      v_transition   : transition_code;
      u_sense        : BOOLEAN;
      v_sense        : BOOLEAN;
    INVERSE
      using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR
                          segments;
    WHERE
      wr1: (NOT ('CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF(
               parent_surface)));
  END_ENTITY; -- surface_patch

  ENTITY surface_replica
    SUBTYPE OF (surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
    WHERE
      wr1: acyclic_surface_replica(SELF,parent_surface);
  END_ENTITY; -- surface_replica

  ENTITY swept_surface
    SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,
        surface_of_revolution))
    SUBTYPE OF (surface);
      swept_curve : curve;
  END_ENTITY; -- swept_surface

  ENTITY topological_representation_item
    SUPERTYPE OF (ONEOF (vertex,edge,face_bound,face,vertex_shell,
        wire_shell,connected_edge_set,connected_face_set,loop ANDOR path))
    SUBTYPE OF (representation_item);
  END_ENTITY; -- topological_representation_item

  ENTITY toroidal_surface
    SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
  END_ENTITY; -- toroidal_surface

  ENTITY trimmed_curve
    SUBTYPE OF (bounded_curve);
      basis_curve           : curve;
      trim_1                : SET [1:2] OF trimming_select;
      trim_2                : SET [1:2] OF trimming_select;
      sense_agreement       : BOOLEAN;
      master_representation : trimming_preference;
    WHERE
      wr1: ((HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <>
           TYPEOF(trim_1[2])));
      wr2: ((HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <>
           TYPEOF(trim_2[2])));
  END_ENTITY; -- trimmed_curve

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : text;
    WHERE
      wr1: valid_measure_value(SELF\measure_with_unit.value_component);
  END_ENTITY; -- uncertainty_measure_with_unit

  ENTITY uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- uniform_curve

  ENTITY uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- uniform_surface

  ENTITY vector
    SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude   : length_measure;
    WHERE
      wr1: (magnitude >= 0);
  END_ENTITY; -- vector

  ENTITY versioned_action_request;
      id          : identifier;
      version     : label;
      purpose     : text;
      description : text;
  END_ENTITY; -- versioned_action_request

  ENTITY vertex
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- vertex

  ENTITY vertex_loop
    SUBTYPE OF (loop);
      loop_vertex : vertex;
  END_ENTITY; -- vertex_loop

  ENTITY vertex_point
    SUBTYPE OF (vertex, geometric_representation_item);
      vertex_geometry : point;
  END_ENTITY; -- vertex_point

  ENTITY vertex_shell
    SUBTYPE OF (topological_representation_item);
      vertex_shell_extent : vertex_loop;
  END_ENTITY; -- vertex_shell

  ENTITY volume_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('CONFIG_CONTROL_DESIGN.VOLUME_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- volume_measure_with_unit

  ENTITY volume_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 3) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- volume_unit

  ENTITY week_of_year_and_day_date
    SUBTYPE OF (date);
      week_component : week_in_year_number;
      day_component  : OPTIONAL day_in_week_number;
  END_ENTITY; -- week_of_year_and_day_date

  ENTITY wire_shell
    SUBTYPE OF (topological_representation_item);
      wire_shell_extent : SET [1:?] OF loop;
    WHERE
      wr1: (NOT mixed_loop_type_set(wire_shell_extent));
  END_ENTITY; -- wire_shell

  RULE acu_requires_security_classification FOR (assembly_component_usage,
               cc_design_security_classification);
  WHERE
    wr1: (SIZEOF(QUERY ( acu <* assembly_component_usage | (NOT (SIZEOF(
             QUERY ( ccdsc <* cc_design_security_classification | (acu IN
             ccdsc.items) )) = 1)) )) = 0);
  END_RULE; -- acu_requires_security_classification

  RULE application_context_requires_ap_definition FOR (application_context,
             application_protocol_definition);
  WHERE
    wr1: (SIZEOF(QUERY ( ac <* application_context | (NOT (SIZEOF(
             QUERY ( apd <* application_protocol_definition | ((ac :=: apd.
             application) AND (apd.
             application_interpreted_model_schema_name =
             'config_control_design')) )) = 1)) )) = 0);
  END_RULE; -- application_context_requires_ap_definition

  RULE approval_date_time_constraints FOR (approval_date_time);
  WHERE
    wr1: (SIZEOF(QUERY ( adt <* approval_date_time | (NOT (SIZEOF(TYPEOF(
             adt.date_time) * ['CONFIG_CONTROL_DESIGN.DATE_AND_TIME'])
             = 1)) )) = 0);
  END_RULE; -- approval_date_time_constraints

  RULE approval_person_organization_constraints FOR (
             approval_person_organization);
  WHERE
    wr1: (SIZEOF(QUERY ( apo <* approval_person_organization | (NOT (
             SIZEOF(TYPEOF(apo.person_organization) * [
             'CONFIG_CONTROL_DESIGN.PERSON_AND_ORGANIZATION'])
             = 1)) )) = 0);
  END_RULE; -- approval_person_organization_constraints

  RULE approval_requires_approval_date_time FOR (approval,
             approval_date_time);
  WHERE
    wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( adt <*
             approval_date_time | (app :=: adt.dated_approval) )) = 1)) ))
             = 0);
  END_RULE; -- approval_requires_approval_date_time

  RULE approval_requires_approval_person_organization FOR (approval,
             approval_person_organization);
  WHERE
    wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( apo <*
             approval_person_organization | (app :=: apo.
             authorized_approval) )) >= 1)) )) = 0);
  END_RULE; -- approval_requires_approval_person_organization

  RULE approvals_are_assigned FOR (approval, approval_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( app <* approval | (NOT (SIZEOF(QUERY ( aa <*
             approval_assignment | (app :=: aa.assigned_approval) ))
             >= 1)) )) = 0);
  END_RULE; -- approvals_are_assigned

  RULE as_required_quantity FOR (measure_with_unit);
  WHERE
    wr1: (SIZEOF(QUERY ( m <* measure_with_unit | ((
             'CONFIG_CONTROL_DESIGN.DESCRIPTIVE_MEASURE' IN TYPEOF(m.
             value_component)) AND (NOT (m.value_component =
             'as_required'))) )) = 0);
  END_RULE; -- as_required_quantity

  RULE certification_requires_approval FOR (certification,
             cc_design_approval);
  WHERE
    wr1: (SIZEOF(QUERY ( cert <* certification | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (cert IN ccda.items) )) =
              1)) )) = 0);
  END_RULE; -- certification_requires_approval

  RULE certification_requires_date_time FOR (certification,
             cc_design_date_and_time_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( cert <* certification | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | (cert IN
              ccdta.items) )) = 1)) )) = 0);
  END_RULE; -- certification_requires_date_time

  RULE change_request_requires_approval FOR (change_request,
             cc_design_approval);
  WHERE
    wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (cr IN ccda.items) ))
             = 1)) )) = 0);
  END_RULE; -- change_request_requires_approval

  RULE change_request_requires_date_time FOR (change_request,
             cc_design_date_and_time_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | (cr IN
             ccdta.items) )) = 1)) )) = 0);
  END_RULE; -- change_request_requires_date_time

  RULE change_request_requires_person_organization FOR (change_request,
             cc_design_person_and_organization_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( cr <* change_request | (NOT (SIZEOF(
             QUERY ( ccpoa <* cc_design_person_and_organization_assignment
              | (cr IN ccpoa.items) )) >= 1)) )) = 0);
  END_RULE; -- change_request_requires_person_organization

  RULE change_requires_approval FOR (change, cc_design_approval);
  WHERE
    wr1: (SIZEOF(QUERY ( chg <* change | (NOT (SIZEOF(QUERY ( ccda <*
             cc_design_approval | (chg IN ccda.items) )) = 1)) )) = 0);
  END_RULE; -- change_requires_approval

  RULE change_requires_date_time FOR (change,
             cc_design_date_and_time_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( chg <* change | (NOT (SIZEOF(QUERY ( ccdta <*
             cc_design_date_and_time_assignment | ((chg IN ccdta.items) AND
              (ccdta.role.name = 'start_date')) )) = 1)) )) = 0);
  END_RULE; -- change_requires_date_time

  RULE compatible_dimension FOR (cartesian_point, direction,
             representation_context, geometric_representation_context);
  WHERE
    wr1: (SIZEOF(QUERY ( x <* cartesian_point | (SIZEOF(QUERY ( y <*
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.coordinates) <> y.coordinate_space_dimension)) )) >
             0) )) = 0);
    wr2: (SIZEOF(QUERY ( x <* direction | (SIZEOF(QUERY ( y <*
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension))
             )) > 0) )) = 0);
  END_RULE; -- compatible_dimension

  RULE configuration_item_requires_approval FOR (configuration_item,
             cc_design_approval);
  WHERE
    wr1: (SIZEOF(QUERY ( ci <* configuration_item | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (ci IN ccda.items) ))
             = 1)) )) = 0);
  END_RULE; -- configuration_item_requires_approval

  RULE configuration_item_requires_person_organization FOR (
             configuration_item,
             cc_design_person_and_organization_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( ci <* configuration_item | (NOT (SIZEOF(
             QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
              | (ci IN ccdpoa.items) )) = 1)) )) = 0);
  END_RULE; -- configuration_item_requires_person_organization

  RULE contract_requires_approval FOR (contract, cc_design_approval);
  WHERE
    wr1: (SIZEOF(QUERY ( c <* contract | (NOT (SIZEOF(QUERY ( ccda <*
             cc_design_approval | (c IN ccda.items) )) = 1)) )) = 0);
  END_RULE; -- contract_requires_approval

  RULE contract_requires_person_organization FOR (contract,
             cc_design_person_and_organization_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( c <* contract | (NOT (SIZEOF(QUERY ( ccdpoa <*
             cc_design_person_and_organization_assignment | (c IN ccdpoa.
             items) )) = 1)) )) = 0);
  END_RULE; -- contract_requires_person_organization

  RULE coordinated_assembly_and_shape FOR (next_assembly_usage_occurrence);
  WHERE
    wr1: (SIZEOF(QUERY ( nauo <* next_assembly_usage_occurrence | (NOT
             assembly_shape_is_defined(nauo,'CONFIG_CONTROL_DESIGN')) )) =
             0);
  END_RULE; -- coordinated_assembly_and_shape

  RULE dependent_instantiable_action_directive FOR (action_directive);
  WHERE
    wr1: (SIZEOF(QUERY ( ad <* action_directive | (NOT (SIZEOF(USEDIN(ad,
             '')) >= 1)) )) = 0);
  END_RULE; -- dependent_instantiable_action_directive

  RULE dependent_instantiable_approval_status FOR (approval_status);
  WHERE
    wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (SIZEOF(USEDIN(ast,
             '')) >= 1)) )) = 0);
  END_RULE; -- dependent_instantiable_approval_status

  RULE dependent_instantiable_certification_type FOR (certification_type);
  WHERE
    wr1: (SIZEOF(QUERY ( ct <* certification_type | (NOT (SIZEOF(USEDIN(ct,
             '')) >= 1)) )) = 0);
  END_RULE; -- dependent_instantiable_certification_type

  RULE dependent_instantiable_contract_type FOR (contract_type);
  WHERE
    wr1: (SIZEOF(QUERY ( ct <* contract_type | (NOT (SIZEOF(USEDIN(ct,''))
             >= 1)) )) = 0);
  END_RULE; -- dependent_instantiable_contract_type

  RULE dependent_instantiable_date FOR (date);
  WHERE
    wr1: (SIZEOF(QUERY ( dt <* date | (NOT (SIZEOF(USEDIN(dt,'')) >= 1)) ))
             = 0);
  END_RULE; -- dependent_instantiable_date

  RULE dependent_instantiable_date_time_role FOR (date_time_role);
  WHERE
    wr1: (SIZEOF(QUERY ( dtr <* date_time_role | (NOT (SIZEOF(USEDIN(dtr,
             '')) >= 1)) )) = 0);
  END_RULE; -- dependent_instantiable_date_time_role

  RULE dependent_instantiable_document_type FOR (document_type);
  WHERE
    wr1: (SIZEOF(QUERY ( dt <* document_type | (NOT (SIZEOF(USEDIN(dt,''))
             >= 1)) )) = 0);
  END_RULE; -- dependent_instantiable_document_type

  RULE dependent_instantiable_named_unit FOR (named_unit);
  WHERE
    wr1: (SIZEOF(QUERY ( nu <* named_unit | (NOT (SIZEOF(USEDIN(nu,'')) >=
              1)) )) = 0);
  END_RULE; -- dependent_instantiable_named_unit

  RULE dependent_instantiable_parametric_representation_context FOR (
             parametric_representation_context);
  WHERE
    wr1: (SIZEOF(QUERY ( prc <* parametric_representation_context | (NOT (
             SIZEOF(USEDIN(prc,'')) >= 1)) )) = 0);
  END_RULE; -- dependent_instantiable_parametric_representation_context

  RULE dependent_instantiable_person_and_organization_role FOR (
             person_and_organization_role);
  WHERE
    wr1: (SIZEOF(QUERY ( poar <* person_and_organization_role | (NOT (
             SIZEOF(USEDIN(poar,'')) >= 1)) )) = 0);
  END_RULE; -- dependent_instantiable_person_and_organization_role

  RULE dependent_instantiable_representation_item FOR
            (representation_item);
  WHERE
    wr1: (SIZEOF(QUERY ( ri <* representation_item | (NOT (SIZEOF(USEDIN(
             ri,'')) >= 1)) )) = 0);
  END_RULE; -- dependent_instantiable_representation_item

  RULE dependent_instantiable_security_classification_level FOR (
             security_classification_level);
  WHERE
    wr1: (SIZEOF(QUERY ( scl <* security_classification_level | (NOT (
             SIZEOF(USEDIN(scl,'')) >= 1)) )) = 0);
  END_RULE; -- dependent_instantiable_security_classification_level

  RULE dependent_instantiable_shape_representation FOR (
             shape_representation);
  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT (SIZEOF(USEDIN(
             sr,'')) >= 1)) )) = 0);
  END_RULE; -- dependent_instantiable_shape_representation

  RULE design_context_for_property FOR (product_definition);
  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | ((SIZEOF(USEDIN(pd,
             'CONFIG_CONTROL_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION') +
              QUERY ( pdr <* USEDIN(pd,'CONFIG_CONTROL_DESIGN.' +
             'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
              | (SIZEOF(USEDIN(pdr,
             'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION.' + 'DEFINITION'))
             >= 1) )) >= 1) AND (NOT (
             'CONFIG_CONTROL_DESIGN.DESIGN_CONTEXT' IN TYPEOF(pd.
             frame_of_reference)))) )) = 0);
  END_RULE; -- design_context_for_property

  RULE document_to_product_definition FOR (
             cc_design_specification_reference);
  WHERE
    wr1: (SIZEOF(QUERY ( sp <* cc_design_specification_reference | (NOT ((
             (('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' +
             'RELATING_DOCUMENT') IN ROLESOF(sp\document_reference.
             assigned_document)) AND (SIZEOF(QUERY ( it <* sp.items | (NOT
             ('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION' IN TYPEOF(it))) ))
             = 0)) OR (NOT (('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.'
             + 'RELATING_DOCUMENT') IN ROLESOF(sp\document_reference.
             assigned_document))))) )) = 0);
  END_RULE; -- document_to_product_definition

  RULE effectivity_requires_approval FOR (effectivity, cc_design_approval);
  WHERE
    wr1: (SIZEOF(QUERY ( eff <* effectivity | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (eff IN ccda.items) )) =
             1)) )) = 0);
  END_RULE; -- effectivity_requires_approval

  RULE geometric_representation_item_3d FOR
            (geometric_representation_item);
  WHERE
    wr1: (SIZEOF(QUERY ( gri <* geometric_representation_item | (NOT ((
             dimension_of(gri) = 3) OR (SIZEOF(QUERY ( ur <*
             using_representations(gri) | (
             'CONFIG_CONTROL_DESIGN.DEFINITIONAL_REPRESENTATION' IN TYPEOF(
             ur)) )) > 0))) )) = 0);
  END_RULE; -- geometric_representation_item_3d

  RULE global_unit_assignment FOR (global_unit_assigned_context);
  WHERE
    wr1: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT (
             SIZEOF(guac.units) = 3)) )) = 0);
    wr2: (SIZEOF(QUERY ( guac <* global_unit_assigned_context | (NOT ((
             SIZEOF(QUERY ( u <* guac.units | (
             'CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN TYPEOF(u)) )) = 1) AND
             (SIZEOF(QUERY ( u <* guac.units | (
             'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF(u)) )) = 1)
             AND (SIZEOF(QUERY ( u <* guac.units | (
             'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF(u)) ))
             = 1))) )) = 0);
  END_RULE; -- global_unit_assignment

  RULE no_shape_for_make_from FOR (design_make_from_relationship);
  WHERE
    wr1: (SIZEOF(QUERY ( dmfr <* design_make_from_relationship | (NOT (
             SIZEOF(QUERY ( pd <* USEDIN(dmfr,'CONFIG_CONTROL_DESIGN.' +
             'PROPERTY_DEFINITION.DEFINITION') | (
             'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE'
             IN TYPEOF(pd)) )) = 0)) )) = 0);
  END_RULE; -- no_shape_for_make_from

  RULE no_shape_for_supplied_part FOR (supplied_part_relationship);
  WHERE
    wr1: (SIZEOF(QUERY ( spr <* supplied_part_relationship | (NOT (SIZEOF(
             QUERY ( pd <* USEDIN(spr,'CONFIG_CONTROL_DESIGN.' +
             'PROPERTY_DEFINITION.DEFINITION') | (
             'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE'
             IN TYPEOF(pd)) )) = 0)) )) = 0);
  END_RULE; -- no_shape_for_supplied_part

  RULE product_concept_requires_configuration_item FOR (product_concept,
             configuration_item);
  WHERE
    wr1: (SIZEOF(QUERY ( pc <* product_concept | (NOT (SIZEOF(
             QUERY ( ci <* configuration_item | (pc :=: ci.item_concept) ))
             >= 1)) )) = 0);
  END_RULE; -- product_concept_requires_configuration_item

  RULE product_definition_requires_approval FOR (product_definition,
             cc_design_approval);
  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (pd IN ccda.items) ))
             = 1)) )) = 0);
  END_RULE; -- product_definition_requires_approval

  RULE product_definition_requires_date_time FOR (product_definition,
             cc_design_date_and_time_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | (pd IN
             ccdta.items) )) = 1)) )) = 0);
  END_RULE; -- product_definition_requires_date_time

  RULE product_definition_requires_person_organization FOR (
             product_definition,
             cc_design_person_and_organization_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( pd <* product_definition | (NOT (SIZEOF(
             QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
              | (pd IN ccdpoa.items) )) = 1)) )) = 0);
  END_RULE; -- product_definition_requires_person_organization

  RULE product_requires_person_organization FOR (product,
             cc_design_person_and_organization_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( ccdpoa <*
             cc_design_person_and_organization_assignment | (prod IN ccdpoa
             .items) )) = 1)) )) = 0);
  END_RULE; -- product_requires_person_organization

  RULE product_requires_product_category FOR (product,
             product_related_product_category);
  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( prpc <*
             product_related_product_category | ((prod IN prpc.products)
             AND (prpc.name IN ['assembly','inseparable_assembly','detail',
             'customer_furnished_equipment'])) )) = 1)) )) = 0);
  END_RULE; -- product_requires_product_category

  RULE product_requires_version FOR (product,
             product_definition_formation);
  WHERE
    wr1: (SIZEOF(QUERY ( prod <* product | (NOT (SIZEOF(QUERY ( pdf <*
             product_definition_formation | (prod :=: pdf.of_product) )) >=
              1)) )) = 0);
  END_RULE; -- product_requires_version

  RULE product_version_requires_approval FOR (product_definition_formation,
             cc_design_approval);
  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (
             SIZEOF(QUERY ( ccda <* cc_design_approval |
             (pdf IN ccda.items) )) = 1)) )) = 0);
  END_RULE; -- product_version_requires_approval

  RULE product_version_requires_person_organization FOR (
             product_definition_formation,
             cc_design_person_and_organization_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (
             SIZEOF(QUERY ( ccdpoa <*
             cc_design_person_and_organization_assignment | ((pdf IN ccdpoa
             .items) AND (ccdpoa.role.name = 'creator')) )) = 1)) )) = 0);
    wr2: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (
             SIZEOF(QUERY ( ccdpoa <*
             cc_design_person_and_organization_assignment | ((pdf IN ccdpoa
             .items) AND (ccdpoa.role.name IN ['design_supplier',
             'part_supplier'])) )) >= 1)) )) = 0);
  END_RULE; -- product_version_requires_person_organization

  RULE product_version_requires_security_classification FOR (
             product_definition_formation,
             cc_design_security_classification);
  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT (
             SIZEOF(QUERY ( ccdsc <* cc_design_security_classification | (
             pdf IN ccdsc.items) )) = 1)) )) = 0);
  END_RULE; -- product_version_requires_security_classification

  RULE restrict_action_request_status FOR (action_request_status);
  WHERE
    wr1: (SIZEOF(QUERY ( ars <* action_request_status | (NOT (ars.status
             IN ['proposed','in_work','issued','hold'])) )) = 0);
  END_RULE; -- restrict_action_request_status

  RULE restrict_approval_status FOR (approval_status);
  WHERE
    wr1: (SIZEOF(QUERY ( ast <* approval_status | (NOT (ast.name IN [
             'approved','not_yet_approved','disapproved','withdrawn'])) ))
             = 0);
  END_RULE; -- restrict_approval_status

  RULE restrict_certification_type FOR (certification_type);
  WHERE
    wr1: (SIZEOF(QUERY ( ct <* certification_type | (NOT (ct.description
             IN ['design_supplier','part_supplier'])) )) = 0);
  END_RULE; -- restrict_certification_type

  RULE restrict_contract_type FOR (contract_type);
  WHERE
    wr1: (SIZEOF(QUERY ( ct <* contract_type | (NOT (ct.description IN [
             'fixed_price','cost_plus'])) )) = 0);
  END_RULE; -- restrict_contract_type

  RULE restrict_date_time_role FOR (date_time_role);
  WHERE
    wr1: (SIZEOF(QUERY ( dtr <* date_time_role | (NOT (dtr.name IN [
             'creation_date','request_date','release_date','start_date',
             'contract_date','certification_date','sign_off_date',
             'classification_date','declassification_date'])) )) = 0);
  END_RULE; -- restrict_date_time_role

  RULE restrict_document_type FOR (document_type);
  WHERE
    wr1: (SIZEOF(QUERY ( dt <* document_type | (NOT (dt.product_data_type
             IN ['material_specification','process_specification',
             'design_specification','surface_finish_specification',
             'cad_filename','drawing'])) )) = 0);
  END_RULE; -- restrict_document_type

  RULE restrict_person_organization_role FOR
            (person_and_organization_role);
  WHERE
    wr1: (SIZEOF(QUERY ( por <* person_and_organization_role | (NOT (por.
             name IN ['request_recipient','initiator','part_supplier',
             'design_supplier','configuration_manager','contractor',
             'classification_officer','creator','design_owner'])) )) = 0);
  END_RULE; -- restrict_person_organization_role

  RULE restrict_product_category_value FOR (
             product_related_product_category);
  WHERE
    wr1: (SIZEOF(QUERY ( prpc <* product_related_product_category | (NOT (
             prpc.name IN ['assembly','detail',
             'customer_furnished_equipment','inseparable_assembly','cast',
             'coined','drawn','extruded','forged','formed','machined',
             'molded','rolled','sheared'])) )) = 0);
  END_RULE; -- restrict_product_category_value

  RULE restrict_security_classification_level FOR (
             security_classification_level);
  WHERE
    wr1: (SIZEOF(QUERY ( scl <* security_classification_level | (NOT (scl.
             name IN ['unclassified','classified','proprietary',
             'confidential','secret','top_secret'])) )) = 0);
  END_RULE; -- restrict_security_classification_level

  RULE security_classification_optional_date_time FOR (
             security_classification, cc_design_date_and_time_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | ((sc IN
             ccdta.items) AND ('declassification_date' = ccdta.role.name))
             )) <= 1)) )) = 0);
  END_RULE; -- security_classification_optional_date_time

  RULE security_classification_requires_approval FOR (
             security_classification, cc_design_approval);
  WHERE
    wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (sc IN ccda.items) ))
             = 1)) )) = 0);
  END_RULE; -- security_classification_requires_approval

  RULE security_classification_requires_date_time FOR (
             security_classification, cc_design_date_and_time_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | ((sc IN
             ccdta.items) AND ('classification_date' = ccdta.role.name)) ))
             = 1)) )) = 0);
  END_RULE; -- security_classification_requires_date_time

  RULE security_classification_requires_person_organization FOR (
             security_classification,
             cc_design_person_and_organization_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( sc <* security_classification | (NOT (SIZEOF(
             QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
              | (sc IN ccdpoa.items) )) = 1)) )) = 0);
  END_RULE; -- security_classification_requires_person_organization

  RULE start_request_requires_approval FOR (start_request,
             cc_design_approval);
  WHERE
    wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(
             QUERY ( ccda <* cc_design_approval | (sr IN ccda.items) ))
             = 1)) )) = 0);
  END_RULE; -- start_request_requires_approval

  RULE start_request_requires_date_time FOR (start_request,
             cc_design_date_and_time_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(
             QUERY ( ccdta <* cc_design_date_and_time_assignment | (sr IN
             ccdta.items) )) = 1)) )) = 0);
  END_RULE; -- start_request_requires_date_time

  RULE start_request_requires_person_organization FOR (start_request,
             cc_design_person_and_organization_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( sr <* start_request | (NOT (SIZEOF(
             QUERY ( ccdpoa <* cc_design_person_and_organization_assignment
              | (sr IN ccdpoa.items) )) >= 1)) )) = 0);
  END_RULE; -- start_request_requires_person_organization

  RULE start_work_requires_approval FOR (start_work, cc_design_approval);
  WHERE
    wr1: (SIZEOF(QUERY ( sw <* start_work | (NOT (SIZEOF(QUERY ( ccda <*
             cc_design_approval | (sw IN ccda.items) )) = 1)) )) = 0);
  END_RULE; -- start_work_requires_approval

  RULE start_work_requires_date_time FOR (start_work,
             cc_design_date_and_time_assignment);
  WHERE
    wr1: (SIZEOF(QUERY ( sw <* start_work | (NOT (SIZEOF(QUERY ( ccdta <*
             cc_design_date_and_time_assignment | ((sw IN ccdta.items) AND
             (ccdta.role.name = 'start_date')) )) = 1)) )) = 0);
  END_RULE; -- start_work_requires_date_time

  RULE subtype_mandatory_action FOR (action);
  WHERE
    wr1: (SIZEOF(QUERY ( act <* action | (NOT (
             'CONFIG_CONTROL_DESIGN.DIRECTED_ACTION' IN TYPEOF(act))) )) =
             0);
  END_RULE; -- subtype_mandatory_action

  RULE subtype_mandatory_effectivity FOR (effectivity);
  WHERE
    wr1: (SIZEOF(QUERY ( eff <* effectivity | (NOT ((SIZEOF([
             'CONFIG_CONTROL_DESIGN.SERIAL_NUMBERED_EFFECTIVITY',
             'CONFIG_CONTROL_DESIGN.LOT_EFFECTIVITY',
             'CONFIG_CONTROL_DESIGN.DATED_EFFECTIVITY'] * TYPEOF(eff)) = 1)
             AND ('CONFIG_CONTROL_DESIGN.CONFIGURATION_EFFECTIVITY' IN
             TYPEOF(eff)))) )) = 0);
  END_RULE; -- subtype_mandatory_effectivity

  RULE subtype_mandatory_product_context FOR (product_context);
  WHERE
    wr1: (SIZEOF(QUERY ( pc <* product_context | (NOT (
             'CONFIG_CONTROL_DESIGN.MECHANICAL_CONTEXT' IN TYPEOF(pc))) ))
             = 0);
  END_RULE; -- subtype_mandatory_product_context

  RULE subtype_mandatory_product_definition_formation FOR (
             product_definition_formation);
  WHERE
    wr1: (SIZEOF(QUERY ( pdf <* product_definition_formation | (NOT ((
             'CONFIG_CONTROL_DESIGN.' +
             'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE') IN
             TYPEOF(pdf))) )) = 0);
  END_RULE; -- subtype_mandatory_product_definition_formation

  RULE subtype_mandatory_product_definition_usage FOR (
             product_definition_usage);
  WHERE
    wr1: (SIZEOF(QUERY ( pdu <* product_definition_usage | (NOT ((
             'CONFIG_CONTROL_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE') IN
             TYPEOF(pdu))) )) = 0);
  END_RULE; -- subtype_mandatory_product_definition_usage

  RULE subtype_mandatory_representation FOR (representation);
  WHERE
    wr1: (SIZEOF(QUERY ( rep <* representation | (NOT (
             'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(rep)))
             )) = 0);
  END_RULE; -- subtype_mandatory_representation

  RULE subtype_mandatory_representation_context FOR (
             representation_context);
  WHERE
    wr1: (SIZEOF(QUERY ( rep_cntxt <* representation_context | (NOT (
             'CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN
             TYPEOF(rep_cntxt))) )) = 0);
  END_RULE; -- subtype_mandatory_representation_context

  RULE subtype_mandatory_shape_representation FOR (shape_representation);
  WHERE
    wr1: (SIZEOF(QUERY ( sr <* shape_representation | (NOT ((SIZEOF([
             'CONFIG_CONTROL_DESIGN.' +
             'ADVANCED_BREP_SHAPE_REPRESENTATION',
             'CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION',
             'CONFIG_CONTROL_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION',
             'CONFIG_CONTROL_DESIGN.' +
             'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION',
             'CONFIG_CONTROL_DESIGN.' +
             'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION',
             'CONFIG_CONTROL_DESIGN.' +
             'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
             'CONFIG_CONTROL_DESIGN.' +
             'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION'] *
             TYPEOF(sr)) = 1) OR (SIZEOF(QUERY ( it <* sr\representation.
             items | (NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN
             TYPEOF(it))) )) = 0) OR (SIZEOF(QUERY ( sdr <* QUERY ( pdr <*
             USEDIN(sr,
             'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
             'USED_REPRESENTATION') | (
             'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
             TYPEOF(pdr)) ) | (NOT (SIZEOF([
             'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT',
             'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT_RELATIONSHIP'] * TYPEOF(
             sdr.definition.definition)) = 1)) )) = 0))) )) = 0);
  END_RULE; -- subtype_mandatory_shape_representation

  RULE unique_version_change_order_rule FOR (change);
  WHERE
    wr1: (SIZEOF(QUERY ( c <* change | (NOT unique_version_change_order(c.
             assigned_action)) )) = 0);
  END_RULE; -- unique_version_change_order_rule

  RULE versioned_action_request_requires_solution FOR (
             versioned_action_request, action_request_solution);
  WHERE
    wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT (SIZEOF(
             QUERY ( ars <* action_request_solution | (ar :=: ars.request)
             )) >= 1)) )) = 0);
  END_RULE; -- versioned_action_request_requires_solution

  RULE versioned_action_request_requires_status FOR (
             versioned_action_request, action_request_status);
  WHERE
    wr1: (SIZEOF(QUERY ( ar <* versioned_action_request | (NOT (SIZEOF(
             QUERY ( ars <* action_request_status | (ar :=: ars.
             assigned_request) )) = 1)) )) = 0);
  END_RULE; -- versioned_action_request_requires_status

  FUNCTION acyclic_curve_replica(rep: curve_replica;
               parent: curve): BOOLEAN;
    IF NOT ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN RETURN(FALSE);
    ELSE
      RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
    END_IF;
  END_FUNCTION; -- acyclic_curve_replica

  FUNCTION acyclic_mapped_representation(parent_set: SET OF representation;
               children_set: SET OF representation_item): BOOLEAN;
    LOCAL
      i : INTEGER;
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z <* children_set | ('CONFIG_CONTROL_DESIGN.MAPPED_ITEM'
        IN TYPEOF(z)) );
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN
            parent_set THEN RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | (
            'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);
  END_FUNCTION; -- acyclic_mapped_representation

  FUNCTION acyclic_point_replica(rep: point_replica;
               parent: point): BOOLEAN;
    IF NOT ('CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(parent)) THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN RETURN(FALSE);
    ELSE
      RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
    END_IF;
  END_FUNCTION; -- acyclic_point_replica

  FUNCTION acyclic_product_category_relationship(
               relation: product_category_relationship;
               children: SET OF product_category): LOGICAL;
    LOCAL
      i              : INTEGER;
      x              : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(children) BY 1;
      IF relation.category :=: children[i] THEN RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category,'CONFIG_CONTROL_DESIGN.' +
        'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_category_relationship(x[i],local_children)
             THEN RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);
  END_FUNCTION; -- acyclic_product_category_relationship

  FUNCTION acyclic_product_definition_relationship(
               relation: product_definition_relationship;
               relatives: SET [1:?] OF product_definition;
               specific_relation: STRING): LOGICAL;
    LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;
    IF relation.relating_product_definition IN relatives THEN
      RETURN(FALSE);
    END_IF;
    x := QUERY ( pd <* bag_to_set(USEDIN(relation.
        relating_product_definition,'CONFIG_CONTROL_DESIGN.' +
        'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))
         | (specific_relation IN TYPEOF(pd)) );
    REPEAT i := 1 TO HIINDEX(x) BY 1;
      IF NOT acyclic_product_definition_relationship(x[i],relatives +
          relation.relating_product_definition,specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_FUNCTION; -- acyclic_product_definition_relationship

  FUNCTION acyclic_surface_replica(rep: surface_replica;
               parent: surface): BOOLEAN;
    IF NOT ('CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN RETURN(FALSE);
    ELSE
      RETURN(acyclic_surface_replica(rep,parent\surface_replica.
          parent_surface));
    END_IF;
  END_FUNCTION; -- acyclic_surface_replica

  FUNCTION assembly_shape_is_defined(assy: next_assembly_usage_occurrence;
               schma: STRING): BOOLEAN;
    LOCAL
      srr_set   : SET OF shape_representation_relationship := [];
      i         : INTEGER;
      j         : INTEGER;
      sdr_set   : SET OF shape_definition_representation := [];
      pr1_set   : SET OF property_definition := [];
      pdrel_set : SET OF product_definition_relationship := [];
      pr2_set   : SET OF property_definition := [];
    END_LOCAL;
    pr1_set := bag_to_set(USEDIN(assy.related_product_definition,schma +
        '.PROPERTY_DEFINITION.DEFINITION'));
    REPEAT i := 1 TO HIINDEX(pr1_set) BY 1;
      sdr_set := sdr_set + QUERY ( pdr <* USEDIN(pr1_set[i],schma +
          '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((schma +
          '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) );
    END_REPEAT;
    pdrel_set := bag_to_set(USEDIN(assy.related_product_definition,schma +
         '.PRODUCT_DEFINITION_RELATIONSHIP.' +
         'RELATED_PRODUCT_DEFINITION'));
    REPEAT j := 1 TO HIINDEX(pdrel_set) BY 1;
      pr2_set := pr2_set + USEDIN(pdrel_set[j],schma +
          '.PROPERTY_DEFINITION.DEFINITION');
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(pr2_set) BY 1;
      sdr_set := sdr_set + QUERY ( pdr <* USEDIN(pr2_set[i],schma +
          '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((schma +
          '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(pdr)) );
    END_REPEAT;
    IF SIZEOF(sdr_set) > 0 THEN
      REPEAT i := 1 TO HIINDEX(sdr_set) BY 1;
        srr_set := QUERY ( rr <* bag_to_set(USEDIN(sdr_set[i]\
            property_definition_representation.used_representation,schma +
            '.REPRESENTATION_RELATIONSHIP.REP_2')) | ((schma +
            '.SHAPE_REPRESENTATION_RELATIONSHIP') IN TYPEOF(rr)) );
        IF SIZEOF(srr_set) > 0 THEN
          REPEAT j := 1 TO HIINDEX(srr_set) BY 1;
            IF SIZEOF(QUERY ( pdr <* bag_to_set(USEDIN(srr_set[j]\
                representation_relationship.rep_1,schma +
                '.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
                 | ((schma + '.SHAPE_DEFINITION_REPRESENTATION') IN TYPEOF(
                pdr)) ) * QUERY ( pdr <* bag_to_set(USEDIN(assy.
                relating_product_definition,schma +
                '.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) | ((
                schma + '.SHAPE_DEFINITION_REPRESENTATION') IN
                TYPEOF(pdr)) )) >= 1 THEN
              IF SIZEOF(QUERY ( cdsr <* USEDIN(srr_set[j],schma +
                  '.CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' +
                  'REPRESENTATION_RELATION') | (NOT (cdsr\
                  context_dependent_shape_representation.
                  represented_product_relation\property_definition.
                  definition :=: assy)) )) > 0 THEN
                RETURN(FALSE);
              END_IF;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);
  END_FUNCTION; -- assembly_shape_is_defined

  FUNCTION associated_surface(arg: pcurve_or_surface): surface;
    LOCAL
      surf : surface;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(arg) THEN
      surf := arg.basis_surface;
    ELSE
      surf := arg;
    END_IF;
    RETURN(surf);
  END_FUNCTION; -- associated_surface

  FUNCTION bag_to_set(the_bag: BAG OF GENERIC:intype
      ): SET OF GENERIC:intype;
    LOCAL
      i       : INTEGER;
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);
  END_FUNCTION; -- bag_to_set

  FUNCTION base_axis(dim: INTEGER; axis1, axis2, axis3: direction
      ): LIST [2:3] OF direction;
    LOCAL
      u      : LIST [2:3] OF direction;
      d1     : direction;
      d2     : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      d1 := NVL(normalise(axis3),dummy_gri || direction([0,0,1]));
      d2 := first_proj_axis(d1,axis1);
      u := [d2,second_proj_axis(d1,d2,axis2),d1];
    ELSE
      IF EXISTS(axis1) THEN
        d1 := normalise(axis1);
        u := [d1,orthogonal_complement(d1)];
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor < 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          d1 := normalise(axis2);
          u := [orthogonal_complement(d1),d1];
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u := [dummy_gri || direction([1,0]),dummy_gri ||
          direction([0,1])];
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);
  END_FUNCTION; -- base_axis

  FUNCTION boolean_choose(b: BOOLEAN;
               choice1, choice2: GENERIC:item): GENERIC:item;
    IF b THEN
      RETURN(choice1);
    ELSE
      RETURN(choice2);
    END_IF;
  END_FUNCTION; -- boolean_choose

  FUNCTION build_2axes(ref_direction: direction): LIST [2:2] OF direction;
    LOCAL
      d : direction := NVL(normalise(ref_direction),dummy_gri ||
           direction([1,0]));
    END_LOCAL;
    RETURN([d,orthogonal_complement(d)]);
  END_FUNCTION; -- build_2axes

  FUNCTION build_axes(axis, ref_direction: direction
      ): LIST [3:3] OF direction;
    LOCAL
      d1 : direction;
      d2 : direction;
    END_LOCAL;
    d1 := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    d2 := first_proj_axis(d1,ref_direction);
    RETURN([d2,normalise(cross_product(d1,d2)).orientation,d1]);
  END_FUNCTION; -- build_axes

  FUNCTION cc_design_date_time_correlation
    (e : cc_design_date_and_time_assignment ) : BOOLEAN;
    LOCAL
      dt_role : STRING;
    END_LOCAL;
      dt_role := e\date_and_time_assignment.role.name;
    CASE dt_role OF
      'creation_date'         : IF SIZEOF (e.items) <>
                                  SIZEOF (QUERY (x <* e.items |
                                  'CONFIG_CONTROL_DESIGN.' +
                                  'PRODUCT_DEFINITION'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      'request_date'         : IF SIZEOF (e.items) <>
                                  SIZEOF (QUERY (x <* e.items |
                                  SIZEOF (
                                  ['CONFIG_CONTROL_DESIGN.CHANGE_REQUEST',
                                  'CONFIG_CONTROL_DESIGN.START_REQUEST'] *
                                  TYPEOF (x)) = 1))
                                  THEN RETURN(FALSE);
                                END_IF;
      'release_date'         : IF SIZEOF (e.items) <>
                                  SIZEOF (QUERY (x <* e.items |
                                  SIZEOF (
                                  ['CONFIG_CONTROL_DESIGN.CHANGE',
                                  'CONFIG_CONTROL_DESIGN.START_WORK'] *
                                  TYPEOF (x)) = 1))
                                  THEN RETURN(FALSE);
                                END_IF;
      'start_date'          : IF SIZEOF (e.items) <>
                                  SIZEOF (QUERY (x <* e.items |
                                  SIZEOF (
                                  ['CONFIG_CONTROL_DESIGN.CHANGE',
                                  'CONFIG_CONTROL_DESIGN.START_WORK'] *
                                  TYPEOF (x)) = 1))
                                  THEN RETURN(FALSE);
                                END_IF;
      'sign_off_date'         : IF SIZEOF (e.items) <>
                                  SIZEOF (QUERY (x <* e.items |
                                  'CONFIG_CONTROL_DESIGN.' +
                                  'APPROVAL_PERSON_ORGANIZATION'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      'contract_date'         : IF SIZEOF (e.items) <>
                                  SIZEOF (QUERY (x <* e.items |
                                  'CONFIG_CONTROL_DESIGN.CONTRACT'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      'certification_date'    : IF SIZEOF (e.items) <>
                                  SIZEOF (QUERY (x <* e.items |
                                  'CONFIG_CONTROL_DESIGN.CERTIFICATION'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      'classification_date'   : IF SIZEOF (e.items) <>
                                  SIZEOF (QUERY (x <* e.items |
                                  'CONFIG_CONTROL_DESIGN.' +
                                  'SECURITY_CLASSIFICATION'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      'declassification_date' : IF SIZEOF (e.items) <>
                                  SIZEOF (QUERY (x <* e.items |
                                  'CONFIG_CONTROL_DESIGN.' +
                                  'SECURITY_CLASSIFICATION'
                                  IN TYPEOF (x)))
                                  THEN RETURN(FALSE);
                                END_IF;
      OTHERWISE : RETURN(TRUE);
    END_CASE;
    RETURN (TRUE);
  END_FUNCTION;  -- cc_design_date_time_correlation

  FUNCTION cc_design_person_and_organization_correlation
     (e : cc_design_person_and_organization_assignment ) : BOOLEAN;
     LOCAL
       po_role : STRING;
     END_LOCAL;
       po_role := e\person_and_organization_assignment.role.name;
     CASE po_role OF
      'request_recipient'      : IF SIZEOF (e.items) <>
                                   SIZEOF (QUERY (x <* e.items |
                                   SIZEOF(['CONFIG_CONTROL_DESIGN.' +
                                   'CHANGE_REQUEST',
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'START_REQUEST'] *
                                   TYPEOF (x)) = 1))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'initiator'              : IF SIZEOF (e.items) <>
                                   SIZEOF (QUERY (x <* e.items |
                                   SIZEOF(['CONFIG_CONTROL_DESIGN.' +
                                   'CHANGE_REQUEST',
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'START_REQUEST',
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'START_WORK',
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'CHANGE'] *
                                   TYPEOF (x)) = 1))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'creator'                : IF SIZEOF (e.items) <>
                                   SIZEOF (QUERY (x <* e.items |
                                   SIZEOF (['CONFIG_CONTROL_DESIGN.' +
                                   'PRODUCT_DEFINITION_FORMATION',
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'PRODUCT_DEFINITION'] *
                                   TYPEOF (x)) = 1))
                                   THEN RETURN (FALSE);
                                 END_IF;
      'part_supplier'          : IF SIZEOF (e.items) <>
                                   SIZEOF (QUERY (x <* e.items |
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'PRODUCT_DEFINITION_FORMATION'
                                   IN TYPEOF (x)))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'design_supplier'        : IF SIZEOF (e.items) <>
                                   SIZEOF (QUERY (x <* e.items |
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'PRODUCT_DEFINITION_FORMATION'
                                   IN TYPEOF (x)))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'design_owner'           : IF SIZEOF (e.items) <>
                                   SIZEOF (QUERY (x <* e.items |
                                   'CONFIG_CONTROL_DESIGN.PRODUCT'
                                   IN TYPEOF (x)))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'configuration_manager'  : IF SIZEOF (e.items) <>
                                   SIZEOF (QUERY (x <* e.items |
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'CONFIGURATION_ITEM'
                                   IN TYPEOF (x)))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'contractor'             : IF SIZEOF (e.items) <>
                                   SIZEOF (QUERY (x <* e.items |
                                   'CONFIG_CONTROL_DESIGN.CONTRACT'
                                   IN TYPEOF (x)))
                                   THEN RETURN(FALSE);
                                 END_IF;
      'classification_officer' : IF SIZEOF (e.items) <>
                                   SIZEOF (QUERY (x <* e.items |
                                   'CONFIG_CONTROL_DESIGN.' +
                                   'SECURITY_CLASSIFICATION'
                                   IN TYPEOF (x))) THEN
                                   RETURN(FALSE);
                                 END_IF;
      OTHERWISE : RETURN(TRUE);
    END_CASE;
    RETURN (TRUE);
  END_FUNCTION; -- cc_design_person_and_organization_correlation

  FUNCTION closed_shell_reversed(a_shell: closed_shell
      ): oriented_closed_shell;
    LOCAL
      the_reverse : oriented_closed_shell;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() ||
          oriented_closed_shell(a_shell\oriented_closed_shell.
          closed_shell_element,NOT a_shell\oriented_closed_shell.
          orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() ||
          oriented_closed_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);
  END_FUNCTION; -- closed_shell_reversed

  FUNCTION conditional_reverse(p: BOOLEAN;
               an_item: reversible_topology): reversible_topology;
    IF p THEN RETURN(an_item);
    ELSE
      RETURN(topology_reversed(an_item));
    END_IF;
  END_FUNCTION; -- conditional_reverse

  FUNCTION constraints_composite_curve_on_surface(
               c: composite_curve_on_surface): BOOLEAN;
    LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
    END_LOCAL;
    REPEAT k := 1 TO n_segments BY 1;
      IF (NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c\composite_curve.
          segments[k].parent_curve))) AND (NOT (
          'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c\composite_curve
          .segments[k].parent_curve))) AND (NOT (
          'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  END_FUNCTION; -- constraints_composite_curve_on_surface

  FUNCTION constraints_geometry_shell_based_surface_model(
               m: shell_based_surface_model): BOOLEAN;
    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
      IF (NOT ('CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(m.
          sbsm_boundary[j]))) AND (NOT (
          'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);
  END_FUNCTION; -- constraints_geometry_shell_based_surface_model

  FUNCTION constraints_geometry_shell_based_wireframe_model(
               m: shell_based_wireframe_model): BOOLEAN;
    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
      IF (NOT ('CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(m.
          sbwm_boundary[j]))) AND (NOT (
          'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN
          TYPEOF(m.sbwm_boundary[j])))
          THEN result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);
  END_FUNCTION; -- constraints_geometry_shell_based_wireframe_model

  FUNCTION constraints_param_b_spline(degree, up_knots, up_cp: INTEGER;
               knot_mult: LIST OF INTEGER;
               knots: LIST OF parameter_value): BOOLEAN;
    LOCAL
      k      : INTEGER;
      sum    : INTEGER;
      result : BOOLEAN := TRUE;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (
        degree + up_cp + 2)) THEN result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[1];
    IF (k < 1) OR (k > (degree + 1)) THEN result := FALSE;
      RETURN(result);
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      k := knot_mult[i];
      IF (i < up_knots) AND (k > degree) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      IF (i = up_knots) AND (k > (degree + 1)) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);
  END_FUNCTION; -- constraints_param_b_spline

  FUNCTION constraints_rectangular_composite_surface(
               s: rectangular_composite_surface): BOOLEAN;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF NOT (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(s.
            segments[i][j].parent_surface)) OR (
            'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s
            .segments[i][j].parent_surface))) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u - 1 BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF s.segments[i][j].u_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v - 1 BY 1;
        IF s.segments[i][j].v_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(TRUE);
  END_FUNCTION; -- constraints_rectangular_composite_surface

  FUNCTION cross_product(arg1, arg2: direction): vector;
    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res := dummy_gri || direction([(v1[2] * v2[3]) - (v1[3] * v2[2]),(
            v1[3] * v2[1]) - (v1[1] * v2[3]),(v1[1] * v2[2]) - (v1[2] * v2[
            1])]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(arg1,0);
        END_IF;
        RETURN(result);
      END;
    END_IF;
  END_FUNCTION; -- cross_product

  FUNCTION curve_weights_positive(b: rational_b_spline_curve): BOOLEAN;
    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
      IF b.weights[i] <= 0 THEN result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);
  END_FUNCTION; -- curve_weights_positive

  FUNCTION derive_dimensional_exponents(x: unit): dimensional_exponents;
    LOCAL
      i      : INTEGER;
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,0);
    END_LOCAL;
      result := x.dimensions;
    RETURN(result);
  END_FUNCTION; -- derive_dimensional_exponents

  FUNCTION dimension_of(item: geometric_representation_item
      ): dimension_count;
    LOCAL
      x : SET OF representation;
      y : representation_context;
    END_LOCAL;
    x := using_representations(item);
    y := x[1].context_of_items;
    RETURN(y\geometric_representation_context.coordinate_space_dimension);
  END_FUNCTION; -- dimension_of

  FUNCTION dimensions_for_si_unit(n: si_unit_name
      ): dimensional_exponents;
    CASE n OF
      metre          :    RETURN(dimensional_exponents(1,0,0,0,0,0,0));
      gram           :    RETURN(dimensional_exponents(0,1,0,0,0,0,0));
      second         :    RETURN(dimensional_exponents(0,0,1,0,0,0,0));
      ampere         :    RETURN(dimensional_exponents(0,0,0,1,0,0,0));
      kelvin         :    RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      mole           :    RETURN(dimensional_exponents(0,0,0,0,0,1,0));
      candela        :    RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      radian         :    RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      steradian      :    RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      hertz          :    RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      newton         :    RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
      pascal         :    RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
      joule          :    RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
      watt           :    RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
      coulomb        :    RETURN(dimensional_exponents(0,0,1,1,0,0,0));
      volt           :    RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
      farad          :    RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
      ohm            :    RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
      siemens        :    RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
      weber          :    RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
      tesla          :    RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
      henry          :    RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
      degree_celsius :    RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      lumen          :    RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      lux            :    RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
      becquerel      :    RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      gray           :    RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      sievert        :    RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      END_CASE;
  END_FUNCTION; -- dimensions_for_si_unit

  FUNCTION dot_product(arg1, arg2: direction): REAL;
    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim <> arg2.dim THEN scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);
  END_FUNCTION; -- dot_product

  FUNCTION edge_reversed(an_edge: edge): oriented_edge;
    LOCAL
      the_reverse : oriented_edge;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start)
          || oriented_edge(an_edge\oriented_edge.edge_element,NOT an_edge\
          oriented_edge.orientation);
    ELSE
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start)
          || oriented_edge(an_edge,FALSE);
    END_IF;
    RETURN(the_reverse);
  END_FUNCTION; -- edge_reversed

  FUNCTION face_bound_reversed(a_face_bound: face_bound): face_bound;
    LOCAL
      the_reverse : face_bound;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)
         THEN
      the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound,
          NOT a_face_bound\face_bound.orientation) || face_outer_bound();
    ELSE
      the_reverse := dummy_tri || face_bound(a_face_bound.bound,NOT
          a_face_bound.orientation);
    END_IF;
    RETURN(the_reverse);
  END_FUNCTION; -- face_bound_reversed

  FUNCTION face_reversed(a_face: face): oriented_face;
    LOCAL
      the_reverse : oriented_face;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF(a_face) THEN
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face\oriented_face.face_element,NOT
          a_face\oriented_face.orientation);
    ELSE
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face,FALSE);
    END_IF;
    RETURN(the_reverse);
  END_FUNCTION; -- face_reversed

  FUNCTION first_proj_axis(z_axis, arg: direction): direction;
    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF NOT EXISTS(z_axis) THEN RETURN(?);
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z.direction_ratios <> [1,0,0] THEN
          v := dummy_gri || direction([1,0,0]);
        ELSE
          v := dummy_gri || direction([0,1,0]);
        END_IF;
      ELSE
        IF arg.dim <> 3 THEN RETURN(?);
        END_IF;
        IF cross_product(arg,z).magnitude = 0 THEN RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);
  END_FUNCTION; -- first_proj_axis

  FUNCTION gbsf_check_curve(cv: curve): BOOLEAN;
    IF SIZEOF(['CONFIG_CONTROL_DESIGN.BOUNDED_CURVE',
        'CONFIG_CONTROL_DESIGN.CONIC',
        'CONFIG_CONTROL_DESIGN.CURVE_REPLICA',
        'CONFIG_CONTROL_DESIGN.LINE',
        'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
      RETURN(FALSE);
    ELSE
      IF SIZEOF(['CONFIG_CONTROL_DESIGN.CIRCLE',
          'CONFIG_CONTROL_DESIGN.ELLIPSE'] * TYPEOF(cv)) = 1 THEN
        RETURN(TRUE);
      ELSE
        IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv
            \b_spline_curve.self_intersect = FALSE)) OR (cv\b_spline_curve.
            self_intersect = UNKNOWN) THEN
          RETURN(TRUE);
        ELSE
          IF (('CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE' IN TYPEOF(cv)) AND
              (cv\composite_curve.self_intersect = FALSE)) OR (cv\
              composite_curve.self_intersect = UNKNOWN) THEN
            RETURN(SIZEOF(QUERY ( seg <* cv\composite_curve.segments | (
                NOT gbsf_check_curve(seg.parent_curve)) )) = 0);
          ELSE
            IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(cv) THEN
              RETURN(gbsf_check_curve(cv\curve_replica.parent_curve));
            ELSE
              IF ('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv))
                  AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\
                  offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (
                  'CONFIG_CONTROL_DESIGN.POLYLINE' IN
                  TYPEOF(cv.basis_curve))) THEN
                RETURN(gbsf_check_curve(cv\offset_curve_3d.basis_curve));
              ELSE
                IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv) THEN
                  RETURN(gbsf_check_curve(cv\pcurve.reference_to_curve\
                      representation.items[1]) AND gbsf_check_surface(cv\
                      pcurve.basis_surface));
                ELSE
                  IF 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv) THEN
                    IF SIZEOF(cv\polyline.points) >= 3 THEN
                      RETURN(TRUE);
                    END_IF;
                  ELSE
                    IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(cv)
                         THEN
                      IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                        REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                            associated_geometry) BY 1;
                          IF 'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(cv\
                              surface_curve.associated_geometry[i]) THEN
                            IF NOT gbsf_check_surface(cv\surface_curve.
                                associated_geometry[i]) THEN
                              RETURN(FALSE);
                            END_IF;
                          ELSE
                            IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv
                                \surface_curve.associated_geometry[i])
                                 THEN
                              IF NOT gbsf_check_curve(cv\surface_curve.
                                  associated_geometry[i]) THEN
                                RETURN(FALSE);
                              END_IF;
                            END_IF;
                          END_IF;
                        END_REPEAT;
                        RETURN(TRUE);
                      END_IF;
                    ELSE
                      IF 'CONFIG_CONTROL_DESIGN.TRIMMED_CURVE' IN TYPEOF(
                          cv) THEN
                        IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',
                            'CONFIG_CONTROL_DESIGN.PARABOLA',
                            'CONFIG_CONTROL_DESIGN.HYPERBOLA'] * TYPEOF(cv\
                            trimmed_curve.basis_curve)) = 1 THEN
                          RETURN(TRUE);
                        ELSE
                          RETURN(gbsf_check_curve(cv\trimmed_curve.
                              basis_curve));
                        END_IF;
                      END_IF;
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_FUNCTION; -- gbsf_check_curve

  FUNCTION gbsf_check_point(pnt: point): BOOLEAN;
    IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
        RETURN(gbsf_check_curve(pnt\point_on_curve.basis_curve));
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN
          RETURN(gbsf_check_surface(pnt\point_on_surface.basis_surface));
        ELSE
          IF 'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE' IN TYPEOF(pnt)
               THEN
            RETURN(gbsf_check_curve(pnt\degenerate_pcurve.
                reference_to_curve\representation.items[1]) AND
                gbsf_check_surface(pnt\degenerate_pcurve.basis_surface));
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_FUNCTION; -- gbsf_check_point

  FUNCTION gbsf_check_surface(sf: surface): BOOLEAN;
    IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\
        b_spline_surface.self_intersect = FALSE)) OR (sf\b_spline_surface.
        self_intersect = UNKNOWN) THEN RETURN(TRUE);
    ELSE
      IF SIZEOF(['CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE',
          'CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 1 THEN
        RETURN(TRUE);
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf)
             THEN
          IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONICAL_SURFACE',
              'CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE',
              'CONFIG_CONTROL_DESIGN.PLANE'] * TYPEOF(sf\
              curve_bounded_surface.basis_surface)) = 1 THEN
            RETURN(SIZEOF(QUERY ( bcurve <* sf\curve_bounded_surface.
                boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);
          ELSE
            IF gbsf_check_surface(sf\curve_bounded_surface.basis_surface)
                 THEN
              RETURN(SIZEOF(QUERY ( bcurve <* sf\curve_bounded_surface.
                  boundaries | (NOT gbsf_check_curve(bcurve)) )) = 0);
            END_IF;
          END_IF;
        ELSE
          IF (('CONFIG_CONTROL_DESIGN.OFFSET_SURFACE' IN TYPEOF(sf)) AND (
              sf\offset_surface.self_intersect = FALSE)) OR (sf\
              offset_surface.self_intersect = UNKNOWN) THEN
            RETURN(gbsf_check_surface(sf\offset_surface.basis_surface));
          ELSE
            IF 'CONFIG_CONTROL_DESIGN.RECTANGULAR_COMPOSITE_SURFACE' IN
                TYPEOF(sf) THEN
              REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.
                  segments) BY 1;
                REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.
                    segments[i]) BY 1;
                  IF NOT gbsf_check_surface(sf\
                      rectangular_composite_surface.segments[i][j].
                      parent_surface) THEN RETURN(FALSE);
                  END_IF;
                END_REPEAT;
              END_REPEAT;
              RETURN(TRUE);
            ELSE
              IF 'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN
                  TYPEOF(sf) THEN
                IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONICAL_SURFACE',
                    'CONFIG_CONTROL_DESIGN.CYLINDRICAL_SURFACE',
                    'CONFIG_CONTROL_DESIGN.PLANE'] * TYPEOF(sf\
                    rectangular_trimmed_surface.basis_surface)) = 1 THEN
                  RETURN(TRUE);
                ELSE
                  RETURN(gbsf_check_surface(sf\rectangular_trimmed_surface
                      .basis_surface));
                END_IF;
              ELSE
                IF 'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(sf)
                     THEN
                  RETURN(gbsf_check_surface(sf\surface_replica.
                      parent_surface));
                ELSE
                  IF 'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(sf)
                       THEN
                    RETURN(gbsf_check_curve(sf\swept_surface.swept_curve));
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_FUNCTION; -- gbsf_check_surface

  FUNCTION get_basis_surface(c: curve_on_surface): SET [0:2] OF surface;
    LOCAL
      surfs : SET [0:2] OF surface;
      n     : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c) THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c) THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n BY 1;
          surfs := surfs + associated_surface(c\surface_curve.
              associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
         THEN
      n := SIZEOF(c\composite_curve.segments);
      surfs := get_basis_surface(c\composite_curve.segments[1].
          parent_curve);
      IF n > 1 THEN
        REPEAT i := 2 TO n BY 1;
          surfs := surfs * get_basis_surface(c\composite_curve.segments[i]
              .parent_curve);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(surfs);
  END_FUNCTION; -- get_basis_surface

  FUNCTION item_in_context(item: representation_item;
               cntxt: representation_context): BOOLEAN;
    LOCAL
      i : INTEGER;
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS') *
        cntxt.representations_in_context) > 0 THEN RETURN(TRUE);
    ELSE
      y := QUERY ( z <* USEDIN(item,'') | (
          'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
      IF SIZEOF(y) > 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_FUNCTION; -- item_in_context

  FUNCTION leap_year(year: year_number): BOOLEAN;
    IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
         0) THEN RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;
  END_FUNCTION; -- leap_year

  FUNCTION list_face_loops(f: face): LIST [0:?] OF loop;
    LOCAL
      loops : LIST [0:?] OF loop := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
      loops := loops + f.bounds[i].bound;
    END_REPEAT;
    RETURN(loops);
  END_FUNCTION; -- list_face_loops

  FUNCTION list_of_topology_reversed(
               a_list: list_of_reversible_topology_item
      ): list_of_reversible_topology_item;
    LOCAL
      the_reverse : list_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_list) BY 1;
      the_reverse := topology_reversed(a_list[i]) + the_reverse;
    END_REPEAT;
    RETURN(the_reverse);
  END_FUNCTION; -- list_of_topology_reversed

  FUNCTION list_to_array(lis: LIST [0:?] OF GENERIC:t;
               low, u: INTEGER): ARRAY OF GENERIC:t;
    LOCAL
      n   : INTEGER;
      res : ARRAY [low:u] OF GENERIC:t;
    END_LOCAL;
    n := SIZEOF(lis);
    IF n <> ((u - low) + 1) THEN RETURN(?);
    ELSE
      res := [lis[1],n];
      REPEAT i := 2 TO n BY 1;
        res[(low + i) - 1] := lis[i];
      END_REPEAT;
      RETURN(res);
    END_IF;
  END_FUNCTION; -- list_to_array

  FUNCTION list_to_set(l: LIST [0:?] OF GENERIC:t): SET OF GENERIC:t;
    LOCAL
      s : SET OF GENERIC:t := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(l) BY 1;
      s := s + l[i];
    END_REPEAT;
    RETURN(s);
  END_FUNCTION; -- list_to_set

  FUNCTION make_array_of_array(lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;
               low1, u1, low2, u2: INTEGER): ARRAY OF ARRAY OF GENERIC:t;
    LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
    END_LOCAL;
    IF ((u1 - low1) + 1) <> SIZEOF(lis) THEN RETURN(?);
    END_IF;
    IF ((u2 - low2) + 1) <> SIZEOF(lis[1]) THEN RETURN(?);
    END_IF;
    res := [list_to_array(lis[1],low2,u2),(u1 - low1) + 1];
    REPEAT i := 2 TO HIINDEX(lis) BY 1;
      IF ((u2 - low2) + 1) <> SIZEOF(lis[i]) THEN RETURN(?);
      END_IF;
      res[(low1 + i) - 1] := list_to_array(lis[i],low2,u2);
    END_REPEAT;
    RETURN(res);
  END_FUNCTION; -- make_array_of_array

  FUNCTION mixed_loop_type_set(l: SET [0:?] OF loop): LOGICAL;
    LOCAL
      poly_loop_type : LOGICAL;
    END_LOCAL;
    IF SIZEOF(l) <= 1 THEN RETURN(FALSE);
    END_IF;
    poly_loop_type := 'CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[1]);
    REPEAT i := 2 TO SIZEOF(l) BY 1;
      IF ('CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[i])) <>
          poly_loop_type THEN RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);
  END_FUNCTION; -- mixed_loop_type_set

  FUNCTION msb_shells(brep: manifold_solid_brep
      ): SET [1:?] OF closed_shell;
    IF SIZEOF(QUERY ( msbtype <* TYPEOF(brep) | (msbtype LIKE
        '*BREP_WITH_VOIDS') )) >= 1 THEN
      RETURN(brep\brep_with_voids.voids + brep.outer);
    ELSE
      RETURN([brep.outer]);
    END_IF;
  END_FUNCTION; -- msb_shells

  FUNCTION msf_curve_check(cv: curve): BOOLEAN;
    IF SIZEOF(['CONFIG_CONTROL_DESIGN.BOUNDED_CURVE',
        'CONFIG_CONTROL_DESIGN.CONIC',
        'CONFIG_CONTROL_DESIGN.CURVE_REPLICA',
        'CONFIG_CONTROL_DESIGN.LINE',
        'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
      RETURN(FALSE);
    ELSE
      IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\
          b_spline_curve.self_intersect = FALSE)) OR (cv\b_spline_curve.
          self_intersect = UNKNOWN) THEN RETURN(TRUE);
      ELSE
        IF SIZEOF(['CONFIG_CONTROL_DESIGN.CONIC',
            'CONFIG_CONTROL_DESIGN.LINE'] * TYPEOF(cv)) = 1 THEN
          RETURN(TRUE);
        ELSE
          IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(cv) THEN
            RETURN(msf_curve_check(cv\curve_replica.parent_curve));
          ELSE
            IF ('CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND
                 ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\
                offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (
                'CONFIG_CONTROL_DESIGN.POLYLINE'
                IN TYPEOF(cv.basis_curve))) THEN
              RETURN(msf_curve_check(cv\offset_curve_3d.basis_curve));
            ELSE
              IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv) THEN
                RETURN(msf_curve_check(cv\pcurve.reference_to_curve\
                    representation.items[1]) AND msf_surface_check(cv\
                    pcurve.basis_surface));
              ELSE
                IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(cv)
                     THEN
                  IF msf_curve_check(cv\surface_curve.curve_3d) THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                        associated_geometry) BY 1;
                      IF 'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(cv\
                          surface_curve.associated_geometry[i]) THEN
                        IF NOT msf_surface_check(cv\surface_curve.
                            associated_geometry[i]) THEN
                          RETURN(FALSE);
                        END_IF;
                      ELSE
                        IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(cv\
                            surface_curve.associated_geometry[i]) THEN
                          IF NOT msf_curve_check(cv\surface_curve.
                              associated_geometry[i]) THEN
                            RETURN(FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN(TRUE);
                  END_IF;
                ELSE
                  IF 'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(cv) THEN
                    IF SIZEOF(cv\polyline.points) >= 3 THEN
                      RETURN(TRUE);
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_FUNCTION; -- msf_curve_check

  FUNCTION msf_surface_check(surf: surface): BOOLEAN;
    IF 'CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
      RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN TYPEOF(surf) THEN
        RETURN(msf_curve_check(surf\swept_surface.swept_curve));
      ELSE
        IF (('CONFIG_CONTROL_DESIGN.OFFSET_SURFACE' IN TYPEOF(surf)) AND (
            surf\offset_surface.self_intersect = FALSE)) OR (surf\
            offset_surface.self_intersect = UNKNOWN) THEN
          RETURN(msf_surface_check(surf\offset_surface.basis_surface));
        ELSE
          IF 'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(surf) THEN
            RETURN(msf_surface_check(surf\surface_replica.parent_surface));
          ELSE
            IF (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(surf))
                AND (surf\b_spline_surface.self_intersect = FALSE)) OR (
                surf\b_spline_surface.self_intersect = UNKNOWN) THEN
              RETURN(TRUE);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_FUNCTION; -- msf_surface_check

  FUNCTION normalise(arg: vector_or_direction): vector_or_direction;
    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN result := ?;
    ELSE
      ndim := arg.dim;
      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
          v := dummy_gri || direction(arg.orientation.direction_ratios);
          IF arg.magnitude = 0 THEN RETURN(?);
          ELSE
            vec := dummy_gri || vector(v,1);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction(arg.direction_ratios);
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);
  END_FUNCTION; -- normalise

  FUNCTION open_shell_reversed(a_shell: open_shell): oriented_open_shell;
    LOCAL
      the_reverse : oriented_open_shell;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() ||
          oriented_open_shell(a_shell\oriented_open_shell.
          open_shell_element,NOT a_shell\oriented_open_shell.orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() ||
          oriented_open_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);
  END_FUNCTION; -- open_shell_reversed

  FUNCTION orthogonal_complement(vec: direction): direction;
    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN RETURN(?);
    ELSE
      result := dummy_gri || direction([-vec.direction_ratios[2],vec.
          direction_ratios[1]]);
      RETURN(result);
    END_IF;
  END_FUNCTION; -- orthogonal_complement

  FUNCTION path_head_to_tail(a_path: path): LOGICAL;
    LOCAL
      n : INTEGER;
      p : BOOLEAN := TRUE;
    END_LOCAL;
    n := SIZEOF(a_path.edge_list);
    REPEAT i := 2 TO n BY 1;
      p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
          .edge_start);
    END_REPEAT;
    RETURN(p);
  END_FUNCTION; -- path_head_to_tail

  FUNCTION path_reversed(a_path: path): oriented_path;
    LOCAL
      the_reverse : oriented_path;
    END_LOCAL;
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF(a_path) THEN
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path\oriented_path.path_element,
          NOT a_path\oriented_path.orientation);
    ELSE
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path,FALSE);
    END_IF;
    RETURN(the_reverse);
  END_FUNCTION; -- path_reversed

  FUNCTION scalar_times_vector(scalar: REAL;
               vec: vector_or_direction): vector;
    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN RETURN(?);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(vec) THEN
        v := dummy_gri || direction(vec.orientation.direction_ratios);
        mag := scalar * vec.magnitude;
      ELSE
        v := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF mag < 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v),mag);
    END_IF;
    RETURN(result);
  END_FUNCTION; -- scalar_times_vector

  FUNCTION second_proj_axis(z_axis, x_axis, arg: direction
      ): direction;
    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := dummy_gri || direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);
  END_FUNCTION; -- second_proj_axis

  FUNCTION set_of_topology_reversed(a_set: set_of_reversible_topology_item
      ): set_of_reversible_topology_item;
    LOCAL
      the_reverse : set_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_set) BY 1;
      the_reverse := the_reverse + topology_reversed(a_set[i]);
    END_REPEAT;
    RETURN(the_reverse);
  END_FUNCTION; -- set_of_topology_reversed

  FUNCTION shell_reversed(a_shell: shell): shell;
    IF 'CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(a_shell) THEN
      RETURN(open_shell_reversed(a_shell));
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
        RETURN(closed_shell_reversed(a_shell));
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
  END_FUNCTION; -- shell_reversed

  FUNCTION surface_weights_positive(b: rational_b_spline_surface
      ): BOOLEAN;
    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        IF b.weights[i][j] <= 0 THEN result := FALSE;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);
  END_FUNCTION; -- surface_weights_positive

  FUNCTION topology_reversed(an_item: reversible_topology
      ): reversible_topology;
    IF 'CONFIG_CONTROL_DESIGN.EDGE' IN TYPEOF(an_item) THEN
      RETURN(edge_reversed(an_item));
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.PATH' IN TYPEOF(an_item) THEN
      RETURN(path_reversed(an_item));
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.FACE_BOUND' IN TYPEOF(an_item) THEN
      RETURN(face_bound_reversed(an_item));
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.FACE' IN TYPEOF(an_item) THEN
      RETURN(face_reversed(an_item));
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.SHELL' IN TYPEOF(an_item) THEN
      RETURN(shell_reversed(an_item));
    END_IF;
    IF 'SET' IN TYPEOF(an_item) THEN
      RETURN(set_of_topology_reversed(an_item));
    END_IF;
    IF 'LIST' IN TYPEOF(an_item) THEN
      RETURN(list_of_topology_reversed(an_item));
    END_IF;
    RETURN(?);
  END_FUNCTION; -- topology_reversed

  FUNCTION unique_version_change_order(c: action): BOOLEAN;
    LOCAL
      ords     : action_directive := c\directed_action.directive;
      assign   : SET OF change_request := [];
      versions : SET OF product_definition_formation := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(ords.requests) BY 1;
      assign := assign + QUERY ( ara <* bag_to_set(USEDIN(ords.requests[i],
          'CONFIG_CONTROL_DESIGN.ACTION_REQUEST_ASSIGNMENT.' +
          'ASSIGNED_ACTION_REQUEST')) | (
          'CONFIG_CONTROL_DESIGN.CHANGE_REQUEST' IN TYPEOF(ara)) );
    END_REPEAT;
    REPEAT k := 1 TO SIZEOF(assign) BY 1;
      versions := versions + assign[k].items;
    END_REPEAT;
    RETURN(SIZEOF(QUERY ( vers <* versions | (NOT (SIZEOF(
        QUERY ( other_vers <* (versions - vers) | (vers.of_product :=:
        other_vers.of_product) )) = 0)) )) = 0);
  END_FUNCTION; -- unique_version_change_order

  FUNCTION using_items(item: founded_item_select;
               checked_items: SET OF founded_item_select
      ): SET OF founded_item_select;
    LOCAL
      next_items      : SET OF founded_item_select;
      new_check_items : SET OF founded_item_select;
      result_items    : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    next_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | ((
        'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) OR (
        'CONFIG_CONTROL_DESIGN.FOUNDED_ITEM' IN TYPEOF(z))) );
    IF SIZEOF(next_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(next_items) BY 1;
        IF NOT (next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] + using_items(
              next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result_items);
  END_FUNCTION; -- using_items

  FUNCTION using_representations(item: founded_item_select
      ): SET OF representation;
    LOCAL
      results            : SET OF representation;
      intermediate_items : SET OF founded_item_select;
      result_bag         : BAG OF representation;
    END_LOCAL;
    results := [];
    result_bag := USEDIN(item,
    'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := using_items(item,[]);
    IF SIZEOF(intermediate_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        result_bag := USEDIN(intermediate_items[i],
            'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(results);
  END_FUNCTION; -- using_representations

  FUNCTION valid_calendar_date(date: calendar_date): LOGICAL;
    IF NOT ((1 <= date.day_component) AND (date.day_component <= 31))
         THEN RETURN(FALSE);
    END_IF;
    CASE date.month_component OF
      4      :       RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      6      :       RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      9      :       RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      11     :       RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      2      :       BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND
            (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND
            (date.day_component <= 28));
          END_IF;
        END;
      OTHERWISE  :         RETURN(TRUE);
      END_CASE;
  END_FUNCTION; -- valid_calendar_date

  FUNCTION valid_geometrically_bounded_wf_curve(crv: curve): BOOLEAN;
    IF SIZEOF(['CONFIG_CONTROL_DESIGN.POLYLINE',
        'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE',
        'CONFIG_CONTROL_DESIGN.ELLIPSE','CONFIG_CONTROL_DESIGN.CIRCLE'] *
        TYPEOF(crv)) = 1 THEN RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.TRIMMED_CURVE' IN TYPEOF(crv) THEN
        IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',
            'CONFIG_CONTROL_DESIGN.PARABOLA',
            'CONFIG_CONTROL_DESIGN.HYPERBOLA'] * TYPEOF(crv\trimmed_curve.
            basis_curve)) = 1 THEN RETURN(TRUE);
        ELSE
          RETURN(valid_geometrically_bounded_wf_curve(crv\trimmed_curve.
              basis_curve));
        END_IF;
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
          RETURN(valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.
              basis_curve));
        ELSE
          IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN
            RETURN(valid_geometrically_bounded_wf_curve(crv\curve_replica.
                parent_curve));
          ELSE
            IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE' IN TYPEOF(crv)
                 THEN
              RETURN(SIZEOF(QUERY ( ccs <* crv\composite_curve.segments |
                  (NOT valid_geometrically_bounded_wf_curve(ccs.
                  parent_curve)) )) = 0);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_FUNCTION; -- valid_geometrically_bounded_wf_curve

  FUNCTION valid_geometrically_bounded_wf_point(pnt: point): BOOLEAN;
    IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
        RETURN(valid_geometrically_bounded_wf_curve(pnt\point_on_curve.
            basis_curve));
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN
          RETURN(valid_geometrically_bounded_wf_point(pnt\point_replica.
              parent_pt));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_FUNCTION; -- valid_geometrically_bounded_wf_point

  FUNCTION valid_measure_value(m: measure_value): BOOLEAN;
    IF 'REAL' IN TYPEOF(m) THEN
      RETURN(m > 0);
    ELSE
      IF 'INTEGER' IN TYPEOF(m) THEN RETURN(m > 0);
      ELSE
        RETURN(TRUE);
      END_IF;
    END_IF;
  END_FUNCTION; -- valid_measure_value

  FUNCTION valid_time(time: local_time): BOOLEAN;
    IF EXISTS(time.second_component) THEN
      RETURN(EXISTS(time.minute_component));
    ELSE
      RETURN(TRUE);
    END_IF;
  END_FUNCTION; -- valid_time

  FUNCTION valid_units(m: measure_with_unit): BOOLEAN;
    IF 'CONFIG_CONTROL_DESIGN.LENGTH_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(1,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.MASS_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.TIME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(0,0,1,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(0,0,0,1,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' IN
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(0,0,0,0,1,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(0,0,0,0,0,1,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(0,0,0,0,0,0,1) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(0,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(0,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.AREA_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(2,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.VOLUME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(3,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.RATIO_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(0,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(1,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <>
          dimensional_exponents(0,0,0,0,0,0,0) THEN RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);
  END_FUNCTION; -- valid_units

  FUNCTION valid_wireframe_edge_curve(crv: curve): BOOLEAN;
    IF SIZEOF(['CONFIG_CONTROL_DESIGN.LINE','CONFIG_CONTROL_DESIGN.CONIC',
        'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE',
        'CONFIG_CONTROL_DESIGN.POLYLINE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(crv) THEN
        RETURN(valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
      ELSE
        IF 'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
          RETURN(valid_wireframe_edge_curve(crv\offset_curve_3d.
              basis_curve));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_FUNCTION; -- valid_wireframe_edge_curve

  FUNCTION valid_wireframe_vertex_point(pnt: point): BOOLEAN;
    IF 'CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(pnt) THEN
        RETURN(valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
      END_IF;
    END_IF;
    RETURN(FALSE);
  END_FUNCTION; -- valid_wireframe_vertex_point

  FUNCTION vector_difference(arg1, arg2: vector_or_direction
      ): vector;
    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
         THEN RETURN(?);
    ELSE
      BEGIN
        IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(vec1,0);
        END_IF;
      END;
    END_IF;
    RETURN(result);
  END_FUNCTION; -- vector_difference

END_SCHEMA; -- config_control_design
