;; iso-10303-11:2004

  0 ABS = ’abs’ .
  1 ABSTRACT = ’abstract’ .
  2 ACOS = ’acos’ .
  3 AGGREGATE = ’aggregate’ .
  4 ALIAS = ’alias’ .
  5 AND = ’and’ .
  6 ANDOR = ’andor’ .
  7 ARRAY = ’array’ .
  8 AS = ’as’ .
  9 ASIN = ’asin’ .
 10 ATAN = ’atan’ .
 11 BAG = ’bag’ .
 12 BASED_ON = ’based_on’ .
 13 BEGIN = ’begin’ .
 14 BINARY = ’binary’ .
 15 BLENGTH = ’blength’ .
 16 BOOLEAN = ’boolean’ .
 17 BY = ’by’ .
 18 CASE = ’case’ .
 19 CONSTANT = ’constant’ .
 20 CONST_E = ’const_e’ .
 21 COS = ’cos’ .
 22 DERIVE = ’derive’ .
 23 DIV = ’div’ .
 24 ELSE = ’else’ .
 25 END = ’end’ .
 26 END_ALIAS = ’end_alias’ .
 27 END_CASE = ’end_case’ .
 28 END_CONSTANT = ’end_constant’ .
 29 END_ENTITY = ’end_entity’ .
 30 END_FUNCTION = ’end_function’ .
 31 END_IF = ’end_if’ .
 32 END_LOCAL = ’end_local’ .
 33 END_PROCEDURE = ’end_procedure’ .
 34 END_REPEAT = ’end_repeat’ .
 35 END_RULE = ’end_rule’ .
 36 END_SCHEMA = ’end_schema’ .
 37 END_SUBTYPE_CONSTRAINT = ’end_subtype_constraint’ .
 38 END_TYPE = ’end_type’ .
 39 ENTITY = ’entity’ .
 40 ENUMERATION = ’enumeration’ .
 41 ESCAPE = ’escape’ .
 42 EXISTS = ’exists’ .
 43 EXTENSIBLE = ’extensible’ .
 44 EXP = ’exp’ .
 45 FALSE = ’false’ .
 46 FIXED = ’fixed’ .
 47 FOR = ’for’ .
 48 FORMAT = ’format’ .
 49 FROM = ’from’ .
 50 FUNCTION = ’function’ .
 51 GENERIC = ’generic’ .
 52 GENERIC_ENTITY = ’generic_entity’ .
 53 HIBOUND = ’hibound’ .
 54 HIINDEX = ’hiindex’ .
 55 IF = ’if’ .
 56 IN = ’in’ .
 57 INSERT = ’insert’ .
 58 INTEGER = ’integer’ .
 59 INVERSE = ’inverse’ .
 60 LENGTH = ’length’ .
 61 LIKE = ’like’ .
 62 LIST = ’list’ .
 63 LOBOUND = ’lobound’ .
 64 LOCAL = ’local’ .
 65 LOG = ’log’ .
 66 LOG10 = ’log10’ .
 67 LOG2 = ’log2’ .
 68 LOGICAL = ’logical’ .
 69 LOINDEX = ’loindex’ .
 70 MOD = ’mod’ .
 71 NOT = ’not’ .
 72 NUMBER = ’number’ .
 73 NVL = ’nvl’ .
 74 ODD = ’odd’ .
 75 OF = ’of’ .
 76 ONEOF = ’oneof’ .
 77 OPTIONAL = ’optional’ .
 78 OR = ’or’ .
 79 OTHERWISE = ’otherwise’ .
 80 PI = ’pi’ .
 81 PROCEDURE = ’procedure’ .
 82 QUERY = ’query’ .
 83 REAL = ’real’ .
 84 REFERENCE = ’reference’ .
 85 REMOVE = ’remove’ .
 86 RENAMED = ’renamed’ .
 87 REPEAT = ’repeat’ .
 88 RETURN = ’return’ .
 89 ROLESOF = ’rolesof’ .
 90 RULE = ’rule’ .
 91 SCHEMA = ’schema’ .
 92 SELECT = ’select’ .
 93 SELF = ’self’ .
 94 SET = ’set’ .
 95 SIN = ’sin’ .
 96 SIZEOF = ’sizeof’ .
 97 SKIP = ’skip’ .
 98 SQRT = ’sqrt’ .
 99 STRING = ’string’ .
100 SUBTYPE = ’subtype’ .
101 SUBTYPE_CONSTRAINT = ’subtype_constraint’ .
102 SUPERTYPE = ’supertype’ .
103 TAN = ’tan’ .
104 THEN = ’then’ .
105 TO = ’to’ .
106 TOTAL_OVER = ’total_over’ .
107 TRUE = ’true’ .
108 TYPE = ’type’ .
109 TYPEOF = ’typeof’ .
110 UNIQUE = ’unique’ .
111 UNKNOWN = ’unknown’ .
112 UNTIL = ’until’ .
113 USE = ’use’ .
114 USEDIN = ’usedin’ .
115 VALUE = ’value’ .
116 VALUE_IN = ’value_in’ .
117 VALUE_UNIQUE = ’value_unique’ .
118 VAR = ’var’ .
119 WHERE = ’where’ .
120 WHILE = ’while’ .
121 WITH = ’with’ .
122 XOR = ’xor’ .
123 bit = ’0’ | ’1’ .
124 digit = ’0’ | ’1’ | ’2’ | ’3’ | ’4’ | ’5’ | ’6’ | ’7’ | ’8’ | ’9’ .
125 digits = digit { digit } .
126 encoded_character = octet octet octet octet .
127 hex_digit = digit | ’a’ | ’b’ | ’c’ | ’d’ | ’e’ | ’f’ .
128 letter = ’a’ | ’b’ | ’c’ | ’d’ | ’e’ | ’f’ | ’g’ | ’h’ | ’i’ | ’j’ | ’k’ | ’l’ | ’m’ | ’n’ | ’o’ | ’p’ | ’q’ | ’r’ | ’s’ | ’t’ | ’u’ | ’v’ | ’w’ | ’x’ | ’y’ | ’z’ .
129 lparen_then_not_lparen_star = ’(’ { ’(’ } not_lparen_star { not_lparen_star } .
130 not_lparen_star = not_paren_star | ’)’ .
131 not_paren_star = letter | digit | not_paren_star_special .
132 not_paren_star_quote_special = ’!’ | ’"’ | ’#’ | ’$’ | ’%’ | ’&’ | ’+’ | ’,’ | ’-’ | ’.’ | ’/’ | ’:’ | ’;’ | ’<’ | ’=’ | ’>’ | ’?’ | ’@’ | ’[’ | ’\’ | ’]’ | ’^’ | ’_’ | ’‘’ | ’{’ | ’|’ | ’}’ | ’~’ .
133 not_paren_star_special = not_paren_star_quote_special | ’’’’ .
134 not_quote = not_paren_star_quote_special | letter | digit | ’(’ | ’)’ | ’*’ .
135 not_rparen_star = not_paren_star | ’(’ .
136 octet = hex_digit hex_digit .
137 special = not_paren_star_quote_special | ’(’ | ’)’ | ’*’ | ’’’’ .
138 not_rparen_star_then_rparen = not_rparen_star { not_rparen_star } ’)’ { ’)’ } .
139 binary_literal = ’%’ bit { bit } .
140 encoded_string_literal = ’"’ encoded_character { encoded_character } ’"’ .
141 integer_literal = digits .
142 real_literal = integer_literal | ( digits ’.’ [ digits ] [ ’e’ [ sign ] digits ] ) .
143 simple_id = letter { letter | digit | ’_’ } .
144 simple_string_literal = \q { ( \q \q ) | not_quote | \s | \x8 | \x9 | \xA | \xB | \xC | \xD } \q .
145 embedded_remark = ’(*’ [ remark_tag ] { ( not_paren_star { not_paren_star } ) | lparen_then_not_lparen_star | ( ’*’ { ’*’ } ) | not_rparen_star_then_rparen | embedded_remark } ’*)’ .
146 remark = embedded_remark | tail_remark .
147 remark_tag = ’"’ remark_ref { ’.’ remark_ref } ’"’ .
148 remark_ref = attribute_ref | constant_ref | entity_ref | enumeration_ref | function_ref | parameter_ref | procedure_ref | rule_label_ref | rule_ref | schema_ref | subtype_constraint_ref | type_label_ref | type_ref | variable_ref .
149 tail_remark = ’--’ [ remark_tag ] { \a | \s | \x8 | \x9 | \xA | \xB | \xC | \xD } \n .
150 attribute_ref = attribute_id .
151 constant_ref = constant_id .
152 entity_ref = entity_id .
153 enumeration_ref = enumeration_id .
154 function_ref = function_id .
155 parameter_ref = parameter_id .
156 procedure_ref = procedure_id .
157 rule_label_ref = rule_label_id .
158 rule_ref = rule_id .
159 schema_ref = schema_id .
160 subtype_constraint_ref = subtype_constraint_id .
161 type_label_ref = type_label_id .
162 type_ref = type_id .
163 variable_ref = variable_id .
164 abstract_entity_declaration = ABSTRACT .
165 abstract_supertype = ABSTRACT SUPERTYPE ’;’ .
166 abstract_supertype_declaration = ABSTRACT SUPERTYPE [ subtype_constraint ] .
167 actual_parameter_list = ’(’ parameter { ’,’ parameter } ’)’ .
168 add_like_op = ’+’ | ’-’ | OR | XOR .
169 aggregate_initializer = ’[’ [ element { ’,’ element } ] ’]’ .
170 aggregate_source = simple_expression .
171 aggregate_type = AGGREGATE [ ’:’ type_label ] OF parameter_type .
172 aggregation_types = array_type | bag_type | list_type | set_type .
173 algorithm_head = { declaration } [ constant_decl ] [ local_decl ] .
174 alias_stmt = ALIAS variable_id FOR general_ref { qualifier } ’;’ stmt { stmt } END_ALIAS ’;’ .
175 array_type = ARRAY bound_spec OF [ OPTIONAL ] [ UNIQUE ] instantiable_type .
176 assignment_stmt = general_ref { qualifier } ’:=’ expression ’;’ .
177 attribute_decl = attribute_id | redeclared_attribute .
178 attribute_id = simple_id .
179 attribute_qualifier = ’.’ attribute_ref .
180 bag_type = BAG [ bound_spec ] OF instantiable_type .
181 binary_type = BINARY [ width_spec ] .
182 boolean_type = BOOLEAN .
183 bound_1 = numeric_expression .
184 bound_2 = numeric_expression .
185 bound_spec = ’[’ bound_1 ’:’ bound_2 ’]’ .
186 built_in_constant = CONST_E | PI | SELF | ’?’ .
187 built_in_function = ABS | ACOS | ASIN | ATAN | BLENGTH | COS | EXISTS | EXP | FORMAT | HIBOUND | HIINDEX | LENGTH | LOBOUND | LOINDEX | LOG | LOG2 | LOG10 | NVL | ODD | ROLESOF | SIN | SIZEOF | SQRT | TAN | TYPEOF | USEDIN | VALUE | VALUE_IN | VALUE_UNIQUE .
188 built_in_procedure = INSERT | REMOVE .
189 case_action = case_label { ’,’ case_label } ’:’ stmt .
190 case_label = expression .
191 case_stmt = CASE selector OF { case_action } [ OTHERWISE ’:’ stmt ] END_CASE ’;’ .
192 compound_stmt = BEGIN stmt { stmt } END ’;’ .
193 concrete_types = aggregation_types | simple_types | type_ref .
194 constant_body = constant_id ’:’ instantiable_type ’:=’ expression ’;’ .
195 constant_decl = CONSTANT constant_body { constant_body } END_CONSTANT ’;’ .
196 constant_factor = built_in_constant | constant_ref .
197 constant_id = simple_id .
198 constructed_types = enumeration_type | select_type .
199 declaration = entity_decl | function_decl | procedure_decl | subtype_constraint_decl | type_decl .
200 derived_attr = attribute_decl ’:’ parameter_type ’:=’ expression ’;’ .
201 derive_clause = DERIVE derived_attr { derived_attr } .
202 domain_rule = [ rule_label_id ’:’ ] expression .
203 element = expression [ ’:’ repetition ] .
204 entity_body = { explicit_attr } [ derive_clause ] [ inverse_clause ] [ unique_clause ] [ where_clause ] .
205 entity_constructor = entity_ref ’(’ [ expression { ’,’ expression } ] ’)’ .
206 entity_decl = entity_head entity_body END_ENTITY ’;’ .
207 entity_head = ENTITY entity_id subsuper ’;’ .
208 entity_id = simple_id .
209 enumeration_extension = BASED_ON type_ref [ WITH enumeration_items ] .
210 enumeration_id = simple_id .
211 enumeration_items = ’(’ enumeration_id { ’,’ enumeration_id } ’)’ .
212 enumeration_reference = [ type_ref ’.’ ] enumeration_ref .
213 enumeration_type = [ EXTENSIBLE ] ENUMERATION [ ( OF enumeration_items ) | enumeration_extension ] .
214 escape_stmt = ESCAPE ’;’ .
215 explicit_attr = attribute_decl { ’,’ attribute_decl } ’:’ [ OPTIONAL ] parameter_type ’;’ .
216 expression = simple_expression [ rel_op_extended simple_expression ] .
217 factor = simple_factor [ ’**’ simple_factor ] .
218 formal_parameter = parameter_id { ’,’ parameter_id } ’:’ parameter_type .
219 function_call = ( built_in_function | function_ref ) [ actual_parameter_list ] .
220 function_decl = function_head algorithm_head stmt { stmt } END_FUNCTION ’;’ .
221 function_head = FUNCTION function_id [ ’(’ formal_parameter { ’;’ formal_parameter } ’)’ ] ’:’ parameter_type ’;’ .
222 function_id = simple_id .
223 generalized_types = aggregate_type | general_aggregation_types | generic_entity_type | generic_type .
224 general_aggregation_types = general_array_type | general_bag_type | general_list_type | general_set_type .
225 general_array_type = ARRAY [ bound_spec ] OF [ OPTIONAL ] [ UNIQUE ] parameter_type .
226 general_bag_type = BAG [ bound_spec ] OF parameter_type .
227 general_list_type = LIST [ bound_spec ] OF [ UNIQUE ] parameter_type .
228 general_ref = parameter_ref | variable_ref .
229 general_set_type = SET [ bound_spec ] OF parameter_type .
230 generic_entity_type = GENERIC_ENTITY [ ’:’ type_label ] .
231 generic_type = GENERIC [ ’:’ type_label ] .
232 group_qualifier = ’\’ entity_ref .
233 if_stmt = IF logical_expression THEN stmt { stmt } [ ELSE stmt { stmt } ] END_IF ’;’ .
234 increment = numeric_expression .
235 increment_control = variable_id ’:=’ bound_1 TO bound_2 [ BY increment ] .
236 index = numeric_expression .
237 index_1 = index .
238 index_2 = index .
239 index_qualifier = ’[’ index_1 [ ’:’ index_2 ] ’]’ .
240 instantiable_type = concrete_types | entity_ref .
241 integer_type = INTEGER .
242 interface_specification = reference_clause | use_clause .
243 interval = ’{’ interval_low interval_op interval_item interval_op interval_high ’}’ .
244 interval_high = simple_expression .
245 interval_item = simple_expression .
246 interval_low = simple_expression .
247 interval_op = ’<’ | ’<=’ .
248 inverse_attr = attribute_decl ’:’ [ ( SET | BAG ) [ bound_spec ] OF ] entity_ref FOR [ entity_ref ’.’ ] attribute_ref ’;’ .
249 inverse_clause = INVERSE inverse_attr { inverse_attr } .
250 list_type = LIST [ bound_spec ] OF [ UNIQUE ] instantiable_type .
251 literal = binary_literal | logical_literal | real_literal | string_literal .
252 local_decl = LOCAL local_variable { local_variable } END_LOCAL ’;’ .
253 local_variable = variable_id { ’,’ variable_id } ’:’ parameter_type [ ’:=’ expression ] ’;’ .
254 logical_expression = expression .
255 logical_literal = FALSE | TRUE | UNKNOWN .
256 logical_type = LOGICAL .
257 multiplication_like_op = ’*’ | ’/’ | DIV | MOD | AND | ’||’ .
258 named_types = entity_ref | type_ref .
259 named_type_or_rename = named_types [ AS ( entity_id | type_id ) ] .
260 null_stmt = ’;’ .
261 number_type = NUMBER .
262 numeric_expression = simple_expression .
263 one_of = ONEOF ’(’ supertype_expression { ’,’ supertype_expression } ’)’ .
264 parameter = expression .
265 parameter_id = simple_id .
266 parameter_type = generalized_types | named_types | simple_types .
267 population = entity_ref .
268 precision_spec = numeric_expression .
269 primary = literal | ( qualifiable_factor { qualifier } ) .
270 procedure_call_stmt = ( built_in_procedure | procedure_ref ) [ actual_parameter_list ] ’;’ .
271 procedure_decl = procedure_head algorithm_head { stmt } END_PROCEDURE ’;’ .
272 procedure_head = PROCEDURE procedure_id [ ’(’ [ VAR ] formal_parameter { ’;’ [ VAR ] formal_parameter } ’)’ ] ’;’ .
273 procedure_id = simple_id .
274 qualifiable_factor = attribute_ref | constant_factor | function_call | general_ref | population .
275 qualified_attribute = SELF group_qualifier attribute_qualifier .
276 qualifier = attribute_qualifier | group_qualifier | index_qualifier .
277 query_expression = QUERY ’(’ variable_id ’<*’ aggregate_source ’|’ logical_expression ’)’ .
278 real_type = REAL [ ’(’ precision_spec ’)’ ] .
279 redeclared_attribute = qualified_attribute [ RENAMED attribute_id ] .
280 referenced_attribute = attribute_ref | qualified_attribute .
281 reference_clause = REFERENCE FROM schema_ref [ ’(’ resource_or_rename { ’,’ resource_or_rename } ’)’ ] ’;’ .
282 rel_op = ’<’ | ’>’ | ’<=’ | ’>=’ | ’<>’ | ’=’ | ’:<>:’ | ’:=:’ .
283 rel_op_extended = rel_op | IN | LIKE .
284 rename_id = constant_id | entity_id | function_id | procedure_id | type_id .
285 repeat_control = [ increment_control ] [ while_control ] [ until_control ] .
286 repeat_stmt = REPEAT repeat_control ’;’ stmt { stmt } END_REPEAT ’;’ .
287 repetition = numeric_expression .
288 resource_or_rename = resource_ref [ AS rename_id ] .
289 resource_ref = constant_ref | entity_ref | function_ref | procedure_ref | type_ref .
290 return_stmt = RETURN [ ’(’ expression ’)’ ] ’;’ .
291 rule_decl = rule_head algorithm_head { stmt } where_clause END_RULE ’;’ .
292 rule_head = RULE rule_id FOR ’(’ entity_ref { ’,’ entity_ref } ’)’ ’;’ .
293 rule_id = simple_id .
294 rule_label_id = simple_id .
295 schema_body = { interface_specification } [ constant_decl ] { declaration | rule_decl } .
296 schema_decl = SCHEMA schema_id [ schema_version_id ] ’;’ schema_body END_SCHEMA ’;’ .
297 schema_id = simple_id .
298 schema_version_id = string_literal .
299 selector = expression .
300 select_extension = BASED_ON type_ref [ WITH select_list ] .
301 select_list = ’(’ named_types { ’,’ named_types } ’)’ .
302 select_type = [ EXTENSIBLE [ GENERIC_ENTITY ] ] SELECT [ select_list | select_extension ] .
303 set_type = SET [ bound_spec ] OF instantiable_type .
304 sign = ’+’ | ’-’ .
305 simple_expression = term { add_like_op term } .
306 simple_factor = aggregate_initializer | entity_constructor | enumeration_reference | interval | query_expression | ( [ unary_op ] ( ’(’ expression ’)’ | primary ) ) .
307 simple_types = binary_type | boolean_type | integer_type | logical_type | number_type | real_type | string_type .
308 skip_stmt = SKIP ’;’ .
309 stmt = alias_stmt | assignment_stmt | case_stmt | compound_stmt | escape_stmt | if_stmt | null_stmt | procedure_call_stmt | repeat_stmt | return_stmt | skip_stmt .
310 string_literal = simple_string_literal | encoded_string_literal .
311 string_type = STRING [ width_spec ] .
312 subsuper = [ supertype_constraint ] [ subtype_declaration ] .
313 subtype_constraint = OF ’(’ supertype_expression ’)’ .
314 subtype_constraint_body = [ abstract_supertype ] [ total_over ] [ supertype_expression ’;’ ] .
315 subtype_constraint_decl = subtype_constraint_head subtype_constraint_body END_SUBTYPE_CONSTRAINT ’;’ .
316 subtype_constraint_head = SUBTYPE_CONSTRAINT subtype_constraint_id FOR entity_ref ’;’ .
317 subtype_constraint_id = simple_id .
318 subtype_declaration = SUBTYPE OF ’(’ entity_ref { ’,’ entity_ref } ’)’ .
319 supertype_constraint = abstract_entity_declaration | abstract_supertype_declaration | supertype_rule .
320 supertype_expression = supertype_factor { ANDOR supertype_factor } .
321 supertype_factor = supertype_term { AND supertype_term } .
322 supertype_rule = SUPERTYPE subtype_constraint .
323 supertype_term = entity_ref | one_of | ’(’ supertype_expression ’)’ .
324 syntax = schema_decl { schema_decl } .
325 term = factor { multiplication_like_op factor } .
326 total_over = TOTAL_OVER ’(’ entity_ref { ’,’ entity_ref } ’)’ ’;’ .
327 type_decl = TYPE type_id ’=’ underlying_type ’;’ [ where_clause ] END_TYPE ’;’ .
328 type_id = simple_id .
329 type_label = type_label_id | type_label_ref .
330 type_label_id = simple_id .
331 unary_op = ’+’ | ’-’ | NOT .
332 underlying_type = concrete_types | constructed_types .
333 unique_clause = UNIQUE unique_rule ’;’ { unique_rule ’;’ } .
334 unique_rule = [ rule_label_id ’:’ ] referenced_attribute { ’,’ referenced_attribute } .
335 until_control = UNTIL logical_expression .
336 use_clause = USE FROM schema_ref [ ’(’ named_type_or_rename { ’,’ named_type_or_rename } ’)’ ] ’;’ .
337 variable_id = simple_id .
338 where_clause = WHERE domain_rule ’;’ { domain_rule ’;’ } .
339 while_control = WHILE logical_expression .
340 width = numeric_expression .
341 width_spec = ’(’ width ’)’ [ FIXED ] .
