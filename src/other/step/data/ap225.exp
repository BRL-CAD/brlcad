(*
  AIM EXPRESS long form for ISO/IS 10303-225:1994
  Wolfgang Haas

  2005-08-15 - Corrected misqualification of cfs_faces (was being
  qualified as closed_shell rather than connected_face_set), dim, and
  composite curve segments in get_basis_surface. Corrected () in WR2
  of advanced csg shape rep, replaced "BUIDLING" with BUILDING in the
  typeof strings -- DTL.
*)
SCHEMA building_design_schema;

  TYPE axis2_placement = SELECT
    (axis2_placement_2d,
     axis2_placement_3d);
  END_TYPE; -- axis2_placement

  TYPE b_spline_curve_form = ENUMERATION OF
    (polyline_form,
     circular_arc,
     elliptic_arc,
     parabolic_arc,
     hyperbolic_arc,
     unspecified);
  END_TYPE; -- b_spline_curve_form

  TYPE b_spline_surface_form = ENUMERATION OF
    (plane_surf,
     cylindrical_surf,
     conical_surf,
     spherical_surf,
     toroidal_surf,
     surf_of_revolution,
     ruled_surf,
     generalised_cone,
     quadric_surf,
     surf_of_linear_extrusion,
     unspecified);
  END_TYPE; -- b_spline_surface_form

  TYPE boolean_operand = SELECT
    (solid_model,
     half_space_solid,
     csg_primitive,
     boolean_result);
  END_TYPE; -- boolean_operand

  TYPE boolean_operator = ENUMERATION OF
    (union,
     intersection,
     difference);
  END_TYPE; -- boolean_operator

  TYPE building_component_classification_item = SELECT
    (negative_component,
     positive_component,
     opening,
     recess);
  END_TYPE; -- building_component_classification_item

  TYPE building_design_approval_item = SELECT
    (building_element_assembly,
     building_element,
     fixture_equipment_element,
     service_element,
     space_element,
     structure_enclosure_element,
     change,
     positive_component,
     negative_component);
  END_TYPE; -- building_design_approval_item

  TYPE building_design_change_item = SELECT
    (identified_item,
     resulting_item);
  END_TYPE; -- building_design_change_item

  TYPE building_design_date_item = SELECT
    (versioned_action_request);
  END_TYPE; -- building_design_date_item

  TYPE building_design_organization_item = SELECT
    (building,
     building_item_identification_assignment,
     versioned_action_request);
  END_TYPE; -- building_design_organization_item

  TYPE building_design_person_and_organization_item = SELECT
    (versioned_action_request);
  END_TYPE; -- building_design_person_and_organization_item

  TYPE building_design_person_item = SELECT
    (building,
     building_item_identification_assignment,
     versioned_action_request);
  END_TYPE; -- building_design_person_item

  TYPE building_document_item = SELECT
    (negative_component,
     positive_component,
     building_element,
     fixture_equipment_element,
     service_element,
     space_element,
     structure_enclosure_element,
     building_component_classification_group,
     product_category);
  END_TYPE; -- building_document_item

  TYPE characterized_definition = SELECT
    (characterized_object,
     characterized_product_definition,
     shape_definition);
  END_TYPE; -- characterized_definition

  TYPE characterized_product_definition = SELECT
    (product_definition,
     product_definition_relationship);
  END_TYPE; -- characterized_product_definition

  TYPE csg_primitive = SELECT
    (sphere,
     block,
     torus,
     right_circular_cone,
     right_circular_cylinder);
  END_TYPE; -- csg_primitive

  TYPE csg_select = SELECT
    (boolean_result,
     csg_primitive);
  END_TYPE; -- csg_select

  TYPE curve_on_surface = SELECT
    (pcurve,
     surface_curve,
     composite_curve_on_surface);
  END_TYPE; -- curve_on_surface

  TYPE date_time_select = SELECT
    (date);
  END_TYPE; -- date_time_select

  TYPE day_in_month_number = INTEGER;
  END_TYPE; -- day_in_month_number

  TYPE day_in_week_number = INTEGER;
  WHERE
    wr1: (1 <= SELF) AND (SELF <= 7);
  END_TYPE; -- day_in_week_number

  TYPE day_in_year_number = INTEGER;
  END_TYPE; -- day_in_year_number

  TYPE dimension_count = INTEGER;
  WHERE
    wr1: SELF > 0;
  END_TYPE; -- dimension_count

  TYPE geometric_set_select = SELECT
    (point,
     curve,
     surface);
  END_TYPE; -- geometric_set_select

  TYPE identified_item = SELECT
    (building_element,
     fixture_equipment_element,
     service_element,
     space_element,
     structure_enclosure_element,
     building_level,
     building_section,
     positive_component,
     negative_component);
  END_TYPE; -- identified_item

  TYPE identifier = STRING;
  END_TYPE; -- identifier

  TYPE knot_type = ENUMERATION OF
    (uniform_knots,
     unspecified,
     quasi_uniform_knots,
     piecewise_bezier_knots);
  END_TYPE; -- knot_type

  TYPE label = STRING;
  END_TYPE; -- label

  TYPE length_measure = REAL;
  END_TYPE; -- length_measure

  TYPE list_of_reversible_topology_item = LIST [0:?] OF
              reversible_topology_item;
  END_TYPE; -- list_of_reversible_topology_item

  TYPE measure_value = SELECT
    (length_measure,
     plane_angle_measure,
     parameter_value,
     positive_length_measure);
  END_TYPE; -- measure_value

  TYPE month_in_year_number = INTEGER;
  WHERE
    wr1: (1 <= SELF) AND (SELF <= 12);
  END_TYPE; -- month_in_year_number

  TYPE parameter_value = REAL;
  END_TYPE; -- parameter_value

  TYPE pcurve_or_surface = SELECT
    (pcurve,
     surface);
  END_TYPE; -- pcurve_or_surface

  TYPE person_organization_select = SELECT
    (person,
     organization,
     person_and_organization);
  END_TYPE; -- person_organization_select

  TYPE plane_angle_measure = REAL;
  END_TYPE; -- plane_angle_measure

  TYPE positive_length_measure = length_measure;
  WHERE
    wr1: SELF > 0;
  END_TYPE; -- positive_length_measure

  TYPE preferred_surface_curve_representation = ENUMERATION OF
    (curve_3d,
     pcurve_s1,
     pcurve_s2);
  END_TYPE; -- preferred_surface_curve_representation

  TYPE resulting_item = SELECT
    (building_element,
     fixture_equipment_element,
     service_element,
     space_element,
     structure_enclosure_element,
     positive_component,
     negative_component);
  END_TYPE; -- resulting_item

  TYPE reversible_topology = SELECT
    (reversible_topology_item,
     list_of_reversible_topology_item,
     set_of_reversible_topology_item);
  END_TYPE; -- reversible_topology

  TYPE reversible_topology_item = SELECT
    (edge,
     path,
     face,
     face_bound,
     closed_shell,
     open_shell);
  END_TYPE; -- reversible_topology_item

  TYPE set_of_reversible_topology_item = SET [0:?] OF
              reversible_topology_item;
  END_TYPE; -- set_of_reversible_topology_item

  TYPE shape_definition = SELECT
    (product_definition_shape,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE; -- shape_definition

  TYPE shell = SELECT
    (open_shell,
     closed_shell);
  END_TYPE; -- shell

  TYPE si_prefix = ENUMERATION OF
    (exa,
     peta,
     tera,
     giga,
     mega,
     kilo,
     hecto,
     deca,
     deci,
     centi,
     milli,
     micro,
     nano,
     pico,
     femto,
     atto);
  END_TYPE; -- si_prefix

  TYPE si_unit_name = ENUMERATION OF
    (metre,
     gram,
     second,
     ampere,
     kelvin,
     mole,
     candela,
     radian,
     steradian,
     hertz,
     newton,
     pascal,
     joule,
     watt,
     coulomb,
     volt,
     farad,
     ohm,
     siemens,
     weber,
     tesla,
     henry,
     degree_celsius,
     lumen,
     lux,
     becquerel,
     gray,
     sievert);
  END_TYPE; -- si_unit_name

  TYPE supported_item = SELECT
    (action,
     action_method);
  END_TYPE; -- supported_item

  TYPE text = STRING;
  END_TYPE; -- text

  TYPE transformation = SELECT
    (functionally_defined_transformation);
  END_TYPE; -- transformation

  TYPE transition_code = ENUMERATION OF
    (discontinuous,
     continuous,
     cont_same_gradient,
     cont_same_gradient_same_curvature);
  END_TYPE; -- transition_code

  TYPE trimming_preference = ENUMERATION OF
    (cartesian,
     parameter,
     unspecified);
  END_TYPE; -- trimming_preference

  TYPE trimming_select = SELECT
    (cartesian_point,
     parameter_value);
  END_TYPE; -- trimming_select

  TYPE unit = SELECT
    (named_unit,
     derived_unit);
  END_TYPE; -- unit

  TYPE vector_or_direction = SELECT
    (vector,
     direction);
  END_TYPE; -- vector_or_direction

  TYPE week_in_year_number = INTEGER;
  WHERE
    wr1: (1 <= SELF) AND (SELF <= 53);
  END_TYPE; -- week_in_year_number

  TYPE year_number = INTEGER;
  END_TYPE; -- year_number

  ENTITY action;
      name          : label;
      description   : text;
      chosen_method : action_method;
  END_ENTITY; -- action

  ENTITY action_assignment
    ABSTRACT SUPERTYPE;
      assigned_action : action;
  END_ENTITY; -- action_assignment

  ENTITY action_method;
      name        : label;
      description : text;
      consequence : text;
      purpose     : text;
  END_ENTITY; -- action_method

  ENTITY action_request_solution;
      method  : action_method;
      request : versioned_action_request;
  END_ENTITY; -- action_request_solution

  ENTITY action_request_status;
      status           : label;
      assigned_request : versioned_action_request;
  END_ENTITY; -- action_request_status

  ENTITY advanced_brep_building_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( it <* SELF.items | (NOT ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP',
               'BUILDING_DESIGN_SCHEMA.FACETED_BREP',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM',
               'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) =
                1) OR (it.name = 'reference line'))) )) = 0;
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               >= 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name =
                'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.items
                | (it.name = 'reference line') )) <= 3));
      wr3: SIZEOF(QUERY ( msb <* QUERY ( it <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (
               SIZEOF(QUERY ( fcs <* csh.cfs_faces | (NOT (
               'BUILDING_DESIGN_SCHEMA.ADVANCED_FACE' IN TYPEOF(fcs))) )) =
                0)) )) = 0)) )) = 0;
      wr4: SIZEOF(QUERY ( msb <* QUERY ( it <* items | (
               'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) )
                | ('BUILDING_DESIGN_SCHEMA.ORIENTED_CLOSED_SHELL' IN 
               TYPEOF(msb.outer)) )) = 0;
      wr5: SIZEOF(QUERY ( brv <* QUERY ( it <* items | (
               'BUILDING_DESIGN_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF(it)) ) | 
               (NOT (SIZEOF(QUERY ( csh <* brv.voids | csh.orientation )) =
                0)) )) = 0;
      wr6: SIZEOF(QUERY ( mi <* QUERY ( it <* items | (
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (
               NOT (('BUILDING_DESIGN_SCHEMA.' + 
               'ADVANCED_BREP_BUILDING_SHAPE_REPRESENTATION') IN TYPEOF(mi
               .mapping_source.mapped_representation))) )) = 0;
      wr7: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
               AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
               OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
               AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
               trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- advanced_brep_building_shape_representation

  ENTITY advanced_csg_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF.items | (NOT ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.CSG_SOLID',
               'BUILDING_DESIGN_SCHEMA.EXTRUDED_AREA_SOLID',
               'BUILDING_DESIGN_SCHEMA.REVOLVED_AREA_SOLID',
               'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) 
               OR (item.name = 'reference line'))) )) = 0;
      wr2: (SIZEOF(QUERY ( item <* SELF.items | (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.CSG_SOLID',
               'BUILDING_DESIGN_SCHEMA.EXTRUDED_AREA_SOLID',
               'BUILDING_DESIGN_SCHEMA.REVOLVED_AREA_SOLID',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1)))
               >= 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name =
                'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.items
                | (it.name = 'reference line') )) <= 3));
      wr3: SIZEOF(QUERY ( item <* SELF.items | ((
               'BUILDING_DESIGN_SCHEMA.CSG_SOLID' IN TYPEOF(item)) AND (
               NOT valid_advanced_csg_tree(item\csg_solid.
               tree_root_expression))) )) = 0;
      wr4: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT (
               'BUILDING_DESIGN_SCHEMA.ADVANCED_CSG_SHAPE_REPRESENTATION' 
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0;
      wr5: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
               AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
               OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
               AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
               trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- advanced_csg_shape_representation

  ENTITY advanced_face
    SUBTYPE OF (face_surface);
    WHERE
      wr1 : SIZEOF(['BUILDING_DESIGN_SCHEMA.ELEMENTARY_SURFACE',
                'BUILDING_DESIGN_SCHEMA.B_SPLINE_SURFACE',
                'BUILDING_DESIGN_SCHEMA.SWEPT_SURFACE'] * TYPEOF(
                face_geometry)) = 1;
      wr2 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT ('BUILDING_DESIGN_SCHEMA.EDGE_CURVE' IN 
                TYPEOF(oe.edge_element))) )) = 0)) )) = 0;
      wr3 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (SIZEOF(['BUILDING_DESIGN_SCHEMA.LINE',
                'BUILDING_DESIGN_SCHEMA.CONIC',
                'BUILDING_DESIGN_SCHEMA.POLYLINE',
                'BUILDING_DESIGN_SCHEMA.SURFACE_CURVE',
                'BUILDING_DESIGN_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(oe.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0;
      wr4 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (('BUILDING_DESIGN_SCHEMA.VERTEX_POINT' IN
                 TYPEOF(oe.edge_start)) AND (
                'BUILDING_DESIGN_SCHEMA.CARTESIAN_POINT' IN TYPEOF(oe.
                edge_start\vertex_point.vertex_geometry)) AND (
                'BUILDING_DESIGN_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_end)) 
                AND ('BUILDING_DESIGN_SCHEMA.CARTESIAN_POINT' IN TYPEOF(oe.
                edge_end\vertex_point.vertex_geometry)))) )) = 0)) )) = 0;
      wr5 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | ('BUILDING_DESIGN_SCHEMA.ORIENTED_PATH' IN TYPEOF(
                elp_fbnds.bound)) )) = 0;
      wr6 : (NOT ('BUILDING_DESIGN_SCHEMA.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (SIZEOF(['BUILDING_DESIGN_SCHEMA.LINE',
                'BUILDING_DESIGN_SCHEMA.CONIC',
                'BUILDING_DESIGN_SCHEMA.POLYLINE',
                'BUILDING_DESIGN_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(
                face_geometry\swept_surface.swept_curve)) = 1);
      wr7 : SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'BUILDING_DESIGN_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (('BUILDING_DESIGN_SCHEMA.VERTEX_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND (
                'BUILDING_DESIGN_SCHEMA.CARTESIAN_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\
                vertex_point.vertex_geometry)))) )) = 0;
      wr8 : SIZEOF(QUERY ( bnd <* SELF.bounds | (NOT (SIZEOF([
                'BUILDING_DESIGN_SCHEMA.EDGE_LOOP',
                'BUILDING_DESIGN_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnd.bound)) 
                = 1)) )) = 0;
      wr9 : SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* SELF.bounds | (
                'BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (('BUILDING_DESIGN_SCHEMA.SURFACE_CURVE' IN 
                TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND (NOT 
                (SIZEOF(QUERY ( sc_ag <* oe.edge_element\edge_curve.
                edge_geometry\surface_curve.associated_geometry | (NOT (
                'BUILDING_DESIGN_SCHEMA.PCURVE' IN TYPEOF(sc_ag))) )) = 0))) )) 
                = 0)) )) = 0;
      wr10: ((NOT ('BUILDING_DESIGN_SCHEMA.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (NOT ('BUILDING_DESIGN_SCHEMA.POLYLINE' 
                IN TYPEOF(face_geometry\swept_surface.swept_curve))) OR (
                SIZEOF(face_geometry\swept_surface.swept_curve\polyline.
                points) < 3)) AND (SIZEOF(QUERY ( elp_fbnds <* 
                QUERY ( bnds <* SELF.bounds | (
                'BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(
                oe.edge_element\edge_curve.edge_geometry)) AND (NOT (
                SIZEOF(oe.edge_element\edge_curve.edge_geometry\polyline.
                points) < 3))) )) = 0)) )) = 0);
  END_ENTITY; -- advanced_face

  ENTITY advanced_face_with_thickness_shape_representation
    SUBTYPE OF (shape_representation, solid_model);
    WHERE
      wr1: SIZEOF(SELF.items) = 2;
      wr2: SIZEOF(QUERY ( item <* SELF.items | ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.MEASURE_REPRESENTATION_ITEM',
               'BUILDING_DESIGN_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(
               item)) = 2) AND (item.name = 'thickness')) )) = 1;
      wr3: SIZEOF(QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.ADVANCED_FACE' IN TYPEOF(item)) )) =
                1;
  END_ENTITY; -- advanced_face_with_thickness_shape_representation

  ENTITY advanced_space_boundary_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF.items | (NOT ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM',
               'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(item)) 
               = 1) OR (item.name = 'reference line'))) )) = 0;
      wr2: (SIZEOF(QUERY ( item <* SELF.items | (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) )) 
               = 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name = 
               'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.items
                | (it.name = 'reference line') )) <= 3));
      wr3: SIZEOF(QUERY ( csh <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL' IN TYPEOF(item)) ) | (
               NOT (SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces
                | (NOT ('BUILDING_DESIGN_SCHEMA.ADVANCED_FACE' IN TYPEOF(
               fcs))) )) = 0)) )) = 0;
      wr4: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT (('BUILDING_DESIGN_SCHEMA.' + 
               'ADVANCED_SPACE_BOUNDARY_SHAPE_REPRESENTATION') IN TYPEOF(mi
               \mapped_item.mapping_source.mapped_representation))) )) = 0;
      wr5: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
               AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
               OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
               AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
               trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- advanced_space_boundary_shape_representation

  ENTITY advanced_wire_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF.items | (NOT ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE',
               'BUILDING_DESIGN_SCHEMA.CIRCLE',
               'BUILDING_DESIGN_SCHEMA.ELLIPSE',
               'BUILDING_DESIGN_SCHEMA.B_SPLINE_CURVE',
               'BUILDING_DESIGN_SCHEMA.OFFSET_CURVE_3D',
               'BUILDING_DESIGN_SCHEMA.CURVE_REPLICA',
               'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM',
               'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(item)) 
               = 1) OR (item.name = 'reference line'))) )) = 0;
      wr2: (SIZEOF(QUERY ( item <* SELF.items | (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE',
               'BUILDING_DESIGN_SCHEMA.CIRCLE',
               'BUILDING_DESIGN_SCHEMA.ELLIPSE',
               'BUILDING_DESIGN_SCHEMA.OFFSET_CURVE_3D',
               'BUILDING_DESIGN_SCHEMA.CURVE_REPLICA',
               'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) )) 
               = 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name = 
               'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.items
                | (it.name = 'reference line') )) <= 3));
      wr3: SIZEOF(QUERY ( item <* SELF.items | ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE',
               'BUILDING_DESIGN_SCHEMA.OFFSET_CURVE_3D',
               'BUILDING_DESIGN_SCHEMA.CURVE_REPLICA',
               'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE'] * TYPEOF(item)) = 1) 
               AND (NOT valid_advanced_wire_composition(item))) )) = 0;
      wr4: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT (('BUILDING_DESIGN_SCHEMA.' + 
               'ADVANCED_WIRE_SHAPE_REPRESENTATION') IN TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation))) )) = 0;
      wr5: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
               AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
               OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
               AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
               trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- advanced_wire_shape_representation

  ENTITY application_context;
      application : text;
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR 
                            frame_of_reference;
  END_ENTITY; -- application_context

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (product_context,product_definition_context));
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY; -- application_context_element

  ENTITY application_protocol_definition;
      status                                    : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year                 : year_number;
      application                               : application_context;
  END_ENTITY; -- application_protocol_definition

  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY; -- approval

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
      assigned_approval : approval;
  END_ENTITY; -- approval_assignment

  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
  END_ENTITY; -- approval_date_time

  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY; -- approval_person_organization

  ENTITY approval_role;
      role : label;
  END_ENTITY; -- approval_role

  ENTITY approval_status;
      name : label;
  END_ENTITY; -- approval_status

  ENTITY assembly_component_usage
    SUBTYPE OF (product_definition_usage);
      reference_designator : OPTIONAL identifier;
  END_ENTITY; -- assembly_component_usage

  ENTITY axis1_placement
    SUBTYPE OF (placement);
      axis : OPTIONAL direction;
    DERIVE
      z : direction := NVL(normalise(axis),direction([0,0,1]));
    WHERE
      wr1: SELF\geometric_representation_item.dim = 3;
  END_ENTITY; -- axis1_placement

  ENTITY axis2_placement_2d
    SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
    WHERE
      wr1: SELF\geometric_representation_item.dim = 2;
  END_ENTITY; -- axis2_placement_2d

  ENTITY axis2_placement_3d
    SUBTYPE OF (placement);
      axis          : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
    WHERE
      wr1: SELF\placement.location.dim = 3;
      wr2: (NOT EXISTS(axis)) OR (axis.dim = 3);
      wr3: (NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3);
      wr4: (NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (
               cross_product(axis,ref_direction).magnitude > 0);
  END_ENTITY; -- axis2_placement_3d

  ENTITY b_spline_curve
    SUPERTYPE OF (ONEOF (uniform_curve,b_spline_curve_with_knots,
        quasi_uniform_curve,bezier_curve) ANDOR rational_b_spline_curve)
    SUBTYPE OF (bounded_curve);
      degree              : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form          : b_spline_curve_form;
      closed_curve        : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(
                                         control_points_list) - 1;
      control_points                : ARRAY [0:
                                         upper_index_on_control_points] OF
                                          cartesian_point := list_to_array(
                                         control_points_list,0,
                                         upper_index_on_control_points);
    WHERE
      wr1: ('BUILDING_DESIGN_SCHEMA.UNIFORM_CURVE' IN TYPEOF(SELF)) OR (
               'BUILDING_DESIGN_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF)) 
               OR ('BUILDING_DESIGN_SCHEMA.BEZIER_CURVE' IN TYPEOF(SELF)) 
               OR ('BUILDING_DESIGN_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN 
               TYPEOF(SELF));
  END_ENTITY; -- b_spline_curve

  ENTITY b_spline_curve_with_knots
    SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots               : LIST [2:?] OF parameter_value;
      knot_spec           : knot_type;
    DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
    WHERE
      wr1: constraints_param_b_spline(degree,upper_index_on_knots,
               upper_index_on_control_points,knot_multiplicities,knots);
      wr2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
  END_ENTITY; -- b_spline_curve_with_knots

  ENTITY b_spline_surface
    SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,uniform_surface,
        quasi_uniform_surface,bezier_surface) ANDOR 
        rational_b_spline_surface)
    SUBTYPE OF (bounded_surface);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form        : b_spline_surface_form;
      u_closed            : LOGICAL;
      v_closed            : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      u_upper        : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF
                           cartesian_point := make_array_of_array(
                          control_points_list,0,u_upper,0,v_upper);
    WHERE
      wr1: ('BUILDING_DESIGN_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR (
               'BUILDING_DESIGN_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(
               SELF)) OR ('BUILDING_DESIGN_SCHEMA.BEZIER_SURFACE' IN 
               TYPEOF(SELF)) OR (
               'BUILDING_DESIGN_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN 
               TYPEOF(SELF));
  END_ENTITY; -- b_spline_surface

  ENTITY b_spline_surface_with_knots
    SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      knot_spec        : knot_type;
    DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
    WHERE
      wr1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
               knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,
               u_knots);
      wr2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
               knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,
               v_knots);
      wr3: SIZEOF(u_multiplicities) = knot_u_upper;
      wr4: SIZEOF(v_multiplicities) = knot_v_upper;
  END_ENTITY; -- b_spline_surface_with_knots

  ENTITY bezier_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- bezier_curve

  ENTITY bezier_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- bezier_surface

  ENTITY block
    SUBTYPE OF (geometric_representation_item);
      position : axis2_placement_3d;
      x        : positive_length_measure;
      y        : positive_length_measure;
      z        : positive_length_measure;
  END_ENTITY; -- block

  ENTITY boolean_result
    SUBTYPE OF (geometric_representation_item);
      operator       : boolean_operator;
      first_operand  : boolean_operand;
      second_operand : boolean_operand;
  END_ENTITY; -- boolean_result

  ENTITY boundary_curve
    SUBTYPE OF (composite_curve_on_surface);
    WHERE
      wr1: SELF\composite_curve.closed_curve;
  END_ENTITY; -- boundary_curve

  ENTITY bounded_curve
    SUPERTYPE OF (ONEOF (polyline,b_spline_curve,trimmed_curve,
        composite_curve))
    SUBTYPE OF (curve);
  END_ENTITY; -- bounded_curve

  ENTITY bounded_surface
    SUPERTYPE OF (ONEOF (b_spline_surface,rectangular_trimmed_surface,
        curve_bounded_surface,rectangular_composite_surface))
    SUBTYPE OF (surface);
  END_ENTITY; -- bounded_surface

  ENTITY brep_with_voids
    SUBTYPE OF (manifold_solid_brep);
      voids : SET [1:?] OF oriented_closed_shell;
  END_ENTITY; -- brep_with_voids

  ENTITY building
    SUBTYPE OF (product_definition);
    WHERE
      wr1: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | ('BUILDING_DESIGN_SCHEMA.BUILDING_SECTION' IN TYPEOF(pdr.
               related_product_definition)) )) >= 1;
      wr2: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ('BUILDING_DESIGN_SCHEMA.BUILDING_COMPLEX' IN TYPEOF(pdr.
               relating_product_definition)) )) = 1;
  END_ENTITY; -- building

  ENTITY building_complex
    SUBTYPE OF (product_definition);
    WHERE
      wr1: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | ((pdr.name = 'in building complex') AND (
               'BUILDING_DESIGN_SCHEMA.BUILDING' IN TYPEOF(pdr.
               related_product_definition))) )) >= 1;
      wr2: (SIZEOF(QUERY ( pa <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_DESIGN_PERSON_ASSIGNMENT.ITEMS') | (pa.role.name =
                'owner') )) + SIZEOF(QUERY ( oa <* USEDIN(SELF,
               'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_DESIGN_ORGANIZATION_ASSIGNMENT.ITEMS') | (oa.role.
               name = 'owner') ))) = 1;
  END_ENTITY; -- building_complex

  ENTITY building_component_classification_assignment
    SUBTYPE OF (group_assignment);
      items : SET [1:?] OF building_component_classification_item;
  END_ENTITY; -- building_component_classification_assignment

  ENTITY building_component_classification_group
    SUBTYPE OF (group);
    WHERE
      wr1: SIZEOF(QUERY ( ga <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'GROUP_ASSIGNMENT.ASSIGNED_GROUP') | ((
               'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_COMPONENT_CLASSIFICATION_ASSIGNMENT') IN TYPEOF(ga)) )) 
               >= 1;
  END_ENTITY; -- building_component_classification_group

  ENTITY building_design_approval
    SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF building_design_approval_item;
    WHERE
      wr1: SIZEOF(QUERY ( i <* SELF.items | (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.BUILDING',
               'BUILDING_DESIGN_SCHEMA.BUILDING_LEVEL',
               'BUILDING_DESIGN_SCHEMA.BUILDING_SECTION',
               'BUILDING_DESIGN_SCHEMA.ELEMENT_ASSEMBLY'] * TYPEOF(i)) = 1) )) 
               = 0;
  END_ENTITY; -- building_design_approval

  ENTITY building_design_date_assignment
    SUBTYPE OF (date_assignment);
      items : SET [1:?] OF building_design_date_item;
  END_ENTITY; -- building_design_date_assignment

  ENTITY building_design_organization_assignment
    SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF building_design_organization_item;
  END_ENTITY; -- building_design_organization_assignment

  ENTITY building_design_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF building_design_person_and_organization_item;
  END_ENTITY; -- building_design_person_and_organization_assignment

  ENTITY building_design_person_assignment
    SUBTYPE OF (person_assignment);
      items : SET [1:?] OF building_design_person_item;
  END_ENTITY; -- building_design_person_assignment

  ENTITY building_document_reference
    SUBTYPE OF (document_reference);
      items : SET [1:?] OF building_document_item;
  END_ENTITY; -- building_document_reference

  ENTITY building_element
    SUBTYPE OF (product_definition);
    WHERE
      wr1: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ('BUILDING_DESIGN_SCHEMA.BUILDING_SECTION' IN TYPEOF(pdr.
               relating_product_definition)) )) = 1;
      wr2: SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_ITEM_IDENTIFICATION_ASSIGNMENT.ITEM')) = 1;
      wr3: SIZEOF(QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(QUERY ( sa <* 
               USEDIN(pd,'BUILDING_DESIGN_SCHEMA.' + 
               'SHAPE_ASPECT.OF_SHAPE') | ((
               'BUILDING_DESIGN_SCHEMA.POSITIVE_COMPONENT' IN TYPEOF(sa)) 
               AND (sa.description = 'main component')) )) = 1) )) = 1;
  END_ENTITY; -- building_element

  ENTITY building_element_assembly
    SUBTYPE OF (product_definition);
    WHERE
      wr1: SIZEOF(QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (
               'BUILDING_DESIGN_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
               pd)) )) = 0;
      wr2: SIZEOF(QUERY ( acu <* QUERY ( pdr <* USEDIN(SELF,
               'BUILDING_DESIGN_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' + 
               'RELATING_PRODUCT_DEFINITION') | (
               'BUILDING_DESIGN_SCHEMA.ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(
               pdr)) ) | (SIZEOF(TYPEOF(acu.related_product_definition) * [
               'BUILDING_DESIGN_SCHEMA.BUILDING_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.FIXTURE_EQUIPMENT_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.SERVICE_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.SPACE_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.STRUCTURE_ENCLOSURE_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.BUILDING_ELEMENT_ASSEMBLY']) = 1) )) 
               >= 1;
  END_ENTITY; -- building_element_assembly

  ENTITY building_element_group
    SUBTYPE OF (product_definition);
    WHERE
      wr1: SIZEOF(QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (
               'BUILDING_DESIGN_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
               pd)) )) = 0;
      wr2: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | (SIZEOF(TYPEOF(pdr.related_product_definition) * [
               'BUILDING_DESIGN_SCHEMA.BUILDING_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.FIXTURE_EQUIPMENT_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.SERVICE_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.SPACE_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.STRUCTURE_ENCLOSURE_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.BUILDING_ELEMENT_GROUP']) = 1) )) >=
                1;
  END_ENTITY; -- building_element_group

  ENTITY building_item_identification_assignment
    SUBTYPE OF (name_assignment);
      item : identified_item;
  END_ENTITY; -- building_item_identification_assignment

  ENTITY building_level
    SUBTYPE OF (product_definition);
    WHERE
      wr1: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ('BUILDING_DESIGN_SCHEMA.BUILDING_SECTION' IN TYPEOF(pdr.
               relating_product_definition)) )) = 1;
      wr2: SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_ITEM_IDENTIFICATION_ASSIGNMENT.ITEM')) <= 1;
      wr3: SIZEOF(QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (NOT (
               SIZEOF(TYPEOF(pdr.used_representation) * [
               'BUILDING_DESIGN_SCHEMA.' + 
               'ADVANCED_SPACE_BOUNDARY_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'ELEMENTARY_SPACE_BOUNDARY_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'FACETED_SPACE_BOUNDARY_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'GROUND_FACE_SPACE_BOUNDARY_SHAPE_REPRESENTATION']) = 1)) )) 
               = 0)) )) = 0;
  END_ENTITY; -- building_level

  ENTITY building_section
    SUBTYPE OF (product_definition);
    WHERE
      wr1: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ('BUILDING_DESIGN_SCHEMA.BUILDING' IN TYPEOF(pdr.
               relating_product_definition)) )) = 1;
      wr2: SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_ITEM_IDENTIFICATION_ASSIGNMENT.ITEM')) = 1;
      wr3: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')
                | (SIZEOF(TYPEOF(pdr.related_product_definition) * [
               'BUILDING_DESIGN_SCHEMA.BUILDING_LEVEL',
               'BUILDING_DESIGN_SCHEMA.BUILDING_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.FIXTURE_EQUIPMENT_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.SERVICE_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.SPACE_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.STRUCTURE_ENCLOSURE_ELEMENT']) = 1) )) 
               >= 1;
  END_ENTITY; -- building_section

  ENTITY calendar_date
    SUBTYPE OF (date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      wr1: valid_calendar_date(SELF);
  END_ENTITY; -- calendar_date

  ENTITY cartesian_point
    SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
  END_ENTITY; -- cartesian_point

  ENTITY cartesian_transformation_operator
    SUPERTYPE OF (cartesian_transformation_operator_3d)
    SUBTYPE OF (geometric_representation_item, 
        functionally_defined_transformation);
      axis1        : OPTIONAL direction;
      axis2        : OPTIONAL direction;
      local_origin : cartesian_point;
      scale        : OPTIONAL REAL;
    DERIVE
      scl : REAL := NVL(scale,1);
    WHERE
      wr1: scl > 0;
  END_ENTITY; -- cartesian_transformation_operator

  ENTITY cartesian_transformation_operator_3d
    SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
    DERIVE
      u : LIST [3:3] OF direction := base_axis(3,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,axis3);
    WHERE
        WR1: SELF\geometric_representation_item.dim = 3;
--      wr1: SELF\cartesian_transformation_operator.dim = 3;
  END_ENTITY; -- cartesian_transformation_operator_3d

  ENTITY change
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF building_design_change_item;
  END_ENTITY; -- change

  ENTITY characterized_object;
      name        : label;
      description : text;
  END_ENTITY; -- characterized_object

  ENTITY circle
    SUBTYPE OF (conic);
      radius : positive_length_measure;
  END_ENTITY; -- circle

  ENTITY classification_table
    SUBTYPE OF (document_usage_constraint);
    WHERE
      wr1: SIZEOF(QUERY ( bddr <* QUERY ( dr <* USEDIN(SELF.source,'BUILDING_DESIGN_SCHEMA.DOCUMENT_REFERENCE.ASSIGNED_DOCUMENT')
                | ('BUILDING_DESIGN_SCHEMA.BUILDING_DOCUMENT_REFERENCE' IN 
               TYPEOF(dr)) ) | (NOT (SIZEOF(QUERY ( item <* bddr.items | (
               NOT (SIZEOF(TYPEOF(item) * [
               'BUILDING_DESIGN_SCHEMA.PRODUCT_CATEGORY',
               'BUILDING_DESIGN_SCHEMA.BUILDING_CLASSIFICATION_GROUP']) = 1)) )) 
               = 0)) )) = 0;
  END_ENTITY; -- classification_table

  ENTITY closed_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- closed_shell

  ENTITY composite_curve
    SUBTYPE OF (bounded_curve);
      segments       : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
    DERIVE
      n_segments   : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <> 
                        discontinuous;
    WHERE
      wr1: ((NOT closed_curve) AND (SIZEOF(QUERY ( temp <* segments | (
               temp.transition = discontinuous) )) = 1)) OR (closed_curve 
               AND (SIZEOF(QUERY ( temp <* segments | (temp.transition = 
               discontinuous) )) = 0));
  END_ENTITY; -- composite_curve

  ENTITY composite_curve_on_surface
    SUPERTYPE OF (boundary_curve)
    SUBTYPE OF (composite_curve);
    DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: SIZEOF(basis_surface) > 0;
      wr2: constraints_composite_curve_on_surface(SELF);
  END_ENTITY; -- composite_curve_on_surface

  ENTITY composite_curve_segment;
      transition   : transition_code;
      same_sense   : BOOLEAN;
      parent_curve : curve;
    INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
    WHERE
      wr1: 'BUILDING_DESIGN_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve);
  END_ENTITY; -- composite_curve_segment

  ENTITY conic
    SUPERTYPE OF (ONEOF (circle,ellipse,hyperbola,parabola))
    SUBTYPE OF (curve);
      position : axis2_placement;
  END_ENTITY; -- conic

  ENTITY conical_surface
    SUBTYPE OF (elementary_surface);
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: radius >= 0;
  END_ENTITY; -- conical_surface

  ENTITY connected_face_set
    SUPERTYPE OF (ONEOF (closed_shell,open_shell))
    SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
  END_ENTITY; -- connected_face_set

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
      name              : label;
      conversion_factor : measure_with_unit;
  END_ENTITY; -- conversion_based_unit

  ENTITY csg_solid
    SUBTYPE OF (solid_model);
      tree_root_expression : csg_select;
  END_ENTITY; -- csg_solid

  ENTITY curve
    SUPERTYPE OF (ONEOF (line,conic,pcurve,surface_curve,offset_curve_3d,
        curve_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- curve

  ENTITY curve_bounded_surface
    SUBTYPE OF (bounded_surface);
      basis_surface  : surface;
      boundaries     : SET [1:?] OF boundary_curve;
      implicit_outer : BOOLEAN;
    WHERE
      wr1: NOT (implicit_outer AND (
               'BUILDING_DESIGN_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(
               boundaries)));
      wr2: (NOT implicit_outer) OR (
               'BUILDING_DESIGN_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(
               basis_surface));
      wr3: SIZEOF(QUERY ( temp <* boundaries | (
               'BUILDING_DESIGN_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)) )) 
               <= 1;
      wr4: SIZEOF(QUERY ( temp <* boundaries | (temp\
               composite_curve_on_surface.basis_surface[1] :<>: SELF.
               basis_surface) )) = 0;
  END_ENTITY; -- curve_bounded_surface

  ENTITY curve_replica
    SUBTYPE OF (curve);
      parent_curve   : curve;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: transformation.dim = parent_curve.dim;
      wr2: acyclic_curve_replica(SELF,parent_curve);
  END_ENTITY; -- curve_replica

  ENTITY cylindrical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- cylindrical_surface

  ENTITY date
    SUPERTYPE OF (ONEOF (calendar_date,ordinal_date,
        week_of_year_and_day_date));
      year_component : year_number;
  END_ENTITY; -- date

  ENTITY date_assignment
    ABSTRACT SUPERTYPE;
      assigned_date : date;
      role          : date_role;
  END_ENTITY; -- date_assignment

  ENTITY date_role;
      name : label;
  END_ENTITY; -- date_role

  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: 'BUILDING_DESIGN_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN 
               TYPEOF(SELF\representation.context_of_items);
  END_ENTITY; -- definitional_representation

  ENTITY degenerate_toroidal_surface
    SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
    WHERE
      wr1: major_radius < minor_radius;
  END_ENTITY; -- degenerate_toroidal_surface

  ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
    WHERE
      wr1: (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements
               [1].exponent <> 1));
  END_ENTITY; -- derived_unit

  ENTITY derived_unit_element;
      unit     : named_unit;
      exponent : REAL;
  END_ENTITY; -- derived_unit_element

  ENTITY descriptive_representation_item
    SUBTYPE OF (representation_item);
      description : text;
  END_ENTITY; -- descriptive_representation_item

  ENTITY dimensional_exponents;
      length_exponent                    : REAL;
      mass_exponent                      : REAL;
      time_exponent                      : REAL;
      electric_current_exponent          : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent       : REAL;
      luminous_intensity_exponent        : REAL;
  END_ENTITY; -- dimensional_exponents

  ENTITY direction
    SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
    WHERE
      wr1: SIZEOF(QUERY ( tmp <* direction_ratios | (tmp <> 0) )) > 0;
  END_ENTITY; -- direction

  ENTITY document;
      id          : identifier;
      name        : label;
      description : text;
      kind        : document_type;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- document

  ENTITY document_reference
    ABSTRACT SUPERTYPE;
      assigned_document : document;
      source            : label;
  END_ENTITY; -- document_reference

  ENTITY document_type;
      product_data_type : label;
  END_ENTITY; -- document_type

  ENTITY document_usage_constraint;
      source                : document;
      subject_element       : label;
      subject_element_value : text;
  END_ENTITY; -- document_usage_constraint

  ENTITY edge
    SUPERTYPE OF (ONEOF (edge_curve,oriented_edge))
    SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end   : vertex;
  END_ENTITY; -- edge

  ENTITY edge_curve
    SUBTYPE OF (edge, geometric_representation_item);
      edge_geometry : curve;
      same_sense    : BOOLEAN;
  END_ENTITY; -- edge_curve

  ENTITY edge_loop
    SUBTYPE OF (loop, path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      wr1: SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].
               edge_end;
  END_ENTITY; -- edge_loop

  ENTITY elementary_csg_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF.items | (NOT ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.CSG_SOLID',
               'BUILDING_DESIGN_SCHEMA.EXTRUDED_AREA_SOLID',
               'BUILDING_DESIGN_SCHEMA.REVOLVED_AREA_SOLID',
               'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) 
               OR (item.name = 'reference line'))) )) = 0;
      wr2: (SIZEOF(QUERY ( item <* SELF.items | (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.CSG_SOLID',
               'BUILDING_DESIGN_SCHEMA.EXTRUDED_AREA_SOLID',
               'BUILDING_DESIGN_SCHEMA.REVOLVED_AREA_SOLID',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) )) 
               >= 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name =
                'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.items
                | (it.name = 'reference line') )) <= 3));
      wr3: SIZEOF(QUERY ( item <* SELF.items | ((
               'BUILDING_DESIGN_SCHEMA.CSG_SOLID' IN TYPEOF(item)) AND (
               NOT valid_elementary_csg_tree(item\csg_solid.
               tree_root_expression))) )) = 0;
      wr4: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT ('BUILDING_DESIGN_SCHEMA.ELEMENTARY_CSG_SHAPE_REPRESENTATION' 
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0;
      wr5: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
               AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
               OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
               AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
               trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- elementary_csg_shape_representation

  ENTITY elementary_face_with_thickness_shape_representation
    SUBTYPE OF (shape_representation, solid_model);
    WHERE
      wr1: SIZEOF(SELF.items) = 2;
      wr2: SIZEOF(QUERY ( item <* SELF.items | ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.MEASURE_REPRESENTATION_ITEM',
               'BUILDING_DESIGN_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(
               item)) = 2) AND (item.name = 'thickness')) )) = 1;
      wr3: SIZEOF(QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.FACE_SURFACE' IN TYPEOF(item)) )) = 
               1;
      wr4: SIZEOF(QUERY ( item <* SELF.items | ((NOT (
               'BUILDING_DESIGN_SCHEMA.FACE_SURFACE' IN TYPEOF(item))) OR (
               'BUILDING_DESIGN_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(item\
               face_surface.face_geometry))) )) = 0;
      wr5: SIZEOF(QUERY ( item <* SELF.items | ((
               'BUILDING_DESIGN_SCHEMA.FACE_SURFACE' IN TYPEOF(item)) AND (
               NOT (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* item\face.
               bounds | ('BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.
               bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
               edge_list | (NOT ('BUILDING_DESIGN_SCHEMA.EDGE_CURVE' IN 
               TYPEOF(oe.edge_element))) )) = 0)) )) = 0))) )) = 0;
      wr6: SIZEOF(QUERY ( item <* SELF.items | ((
               'BUILDING_DESIGN_SCHEMA.FACE_SURFACE' IN TYPEOF(item)) AND (
               NOT (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* item\face.
               bounds | ('BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.
               bound)) ) | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
               edge_list | (NOT (SIZEOF(['BUILDING_DESIGN_SCHEMA.LINE',
               'BUILDING_DESIGN_SCHEMA.CONIC',
               'BUILDING_DESIGN_SCHEMA.POLYLINE',
               'BUILDING_DESIGN_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(oe.
               edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) = 
               0))) )) = 0;
      wr7: SIZEOF(QUERY ( item <* SELF.items | ((
               'BUILDING_DESIGN_SCHEMA.FACE_SURFACE' IN TYPEOF(item)) AND (
               NOT (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* item\face.
               bounds | ('BUILDING_DESIGN_SCHEMA.VERTEX_LOOP' IN TYPEOF(
               bnds.bound)) ) | (NOT ((
               'BUILDING_DESIGN_SCHEMA.VERTEX_POINT' IN TYPEOF(vlp_fbnds\
               face_bound.bound\vertex_loop.loop_vertex)) AND (
               'BUILDING_DESIGN_SCHEMA.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds
               \face_bound.bound\vertex_loop.loop_vertex\vertex_point.
               vertex_geometry)))) )) = 0))) )) = 0;
  END_ENTITY; -- elementary_face_with_thickness_shape_representation

  ENTITY elementary_geometric_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : SIZEOF(QUERY ( item <* SELF.items | (NOT ((SIZEOF([
                'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP',
                'BUILDING_DESIGN_SCHEMA.FACETED_BREP',
                'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM',
                'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(item)) 
                = 1) OR (item.name = 'reference line'))) )) = 0;
      wr2 : (SIZEOF(QUERY ( item <* SELF.items | (SIZEOF([
                'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP',
                'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) )) 
                >= 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name 
                = 'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.
                items | (it.name = 'reference line') )) <= 3));
      wr3 : SIZEOF(QUERY ( msb <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(item)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (
                SIZEOF(QUERY ( fcs <* csh.cfs_faces | (NOT (
                'BUILDING_DESIGN_SCHEMA.FACE_SURFACE' IN TYPEOF(fcs))) )) =
                 0)) )) = 0)) )) = 0;
      wr4 : SIZEOF(QUERY ( msb <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(item)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (
                SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT ('BUILDING_DESIGN_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(
                fcs\face_surface.face_geometry))) )) = 0)) )) = 0)) )) = 0;
      wr5 : SIZEOF(QUERY ( msb <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(item)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (
                SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fcs.bounds
                 | ('BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT ('BUILDING_DESIGN_SCHEMA.EDGE_CURVE' IN 
                TYPEOF(oe.edge_element))) )) = 0)) )) = 0)) )) = 0)) )) = 0)) )) 
                = 0;
      wr6 : SIZEOF(QUERY ( msb <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(item)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (
                SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fcs.bounds
                 | ('BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (SIZEOF(['BUILDING_DESIGN_SCHEMA.LINE',
                'BUILDING_DESIGN_SCHEMA.CONIC',
                'BUILDING_DESIGN_SCHEMA.POLYLINE',
                'BUILDING_DESIGN_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(oe.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0)) )) = 0)) )) = 0)) )) = 0;
      wr7 : SIZEOF(QUERY ( msb <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(item)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (
                SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fcs.bounds
                 | ('BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (('BUILDING_DESIGN_SCHEMA.VERTEX_POINT' IN
                 TYPEOF(oe.edge_start)) AND (
                'BUILDING_DESIGN_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_end)))) )) 
                = 0)) )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr8 : SIZEOF(QUERY ( msb <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(item)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (
                SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fcs.bounds
                 | ('BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | ('BUILDING_DESIGN_SCHEMA.ORIENTED_PATH' IN TYPEOF(
                elp_fbnds.bound)) )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr9 : SIZEOF(QUERY ( msb <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(item)) )
                 | ('BUILDING_DESIGN_SCHEMA.ORIENTED_CLOSED_SHELL' IN 
                TYPEOF(msb\manifold_solid_brep.outer)) )) = 0;
      wr10: SIZEOF(QUERY ( brv <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.BREP_WITH_VOIDS' IN TYPEOF(item)) )
                 | (NOT (SIZEOF(QUERY ( csh <* brv\brep_with_voids.voids | 
                csh\oriented_closed_shell.orientation )) = 0)) )) = 0;
      wr11: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
                NOT (('BUILDING_DESIGN_SCHEMA.' + 
                'ELEMENTARY_GEOMETRIC_SHAPE_REPRESENTATION') IN TYPEOF(mi\
                mapped_item.mapping_source.mapped_representation))) )) = 0;
      wr12: SIZEOF(QUERY ( msb <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP' IN TYPEOF(item)) )
                 | (NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (
                SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fcs.bounds
                 | ('BUILDING_DESIGN_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.
                bound)) ) | (NOT (('BUILDING_DESIGN_SCHEMA.VERTEX_POINT' IN
                 TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) 
                AND ('BUILDING_DESIGN_SCHEMA.CARTESIAN_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\
                vertex_point.vertex_geometry)))) )) = 0)) )) = 0)) )) = 0)) )) 
                = 0;
      wr13: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
                AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
                OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
                AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
                trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- elementary_geometric_shape_representation

  ENTITY elementary_space_boundary_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : SIZEOF(QUERY ( item <* SELF.items | (NOT ((SIZEOF([
                'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL',
                'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM',
                'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(item)) 
                = 1) OR (item.name = 'reference line'))) )) = 0;
      wr2 : (SIZEOF(QUERY ( item <* SELF.items | (SIZEOF([
                'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL',
                'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) )) 
                = 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name =
                 'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.items
                 | (it.name = 'reference line') )) <= 3));
      wr3 : SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
                NOT (('BUILDING_DESIGN_SCHEMA.' + 
                'ELEMENTARY_SPACE_BOUNDARY_SHAPE_REPRESENTATION') IN 
                TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) )) 
                = 0;
      wr4 : SIZEOF(QUERY ( csh <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL' IN TYPEOF(item)) ) | 
                (NOT (SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT ('BUILDING_DESIGN_SCHEMA.FACE_SURFACE' IN TYPEOF(fcs))) )) 
                = 0)) )) = 0;
      wr5 : SIZEOF(QUERY ( csh <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL' IN TYPEOF(item)) ) | 
                (NOT (SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT ('BUILDING_DESIGN_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(
                fcs\face_surface.face_geometry))) )) = 0)) )) = 0;
      wr6 : SIZEOF(QUERY ( csh <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL' IN TYPEOF(item)) ) | 
                (NOT (SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fcs.bounds
                 | ('BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT ('BUILDING_DESIGN_SCHEMA.EDGE_CURVE' IN 
                TYPEOF(oe.edge_element))) )) = 0)) )) = 0)) )) = 0)) )) = 0;
      wr7 : SIZEOF(QUERY ( csh <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL' IN TYPEOF(item)) ) | 
                (NOT (SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fcs.bounds
                 | ('BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (SIZEOF(['BUILDING_DESIGN_SCHEMA.LINE',
                'BUILDING_DESIGN_SCHEMA.CONIC',
                'BUILDING_DESIGN_SCHEMA.POLYLINE',
                'BUILDING_DESIGN_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(oe.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0)) )) = 0)) )) = 0;
      wr8 : SIZEOF(QUERY ( csh <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL' IN TYPEOF(item)) ) | 
                (NOT (SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fcs.bounds
                 | ('BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (('BUILDING_DESIGN_SCHEMA.VERTEX_POINT' IN
                 TYPEOF(oe.edge_start)) AND (
                'BUILDING_DESIGN_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.edge_end)))) )) 
                = 0)) )) = 0)) )) = 0)) )) = 0;
      wr9 : SIZEOF(QUERY ( csh <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL' IN TYPEOF(item)) ) | 
                (NOT (SIZEOF(QUERY ( fcs <* csh\connected_face_set.
                cfs_faces | (NOT (SIZEOF(QUERY ( elp_fbnds <* 
                QUERY ( bnds <* fcs.bounds | (
                'BUILDING_DESIGN_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | ('BUILDING_DESIGN_SCHEMA.ORIENTED_PATH' IN TYPEOF(
                elp_fbnds.bound)) )) = 0)) )) = 0)) )) = 0;
      wr10: SIZEOF(QUERY ( csh <* QUERY ( item <* SELF.items | (
                'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL' IN TYPEOF(item)) ) | 
                (NOT (SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces | (
                NOT (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fcs.bounds
                 | ('BUILDING_DESIGN_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.
                bound)) ) | (NOT (('BUILDING_DESIGN_SCHEMA.VERTEX_POINT' IN
                 TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) 
                AND ('BUILDING_DESIGN_SCHEMA.CARTESIAN_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\
                vertex_point.vertex_geometry)))) )) = 0)) )) = 0)) )) = 0;
      wr11: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
                AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
                OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
                AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
                trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- elementary_space_boundary_shape_representation

  ENTITY elementary_surface
    SUPERTYPE OF (ONEOF (plane,cylindrical_surface,conical_surface,
        spherical_surface,toroidal_surface))
    SUBTYPE OF (surface);
      position : axis2_placement_3d;
  END_ENTITY; -- elementary_surface

  ENTITY elementary_wire_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF.items | (NOT ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE',
               'BUILDING_DESIGN_SCHEMA.CIRCLE',
               'BUILDING_DESIGN_SCHEMA.ELLIPSE',
               'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM',
               'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(item)) 
               = 1) OR (item.name = 'reference line'))) )) = 0;
      wr2: (SIZEOF(QUERY ( item <* SELF.items | (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE',
               'BUILDING_DESIGN_SCHEMA.CIRCLE',
               'BUILDING_DESIGN_SCHEMA.ELLIPSE',
               'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) )) 
               = 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name = 
               'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.items
                | (it.name = 'reference line') )) <= 3));
      wr3: SIZEOF(QUERY ( item <* SELF.items | ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE',
               'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE'] * TYPEOF(item)) = 1) 
               AND (NOT valid_elementary_wire_composition(item))) )) = 0;
      wr4: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT (('BUILDING_DESIGN_SCHEMA.' + 
               'ELEMENTARY_WIRE_SHAPE_REPRESENTATION') IN TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation))) )) = 0;
      wr5: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
               AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
               OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
               AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
               trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- elementary_wire_shape_representation

  ENTITY ellipse
    SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY; -- ellipse

  ENTITY extruded_area_solid
    SUBTYPE OF (swept_area_solid);
      extruded_direction : direction;
      depth              : positive_length_measure;
    WHERE
      wr1: dot_product(SELF\swept_area_solid.swept_area.basis_surface\
               elementary_surface.position.p[3],extruded_direction) <> 0;
  END_ENTITY; -- extruded_area_solid

  ENTITY face
    SUPERTYPE OF (ONEOF (face_surface,oriented_face))
    SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
    WHERE
      wr1: NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)));
      wr2: SIZEOF(QUERY ( temp <* bounds | (
               'BUILDING_DESIGN_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(temp)) )) 
               <= 1;
  END_ENTITY; -- face

  ENTITY face_bound
    SUBTYPE OF (topological_representation_item);
      bound       : loop;
      orientation : BOOLEAN;
  END_ENTITY; -- face_bound

  ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
  END_ENTITY; -- face_outer_bound

  ENTITY face_surface
    SUBTYPE OF (face, geometric_representation_item);
      face_geometry : surface;
      same_sense    : BOOLEAN;
  END_ENTITY; -- face_surface

  ENTITY faceted_brep
    SUBTYPE OF (manifold_solid_brep);
  END_ENTITY; -- faceted_brep

  ENTITY faceted_csg_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF.items | (NOT ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.CSG_SOLID',
               'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) 
               OR (item.name = 'reference line'))) )) = 0;
      wr2: (SIZEOF(QUERY ( item <* SELF.items | (NOT (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.CSG_SOLID',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1)) )) 
               >= 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name =
                'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.items
                | (it.name = 'reference line') )) <= 3));
      wr3: SIZEOF(QUERY ( item <* SELF.items | ((
               'BUILDING_DESIGN_SCHEMA.CSG_SOLID' IN TYPEOF(item)) AND (
               NOT valid_faceted_csg_tree(item\csg_solid.
               tree_root_expression))) )) = 0;
      wr4: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT (
               'BUILDING_DESIGN_SCHEMA.FACETED_CSG_SHAPE_REPRESENTATION' IN
                TYPEOF(mi\mapped_item.mapping_source.mapped_representation))) )) 
               = 0;
      wr5: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
               AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
               OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
               AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
               trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- faceted_csg_shape_representation

  ENTITY faceted_face_with_thickness_shape_representation
    SUBTYPE OF (shape_representation, solid_model);
    WHERE
      wr1: SIZEOF(SELF.items) = 2;
      wr2: SIZEOF(QUERY ( item <* SELF.items | ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.MEASURE_REPRESENTATION_ITEM',
               'BUILDING_DESIGN_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(
               item)) = 2) AND (item.name = 'thickness')) )) = 1;
      wr3: SIZEOF(QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.FACE' IN TYPEOF(item)) )) = 1;
      wr4: SIZEOF(QUERY ( item <* SELF.items | ((
               'BUILDING_DESIGN_SCHEMA.FACE' IN TYPEOF(item)) AND (NOT (
               SIZEOF(QUERY ( bnds <* item\face.bounds | (NOT (
               'BUILDING_DESIGN_SCHEMA.POLY_LOOP' IN TYPEOF(bnds.bound))) )) 
               = 0))) )) = 0;
      wr5: SIZEOF(QUERY ( item <* SELF.items | ((NOT (
               'BUILDING_DESIGN_SCHEMA.FACE_SURFACE' IN TYPEOF(item))) OR (
               'BUILDING_DESIGN_SCHEMA.PLANE' IN TYPEOF(item\face_surface.
               face_geometry))) )) = 0;
  END_ENTITY; -- faceted_face_with_thickness_shape_representation

  ENTITY faceted_geometric_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF.items | (NOT ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.FACETED_BREP',
               'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) 
               OR (item.name = 'reference line'))) )) = 0;
      wr2: (SIZEOF(QUERY ( item <* SELF.items | (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.FACETED_BREP',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) )) 
               >= 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name =
                'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.items
                | (it.name = 'reference line') )) <= 3));
      wr3: SIZEOF(QUERY ( msb <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.FACETED_BREP' IN TYPEOF(item)) ) | (
               NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (SIZEOF(
               QUERY ( fcs <* csh\connected_face_set.cfs_faces | (NOT (
               SIZEOF(QUERY ( bnds <* fcs.bounds | (NOT (
               'BUILDING_DESIGN_SCHEMA.POLY_LOOP' IN TYPEOF(bnds.bound))) )) 
               = 0)) )) = 0)) )) = 0)) )) = 0;
      wr4: SIZEOF(QUERY ( msb <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.FACETED_BREP' IN TYPEOF(item)) ) | (
               NOT (SIZEOF(QUERY ( csh <* msb_shells(msb) | (NOT (SIZEOF(
               QUERY ( fcs <* csh.cfs_faces | ((
               'BUILDING_DESIGN_SCHEMA.FACE_SURFACE' IN TYPEOF(fcs)) AND (
               NOT ('BUILDING_DESIGN_SCHEMA.PLANE' IN TYPEOF(fcs\
               face_surface.face_geometry)))) )) = 0)) )) = 0)) )) = 0;
      wr5: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT ('BUILDING_DESIGN_SCHEMA.FACETED_GEOMETRIC_SHAPE_REPRESENTATION' 
               IN TYPEOF(mi\mapped_item.mapping_source.
               mapped_representation))) )) = 0;
      wr6: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
               AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
               OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
               AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
               trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- faceted_geometric_shape_representation

  ENTITY faceted_space_boundary_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF.items | (NOT ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM',
               'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(item)) 
               = 1) OR (item.name = 'reference line'))) )) = 0;
      wr2: (SIZEOF(QUERY ( item <* SELF.items | (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) )) 
               = 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name = 
               'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.items
                | (it.name = 'reference line') )) <= 3));
      wr3: SIZEOF(QUERY ( csh <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL' IN TYPEOF(item)) ) | (
               NOT (SIZEOF(QUERY ( fcs <* csh\connected_face_set.cfs_faces
                | (NOT (SIZEOF(QUERY ( bnds <* fcs.bounds | (NOT (
               'BUILDING_DESIGN_SCHEMA.POLY_LOOP' IN TYPEOF(bnds.bound))) )) 
               = 0)) )) = 0)) )) = 0;
      wr4: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT (('BUILDING_DESIGN_SCHEMA.' + 
               'FACETED_SPACE_BOUNDARY_SHAPE_REPRESENTATION') IN TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation))) )) = 0;
      wr5: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
               AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
               OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
               AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
               trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- faceted_space_boundary_shape_representation

  ENTITY faceted_wire_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( item <* SELF.items | (NOT ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE',
               'BUILDING_DESIGN_SCHEMA.POLYLINE',
               'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM',
               'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(item)) 
               = 1) OR (item.name = 'reference line'))) )) = 0;
      wr2: (SIZEOF(QUERY ( item <* SELF.items | (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE',
               'BUILDING_DESIGN_SCHEMA.POLYLINE',
               'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE',
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM'] * TYPEOF(item)) = 1) )) 
               = 1) OR ((2 <= SIZEOF(QUERY ( it <* SELF.items | (it.name = 
               'reference line') ))) AND (SIZEOF(QUERY ( it <* SELF.items
                | (it.name = 'reference line') )) <= 3));
      wr3: SIZEOF(QUERY ( item <* SELF.items | ((SIZEOF([
               'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE',
               'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE'] * TYPEOF(item)) = 1) 
               AND (NOT valid_faceted_wire_composition(item))) )) = 0;
      wr4: SIZEOF(QUERY ( mi <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) ) | (
               NOT (('BUILDING_DESIGN_SCHEMA.' + 
               'FACETED_WIRE_SHAPE_REPRESENTATION') IN TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation))) )) = 0;
      wr5: SIZEOF(QUERY ( it <* SELF.items | ((it.name = 'reference line') 
               AND (NOT (('BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(it)) 
               OR (('BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(it)) 
               AND ('BUILDING_DESIGN_SCHEMA.CIRCLE' IN TYPEOF(it\
               trimmed_curve.basis_curve)))))) )) = 0;
  END_ENTITY; -- faceted_wire_shape_representation

  ENTITY fixture_equipment_element
    SUBTYPE OF (product_definition);
    WHERE
      wr1: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ('BUILDING_DESIGN_SCHEMA.BUILDING_SECTION' IN TYPEOF(pdr.
               relating_product_definition)) )) = 1;
      wr2: SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_ITEM_IDENTIFICATION_ASSIGNMENT.ITEM')) = 1;
      wr3: SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
               'BUILDING_DESIGN_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | (
               'BUILDING_DESIGN_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
               pd)) ) | (SIZEOF(QUERY ( sa <* USEDIN(pds,
               'BUILDING_DESIGN_SCHEMA.' + 'SHAPE_ASPECT.OF_SHAPE') | ((
               'BUILDING_DESIGN_SCHEMA.POSITIVE_COMPONENT' IN TYPEOF(sa)) 
               AND (sa.description = 'main component')) )) = 1) )) = 1;
  END_ENTITY; -- fixture_equipment_element

  ENTITY functionally_defined_transformation;
      name        : label;
      description : text;
  END_ENTITY; -- functionally_defined_transformation

  ENTITY geometric_curve_set
    SUBTYPE OF (geometric_set);
    WHERE
      wr1: SIZEOF(QUERY ( temp <* SELF\geometric_set.elements | (
               'BUILDING_DESIGN_SCHEMA.SURFACE' IN TYPEOF(temp)) )) = 0;
  END_ENTITY; -- geometric_curve_set

  ENTITY geometric_representation_context
    SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
  END_ENTITY; -- geometric_representation_context

  ENTITY geometric_representation_item
    SUPERTYPE OF (ONEOF (point,direction,vector,placement,
        cartesian_transformation_operator,curve,surface,edge_curve,
        face_surface,poly_loop,vertex_point,solid_model,boolean_result,
        sphere,right_circular_cone,right_circular_cylinder,torus,block,
        half_space_solid,geometric_set))
    SUBTYPE OF (representation_item);
    DERIVE
      dim : dimension_count := dimension_of(SELF);
    WHERE
      wr1: SIZEOF(QUERY ( using_rep <* using_representations(SELF) | (NOT 
               ('BUILDING_DESIGN_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(using_rep.context_of_items))) )) = 0;
  END_ENTITY; -- geometric_representation_item

  ENTITY geometric_set
    SUPERTYPE OF (geometric_curve_set)
    SUBTYPE OF (geometric_representation_item);
      elements : SET [1:?] OF geometric_set_select;
  END_ENTITY; -- geometric_set

  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
  END_ENTITY; -- global_unit_assigned_context

  ENTITY ground_face_space_boundary_shape_representation
    SUBTYPE OF (shape_representation, solid_model);
    WHERE
      wr1: SIZEOF(SELF.items) = 1;
      wr2: SIZEOF(QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.FACE' IN TYPEOF(item)) )) = 1;
      wr3: SIZEOF(QUERY ( item <* SELF.items | (NOT (SIZEOF(
               QUERY ( bnds <* item\face.bounds | (NOT (
               'BUILDING_DESIGN_SCHEMA.POLY_LOOP' IN TYPEOF(bnds.bound))) )) 
               = 0)) )) = 0;
      wr4: SIZEOF(QUERY ( item <* SELF.items | ((NOT (
               'BUILDING_DESIGN_SCHEMA.FACE_SURFACE' IN TYPEOF(item))) OR (
               'BUILDING_DESIGN_SCHEMA.PLANE' IN TYPEOF(item\face_surface.
               face_geometry))) )) = 0;
  END_ENTITY; -- ground_face_space_boundary_shape_representation

  ENTITY group;
      name        : label;
      description : text;
  END_ENTITY; -- group

  ENTITY group_assignment
    ABSTRACT SUPERTYPE;
      assigned_group : group;
  END_ENTITY; -- group_assignment

  ENTITY half_space_solid
    SUBTYPE OF (geometric_representation_item);
      base_surface   : surface;
      agreement_flag : BOOLEAN;
  END_ENTITY; -- half_space_solid

  ENTITY hyperbola
    SUBTYPE OF (conic);
      semi_axis      : positive_length_measure;
      semi_imag_axis : positive_length_measure;
  END_ENTITY; -- hyperbola

  ENTITY intersection_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
      wr2: associated_surface(SELF\surface_curve.associated_geometry[1]) 
               <> associated_surface(SELF\surface_curve.associated_geometry
               [2]);
  END_ENTITY; -- intersection_curve

  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: 'BUILDING_DESIGN_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component);
  END_ENTITY; -- length_measure_with_unit

  ENTITY length_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: (SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0);
  END_ENTITY; -- length_unit

  ENTITY line
    SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
    WHERE
      wr1: dir.dim = pnt.dim;
  END_ENTITY; -- line

  ENTITY loop
    SUPERTYPE OF (ONEOF (vertex_loop,edge_loop,poly_loop))
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- loop

  ENTITY manifold_solid_brep
    SUBTYPE OF (solid_model);
      outer : closed_shell;
  END_ENTITY; -- manifold_solid_brep

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      wr1: acyclic_mapped_representation(using_representations(SELF),[SELF]);
  END_ENTITY; -- mapped_item

  ENTITY measure_representation_item
    SUBTYPE OF (representation_item, measure_with_unit);
  END_ENTITY; -- measure_representation_item

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF (length_measure_with_unit,
        plane_angle_measure_with_unit));
      value_component : measure_value;
      unit_component  : unit;
    WHERE
      wr1: valid_units(SELF);
  END_ENTITY; -- measure_with_unit

  ENTITY name_assignment
    ABSTRACT SUPERTYPE;
      assigned_name : label;
  END_ENTITY; -- name_assignment

  ENTITY named_unit
    SUPERTYPE OF (ONEOF (si_unit,conversion_based_unit) ANDOR ONEOF (
        length_unit,plane_angle_unit));
      dimensions : dimensional_exponents;
  END_ENTITY; -- named_unit

  ENTITY negative_component
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION')) >= 1) AND (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(USEDIN(pd,
               'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) >= 1)) )) 
               = 0);
      wr2: SIZEOF(TYPEOF(SELF.of_shape.definition) * [
               'BUILDING_DESIGN_SCHEMA.BUILDING_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.FIXTURE_EQUIPMENT_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.SERVICE_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.STRUCTURE_ENCLOSURE_ELEMENT']) = 1;
      wr3: SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_ITEM_IDENTIFICATION_ASSIGNMENT.ITEM')) = 1;
      wr4: SIZEOF(QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (NOT (
               SIZEOF(TYPEOF(pdr.used_representation) * [
               'BUILDING_DESIGN_SCHEMA.' + 
               'ADVANCED_BREP_BUILDING_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.ADVANCED_CSG_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'ADVANCED_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'ADVANCED_WIRE_SHAPE_REPRESENTATION','BUILDING_DESIGN_SCHEMA.ELEMENTARY_CSG_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'ELEMENTARY_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'ELEMENTARY_GEOMETRIC_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'ELEMENTARY_WIRE_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.FACETED_CSG_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'FACETED_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION','BUILDING_DESIGN_SCHEMA.FACETED_GEOMETRIC_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'FACETED_WIRE_SHAPE_REPRESENTATION']) = 1)) )) = 0)) )) = 0;
  END_ENTITY; -- negative_component

  ENTITY offset_curve_3d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
      ref_direction  : direction;
    WHERE
      wr1: (basis_curve.dim = 3) AND (ref_direction.dim = 3);
  END_ENTITY; -- offset_curve_3d

  ENTITY open_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- open_shell

  ENTITY opening
    SUBTYPE OF (negative_component);
    WHERE
      wr1: SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_COMPONENT_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      wr2: SIZEOF(QUERY ( bcca <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_COMPONENT_CLASSIFICATION_ASSIGNMENT.ITEMS') | (
               NOT (bcca\group_assignment.assigned_group.description = 
               'opening')) )) = 0;
  END_ENTITY; -- opening

  ENTITY ordinal_date
    SUBTYPE OF (date);
      day_component : day_in_year_number;
    WHERE
      wr1: ((NOT leap_year(SELF.year_component)) AND (1 <= day_component) 
               AND (day_component <= 365)) OR (leap_year(SELF.
               year_component) AND (1 <= day_component) AND (day_component 
               <= 366));
  END_ENTITY; -- ordinal_date

  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : text;
  END_ENTITY; -- organization

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role                  : organization_role;
  END_ENTITY; -- organization_assignment

  ENTITY organization_role;
      name : label;
  END_ENTITY; -- organization_role

  ENTITY organizational_project;
      name                      : label;
      description               : text;
      responsible_organizations : SET [1:?] OF organization;
  END_ENTITY; -- organizational_project

  ENTITY oriented_closed_shell
    SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation          : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             closed_shell_element.cfs_faces);
    WHERE
      wr1: NOT ('BUILDING_DESIGN_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(
               SELF.closed_shell_element));
  END_ENTITY; -- oriented_closed_shell

  ENTITY oriented_edge
    SUBTYPE OF (edge);
      edge_element : edge;
      orientation  : BOOLEAN;
    DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_start,SELF.
                                edge_element.edge_end);
      SELF\edge.edge_end   : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_end,SELF.
                                edge_element.edge_start);
    WHERE
      wr1: NOT ('BUILDING_DESIGN_SCHEMA.ORIENTED_EDGE' IN TYPEOF(SELF.
               edge_element));
  END_ENTITY; -- oriented_edge

  ENTITY oriented_face
    SUBTYPE OF (face);
      face_element : face;
      orientation  : BOOLEAN;
    DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(
                            SELF.orientation,SELF.face_element.bounds);
    WHERE
      wr1: NOT ('BUILDING_DESIGN_SCHEMA.ORIENTED_FACE' IN TYPEOF(SELF.
               face_element));
  END_ENTITY; -- oriented_face

  ENTITY oriented_open_shell
    SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation        : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             open_shell_element.cfs_faces);
    WHERE
      wr1: NOT ('BUILDING_DESIGN_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(
               SELF.open_shell_element));
  END_ENTITY; -- oriented_open_shell

  ENTITY oriented_path
    SUBTYPE OF (path);
      path_element : path;
      orientation  : BOOLEAN;
    DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := 
                               conditional_reverse(SELF.orientation,SELF.
                               path_element.edge_list);
    WHERE
      wr1: NOT ('BUILDING_DESIGN_SCHEMA.ORIENTED_PATH' IN TYPEOF(SELF.
               path_element));
  END_ENTITY; -- oriented_path

  ENTITY outer_boundary_curve
    SUBTYPE OF (boundary_curve);
  END_ENTITY; -- outer_boundary_curve

  ENTITY parabola
    SUBTYPE OF (conic);
      focal_dist : length_measure;
    WHERE
      wr1: focal_dist <> 0;
  END_ENTITY; -- parabola

  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY; -- parametric_representation_context

  ENTITY path
    SUPERTYPE OF (ONEOF (edge_loop,oriented_path))
    SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
    WHERE
      wr1: path_head_to_tail(SELF);
  END_ENTITY; -- path

  ENTITY pcurve
    SUBTYPE OF (curve);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: SIZEOF(reference_to_curve\representation.items) = 1;
      wr2: 'BUILDING_DESIGN_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\
               representation.items[1]);
      wr3: reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2;
  END_ENTITY; -- pcurve

  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    UNIQUE
      ur1 : id;
    WHERE
      wr1: EXISTS(last_name) OR EXISTS(first_name);
  END_ENTITY; -- person

  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
  END_ENTITY; -- person_and_organization

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role                             : person_and_organization_role;
  END_ENTITY; -- person_and_organization_assignment

  ENTITY person_and_organization_role;
      name : label;
  END_ENTITY; -- person_and_organization_role

  ENTITY person_assignment
    ABSTRACT SUPERTYPE;
      assigned_person : person;
      role            : person_role;
  END_ENTITY; -- person_assignment

  ENTITY person_role;
      name : label;
  END_ENTITY; -- person_role

  ENTITY placement
    SUPERTYPE OF (ONEOF (axis1_placement,axis2_placement_2d,
        axis2_placement_3d))
    SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
  END_ENTITY; -- placement

  ENTITY plane
    SUBTYPE OF (elementary_surface);
  END_ENTITY; -- plane

  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: 'BUILDING_DESIGN_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component);
  END_ENTITY; -- plane_angle_measure_with_unit

  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: (SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0);
  END_ENTITY; -- plane_angle_unit

  ENTITY point
    SUPERTYPE OF (cartesian_point)
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- point

  ENTITY poly_loop
    SUBTYPE OF (loop, geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
  END_ENTITY; -- poly_loop

  ENTITY polyline
    SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
  END_ENTITY; -- polyline

  ENTITY positive_component
    SUBTYPE OF (shape_aspect);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION')) >= 1) AND (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(USEDIN(pd,
               'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) >= 1)) )) 
               = 0);
      wr2: SIZEOF(TYPEOF(SELF.of_shape.definition) * [
               'BUILDING_DESIGN_SCHEMA.BUILDING_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.FIXTURE_EQUIPMENT_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.SERVICE_ELEMENT',
               'BUILDING_DESIGN_SCHEMA.STRUCTURE_ENCLOSURE_ELEMENT']) = 1;
      wr3: SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_ITEM_IDENTIFICATION_ASSIGNMENT.ITEM')) = 1;
      wr4: SIZEOF(QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | (NOT (
               SIZEOF(TYPEOF(pdr.used_representation) * [
               'BUILDING_DESIGN_SCHEMA.' + 
               'ADVANCED_BREP_BUILDING_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.ADVANCED_CSG_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'ADVANCED_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'ADVANCED_WIRE_SHAPE_REPRESENTATION','BUILDING_DESIGN_SCHEMA.ELEMENTARY_CSG_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'ELEMENTARY_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION','BUILDING_DESIGN_SCHEMA.ELEMENTARY_GEOMETRIC_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'ELEMENTARY_WIRE_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.FACETED_CSG_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'FACETED_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION','BUILDING_DESIGN_SCHEMA.FACETED_GEOMETRIC_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'FACETED_WIRE_SHAPE_REPRESENTATION']) = 1)) )) = 0)) )) = 0;
  END_ENTITY; -- positive_component

  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : text;
      frame_of_reference : SET [1:?] OF product_context;
    UNIQUE
      ur1 : id;
  END_ENTITY; -- product

  ENTITY product_category;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- product_category

  ENTITY product_category_relationship;
      name         : label;
      description  : text;
      category     : product_category;
      sub_category : product_category;
    WHERE
      wr1: acyclic_product_category_relationship(SELF,[SELF.sub_category]);
  END_ENTITY; -- product_category_relationship

  ENTITY product_context
    SUBTYPE OF (application_context_element);
      discipline_type : label;
  END_ENTITY; -- product_context

  ENTITY product_definition;
      id                 : identifier;
      description        : text;
      formation          : product_definition_formation;
      frame_of_reference : product_definition_context;
  END_ENTITY; -- product_definition

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
  END_ENTITY; -- product_definition_context

  ENTITY product_definition_formation;
      id          : identifier;
      description : text;
      of_product  : product;
    UNIQUE
      ur1 : id, of_product;
  END_ENTITY; -- product_definition_formation

  ENTITY product_definition_relationship;
      id                          : identifier;
      name                        : label;
      description                 : text;
      relating_product_definition : product_definition;
      related_product_definition  : product_definition;
  END_ENTITY; -- product_definition_relationship

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : definition;
    WHERE
      wr1: 'BUILDING_DESIGN_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION' IN 
               TYPEOF(SELF\property_definition.definition);
  END_ENTITY; -- product_definition_shape

  ENTITY product_definition_usage
    SUPERTYPE OF (assembly_component_usage)
    SUBTYPE OF (product_definition_relationship);
    UNIQUE
      ur1 : id, relating_product_definition, related_product_definition;
    WHERE
      wr1: acyclic_product_definition_relationship(SELF,[SELF\
               product_definition_relationship.related_product_definition],
               'BUILDING_DESIGN_SCHEMA.PRODUCT_DEFINITION_USAGE.' + 
               'RELATED_PRODUCT_DEFINITION');
  END_ENTITY; -- product_definition_usage

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
  END_ENTITY; -- product_related_product_category

  ENTITY property_definition;
      name        : label;
      description : text;
      definition  : characterized_definition;
  END_ENTITY; -- property_definition

  ENTITY property_definition_representation;
      definition          : property_definition;
      used_representation : representation;
  END_ENTITY; -- property_definition_representation

  ENTITY quasi_uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- quasi_uniform_curve

  ENTITY quasi_uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- quasi_uniform_surface

  ENTITY rational_b_spline_curve
    SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL := 
                   list_to_array(weights_data,0,
                   upper_index_on_control_points);
    WHERE
      wr1: SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
               control_points_list);
      wr2: curve_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_curve

  ENTITY rational_b_spline_surface
    SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := 
                   make_array_of_array(weights_data,0,u_upper,0,v_upper);
    WHERE
      wr1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.
               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(
               SELF\b_spline_surface.control_points_list[1]));
      wr2: surface_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_surface

  ENTITY recess
    SUBTYPE OF (negative_component);
    WHERE
      wr1: SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_COMPONENT_CLASSIFICATION_ASSIGNMENT.ITEMS')) = 1;
      wr2: SIZEOF(QUERY ( bcca <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_COMPONENT_CLASSIFICATION_ASSIGNMENT.ITEMS') | (
               NOT (bcca\group_assignment.assigned_group.description = 
               'recess')) )) = 0;
  END_ENTITY; -- recess

  ENTITY rectangular_composite_surface
    SUBTYPE OF (bounded_surface);
      segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
    DERIVE
      n_u : INTEGER := SIZEOF(segments);
      n_v : INTEGER := SIZEOF(segments[1]);
    WHERE
      wr1: [] = QUERY ( s <* segments | (n_v <> SIZEOF(s)) );
      wr2: constraints_rectangular_composite_surface(SELF);
  END_ENTITY; -- rectangular_composite_surface

  ENTITY rectangular_trimmed_surface
    SUBTYPE OF (bounded_surface);
      basis_surface : surface;
      u1            : parameter_value;
      u2            : parameter_value;
      v1            : parameter_value;
      v2            : parameter_value;
      usense        : BOOLEAN;
      vsense        : BOOLEAN;
    WHERE
      wr1: u1 <> u2;
      wr2: v1 <> v2;
      wr3: (('BUILDING_DESIGN_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(
               basis_surface)) AND (NOT ('BUILDING_DESIGN_SCHEMA.PLANE' IN 
               TYPEOF(basis_surface)))) OR (
               'BUILDING_DESIGN_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(
               basis_surface)) OR (usense = (u2 > u1));
      wr4: ('BUILDING_DESIGN_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(
               basis_surface)) OR (
               'BUILDING_DESIGN_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(
               basis_surface)) OR (vsense = (v2 > v1));
  END_ENTITY; -- rectangular_trimmed_surface

  ENTITY representation;
      name             : label;
      items            : SET [1:?] OF representation_item;
      context_of_items : representation_context;
  END_ENTITY; -- representation

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR 
                                      context_of_items;
  END_ENTITY; -- representation_context

  ENTITY representation_item;
      name : label;
    WHERE
      wr1: SIZEOF(using_representations(SELF)) > 0;
  END_ENTITY; -- representation_item

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
    WHERE
      wr1: item_in_context(SELF.mapping_origin,SELF.mapped_representation.
               context_of_items);
  END_ENTITY; -- representation_map

  ENTITY representation_relationship;
      name        : label;
      description : text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY; -- representation_relationship

  ENTITY representation_relationship_with_transformation
    SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
    WHERE
      wr1: SELF\representation_relationship.rep_1.context_of_items :<>: 
               SELF\representation_relationship.rep_2.context_of_items;
  END_ENTITY; -- representation_relationship_with_transformation

  ENTITY revolved_area_solid
    SUBTYPE OF (swept_area_solid);
      axis  : axis1_placement;
      angle : plane_angle_measure;
    DERIVE
      axis_line : line := line(axis.location,vector(axis.z,1));
  END_ENTITY; -- revolved_area_solid

  ENTITY right_circular_cone
    SUBTYPE OF (geometric_representation_item);
      position   : axis1_placement;
      height     : positive_length_measure;
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: radius >= 0;
  END_ENTITY; -- right_circular_cone

  ENTITY right_circular_cylinder
    SUBTYPE OF (geometric_representation_item);
      position : axis1_placement;
      height   : positive_length_measure;
      radius   : positive_length_measure;
  END_ENTITY; -- right_circular_cylinder

  ENTITY service_element
    SUBTYPE OF (product_definition);
    WHERE
      wr1: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ('BUILDING_DESIGN_SCHEMA.BUILDING_SECTION' IN TYPEOF(pdr.
               relating_product_definition)) )) = 1;
      wr2: SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_ITEM_IDENTIFICATION_ASSIGNMENT.ITEM')) = 1;
      wr3: SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
               'BUILDING_DESIGN_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | (
               'BUILDING_DESIGN_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
               pd)) ) | (SIZEOF(QUERY ( sa <* USEDIN(pds,
               'BUILDING_DESIGN_SCHEMA.' + 'SHAPE_ASPECT.OF_SHAPE') | ((
               'BUILDING_DESIGN_SCHEMA.POSITIVE_COMPONENT' IN TYPEOF(sa)) 
               AND (sa.description = 'main component')) )) = 1) )) = 1;
  END_ENTITY; -- service_element

  ENTITY shape_aspect;
      name                 : label;
      description          : text;
      of_shape             : product_definition_shape;
      product_definitional : LOGICAL;
  END_ENTITY; -- shape_aspect

  ENTITY shape_aspect_relationship;
      name                  : label;
      description           : text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect  : shape_aspect;
  END_ENTITY; -- shape_aspect_relationship

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: ('BUILDING_DESIGN_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(SELF.
               definition.definition)) OR (
               'BUILDING_DESIGN_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
               SELF.definition));
      wr2: 'BUILDING_DESIGN_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(SELF.
               used_representation);
  END_ENTITY; -- shape_definition_representation

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY; -- shape_representation

  ENTITY si_unit
    SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name   : si_unit_name;
    DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := 
                                      dimensions_for_si_unit(SELF.name);
  END_ENTITY; -- si_unit

  ENTITY site
    SUBTYPE OF (characterized_object, product_definition);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION')) >= 1) AND (SIZEOF(
               QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF(USEDIN(pd,
               'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 0) )) = 
               0);
      wr2: SIZEOF(QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,'BUILDING_DESIGN_SCHEMA.' + 
               'PRODUCT_DEFINITION_REPRESENTATION.DEFINITION') | (NOT (
               'BUILDING_DESIGN_SCHEMA.SITE_REPRESENTATION' IN TYPEOF(pdr.
               used_representation))) )) = 0)) )) = 0;
  END_ENTITY; -- site

  ENTITY site_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | 
               (NOT ('BUILDING_DESIGN_SCHEMA.SITE' IN TYPEOF(pdr.definition
               .definition))) )) = 0;
      wr2: SIZEOF(QUERY ( item <* SELF.items | (NOT (SIZEOF([
               'BUILDING_DESIGN_SCHEMA.CONNECTED_FACE_SET',
               'BUILDING_DESIGN_SCHEMA.GEOMETRIC_CURVE_SET'] * TYPEOF(item)) 
               = 1)) )) = 1;
      wr3: SIZEOF(QUERY ( cfs <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.CONNECTED_FACE_SET' IN TYPEOF(item)) )
                | (NOT (SIZEOF(QUERY ( fcs <* cfs\connected_face_set.
               cfs_faces | (NOT (SIZEOF(QUERY ( bnds <* fcs.bounds | (NOT (
               'BUILDING_DESIGN_SCHEMA.POLY_LOOP' IN TYPEOF(bnds.bound))) )) 
               = 0)) )) = 0)) )) = 0;
      wr4: SIZEOF(QUERY ( cfs <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.CONNECTED_FACE_SET' IN TYPEOF(item)) )
                | (NOT (SIZEOF(QUERY ( fcs <* cfs\connected_face_set.
               cfs_faces | (NOT (SIZEOF(QUERY ( bnds <* fcs.bounds | (NOT (
               SIZEOF(bnds.bound\poly_loop.polygon) = 3)) )) = 0)) )) = 0)) )) 
               = 0;
      wr5: SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(item)) )
                | (NOT (SIZEOF(QUERY ( el <* gcs\geometric_set.elements | (
               NOT (SIZEOF(['BUILDING_DESIGN_SCHEMA.CARTESIAN_POINT',
               'BUILDING_DESIGN_SCHEMA.POLYLINE'] * TYPEOF(el)) = 1)) )) = 
               0)) )) = 0;
      wr6: SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(item)) )
                | (NOT (SIZEOF(QUERY ( el <* gcs\geometric_set.elements | (
               'BUILDING_DESIGN_SCHEMA.CARTESIAN_POINT' IN TYPEOF(el)) )) 
               >= 1)) )) = 0;
      wr7: SIZEOF(QUERY ( gcs <* QUERY ( item <* SELF.items | (
               'BUILDING_DESIGN_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(item)) )
                | (NOT (SIZEOF(QUERY ( pline <* QUERY ( el <* gcs\
               geometric_set.elements | ('BUILDING_DESIGN_SCHEMA.POLYLINE' 
               IN TYPEOF(el)) ) | (NOT (SIZEOF(QUERY ( pline_pt <* pline\
               polyline.points | (NOT (pline_pt IN gcs\geometric_set.
               elements)) )) = 0)) )) = 0)) )) = 0;
  END_ENTITY; -- site_representation

  ENTITY solid_model
    SUPERTYPE OF (ONEOF (csg_solid,manifold_solid_brep,swept_area_solid))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- solid_model

  ENTITY space_element
    SUBTYPE OF (product_definition);
    WHERE
      wr1: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ('BUILDING_DESIGN_SCHEMA.BUILDING_SECTION' IN TYPEOF(pdr.
               relating_product_definition)) )) = 1;
      wr2: SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_ITEM_IDENTIFICATION_ASSIGNMENT.ITEM')) = 1;
      wr3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (
               'BUILDING_DESIGN_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
               pd)) )) >= 1) AND (SIZEOF(QUERY ( pds <* QUERY ( pd <* 
               USEDIN(SELF,
               'BUILDING_DESIGN_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | (
               'BUILDING_DESIGN_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
               pd)) ) | (NOT (SIZEOF(USEDIN(pds,'BUILDING_DESIGN_SCHEMA.' +
                'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) >= 1)) )) 
               = 0);
      wr4: SIZEOF(QUERY ( pd <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(
               QUERY ( pdr <* USEDIN(pd,'BUILDING_DESIGN_SCHEMA.' + 
               'PRODUCT_DEFINITION_REPRESENTATION.DEFINITION') | (NOT (
               SIZEOF(TYPEOF(pdr.used_representation) * [
               'BUILDING_DESIGN_SCHEMA.' + 
               'ADVANCED_SPACE_BOUNDARY_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'ELEMENTARY_SPACE_BOUNDARY_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'FACETED_SPACE_BOUNDARY_SHAPE_REPRESENTATION',
               'BUILDING_DESIGN_SCHEMA.' + 
               'GROUND_FACE_SPACE_BOUNDARY_SHAPE_REPRESENTATION']) = 1)) )) 
               = 0)) )) = 0;
  END_ENTITY; -- space_element

  ENTITY sphere
    SUBTYPE OF (geometric_representation_item);
      radius : positive_length_measure;
      centre : point;
  END_ENTITY; -- sphere

  ENTITY spherical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- spherical_surface

  ENTITY structure_enclosure_element
    SUBTYPE OF (product_definition);
    WHERE
      wr1: SIZEOF(QUERY ( pdr <* USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')
                | ('BUILDING_DESIGN_SCHEMA.BUILDING_SECTION' IN TYPEOF(pdr.
               relating_product_definition)) )) = 1;
      wr2: SIZEOF(USEDIN(SELF,'BUILDING_DESIGN_SCHEMA.' + 
               'BUILDING_ITEM_IDENTIFICATION_ASSIGNMENT.ITEM')) = 1;
      wr3: SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
               'BUILDING_DESIGN_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | (
               'BUILDING_DESIGN_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
               pd)) ) | (SIZEOF(QUERY ( sa <* USEDIN(pds,
               'BUILDING_DESIGN_SCHEMA.' + 'SHAPE_ASPECT.OF_SHAPE') | ((
               'BUILDING_DESIGN_SCHEMA.POSITIVE_COMPONENT' IN TYPEOF(sa)) 
               AND (sa.description = 'main component')) )) = 1) )) = 1;
  END_ENTITY; -- structure_enclosure_element

  ENTITY surface
    SUPERTYPE OF (ONEOF (elementary_surface,swept_surface,bounded_surface))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- surface

  ENTITY surface_curve
    SUPERTYPE OF (intersection_curve)
    SUBTYPE OF (curve);
      curve_3d              : curve;
      associated_geometry   : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
    DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: curve_3d.dim = 3;
      wr2: ('BUILDING_DESIGN_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[
               1])) OR (master_representation <> pcurve_s1);
      wr3: ('BUILDING_DESIGN_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[
               2])) OR (master_representation <> pcurve_s2);
      wr4: NOT ('BUILDING_DESIGN_SCHEMA.PCURVE' IN TYPEOF(curve_3d));
  END_ENTITY; -- surface_curve

  ENTITY surface_of_linear_extrusion
    SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
  END_ENTITY; -- surface_of_linear_extrusion

  ENTITY surface_of_revolution
    SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
    DERIVE
      axis_line : line := line(axis_position.location,vector(axis_position
                     .z,1));
  END_ENTITY; -- surface_of_revolution

  ENTITY surface_patch;
      parent_surface : bounded_surface;
      u_transition   : transition_code;
      v_transition   : transition_code;
      u_sense        : BOOLEAN;
      v_sense        : BOOLEAN;
    INVERSE
      using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR 
                          segments;
    WHERE
      wr1: NOT ('BUILDING_DESIGN_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(
               parent_surface));
  END_ENTITY; -- surface_patch

  ENTITY swept_area_solid
    SUPERTYPE OF (ONEOF (revolved_area_solid,extruded_area_solid))
    SUBTYPE OF (solid_model);
      swept_area : curve_bounded_surface;
    WHERE
      wr1: 'BUILDING_DESIGN_SCHEMA.PLANE' IN TYPEOF(swept_area.
               basis_surface);
  END_ENTITY; -- swept_area_solid

  ENTITY swept_surface
    SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,surface_of_revolution))
    SUBTYPE OF (surface);
      swept_curve : curve;
  END_ENTITY; -- swept_surface

  ENTITY topological_representation_item
    SUPERTYPE OF (ONEOF (vertex,edge,face_bound,face,connected_face_set,
        loop ANDOR path))
    SUBTYPE OF (representation_item);
  END_ENTITY; -- topological_representation_item

  ENTITY toroidal_surface
    SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
  END_ENTITY; -- toroidal_surface

  ENTITY torus
    SUBTYPE OF (geometric_representation_item);
      position     : axis1_placement;
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
    WHERE
      wr1: major_radius > minor_radius;
  END_ENTITY; -- torus

  ENTITY trimmed_curve
    SUBTYPE OF (bounded_curve);
      basis_curve           : curve;
      trim_1                : SET [1:2] OF trimming_select;
      trim_2                : SET [1:2] OF trimming_select;
      sense_agreement       : BOOLEAN;
      master_representation : trimming_preference;
    WHERE
      wr1: (HIINDEX(trim_1) = 1) XOR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
      wr2: (HIINDEX(trim_2) = 1) XOR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
  END_ENTITY; -- trimmed_curve

  ENTITY truncated_pyramid
    SUBTYPE OF (boolean_result);
  END_ENTITY; -- truncated_pyramid

  ENTITY uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- uniform_curve

  ENTITY uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- uniform_surface

  ENTITY vector
    SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude   : length_measure;
    WHERE
      wr1: magnitude >= 0;
  END_ENTITY; -- vector

  ENTITY versioned_action_request;
      id          : identifier;
      version     : label;
      purpose     : text;
      description : text;
  END_ENTITY; -- versioned_action_request

  ENTITY vertex
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- vertex

  ENTITY vertex_loop
    SUBTYPE OF (loop);
      loop_vertex : vertex;
  END_ENTITY; -- vertex_loop

  ENTITY vertex_point
    SUBTYPE OF (vertex, geometric_representation_item);
      vertex_geometry : point;
  END_ENTITY; -- vertex_point

  ENTITY week_of_year_and_day_date
    SUBTYPE OF (date);
      week_component : week_in_year_number;
      day_component  : OPTIONAL day_in_week_number;
  END_ENTITY; -- week_of_year_and_day_date

  RULE application_context_requires_ap_definition FOR (application_context, 
                          application_protocol_definition);

  WHERE
    wr1: SIZEOF(QUERY ( ac <* application_context | (NOT (SIZEOF(
             QUERY ( apd <* application_protocol_definition | ((ac :=: apd.
             application) AND (apd.
             application_interpreted_model_schema_name = 
             'building_design_schema')) )) = 1)) )) = 0;

  END_RULE; -- application_context_requires_ap_definition

  RULE building_element_maps_into_building_section FOR (mapped_item, 
             representation_relationship_with_transformation);

  WHERE
    wr1: SIZEOF(QUERY ( mi <* mapped_item | ((SIZEOF(QUERY ( pdr <* 
             USEDIN(mi.mapping_source.mapped_representation,
             'BUILDING_DESIGN_SCHEMA.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')
              | (SIZEOF(TYPEOF(pdr.definition.definition) * [
             'BUILDING_DESIGN_SCHEMA.BUILDING_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.FIXTURE_EQUIPMENT_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.SERVICE_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.SPACE_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.STRUCTURE_ENCLOSURE_ELEMENT']) = 1) )) 
             >= 1) AND (NOT (SIZEOF(QUERY ( r <* USEDIN(mi,
             'BUILDING_DESIGN_SCHEMA.' + 'REPRESENTATION.ITEMS') | (SIZEOF(
             QUERY ( pdr <* USEDIN(r,'BUILDING_DESIGN_SCHEMA.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') | (
             'BUILDING_DESIGN_SCHEMA.BUILDING_SECTION' IN TYPEOF(pdr.
             definition.definition)) )) >= 1) )) = 1))) )) = 0;
    wr2: SIZEOF(QUERY ( rrwt <* 
             representation_relationship_with_transformation | ((SIZEOF(
             QUERY ( pdr <* USEDIN(rrwt\representation_relationship.rep_2,
             'BUILDING_DESIGN_SCHEMA.' + 
             'PROPERTY_DEFINITION_REPRESENTATION.' + 'USED_REPRESENTATION')
              | (SIZEOF(TYPEOF(pdr.definition.definition) * [
             'BUILDING_DESIGN_SCHEMA.BUILDING_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.FIXTURE_EQUIPMENT_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.SERVICE_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.SPACE_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.STRUCTURE_ENCLOSURE_ELEMENT']) = 1) )) 
             >= 1) AND (NOT (SIZEOF(QUERY ( pdr <* USEDIN(rrwt\
             representation_relationship.rep_1,
             'BUILDING_DESIGN_SCHEMA.PROPERTY_DEFINITION_' + 
             'REPRESENTATION.USED_REPRESENTATION') | (
             'BUILDING_DESIGN_SCHEMA.BUILDING_SECTION' IN TYPEOF(pdr.
             definition.definition)) )) = 1))) )) = 0;
    wr3: SIZEOF(QUERY ( rrwt_1 <* 
             representation_relationship_with_transformation | (SIZEOF(
             QUERY ( rrwt_2 <* 
             representation_relationship_with_transformation | ((SIZEOF(
             QUERY ( pdr <* USEDIN(rrwt_1\representation_relationship.rep_2,
             'BUILDING_DESIGN_SCHEMA.PROPERTY_DEFINITION_' + 
             'REPRESENTATION.USED_REPRESENTATION') | (SIZEOF(TYPEOF(pdr.
             definition.definition) * [
             'BUILDING_DESIGN_SCHEMA.BUILDING_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.FIXTURE_EQUIPMENT_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.SERVICE_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.SPACE_ELEMENT',
             'BUILDING_DESIGN_SCHEMA.' + 'STRUCTURE_ENCLOSURE_ELEMENT']) = 
             1) )) >= 1) AND (rrwt_1\representation_relationship.rep_2 = 
             rrwt_2\representation_relationship.rep_2)) )) >= 1) )) = 0;

  END_RULE; -- building_element_maps_into_building_section

  RULE compatible_dimension FOR (cartesian_point, direction, 
             representation_context, geometric_representation_context);

  WHERE
    wr1: SIZEOF(QUERY ( x <* cartesian_point | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.coordinates) <> y.coordinate_space_dimension)) )) > 
             0) )) = 0;
    wr2: SIZEOF(QUERY ( x <* direction | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)) )) 
             > 0) )) = 0;

  END_RULE; -- compatible_dimension

  RULE geometric_representation_context_3d FOR (
             geometric_representation_context);

  WHERE
    wr1: SIZEOF(QUERY ( grc <* geometric_representation_context | (NOT (
             grc.coordinate_space_dimension = 3)) )) = 0;

  END_RULE; -- geometric_representation_context_3d

  RULE restrict_application_context FOR (application_context);

  WHERE
    wr1: SIZEOF(QUERY ( ac <* application_context | (NOT (ac.application =
              'building shape composition')) )) = 0;

  END_RULE; -- restrict_application_context

  RULE restrict_origin_and_target FOR (mapped_item);

  WHERE
    wr1: SIZEOF(QUERY ( mi <* mapped_item | (NOT ((
             'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(mi.
             mapping_target)) AND (
             'BUILDING_DESIGN_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(mi.
             mapping_source.mapping_origin)))) )) = 0;

  END_RULE; -- restrict_origin_and_target

  RULE shape_representation_subtype_exclusiveness FOR (
             shape_representation);

  WHERE
    wr1: SIZEOF(QUERY ( sr <* shape_representation | (NOT (SIZEOF(TYPEOF(
             sr) * ['BUILDING_DESIGN_SCHEMA.' + 
             'ADVANCED_BREP_BUILDING_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.ADVANCED_CSG_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.' + 
             'ADVANCED_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.' + 
             'ADVANCED_SPACE_BOUNDARY_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.ADVANCED_WIRE_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.ELEMENTARY_CSG_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.' + 
             'ELEMENTARY_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION','BUILDING_DESIGN_SCHEMA.ELEMENTARY_GEOMETRIC_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.' + 
             'ELEMENTARY_SPACE_BOUNDARY_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.' + 
             'ELEMENTARY_WIRE_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.FACETED_CSG_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.' + 
             'FACETED_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION','BUILDING_DESIGN_SCHEMA.FACETED_GEOMETRIC_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.' + 
             'FACETED_SPACE_BOUNDARY_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.FACETED_WIRE_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.' + 
             'GROUND_FACE_SPACE_BOUNDARY_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.SITE_REPRESENTATION']) <= 1)) )) = 0;

  END_RULE; -- shape_representation_subtype_exclusiveness

  RULE subtype_mandatory_geometric_set FOR (geometric_set);

  WHERE
    wr1: SIZEOF(QUERY ( gs <* geometric_set | (NOT (
             'BUILDING_DESIGN_SCHEMA.GEOMETRIC_CURVE_SET' IN TYPEOF(gs))) )) 
             = 0;

  END_RULE; -- subtype_mandatory_geometric_set

  RULE subtype_mandatory_group FOR (group);

  WHERE
    wr1: SIZEOF(QUERY ( g <* group | (NOT ('BUILDING_DESIGN_SCHEMA.BUILDING_COMPONENT_CLASSIFICATION_GROUP' 
             IN TYPEOF(g))) )) = 0;

  END_RULE; -- subtype_mandatory_group

  RULE subtype_mandatory_solid_model FOR (solid_model);

  WHERE
    wr1: SIZEOF(QUERY ( sm <* solid_model | (NOT (SIZEOF(TYPEOF(sm) * [
             'BUILDING_DESIGN_SCHEMA.CSG_SOLID',
             'BUILDING_DESIGN_SCHEMA.MANIFOLD_SOLID_BREP',
             'BUILDING_DESIGN_SCHEMA.EXTRUDED_AREA_SOLID',
             'BUILDING_DESIGN_SCHEMA.REVOLVED_AREA_SOLID',
             'BUILDING_DESIGN_SCHEMA.' + 
             'ADVANCED_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.' + 
             'ELEMENTARY_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION',
             'BUILDING_DESIGN_SCHEMA.' + 
             'FACETED_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION']) = 1)) )) 
             = 0;

  END_RULE; -- subtype_mandatory_solid_model

  FUNCTION acyclic_curve_replica(
               rep: curve_replica;
               parent: curve
      ): BOOLEAN;
    IF NOT ('BUILDING_DESIGN_SCHEMA.CURVE_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
    END_IF;

  END_FUNCTION; -- acyclic_curve_replica

  FUNCTION acyclic_mapped_representation(
               parent_set: SET OF representation;
               children_set: SET OF representation_item
      ): BOOLEAN;

    LOCAL
      i : INTEGER;
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z <* children_set | ('BUILDING_DESIGN_SCHEMA.MAPPED_ITEM' 
        IN TYPEOF(z)) );
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN 
            parent_set THEN
          RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | (
            'BUILDING_DESIGN_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_mapped_representation

  FUNCTION acyclic_product_category_relationship(
               relation: product_category_relationship;
               children: SET OF product_category
      ): LOGICAL;

    LOCAL
      i              : INTEGER;
      x              : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(children) BY 1;
      IF relation.category :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category,'BUILDING_DESIGN_SCHEMA.' + 
        'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_category_relationship(x[i],local_children)
             THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_category_relationship

  FUNCTION acyclic_product_definition_relationship(
               relation: product_definition_relationship;
               relatives: SET OF product_definition;
               specific_relation: STRING
      ): LOGICAL;

    LOCAL
      i               : INTEGER;
      x               : SET OF product_definition_relationship;
      local_relatives : SET OF product_definition;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(relatives) BY 1;
      IF relation.relating_product_definition :=: relatives[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.relating_product_definition,
        specific_relation));
    local_relatives := relatives + relation.relating_product_definition;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_definition_relationship(x[i],
            local_relatives,specific_relation) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_definition_relationship

  FUNCTION associated_surface(
               arg: pcurve_or_surface
      ): surface;

    LOCAL
      surf : surface;
    END_LOCAL;
    IF 'BUILDING_DESIGN_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
      surf := arg.basis_surface;
    ELSE
      surf := arg;
    END_IF;
    RETURN(surf);

  END_FUNCTION; -- associated_surface

  FUNCTION bag_to_set(
               the_bag: BAG OF GENERIC:intype
      ): SET OF GENERIC:intype;

    LOCAL
      i       : INTEGER;
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);

  END_FUNCTION; -- bag_to_set

  FUNCTION base_axis(
               dim: INTEGER;
               axis1, axis2, axis3: direction
      ): LIST [2:3] OF direction;

    LOCAL
      u      : LIST [2:3] OF direction;
      vec    : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      u[3] := NVL(normalise(axis3),direction([0,0,1]));
      u[1] := first_proj_axis(u[3],axis1);
      u[2] := second_proj_axis(u[3],u[1],axis2);
    ELSE
      u[3] := ?;
      IF EXISTS(axis1) THEN
        u[1] := normalise(axis1);
        u[2] := orthogonal_complement(u[1]);
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor < 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          u[2] := normalise(axis2);
          u[1] := orthogonal_complement(u[2]);
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u[1].direction_ratios[1] := 1;
          u[1].direction_ratios[2] := 0;
          u[2].direction_ratios[1] := 0;
          u[2].direction_ratios[2] := 1;
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);

  END_FUNCTION; -- base_axis

  FUNCTION boolean_choose(
               b: BOOLEAN;
               choice1, choice2: GENERIC:item
      ): GENERIC:item;
    IF b THEN
      RETURN(choice1);
    ELSE
      RETURN(choice2);
    END_IF;

  END_FUNCTION; -- boolean_choose

  FUNCTION build_2axes(
               ref_direction: direction
      ): LIST [2:2] OF direction;

    LOCAL
      u : LIST [2:2] OF direction;
    END_LOCAL;
    u[1] := NVL(normalise(ref_direction),direction([1,0]));
    u[2] := orthogonal_complement(u[1]);
    RETURN(u);

  END_FUNCTION; -- build_2axes

  FUNCTION build_axes(
               axis, ref_direction: direction
      ): LIST [3:3] OF direction;

    LOCAL
      u : LIST [3:3] OF direction;
    END_LOCAL;
    u[3] := NVL(normalise(axis),direction([0,0,1]));
    u[1] := first_proj_axis(u[3],ref_direction);
    u[2] := normalise(cross_product(u[3],u[1])).orientation;
    RETURN(u);

  END_FUNCTION; -- build_axes

  FUNCTION conditional_reverse(
               p: BOOLEAN;
               an_item: reversible_topology
      ): reversible_topology;
    IF p THEN
      RETURN(an_item);
    ELSE
      RETURN(topology_reversed(an_item));
    END_IF;

  END_FUNCTION; -- conditional_reverse

  FUNCTION constraints_composite_curve_on_surface(
               c: composite_curve_on_surface
      ): BOOLEAN;

    LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
    END_LOCAL;
    REPEAT k := 1 TO n_segments BY 1;
      IF (NOT ('BUILDING_DESIGN_SCHEMA.PCURVE' IN TYPEOF(c\composite_curve
          .segments[k].parent_curve))) AND (NOT (
          'BUILDING_DESIGN_SCHEMA.SURFACE_CURVE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) AND (NOT (
          'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_composite_curve_on_surface

  FUNCTION constraints_param_b_spline(
               degree, up_knots, up_cp: INTEGER;
               knot_mult: LIST OF INTEGER;
               knots: LIST OF parameter_value
      ): BOOLEAN;

    LOCAL
      k      : INTEGER;
      l      : INTEGER;
      sum    : INTEGER;
      result : BOOLEAN := TRUE;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (
        degree + up_cp + 2)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[1];
    IF (k < 1) OR (k > (degree + 1)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      k := knot_mult[i];
      IF (i < up_knots) AND (k > degree) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      IF (i = up_knots) AND (k > (degree + 1)) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_param_b_spline

  FUNCTION constraints_rectangular_composite_surface(
               s: rectangular_composite_surface
      ): BOOLEAN;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF NOT (('BUILDING_DESIGN_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(s.
            segments[i][j].parent_surface)) OR (
            'BUILDING_DESIGN_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(
            s.segments[i][j].parent_surface))) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u - 1 BY 1;
      REPEAT j := 1 TO s.n_v BY 1;
        IF s.segments[i][j].u_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO s.n_u BY 1;
      REPEAT j := 1 TO s.n_v - 1 BY 1;
        IF s.segments[i][j].v_transition = discontinuous THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_rectangular_composite_surface

  FUNCTION cross_product(
               arg1, arg2: direction
      ): vector;

    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN
      RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res.direction_ratios[1] := (v1[2] * v2[3]) - (v1[3] * v2[2]);
        res.direction_ratios[2] := (v1[3] * v2[1]) - (v1[1] * v2[3]);
        res.direction_ratios[3] := (v1[1] * v2[2]) - (v1[2] * v2[1]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result.orientation := res;
          result.magnitude := SQRT(mag);
        ELSE
          result.orientation := arg1;
          result.magnitude := 0;
        END_IF;
        RETURN(result);
      END;
    END_IF;

  END_FUNCTION; -- cross_product

  FUNCTION curve_weights_positive(
               b: rational_b_spline_curve
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
      IF b.weights[i] <= 0 THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- curve_weights_positive

  FUNCTION derive_dimensional_exponents(
               x: unit
      ): dimensional_exponents;

    LOCAL
      i      : INTEGER;
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'BUILDING_DESIGN_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
        result.length_exponent := result.length_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent * 
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- derive_dimensional_exponents

  FUNCTION dimension_of(
               item: geometric_representation_item
      ): dimension_count;

    LOCAL
      x : SET OF representation;
      y : representation_context;
    END_LOCAL;
    x := using_representations(item);
    y := x[1].context_of_items;
    RETURN(y\geometric_representation_context.coordinate_space_dimension);

  END_FUNCTION; -- dimension_of

  FUNCTION dimensions_for_si_unit(
               n: si_unit_name
      ): dimensional_exponents;
    CASE n OF
      metre         :         RETURN(dimensional_exponents(1,0,0,0,0,0,0));
      gram          :         RETURN(dimensional_exponents(0,1,0,0,0,0,0));
      second        :         RETURN(dimensional_exponents(0,0,1,0,0,0,0));
      ampere        :         RETURN(dimensional_exponents(0,0,0,1,0,0,0));
      kelvin        :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      mole          :         RETURN(dimensional_exponents(0,0,0,0,0,1,0));
      candela       :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      radian        :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      steradian     :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      hertz         :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      newton        :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
      pascal        :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
      joule         :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
      watt          :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
      coulomb       :         RETURN(dimensional_exponents(0,0,1,1,0,0,0));
      volt          :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
      farad         :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
      ohm           :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
      siemens       :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
      weber         :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
      tesla         :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
      henry         :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
      degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      lumen         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      lux           :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
      becquerel     :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      gray          :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      sievert       :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      END_CASE;

  END_FUNCTION; -- dimensions_for_si_unit

  FUNCTION dot_product(
               arg1, arg2: direction
      ): REAL;

    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim <> arg2.dim THEN
        scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);

  END_FUNCTION; -- dot_product

  FUNCTION edge_reversed(
               an_edge: edge
      ): edge;

    LOCAL
      the_reverse : edge;
    END_LOCAL;
    IF 'BUILDING_DESIGN_SCHEMA.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
      the_reverse := oriented_edge(an_edge\oriented_edge.edge_element,NOT 
          an_edge\oriented_edge.orientation);
    ELSE
      the_reverse := oriented_edge(an_edge,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- edge_reversed

  FUNCTION face_bound_reversed(
               a_face_bound: face_bound
      ): face_bound;

    LOCAL
      the_reverse : face_bound;
    END_LOCAL;
    IF 'BUILDING_DESIGN_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)
         THEN
      the_reverse := face_bound(a_face_bound\face_bound.bound,NOT 
          a_face_bound\face_bound.orientation);
    ELSE
      the_reverse := face_bound(a_face_bound.bound,NOT a_face_bound.
          orientation);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_bound_reversed

  FUNCTION face_reversed(
               a_face: face
      ): face;

    LOCAL
      the_reverse : face;
    END_LOCAL;
    IF 'BUILDING_DESIGN_SCHEMA.ORIENTED_FACE' IN TYPEOF(a_face) THEN
      the_reverse := oriented_face(a_face\oriented_face.face_element,NOT 
          a_face\oriented_face.orientation);
    ELSE
      the_reverse := oriented_face(a_face,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_reversed

  FUNCTION first_proj_axis(
               z_axis, arg: direction
      ): direction;

    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF (NOT EXISTS(z_axis)) OR (NOT EXISTS(arg)) OR (arg.dim <> 3) THEN
      x_axis := ?;
    ELSE
      z_axis := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z_axis <> direction([1,0,0]) THEN
          v := direction([1,0,0]);
        ELSE
          v := direction([0,1,0]);
        END_IF;
      ELSE
        IF cross_product(arg,z).magnitude = 0 THEN
          RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z_axis);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);

  END_FUNCTION; -- first_proj_axis

  FUNCTION get_basis_surface(
               c: curve_on_surface
      ): SET [0:2] OF surface;

    LOCAL
      surfs : SET [0:2] OF surface;
      n     : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'BUILDING_DESIGN_SCHEMA.PCURVE' IN TYPEOF(c) THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'BUILDING_DESIGN_SCHEMA.SURFACE_CURVE' IN TYPEOF(c) THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n BY 1;
          surfs := surfs + associated_surface(c\surface_curve.
              associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
         THEN
      n := SIZEOF(c\composite_curve.segments);
      surfs := get_basis_surface(c\composite_curve.segments[1].
          parent_curve);
      IF n > 1 THEN
        REPEAT i := 2 TO n BY 1;
          surfs := surfs * get_basis_surface(c\composite_curve.
              segments[i].parent_curve);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(surfs);

  END_FUNCTION; -- get_basis_surface

  FUNCTION item_in_context(
               item: representation_item;
               cntxt: representation_context
      ): BOOLEAN;

    LOCAL
      i : INTEGER;
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,'BUILDING_DESIGN_SCHEMA.REPRESENTATION.ITEMS') *
         cntxt.representations_in_context) > 0 THEN
      RETURN(TRUE);
    ELSE
      y := QUERY ( z <* USEDIN(item,'') | (
          'BUILDING_DESIGN_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) );
      IF SIZEOF(y) > 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN
            RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- item_in_context

  FUNCTION leap_year(
               year: year_number
      ): BOOLEAN;
    IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
         0) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- leap_year

  FUNCTION list_face_loops(
               f: face
      ): LIST [0:?] OF loop;

    LOCAL
      loops : LIST [0:?] OF loop := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
      loops := loops + f.bounds[i].bound;
    END_REPEAT;
    RETURN(loops);

  END_FUNCTION; -- list_face_loops

  FUNCTION list_of_topology_reversed(
               a_list: list_of_reversible_topology_item
      ): list_of_reversible_topology_item;

    LOCAL
      the_reverse : list_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_list) BY 1;
      the_reverse := topology_reversed(a_list[i]) + the_reverse;
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- list_of_topology_reversed

  FUNCTION list_to_array(
               lis: LIST [0:?] OF GENERIC:t;
               low, u: INTEGER
      ): ARRAY [low:u] OF GENERIC:t;

    LOCAL
      n   : INTEGER;
      res : ARRAY [low:u] OF GENERIC:t;
    END_LOCAL;
    n := SIZEOF(lis);
    IF n <> ((u - low) + 1) THEN
      RETURN(?);
    ELSE
      REPEAT i := 1 TO n BY 1;
        res[(low + i) - 1] := lis[i];
      END_REPEAT;
      RETURN(res);
    END_IF;

  END_FUNCTION; -- list_to_array

  FUNCTION list_to_set(
               l: LIST [0:?] OF GENERIC:t
      ): SET OF GENERIC:t;

    LOCAL
      s : SET OF GENERIC:t := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(l) BY 1;
      s := s + l[i];
    END_REPEAT;
    RETURN(s);

  END_FUNCTION; -- list_to_set

  FUNCTION make_array_of_array(
               lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;
               low1, u1, low2, u2: INTEGER
      ): ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;

    LOCAL
      n2   : INTEGER;
      n1   : INTEGER;
      res  : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
      resl : LIST [1:?] OF ARRAY [low2:u2] OF GENERIC:t;
    END_LOCAL;
    n1 := SIZEOF(lis);
    n2 := SIZEOF(lis[1]);
    IF (n1 <> ((u1 - low1) + 1)) AND (n2 <> ((u2 - low2) + 1)) THEN
      RETURN(?);
    END_IF;
    REPEAT i := 1 TO n1 BY 1;
      IF SIZEOF(lis[i]) <> n2 THEN
        RETURN(?);
      END_IF;
    END_REPEAT;
    REPEAT i := 1 TO n1 BY 1;
      resl[i] := list_to_array(lis[i],low2,u2);
    END_REPEAT;
    res := list_to_array(resl,low1,u1);
    RETURN(res);

  END_FUNCTION; -- make_array_of_array

  FUNCTION mixed_loop_type_set(
               l: SET [0:?] OF loop
      ): LOGICAL;

    LOCAL
      i              : INTEGER;
      poly_loop_type : LOGICAL;
    END_LOCAL;
    IF SIZEOF(l) <= 1 THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := 'BUILDING_DESIGN_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]);
    REPEAT i := 2 TO SIZEOF(l) BY 1;
      IF ('BUILDING_DESIGN_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> 
          poly_loop_type THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);

  END_FUNCTION; -- mixed_loop_type_set

  FUNCTION msb_shells(
               brep: manifold_solid_brep
      ): SET [1:?] OF closed_shell;
    IF SIZEOF(QUERY ( brtyp <* TYPEOF(brep) | (brtyp LIKE 
        '*.BREP_WITH_VOIDS') )) >= 1 THEN
      RETURN(brep\brep_with_voids.voids + brep.outer);
    ELSE
      RETURN([brep.outer]);
    END_IF;

  END_FUNCTION; -- msb_shells

  FUNCTION normalise(
               arg: vector_or_direction
      ): vector_or_direction;

    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      result := ?;
    ELSE
      ndim := arg.dim;
      IF 'BUILDING_DESIGN_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
          vec := arg;
          v := arg.orientation;
          IF arg.magnitude = 0 THEN
            RETURN(?);
          ELSE
            vec.magnitude := 1;
          END_IF;
        END;
      ELSE
        v := arg;
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'BUILDING_DESIGN_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- normalise

  FUNCTION orthogonal_complement(
               vec: direction
      ): direction;

    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      result.direction_ratios[1] := -vec.direction_ratios[2];
      result.direction_ratios[2] := vec.direction_ratios[1];
      RETURN(result);
    END_IF;

  END_FUNCTION; -- orthogonal_complement

  FUNCTION path_head_to_tail(
               a_path: path
      ): LOGICAL;

    LOCAL
      n : INTEGER;
      p : BOOLEAN := TRUE;
    END_LOCAL;
    n := SIZEOF(a_path.edge_list);
    REPEAT i := 2 TO n BY 1;
      p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
          .edge_start);
    END_REPEAT;
    RETURN(p);

  END_FUNCTION; -- path_head_to_tail

  FUNCTION path_reversed(
               a_path: path
      ): path;

    LOCAL
      the_reverse : path;
    END_LOCAL;
    IF 'BUILDING_DESIGN_SCHEMA.ORIENTED_PATH' IN TYPEOF(a_path) THEN
      the_reverse := oriented_path(a_path\oriented_path.path_element,NOT 
          a_path\oriented_path.orientation);
    ELSE
      the_reverse := oriented_path(a_path,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- path_reversed

  FUNCTION scalar_times_vector(
               scalar: REAL;
               vec: vector_or_direction
      ): vector;

    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
      result := ?;
    ELSE
      IF 'BUILDING_DESIGN_SCHEMA.VECTOR' IN TYPEOF(vec) THEN
        v := vec.orientation;
        mag := scalar * vec.magnitude;
      ELSE
        v := vec;
        mag := scalar;
      END_IF;
      IF mag < 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result.orientation := normalise(v);
      result.magnitude := mag;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- scalar_times_vector

  FUNCTION second_proj_axis(
               z_axis, x_axis, arg: direction
      ): direction;

    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);

  END_FUNCTION; -- second_proj_axis

  FUNCTION set_of_topology_reversed(
               a_set: set_of_reversible_topology_item
      ): set_of_reversible_topology_item;

    LOCAL
      the_reverse : set_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_set) BY 1;
      the_reverse := the_reverse + topology_reversed(a_set[i]);
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- set_of_topology_reversed

  FUNCTION shell_reversed(
               a_shell: shell
      ): shell;

    LOCAL
      the_reverse : shell;
    END_LOCAL;
    IF 'BUILDING_DESIGN_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := oriented_open_shell(a_shell\oriented_open_shell.
          open_shell_element,NOT a_shell\oriented_open_shell.orientation);
    ELSE
      IF 'BUILDING_DESIGN_SCHEMA.OPEN_SHELL' IN TYPEOF(a_shell) THEN
        the_reverse := oriented_open_shell(a_shell,FALSE);
      ELSE
        IF 'BUILDING_DESIGN_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(
            a_shell) THEN
          the_reverse := oriented_closed_shell(a_shell\
              oriented_closed_shell.closed_shell_element,NOT a_shell\
              oriented_closed_shell.orientation);
        ELSE
          IF 'BUILDING_DESIGN_SCHEMA.CLOSED_SHELL' IN TYPEOF(a_shell)
               THEN
            the_reverse := oriented_closed_shell(a_shell,FALSE);
          ELSE
            the_reverse := ?;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- shell_reversed

  FUNCTION surface_weights_positive(
               b: rational_b_spline_surface
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        IF b.weights[i][j] <= 0 THEN
          result := FALSE;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- surface_weights_positive

  FUNCTION topology_reversed(
               an_item: reversible_topology
      ): reversible_topology;
    IF 'BUILDING_DESIGN_SCHEMA.EDGE' IN TYPEOF(an_item) THEN
      RETURN(edge_reversed(an_item));
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.PATH' IN TYPEOF(an_item) THEN
      RETURN(path_reversed(an_item));
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.FACE_BOUND' IN TYPEOF(an_item) THEN
      RETURN(face_bound_reversed(an_item));
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.FACE' IN TYPEOF(an_item) THEN
      RETURN(face_reversed(an_item));
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.SHELL' IN TYPEOF(an_item) THEN
      RETURN(shell_reversed(an_item));
    END_IF;
    IF 'SET' IN TYPEOF(an_item) THEN
      RETURN(set_of_topology_reversed(an_item));
    END_IF;
    IF 'LIST' IN TYPEOF(an_item) THEN
      RETURN(list_of_topology_reversed(an_item));
    END_IF;
    RETURN(?);

  END_FUNCTION; -- topology_reversed

  FUNCTION using_representations(
               item: representation_item
      ): SET OF representation;

    LOCAL
      results            : SET OF representation;
      i                  : INTEGER;
      intermediate_items : SET OF representation_item;
      result_bag         : BAG OF representation;
    END_LOCAL;
    result_bag := USEDIN(item,
        'BUILDING_DESIGN_SCHEMA.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | (
        'BUILDING_DESIGN_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) );
    IF SIZEOF(intermediate_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        results := results + using_representations(intermediate_items[i]);
      END_REPEAT;
    END_IF;
    RETURN(results);

  END_FUNCTION; -- using_representations

  FUNCTION valid_advanced_csg_tree(
               tree_element: boolean_operand
      ): BOOLEAN;
    IF SIZEOF(TYPEOF(tree_element) * ['BUILDING_DESIGN_SCHEMA.BLOCK',
        'BUILDING_DESIGN_SCHEMA.TORUS',
        'BUILDING_DESIGN_SCHEMA.RIGHT_CIRCULAR_CYLINDER',
        'BUILDING_DESIGN_SCHEMA.SPHERE',
        'BUILDING_DESIGN_SCHEMA.RIGHT_CIRCULAR_CONE',
        'BUILDING_DESIGN_SCHEMA.' + 
        'ADVANCED_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION',
        'BUILDING_DESIGN_SCHEMA.EXTRUDED_AREA_SOLID',
        'BUILDING_DESIGN_SCHEMA.REVOLVED_AREA_SOLID',
        'BUILDING_DESIGN_SCHEMA.HALF_SPACE_SOLID']) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'BUILDING_DESIGN_SCHEMA.BOOLEAN_RESULT' IN TYPEOF(tree_element)
           THEN
        IF NOT (tree_element\boolean_result.operator IN ['union',
            'difference']) THEN
          RETURN(FALSE);
        END_IF;
        IF 'BUILDING_DESIGN_SCHEMA.HALF_SPACE_SOLID' IN TYPEOF(
            tree_element\boolean_result.first_operand) THEN
          IF 'BUILDING_DESIGN_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(
              tree_element\boolean_result.first_operand\half_space_solid.
              base_surface) THEN
            IF 'BUILDING_DESIGN_SCHEMA.HALF_SPACE_SOLID' IN TYPEOF(
                tree_element\boolean_result.second_operand) THEN
              IF 'BUILDING_DESIGN_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(
                  tree_element\boolean_result.second_operand\
                  half_space_solid.base_surface) THEN
                RETURN(TRUE);
              ELSE
                RETURN(FALSE);
              END_IF;
            ELSE
              RETURN(valid_advanced_csg_tree(tree_element\boolean_result.
                  second_operand));
            END_IF;
          ELSE
            RETURN(FALSE);
          END_IF;
        ELSE
          IF 'BUILDING_DESIGN_SCHEMA.HALF_SPACE_SOLID' IN TYPEOF(
              tree_element\boolean_result.second_operand) THEN
            IF 'BUILDING_DESIGN_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(
                tree_element\boolean_result.second_operand\half_space_solid
                .base_surface) THEN
              RETURN(valid_advanced_csg_tree(tree_element\boolean_result.
                  first_operand));
            ELSE
              RETURN(FALSE);
            END_IF;
          ELSE
            RETURN(valid_advanced_csg_tree(tree_element\boolean_result.
                first_operand) AND valid_advanced_csg_tree(tree_element\
                boolean_result.second_operand));
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_advanced_csg_tree

  FUNCTION valid_advanced_wire_composition(
               sw_element: curve
      ): BOOLEAN;
    IF SIZEOF(['BUILDING_DESIGN_SCHEMA.B_SPLINE_CURVE',
        'BUILDING_DESIGN_SCHEMA.CONIC','BUILDING_DESIGN_SCHEMA.LINE',
        'BUILDING_DESIGN_SCHEMA.POLYLINE'] * TYPEOF(sw_element)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'BUILDING_DESIGN_SCHEMA.CURVE_REPLICA' IN TYPEOF(sw_element)
           THEN
        RETURN(valid_advanced_wire_composition(sw_element\curve_replica.
            parent_curve));
      ELSE
        IF 'BUILDING_DESIGN_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF(sw_element)
             THEN
          RETURN(valid_advanced_wire_composition(sw_element\
              offset_curve_3d.basis_curve));
        ELSE
          IF 'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(sw_element)
               THEN
            RETURN(valid_faceted_wire_composition(sw_element\trimmed_curve
                .basis_curve));
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_advanced_wire_composition

  FUNCTION valid_calendar_date(
               date: calendar_date
      ): LOGICAL;
    IF NOT ((1 <= date.day_component) AND (date.day_component <= 31))
         THEN
      RETURN(FALSE);
    END_IF;
    CASE date.month_component OF
      4        :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      6        :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      9        :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      11       :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      2        :         BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND (date.day_component <= 28));
          END_IF;
        END;
      OTHERWISE  :         RETURN(TRUE);
      END_CASE;

  END_FUNCTION; -- valid_calendar_date

  FUNCTION valid_elementary_csg_tree(
               tree_element: boolean_operand
      ): BOOLEAN;
    IF SIZEOF(TYPEOF(tree_element) * ['BUILDING_DESIGN_SCHEMA.BLOCK',
        'BUILDING_DESIGN_SCHEMA.TORUS',
        'BUILDING_DESIGN_SCHEMA.RIGHT_CIRCULAR_CYLINDER',
        'BUILDING_DESIGN_SCHEMA.SPHERE',
        'BUILDING_DESIGN_SCHEMA.RIGHT_CIRCULAR_CONE',
        'BUILDING_DESIGN_SCHEMA.' + 
        'ELEMENTARY_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION',
        'BUILDING_DESIGN_SCHEMA.EXTRUDED_AREA_SOLID',
        'BUILDING_DESIGN_SCHEMA.REVOLVED_AREA_SOLID',
        'BUILDING_DESIGN_SCHEMA.HALF_SPACE_SOLID']) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'BUILDING_DESIGN_SCHEMA.BOOLEAN_RESULT' IN TYPEOF(tree_element)
           THEN
        IF NOT (tree_element\boolean_result.operator IN ['union',
            'difference']) THEN
          RETURN(FALSE);
        END_IF;
        IF 'BUILDING_DESIGN_SCHEMA.HALF_SPACE_SOLID' IN TYPEOF(
            tree_element\boolean_result.first_operand) THEN
          IF 'BUILDING_DESIGN_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(
              tree_element\boolean_result.first_operand\half_space_solid.
              base_surface) THEN
            IF 'BUILDING_DESIGN_SCHEMA.HALF_SPACE_SOLID' IN TYPEOF(
                tree_element\boolean_result.second_operand) THEN
              IF 'BUILDING_DESIGN_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(
                  tree_element\boolean_result.second_operand\
                  half_space_solid.base_surface) THEN
                RETURN(TRUE);
              ELSE
                RETURN(FALSE);
              END_IF;
            ELSE
              RETURN(valid_elementary_csg_tree(tree_element\boolean_result
                  .second_operand));
            END_IF;
          ELSE
            RETURN(FALSE);
          END_IF;
        ELSE
          IF 'BUILDING_DESIGN_SCHEMA.HALF_SPACE_SOLID' IN TYPEOF(
              tree_element\boolean_result.second_operand) THEN
            IF 'BUILDING_DESIGN_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(
                tree_element\boolean_result.second_operand\half_space_solid
                .base_surface) THEN
              RETURN(valid_elementary_csg_tree(tree_element\boolean_result
                  .first_operand));
            ELSE
              RETURN(FALSE);
            END_IF;
          ELSE
            RETURN(valid_elementary_csg_tree(tree_element\boolean_result.
                first_operand) AND valid_elementary_csg_tree(tree_element\
                boolean_result.second_operand));
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_elementary_csg_tree

  FUNCTION valid_elementary_wire_composition(
               sw_element: curve
      ): BOOLEAN;
    IF SIZEOF(['BUILDING_DESIGN_SCHEMA.LINE',
        'BUILDING_DESIGN_SCHEMA.CONIC'] * TYPEOF(sw_element)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(sw_element)
           THEN
        RETURN(valid_elementary_wire_composition(sw_element\trimmed_curve.
            basis_curve));
      ELSE
        IF 'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE' IN TYPEOF(sw_element)
             THEN
          RETURN(SIZEOF(QUERY ( ccs <* sw_element\composite_curve.segments
               | (NOT valid_elementary_wire_composition(ccs.parent_curve)) )) 
              = 0);
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_elementary_wire_composition

  FUNCTION valid_faceted_csg_tree(
               tree_element: boolean_operand
      ): BOOLEAN;
    IF SIZEOF(['BUILDING_DESIGN_SCHEMA.BLOCK','BUILDING_DESIGN_SCHEMA.' + 
        'FACETED_FACE_WITH_THICKNESS_SHAPE_REPRESENTATION'] * TYPEOF(
        tree_element)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'BUILDING_DESIGN_SCHEMA.BOOLEAN_RESULT' IN TYPEOF(tree_element)
           THEN
        IF NOT (tree_element\boolean_result.operator IN ['union',
            'difference']) THEN
          RETURN(FALSE);
        END_IF;
        IF 'BUILDING_DESIGN_SCHEMA.HALF_SPACE_SOLID' IN TYPEOF(
            tree_element\boolean_result.first_operand) THEN
          IF 'BUILDING_DESIGN_SCHEMA.PLANE' IN TYPEOF(tree_element\
              boolean_result.first_operand\half_space_solid.base_surface)
               THEN
            IF 'BUILDING_DESIGN_SCHEMA.HALF_SPACE_SOLID' IN TYPEOF(
                tree_element\boolean_result.second_operand) THEN
              IF 'BUILDING_DESIGN_SCHEMA.PLANE' IN TYPEOF(tree_element\
                  boolean_result.second_operand\half_space_solid.
                  base_surface) THEN
                RETURN(TRUE);
              ELSE
                RETURN(FALSE);
              END_IF;
            ELSE
              RETURN(valid_faceted_csg_tree(tree_element\boolean_result.
                  second_operand));
            END_IF;
          ELSE
            RETURN(FALSE);
          END_IF;
        ELSE
          IF 'BUILDING_DESIGN_SCHEMA.HALF_SPACE_SOLID' IN TYPEOF(
              tree_element\boolean_result.second_operand) THEN
            IF 'BUILDING_DESIGN_SCHEMA.PLANE' IN TYPEOF(tree_element\
                boolean_result.second_operand\half_space_solid.base_surface)
                 THEN
              RETURN(valid_faceted_csg_tree(tree_element\boolean_result.
                  first_operand));
            ELSE
              RETURN(FALSE);
            END_IF;
          ELSE
            RETURN(valid_faceted_csg_tree(tree_element\boolean_result.
                first_operand) AND valid_faceted_csg_tree(tree_element\
                boolean_result.second_operand));
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_faceted_csg_tree

  FUNCTION valid_faceted_wire_composition(
               sw_element: curve
      ): BOOLEAN;
    IF 'BUILDING_DESIGN_SCHEMA.POLYLINE' IN TYPEOF(sw_element) THEN
      RETURN(TRUE);
    ELSE
      IF 'BUILDING_DESIGN_SCHEMA.TRIMMED_CURVE' IN TYPEOF(sw_element)
           THEN
        IF SIZEOF(['BUILDING_DESIGN_SCHEMA.LINE',
            'BUILDING_DESIGN_SCHEMA.CONIC'] * TYPEOF(sw_element\
            trimmed_curve.basis_curve)) = 1 THEN
          RETURN(TRUE);
        ELSE
          RETURN(valid_faceted_wire_composition(sw_element\trimmed_curve.
              basis_curve));
        END_IF;
      ELSE
        IF 'BUILDING_DESIGN_SCHEMA.COMPOSITE_CURVE' IN TYPEOF(sw_element)
             THEN
          RETURN(SIZEOF(QUERY ( ccs <* sw_element\composite_curve.segments
               | (NOT valid_faceted_wire_composition(ccs.parent_curve)) )) 
              = 0);
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_faceted_wire_composition

  FUNCTION valid_units(
               m: measure_with_unit
      ): BOOLEAN;
    IF 'BUILDING_DESIGN_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,1,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,1,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,1,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,1) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(2,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(3,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.RATIO_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'BUILDING_DESIGN_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- valid_units

  FUNCTION vector_difference(
               arg1, arg2: vector_or_direction
      ): vector;

    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
         THEN
      result := ?;
    ELSE
      BEGIN
        IF 'BUILDING_DESIGN_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'BUILDING_DESIGN_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) - (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result.magnitude := SQRT(mag);
          result.orientation := res;
        ELSE
          result.magnitude := 0;
          result.orientation := vec1;
        END_IF;
      END;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- vector_difference

END_SCHEMA; -- building_design_schema
