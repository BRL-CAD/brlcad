(* 
AIM EXPRESS long form for ISO/IS 10303-216 TC1
Pete Lazo
2007-05-10
ISO TC184/SC4/WG3 N2366
*)

SCHEMA ship_moulded_form_schema;

  CONSTANT
  dummy_gri : geometric_representation_item := representation_item('') || 
                 geometric_representation_item();
  dummy_tri : topological_representation_item := representation_item('') 
                 || topological_representation_item();
  END_CONSTANT;

  TYPE action_item = SELECT
    (product,
     product_definition,
     property_definition,
     product_definition_relationship,
     product_definition_shape,
     product_related_product_category,
     action_request_solution,
     executed_action);
  END_TYPE; -- action_item

  TYPE action_request_item = SELECT
    (action,
     executed_action);
  END_TYPE; -- action_request_item

  TYPE ahead_or_behind = ENUMERATION OF
    (ahead,
     exact,
     behind);
  END_TYPE; -- ahead_or_behind

  TYPE amount_of_substance_measure = REAL;
  END_TYPE; -- amount_of_substance_measure

  TYPE approval_item = SELECT
    (product_definition,
     product_definition_shape,
     property_definition,
     product_related_product_category);
  END_TYPE; -- approval_item

  TYPE area_measure = REAL;
  END_TYPE; -- area_measure

  TYPE attribute_type = SELECT
    (label,
     text);
  END_TYPE; -- attribute_type

  TYPE axis2_placement = SELECT
    (axis2_placement_2d,
     axis2_placement_3d);
  END_TYPE; -- axis2_placement

  TYPE b_spline_curve_form = ENUMERATION OF
    (polyline_form,
     circular_arc,
     elliptic_arc,
     parabolic_arc,
     hyperbolic_arc,
     unspecified);
  END_TYPE; -- b_spline_curve_form

  TYPE b_spline_surface_form = ENUMERATION OF
    (plane_surf,
     cylindrical_surf,
     conical_surf,
     spherical_surf,
     toroidal_surf,
     surf_of_revolution,
     ruled_surf,
     generalised_cone,
     quadric_surf,
     surf_of_linear_extrusion,
     unspecified);
  END_TYPE; -- b_spline_surface_form

  TYPE boolean_operand = SELECT
    (solid_model);
  END_TYPE; -- boolean_operand

  TYPE celsius_temperature_measure = REAL;
  END_TYPE; -- celsius_temperature_measure

  TYPE characterized_definition = SELECT
    (characterized_object,
     characterized_product_definition,
     shape_definition);
  END_TYPE; -- characterized_definition

  TYPE characterized_product_definition = SELECT
    (product_definition,
     product_definition_relationship);
  END_TYPE; -- characterized_product_definition

  TYPE classification_item = SELECT
    (action,
     action_request_solution,
     applied_action_request_assignment,
     approval,
     axis2_placement_3d,
     compound_representation_item,
     external_source,
     document,
     document_reference,
     edge_curve,
     executed_action,
     group,
     identification_assignment_relationship,
     measure_with_unit,
     product,
     product_definition,
     product_definition_relationship,
     product_definition_shape,
     product_related_product_category,
     property_definition,
     property_definition_representation,
     representation,
     representation_item,     
     representation_relationship,
     shape_representation,
     surface,
     vertex_point,
     versioned_action_request);
  END_TYPE; -- classification_item

  TYPE compound_item_definition = SELECT
    (list_representation_item,
     set_representation_item);
  END_TYPE; -- compound_item_definition

  TYPE context_dependent_measure = REAL; 
  END_TYPE; -- context_dependent_measure

  TYPE count_measure = NUMBER;
  END_TYPE; -- count_measure

  TYPE curve_on_surface = SELECT
    (pcurve,
     surface_curve,
     composite_curve_on_surface);
  END_TYPE; -- curve_on_surface

  TYPE date_and_time_item = SELECT
    (action_request_solution,
     executed_action,
     versioned_action_request,
     product_definition,
     action);
  END_TYPE; -- date_and_time_item

  TYPE date_time_or_event_occurrence = SELECT
    (date_time_select);
  END_TYPE; -- date_time_or_event_occurrence

  TYPE date_time_select = SELECT
    (date,
     local_time,
     date_and_time);
  END_TYPE; -- date_time_select

  TYPE day_in_month_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 31));
  END_TYPE; -- day_in_month_number

  TYPE day_in_week_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 7));
  END_TYPE; -- day_in_week_number

  TYPE day_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 366));
  END_TYPE; -- day_in_year_number

  TYPE derived_property_select = SELECT
    (property_definition);
  END_TYPE; -- derived_property_select

  TYPE description_attribute_select = SELECT
    (action_request_solution,
     application_context,
     approval_role,
     date_time_role,
     effectivity,
     external_source,
     organization_role,
     person_and_organization_role,
     person_and_organization,
     person_role,
     property_definition_representation,
     representation);
  END_TYPE; -- description_attribute_select

  TYPE dimension_count = INTEGER;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- dimension_count

  TYPE document_reference_item = SELECT
    (action,
     product,
     property_definition,
     product_definition);
  END_TYPE; -- document_reference_item

  TYPE effectivity_item = SELECT
    (product_definition,
     property_definition,
     product_definition_shape,
     product_related_product_category);
  END_TYPE; -- effectivity_item

  TYPE electric_current_measure = REAL;
  END_TYPE; -- electric_current_measure

  TYPE external_identification_item = SELECT
    (action,
     document,
     product,
     product_definition,
     product_definition_relationship,
     property_definition);
  END_TYPE; -- external_identification_item

  TYPE founded_item_select = SELECT
    (founded_item,
     representation_item);
  END_TYPE; -- founded_item_select

  TYPE geometric_set_select = SELECT
    (point,
     curve,
     surface);
  END_TYPE; -- geometric_set_select

  TYPE group_item = SELECT
    (approval,
     identification_assignment_relationship,
     product_definition,
     product_definition_relationship);
  END_TYPE; -- group_item

  TYPE hour_in_day = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF < 24));
  END_TYPE; -- hour_in_day

  TYPE id_attribute_select = SELECT
    (action,
     address,
     product_category,
     property_definition,
     shape_aspect,
     application_context,
     group,
     organizational_project,
     representation);
  END_TYPE; -- id_attribute_select

  TYPE identification_item = SELECT
    (action,
     action_request_solution,
     compound_representation_item,
     document,
     executed_action,
     group,
     product,
     product_definition,
     product_definition_relationship,
     product_definition_shape,
     product_related_product_category,
     property_definition,
     surface,
     versioned_action_request);
  END_TYPE; -- identification_item

  TYPE identifier = STRING;
  END_TYPE; -- identifier

  TYPE knot_type = ENUMERATION OF
    (uniform_knots,
     quasi_uniform_knots,
     piecewise_bezier_knots,
     unspecified);
  END_TYPE; -- knot_type

  TYPE label = STRING;
  END_TYPE; -- label

  TYPE length_measure = REAL;
  END_TYPE; -- length_measure

  TYPE list_of_reversible_topology_item = LIST [0:?] OF
              reversible_topology_item;
  END_TYPE; -- list_of_reversible_topology_item

  TYPE list_representation_item = LIST [1:?] OF representation_item;
  END_TYPE; -- list_representation_item

  TYPE luminous_intensity_measure = REAL;
  END_TYPE; -- luminous_intensity_measure

  TYPE mass_measure = REAL;
  END_TYPE; -- mass_measure

  TYPE measure_value = SELECT
    (length_measure,
     mass_measure,
     time_measure,
     electric_current_measure,
     thermodynamic_temperature_measure,
     celsius_temperature_measure,
     context_dependent_measure,
     amount_of_substance_measure,
     luminous_intensity_measure,
     plane_angle_measure,
     solid_angle_measure,
     area_measure,
     volume_measure,
     ratio_measure,
     parameter_value,
     positive_length_measure,
     positive_plane_angle_measure,
     count_measure);
  END_TYPE; -- measure_value

  TYPE minute_in_hour = INTEGER;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 59));
  END_TYPE; -- minute_in_hour

  TYPE month_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 12));
  END_TYPE; -- month_in_year_number

  TYPE name_attribute_select = SELECT
    (action_request_solution,
     address,
     derived_unit,
     effectivity,
     person_and_organization,
     product_definition,
     property_definition_representation);
  END_TYPE; -- name_attribute_select

  TYPE organization_item = SELECT
    (document,
     product_definition,
     property_definition);
  END_TYPE; -- organization_item

  TYPE parameter_value = REAL;
  END_TYPE; -- parameter_value

  TYPE pcurve_or_surface = SELECT
    (pcurve,
     surface);
  END_TYPE; -- pcurve_or_surface

  TYPE person_and_organization_item = SELECT
    (action_request_solution,
     document,
     executed_action,
     versioned_action_request,
     action);
  END_TYPE; -- person_and_organization_item

  TYPE person_item = SELECT
    (document);
  END_TYPE; -- person_item

  TYPE person_organization_select = SELECT
    (person,
     organization,
     person_and_organization);
  END_TYPE; -- person_organization_select

  TYPE plane_angle_measure = REAL;
  END_TYPE; -- plane_angle_measure

  TYPE positive_length_measure = length_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_length_measure

  TYPE positive_plane_angle_measure = plane_angle_measure;
  WHERE
    wr1: (SELF > 0);
  END_TYPE; -- positive_plane_angle_measure

  TYPE preferred_surface_curve_representation = ENUMERATION OF
    (curve_3d,
     pcurve_s1,
     pcurve_s2);
  END_TYPE; -- preferred_surface_curve_representation

  TYPE product_or_formation_or_definition = SELECT
    (product,
     product_definition_formation,
     product_definition);
  END_TYPE; -- product_or_formation_or_definition

  TYPE ratio_measure = REAL;
  END_TYPE; -- ratio_measure

  TYPE represented_definition = SELECT
    (property_definition,
     property_definition_relationship,
     shape_aspect);
  END_TYPE; -- represented_definition

  TYPE reversible_topology = SELECT
    (reversible_topology_item,
     list_of_reversible_topology_item,
     set_of_reversible_topology_item);
  END_TYPE; -- reversible_topology

  TYPE reversible_topology_item = SELECT
    (edge,
     path,
     face,
     face_bound,
     closed_shell,
     open_shell);
  END_TYPE; -- reversible_topology_item

  TYPE role_select = SELECT
    (action_assignment,
     action_request_assignment,
     approval_assignment,
     approval_date_time,
     document_reference,
     effectivity_assignment,
     group_assignment);
  END_TYPE; -- role_select

  TYPE second_in_minute = REAL;
  WHERE
    wr1: ((0 <= SELF) AND (SELF <= 60));
  END_TYPE; -- second_in_minute

  TYPE set_of_reversible_topology_item = SET [0:?] OF
              reversible_topology_item;
  END_TYPE; -- set_of_reversible_topology_item

  TYPE set_representation_item = SET [1:?] OF representation_item;
  END_TYPE; -- set_representation_item

  TYPE shape_definition = SELECT
    (product_definition_shape,
     shape_aspect);
  END_TYPE; -- shape_definition

  TYPE shell = SELECT
    (open_shell,
     closed_shell);
  END_TYPE; -- shell

  TYPE si_prefix = ENUMERATION OF
    (exa,
     peta,
     tera,
     giga,
     mega,
     kilo,
     hecto,
     deca,
     deci,
     centi,
     milli,
     micro,
     nano,
     pico,
     femto,
     atto);
  END_TYPE; -- si_prefix

  TYPE si_unit_name = ENUMERATION OF
    (metre,
     gram,
     second,
     ampere,
     kelvin,
     mole,
     candela,
     radian,
     steradian,
     hertz,
     newton,
     pascal,
     joule,
     watt,
     coulomb,
     volt,
     farad,
     ohm,
     siemens,
     weber,
     tesla,
     henry,
     degree_celsius,
     lumen,
     lux,
     becquerel,
     gray,
     sievert);
  END_TYPE; -- si_unit_name

  TYPE solid_angle_measure = REAL;
  END_TYPE; -- solid_angle_measure

  TYPE source_item = SELECT
    (identifier);
  END_TYPE; -- source_item

  TYPE supported_item = SELECT
    (action,
     action_method);
  END_TYPE; -- supported_item

  TYPE surface_boundary = SELECT
    (degenerate_pcurve);
  END_TYPE; -- surface_boundary

  TYPE surface_model = SELECT
    (face_based_surface_model);
  END_TYPE; -- surface_model

  TYPE text = STRING;
  END_TYPE; -- text

  TYPE thermodynamic_temperature_measure = REAL;
  END_TYPE; -- thermodynamic_temperature_measure

  TYPE time_measure = REAL;
  END_TYPE; -- time_measure

  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation);
  END_TYPE; -- transformation

  TYPE transition_code = ENUMERATION OF
    (discontinuous,
     continuous,
     cont_same_gradient,
     cont_same_gradient_same_curvature);
  END_TYPE; -- transition_code

  TYPE trimming_select = SELECT
    (cartesian_point,
     parameter_value);
  END_TYPE; -- trimming_select

  TYPE unit = SELECT
    (named_unit,
     derived_unit);
  END_TYPE; -- unit

  TYPE vector_or_direction = SELECT
    (vector,
     direction);
  END_TYPE; -- vector_or_direction

  TYPE volume_measure = REAL;
  END_TYPE; -- volume_measure

  TYPE week_in_year_number = INTEGER;
  WHERE
    wr1: ((1 <= SELF) AND (SELF <= 53));
  END_TYPE; -- week_in_year_number

  TYPE wireframe_model = SELECT
    (edge_based_wireframe_model);
  END_TYPE; -- wireframe_model

  TYPE year_number = INTEGER;
  END_TYPE; -- year_number

  ENTITY action;
      name          : label;
      description   : OPTIONAL text;
      chosen_method : action_method;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- action

  ENTITY action_assignment
    ABSTRACT SUPERTYPE;
      assigned_action : action;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- action_assignment

  ENTITY action_method;
      name        : label;
      description : OPTIONAL text;
      consequence : text;
      purpose     : text;
  END_ENTITY; -- action_method

  ENTITY action_relationship;
      name            : label;
      description     : OPTIONAL text;
      relating_action : action;
      related_action  : action;
  END_ENTITY; -- action_relationship

  ENTITY action_request_assignment
    ABSTRACT SUPERTYPE;
      assigned_action_request : versioned_action_request;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- action_request_assignment

  ENTITY action_request_solution;
      method  : action_method;
      request : versioned_action_request;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY; -- action_request_solution

  ENTITY address;
      internal_location       : OPTIONAL label;
      street_number           : OPTIONAL label;
      street                  : OPTIONAL label;
      postal_box              : OPTIONAL label;
      town                    : OPTIONAL label;
      region                  : OPTIONAL label;
      postal_code             : OPTIONAL label;
      country                 : OPTIONAL label;
      facsimile_number        : OPTIONAL label;
      telephone_number        : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number            : OPTIONAL label;
    DERIVE
      name : label := get_name_value(SELF);
      url  : identifier := get_id_value(SELF);
    WHERE
      wr1: (EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(
               street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(
               region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(
               facsimile_number) OR EXISTS(telephone_number) OR EXISTS(
               electronic_mail_address) OR EXISTS(telex_number));
  END_ENTITY; -- address

  ENTITY advanced_face
    SUBTYPE OF (face_surface);
    WHERE
      wr1 : (SIZEOF(['SHIP_MOULDED_FORM_SCHEMA.ELEMENTARY_SURFACE',
                'SHIP_MOULDED_FORM_SCHEMA.B_SPLINE_SURFACE',
                'SHIP_MOULDED_FORM_SCHEMA.SWEPT_SURFACE'] * TYPEOF(
                face_geometry)) = 1);
      wr2 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT ('SHIP_MOULDED_FORM_SCHEMA.EDGE_CURVE' IN 
                TYPEOF(oe\oriented_edge.edge_element))) )) = 0)) )) = 0);
      wr3 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (SIZEOF(['SHIP_MOULDED_FORM_SCHEMA.LINE',
                'SHIP_MOULDED_FORM_SCHEMA.CONIC',
                'SHIP_MOULDED_FORM_SCHEMA.POLYLINE',
                'SHIP_MOULDED_FORM_SCHEMA.SURFACE_CURVE',
                'SHIP_MOULDED_FORM_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(oe.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0);
      wr4 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (NOT (('SHIP_MOULDED_FORM_SCHEMA.VERTEX_POINT' 
                IN TYPEOF(oe\edge.edge_start)) AND (
                'SHIP_MOULDED_FORM_SCHEMA.CARTESIAN_POINT' IN TYPEOF(oe\
                edge.edge_start\vertex_point.vertex_geometry)) AND (
                'SHIP_MOULDED_FORM_SCHEMA.VERTEX_POINT' IN TYPEOF(oe\edge.
                edge_end)) AND ('SHIP_MOULDED_FORM_SCHEMA.CARTESIAN_POINT' 
                IN TYPEOF(oe\edge.edge_end\vertex_point.vertex_geometry)))) )) 
                = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | ('SHIP_MOULDED_FORM_SCHEMA.ORIENTED_PATH' IN TYPEOF(
                elp_fbnds.bound)) )) = 0);
      wr6 : ((NOT ('SHIP_MOULDED_FORM_SCHEMA.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (SIZEOF([
                'SHIP_MOULDED_FORM_SCHEMA.LINE',
                'SHIP_MOULDED_FORM_SCHEMA.CONIC',
                'SHIP_MOULDED_FORM_SCHEMA.POLYLINE',
                'SHIP_MOULDED_FORM_SCHEMA.B_SPLINE_CURVE'] * TYPEOF(
                face_geometry\swept_surface.swept_curve)) = 1));
      wr7 : (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (('SHIP_MOULDED_FORM_SCHEMA.VERTEX_POINT' IN 
                TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) 
                AND ('SHIP_MOULDED_FORM_SCHEMA.CARTESIAN_POINT' IN TYPEOF(
                vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\
                vertex_point.vertex_geometry)))) )) = 0);
      wr8 : (SIZEOF(QUERY ( bnd <* bounds | (NOT (SIZEOF([
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP',
                'SHIP_MOULDED_FORM_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnd.bound)) 
                = 1)) )) = 0);
      wr9 : (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (('SHIP_MOULDED_FORM_SCHEMA.SURFACE_CURVE' IN 
                TYPEOF(oe\oriented_edge.edge_element\edge_curve.
                edge_geometry)) AND (NOT (SIZEOF(QUERY ( sc_ag <* oe.
                edge_element\edge_curve.edge_geometry\surface_curve.
                associated_geometry | (NOT (
                'SHIP_MOULDED_FORM_SCHEMA.PCURVE' IN TYPEOF(sc_ag))) )) = 0))) )) 
                = 0)) )) = 0);
      wr10: (((NOT ('SHIP_MOULDED_FORM_SCHEMA.SWEPT_SURFACE' IN TYPEOF(
                face_geometry))) OR (NOT (
                'SHIP_MOULDED_FORM_SCHEMA.POLYLINE' IN TYPEOF(face_geometry
                \swept_surface.swept_curve))) OR (SIZEOF(face_geometry\
                swept_surface.swept_curve\polyline.points) >= 3)) AND (
                SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds.bound\path.
                edge_list | (('SHIP_MOULDED_FORM_SCHEMA.POLYLINE' IN 
                TYPEOF(oe\oriented_edge.edge_element\edge_curve.
                edge_geometry)) AND (NOT (SIZEOF(oe\oriented_edge.
                edge_element\edge_curve.edge_geometry\polyline.points) >= 3))) )) 
                = 0)) )) = 0));
  END_ENTITY; -- advanced_face

  ENTITY amount_of_substance_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 1) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- amount_of_substance_unit

  ENTITY application_context;
      application : label;
    DERIVE
      description : text := get_description_value(SELF);
      id          : identifier := get_id_value(SELF);
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR 
                            frame_of_reference;
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- application_context

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (product_context,product_definition_context));
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY; -- application_context_element

  ENTITY application_protocol_definition;
      status                                    : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year                 : year_number;
      application                               : application_context;
  END_ENTITY; -- application_protocol_definition

  ENTITY applied_action_assignment
    SUBTYPE OF (action_assignment);
      items : SET [1:?] OF action_item;
  END_ENTITY; -- applied_action_assignment

  ENTITY applied_action_request_assignment
    SUBTYPE OF (action_request_assignment);
      items : SET [1:?] OF action_request_item;
  END_ENTITY; -- applied_action_request_assignment

  ENTITY applied_approval_assignment
    SUBTYPE OF (approval_assignment);
      items : SET [1:?] OF approval_item;
    WHERE
      wr1: ((NOT (SELF\approval_assignment.role.name = 
               'proposed alternative')) OR (SIZEOF(QUERY ( app <* USEDIN(
               SELF\approval_assignment.assigned_approval,'SHIP_MOULDED_FORM_SCHEMA.APPROVAL_ASSIGNMENT.ASSIGNED_APPROVAL')
                | (('SHIP_MOULDED_FORM_SCHEMA.APPLIED_APPROVAL_ASSIGNMENT' 
               IN TYPEOF(app)) AND (app\approval_assignment.role.name = 
               'subject')) )) = 1));
  END_ENTITY; -- applied_approval_assignment

  ENTITY applied_classification_assignment
    SUBTYPE OF (classification_assignment);
      items : SET [1:?] OF classification_item;
  END_ENTITY; -- applied_classification_assignment

  ENTITY applied_date_and_time_assignment
    SUBTYPE OF (date_and_time_assignment);
      items : SET [1:?] OF date_and_time_item;
  END_ENTITY; -- applied_date_and_time_assignment

  ENTITY applied_document_reference
    SUBTYPE OF (document_reference);
      items : SET [1:?] OF document_reference_item;
  END_ENTITY; -- applied_document_reference

  ENTITY applied_effectivity_assignment
    SUBTYPE OF (effectivity_assignment);
      items : SET [1:?] OF effectivity_item;
  END_ENTITY; -- applied_effectivity_assignment

  ENTITY applied_external_identification_assignment
    SUBTYPE OF (external_identification_assignment);
      items : SET [1:?] OF external_identification_item;
  END_ENTITY; -- applied_external_identification_assignment

  ENTITY applied_group_assignment
    SUBTYPE OF (group_assignment);
      items : SET [1:?] OF group_item;
  END_ENTITY; -- applied_group_assignment

  ENTITY applied_identification_assignment
    SUBTYPE OF (identification_assignment);
      items : SET [1:?] OF identification_item;
  END_ENTITY; -- applied_identification_assignment

  ENTITY applied_organization_assignment
    SUBTYPE OF (organization_assignment);
      items : SET [1:?] OF organization_item;
  END_ENTITY; -- applied_organization_assignment

  ENTITY applied_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET [1:?] OF person_and_organization_item;
  END_ENTITY; -- applied_person_and_organization_assignment

  ENTITY applied_person_assignment
    SUBTYPE OF (person_assignment);
      items : SET [1:?] OF person_item;
  END_ENTITY; -- applied_person_assignment

  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY; -- approval

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
      assigned_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- approval_assignment

  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- approval_date_time

  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY; -- approval_person_organization

  ENTITY approval_role;
      role : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- approval_role

  ENTITY approval_status;
      name : label;
  END_ENTITY; -- approval_status

  ENTITY axis1_placement
    SUBTYPE OF (placement);
      axis : OPTIONAL direction;
    DERIVE
      z : direction := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- axis1_placement

  ENTITY axis2_placement_2d
    SUBTYPE OF (placement);
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [2:2] OF direction := build_2axes(ref_direction);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 2);
  END_ENTITY; -- axis2_placement_2d

  ENTITY axis2_placement_3d
    SUBTYPE OF (placement);
      axis          : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
    DERIVE
      p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
    WHERE
      wr1: (SELF\placement.location.dim = 3);
      wr2: ((NOT EXISTS(axis)) OR (axis.dim = 3));
      wr3: ((NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3));
      wr4: ((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction)) OR (
               cross_product(axis,ref_direction).magnitude > 0));
  END_ENTITY; -- axis2_placement_3d

  ENTITY b_spline_curve
    SUPERTYPE OF (ONEOF (uniform_curve,b_spline_curve_with_knots,
        quasi_uniform_curve,bezier_curve) ANDOR rational_b_spline_curve)
    SUBTYPE OF (bounded_curve);
      degree              : INTEGER;
      control_points_list : LIST [2:?] OF cartesian_point;
      curve_form          : b_spline_curve_form;
      closed_curve        : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      upper_index_on_control_points : INTEGER := SIZEOF(
                                         control_points_list) - 1;
      control_points                : ARRAY [0:
                                         upper_index_on_control_points] OF
                                          cartesian_point := list_to_array(
                                         control_points_list,0,
                                         upper_index_on_control_points);
    WHERE
      wr1: (('SHIP_MOULDED_FORM_SCHEMA.UNIFORM_CURVE' IN TYPEOF(SELF)) OR 
               ('SHIP_MOULDED_FORM_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(
               SELF)) OR ('SHIP_MOULDED_FORM_SCHEMA.BEZIER_CURVE' IN 
               TYPEOF(SELF)) OR (
               'SHIP_MOULDED_FORM_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN 
               TYPEOF(SELF)));
  END_ENTITY; -- b_spline_curve

  ENTITY b_spline_curve_with_knots
    SUBTYPE OF (b_spline_curve);
      knot_multiplicities : LIST [2:?] OF INTEGER;
      knots               : LIST [2:?] OF parameter_value;
      knot_spec           : knot_type;
    DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
    WHERE
      wr1: constraints_param_b_spline(degree,upper_index_on_knots,
               upper_index_on_control_points,knot_multiplicities,knots);
      wr2: (SIZEOF(knot_multiplicities) = upper_index_on_knots);
  END_ENTITY; -- b_spline_curve_with_knots

  ENTITY b_spline_surface
    SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,uniform_surface,
        quasi_uniform_surface,bezier_surface) ANDOR 
        rational_b_spline_surface)
    SUBTYPE OF (bounded_surface);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form        : b_spline_surface_form;
      u_closed            : LOGICAL;
      v_closed            : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      u_upper        : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF
                           cartesian_point := make_array_of_array(
                          control_points_list,0,u_upper,0,v_upper);
    WHERE
      wr1: (('SHIP_MOULDED_FORM_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) 
               OR ('SHIP_MOULDED_FORM_SCHEMA.QUASI_UNIFORM_SURFACE' IN 
               TYPEOF(SELF)) OR ('SHIP_MOULDED_FORM_SCHEMA.BEZIER_SURFACE' 
               IN TYPEOF(SELF)) OR (
               'SHIP_MOULDED_FORM_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN 
               TYPEOF(SELF)));
  END_ENTITY; -- b_spline_surface

  ENTITY b_spline_surface_with_knots
    SUBTYPE OF (b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      knot_spec        : knot_type;
    DERIVE
      knot_u_upper : INTEGER := SIZEOF(u_knots);
      knot_v_upper : INTEGER := SIZEOF(v_knots);
    WHERE
      wr1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
               knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,
               u_knots);
      wr2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
               knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,
               v_knots);
      wr3: (SIZEOF(u_multiplicities) = knot_u_upper);
      wr4: (SIZEOF(v_multiplicities) = knot_v_upper);
  END_ENTITY; -- b_spline_surface_with_knots

  ENTITY bezier_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- bezier_curve

  ENTITY bezier_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- bezier_surface

  ENTITY bounded_curve
    SUPERTYPE OF (ONEOF (polyline,b_spline_curve,bounded_pcurve,
        bounded_surface_curve,composite_curve))
    SUBTYPE OF (curve);
  END_ENTITY; -- bounded_curve

  ENTITY bounded_pcurve
    SUBTYPE OF (pcurve, bounded_curve);
    WHERE
      wr1: ('SHIP_MOULDED_FORM_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve
               .reference_to_curve.items[1]));
  END_ENTITY; -- bounded_pcurve

  ENTITY bounded_surface
    SUPERTYPE OF (b_spline_surface)
    SUBTYPE OF (surface);
  END_ENTITY; -- bounded_surface

  ENTITY bounded_surface_curve
    SUBTYPE OF (surface_curve, bounded_curve);
    WHERE
      wr1: ('SHIP_MOULDED_FORM_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\
               surface_curve.curve_3d));
  END_ENTITY; -- bounded_surface_curve

  ENTITY calendar_date
    SUBTYPE OF (date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      wr1: valid_calendar_date(SELF);
  END_ENTITY; -- calendar_date

  ENTITY cartesian_point
    SUBTYPE OF (point);
      coordinates : LIST [1:3] OF length_measure;
  END_ENTITY; -- cartesian_point

  ENTITY cartesian_transformation_operator
    SUPERTYPE OF (cartesian_transformation_operator_3d)
    SUBTYPE OF (geometric_representation_item, 
        functionally_defined_transformation);
      axis1        : OPTIONAL direction;
      axis2        : OPTIONAL direction;
      local_origin : cartesian_point;
      scale        : OPTIONAL REAL;
    DERIVE
      scl : REAL := NVL(scale,1);
    WHERE
      wr1: (scl > 0);
  END_ENTITY; -- cartesian_transformation_operator

  ENTITY cartesian_transformation_operator_3d
    SUBTYPE OF (cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
    DERIVE
      u : LIST [3:3] OF direction := base_axis(3,SELF\
             cartesian_transformation_operator.axis1,SELF\
             cartesian_transformation_operator.axis2,axis3);
    WHERE
      wr1: (SELF\geometric_representation_item.dim = 3);
  END_ENTITY; -- cartesian_transformation_operator_3d

  ENTITY characterized_object;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- characterized_object

  ENTITY circle
    SUBTYPE OF (conic);
      radius : positive_length_measure;
  END_ENTITY; -- circle

  ENTITY class
    SUBTYPE OF (group);
    WHERE
      wr1: (SIZEOF(QUERY ( oa <* USEDIN(SELF,
               'SHIP_MOULDED_FORM_SCHEMA.GROUP_ASSIGNMENT.ASSIGNED_GROUP')
                | (NOT ('SHIP_MOULDED_FORM_SCHEMA.APPLIED_GROUP_ASSIGNMENT' 
               IN TYPEOF(oa))) )) = 0);
  END_ENTITY; -- class

  ENTITY classification_assignment
    ABSTRACT SUPERTYPE;
      assigned_class : group;
      role           : classification_role;
  END_ENTITY; -- classification_assignment

  ENTITY classification_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- classification_role

  ENTITY closed_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- closed_shell

  ENTITY composite_curve
    SUBTYPE OF (bounded_curve);
      segments       : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
    DERIVE
      n_segments   : INTEGER := SIZEOF(segments);
      closed_curve : LOGICAL := segments[n_segments].transition <> 
                        discontinuous;
    WHERE
      wr1: (((NOT closed_curve) AND (SIZEOF(QUERY ( temp <* segments | (
               temp.transition = discontinuous) )) = 1)) OR (closed_curve 
               AND (SIZEOF(QUERY ( temp <* segments | (temp.transition = 
               discontinuous) )) = 0)));
  END_ENTITY; -- composite_curve

  ENTITY composite_curve_on_surface
    SUBTYPE OF (composite_curve);
    DERIVE
      basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (SIZEOF(basis_surface) > 0);
      wr2: constraints_composite_curve_on_surface(SELF);
  END_ENTITY; -- composite_curve_on_surface

  ENTITY composite_curve_segment
    SUBTYPE OF (founded_item);
      transition   : transition_code;
      same_sense   : BOOLEAN;
      parent_curve : curve;
    INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
    WHERE
      wr1: ('SHIP_MOULDED_FORM_SCHEMA.BOUNDED_CURVE' IN TYPEOF(
               parent_curve));
  END_ENTITY; -- composite_curve_segment

  ENTITY compound_representation_item
    SUBTYPE OF (representation_item);
      item_element : compound_item_definition;
  END_ENTITY; -- compound_representation_item

  ENTITY conic
    SUPERTYPE OF (ONEOF (circle,ellipse,hyperbola,parabola))
    SUBTYPE OF (curve);
      position : axis2_placement;
  END_ENTITY; -- conic

  ENTITY conical_surface
    SUBTYPE OF (elementary_surface);
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
      wr1: (radius >= 0);
  END_ENTITY; -- conical_surface

  ENTITY connected_edge_set
    SUBTYPE OF (topological_representation_item);
      ces_edges : SET [1:?] OF edge;
  END_ENTITY; -- connected_edge_set

  ENTITY connected_face_set
    SUPERTYPE OF (ONEOF (closed_shell,open_shell))
    SUBTYPE OF (topological_representation_item);
      cfs_faces : SET [1:?] OF face;
  END_ENTITY; -- connected_face_set

  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
      name : label;
  END_ENTITY; -- context_dependent_unit

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
      name              : label;
      conversion_factor : measure_with_unit;
  END_ENTITY; -- conversion_based_unit

  ENTITY coordinated_universal_time_offset;
      hour_offset   : INTEGER;
      minute_offset : OPTIONAL INTEGER;
      sense         : ahead_or_behind;
    DERIVE
      actual_minute_offset : INTEGER := NVL(minute_offset,0);
    WHERE
      wr1: ((0 <= hour_offset) AND (hour_offset < 24));
      wr2: ((0 <= actual_minute_offset) AND (actual_minute_offset <= 59));
      wr3: (NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND (
               sense = exact)));
  END_ENTITY; -- coordinated_universal_time_offset

  ENTITY curve
    SUPERTYPE OF (ONEOF (line,conic,pcurve,surface_curve,offset_curve_3d,
        curve_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- curve

  ENTITY curve_replica
    SUBTYPE OF (curve);
      parent_curve   : curve;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_curve.dim);
      wr2: acyclic_curve_replica(SELF,parent_curve);
  END_ENTITY; -- curve_replica

  ENTITY cylindrical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- cylindrical_surface

  ENTITY date
    SUPERTYPE OF (ONEOF (calendar_date,ordinal_date,
        week_of_year_and_day_date));
      year_component : year_number;
  END_ENTITY; -- date

  ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
  END_ENTITY; -- date_and_time

  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
      assigned_date_and_time : date_and_time;
      role                   : date_time_role;
  END_ENTITY; -- date_and_time_assignment

  ENTITY date_time_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- date_time_role

  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      wr1: ('SHIP_MOULDED_FORM_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(SELF\representation.context_of_items));
  END_ENTITY; -- definitional_representation

  ENTITY degenerate_pcurve
    SUBTYPE OF (point);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('SHIP_MOULDED_FORM_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\
               representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- degenerate_pcurve

  ENTITY degenerate_toroidal_surface
    SUBTYPE OF (toroidal_surface);
      select_outer : BOOLEAN;
    WHERE
      wr1: (major_radius < minor_radius);
  END_ENTITY; -- degenerate_toroidal_surface

  ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
    DERIVE
      name : label := get_name_value(SELF);
    WHERE
      wr1: ((SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (
               elements[1].exponent <> 1)));
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY; -- derived_unit

  ENTITY derived_unit_element;
      unit     : named_unit;
      exponent : REAL;
  END_ENTITY; -- derived_unit_element

  ENTITY description_attribute;
      attribute_value : text;
      described_item  : description_attribute_select;
  END_ENTITY; -- description_attribute

  ENTITY descriptive_representation_item
    SUBTYPE OF (representation_item);
      description : text;
  END_ENTITY; -- descriptive_representation_item

  ENTITY dimensional_exponents;
      length_exponent                    : REAL;
      mass_exponent                      : REAL;
      time_exponent                      : REAL;
      electric_current_exponent          : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent       : REAL;
      luminous_intensity_exponent        : REAL;
  END_ENTITY; -- dimensional_exponents

  ENTITY direction
    SUBTYPE OF (geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
    WHERE
      wr1: (SIZEOF(QUERY ( tmp <* direction_ratios | (tmp <> 0) )) > 0);
  END_ENTITY; -- direction

  ENTITY document;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      kind        : document_type;
    INVERSE
      representation_types : SET [0:?] OF document_representation_type FOR 
                                represented_document;
  END_ENTITY; -- document

  ENTITY document_reference
    ABSTRACT SUPERTYPE;
      assigned_document : document;
      source            : label;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- document_reference

  ENTITY document_representation_type;
      name                 : label;
      represented_document : document;
  END_ENTITY; -- document_representation_type

  ENTITY document_type;
      product_data_type : label;
  END_ENTITY; -- document_type

  ENTITY document_usage_constraint;
      source                : document;
      subject_element       : label;
      subject_element_value : text;
  END_ENTITY; -- document_usage_constraint

  ENTITY edge
    SUPERTYPE OF (ONEOF (edge_curve,oriented_edge))
    SUBTYPE OF (topological_representation_item);
      edge_start : vertex;
      edge_end   : vertex;
  END_ENTITY; -- edge

  ENTITY edge_based_wireframe_model
    SUBTYPE OF (geometric_representation_item);
      ebwm_boundary : SET [1:?] OF connected_edge_set;
  END_ENTITY; -- edge_based_wireframe_model

  ENTITY edge_based_wireframe_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1: (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
               'SHIP_MOULDED_FORM_SCHEMA.EDGE_BASED_WIREFRAME_MODEL',
               'SHIP_MOULDED_FORM_SCHEMA.MAPPED_ITEM',
               'SHIP_MOULDED_FORM_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) 
               = 1)) )) = 0);
      wr2: (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
               'SHIP_MOULDED_FORM_SCHEMA.EDGE_BASED_WIREFRAME_MODEL',
               'SHIP_MOULDED_FORM_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
               >= 1);
      wr3: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'SHIP_MOULDED_FORM_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (
               'SHIP_MOULDED_FORM_SCHEMA.EDGE_CURVE' IN TYPEOF(edges))) )) 
               = 0)) )) = 0)) )) = 0);
      wr4: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'SHIP_MOULDED_FORM_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( pline_edges <* QUERY ( edges <* eb.ces_edges | (
               'SHIP_MOULDED_FORM_SCHEMA.POLYLINE' IN TYPEOF(edges\
               edge_curve.edge_geometry)) ) | (NOT (SIZEOF(pline_edges\
               edge_curve.edge_geometry\polyline.points) > 2)) )) = 0)) )) 
               = 0)) )) = 0);
      wr5: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'SHIP_MOULDED_FORM_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT ((
               'SHIP_MOULDED_FORM_SCHEMA.VERTEX_POINT' IN TYPEOF(edges.
               edge_start)) AND ('SHIP_MOULDED_FORM_SCHEMA.VERTEX_POINT' IN
                TYPEOF(edges.edge_end)))) )) = 0)) )) = 0)) )) = 0);
      wr6: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'SHIP_MOULDED_FORM_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT 
               valid_wireframe_edge_curve(edges\edge_curve.edge_geometry)) )) 
               = 0)) )) = 0)) )) = 0);
      wr7: (SIZEOF(QUERY ( ebwm <* QUERY ( it <* SELF.items | (
               'SHIP_MOULDED_FORM_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN 
               TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( eb <* ebwm\
               edge_based_wireframe_model.ebwm_boundary | (NOT (SIZEOF(
               QUERY ( edges <* eb.ces_edges | (NOT (
               valid_wireframe_vertex_point(edges.edge_start\vertex_point.
               vertex_geometry) AND valid_wireframe_vertex_point(edges.
               edge_end\vertex_point.vertex_geometry))) )) = 0)) )) = 0)) )) 
               = 0);
      wr8: (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
               'SHIP_MOULDED_FORM_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (
               NOT (('SHIP_MOULDED_FORM_SCHEMA.' + 
               'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION') IN TYPEOF(mi\
               mapped_item.mapping_source.mapped_representation))) )) = 0);
      wr9: (SELF.context_of_items\geometric_representation_context.
               coordinate_space_dimension = 3);
  END_ENTITY; -- edge_based_wireframe_shape_representation

  ENTITY edge_curve
    SUBTYPE OF (edge, geometric_representation_item);
      edge_geometry : curve;
      same_sense    : BOOLEAN;
  END_ENTITY; -- edge_curve

  ENTITY edge_loop
    SUBTYPE OF (loop, path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      wr1: (SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].
               edge_end);
  END_ENTITY; -- edge_loop

  ENTITY effectivity
    SUPERTYPE OF (serial_numbered_effectivity);
      id : identifier;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- effectivity

  ENTITY effectivity_assignment
    ABSTRACT SUPERTYPE;
      assigned_effectivity : effectivity;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- effectivity_assignment

  ENTITY electric_current_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 1) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- electric_current_unit

  ENTITY elementary_surface
    SUPERTYPE OF (ONEOF (plane,cylindrical_surface,conical_surface,
        spherical_surface,toroidal_surface))
    SUBTYPE OF (surface);
      position : axis2_placement_3d;
  END_ENTITY; -- elementary_surface

  ENTITY ellipse
    SUBTYPE OF (conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY; -- ellipse

  ENTITY evaluated_degenerate_pcurve
    SUBTYPE OF (degenerate_pcurve);
      equivalent_point : cartesian_point;
  END_ENTITY; -- evaluated_degenerate_pcurve

  ENTITY executed_action
    SUBTYPE OF (action);
  END_ENTITY; -- executed_action

  ENTITY external_identification_assignment
    ABSTRACT SUPERTYPE
    SUBTYPE OF (identification_assignment);
      source : external_source;
  END_ENTITY; -- external_identification_assignment

  ENTITY external_source;
      source_id : source_item;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- external_source

  ENTITY external_source_relationship;
      name            : label;
      description     : OPTIONAL text;
      relating_source : external_source;
      related_source  : external_source;
  END_ENTITY; -- external_source_relationship

  ENTITY externally_defined_item;
      item_id : source_item;
      source  : external_source;
  END_ENTITY; -- externally_defined_item

  ENTITY face
    SUPERTYPE OF (ONEOF (face_surface,subface,oriented_face))
    SUBTYPE OF (topological_representation_item);
      bounds : SET [1:?] OF face_bound;
    WHERE
      wr1: (NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
      wr2: (SIZEOF(QUERY ( temp <* bounds | (
               'SHIP_MOULDED_FORM_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(temp)) )) 
               <= 1);
  END_ENTITY; -- face

  ENTITY face_based_surface_model
    SUBTYPE OF (geometric_representation_item);
      fbsm_faces : SET [1:?] OF connected_face_set;
  END_ENTITY; -- face_based_surface_model

  ENTITY face_bound
    SUBTYPE OF (topological_representation_item);
      bound       : loop;
      orientation : BOOLEAN;
  END_ENTITY; -- face_bound

  ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
  END_ENTITY; -- face_outer_bound

  ENTITY face_surface
    SUBTYPE OF (face, geometric_representation_item);
      face_geometry : surface;
      same_sense    : BOOLEAN;
    WHERE
      wr1: (NOT ('SHIP_MOULDED_FORM_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(
               face_geometry)));
  END_ENTITY; -- face_surface

  ENTITY faceted_brep
    SUBTYPE OF (manifold_solid_brep);
  END_ENTITY; -- faceted_brep

  ENTITY founded_item;
  END_ENTITY; -- founded_item

  ENTITY functionally_defined_transformation;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- functionally_defined_transformation

  ENTITY geometric_curve_set
    SUBTYPE OF (geometric_set);
    WHERE
      wr1: (SIZEOF(QUERY ( temp <* SELF\geometric_set.elements | (
               'SHIP_MOULDED_FORM_SCHEMA.SURFACE' IN TYPEOF(temp)) )) = 0);
  END_ENTITY; -- geometric_curve_set

  ENTITY geometric_representation_context
    SUBTYPE OF (representation_context);
      coordinate_space_dimension : dimension_count;
  END_ENTITY; -- geometric_representation_context

  ENTITY geometric_representation_item
    SUPERTYPE OF (ONEOF (point,direction,vector,placement,
        cartesian_transformation_operator,curve,surface,edge_curve,
        face_surface,poly_loop,vertex_point,solid_model,
        face_based_surface_model,edge_based_wireframe_model,geometric_set))
    SUBTYPE OF (representation_item);
    DERIVE
      dim : dimension_count := dimension_of(SELF);
    WHERE
      wr1: (SIZEOF(QUERY ( using_rep <* using_representations(SELF) | (
               NOT (
               'SHIP_MOULDED_FORM_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' 
               IN TYPEOF(using_rep.context_of_items))) )) = 0);
  END_ENTITY; -- geometric_representation_item

  ENTITY geometric_set
    SUPERTYPE OF (geometric_curve_set)
    SUBTYPE OF (geometric_representation_item);
      elements : SET [1:?] OF geometric_set_select;
  END_ENTITY; -- geometric_set

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY; -- global_uncertainty_assigned_context

  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
      units : SET [1:?] OF unit;
  END_ENTITY; -- global_unit_assigned_context

  ENTITY group;
      name        : label;
      description : OPTIONAL text;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- group

  ENTITY group_assignment
    ABSTRACT SUPERTYPE;
      assigned_group : group;
    DERIVE
      role : object_role := get_role(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1);
  END_ENTITY; -- group_assignment

  ENTITY group_relationship;
      name           : label;
      description    : OPTIONAL text;
      relating_group : group;
      related_group  : group;
  END_ENTITY; -- group_relationship

  ENTITY hyperbola
    SUBTYPE OF (conic);
      semi_axis      : positive_length_measure;
      semi_imag_axis : positive_length_measure;
  END_ENTITY; -- hyperbola

  ENTITY id_attribute;
      attribute_value : identifier;
      identified_item : id_attribute_select;
  END_ENTITY; -- id_attribute

  ENTITY identification_assignment
    ABSTRACT SUPERTYPE;
      assigned_id : identifier;
      role        : identification_role;
  END_ENTITY; -- identification_assignment

  ENTITY identification_assignment_relationship;
      name                               : label;
      description                        : OPTIONAL text;
      relating_identification_assignment : identification_assignment;
      related_identification_assignment  : identification_assignment;
  END_ENTITY; -- identification_assignment_relationship

  ENTITY identification_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- identification_role

  ENTITY intersection_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               <> associated_surface(SELF\surface_curve.associated_geometry
               [2]));
  END_ENTITY; -- intersection_curve

  ENTITY item_defined_transformation;
      name             : label;
      description      : OPTIONAL text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
  END_ENTITY; -- item_defined_transformation

  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('SHIP_MOULDED_FORM_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- length_measure_with_unit

  ENTITY length_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 1) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- length_unit

  ENTITY line
    SUBTYPE OF (curve);
      pnt : cartesian_point;
      dir : vector;
    WHERE
      wr1: (dir.dim = pnt.dim);
  END_ENTITY; -- line

  ENTITY local_time;
      hour_component   : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone             : coordinated_universal_time_offset;
    WHERE
      wr1: valid_time(SELF);
  END_ENTITY; -- local_time

  ENTITY loop
    SUPERTYPE OF (ONEOF (vertex_loop,edge_loop,poly_loop))
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- loop

  ENTITY luminous_intensity_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 1));
  END_ENTITY; -- luminous_intensity_unit

  ENTITY manifold_solid_brep
    SUBTYPE OF (solid_model);
      outer : closed_shell;
  END_ENTITY; -- manifold_solid_brep

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      wr1: acyclic_mapped_representation(using_representations(SELF),[SELF]);
  END_ENTITY; -- mapped_item

  ENTITY mass_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('SHIP_MOULDED_FORM_SCHEMA.MASS_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- mass_measure_with_unit

  ENTITY mass_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 1) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- mass_unit

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF (length_measure_with_unit,mass_measure_with_unit,
        plane_angle_measure_with_unit,solid_angle_measure_with_unit));
      value_component : measure_value;
      unit_component  : unit;
    WHERE
      wr1: valid_units(SELF);
  END_ENTITY; -- measure_with_unit

  ENTITY name_attribute;
      attribute_value : label;
      named_item      : name_attribute_select;
  END_ENTITY; -- name_attribute

  ENTITY named_unit
    SUPERTYPE OF (ONEOF (si_unit,conversion_based_unit,
        context_dependent_unit) ANDOR ONEOF (length_unit,mass_unit,
        time_unit,electric_current_unit,thermodynamic_temperature_unit,
        amount_of_substance_unit,luminous_intensity_unit,plane_angle_unit,
        solid_angle_unit,ratio_unit));
      dimensions : dimensional_exponents;
  END_ENTITY; -- named_unit

  ENTITY non_manifold_surface_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      wr1 : (SIZEOF(QUERY ( it <* SELF.items | (NOT (SIZEOF([
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL',
                'SHIP_MOULDED_FORM_SCHEMA.MAPPED_ITEM',
                'SHIP_MOULDED_FORM_SCHEMA.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) 
                = 1)) )) = 0);
      wr2 : (SIZEOF(QUERY ( it <* SELF.items | (SIZEOF([
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL',
                'SHIP_MOULDED_FORM_SCHEMA.MAPPED_ITEM'] * TYPEOF(it)) = 1) )) 
                > 0);
      wr3 : (SIZEOF(QUERY ( mi <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.MAPPED_ITEM' IN TYPEOF(it)) ) | (
                NOT ((('SHIP_MOULDED_FORM_SCHEMA.' + 
                'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION') IN TYPEOF(mi\
                mapped_item.mapping_source.mapped_representation)) AND (
                SIZEOF(QUERY ( mr_it <* mi\mapped_item.mapping_source.
                mapped_representation.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(mr_it)) )) > 0))) )) = 0);
      wr4 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT (SIZEOF([
                'SHIP_MOULDED_FORM_SCHEMA.FACE_SURFACE',
                'SHIP_MOULDED_FORM_SCHEMA.ORIENTED_FACE'] * TYPEOF(fa)) = 1)) )) 
                = 0)) )) = 0)) )) = 0);
      wr5 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( f_sf <* QUERY ( fa <* cfs.cfs_faces | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_SURFACE' IN TYPEOF(fa)) ) | 
                (NOT (('SHIP_MOULDED_FORM_SCHEMA.ADVANCED_FACE' IN TYPEOF(
                f_sf)) OR nmsf_surface_check(f_sf\face_surface.
                face_geometry))) )) = 0)) )) = 0)) )) = 0);
      wr6 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( o_fa <* QUERY ( fa <* cfs.cfs_faces | (
                'SHIP_MOULDED_FORM_SCHEMA.ORIENTED_FACE' IN TYPEOF(fa)) )
                 | (NOT (('SHIP_MOULDED_FORM_SCHEMA.ADVANCED_FACE' IN 
                TYPEOF(o_fa\oriented_face.face_element)) OR 
                nmsf_surface_check(o_fa\oriented_face.face_element\
                face_surface.face_geometry))) )) = 0)) )) = 0)) )) = 0);
      wr7 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_MOULDED_FORM_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR 
                (SIZEOF(QUERY ( bnds <* fa.bounds | (NOT (SIZEOF([
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP',
                'SHIP_MOULDED_FORM_SCHEMA.VERTEX_LOOP'] * TYPEOF(bnds.bound)) 
                = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr8 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_MOULDED_FORM_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR 
                (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT ('SHIP_MOULDED_FORM_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.
                edge_element))) )) = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr9 : (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_MOULDED_FORM_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR 
                (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe_cv <* QUERY ( oe <* elp_fbnds\
                path.edge_list | ('SHIP_MOULDED_FORM_SCHEMA.EDGE_CURVE' IN 
                TYPEOF(oe.edge_element)) ) | (NOT (SIZEOF([
                'SHIP_MOULDED_FORM_SCHEMA.B_SPLINE_CURVE',
                'SHIP_MOULDED_FORM_SCHEMA.CONIC',
                'SHIP_MOULDED_FORM_SCHEMA.CURVE_REPLICA',
                'SHIP_MOULDED_FORM_SCHEMA.LINE',
                'SHIP_MOULDED_FORM_SCHEMA.OFFSET_CURVE_3D',
                'SHIP_MOULDED_FORM_SCHEMA.PCURVE',
                'SHIP_MOULDED_FORM_SCHEMA.POLYLINE',
                'SHIP_MOULDED_FORM_SCHEMA.SURFACE_CURVE'] * TYPEOF(oe_cv.
                edge_element\edge_curve.edge_geometry)) = 1)) )) = 0)) )) =
                 0))) )) = 0)) )) = 0)) )) = 0);
      wr10: (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_MOULDED_FORM_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR 
                (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT nmsf_curve_check(oe.edge_element\edge_curve.
                edge_geometry)) )) = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr11: (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_MOULDED_FORM_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR 
                (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT (('SHIP_MOULDED_FORM_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_start)) AND (
                'SHIP_MOULDED_FORM_SCHEMA.VERTEX_POINT' IN TYPEOF(oe.
                edge_element.edge_end)))) )) = 0)) )) = 0))) )) = 0)) )) = 
                0)) )) = 0);
      wr12: (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_MOULDED_FORM_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR 
                (SIZEOF(QUERY ( elp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(QUERY ( oe <* elp_fbnds\path.edge_list | (
                NOT ((SIZEOF(['SHIP_MOULDED_FORM_SCHEMA.CARTESIAN_POINT',
                'SHIP_MOULDED_FORM_SCHEMA.DEGENERATE_PCURVE',
                'SHIP_MOULDED_FORM_SCHEMA.POINT_ON_CURVE',
                'SHIP_MOULDED_FORM_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(oe.
                edge_element.edge_start\vertex_point.vertex_geometry)) = 1) 
                AND (SIZEOF(['SHIP_MOULDED_FORM_SCHEMA.CARTESIAN_POINT',
                'SHIP_MOULDED_FORM_SCHEMA.DEGENERATE_PCURVE',
                'SHIP_MOULDED_FORM_SCHEMA.POINT_ON_CURVE',
                'SHIP_MOULDED_FORM_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(oe.
                edge_element.edge_end\vertex_point.vertex_geometry)) = 1))) )) 
                = 0)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
      wr13: (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_MOULDED_FORM_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR 
                (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT ('SHIP_MOULDED_FORM_SCHEMA.VERTEX_POINT' IN TYPEOF(
                vlp_fbnds\vertex_loop.loop_vertex))) )) = 0))) )) = 0)) )) 
                = 0)) )) = 0);
      wr14: (SIZEOF(QUERY ( fbsm <* QUERY ( it <* SELF.items | (
                'SHIP_MOULDED_FORM_SCHEMA.FACE_BASED_SURFACE_MODEL' IN 
                TYPEOF(it)) ) | (NOT (SIZEOF(QUERY ( cfs <* fbsm\
                face_based_surface_model.fbsm_faces | (NOT (SIZEOF(
                QUERY ( fa <* cfs.cfs_faces | (NOT ((
                'SHIP_MOULDED_FORM_SCHEMA.ADVANCED_FACE' IN TYPEOF(fa)) OR 
                (SIZEOF(QUERY ( vlp_fbnds <* QUERY ( bnds <* fa.bounds | (
                'SHIP_MOULDED_FORM_SCHEMA.VERTEX_LOOP' IN TYPEOF(bnds.bound)) )
                 | (NOT (SIZEOF(['SHIP_MOULDED_FORM_SCHEMA.CARTESIAN_POINT',
                'SHIP_MOULDED_FORM_SCHEMA.DEGENERATE_PCURVE',
                'SHIP_MOULDED_FORM_SCHEMA.POINT_ON_CURVE',
                'SHIP_MOULDED_FORM_SCHEMA.POINT_ON_SURFACE'] * TYPEOF(
                vlp_fbnds\vertex_loop.loop_vertex\vertex_point.
                vertex_geometry)) = 1)) )) = 0))) )) = 0)) )) = 0)) )) = 0);
  END_ENTITY; -- non_manifold_surface_shape_representation

  ENTITY object_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- object_role

  ENTITY offset_curve_3d
    SUBTYPE OF (curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
      ref_direction  : direction;
    WHERE
      wr1: ((basis_curve.dim = 3) AND (ref_direction.dim = 3));
  END_ENTITY; -- offset_curve_3d

  ENTITY offset_surface
    SUBTYPE OF (surface);
      basis_surface  : surface;
      distance       : length_measure;
      self_intersect : LOGICAL;
  END_ENTITY; -- offset_surface

  ENTITY open_shell
    SUBTYPE OF (connected_face_set);
  END_ENTITY; -- open_shell

  ENTITY ordinal_date
    SUBTYPE OF (date);
      day_component : day_in_year_number;
    WHERE
      wr1: (((NOT leap_year(SELF.year_component)) AND (1 <= day_component) 
               AND (day_component <= 365)) OR (leap_year(SELF.
               year_component) AND (1 <= day_component) AND (day_component 
               <= 366)));
  END_ENTITY; -- ordinal_date

  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY; -- organization

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_organization : organization;
      role                  : organization_role;
  END_ENTITY; -- organization_assignment

  ENTITY organization_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- organization_role

  ENTITY organizational_address
    SUBTYPE OF (address);
      organizations : SET [1:?] OF organization;
      description   : OPTIONAL text;
  END_ENTITY; -- organizational_address

  ENTITY organizational_project;
      name                      : label;
      description               : OPTIONAL text;
      responsible_organizations : SET [1:?] OF organization;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- organizational_project

  ENTITY oriented_closed_shell
    SUBTYPE OF (closed_shell);
      closed_shell_element : closed_shell;
      orientation          : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             closed_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('SHIP_MOULDED_FORM_SCHEMA.ORIENTED_CLOSED_SHELL' IN 
               TYPEOF(SELF.closed_shell_element)));
  END_ENTITY; -- oriented_closed_shell

  ENTITY oriented_edge
    SUBTYPE OF (edge);
      edge_element : edge;
      orientation  : BOOLEAN;
    DERIVE
      SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_start,SELF.
                                edge_element.edge_end);
      SELF\edge.edge_end   : vertex := boolean_choose(SELF.orientation,
                                SELF.edge_element.edge_end,SELF.
                                edge_element.edge_start);
    WHERE
      wr1: (NOT ('SHIP_MOULDED_FORM_SCHEMA.ORIENTED_EDGE' IN TYPEOF(SELF.
               edge_element)));
  END_ENTITY; -- oriented_edge

  ENTITY oriented_face
    SUBTYPE OF (face);
      face_element : face;
      orientation  : BOOLEAN;
    DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(
                            SELF.orientation,SELF.face_element.bounds);
    WHERE
      wr1: (NOT ('SHIP_MOULDED_FORM_SCHEMA.ORIENTED_FACE' IN TYPEOF(SELF.
               face_element)));
  END_ENTITY; -- oriented_face

  ENTITY oriented_open_shell
    SUBTYPE OF (open_shell);
      open_shell_element : open_shell;
      orientation        : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := 
                                             conditional_reverse(SELF.
                                             orientation,SELF.
                                             open_shell_element.cfs_faces);
    WHERE
      wr1: (NOT ('SHIP_MOULDED_FORM_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(
               SELF.open_shell_element)));
  END_ENTITY; -- oriented_open_shell

  ENTITY oriented_path
    SUBTYPE OF (path);
      path_element : path;
      orientation  : BOOLEAN;
    DERIVE
      SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := 
                               conditional_reverse(SELF.orientation,SELF.
                               path_element.edge_list);
    WHERE
      wr1: (NOT ('SHIP_MOULDED_FORM_SCHEMA.ORIENTED_PATH' IN TYPEOF(SELF.
               path_element)));
  END_ENTITY; -- oriented_path

  ENTITY oriented_surface
    SUBTYPE OF (surface);
      orientation : BOOLEAN;
  END_ENTITY; -- oriented_surface

  ENTITY parabola
    SUBTYPE OF (conic);
      focal_dist : length_measure;
    WHERE
      wr1: (focal_dist <> 0);
  END_ENTITY; -- parabola

  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY; -- parametric_representation_context

  ENTITY path
    SUPERTYPE OF (ONEOF (edge_loop,oriented_path))
    SUBTYPE OF (topological_representation_item);
      edge_list : LIST [1:?] OF UNIQUE oriented_edge;
    WHERE
      wr1: path_head_to_tail(SELF);
  END_ENTITY; -- path

  ENTITY pcurve
    SUBTYPE OF (curve);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
      wr1: (SIZEOF(reference_to_curve\representation.items) = 1);
      wr2: ('SHIP_MOULDED_FORM_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\
               representation.items[1]));
      wr3: (reference_to_curve\representation.items[1]\
               geometric_representation_item.dim = 2);
  END_ENTITY; -- pcurve

  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    WHERE
      wr1: (EXISTS(last_name) OR EXISTS(first_name));
  END_ENTITY; -- person

  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- person_and_organization

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
      assigned_person_and_organization : person_and_organization;
      role                             : person_and_organization_role;
  END_ENTITY; -- person_and_organization_assignment

  ENTITY person_and_organization_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- person_and_organization_role

  ENTITY person_assignment
    ABSTRACT SUPERTYPE;
      assigned_person : person;
      role            : person_role;
  END_ENTITY; -- person_assignment

  ENTITY person_role;
      name : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- person_role

  ENTITY personal_address
    SUBTYPE OF (address);
      people      : SET [1:?] OF person;
      description : OPTIONAL text;
  END_ENTITY; -- personal_address

  ENTITY placement
    SUPERTYPE OF (ONEOF (axis1_placement,axis2_placement_2d,
        axis2_placement_3d))
    SUBTYPE OF (geometric_representation_item);
      location : cartesian_point;
  END_ENTITY; -- placement

  ENTITY plane
    SUBTYPE OF (elementary_surface);
  END_ENTITY; -- plane

  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('SHIP_MOULDED_FORM_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- plane_angle_measure_with_unit

  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- plane_angle_unit

  ENTITY point
    SUPERTYPE OF (ONEOF (cartesian_point,point_on_curve,point_on_surface,
        point_replica,degenerate_pcurve))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- point

  ENTITY point_on_curve
    SUBTYPE OF (point);
      basis_curve     : curve;
      point_parameter : parameter_value;
  END_ENTITY; -- point_on_curve

  ENTITY point_on_surface
    SUBTYPE OF (point);
      basis_surface     : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
  END_ENTITY; -- point_on_surface

  ENTITY point_replica
    SUBTYPE OF (point);
      parent_pt      : point;
      transformation : cartesian_transformation_operator;
    WHERE
      wr1: (transformation.dim = parent_pt.dim);
      wr2: acyclic_point_replica(SELF,parent_pt);
  END_ENTITY; -- point_replica

  ENTITY poly_loop
    SUBTYPE OF (loop, geometric_representation_item);
      polygon : LIST [3:?] OF UNIQUE cartesian_point;
  END_ENTITY; -- poly_loop

  ENTITY polyline
    SUBTYPE OF (bounded_curve);
      points : LIST [2:?] OF cartesian_point;
  END_ENTITY; -- polyline

  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : OPTIONAL text;
      frame_of_reference : SET [1:?] OF product_context;
  END_ENTITY; -- product

  ENTITY product_category;
      name        : label;
      description : OPTIONAL text;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- product_category

  ENTITY product_category_relationship;
      name         : label;
      description  : OPTIONAL text;
      category     : product_category;
      sub_category : product_category;
    WHERE
      wr1: acyclic_product_category_relationship(SELF,[SELF.sub_category]);
  END_ENTITY; -- product_category_relationship

  ENTITY product_context
    SUBTYPE OF (application_context_element);
      discipline_type : label;
  END_ENTITY; -- product_context

  ENTITY product_definition;
      id                 : identifier;
      description        : OPTIONAL text;
      formation          : product_definition_formation;
      frame_of_reference : product_definition_context;
    DERIVE
      name : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY; -- product_definition

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
      life_cycle_stage : label;
  END_ENTITY; -- product_definition_context

  ENTITY product_definition_formation;
      id          : identifier;
      description : OPTIONAL text;
      of_product  : product;
    UNIQUE
      ur1 : id, of_product;
  END_ENTITY; -- product_definition_formation

  ENTITY product_definition_relationship;
      id                          : identifier;
      name                        : label;
      description                 : OPTIONAL text;
      relating_product_definition : product_definition;
      related_product_definition  : product_definition;
  END_ENTITY; -- product_definition_relationship

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
    UNIQUE
      ur1 : definition;
    WHERE
      wr1: (SIZEOF([
               'SHIP_MOULDED_FORM_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION',
               'SHIP_MOULDED_FORM_SCHEMA.CHARACTERIZED_OBJECT'] * TYPEOF(
               SELF\property_definition.definition)) > 0);
  END_ENTITY; -- product_definition_shape

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
      products : SET [1:?] OF product;
  END_ENTITY; -- product_related_product_category

  ENTITY property_definition;
      name        : label;
      description : OPTIONAL text;
      definition  : characterized_definition;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- property_definition

  ENTITY property_definition_relationship;
      name                         : label;
      description                  : text;
      relating_property_definition : property_definition;
      related_property_definition  : property_definition;
  END_ENTITY; -- property_definition_relationship

  ENTITY property_definition_representation;
      definition          : represented_definition;
      used_representation : representation;
    DERIVE
      description : text := get_description_value(SELF);
      name        : label := get_name_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1);
  END_ENTITY; -- property_definition_representation

  ENTITY quasi_uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- quasi_uniform_curve

  ENTITY quasi_uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- quasi_uniform_surface

  ENTITY ratio_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- ratio_unit

  ENTITY rational_b_spline_curve
    SUBTYPE OF (b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:upper_index_on_control_points] OF REAL := 
                   list_to_array(weights_data,0,
                   upper_index_on_control_points);
    WHERE
      wr1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
               control_points_list));
      wr2: curve_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_curve

  ENTITY rational_b_spline_surface
    SUBTYPE OF (b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := 
                   make_array_of_array(weights_data,0,u_upper,0,v_upper);
    WHERE
      wr1: ((SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.
               control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(
               SELF\b_spline_surface.control_points_list[1])));
      wr2: surface_weights_positive(SELF);
  END_ENTITY; -- rational_b_spline_surface

  ENTITY representation;
      name             : label;
      items            : SET [1:?] OF representation_item;
      context_of_items : representation_context;
    DERIVE
      id          : identifier := get_id_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
      wr2: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1);
  END_ENTITY; -- representation

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR 
                                      context_of_items;
  END_ENTITY; -- representation_context

  ENTITY representation_item;
      name : label;
    WHERE
      wr1: (SIZEOF(using_representations(SELF)) > 0);
  END_ENTITY; -- representation_item

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET [1:?] OF mapped_item FOR mapping_source;
    WHERE
      wr1: item_in_context(SELF.mapping_origin,SELF.mapped_representation.
               context_of_items);
  END_ENTITY; -- representation_map

  ENTITY representation_relationship;
      name        : label;
      description : OPTIONAL text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY; -- representation_relationship

  ENTITY role_association;
      role           : object_role;
      item_with_role : role_select;
  END_ENTITY; -- role_association

  ENTITY seam_curve
    SUBTYPE OF (surface_curve);
    WHERE
      wr1: (SIZEOF(SELF\surface_curve.associated_geometry) = 2);
      wr2: (associated_surface(SELF\surface_curve.associated_geometry[1]) 
               = associated_surface(SELF\surface_curve.associated_geometry[
               2]));
      wr3: ('SHIP_MOULDED_FORM_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve
               .associated_geometry[1]));
      wr4: ('SHIP_MOULDED_FORM_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve
               .associated_geometry[2]));
  END_ENTITY; -- seam_curve

  ENTITY serial_numbered_effectivity
    SUBTYPE OF (effectivity);
      effectivity_start_id : identifier;
      effectivity_end_id   : OPTIONAL identifier;
  END_ENTITY; -- serial_numbered_effectivity

  ENTITY shape_aspect;
      name                 : label;
      description          : OPTIONAL text;
      of_shape             : product_definition_shape;
      product_definitional : LOGICAL;
    DERIVE
      id : identifier := get_id_value(SELF);
    WHERE
      wr1: (SIZEOF(USEDIN(SELF,'SHIP_MOULDED_FORM_SCHEMA.' + 
               'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1);
  END_ENTITY; -- shape_aspect

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    WHERE
      wr1: (('SHIP_MOULDED_FORM_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN 
               TYPEOF(SELF.definition)) OR (
               'SHIP_MOULDED_FORM_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(SELF.
               definition.definition)));
      wr2: ('SHIP_MOULDED_FORM_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(SELF
               .used_representation));
  END_ENTITY; -- shape_definition_representation

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY; -- shape_representation

  ENTITY si_unit
    SUBTYPE OF (named_unit);
      prefix : OPTIONAL si_prefix;
      name   : si_unit_name;
    DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := 
                                      dimensions_for_si_unit(name);
  END_ENTITY; -- si_unit

  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
    WHERE
      wr1: ('SHIP_MOULDED_FORM_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\
               measure_with_unit.unit_component));
  END_ENTITY; -- solid_angle_measure_with_unit

  ENTITY solid_angle_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- solid_angle_unit

  ENTITY solid_model
    SUPERTYPE OF (manifold_solid_brep)
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- solid_model

  ENTITY spherical_surface
    SUBTYPE OF (elementary_surface);
      radius : positive_length_measure;
  END_ENTITY; -- spherical_surface

  ENTITY subface
    SUBTYPE OF (face);
      parent_face : face;
    WHERE
      wr1: (NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)) + 
               list_to_set(list_face_loops(parent_face))));
  END_ENTITY; -- subface

  ENTITY surface
    SUPERTYPE OF (ONEOF (elementary_surface,swept_surface,bounded_surface,
        offset_surface,surface_replica))
    SUBTYPE OF (geometric_representation_item);
  END_ENTITY; -- surface

  ENTITY surface_curve
    SUPERTYPE OF (ONEOF (intersection_curve,seam_curve) ANDOR 
        bounded_surface_curve)
    SUBTYPE OF (curve);
      curve_3d              : curve;
      associated_geometry   : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
    DERIVE
      basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
    WHERE
      wr1: (curve_3d.dim = 3);
      wr2: (('SHIP_MOULDED_FORM_SCHEMA.PCURVE' IN TYPEOF(
               associated_geometry[1])) OR (master_representation <> 
               pcurve_s1));
      wr3: (('SHIP_MOULDED_FORM_SCHEMA.PCURVE' IN TYPEOF(
               associated_geometry[2])) OR (master_representation <> 
               pcurve_s2));
      wr4: (NOT ('SHIP_MOULDED_FORM_SCHEMA.PCURVE' IN TYPEOF(curve_3d)));
  END_ENTITY; -- surface_curve

  ENTITY surface_of_linear_extrusion
    SUBTYPE OF (swept_surface);
      extrusion_axis : vector;
  END_ENTITY; -- surface_of_linear_extrusion

  ENTITY surface_of_revolution
    SUBTYPE OF (swept_surface);
      axis_position : axis1_placement;
    DERIVE
      axis_line : line := representation_item('') || 
                     geometric_representation_item() || curve() || line(
                     axis_position.location,representation_item('') || 
                     geometric_representation_item() || vector(
                     axis_position.z,1));
  END_ENTITY; -- surface_of_revolution

  ENTITY surface_replica
    SUBTYPE OF (surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
    WHERE
      wr1: acyclic_surface_replica(SELF,parent_surface);
  END_ENTITY; -- surface_replica

  ENTITY swept_surface
    SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,surface_of_revolution))
    SUBTYPE OF (surface);
      swept_curve : curve;
  END_ENTITY; -- swept_surface

  ENTITY thermodynamic_temperature_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 0) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 1) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- thermodynamic_temperature_unit

  ENTITY time_unit
    SUBTYPE OF (named_unit);
    WHERE
      wr1: ((SELF\named_unit.dimensions.length_exponent = 0) AND (SELF\
               named_unit.dimensions.mass_exponent = 0) AND (SELF\
               named_unit.dimensions.time_exponent = 1) AND (SELF\
               named_unit.dimensions.electric_current_exponent = 0) AND (
               SELF\named_unit.dimensions.
               thermodynamic_temperature_exponent = 0) AND (SELF\named_unit
               .dimensions.amount_of_substance_exponent = 0) AND (SELF\
               named_unit.dimensions.luminous_intensity_exponent = 0));
  END_ENTITY; -- time_unit

  ENTITY topological_representation_item
    SUPERTYPE OF (ONEOF (vertex,edge,face_bound,face,connected_edge_set,
        connected_face_set,loop ANDOR path))
    SUBTYPE OF (representation_item);
  END_ENTITY; -- topological_representation_item

  ENTITY toroidal_surface
    SUBTYPE OF (elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
  END_ENTITY; -- toroidal_surface

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : OPTIONAL text;
    WHERE
      wr1: valid_measure_value(SELF\measure_with_unit.value_component);
  END_ENTITY; -- uncertainty_measure_with_unit

  ENTITY uniform_curve
    SUBTYPE OF (b_spline_curve);
  END_ENTITY; -- uniform_curve

  ENTITY uniform_surface
    SUBTYPE OF (b_spline_surface);
  END_ENTITY; -- uniform_surface

  ENTITY value_representation_item
    SUBTYPE OF (representation_item);
      value_component : measure_value;
    WHERE
      wr1: (SIZEOF(QUERY ( rep <* using_representations(SELF) | (NOT (
               'SHIP_MOULDED_FORM_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN 
               TYPEOF(rep.context_of_items))) )) = 0);
  END_ENTITY; -- value_representation_item

  ENTITY vector
    SUBTYPE OF (geometric_representation_item);
      orientation : direction;
      magnitude   : length_measure;
    WHERE
      wr1: (magnitude >= 0);
  END_ENTITY; -- vector

  ENTITY versioned_action_request;
      id          : identifier;
      version     : label;
      purpose     : text;
      description : OPTIONAL text;
  END_ENTITY; -- versioned_action_request

  ENTITY vertex
    SUBTYPE OF (topological_representation_item);
  END_ENTITY; -- vertex

  ENTITY vertex_loop
    SUBTYPE OF (loop);
      loop_vertex : vertex;
  END_ENTITY; -- vertex_loop

  ENTITY vertex_point
    SUBTYPE OF (vertex, geometric_representation_item);
      vertex_geometry : point;
  END_ENTITY; -- vertex_point

  ENTITY week_of_year_and_day_date
    SUBTYPE OF (date);
      week_component : week_in_year_number;
      day_component  : OPTIONAL day_in_week_number;
  END_ENTITY; -- week_of_year_and_day_date

  RULE action_request_solution_connected_to_action FOR (
                          action_request_solution, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action_request_solution := [];
      set_3   : SET OF action_method := [];
      t2_set  : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action_request_solution | VALUE_IN(which_class(
        a),'change plan') );
    t2_set := QUERY ( b <* action | VALUE_IN(which_class(b),'change') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      set_3 := [];
      REPEAT j := 1 TO HIINDEX(t2_set) BY 1;
        set_3 := set_3 + [t2_set[j].chosen_method];
      END_REPEAT;
      violate := VALUE_IN(set_3,t1_set[i].method);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- action_request_solution_connected_to_action

  RULE action_request_solution_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF action_request_solution := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['change plan'];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | (j.role.name = 
          'globally unambiguous identifier') );
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- action_request_solution_with_identification_assignment

  RULE action_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF action := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['change',
                   'versionable object change event','check'];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | (j.role.name = 
          'globally unambiguous identifier') );
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- action_with_identification_assignment

  RULE alternative_version_relationship_has_mandatory_description FOR (
             identification_assignment_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF identification_assignment_relationship := [];
    END_LOCAL;
    t1_set := QUERY ( i <* identification_assignment_relationship | 
        VALUE_IN(which_class(i),'alternative version relationship') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- alternative_version_relationship_has_mandatory_description

  RULE alternative_version_relationship_has_unique_versions FOR (
             identification_assignment_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF identification_assignment_relationship := [];
    END_LOCAL;
    t1_set := QUERY ( a <* identification_assignment_relationship | 
        VALUE_IN(which_class(a),'alternative version relationship') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      violate := t1_set[i].relating_identification_assignment.assigned_id 
          = t1_set[i].related_identification_assignment.assigned_id;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- alternative_version_relationship_has_unique_versions

  RULE alternative_version_relationship_versionable_object FOR (
             applied_identification_assignment, 
             identification_assignment_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1
         WHILE NOT violate;
      IF (SIZEOF(USEDIN(applied_identification_assignment[i],'SHIP_MOULDED_FORM_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' 
          + 'RELATING_IDENTIFICATION_ASSIGNMENT')) > 0) OR (SIZEOF(USEDIN(
          applied_identification_assignment[i],'SHIP_MOULDED_FORM_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' 
          + 'RELATED_IDENTIFICATION_ASSIGNMENT')) > 0) THEN
        REPEAT j := 1 TO HIINDEX(applied_identification_assignment[i].
            items) BY 1 WHILE NOT violate;
          violate := NOT VALUE_IN(which_class(
              applied_identification_assignment[i].items[j]),
              'versionable object');
        END_REPEAT;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- alternative_version_relationship_versionable_object

  RULE approval_event_with_approval_date_time FOR (approval);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF approval := [];
      t2_set  : SET OF approval_date_time := [];
    END_LOCAL;
    t1_set := QUERY ( i <* approval | VALUE_IN(which_class(i),
        'approval event') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.APPROVAL_DATE_TIME.' + 'DATED_APPROVAL'));
      violate := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- approval_event_with_approval_date_time

  RULE approval_event_with_approval_person_organization FOR (approval);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF approval := [];
      t2_set  : SET OF approval_person_organization := [];
    END_LOCAL;
    t1_set := QUERY ( i <* approval | VALUE_IN(which_class(i),
        'approval event') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.APPROVAL_PERSON_ORGANIZATION.' + 
          'AUTHORIZED_APPROVAL'));
      violate := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- approval_event_with_approval_person_organization

  RULE approval_history_approves_same_definition FOR (
             applied_group_assignment, applied_approval_assignment);

    LOCAL
      violate : LOGICAL := FALSE;
      t3_set  : SET OF approval := [];
      t4_set  : SET OF group_item := [];
      t5_set  : SET OF applied_approval_assignment := [];
      t2_set  : SET OF applied_group_assignment := [];
    END_LOCAL;
    t2_set := QUERY ( a <* applied_group_assignment | VALUE_IN(
        which_class(a.assigned_group),'approval history') );
    t3_set := QUERY ( b <* t2_set[1].items | (
        'SHIP_MOULDED_FORM_SCHEMA.APPROVAL' IN TYPEOF(b)) );
    t4_set := QUERY ( b <* t2_set[1].items | VALUE_IN(which_class(b),
        'DEFINITION') );
    violate := NOT (SIZEOF(t4_set) = 1);
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1 WHILE NOT violate;
      t5_set := QUERY ( a <* applied_approval_assignment | ((a.
          assigned_approval = t3_set[i]) AND (NOT VALUE_IN(a.items,t4_set[1]))) );
      violate := SIZEOF(t5_set) > 0;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);
    wr2: (SIZEOF(t4_set) = 1);

  END_RULE; -- approval_history_approves_same_definition

  RULE approval_history_has_at_least_one_member FOR (group, 
             applied_group_assignment);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      t2_set  : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( i <* group | VALUE_IN(which_class(i),
        'approval history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := QUERY ( a <* applied_group_assignment | (a.assigned_group 
          = t1_set[i]) );
      violate := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- approval_history_has_at_least_one_member

  RULE approvals_references_approval_history FOR (applied_group_assignment, 
             group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),
        'approval history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | (NOT ((b.
          assigned_group = t1_set[i]) AND (b.role.name = 'approvals'))) );
      violate := SIZEOF(a_set) > 0;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- approvals_references_approval_history

  RULE author_for_change_plan FOR (
             applied_person_and_organization_assignment, 
             action_request_solution);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action_request_solution := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action_request_solution | VALUE_IN(which_class(
        a),'change plan') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'author')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- author_for_change_plan

  RULE author_for_change_realisation FOR (
             applied_person_and_organization_assignment, executed_action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF executed_action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* executed_action | VALUE_IN(which_class(a),
        'change realization') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'author')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- author_for_change_realisation

  RULE author_for_change_request FOR (
             applied_person_and_organization_assignment, 
             versioned_action_request);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF versioned_action_request := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* versioned_action_request | VALUE_IN(
        which_class(a),'change request') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'author')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- author_for_change_request

  RULE caused_by_for_check FOR (applied_person_and_organization_assignment, 
             action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),'check') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'caused by')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_by_for_check

  RULE caused_by_for_envisaged_version_creation FOR (
             applied_person_and_organization_assignment, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'envisaged version creation') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'caused by')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_by_for_envisaged_version_creation

  RULE caused_by_for_version_creation FOR (
             applied_person_and_organization_assignment, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version creation') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'caused by')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_by_for_version_creation

  RULE caused_by_for_version_deletion FOR (
             applied_person_and_organization_assignment, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version deletion') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'caused by')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_by_for_version_deletion

  RULE caused_by_for_version_modification FOR (
             applied_person_and_organization_assignment, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version modification') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'caused by')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_by_for_version_modification

  RULE caused_when_for_check FOR (applied_date_and_time_assignment, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),'check') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'caused when')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_when_for_check

  RULE caused_when_for_envisaged_version_creation FOR (
             applied_date_and_time_assignment, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'envisaged version creation') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'caused when')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_when_for_envisaged_version_creation

  RULE caused_when_for_version_creation FOR (
             applied_date_and_time_assignment, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version creation') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'caused when')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_when_for_version_creation

  RULE caused_when_for_version_deletion FOR (
             applied_date_and_time_assignment, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version deletion') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'caused when')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_when_for_version_deletion

  RULE caused_when_for_version_modification FOR (
             applied_date_and_time_assignment, action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action | VALUE_IN(which_class(a),
        'version modification') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'caused when')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- caused_when_for_version_modification

  RULE centre_location_compound_representation_has_specified_name FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['longitudinal location',
                   'transversal location','vertical location'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'centre location') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- centre_location_compound_representation_has_specified_name

  RULE change_impact_with_versionable_object_change_event FOR (
             applied_action_request_assignment);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF applied_action_request_assignment := [];
      a_set   : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( b <* applied_action_request_assignment | (b.role.
        name = 'change impact') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* t1_set[i].items | ((
          'SHIP_MOULDED_FORM_SCHEMA.ACTION' IN TYPEOF(b)) AND VALUE_IN(
          which_class(b),'versionable object change event')) );
      violate := SIZEOF(a_set) = 0;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- change_impact_with_versionable_object_change_event

  RULE change_plan_has_mandatory_attribute_description FOR (
             action_request_solution);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action_request_solution := [];
    END_LOCAL;
    t1_set := QUERY ( i <* action_request_solution | VALUE_IN(which_class(
        i),'change plan') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- change_plan_has_mandatory_attribute_description

  RULE class_and_statutory_designation_has_properties FOR (
             property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t4_list   : LIST OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t3_list   : LIST OF property_definition := [];
      t1_list   : LIST OF product_definition := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class and statutory designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_list := t1_list + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    t2_set := QUERY ( i <* property_definition_representation | (i.name = 
        'class and statutory designation') );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_list := t3_list + t2_set[i].definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_list) BY 1;
      t4_list := t4_list + t3_list[i].definition;
    END_REPEAT;
    violation := t1_list <> t4_list;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- class_and_statutory_designation_has_properties

  RULE class_notation_with_named_representation_items FOR (representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['class notations hull',
                   'class notations machinery'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'class notation') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) < 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- class_notation_with_named_representation_items

  RULE class_parameters_has_properties FOR (
             property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      t3_set    : LIST OF property_definition := [];
      violation : LOGICAL := FALSE;
      t4_set    : LIST OF product_definition := [];
      t1_set    : LIST OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class parameters') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    t2_set := QUERY ( i <* property_definition_representation | (i.name = 
        'class parameters') );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + t2_set[i].definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- class_parameters_has_properties

  RULE compatible_dimension FOR (cartesian_point, direction, 
             representation_context, geometric_representation_context);

  WHERE
    wr1: (SIZEOF(QUERY ( x <* cartesian_point | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.coordinates) <> y.coordinate_space_dimension)) )) > 
             0) )) = 0);
    wr2: (SIZEOF(QUERY ( x <* direction | (SIZEOF(QUERY ( y <* 
             geometric_representation_context | (item_in_context(x,y) AND (
             HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)) )) 
             > 0) )) = 0);

  END_RULE; -- compatible_dimension

  RULE compound_representation_item_with_class_id_knot FOR (
             applied_classification_assignment);

    LOCAL
      t3_set     : SET OF representation_item := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF compound_representation_item := [];
      c_a_set    : SET OF applied_classification_assignment := [];
      c_a_set2   : SET OF applied_classification_assignment := [];
      l_rep_item : list_representation_item;
      t2_set     : SET OF compound_representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'knot') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c_a_set2 := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship curve') );
    REPEAT i := 1 TO HIINDEX(c_a_set2) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set2[i].items) BY 1;
        t2_set := t2_set + c_a_set2[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      l_rep_item := t1_set[i].item_element;
      REPEAT j := 1 TO HIINDEX(t1_set[i].item_element) BY 1;
        t3_set := t3_set + l_rep_item[j];
      END_REPEAT;
      violation := SIZEOF(t3_set * t2_set) < 2;
      t3_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- compound_representation_item_with_class_id_knot

  RULE compound_representation_item_with_hydrostatic_properties FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['hydrostatic property value'];
      t2_set    : LIST OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'hydrostatic properties for constant floating position') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) < 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- compound_representation_item_with_hydrostatic_properties

  RULE compound_representation_item_with_section_identifier FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'section of offset point table') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'APPLIED_IDENTIFICATION_ASSIGNMENT' + '.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'section identifier') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- compound_representation_item_with_section_identifier

  RULE date_time_for_change_plan FOR (applied_date_and_time_assignment, 
             action_request_solution);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action_request_solution := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* action_request_solution | VALUE_IN(which_class(
        a),'change plan') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'date time')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- date_time_for_change_plan

  RULE date_time_for_change_realisation FOR (
             applied_date_and_time_assignment, executed_action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF executed_action := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* executed_action | VALUE_IN(which_class(a),
        'change realisation') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'date time')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- date_time_for_change_realisation

  RULE date_time_for_change_request FOR (applied_date_and_time_assignment, 
             versioned_action_request);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF versioned_action_request := [];
      a_set   : SET OF applied_date_and_time_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* versioned_action_request | VALUE_IN(
        which_class(a),'change request') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_date_and_time_assignment | (VALUE_IN(b
          .items,t1_set[i]) AND (b.role.name = 'date time')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- date_time_for_change_request

  RULE document_has_at_least_one_references FOR (document);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF document := [];
      t2_set  : SET OF document_representation_type := [];
    END_LOCAL;
    t1_set := QUERY ( i <* document | VALUE_IN(which_class(i),'document') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.DOCUMENT_REPRESENTATION_TYPE.' + 
          'REPRESENTED_DOCUMENT'));
      violate := SIZEOF(t2_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- document_has_at_least_one_references

  RULE document_has_exactly_one_author FOR (document);

    LOCAL
      violate : LOGICAL := FALSE;
      bag_3   : BAG OF applied_organization_assignment := [];
      bag_2   : BAG OF applied_person_and_organization_assignment := [];
      bag_1   : BAG OF applied_person_assignment := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(document) BY 1 WHILE NOT violate;
      bag_1 := USEDIN(document[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'APPLIED_PERSON_ASSIGNMENT.ITEMS');
      bag_1 := QUERY ( assign <* bag_1 | (assign.role.name = 'author') );
      bag_2 := USEDIN(document[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS');
      bag_2 := QUERY ( assign <* bag_2 | (assign.role.name = 'author') );
      bag_3 := USEDIN(document[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS');
      bag_3 := QUERY ( assign <* bag_3 | (assign.role.name = 'author') );
      violate := NOT ((SIZEOF(bag_1) + SIZEOF(bag_2) + SIZEOF(bag_3)) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- document_has_exactly_one_author

  RULE document_reference_with_address_has_at_least_one_references FOR (
             document);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF document := [];
      t2_set  : SET OF applied_external_identification_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( i <* document | VALUE_IN(which_class(i),
        'document reference with address') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violate := SIZEOF(t2_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- document_reference_with_address_has_at_least_one_references

  RULE envisaged_version_creation_has_mandatory_attribute_description FOR (
             action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( i <* action | VALUE_IN(which_class(i),
        'envisaged version creation') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- envisaged_version_creation_has_mandatory_attribute_description

  RULE executed_action_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF executed_action := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['change realization'];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | (j.role.name = 
          'globally unambiguous identifier') );
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- executed_action_with_identification_assignment

  RULE external_instance_reference_has_same_identifier FOR (
		applied_external_identification_assignment);
    LOCAL
      violation : LOGICAL := FALSE;
      extref_set : SET OF applied_external_identification_assignment := [];
      aia_set : SET OF applied_identification_assignment := [];
    END_LOCAL;

    extref_set := QUERY ( i <* applied_external_identification_assignment |
	(i.role.name = 'external instance reference') );

    REPEAT i := 1 TO HIINDEX(extref_set) BY 1 WHILE NOT violation;
      aia_set := bag_to_set(USEDIN(extref_set[i].items[1],
      'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (aia_set[1].assigned_id = extref_set[i].assigned_id);
    END_REPEAT;

  WHERE
    wr1: NOT violation;
  END_RULE; -- external_instance_reference_has_same_identifier

  RULE floating_position_compound_representation_with_name FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['moulded form displacement',
                   'draught at amidships','length of waterline',
                   'breadth of waterline','angle of trim','angle of heel'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'floating position') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- floating_position_compound_representation_with_name

  RULE global_axis_placement_has_properties FOR (
             property_definition_representation, group, 
             applied_classification_assignment);

    LOCAL
      t3_set    : LIST OF property_definition := [];
      violation : LOGICAL := FALSE;
      t4_set    : LIST OF product_definition := [];
      t1_set    : LIST OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'global axis placement') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    t2_set := QUERY ( i <* property_definition_representation | (i.name = 
        'global axis placement') );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + t2_set[i].definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- global_axis_placement_has_properties

  RULE global_id_is_unique FOR (applied_identification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      set_1     : SET OF applied_identification_assignment := [];
      bag_2     : BAG OF STRING := [];
    END_LOCAL;
    set_1 := QUERY ( i <* applied_identification_assignment | (i.role.name 
        = 'globally unambiguous identifier') );
    REPEAT i := 1 TO HIINDEX(set_1) BY 1;
      bag_2 := bag_2 + [set_1[i].assigned_id];
    END_REPEAT;
    violation := SIZEOF(QUERY ( i <* set_1 | (SIZEOF(i.items) = 1) )) <> 
        SIZEOF(set_1);

  WHERE
    wr1: VALUE_UNIQUE(bag_2);
    wr2: (NOT violation);

  END_RULE; -- global_id_is_unique

  RULE hull_moulded_form_design_parameter_with_class_references FOR (
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF representation := [];
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hull moulded form design parameter') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
          'DEFINITION'));
      REPEAT j := 1 TO HIINDEX(t2_set) BY 1;
        t3_set := t3_set + t2_set[j].used_representation;
      END_REPEAT;
      violation := SIZEOF(QUERY ( t2_inst <* t3_set | ('midship tumble' IN
           which_class(t2_inst)) )) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- hull_moulded_form_design_parameter_with_class_references

  RULE hydrostatic_properties_with_specified_class FOR (
             applied_classification_assignment);

    LOCAL
      t3_set     : SET OF representation_item := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF compound_representation_item := [];
      c_a_set    : SET OF applied_classification_assignment := [];
      c_a_set2   : SET OF applied_classification_assignment := [];
      l_rep_item : list_representation_item;
      t2_set     : SET OF compound_representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'hydrostatic properties for constant floating position') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c_a_set2 := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'floating position') );
    REPEAT i := 1 TO HIINDEX(c_a_set2) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set2[i].items) BY 1;
        t2_set := t2_set + c_a_set2[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      l_rep_item := t1_set[i].item_element;
      REPEAT j := 1 TO HIINDEX(t1_set[i].item_element) BY 1;
        t3_set := t3_set + l_rep_item[j];
      END_REPEAT;
      violation := SIZEOF(t3_set * t2_set) <> 1;
      t3_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- hydrostatic_properties_with_specified_class

  RULE hydrostatic_property_with_specified_name FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['property type'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hydrostatic property') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- hydrostatic_property_with_specified_name

  RULE identification_role_optional_attribute_description_required FOR (
             identification_role);

  WHERE
    wr1: (SIZEOF(QUERY ( i <* identification_role | ((i.name = 
             'external reference') AND (NOT EXISTS(i.description))) )) = 0);

  END_RULE; -- identification_role_optional_attribute_description_required

  RULE initiator_for_change_request FOR (
             applied_person_and_organization_assignment, 
             versioned_action_request);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF versioned_action_request := [];
      a_set   : SET OF applied_person_and_organization_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* versioned_action_request | VALUE_IN(
        which_class(a),'change request') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_person_and_organization_assignment | (
          VALUE_IN(b.items,t1_set[i]) AND (b.role.name = 'initiator')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- initiator_for_change_request

  RULE mandatory_entity_type_for_external_instance_reference FOR (
             external_source, external_source_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
      bag_1   : BAG OF external_source := [];
    END_LOCAL;
    bag_1 := QUERY ( a <* external_source | (a.description = 'schema name') );
    REPEAT i := 1 TO SIZEOF(bag_1) BY 1 WHILE NOT violate;
      violate := SIZEOF(QUERY ( a <* external_source_relationship | ((a.
          relating_source :=: bag_1[i]) AND (a.related_source.description =
           'entity type')) )) = 0;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- mandatory_entity_type_for_external_instance_reference

  RULE members_is_referenced_by_at_least_one_revision FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),'revision') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          :=: t1_set[i]) AND (b.role.name = 'members')) );
      violate := SIZEOF(a_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- members_is_referenced_by_at_least_one_revision

  RULE no_approvals_except_in_approval_history FOR (approval);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF approval := [];
      t2_set  : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* approval | VALUE_IN(which_class(a),
        'approval event') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.APPLIED_GROUP_ASSIGNMENT.ITEMS'));
      violate := SIZEOF(t2_set) = 0;
      REPEAT k := 1 TO HIINDEX(t2_set) BY 1 WHILE NOT violate;
        violate := NOT VALUE_IN(which_class(t2_set[k].assigned_group),
            'approval history');
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- no_approvals_except_in_approval_history

  RULE offset_point_table_model_compound_representation_has_name FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['offset point table type'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'offset point table model') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- offset_point_table_model_compound_representation_has_name

  RULE principal_characteristics_has_properties FOR (
             property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      t3_set    : LIST OF property_definition := [];
      violation : LOGICAL := FALSE;
      t4_set    : LIST OF product_definition := [];
      t1_set    : LIST OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'principal characteristics') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    t2_set := QUERY ( i <* property_definition_representation | (i.name = 
        'principal characteristics') );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + t2_set[i].definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- principal_characteristics_has_properties

  RULE product_definition_for_call_sign FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'call sign') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_call_sign

  RULE product_definition_for_class_notation FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class and statutory designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (
          'class notation' IN which_class(t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_class_notation

  RULE product_definition_for_flag_state FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'flag state') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_flag_state

  RULE product_definition_for_hydrostatic_definition_requires_reference FOR (
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
      t4_set    : SET OF property_definition := [];
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      c2_a_set  : SET OF applied_classification_assignment := [];
      t2_set    : SET OF representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hydrostatic definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c2_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hydrostatic table') );
    REPEAT i := 1 TO HIINDEX(c2_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c2_a_set[i].items) BY 1;
        t2_set := t2_set + c2_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + bag_to_set(USEDIN(t2_set[i],'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_hydrostatic_definition_requires_reference

  RULE product_definition_for_managing_company FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_organization_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'owner designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'managing company') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_managing_company

  RULE product_definition_for_ordering_company FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_organization_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'owner designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'ordering company') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_ordering_company

  RULE product_definition_for_owning_company FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_organization_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'owner designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'owning company') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_owning_company

  RULE product_definition_for_port_of_registration FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'port of registration') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_port_of_registration

  RULE product_definition_for_regulation FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class and statutory designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | ('regulation' 
          IN which_class(t2_inst)) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_regulation

  RULE product_definition_for_shipyard FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_organization_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'shipyard designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'shipyard') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_shipyard

  RULE product_definition_for_stability_definition FOR (
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF property_definition_representation := [];
      violation : LOGICAL := FALSE;
      t4_set    : SET OF property_definition := [];
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      c2_a_set  : SET OF applied_classification_assignment := [];
      t2_set    : SET OF representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'stability definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c2_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'stability table') );
    REPEAT i := 1 TO HIINDEX(c2_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c2_a_set[i].items) BY 1;
        t2_set := t2_set + c2_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + bag_to_set(USEDIN(t2_set[i],'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_for_stability_definition

  RULE product_definition_relationship_references_are_distinct FOR (
             product_definition_relationship);

    LOCAL
      cyclic_relationship : LOGICAL := FALSE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(product_definition_relationship) BY 1 WHILE 
        NOT cyclic_relationship;
      cyclic_relationship := product_definition_relationship[i].
          related_product_definition :=: product_definition_relationship[i]
          .relating_product_definition;
    END_REPEAT;

  WHERE
    wr1: (NOT cyclic_relationship);

  END_RULE; -- product_definition_relationship_references_are_distinct

  RULE product_definition_relationship_related_to_class_moulded_form FOR (
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF product_definition := [];
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_relationship := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      c2_a_set  : SET OF applied_classification_assignment := [];
      t2_set    : SET OF product_definition := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'moulded form relationship') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1;
      t2_set := t2_set + t1_set[i].related_product_definition;
      t2_set := t2_set + t1_set[i].relating_product_definition;
    END_REPEAT;
    c2_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'moulded form') );
    REPEAT i := 1 TO HIINDEX(c2_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c2_a_set[i].items) BY 1;
        t3_set := t3_set + c2_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    violation := NOT (t2_set <= t3_set);

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_relationship_related_to_class_moulded_form

  RULE product_definition_relationship_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_relationship := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['item relationship'];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | (j.role.name = 
          'globally unambiguous identifier') );
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_relationship_with_identification_assignment

  RULE product_definition_shape_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition_shape := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['definition'];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | (j.role.name = 
          'globally unambiguous identifier') );
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_shape_with_identification_assignment

  RULE product_definition_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['definition','definable object'];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | (j.role.name = 
          'globally unambiguous identifier') );
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_definition_with_identification_assignment

  RULE product_related_product_category_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_related_product_category := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['Shiptype'];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | (j.role.name = 
          'globally unambiguous identifier') );
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_related_product_category_with_identification_assignment

  RULE product_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['ship'];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | (j.role.name = 
          'globally unambiguous identifier') );
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- product_with_identification_assignment

  RULE propeller_moulded_form_design_parameter_with_class_references FOR (
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF representation := [];
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'propeller moulded form design parameter') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
          'DEFINITION'));
      REPEAT j := 1 TO HIINDEX(t2_set) BY 1;
        t3_set := t3_set + t2_set[j].used_representation;
      END_REPEAT;
      violation := SIZEOF(QUERY ( t2_inst <* t3_set | (
          'propeller location' IN which_class(t2_inst)) )) > 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- propeller_moulded_form_design_parameter_with_class_references

  RULE property_definition_appendage_moulded_form_design_parameter FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'appendage moulded form design parameter') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'appendage moulded form design parameter') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_appendage_moulded_form_design_parameter

  RULE property_definition_for_bottom_moulded_form_design_parameter FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'bottom moulded form design parameter') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'bottom moulded form design parameter') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_bottom_moulded_form_design_parameter

  RULE property_definition_for_bulb_moulded_form_design_parameter FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'bulb moulded form design parameter') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'bulb moulded form design parameter') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_bulb_moulded_form_design_parameter

  RULE property_definition_for_class_notation FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class notation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'class notation') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_class_notation

  RULE property_definition_for_class_society FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_organization_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'class notation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.role.
          name = 'class society') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_class_society

  RULE property_definition_for_deck_moulded_form_design_parameter FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'deck moulded form design parameter') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'deck moulded form design parameter') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_deck_moulded_form_design_parameter

  RULE property_definition_for_hull_moulded_form_design_parameter FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hull moulded form design parameter') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'hull moulded form design parameter') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_hull_moulded_form_design_parameter

  RULE property_definition_for_local_coordinate_system FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'local co ordinate system') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'local coordinate system') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_local_coordinate_system

  RULE property_definition_for_local_coordinate_system_with_position FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'local co ordinate system with position reference') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'local coordinate system with position reference') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_local_coordinate_system_with_position

  RULE property_definition_for_moulded_form_function_parameters FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'moulded form functional definition') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'moulded form function parameters') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_moulded_form_function_parameters

  RULE property_definition_for_rudder_moulded_form_design_parameter FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'rudder moulded form design parameter') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'rudder moulded form design parameter') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_rudder_moulded_form_design_parameter

  RULE property_definition_for_thruster_moulded_form_design_parameter FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'thruster moulded form design parameter') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'thruster moulded form design parameter') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_thruster_moulded_form_design_parameter

  RULE property_definition_for_thruster_propeller_parameter FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_relationship := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'thruster moulded form design parameter') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'PROPERTY_DEFINITION_RELATIONSHIP' + 
          '.RELATING_PROPERTY_DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'thruster propeller parameter') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_for_thruster_propeller_parameter

  RULE property_definition_of_propeller_moulded_form_design_parameter FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'propeller moulded form design parameter') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.' + 
          'PROPERTY_DEFINITION_REPRESENTATION' + '.DEFINITION'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.name =
           'propeller moulded form design parameter') )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_of_propeller_moulded_form_design_parameter

  RULE property_definition_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF property_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := [
                   'moulded form characteristics definition',
                   'moulded form functional definition',
                   'local co ordinate system','spacing table',
                   'hydrostatic definition','stability definition'];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | (j.role.name = 
          'globally unambiguous identifier') );
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- property_definition_with_identification_assignment

  RULE representation_for_appendage_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['appendage length',
                   'appendage breadth','appendage depth',
                   'type of appendage'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'appendage moulded form design parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_appendage_moulded_form_design_parameter

  RULE representation_for_bottom_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['bilge radius','rise of floor',
                   'aft end of flat of bottom',
                   'front end of flat of bottom','flat of bottom breadth',
                   'rake of keel'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 'bottom moulded form design parameter') )) 
        > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_bottom_moulded_form_design_parameter

  RULE representation_for_bulb_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['bulb length','bulb length from pp',
                   'bulb breadth','bulb breadth pp','bulb depth',
                   'bulb depth pp','bulb frame section area at pp',
                   'bulb location'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 'bulb moulded form design parameter') )) 
        > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_bulb_moulded_form_design_parameter

  RULE representation_for_class_and_statutory_designation FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['class number'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'class and statutory designation') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_class_and_statutory_designation

  RULE representation_for_deck_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['camber','sheer at ap','sheer at fp'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 'deck moulded form design parameter') )) 
        > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_deck_moulded_form_design_parameter

  RULE representation_for_global_axis_placement FOR (representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['global axes and origin',
                   'after perpendicular offset','orientation'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'global axis placement') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_global_axis_placement

  RULE representation_for_hull_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := [
                   'aft end of parallel midbody at design draught',
                   'front end of parallel midbody at design draught',
                   'aft end of flat of side','front end of flat of side',
                   'block coefficient','prismatic coefficient',
                   'max wetted frame section area','waterplane coefficient'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 'hull moulded form design parameter') )) 
        > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_hull_moulded_form_design_parameter

  RULE representation_for_hydrostatic_table_constrained FOR (
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF representation_item := [];
      violation : LOGICAL := FALSE;
      t1_set    : SET OF representation := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      c2_a_set  : SET OF applied_classification_assignment := [];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hydrostatic table') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c2_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'hydrostatic properties for constant floating position') );
    REPEAT i := 1 TO HIINDEX(c2_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c2_a_set[i].items) BY 1;
        t2_set := t2_set + c2_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(t1_set[i].items) BY 1;
        t3_set := t3_set + t1_set[i].items[j];
      END_REPEAT;
      violation := SIZEOF(t3_set * t2_set) < 1;
      t3_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_hydrostatic_table_constrained

  RULE representation_for_hydrostatic_table_restricted FOR (
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF representation_item := [];
      violation : LOGICAL := FALSE;
      t1_set    : SET OF representation := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      c2_a_set  : SET OF applied_classification_assignment := [];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hydrostatic table') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c2_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hydrostatic property') );
    REPEAT i := 1 TO HIINDEX(c2_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c2_a_set[i].items) BY 1;
        t2_set := t2_set + c2_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(t1_set[i].items) BY 1;
        t3_set := t3_set + t1_set[i].items[j];
      END_REPEAT;
      violation := SIZEOF(t3_set * t2_set) < 1;
      t3_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_hydrostatic_table_restricted

  RULE representation_for_hydrostatic_table_restricted_by_class_id FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF representation := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['mean shell thickness'];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'hydrostatic table') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* t1_set[i].items | (
            rep_item.name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_hydrostatic_table_restricted_by_class_id

  RULE representation_for_local_coordinate_system FOR (representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['local axes and origin'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'local coordinate system') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_local_coordinate_system

  RULE representation_for_midship_tumble_restricted_by_class_id FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF representation := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['tumble out at bottom',
                   'tumble in at top','tumble out at side',
                   'tumble in at side'];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'midship tumble') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* t1_set[i].items | (
            rep_item.name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_midship_tumble_restricted_by_class_id

  RULE representation_for_moulded_form_function_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['function'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 'moulded form function parameters') )) 
        > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_moulded_form_function_parameters

  RULE representation_for_offset_point_table_model_for_point FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['section point'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'section of offset point table') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) < 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_offset_point_table_model_for_point

  RULE representation_for_offset_point_table_model_for_section FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['offset point table section'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'offset point table model') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) < 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_offset_point_table_model_for_section

  RULE representation_for_offset_table_shape_representation_restricted FOR (
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF representation_item := [];
      violation : LOGICAL := FALSE;
      t1_set    : SET OF representation := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      c2_a_set  : SET OF applied_classification_assignment := [];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'offset table shape representation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c2_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'offset point table model') );
    REPEAT i := 1 TO HIINDEX(c2_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c2_a_set[i].items) BY 1;
        t2_set := t2_set + c2_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(t1_set[i].items) BY 1;
        t3_set := t3_set + t1_set[i].items[j];
      END_REPEAT;
      violation := SIZEOF(t3_set * t2_set) < 1;
      t3_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_offset_table_shape_representation_restricted

  RULE representation_for_propeller_location_restricted_by_class_id FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF representation := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['shaft line inclination x',
                   'shaft line inclination y','shaft line location',
                   'propeller location'];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'propeller location') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* t1_set[i].items | (
            rep_item.name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_propeller_location_restricted_by_class_id

  RULE representation_for_propeller_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['type of propulsion',
                   'propeller diameter','chord length at 0 7 radius',
                   'thickness at 0 7 radius','number of propeller blades',
                   'expanded area ratio','hub diameter ratio',
                   'nominal design pitch ratio','type of propeller blades',
                   'rake','skew','design sense of rotation'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 
        'propeller moulded form design parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_propeller_moulded_form_design_parameter

  RULE representation_for_rudder_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['rudder height','rudder mean height',
                   'rudder length','rudder mean length','rudder thickness',
                   'projected rudder area','type of the rudder',
                   'rudder location'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 'rudder moulded form design parameter') )) 
        > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_rudder_moulded_form_design_parameter

  RULE representation_for_stability_table_restricted FOR (
             applied_classification_assignment);

    LOCAL
      t3_set    : SET OF representation_item := [];
      violation : LOGICAL := FALSE;
      t1_set    : SET OF representation := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      c2_a_set  : SET OF applied_classification_assignment := [];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'stability table') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c2_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'stability properties for one floating position') );
    REPEAT i := 1 TO HIINDEX(c2_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c2_a_set[i].items) BY 1;
        t2_set := t2_set + c2_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(t1_set[i].items) BY 1;
        t3_set := t3_set + t1_set[i].items[j];
      END_REPEAT;
      violation := SIZEOF(t3_set * t2_set) < 1;
      t3_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_stability_table_restricted

  RULE representation_for_stability_table_restricted_by_class_id FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF representation := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['mean shell thickness'];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'stability table') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* t1_set[i].items | (
            rep_item.name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_stability_table_restricted_by_class_id

  RULE representation_for_thruster_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['thruster tunnel diameter',
                   'thruster tunnel min length',
                   'thruster tunnel max length',
                   'geometric thruster location','thruster location'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 
        'thruster moulded form design parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_for_thruster_moulded_form_design_parameter

  RULE representation_has_global_uncertainty_assigned_context FOR (
             shape_representation);

    LOCAL
      has_gunac : LOGICAL := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(shape_representation) BY 1 WHILE has_gunac;
      has_gunac := 
          'SHIP_MOULDED_FORM_SCHEMA.GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT' IN
           TYPEOF(shape_representation[i].context_of_items);
    END_REPEAT;

  WHERE
    wr1: has_gunac;

  END_RULE; -- representation_has_global_uncertainty_assigned_context

  RULE representation_has_global_unit_assigned_context FOR (representation);

    LOCAL
      has_guac : LOGICAL := TRUE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(representation) BY 1 WHILE has_guac;
      REPEAT j := 1 TO SIZEOF(representation[i].items) BY 1 WHILE has_guac;
        IF ('SHIP_MOULDED_FORM_SCHEMA.VALUE_REPRESENTATION_ITEM' IN 
            TYPEOF(representation[i].items[j])) OR (
            'SHIP_MOULDED_FORM_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN 
            TYPEOF(representation[i].items[j])) THEN
          has_guac := 
              'SHIP_MOULDED_FORM_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN 
              TYPEOF(representation[i].context_of_items);
        END_IF;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: has_guac;

  END_RULE; -- representation_has_global_unit_assigned_context

  RULE representation_item_for_transformation_to_parent FOR (
             applied_classification_assignment);

    LOCAL
      t3_set     : SET OF representation := [];
      t4_set     : SET OF representation_map := [];
      t1_set     : SET OF property_definition := [];
      t5_set     : SET OF mapped_item := [];
      c_a_set    : SET OF applied_classification_assignment := [];
      arg_list   : LIST OF STRING := ['local coordinate system position in global coordinate system','local coordinate system position in parent local coordinate system','local coordinate system position in parent local coordinate system with position reference'];
      violation1 : LOGICAL := FALSE;
      violation2 : LOGICAL := FALSE;
      t2_set     : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'local co ordinate system') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation1;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      violation1 := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | (t2_inst.
          used_representation.name = 'local axis representation') )) = 1);
      t3_set := t3_set + t2_set[i].used_representation;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation1;
      t4_set := bag_to_set(USEDIN(t3_set[i],'SHIP_MOULDED_FORM_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation1;
      t5_set := bag_to_set(USEDIN(t4_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
      REPEAT j := 1 TO 3 BY 1 WHILE NOT violation2;
        violation2 := NOT (SIZEOF(QUERY ( t2_inst <* t5_set | (t2_inst.
            name = arg_list[j]) )) = 1);
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation1);
    wr2: (NOT violation2);

  END_RULE; -- representation_item_for_transformation_to_parent

  RULE representation_items_appendage_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['moulded form outer surface',
                  'moulded form displacement','user def appendage type'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'appendage moulded form design parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_appendage_moulded_form_design_parameter

  RULE representation_items_for_bottom_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['moulded form outer surface',
                  'moulded form displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'bottom moulded form design parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_bottom_moulded_form_design_parameter

  RULE representation_items_for_bulb_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['moulded form outer surface',
                  'moulded form displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'bulb moulded form design parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_bulb_moulded_form_design_parameter

  RULE representation_items_for_deck_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['moulded form outer surface',
                  'moulded form displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'deck moulded form design parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_deck_moulded_form_design_parameter

  RULE representation_items_for_hull_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['moulded form outer surface',
                  'moulded form displacement',
                  'waterline angle of entrance at stern',
                  'waterline angle of entrance at bow',
                  'max frame section area location','hull length pp',
                  'hull length waterline','hull breadth','hull depth',
                  'hull design draught','gunwale radius'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'hull moulded form design parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_hull_moulded_form_design_parameter

  RULE representation_items_for_moulded_form_design_parameters FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['status'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'moulded form design parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_moulded_form_design_parameters

  RULE representation_items_for_moulded_form_function_parameters FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['user def function'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))
         | (temp_prop_def_rep.name = 'moulded form function parameters') )) 
        > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_moulded_form_function_parameters

  RULE representation_items_for_rudder_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['moulded form outer surface',
                  'moulded form displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'rudder moulded form design parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_for_rudder_moulded_form_design_parameter

  RULE representation_items_of_thruster_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['moulded form outer surface',
                  'moulded form displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'thruster moulded form design parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_of_thruster_moulded_form_design_parameter

  RULE representation_items_optional_for_class_notation FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['ice class notation','service factor',
                  'approval required for heavy cargo'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'class notation') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_class_notation

  RULE representation_items_optional_for_owner_designation FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['owner approval'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'owner designation') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_owner_designation

  RULE representation_items_optional_for_principal_characteristics FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['block coefficient','design draught',
                  'design deadweight','min draught at fp',
                  'max draught at fp','min draught at ap',
                  'max draught at ap'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'principal characteristics') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_optional_for_principal_characteristics

  RULE representation_items_propeller_moulded_form_design_parameter FOR (
             representation);

    LOCAL
      found    : LOGICAL := FALSE;
      arg_list : LIST OF STRING := ['blade_mean_height',
                  'moulded form outer surface','moulded form displacement'];
      reps     : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'propeller moulded form design parameter') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT found;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT found;
        found := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.name 
            = arg_list[j]) )) > 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT found);

  END_RULE; -- representation_items_propeller_moulded_form_design_parameter

  RULE representation_of_local_coordinate_system_with_position_reference FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['local axes and origin'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'local coordinate system with position reference') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_of_local_coordinate_system_with_position_reference

  RULE representation_restricted_by_name_class_notation FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['service area',
                   'approval required for oil cargo',
                   'approval required for loading unloading aground',
                   'approval required for unloading grabs'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'class notation') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_class_notation

  RULE representation_restricted_by_name_class_parameters FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['length class','length solas',
                   'scantlings draught','block coefficient class',
                   'design speed ahead','design speed astern'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'class parameters') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_class_parameters

  RULE representation_restricted_by_name_principal_characteristics FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['length between perpendiculars',
                   'moulded breadth','moulded depth'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'principal characteristics') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_principal_characteristics

  RULE representation_restricted_by_name_ship_overall_dimensions FOR (
             representation);

    LOCAL
      violation : LOGICAL := FALSE;
      arg_list  : LIST OF STRING := ['overall breadth','overall depth',
                   'overall length','stem overhang','stern overhang'];
      reps      : BAG OF representation := [];
    END_LOCAL;
    reps := QUERY ( temp_rep <* representation | (SIZEOF(
        QUERY ( temp_prop_def_rep <* bag_to_set(USEDIN(temp_rep,
        'SHIP_MOULDED_FORM_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.' + 
        'USED_REPRESENTATION')) | (temp_prop_def_rep.name = 
        'ship overall dimensions') )) > 0) );
    REPEAT i := 1 TO HIINDEX(reps) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        violation := SIZEOF(QUERY ( rep_item <* reps[i].items | (rep_item.
            name = arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- representation_restricted_by_name_ship_overall_dimensions

  RULE revision_has_mandatory_attribute_description FOR (group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
    END_LOCAL;
    t1_set := QUERY ( i <* group | VALUE_IN(which_class(i),'revision') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- revision_has_mandatory_attribute_description

  RULE revision_with_context_referenced_for_context_of_revision FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),
        'revision with context') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (b.role.name = 'context of revision')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- revision_with_context_referenced_for_context_of_revision

  RULE ship_curve_has_name FOR (applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['side condition','curve shape'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship curve') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- ship_curve_has_name

  RULE ship_curve_segment_has_class FOR (applied_classification_assignment);

    LOCAL
      t3_set     : SET OF representation_item := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF compound_representation_item := [];
      c_a_set    : SET OF applied_classification_assignment := [];
      c_a_set2   : SET OF applied_classification_assignment := [];
      l_rep_item : list_representation_item;
      t2_set     : SET OF compound_representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship curve segment') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c_a_set2 := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship curve') );
    REPEAT i := 1 TO HIINDEX(c_a_set2) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set2[i].items) BY 1;
        t2_set := t2_set + c_a_set2[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(t1_set[i].item_element) BY 1;
        l_rep_item := t1_set[i].item_element;
        t3_set := t3_set + l_rep_item[j];
      END_REPEAT;
      violation := SIZEOF(t3_set * t2_set) <> 1;
      t3_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- ship_curve_segment_has_class

  RULE ship_curve_with_spacing_position_has_class FOR (
             applied_classification_assignment);

    LOCAL
      t3_set     : SET OF representation_item := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF compound_representation_item := [];
      c_a_set    : SET OF applied_classification_assignment := [];
      c_a_set2   : SET OF applied_classification_assignment := [];
      l_rep_item : list_representation_item;
      t2_set     : SET OF compound_representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship curve with spacing position') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c_a_set2 := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'spacing position') );
    REPEAT i := 1 TO HIINDEX(c_a_set2) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set2[i].items) BY 1;
        t2_set := t2_set + c_a_set2[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(t1_set[i].item_element) BY 1;
        l_rep_item := t1_set[i].item_element;
        t3_set := t3_set + l_rep_item[j];
      END_REPEAT;
      violation := SIZEOF(t3_set * t2_set) <> 1;
      t3_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- ship_curve_with_spacing_position_has_class

  RULE ship_designation_has_one_specified_names FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship designation') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      violation := NOT (SIZEOF(QUERY ( t2_inst <* t2_set | ((t2_inst.role.
          name = 'imo number') OR (t2_inst.role.name = 
          'pennant hull number')) )) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- ship_designation_has_one_specified_names

  RULE ship_moulded_form_revision_has_description FOR (
             product_definition_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF product_definition_relationship := [];
    END_LOCAL;
    t1_set := QUERY ( i <* product_definition_relationship | VALUE_IN(
        which_class(i),'ship moulded form revision') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- ship_moulded_form_revision_has_description

  RULE ship_overall_dimensions_has_properties FOR (
             property_definition_representation, 
             applied_classification_assignment);

    LOCAL
      t3_set    : LIST OF property_definition := [];
      violation : LOGICAL := FALSE;
      t4_set    : LIST OF product_definition := [];
      t1_set    : LIST OF product_definition := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      t2_set    : SET OF property_definition_representation := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship overall dimensions') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    t2_set := QUERY ( i <* property_definition_representation | (i.name = 
        'ship overall dimensions') );
    REPEAT i := 1 TO HIINDEX(t2_set) BY 1;
      t3_set := t3_set + t2_set[i].definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t3_set) BY 1;
      t4_set := t4_set + t3_set[i].definition;
    END_REPEAT;
    violation := t1_set <> t4_set;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- ship_overall_dimensions_has_properties

  RULE ship_point_compound_representation_has_name FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['point shape'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship point') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- ship_point_compound_representation_has_name

  RULE ship_surface_compound_representation_has_name FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['surface shape'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship surface') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- ship_surface_compound_representation_has_name

  RULE spacing_position_compound_representation_has_name FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['position number','position'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'spacing position') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- spacing_position_compound_representation_has_name


  RULE spacing_position_with_offset_compound_representation_has_class FOR (
             applied_classification_assignment);

    LOCAL
      t3_set     : SET OF representation_item := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF compound_representation_item := [];
      c_a_set    : SET OF applied_classification_assignment := [];
      c_a_set2   : SET OF applied_classification_assignment := [];
      l_rep_item : list_representation_item;
      t2_set     : SET OF compound_representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'spacing position with offset') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c_a_set2 := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'spacing position') );
    REPEAT i := 1 TO HIINDEX(c_a_set2) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set2[i].items) BY 1;
        t2_set := t2_set + c_a_set2[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(t1_set[i].item_element) BY 1;
        l_rep_item := t1_set[i].item_element;
        t3_set := t3_set + l_rep_item[j];
      END_REPEAT;
      violation := SIZEOF(t3_set * t2_set) <> 1;
      t3_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- spacing_position_with_offset_compound_representation_has_class

  RULE spacing_position_with_offset_compound_representation_has_name FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['offset'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'spacing position with offset') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- spacing_position_with_offset_compound_representation_has_name

  RULE stability_properties_for_floating_position_has_class FOR (
             applied_classification_assignment);

    LOCAL
      t3_set     : SET OF representation_item := [];
      violation  : LOGICAL := FALSE;
      t1_set     : SET OF compound_representation_item := [];
      c_a_set    : SET OF applied_classification_assignment := [];
      c_a_set2   : SET OF applied_classification_assignment := [];
      l_rep_item : list_representation_item;
      t2_set     : SET OF compound_representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'stability properties for one floating position') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    c_a_set2 := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'stability property') );
    REPEAT i := 1 TO HIINDEX(c_a_set2) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set2[i].items) BY 1;
        t2_set := t2_set + c_a_set2[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(t1_set[i].item_element) BY 1;
        l_rep_item := t1_set[i].item_element;
        t3_set := t3_set + l_rep_item[j];
      END_REPEAT;
      violation := SIZEOF(t3_set * t2_set) < 1;
      t3_set := [];
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- stability_properties_for_floating_position_has_class

  RULE stability_properties_for_floating_position_has_name FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['centre of gravity above keel',
                   'definition of starting floating position'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 
        'stability properties for one floating position') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- stability_properties_for_floating_position_has_name

  RULE stability_property_has_name FOR (applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF compound_representation_item := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['angle of heel','righting arm',
                   'centre of buoyancy'];
      t2_set    : SET OF representation_item := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'stability property') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
        t2_set := t1_set[i].item_element;
        violation := SIZEOF(QUERY ( items <* t2_set | (items.name = 
            arg_list[j]) )) <> 1;
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- stability_property_has_name

  RULE surface_with_identification_assignment
     FOR (APPLIED_CLASSIFICATION_ASSIGNMENT);
  LOCAL
    c_a_set: SET OF APPLIED_CLASSIFICATION_ASSIGNMENT := [];
    t1_set:  SET OF surface := [];
    t2_set:  SET OF applied_identification_assignment := [];
    arg_list:  LIST OF STRING := ['surface with identifier'];
    violation: LOGICAL := FALSE;
  END_LOCAL;

  (* get all classification_assignment instances  *)
    REPEAT j:=1 TO HIINDEX(arg_list) WHILE (NOT violation);
        c_a_set := QUERY(i <* APPLIED_CLASSIFICATION_ASSIGNMENT |
                   i.assigned_class.NAME =  arg_LIST[j]);
   END_REPEAT;

  (* get all instances of surface that have class id *)
  REPEAT i := 1 TO HIINDEX(c_a_set);
    REPEAT j := 1 TO HIINDEX(c_a_set[i].items);
      t1_set := t1_set + c_a_set[i].items[j];
    END_REPEAT;
  END_REPEAT;

    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],
          'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | 
		     j.role.name = 'globally unambiguous identifier');
   violation := NOT (SIZEOF(T2_SET) = 1);
    END_REPEAT;

    WHERE
      wr1: NOT violation;
  END_RULE; -- surface_with_identification_assignment

  RULE unique_approvals_in_approval_history FOR (group, 
             applied_group_assignment);

    LOCAL
      violate : LOGICAL := FALSE;
      t3_set  : SET OF approval := [];
      t1_set  : SET OF group := [];
      t2_set  : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( i <* group | VALUE_IN(which_class(i),
        'approval history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      t2_set := QUERY ( a <* applied_group_assignment | (a.assigned_group 
          = t1_set[i]) );
      t3_set := QUERY ( b <* t2_set[1].items | (
          'SHIP_MOULDED_FORM_SCHEMA.APPROVAL' IN TYPEOF(b)) );
      violate := NOT VALUE_UNIQUE(t3_set);
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- unique_approvals_in_approval_history

  RULE user_def_appendage_type_description_required FOR (representation);

    LOCAL
      violation : LOGICAL := FALSE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(representation) BY 1 WHILE NOT violation;
      violation := (SIZEOF(QUERY ( r <* representation[i].items | ((
          'SHIP_MOULDED_FORM_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN 
          TYPEOF(r)) AND (r.name = 'type of appendage') AND (r\
          descriptive_representation_item.description = 'user defined')) )) 
          > 0) AND (SIZEOF(QUERY ( r <* representation[i].items | (r.name =
           'user def appendage type') )) = 0);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- user_def_appendage_type_description_required

  RULE user_def_function_description_required FOR (representation);

    LOCAL
      violation : LOGICAL := FALSE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(representation) BY 1 WHILE NOT violation;
      violation := (SIZEOF(QUERY ( r <* representation[i].items | ((
          'SHIP_MOULDED_FORM_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN 
          TYPEOF(r)) AND (r.name = 'function') AND (r\
          descriptive_representation_item.description = 'user defined')) )) 
          > 0) AND (SIZEOF(QUERY ( r <* representation[i].items | (r.name =
           'user def function') )) = 0);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- user_def_function_description_required

  RULE valid_product_definition_for_class_moulded_form FOR (
             applied_classification_assignment, applied_group_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF product_definition := [];
      violate1  : LOGICAL;
      violate2  : LOGICAL;
      c_a_set   : SET OF applied_classification_assignment := [];
      gr_ass    : SET OF applied_group_assignment := [];
      groups    : SET OF group := [];
    END_LOCAL;
    c_a_set := QUERY ( i <* applied_classification_assignment | (i.
        assigned_class.name = 'ship moulded form') );
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    gr_ass := QUERY ( i <* applied_group_assignment | (i.role.name = 
        'equivalence') );
    REPEAT i := 1 TO HIINDEX(gr_ass) BY 1;
      REPEAT j := 1 TO HIINDEX(gr_ass[i].items) BY 1;
        IF gr_ass[i].items[j] IN t1_set THEN
          groups := groups + gr_ass[i].assigned_group;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    gr_ass := QUERY ( i <* applied_group_assignment | ((SIZEOF(i.items) <>
         0) AND (i.role.name = 'item structure') AND (i.assigned_group IN 
        groups)) );
    REPEAT i := 1 TO HIINDEX(gr_ass) BY 1 WHILE NOT violation;
      REPEAT j := 1 TO HIINDEX(gr_ass[i].items) BY 1 WHILE NOT violation;
        violate1 := VALUE_IN(which_class(gr_ass[i].items[j]),
            'moulded form');
        violate2 := VALUE_IN(which_class(gr_ass[i].items[j]),
            'moulded form relationship');
        violation := NOT (violate1 OR violate2);
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- valid_product_definition_for_class_moulded_form

  RULE version_creation_has_mandatory_attribute_description FOR (action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( i <* action | VALUE_IN(which_class(i),
        'version creation') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_creation_has_mandatory_attribute_description

  RULE version_deletion_has_mandatory_attribute_description FOR (action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( i <* action | VALUE_IN(which_class(i),
        'version deletion') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_deletion_has_mandatory_attribute_description

  RULE version_history_has_exactly_one_assigned_group FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      set_1   : SET OF applied_group_assignment := [];
      set_3   : SET OF group_item := [];
      set_2   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),
        'version history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      set_1 := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (b.role.name = 'current version')) );
      set_2 := QUERY ( c <* applied_group_assignment | ((c.assigned_group 
          = t1_set[i]) AND (c.role.name = 'members')) );
      violate := (SIZEOF(set_1) <> 1) OR (SIZEOF(set_2) <> 1);
      IF NOT violate THEN
        set_3 := set_1[1].items * set_2[1].items;
        violate := (SIZEOF(set_3) <> 1) OR (NOT VALUE_IN(which_class(set_3
            [1]),'versionable object'));
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_history_has_exactly_one_assigned_group

  RULE version_history_is_referenced_by_at_least_one_versions FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),
        'version history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (b.role.name = 'versions')) );
      violate := SIZEOF(a_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_history_is_referenced_by_at_least_one_versions

  RULE version_history_referenced_by_exactly_one_current_version FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),
        'version history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (b.role.name = 'current version')) );
      violate := SIZEOF(a_set) <> 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_history_referenced_by_exactly_one_current_version

  RULE version_history_referenced_by_multiple_roles FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),
        'version history') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (NOT (b.role.name IN ['versions',
          'current version','relationships']))) );
      violate := SIZEOF(a_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_history_referenced_by_multiple_roles

  RULE version_modification_has_mandatory_attribute_description FOR (
             action);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF action := [];
    END_LOCAL;
    t1_set := QUERY ( i <* action | VALUE_IN(which_class(i),
        'version modification') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_modification_has_mandatory_attribute_description

  RULE version_relationship_associates_with_versionable_object FOR (
             applied_identification_assignment);

    LOCAL
      violate : LOGICAL := FALSE;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(applied_identification_assignment) BY 1
         WHILE NOT violate;
      IF (SIZEOF(USEDIN(applied_identification_assignment[i],'SHIP_MOULDED_FORM_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' 
          + 'RELATING_IDENTIFICATION_ASSIGNMENT')) > 0) OR (SIZEOF(USEDIN(
          applied_identification_assignment[i],'SHIP_MOULDED_FORM_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' 
          + 'RELATED_IDENTIFICATION_ASSIGNMENT')) > 0) THEN
        REPEAT j := 1 TO HIINDEX(applied_identification_assignment[i].
            items) BY 1 WHILE NOT violate;
          violate := NOT VALUE_IN(which_class(
              applied_identification_assignment[i].items[j]),
              'versionable object');
        END_REPEAT;
      END_IF;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_relationship_associates_with_versionable_object

  RULE version_relationship_has_mandatory_attribute_description FOR (
             identification_assignment_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF identification_assignment_relationship := [];
    END_LOCAL;
    t1_set := QUERY ( i <* identification_assignment_relationship | 
        VALUE_IN(which_class(i),'version relationship') );
    violate := SIZEOF(QUERY ( k <* t1_set | (NOT EXISTS(k.description)) )) 
        > 0;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_relationship_has_mandatory_attribute_description

  RULE version_relationship_has_unique_versions FOR (
             identification_assignment_relationship);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF identification_assignment_relationship := [];
    END_LOCAL;
    t1_set := QUERY ( a <* identification_assignment_relationship | 
        VALUE_IN(which_class(a),'version relationship') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      violate := t1_set[i].relating_identification_assignment.assigned_id 
          = t1_set[i].related_identification_assignment.assigned_id;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- version_relationship_has_unique_versions

  RULE versionable_object_has_one_version_id FOR (
             applied_identification_assignment);

    LOCAL
      version_ids         : SET OF applied_identification_assignment := [];
      duplicate           : LOGICAL := FALSE;
      versionable_objects : BAG OF identification_item := [];
    END_LOCAL;
    version_ids := QUERY ( i <* applied_identification_assignment | (i.
        role.name = 'version identifier') );
    REPEAT i := 1 TO HIINDEX(version_ids) BY 1;
      versionable_objects := versionable_objects + version_ids[i].items;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(versionable_objects) BY 1 WHILE NOT duplicate;
      REPEAT j := i + 1 TO HIINDEX(versionable_objects) BY 1 WHILE NOT 
          duplicate;
        duplicate := versionable_objects[i] :=: versionable_objects[j];
      END_REPEAT;
    END_REPEAT;

  WHERE
    wr1: (NOT duplicate);

  END_RULE; -- versionable_object_has_one_version_id

  RULE versioned_action_request_with_identification_assignment FOR (
             applied_classification_assignment);

    LOCAL
      violation : LOGICAL := FALSE;
      t1_set    : SET OF versioned_action_request := [];
      c_a_set   : SET OF applied_classification_assignment := [];
      arg_list  : LIST OF STRING := ['change request'];
      t2_set    : SET OF applied_identification_assignment := [];
    END_LOCAL;
    REPEAT j := 1 TO HIINDEX(arg_list) BY 1 WHILE NOT violation;
      c_a_set := QUERY ( i <* applied_classification_assignment | (i.
          assigned_class.name = arg_list[j]) );
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(c_a_set) BY 1;
      REPEAT j := 1 TO HIINDEX(c_a_set[i].items) BY 1;
        t1_set := t1_set + c_a_set[i].items[j];
      END_REPEAT;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violation;
      t2_set := bag_to_set(USEDIN(t1_set[i],'SHIP_MOULDED_FORM_SCHEMA.APPLIED_IDENTIFICATION_ASSIGNMENT.ITEMS'));
      t2_set := QUERY ( j <* t2_set | (j.role.name = 
          'globally unambiguous identifier') );
      violation := NOT (SIZEOF(t2_set) = 1);
    END_REPEAT;

  WHERE
    wr1: (NOT violation);

  END_RULE; -- versioned_action_request_with_identification_assignment

  RULE versions_is_referenced_by_at_least_one_version_history FOR (
             applied_group_assignment, group);

    LOCAL
      violate : LOGICAL := FALSE;
      t1_set  : SET OF group := [];
      a_set   : SET OF applied_group_assignment := [];
    END_LOCAL;
    t1_set := QUERY ( a <* group | VALUE_IN(which_class(a),'versions') );
    REPEAT i := 1 TO HIINDEX(t1_set) BY 1 WHILE NOT violate;
      a_set := QUERY ( b <* applied_group_assignment | ((b.assigned_group 
          = t1_set[i]) AND (b.role.name = 'version history')) );
      violate := SIZEOF(a_set) < 1;
    END_REPEAT;

  WHERE
    wr1: (NOT violate);

  END_RULE; -- versions_is_referenced_by_at_least_one_version_history

  FUNCTION acyclic_curve_replica(
               rep: curve_replica;
               parent: curve
      ): BOOLEAN;
    IF NOT ('SHIP_MOULDED_FORM_SCHEMA.CURVE_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
    END_IF;

  END_FUNCTION; -- acyclic_curve_replica

  FUNCTION acyclic_mapped_representation(
               parent_set: SET OF representation;
               children_set: SET OF representation_item
      ): BOOLEAN;

    LOCAL
      x : SET OF representation_item;
      y : SET OF representation_item;
    END_LOCAL;
    x := QUERY ( z <* children_set | (
        'SHIP_MOULDED_FORM_SCHEMA.MAPPED_ITEM' IN TYPEOF(z)) );
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF x[i]\mapped_item.mapping_source.mapped_representation IN 
            parent_set THEN
          RETURN(FALSE);
        END_IF;
        IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
            .mapping_source.mapped_representation,x[i]\mapped_item.
            mapping_source.mapped_representation.items) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    x := children_set - x;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | (
            'SHIP_MOULDED_FORM_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) );
        IF NOT acyclic_mapped_representation(parent_set,y) THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_mapped_representation

  FUNCTION acyclic_point_replica(
               rep: point_replica;
               parent: point
      ): BOOLEAN;
    IF NOT ('SHIP_MOULDED_FORM_SCHEMA.POINT_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
    END_IF;

  END_FUNCTION; -- acyclic_point_replica

  FUNCTION acyclic_product_category_relationship(
               relation: product_category_relationship;
               children: SET OF product_category
      ): BOOLEAN;

    LOCAL
      x              : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;
    REPEAT i := 1 TO HIINDEX(children) BY 1;
      IF relation.category :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category,'SHIP_MOULDED_FORM_SCHEMA.' +
         'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x) BY 1;
        IF NOT acyclic_product_category_relationship(x[i],local_children)
             THEN
          RETURN(FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- acyclic_product_category_relationship

  FUNCTION acyclic_surface_replica(
               rep: surface_replica;
               parent: surface
      ): BOOLEAN;
    IF NOT ('SHIP_MOULDED_FORM_SCHEMA.SURFACE_REPLICA' IN TYPEOF(parent))
         THEN
      RETURN(TRUE);
    END_IF;
    IF parent :=: rep THEN
      RETURN(FALSE);
    ELSE
      RETURN(acyclic_surface_replica(rep,parent\surface_replica.
          parent_surface));
    END_IF;

  END_FUNCTION; -- acyclic_surface_replica

  FUNCTION associated_surface(
               arg: pcurve_or_surface
      ): surface;

    LOCAL
      surf : surface;
    END_LOCAL;
    IF 'SHIP_MOULDED_FORM_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
      surf := arg.basis_surface;
    ELSE
      surf := arg;
    END_IF;
    RETURN(surf);

  END_FUNCTION; -- associated_surface

  FUNCTION bag_to_set(
               the_bag: BAG OF GENERIC:intype
      ): SET OF GENERIC:intype;

    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;
    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag) BY 1;
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN(the_set);

  END_FUNCTION; -- bag_to_set

  FUNCTION base_axis(
               dim: INTEGER;
               axis1, axis2, axis3: direction
      ): LIST [2:3] OF direction;

    LOCAL
      u      : LIST [2:3] OF direction;
      d1     : direction;
      d2     : direction;
      factor : REAL;
    END_LOCAL;
    IF dim = 3 THEN
      d1 := NVL(normalise(axis3),dummy_gri || direction([0,0,1]));
      d2 := first_proj_axis(d1,axis1);
      u := [d2,second_proj_axis(d1,d2,axis2),d1];
    ELSE
      IF EXISTS(axis1) THEN
        d1 := normalise(axis1);
        u := [d1,orthogonal_complement(d1)];
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF factor < 0 THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          d1 := normalise(axis2);
          u := [orthogonal_complement(d1),d1];
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u := [dummy_gri || direction([1,0]),dummy_gri || direction([0,1])];
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);

  END_FUNCTION; -- base_axis

  FUNCTION boolean_choose(
               b: BOOLEAN;
               choice1: GENERIC:item;
               choice2: GENERIC:item
      ): GENERIC:item;
    IF b THEN
      RETURN(choice1);
    ELSE
      RETURN(choice2);
    END_IF;

  END_FUNCTION; -- boolean_choose

  FUNCTION build_2axes(
               ref_direction: direction
      ): LIST [2:2] OF direction;

    LOCAL
      d : direction := NVL(normalise(ref_direction),dummy_gri || 
           direction([1,0]));
    END_LOCAL;
    RETURN([d,orthogonal_complement(d)]);

  END_FUNCTION; -- build_2axes

  FUNCTION build_axes(
               axis, ref_direction: direction
      ): LIST [3:3] OF direction;

    LOCAL
      d1 : direction;
      d2 : direction;
    END_LOCAL;
    d1 := NVL(normalise(axis),dummy_gri || direction([0,0,1]));
    d2 := first_proj_axis(d1,ref_direction);
    RETURN([d2,normalise(cross_product(d1,d2)).orientation,d1]);

  END_FUNCTION; -- build_axes

  FUNCTION closed_shell_reversed(
               a_shell: closed_shell
      ): oriented_closed_shell;

    LOCAL
      the_reverse : oriented_closed_shell;
    END_LOCAL;
    IF 'SHIP_MOULDED_FORM_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell\oriented_closed_shell.
          closed_shell_element,NOT a_shell\oriented_closed_shell.
          orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || closed_shell() || 
          oriented_closed_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- closed_shell_reversed

  FUNCTION conditional_reverse(
               p: BOOLEAN;
               an_item: reversible_topology
      ): reversible_topology;
    IF p THEN
      RETURN(an_item);
    ELSE
      RETURN(topology_reversed(an_item));
    END_IF;

  END_FUNCTION; -- conditional_reverse

  FUNCTION constraints_composite_curve_on_surface(
               c: composite_curve_on_surface
      ): BOOLEAN;

    LOCAL
      n_segments : INTEGER := SIZEOF(c.segments);
    END_LOCAL;
    REPEAT k := 1 TO n_segments BY 1;
      IF (NOT ('SHIP_MOULDED_FORM_SCHEMA.PCURVE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) AND (NOT (
          'SHIP_MOULDED_FORM_SCHEMA.SURFACE_CURVE' IN TYPEOF(c\
          composite_curve.segments[k].parent_curve))) AND (NOT (
          'SHIP_MOULDED_FORM_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c
          \composite_curve.segments[k].parent_curve))) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);

  END_FUNCTION; -- constraints_composite_curve_on_surface

  FUNCTION constraints_param_b_spline(
               degree: INTEGER;
               up_knots: INTEGER;
               up_cp: INTEGER;
               knot_mult: LIST OF INTEGER;
               knots: LIST OF parameter_value
      ): BOOLEAN;

    LOCAL
      k      : INTEGER;
      sum    : INTEGER;
      result : BOOLEAN := TRUE;
    END_LOCAL;
    sum := knot_mult[1];
    REPEAT i := 2 TO up_knots BY 1;
      sum := sum + knot_mult[i];
    END_REPEAT;
    IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (
        degree + up_cp + 2)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    k := knot_mult[1];
    IF (k < 1) OR (k > (degree + 1)) THEN
      result := FALSE;
      RETURN(result);
    END_IF;
    REPEAT i := 2 TO up_knots BY 1;
      IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      k := knot_mult[i];
      IF (i < up_knots) AND (k > degree) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
      IF (i = up_knots) AND (k > (degree + 1)) THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- constraints_param_b_spline

  FUNCTION cross_product(
               arg1, arg2: direction
      ): vector;

    LOCAL
      v2     : LIST [3:3] OF REAL;
      v1     : LIST [3:3] OF REAL;
      mag    : REAL;
      res    : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (arg1.dim = 2) OR (NOT EXISTS(arg2)) OR (arg2
        .dim = 2) THEN
      RETURN(?);
    ELSE
      BEGIN
        v1 := normalise(arg1).direction_ratios;
        v2 := normalise(arg2).direction_ratios;
        res := dummy_gri || direction([(v1[2] * v2[3]) - (v1[3] * v2[2]),(
            v1[3] * v2[1]) - (v1[1] * v2[3]),(v1[1] * v2[2]) - (v1[2] * v2[
            1])]);
        mag := 0;
        REPEAT i := 1 TO 3 BY 1;
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(arg1,0);
        END_IF;
        RETURN(result);
      END;
    END_IF;

  END_FUNCTION; -- cross_product

  FUNCTION curve_weights_positive(
               b: rational_b_spline_curve
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
      IF b.weights[i] <= 0 THEN
        result := FALSE;
        RETURN(result);
      END_IF;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- curve_weights_positive

  FUNCTION derive_dimensional_exponents(
               x: unit
      ): dimensional_exponents;

    LOCAL
      result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
                0);
    END_LOCAL;
    IF 'SHIP_MOULDED_FORM_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements) BY 1;
        result.length_exponent := result.length_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].
            exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.
            electric_current_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.
            thermodynamic_temperature_exponent + (x.elements[i].exponent * 
            x.elements[i].unit.dimensions.
            thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.
            amount_of_substance_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.
            luminous_intensity_exponent + (x.elements[i].exponent * x.
            elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- derive_dimensional_exponents

  FUNCTION dimension_of(
               item: geometric_representation_item
      ): dimension_count;

    LOCAL
      x   : SET OF representation;
      y   : representation_context;
      dim : dimension_count;
    END_LOCAL;
    IF 'SHIP_MOULDED_FORM_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
      dim := SIZEOF(item\cartesian_point.coordinates);
      RETURN(dim);
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
      dim := SIZEOF(item\direction.direction_ratios);
      RETURN(dim);
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.VECTOR' IN TYPEOF(item) THEN
      dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
      RETURN(dim);
    END_IF;
    x := using_representations(item);
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN(dim);

  END_FUNCTION; -- dimension_of

  FUNCTION dimensions_for_si_unit(
               n: si_unit_name
      ): dimensional_exponents;
    CASE n OF
      metre         :         RETURN(dimensional_exponents(1,0,0,0,0,0,0));
      gram          :         RETURN(dimensional_exponents(0,1,0,0,0,0,0));
      second        :         RETURN(dimensional_exponents(0,0,1,0,0,0,0));
      ampere        :         RETURN(dimensional_exponents(0,0,0,1,0,0,0));
      kelvin        :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      mole          :         RETURN(dimensional_exponents(0,0,0,0,0,1,0));
      candela       :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      radian        :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      steradian     :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
      hertz         :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      newton        :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
      pascal        :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
      joule         :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
      watt          :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
      coulomb       :         RETURN(dimensional_exponents(0,0,1,1,0,0,0));
      volt          :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
      farad         :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
      ohm           :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
      siemens       :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
      weber         :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
      tesla         :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
      henry         :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
      degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
      lumen         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
      lux           :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
      becquerel     :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
      gray          :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      sievert       :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
      OTHERWISE     :         RETURN(?);
      END_CASE;

  END_FUNCTION; -- dimensions_for_si_unit

  FUNCTION dot_product(
               arg1, arg2: direction
      ): REAL;

    LOCAL
      ndim   : INTEGER;
      scalar : REAL;
      vec1   : direction;
      vec2   : direction;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
      scalar := ?;
    ELSE
      IF arg1.dim <> arg2.dim THEN
        scalar := ?;
      ELSE
        BEGIN
          vec1 := normalise(arg1);
          vec2 := normalise(arg2);
          ndim := arg1.dim;
          scalar := 0;
          REPEAT i := 1 TO ndim BY 1;
            scalar := scalar + (vec1.direction_ratios[i] * vec2.
                direction_ratios[i]);
          END_REPEAT;
        END;
      END_IF;
    END_IF;
    RETURN(scalar);

  END_FUNCTION; -- dot_product

  FUNCTION edge_reversed(
               an_edge: edge
      ): oriented_edge;

    LOCAL
      the_reverse : oriented_edge;
    END_LOCAL;
    IF 'SHIP_MOULDED_FORM_SCHEMA.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge\oriented_edge.edge_element,NOT an_edge\
          oriented_edge.orientation);
    ELSE
      the_reverse := dummy_tri || edge(an_edge.edge_end,an_edge.edge_start) 
          || oriented_edge(an_edge,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- edge_reversed

  FUNCTION face_bound_reversed(
               a_face_bound: face_bound
      ): face_bound;

    LOCAL
      the_reverse : face_bound;
    END_LOCAL;
    IF 'SHIP_MOULDED_FORM_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)
         THEN
      the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound,
          NOT a_face_bound\face_bound.orientation) || face_outer_bound();
    ELSE
      the_reverse := dummy_tri || face_bound(a_face_bound.bound,NOT 
          a_face_bound.orientation);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_bound_reversed

  FUNCTION face_reversed(
               a_face: face
      ): oriented_face;

    LOCAL
      the_reverse : oriented_face;
    END_LOCAL;
    IF 'SHIP_MOULDED_FORM_SCHEMA.ORIENTED_FACE' IN TYPEOF(a_face) THEN
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face\oriented_face.face_element,NOT 
          a_face\oriented_face.orientation);
    ELSE
      the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.
          bounds)) || oriented_face(a_face,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- face_reversed

  FUNCTION first_proj_axis(
               z_axis, arg: direction
      ): direction;

    LOCAL
      x_vec  : vector;
      v      : direction;
      z      : direction;
      x_axis : direction;
    END_LOCAL;
    IF NOT EXISTS(z_axis) THEN
      RETURN(?);
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF z.direction_ratios <> [1,0,0] THEN
          v := dummy_gri || direction([1,0,0]);
        ELSE
          v := dummy_gri || direction([0,1,0]);
        END_IF;
      ELSE
        IF arg.dim <> 3 THEN
          RETURN(?);
        END_IF;
        IF cross_product(arg,z).magnitude = 0 THEN
          RETURN(?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v,z),z);
      x_axis := vector_difference(v,x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);

  END_FUNCTION; -- first_proj_axis

  FUNCTION get_basis_surface(
               c: curve_on_surface
      ): SET [0:2] OF surface;

    LOCAL
      surfs : SET [0:2] OF surface;
      n     : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'SHIP_MOULDED_FORM_SCHEMA.PCURVE' IN TYPEOF(c) THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'SHIP_MOULDED_FORM_SCHEMA.SURFACE_CURVE' IN TYPEOF(c) THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n BY 1;
          surfs := surfs + associated_surface(c\surface_curve.
              associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
         THEN
      n := SIZEOF(c\composite_curve.segments);
      surfs := get_basis_surface(c\composite_curve.segments[1].
          parent_curve);
      IF n > 1 THEN
        REPEAT i := 2 TO n BY 1;
          surfs := surfs * get_basis_surface(c\composite_curve.segments[i]
              .parent_curve);
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(surfs);

  END_FUNCTION; -- get_basis_surface

  FUNCTION get_description_value(
               obj: description_attribute_select
      ): text;

    LOCAL
      description_bag : BAG OF description_attribute := USEDIN(obj,
                         'SHIP_MOULDED_FORM_SCHEMA.' + 
                         'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM');
    END_LOCAL;
    IF SIZEOF(description_bag) = 1 THEN
      RETURN(description_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_description_value

  FUNCTION get_id_value(
               obj: id_attribute_select
      ): identifier;

    LOCAL
      id_bag : BAG OF id_attribute := USEDIN(obj,
                'SHIP_MOULDED_FORM_SCHEMA.' + 'ID_ATTRIBUTE.' + 
                'IDENTIFIED_ITEM');
    END_LOCAL;
    IF SIZEOF(id_bag) = 1 THEN
      RETURN(id_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_id_value

  FUNCTION get_name_value(
               obj: name_attribute_select
      ): label;

    LOCAL
      name_bag : BAG OF name_attribute := USEDIN(obj,
                  'SHIP_MOULDED_FORM_SCHEMA.' + 'NAME_ATTRIBUTE.' + 
                  'NAMED_ITEM');
    END_LOCAL;
    IF SIZEOF(name_bag) = 1 THEN
      RETURN(name_bag[1].attribute_value);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_name_value

  FUNCTION get_role(
               obj: role_select
      ): object_role;

    LOCAL
      role_bag : BAG OF role_association := USEDIN(obj,
                  'SHIP_MOULDED_FORM_SCHEMA.' + 'ROLE_ASSOCIATION.' + 
                  'ITEM_WITH_ROLE');
    END_LOCAL;
    IF SIZEOF(role_bag) = 1 THEN
      RETURN(role_bag[1].role);
    ELSE
      RETURN(?);
    END_IF;

  END_FUNCTION; -- get_role

  FUNCTION item_in_context(
               item: representation_item;
               cntxt: representation_context
      ): BOOLEAN;

    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    IF SIZEOF(USEDIN(item,'SHIP_MOULDED_FORM_SCHEMA.REPRESENTATION.ITEMS') 
        * cntxt.representations_in_context) > 0 THEN
      RETURN(TRUE);
    ELSE
      y := QUERY ( z <* USEDIN(item,'') | (
          'SHIP_MOULDED_FORM_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) );
      IF SIZEOF(y) > 0 THEN
        REPEAT i := 1 TO HIINDEX(y) BY 1;
          IF item_in_context(y[i],cntxt) THEN
            RETURN(TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- item_in_context

  FUNCTION leap_year(
               year: year_number
      ): BOOLEAN;
    IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
         0) THEN
      RETURN(TRUE);
    ELSE
      RETURN(FALSE);
    END_IF;

  END_FUNCTION; -- leap_year

  FUNCTION list_face_loops(
               f: face
      ): LIST [0:?] OF loop;

    LOCAL
      loops : LIST [0:?] OF loop := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
      loops := loops + f.bounds[i].bound;
    END_REPEAT;
    RETURN(loops);

  END_FUNCTION; -- list_face_loops

  FUNCTION list_of_topology_reversed(
               a_list: list_of_reversible_topology_item
      ): list_of_reversible_topology_item;

    LOCAL
      the_reverse : list_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_list) BY 1;
      the_reverse := topology_reversed(a_list[i]) + the_reverse;
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- list_of_topology_reversed

  FUNCTION list_to_array(
               lis: LIST [0:?] OF GENERIC:t;
               low: INTEGER;
               u: INTEGER
      ): ARRAY OF GENERIC:t;

    LOCAL
      n   : INTEGER;
      res : ARRAY [low:u] OF GENERIC:t;
    END_LOCAL;
    n := SIZEOF(lis);
    IF n <> ((u - low) + 1) THEN
      RETURN(?);
    ELSE
      res := [lis[1]];
      REPEAT i := 2 TO n BY 1;
        res[(low + i) - 1] := lis[i];
      END_REPEAT;
      RETURN(res);
    END_IF;

  END_FUNCTION; -- list_to_array

  FUNCTION list_to_set(
               l: LIST [0:?] OF GENERIC:t
      ): SET OF GENERIC:t;

    LOCAL
      s : SET OF GENERIC:t := [];
    END_LOCAL;
    REPEAT i := 1 TO SIZEOF(l) BY 1;
      s := s + l[i];
    END_REPEAT;
    RETURN(s);

  END_FUNCTION; -- list_to_set

  FUNCTION make_array_of_array(
               lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;
               low1: INTEGER;
               u1: INTEGER;
               low2: INTEGER;
               u2: INTEGER
      ): ARRAY OF ARRAY OF GENERIC:t;

    LOCAL
      res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
    END_LOCAL;
    IF ((u1 - low1) + 1) <> SIZEOF(lis) THEN
      RETURN(?);
    END_IF;
    IF ((u2 - low2) + 1) <> SIZEOF(lis[1]) THEN
      RETURN(?);
    END_IF;
    res := [list_to_array(lis[1],low2,u2)];
    REPEAT i := 2 TO HIINDEX(lis) BY 1;
      IF ((u2 - low2) + 1) <> SIZEOF(lis[i]) THEN
        RETURN(?);
      END_IF;
      res[(low1 + i) - 1] := list_to_array(lis[i],low2,u2);
    END_REPEAT;
    RETURN(res);

  END_FUNCTION; -- make_array_of_array

  FUNCTION mixed_loop_type_set(
               l: SET [0:?] OF loop
      ): LOGICAL;

    LOCAL
      poly_loop_type : LOGICAL;
    END_LOCAL;
    IF SIZEOF(l) <= 1 THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := 'SHIP_MOULDED_FORM_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]);
    REPEAT i := 2 TO SIZEOF(l) BY 1;
      IF ('SHIP_MOULDED_FORM_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> 
          poly_loop_type THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
    RETURN(FALSE);

  END_FUNCTION; -- mixed_loop_type_set

  FUNCTION nmsf_curve_check(
               cv: representation_item
      ): BOOLEAN;
    IF SIZEOF(['SHIP_MOULDED_FORM_SCHEMA.BOUNDED_CURVE',
        'SHIP_MOULDED_FORM_SCHEMA.CONIC',
        'SHIP_MOULDED_FORM_SCHEMA.CURVE_REPLICA',
        'SHIP_MOULDED_FORM_SCHEMA.LINE',
        'SHIP_MOULDED_FORM_SCHEMA.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
      RETURN(FALSE);
    ELSE
      IF (('SHIP_MOULDED_FORM_SCHEMA.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (
          cv\b_spline_curve.self_intersect = FALSE)) OR (cv\b_spline_curve.
          self_intersect = UNKNOWN) THEN
        RETURN(TRUE);
      ELSE
        IF SIZEOF(['SHIP_MOULDED_FORM_SCHEMA.CONIC',
            'SHIP_MOULDED_FORM_SCHEMA.LINE'] * TYPEOF(cv)) = 1 THEN
          RETURN(TRUE);
        ELSE
          IF 'SHIP_MOULDED_FORM_SCHEMA.CURVE_REPLICA' IN TYPEOF(cv) THEN
            RETURN(nmsf_curve_check(cv\curve_replica.parent_curve));
          ELSE
            IF ('SHIP_MOULDED_FORM_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF(cv)) 
                AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\
                offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT (
                'SHIP_MOULDED_FORM_SCHEMA.POLYLINE' IN TYPEOF(cv\
                offset_curve_3d.basis_curve))) THEN
              RETURN(nmsf_curve_check(cv\offset_curve_3d.basis_curve));
            ELSE
              IF 'SHIP_MOULDED_FORM_SCHEMA.PCURVE' IN TYPEOF(cv) THEN
                RETURN(nmsf_curve_check(cv\pcurve.reference_to_curve\
                    representation.items[1]) AND nmsf_surface_check(cv\
                    pcurve.basis_surface));
              ELSE
                IF 'SHIP_MOULDED_FORM_SCHEMA.SURFACE_CURVE' IN TYPEOF(cv)
                     THEN
                  IF nmsf_curve_check(cv\surface_curve.curve_3d) THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.
                        associated_geometry) BY 1;
                      IF 'SHIP_MOULDED_FORM_SCHEMA.SURFACE' IN TYPEOF(cv\
                          surface_curve.associated_geometry[i]) THEN
                        IF NOT nmsf_surface_check(cv\surface_curve.
                            associated_geometry[i]) THEN
                          RETURN(FALSE);
                        END_IF;
                      ELSE
                        IF 'SHIP_MOULDED_FORM_SCHEMA.PCURVE' IN TYPEOF(cv\
                            surface_curve.associated_geometry[i]) THEN
                          IF NOT nmsf_curve_check(cv\surface_curve.
                              associated_geometry[i]) THEN
                            RETURN(FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN(TRUE);
                  END_IF;
                ELSE
                  IF 'SHIP_MOULDED_FORM_SCHEMA.POLYLINE' IN TYPEOF(cv)
                       THEN
                    IF SIZEOF(cv\polyline.points) >= 3 THEN
                      RETURN(TRUE);
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- nmsf_curve_check

  FUNCTION nmsf_surface_check(
               surf: surface
      ): BOOLEAN;
    IF 'SHIP_MOULDED_FORM_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
      RETURN(TRUE);
    ELSE
      IF 'SHIP_MOULDED_FORM_SCHEMA.SWEPT_SURFACE' IN TYPEOF(surf) THEN
        RETURN(nmsf_curve_check(surf\swept_surface.swept_curve));
      ELSE
        IF (('SHIP_MOULDED_FORM_SCHEMA.OFFSET_SURFACE' IN TYPEOF(surf)) 
            AND (surf\offset_surface.self_intersect = FALSE)) OR (surf\
            offset_surface.self_intersect = UNKNOWN) THEN
          RETURN(nmsf_surface_check(surf\offset_surface.basis_surface));
        ELSE
          IF 'SHIP_MOULDED_FORM_SCHEMA.SURFACE_REPLICA' IN TYPEOF(surf)
               THEN
            RETURN(nmsf_surface_check(surf\surface_replica.parent_surface));
          ELSE
            IF (('SHIP_MOULDED_FORM_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(
                surf)) AND (surf\b_spline_surface.self_intersect = FALSE)) 
                OR (surf\b_spline_surface.self_intersect = UNKNOWN) THEN
              RETURN(TRUE);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- nmsf_surface_check

  FUNCTION normalise(
               arg: vector_or_direction
      ): vector_or_direction;

    LOCAL
      ndim   : INTEGER;
      v      : direction;
      vec    : vector;
      mag    : REAL;
      result : vector_or_direction;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      result := ?;
    ELSE
      ndim := arg.dim;
      IF 'SHIP_MOULDED_FORM_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
          v := dummy_gri || direction(arg.orientation.direction_ratios);
          IF arg.magnitude = 0 THEN
            RETURN(?);
          ELSE
            vec := dummy_gri || vector(v,1);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction(arg.direction_ratios);
      END_IF;
      mag := 0;
      REPEAT i := 1 TO ndim BY 1;
        mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
      END_REPEAT;
      IF mag > 0 THEN
        mag := SQRT(mag);
        REPEAT i := 1 TO ndim BY 1;
          v.direction_ratios[i] := v.direction_ratios[i] / mag;
        END_REPEAT;
        IF 'SHIP_MOULDED_FORM_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- normalise

  FUNCTION open_shell_reversed(
               a_shell: open_shell
      ): oriented_open_shell;

    LOCAL
      the_reverse : oriented_open_shell;
    END_LOCAL;
    IF 'SHIP_MOULDED_FORM_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell\oriented_open_shell.
          open_shell_element,NOT a_shell\oriented_open_shell.orientation);
    ELSE
      the_reverse := dummy_tri || connected_face_set(a_shell\
          connected_face_set.cfs_faces) || open_shell() || 
          oriented_open_shell(a_shell,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- open_shell_reversed

  FUNCTION orthogonal_complement(
               vec: direction
      ): direction;

    LOCAL
      result : direction;
    END_LOCAL;
    IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      result := dummy_gri || direction([-vec.direction_ratios[2],vec.
          direction_ratios[1]]);
      RETURN(result);
    END_IF;

  END_FUNCTION; -- orthogonal_complement

  FUNCTION path_head_to_tail(
               a_path: path
      ): BOOLEAN;

    LOCAL
      n : INTEGER;
      p : BOOLEAN := TRUE;
    END_LOCAL;
    n := SIZEOF(a_path.edge_list);
    REPEAT i := 2 TO n BY 1;
      p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
          .edge_start);
    END_REPEAT;
    RETURN(p);

  END_FUNCTION; -- path_head_to_tail

  FUNCTION path_reversed(
               a_path: path
      ): oriented_path;

    LOCAL
      the_reverse : oriented_path;
    END_LOCAL;
    IF 'SHIP_MOULDED_FORM_SCHEMA.ORIENTED_PATH' IN TYPEOF(a_path) THEN
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path\oriented_path.path_element,
          NOT a_path\oriented_path.orientation);
    ELSE
      the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.
          edge_list)) || oriented_path(a_path,FALSE);
    END_IF;
    RETURN(the_reverse);

  END_FUNCTION; -- path_reversed

  FUNCTION scalar_times_vector(
               scalar: REAL;
               vec: vector_or_direction
      ): vector;

    LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
      RETURN(?);
    ELSE
      IF 'SHIP_MOULDED_FORM_SCHEMA.VECTOR' IN TYPEOF(vec) THEN
        v := dummy_gri || direction(vec.orientation.direction_ratios);
        mag := scalar * vec.magnitude;
      ELSE
        v := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF mag < 0 THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v),mag);
    END_IF;
    RETURN(result);

  END_FUNCTION; -- scalar_times_vector

  FUNCTION second_proj_axis(
               z_axis, x_axis, arg: direction
      ): direction;

    LOCAL
      temp   : vector;
      v      : direction;
      y_axis : vector;
    END_LOCAL;
    IF NOT EXISTS(arg) THEN
      v := dummy_gri || direction([0,1,0]);
    ELSE
      v := arg;
    END_IF;
    temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
    y_axis := vector_difference(v,temp);
    temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
    y_axis := vector_difference(y_axis,temp);
    y_axis := normalise(y_axis);
    RETURN(y_axis.orientation);

  END_FUNCTION; -- second_proj_axis

  FUNCTION set_of_topology_reversed(
               a_set: set_of_reversible_topology_item
      ): set_of_reversible_topology_item;

    LOCAL
      the_reverse : set_of_reversible_topology_item;
    END_LOCAL;
    the_reverse := [];
    REPEAT i := 1 TO SIZEOF(a_set) BY 1;
      the_reverse := the_reverse + topology_reversed(a_set[i]);
    END_REPEAT;
    RETURN(the_reverse);

  END_FUNCTION; -- set_of_topology_reversed

  FUNCTION shell_reversed(
               a_shell: shell
      ): shell;
    IF 'SHIP_MOULDED_FORM_SCHEMA.OPEN_SHELL' IN TYPEOF(a_shell) THEN
      RETURN(open_shell_reversed(a_shell));
    ELSE
      IF 'SHIP_MOULDED_FORM_SCHEMA.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
        RETURN(closed_shell_reversed(a_shell));
      ELSE
        RETURN(?);
      END_IF;
    END_IF;

  END_FUNCTION; -- shell_reversed

  FUNCTION surface_weights_positive(
               b: rational_b_spline_surface
      ): BOOLEAN;

    LOCAL
      result : BOOLEAN := TRUE;
    END_LOCAL;
    REPEAT i := 0 TO b.u_upper BY 1;
      REPEAT j := 0 TO b.v_upper BY 1;
        IF b.weights[i][j] <= 0 THEN
          result := FALSE;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(result);

  END_FUNCTION; -- surface_weights_positive

  FUNCTION topology_reversed(
               an_item: reversible_topology
      ): reversible_topology;
    IF 'SHIP_MOULDED_FORM_SCHEMA.EDGE' IN TYPEOF(an_item) THEN
      RETURN(edge_reversed(an_item));
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.PATH' IN TYPEOF(an_item) THEN
      RETURN(path_reversed(an_item));
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.FACE_BOUND' IN TYPEOF(an_item) THEN
      RETURN(face_bound_reversed(an_item));
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.FACE' IN TYPEOF(an_item) THEN
      RETURN(face_reversed(an_item));
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.SHELL' IN TYPEOF(an_item) THEN
      RETURN(shell_reversed(an_item));
    END_IF;
    IF 'SET' IN TYPEOF(an_item) THEN
      RETURN(set_of_topology_reversed(an_item));
    END_IF;
    IF 'LIST' IN TYPEOF(an_item) THEN
      RETURN(list_of_topology_reversed(an_item));
    END_IF;
    RETURN(?);

  END_FUNCTION; -- topology_reversed

  FUNCTION using_items(
               item: founded_item_select;
               checked_items: SET OF founded_item_select
      ): SET OF founded_item_select;

    LOCAL
      next_items      : SET OF founded_item_select;
      new_check_items : SET OF founded_item_select;
      result_items    : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    next_items := QUERY ( z <* bag_to_set(USEDIN(item,'')) | ((
        'SHIP_MOULDED_FORM_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR (
        'SHIP_MOULDED_FORM_SCHEMA.FOUNDED_ITEM' IN TYPEOF(z))) );
    IF SIZEOF(next_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(next_items) BY 1;
        IF NOT (next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] + using_items(
              next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result_items);

  END_FUNCTION; -- using_items

  FUNCTION using_representations(
               item: founded_item_select
      ): SET OF representation;

    LOCAL
      results            : SET OF representation;
      intermediate_items : SET OF founded_item_select;
      result_bag         : BAG OF representation;
    END_LOCAL;
    results := [];
    result_bag := USEDIN(item,
        'SHIP_MOULDED_FORM_SCHEMA.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag) BY 1;
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    intermediate_items := using_items(item,[]);
    IF SIZEOF(intermediate_items) > 0 THEN
      REPEAT i := 1 TO HIINDEX(intermediate_items) BY 1;
        result_bag := USEDIN(intermediate_items[i],
            'SHIP_MOULDED_FORM_SCHEMA.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag) BY 1;
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(results);

  END_FUNCTION; -- using_representations

  FUNCTION valid_calendar_date(
               date: calendar_date
      ): LOGICAL;
    CASE date.month_component OF
      1 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      2 :         BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND (date.day_component <= 28));
          END_IF;
        END;
      3 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      4 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      5 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      6 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      7 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      8 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 31));
      9 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      10  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      11  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      12  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 31));
      END_CASE;
    RETURN(FALSE);

  END_FUNCTION; -- valid_calendar_date

  FUNCTION valid_measure_value(
               m: measure_value
      ): BOOLEAN;
    IF 'REAL' IN TYPEOF(m) THEN
      RETURN(m > 0);
    ELSE
      IF 'INTEGER' IN TYPEOF(m) THEN
        RETURN(m > 0);
      ELSE
        RETURN(TRUE);
      END_IF;
    END_IF;

  END_FUNCTION; -- valid_measure_value

  FUNCTION valid_time(
               time: local_time
      ): BOOLEAN;
    IF EXISTS(time.second_component) THEN
      RETURN(EXISTS(time.minute_component));
    ELSE
      RETURN(TRUE);
    END_IF;

  END_FUNCTION; -- valid_time

  FUNCTION valid_units(
               m: measure_with_unit
      ): BOOLEAN;
    IF 'SHIP_MOULDED_FORM_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,1,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,1,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,1,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN 
        TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,1,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,1,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,1) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component)
         THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(2,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(3,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.RATIO_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
        value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(1,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    IF 'SHIP_MOULDED_FORM_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m
        .value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
          dimensional_exponents(0,0,0,0,0,0,0) THEN
        RETURN(FALSE);
      END_IF;
    END_IF;
    RETURN(TRUE);

  END_FUNCTION; -- valid_units

  FUNCTION valid_wireframe_edge_curve(
               crv: curve
      ): BOOLEAN;
    IF SIZEOF(['SHIP_MOULDED_FORM_SCHEMA.LINE',
        'SHIP_MOULDED_FORM_SCHEMA.CONIC',
        'SHIP_MOULDED_FORM_SCHEMA.B_SPLINE_CURVE',
        'SHIP_MOULDED_FORM_SCHEMA.POLYLINE'] * TYPEOF(crv)) = 1 THEN
      RETURN(TRUE);
    ELSE
      IF 'SHIP_MOULDED_FORM_SCHEMA.CURVE_REPLICA' IN TYPEOF(crv) THEN
        RETURN(valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
      ELSE
        IF 'SHIP_MOULDED_FORM_SCHEMA.OFFSET_CURVE_3D' IN TYPEOF(crv) THEN
          RETURN(valid_wireframe_edge_curve(crv\offset_curve_3d.
              basis_curve));
        END_IF;
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_wireframe_edge_curve

  FUNCTION valid_wireframe_vertex_point(
               pnt: point
      ): BOOLEAN;
    IF 'SHIP_MOULDED_FORM_SCHEMA.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
      RETURN(TRUE);
    ELSE
      IF 'SHIP_MOULDED_FORM_SCHEMA.POINT_REPLICA' IN TYPEOF(pnt) THEN
        RETURN(valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
      END_IF;
    END_IF;
    RETURN(FALSE);

  END_FUNCTION; -- valid_wireframe_vertex_point

  FUNCTION vector_difference(
               arg1, arg2: vector_or_direction
      ): vector;

    LOCAL
      ndim   : INTEGER;
      mag2   : REAL;
      mag1   : REAL;
      mag    : REAL;
      res    : direction;
      vec1   : direction;
      vec2   : direction;
      result : vector;
    END_LOCAL;
    IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) OR (arg1.dim <> arg2.dim)
         THEN
      RETURN(?);
    ELSE
      BEGIN
        IF 'SHIP_MOULDED_FORM_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1.orientation;
        ELSE
          mag1 := 1;
          vec1 := arg1;
        END_IF;
        IF 'SHIP_MOULDED_FORM_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2.magnitude;
          vec2 := arg2.orientation;
        ELSE
          mag2 := 1;
          vec2 := arg2;
        END_IF;
        vec1 := normalise(vec1);
        vec2 := normalise(vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim BY 1;
          res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) + (
              mag2 * vec2.direction_ratios[i]);
          mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
        END_REPEAT;
        IF mag > 0 THEN
          result := dummy_gri || vector(res,SQRT(mag));
        ELSE
          result := dummy_gri || vector(vec1,0);
        END_IF;
      END;
    END_IF;
    RETURN(result);

  END_FUNCTION; -- vector_difference

  FUNCTION which_class(
               t: GENERIC
      ): LIST OF STRING;

    LOCAL
      class_list : LIST OF STRING := [];
      elements   : BAG OF applied_classification_assignment;
    END_LOCAL;
    elements := USEDIN(t,
        'SHIP_MOULDED_FORM_SCHEMA.APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS');
    REPEAT i := 1 TO HIINDEX(elements) BY 1;
      IF elements[i]\classification_assignment.role.name = 
          'class membership' THEN
        class_list := class_list + elements[i]\classification_assignment.
            assigned_class\group.name;
      END_IF;
    END_REPEAT;
    RETURN(class_list);

  END_FUNCTION; -- which_class

END_SCHEMA; -- ap216aim
