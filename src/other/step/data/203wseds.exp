(*

This EXPRESS schema is based on ISO 10303-203, an international
standard which is copyrighted by ISO. ISO has granted NIST permission
to publicly distribute the EXPRESS source from ISO standards. The
EXPRESS schema provided in this software release has been modified to
facilitate its use with this software and is provided as an example
schema only. This disclaimer must be included in any redistribution of
this EXPRESS schema.

*)

SCHEMA config_control_design;

TYPE ahead_or_behind = ENUMERATION OF
  (ahead,
   behind);
END_TYPE; -- ahead_or_behind

TYPE approved_item = SELECT
  (product_definition_formation,
   product_definition,
   configuration_effectivity,
   configuration_item,
   security_classification,
   change_request,
   change,
   start_request,
   start_work,
   certification,
   contract);
END_TYPE; -- approved_item

TYPE area_measure = REAL;
END_TYPE; -- area_measure

TYPE axis2_placement = SELECT
  (axis2_placement_2d,
   axis2_placement_3d);
END_TYPE; -- axis2_placement

TYPE b_spline_curve_form = ENUMERATION OF
  (elliptic_arc,
   polyline_form,
   parabolic_arc,
   circular_arc,
   unspecified,
   hyperbolic_arc);
END_TYPE; -- b_spline_curve_form

TYPE b_spline_surface_form = ENUMERATION OF
  (surf_of_linear_extrusion,
   plane_surf,
   generalised_cone,
   toroidal_surf,
   conical_surf,
   spherical_surf,
   unspecified,
   ruled_surf,
   surf_of_revolution,
   cylindrical_surf,
   quadric_surf);
END_TYPE; -- b_spline_surface_form

TYPE boolean_operand = SELECT
  (solid_model);
END_TYPE; -- boolean_operand

TYPE certified_item = SELECT
  (supplied_part_relationship);
END_TYPE; -- certified_item

TYPE change_request_item = SELECT
  (product_definition_formation);
END_TYPE; -- change_request_item

TYPE characterized_definition = SELECT
  (characterized_product_definition,
   shape_definition);
END_TYPE; -- characterized_definition

TYPE characterized_product_definition = SELECT
  (product_definition,
   product_definition_relationship);
END_TYPE; -- characterized_product_definition

TYPE classified_item = SELECT
  (product_definition_formation,
   assembly_component_usage);
END_TYPE; -- classified_item

TYPE context_dependent_measure = REAL;
END_TYPE; -- context_dependent_measure

TYPE contracted_item = SELECT
  (product_definition_formation);
END_TYPE; -- contracted_item

TYPE count_measure = NUMBER;
END_TYPE; -- count_measure

TYPE curve_on_surface = SELECT
  (pcurve,
   surface_curve,
   composite_curve_on_surface);
END_TYPE; -- curve_on_surface

TYPE date_time_item = SELECT
  (product_definition,
   change_request,
   start_request,
   change,
   start_work,
   approval_person_organization,
   contract,
   security_classification,
   certification);
END_TYPE; -- date_time_item

TYPE date_time_select = SELECT
  (date_and_time);
END_TYPE; -- date_time_select

TYPE day_in_month_number = INTEGER;
END_TYPE; -- day_in_month_number

TYPE day_in_week_number = INTEGER;
WHERE
  WR1: (1 <= SELF) AND (SELF <= 7);
END_TYPE; -- day_in_week_number

TYPE day_in_year_number = INTEGER;
END_TYPE; -- day_in_year_number

TYPE descriptive_measure = STRING;
END_TYPE; -- descriptive_measure

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE; -- dimension_count

TYPE geometric_set_select = SELECT
  (point,
   curve,
   surface);
END_TYPE; -- geometric_set_select

TYPE hour_in_day = INTEGER;
WHERE
  WR1: (0 <= SELF) AND (SELF < 24);
END_TYPE; -- hour_in_day

TYPE identifier = STRING;
END_TYPE; -- identifier

TYPE knot_type = ENUMERATION OF
  (uniform_knots,
   quasi_uniform_knots,
   piecewise_bezier_knots,
   unspecified);
END_TYPE; -- knot_type

TYPE label = STRING;
END_TYPE; -- label

TYPE length_measure = REAL;
END_TYPE; -- length_measure

TYPE list_of_reversible_topology_item = LIST [0:?] OF
            reversible_topology_item;
END_TYPE; -- list_of_reversible_topology_item

TYPE mass_measure = REAL;
END_TYPE; -- mass_measure

TYPE measure_value = SELECT
  (area_measure,
   context_dependent_measure,
   count_measure,
   descriptive_measure,
   length_measure,
   mass_measure,
   plane_angle_measure,
   parameter_value,
   positive_length_measure,
   positive_plane_angle_measure,
   solid_angle_measure,
   volume_measure);
END_TYPE; -- measure_value

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: (0 <= SELF) AND (SELF <= 59);
END_TYPE; -- minute_in_hour

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: (1 <= SELF) AND (SELF <= 12);
END_TYPE; -- month_in_year_number

TYPE parameter_value = REAL;
END_TYPE; -- parameter_value

TYPE pcurve_or_surface = SELECT
  (pcurve,
   surface);
END_TYPE; -- pcurve_or_surface

TYPE person_organization_item = SELECT
  (change,
   start_work,
   change_request,
   start_request,
   configuration_item,
   product,
   product_definition_formation,
   product_definition,
   contract,
   security_classification);
END_TYPE; -- person_organization_item

TYPE person_organization_select = SELECT
  (person_and_organization);
END_TYPE; -- person_organization_select

TYPE plane_angle_measure = REAL;
END_TYPE; -- plane_angle_measure

TYPE positive_length_measure = length_measure;
WHERE
  WR1: SELF > 0;
END_TYPE; -- positive_length_measure

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0;
END_TYPE; -- positive_plane_angle_measure

TYPE preferred_surface_curve_representation = ENUMERATION OF
  (pcurve_s2,
   pcurve_s1,
   curve_3d);
END_TYPE; -- preferred_surface_curve_representation

TYPE reversible_topology = SELECT
  (reversible_topology_item,
   list_of_reversible_topology_item,
   set_of_reversible_topology_item);
END_TYPE; -- reversible_topology

TYPE reversible_topology_item = SELECT
  (edge,
   path,
   face,
   face_bound,
   closed_shell,
   open_shell);
END_TYPE; -- reversible_topology_item

TYPE second_in_minute = REAL;
WHERE
  WR1: (0 <= SELF) AND (SELF < 60);
END_TYPE; -- second_in_minute

TYPE set_of_reversible_topology_item = SET [0:?] OF
            reversible_topology_item;
END_TYPE; -- set_of_reversible_topology_item

TYPE shape_definition = SELECT
  (product_definition_shape,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE; -- shape_definition

TYPE shell = SELECT
  (open_shell,
   closed_shell,
   vertex_shell,
   wire_shell);
END_TYPE; -- shell

TYPE si_prefix = ENUMERATION OF
  (exa,
   pico,
   mega,
   femto,
   atto,
   centi,
   nano,
   hecto,
   micro,
   tera,
   giga,
   milli,
   peta,
   deci,
   kilo,
   deca);
END_TYPE; -- si_prefix

TYPE si_unit_name = ENUMERATION OF
  (hertz,
   degree_celsius,
   siemens,
   sievert,
   lux,
   watt,
   ohm,
   second,
   becquerel,
   pascal,
   henry,
   tesla,
   volt,
   joule,
   kelvin,
   ampere,
   gram,
   steradian,
   mole,
   lumen,
   gray,
   candela,
   farad,
   radian,
   newton,
   metre,
   weber,
   coulomb);
END_TYPE; -- si_unit_name

TYPE solid_angle_measure = REAL;
END_TYPE; -- solid_angle_measure

TYPE source = ENUMERATION OF
  (bought,
   not_known,
   made);
END_TYPE; -- source

TYPE specified_item = SELECT
  (product_definition,
   shape_aspect);
END_TYPE; -- specified_item

TYPE start_request_item = SELECT
  (product_definition_formation);
END_TYPE; -- start_request_item

TYPE supported_item = SELECT
  (action_directive,
   action,
   action_method);
END_TYPE; -- supported_item

TYPE surface_model = SELECT
  (shell_based_surface_model);
END_TYPE; -- surface_model

TYPE text = STRING;
END_TYPE; -- text

TYPE transformation = SELECT
  (item_defined_transformation,
   functionally_defined_transformation);
END_TYPE; -- transformation

TYPE transition_code = ENUMERATION OF
  (discontinuous,
   cont_same_gradient_same_curvature,
   cont_same_gradient,
   continuous);
END_TYPE; -- transition_code

TYPE trimming_preference = ENUMERATION OF
  (parameter,
   unspecified,
   cartesian);
END_TYPE; -- trimming_preference

TYPE trimming_select = SELECT
  (cartesian_point,
   parameter_value);
END_TYPE; -- trimming_select

TYPE unit = SELECT
  (named_unit);
END_TYPE; -- unit

TYPE vector_or_direction = SELECT
  (vector,
   direction);
END_TYPE; -- vector_or_direction

TYPE volume_measure = REAL;
END_TYPE; -- volume_measure

TYPE week_in_year_number = INTEGER;
WHERE
  WR1: (1 <= SELF) AND (SELF <= 53);
END_TYPE; -- week_in_year_number

TYPE wireframe_model = SELECT
  (shell_based_wireframe_model,
   edge_based_wireframe_model);
END_TYPE; -- wireframe_model

TYPE work_item = SELECT
  (product_definition_formation);
END_TYPE; -- work_item

TYPE year_number = INTEGER;
END_TYPE; -- year_number

ENTITY action;
  name          : label;
  description   : text;
  chosen_method : action_method;
END_ENTITY; -- action

ENTITY action_assignment
  ABSTRACT SUPERTYPE;
  assigned_action : action;
END_ENTITY; -- action_assignment

ENTITY action_directive;
  name        : label;
  description : text;
  analysis    : text;
  comment     : text;
  requests    : SET [1:?] OF versioned_action_request;
END_ENTITY; -- action_directive

ENTITY action_method;
  name        : label;
  description : text;
  consequence : text;
  purpose     : text;
END_ENTITY; -- action_method

ENTITY action_request_assignment
  ABSTRACT SUPERTYPE;
  assigned_action_request : versioned_action_request;
END_ENTITY; -- action_request_assignment

ENTITY action_request_solution;
  method  : action_method;
  request : versioned_action_request;
END_ENTITY; -- action_request_solution

ENTITY action_request_status;
  status           : label;
  assigned_request : versioned_action_request;
END_ENTITY; -- action_request_status

ENTITY action_status;
  status          : label;
  assigned_action : executed_action;
END_ENTITY; -- action_status

ENTITY address;
  internal_location       : OPTIONAL label;
  street_number           : OPTIONAL label;
  street                  : OPTIONAL label;
  postal_box              : OPTIONAL label;
  town                    : OPTIONAL label;
  region                  : OPTIONAL label;
  postal_code             : OPTIONAL label;
  country                 : OPTIONAL label;
  facsimile_number        : OPTIONAL label;
  telephone_number        : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number            : OPTIONAL label;
WHERE
  WR1: EXISTS(internal_location)       OR
       EXISTS(street_number)           OR
       EXISTS(street)                  OR
       EXISTS(postal_box)              OR
       EXISTS(town)                    OR
       EXISTS(region)                  OR
       EXISTS(postal_code)             OR
       EXISTS(country)                 OR
       EXISTS(facsimile_number)        OR
       EXISTS(telephone_number)        OR
       EXISTS(electronic_mail_address) OR
       EXISTS(telex_number);
END_ENTITY; -- address

ENTITY advanced_brep_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1 : SIZEOF (QUERY (it <* SELF.items |
        NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP',
        'CONFIG_CONTROL_DESIGN.FACETED_BREP',
        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
        'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)))
        = 0;
  WR2 : SIZEOF (QUERY (it <* SELF.items |
        SIZEOF (['CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP',
        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
  WR3 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
        'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
        NOT (SIZEOF (QUERY (csh <*
        msb_shells(msb, 'CONFIG_CONTROL_DESIGN') |
        NOT (SIZEOF (QUERY(csf <* csh.cfs_faces |
        NOT('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF(csf)))) = 0
        ))) = 0))) = 0;
  WR4 : SIZEOF (QUERY (msb <* QUERY (it <* items |
        'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
        'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN
        TYPEOF (msb\manifold_solid_brep.outer))) = 0;
  WR5 : SIZEOF (QUERY (brv <* QUERY (it <* items |
        'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) |
        NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
        csh\oriented_closed_shell.orientation)) = 0))) = 0;
  WR6 : SIZEOF (QUERY (mi <*  QUERY (it <* items |
        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) |
        NOT ('CONFIG_CONTROL_DESIGN.ADVANCED_BREP_SHAPE_REPRESENTATION' IN
        TYPEOF(mi\mapped_item.mapping_source.mapped_representation)))) = 0;
END_ENTITY; -- advanced_brep_shape_representation

ENTITY advanced_face
  SUBTYPE OF (face_surface);
WHERE
  WR1: SIZEOF (['CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE',
       'CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE',
       'CONFIG_CONTROL_DESIGN.SWEPT_SURFACE'] *
       TYPEOF (face_geometry)) = 1;
  WR2: SIZEOF (QUERY (bnd <* bounds |
       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.EDGE_LOOP',
       'CONFIG_CONTROL_DESIGN.VERTEX_LOOP'] * TYPEOF (bnd)) = 1))) = 0;
  WR3: SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* bounds |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
       NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN
       TYPEOF (oe.edge_element)))) = 0))) = 0;
  WR4: SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* bounds |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
       NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (oe.edge_start))
       AND
       ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF (oe.edge_end)))))
       = 0))) = 0;
  WR5: SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* bounds |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.LINE',
       'CONFIG_CONTROL_DESIGN.CONIC',
       'CONFIG_CONTROL_DESIGN.POLYLINE',
       'CONFIG_CONTROL_DESIGN.PCURVE',
       'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] *
       TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1))) = 0))) = 0;
  WR6: SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* bounds |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
       NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN
       TYPEOF (elp_fbnds.bound)))) = 0;
  WR7: (NOT ('CONFIG_CONTROL_DESIGN.SWEPT_SURFACE' IN
       TYPEOF(face_geometry)))
       OR
       (SIZEOF(['CONFIG_CONTROL_DESIGN.LINE',
       'CONFIG_CONTROL_DESIGN.CONIC',
       'CONFIG_CONTROL_DESIGN.POLYLINE',
       'CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE'] *
       TYPEOF (face_geometry\swept_surface.swept_curve)) = 1);
  WR8: SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* bounds |
       'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN
       TYPEOF (vlp_fbnds.bound\vertex_loop.loop_vertex)) AND
       ('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN
       TYPEOF
       (vlp_fbnds.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry)
       )))) = 0;
END_ENTITY; -- advanced_face

ENTITY alternate_product_relationship;
  name        : label;
  description : text;
  alternate   : product;
  base        : product;
  basis       : text;
UNIQUE
  UR1 : alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY; -- alternate_product_relationship

ENTITY application_context;
  application : text;
INVERSE
  context_elements : SET [1:?] OF application_context_element FOR
                        frame_of_reference;
END_ENTITY; -- application_context

ENTITY application_context_element
  SUPERTYPE OF (ONEOF (product_context, product_definition_context,
  product_concept_context));
  name               : label;
  frame_of_reference : application_context;
END_ENTITY; -- application_context_element

ENTITY application_protocol_definition;
  status                                    : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year                 : year_number;
  application                               : application_context;
END_ENTITY; -- application_protocol_definition

ENTITY approval;
  status : approval_status;
  level  : label;
END_ENTITY; -- approval

ENTITY approval_assignment
ABSTRACT SUPERTYPE;
  assigned_approval : approval;
END_ENTITY; -- approval_assignment

ENTITY approval_date_time;
  date_time      : date_time_select;
  dated_approval : approval;
END_ENTITY; -- approval_date_time

ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role                : approval_role;
END_ENTITY; -- approval_person_organization

ENTITY approval_relationship;
  name              : label;
  description       : text;
  relating_approval : approval;
  related_approval  : approval;
END_ENTITY; -- approval_relationship

ENTITY approval_role;
  role : label;
END_ENTITY; -- approval_role

ENTITY approval_status;
  name : label;
END_ENTITY; -- approval_status

ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CONFIG_CONTROL_DESIGN.AREA_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- area_measure_with_unit

ENTITY area_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 2) AND
       (SELF\named_unit.dimensions.mass_exponent = 0) AND
       (SELF\named_unit.dimensions.time_exponent = 0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND
       (SELF\named_unit.dimensions.
       thermodynamic_temperature_exponent = 0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0);
END_ENTITY; -- area_unit

ENTITY assembly_component_usage
  SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence,
  specified_higher_usage_occurrence, promissory_usage_occurrence))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY; -- assembly_component_usage

ENTITY assembly_component_usage_substitute;
  name        : label;
  description : text;
  base        : assembly_component_usage;
  substitute  : assembly_component_usage;
UNIQUE
  UR1 : base, substitute;
WHERE
  WR1: base.relating_product_definition :=: substitute.
       relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY; -- assembly_component_usage_substitute

ENTITY axis1_placement
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
DERIVE
  z : direction := NVL(normalise(axis),direction([0,0,1]));
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY; -- axis1_placement

ENTITY axis2_placement_2d
  SUBTYPE OF (placement);
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST [2:2] OF direction := build_2axes(ref_direction);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY; -- axis2_placement_2d

ENTITY axis2_placement_3d
  SUBTYPE OF (placement);
  axis          : OPTIONAL direction;
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
WHERE
  WR1: SELF\placement.location.dim = 3;
  WR2: (NOT EXISTS(axis)) OR (axis.dim = 3);
  WR3: (NOT EXISTS(ref_direction)) OR (ref_direction.dim = 3);
  WR4: ((NOT EXISTS(axis)) OR (NOT EXISTS(ref_direction))) OR (
       cross_product(axis,ref_direction).magnitude > 0);
END_ENTITY; -- axis2_placement_3d

ENTITY b_spline_curve
  SUPERTYPE OF (ONEOF (uniform_curve, b_spline_curve_with_knots,
    quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve)
  SUBTYPE OF (bounded_curve);
  degree              : INTEGER;
  control_points_list : LIST [2:?] OF cartesian_point;
  curve_form          : b_spline_curve_form;
  closed_curve        : LOGICAL;
  self_intersect      : LOGICAL;
DERIVE
  upper_index_on_control_points : INTEGER := SIZEOF(
                                  control_points_list) - 1;
  control_points                : ARRAY [0:
                                  upper_index_on_control_points] OF
                                  cartesian_point := list_to_array(
                                  control_points_list,0,
                                  upper_index_on_control_points);
WHERE
  WR1: ('CONFIG_CONTROL_DESIGN.UNIFORM_CURVE' IN TYPEOF(SELF)) OR
       ('CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF)) OR
       ('CONFIG_CONTROL_DESIGN.BEZIER_CURVE' IN TYPEOF(SELF)) OR
       ('CONFIG_CONTROL_DESIGN.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY; -- b_spline_curve

ENTITY b_spline_curve_with_knots
  SUBTYPE OF (b_spline_curve);
  knot_multiplicities : LIST [2:?] OF INTEGER;
  knots               : LIST [2:?] OF parameter_value;
  knot_spec           : knot_type;
DERIVE
  upper_index_on_knots : INTEGER := SIZEOF(knots);
WHERE
  WR1: constraints_param_b_spline(degree,upper_index_on_knots,
       upper_index_on_control_points,knot_multiplicities,knots);
  WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY; -- b_spline_curve_with_knots

ENTITY b_spline_surface
  SUPERTYPE OF (ONEOF (b_spline_surface_with_knots, uniform_surface,
    quasi_uniform_surface, bezier_surface) ANDOR
    rational_b_spline_surface)
  SUBTYPE OF (bounded_surface);
  u_degree            : INTEGER;
  v_degree            : INTEGER;
  control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
  surface_form        : b_spline_surface_form;
  u_closed            : LOGICAL;
  v_closed            : LOGICAL;
  self_intersect      : LOGICAL;
DERIVE
  u_upper        : INTEGER := SIZEOF(control_points_list) - 1;
  v_upper        : INTEGER := SIZEOF(control_points_list[1]) - 1;
  control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF
                       cartesian_point := make_array_of_array(
                      control_points_list,0,u_upper,0,v_upper);
WHERE
  WR1: ('CONFIG_CONTROL_DESIGN.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
       ('CONFIG_CONTROL_DESIGN.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
       ('CONFIG_CONTROL_DESIGN.BEZIER_SURFACE' IN TYPEOF(SELF)) OR
       ('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY; -- b_spline_surface

ENTITY b_spline_surface_with_knots
  SUBTYPE OF (b_spline_surface);
  u_multiplicities : LIST [2:?] OF INTEGER;
  v_multiplicities : LIST [2:?] OF INTEGER;
  u_knots          : LIST [2:?] OF parameter_value;
  v_knots          : LIST [2:?] OF parameter_value;
  knot_spec        : knot_type;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
WHERE
  WR1: constraints_param_b_spline(SELF\b_spline_surface.u_degree,
       knot_u_upper,SELF\b_spline_surface.u_upper,u_multiplicities,
       u_knots);
  WR2: constraints_param_b_spline(SELF\b_spline_surface.v_degree,
       knot_v_upper,SELF\b_spline_surface.v_upper,v_multiplicities,
       v_knots);
  WR3: SIZEOF(u_multiplicities) = knot_u_upper;
  WR4: SIZEOF(v_multiplicities) = knot_v_upper;
END_ENTITY; -- b_spline_surface_with_knots

ENTITY bezier_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY; -- bezier_curve

ENTITY bezier_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY; -- bezier_surface

ENTITY boundary_curve
  SUBTYPE OF (composite_curve_on_surface);
WHERE
  WR1: SELF\composite_curve.closed_curve;
END_ENTITY; -- boundary_curve

ENTITY bounded_curve
  SUPERTYPE OF (ONEOF (polyline, b_spline_curve, trimmed_curve,
    composite_curve))
  SUBTYPE OF (curve);
END_ENTITY; -- bounded_curve

ENTITY bounded_surface
  SUPERTYPE OF (ONEOF (b_spline_surface, rectangular_trimmed_surface,
    curve_bounded_surface, rectangular_composite_surface))
  SUBTYPE OF (surface);
END_ENTITY; -- bounded_surface

ENTITY brep_with_voids
  SUBTYPE OF (manifold_solid_brep);
  voids : SET [1:?] OF oriented_closed_shell;
END_ENTITY; -- brep_with_voids

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component   : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date(SELF);
END_ENTITY; -- calendar_date

ENTITY cartesian_point
  SUBTYPE OF (point);
  coordinates : LIST [1:3] OF length_measure;
END_ENTITY; -- cartesian_point

ENTITY cartesian_transformation_operator
  SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d,
    cartesian_transformation_operator_3d))
  SUBTYPE OF (geometric_representation_item,
    functionally_defined_transformation);
  axis1        : OPTIONAL direction;
  axis2        : OPTIONAL direction;
  local_origin : cartesian_point;
  scale        : OPTIONAL REAL;
DERIVE
  scl : REAL := NVL(scale,1);
WHERE
  WR1: scl > 0;
END_ENTITY; -- cartesian_transformation_operator

ENTITY cartesian_transformation_operator_2d
  SUBTYPE OF (cartesian_transformation_operator);
DERIVE
  u : LIST [2:2] OF direction := base_axis(2,SELF\
      cartesian_transformation_operator.axis1,SELF\
      cartesian_transformation_operator.axis2,?);
WHERE
  WR1: SELF\cartesian_transformation_operator.dim = 2;
END_ENTITY; -- cartesian_transformation_operator_2d

ENTITY cartesian_transformation_operator_3d
  SUBTYPE OF (cartesian_transformation_operator);
  axis3 : OPTIONAL direction;
DERIVE
  u : LIST [3:3] OF direction := base_axis(3,
      SELF\cartesian_transformation_operator.axis1,
      SELF\cartesian_transformation_operator.axis2, axis3);
WHERE
  WR1: SELF\cartesian_transformation_operator.dim = 3;
END_ENTITY; -- cartesian_transformation_operator_3d

ENTITY cc_design_approval
  SUBTYPE OF (approval_assignment);
  items : SET [1:?] OF approved_item;
END_ENTITY; -- cc_design_approval

ENTITY cc_design_certification
  SUBTYPE OF (certification_assignment);
  items : SET [1:?] OF certified_item;
END_ENTITY; -- cc_design_certification

ENTITY cc_design_contract
  SUBTYPE OF (contract_assignment);
  items : SET [1:?] OF contracted_item;
END_ENTITY; -- cc_design_contract

ENTITY cc_design_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items : SET [1:?] OF date_time_item;
WHERE
  WR1: cc_design_date_time_correlation(SELF);
END_ENTITY; -- cc_design_date_and_time_assignment

ENTITY cc_design_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items : SET [1:?] OF person_organization_item;
WHERE
  WR1: cc_design_person_and_organization_correlation(SELF);
END_ENTITY; -- cc_design_person_and_organization_assignment

ENTITY cc_design_security_classification
  SUBTYPE OF (security_classification_assignment);
  items : SET [1:?] OF classified_item;
END_ENTITY; -- cc_design_security_classification

ENTITY cc_design_specification_reference
  SUBTYPE OF (document_reference);
  items : SET [1:?] OF specified_item;
END_ENTITY; -- cc_design_specification_reference

ENTITY certification;
  name    : label;
  purpose : text;
  kind    : certification_type;
END_ENTITY; -- certification

ENTITY certification_assignment
  ABSTRACT SUPERTYPE;
  assigned_certification : certification;
END_ENTITY; -- certification_assignment

ENTITY certification_type;
  description : label;
END_ENTITY; -- certification_type

ENTITY change
  SUBTYPE OF (action_assignment);
  items : SET [1:?] OF work_item;
END_ENTITY; -- change

ENTITY change_request
  SUBTYPE OF (action_request_assignment);
  items : SET [1:?] OF change_request_item;
END_ENTITY; -- change_request

ENTITY circle
  SUBTYPE OF (conic);
  radius : positive_length_measure;
END_ENTITY; -- circle

ENTITY closed_shell
  SUBTYPE OF (connected_face_set);
END_ENTITY; -- closed_shell

ENTITY composite_curve
  SUBTYPE OF (bounded_curve);
  segments       : LIST [1:?] OF composite_curve_segment;
  self_intersect : LOGICAL;
DERIVE
  n_segments   : INTEGER := SIZEOF(segments);
  closed_curve : LOGICAL := segments[n_segments].transition <>
                    discontinuous;
WHERE
  WR1: ((NOT closed_curve) AND
       (SIZEOF (QUERY (temp <* segments |
       temp.transition = discontinuous)) = 1)) OR
       ((closed_curve) AND
       (SIZEOF (QUERY (temp <* segments |
       temp.transition = discontinuous)) = 0));
END_ENTITY; -- composite_curve

ENTITY composite_curve_on_surface
  SUPERTYPE OF (boundary_curve)
  SUBTYPE OF (composite_curve);
DERIVE
  basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: SIZEOF(basis_surface) > 0;
  WR2: constraints_composite_curve_on_surface(SELF);
END_ENTITY; -- composite_curve_on_surface

ENTITY composite_curve_segment;
  transition   : transition_code;
  same_sense   : BOOLEAN;
  parent_curve : curve;
INVERSE
  using_curves : BAG [1:?] OF composite_curve FOR segments;
WHERE
  WR1: 'CONFIG_CONTROL_DESIGN.BOUNDED_CURVE' IN TYPEOF(parent_curve);
END_ENTITY; -- composite_curve_segment

ENTITY configuration_design;
  configuration : configuration_item;
  design        : product_definition_formation;
UNIQUE
  UR1 : configuration, design;
END_ENTITY; -- configuration_design

ENTITY configuration_effectivity
  SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  UR1 : configuration, usage, id;
WHERE
  WR1: SELF\product_definition_effectivity.usage.
       relating_product_definition IN
       (USEDIN (SELF.configuration.design, 'CONFIG_CONTROL_DESIGN.' +
       'PRODUCT_DEFINITION.FORMATION') +
       relatives_of_product_definitions (bag_to_set (USEDIN
       (SELF.configuration.design, 'CONFIG_CONTROL_DESIGN.' +
       'PRODUCT_DEFINITION.FORMATION')), 'CONFIG_CONTROL_DESIGN.' +
       'PRODUCT_DEFINITION_USAGE'));
  WR2: 'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_USAGE' IN
       TYPEOF(SELF\product_definition_effectivity.usage);
END_ENTITY; -- configuration_effectivity

ENTITY configuration_item;
  id           : identifier;
  name         : label;
  description  : OPTIONAL text;
  item_concept : product_concept;
  purpose      : OPTIONAL label;
UNIQUE
  UR1 : id;
END_ENTITY; -- configuration_item

ENTITY conic
  SUPERTYPE OF (ONEOF (circle, ellipse, hyperbola, parabola))
  SUBTYPE OF (curve);
  position : axis2_placement;
END_ENTITY; -- conic

ENTITY conical_surface
  SUBTYPE OF (elementary_surface);
  radius     : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  WR1: radius >= 0;
END_ENTITY; -- conical_surface

ENTITY connected_edge_set
  SUBTYPE OF (topological_representation_item);
  ces_edges : SET [1:?] OF edge;
END_ENTITY; -- connected_edge_set

ENTITY connected_face_set
  SUPERTYPE OF (ONEOF (closed_shell, open_shell))
  SUBTYPE OF (topological_representation_item);
  cfs_faces : SET [1:?] OF face;
END_ENTITY; -- connected_face_set

ENTITY context_dependent_shape_representation;
  representation_relation      : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
WHERE
  WR1: 'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP' IN
       TYPEOF(SELF.represented_product_relation.definition);
END_ENTITY; -- context_dependent_shape_representation

ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY; -- context_dependent_unit

ENTITY contract;
  name    : label;
  purpose : text;
  kind    : contract_type;
END_ENTITY; -- contract

ENTITY contract_assignment
  ABSTRACT SUPERTYPE;
  assigned_contract : contract;
END_ENTITY; -- contract_assignment

ENTITY contract_type;
  description : label;
END_ENTITY; -- contract_type

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name              : label;
  conversion_factor : measure_with_unit;
END_ENTITY; -- conversion_based_unit

ENTITY coordinated_universal_time_offset;
  hour_offset   : hour_in_day;
  minute_offset : OPTIONAL minute_in_hour;
  sense         : ahead_or_behind;
END_ENTITY; -- coordinated_universal_time_offset

ENTITY curve
  SUPERTYPE OF (ONEOF (line, conic, pcurve, surface_curve, offset_curve_2d,
    offset_curve_3d, curve_replica))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- curve

ENTITY curve_bounded_surface
  SUBTYPE OF (bounded_surface);
  basis_surface  : surface;
  boundaries     : SET [1:?] OF boundary_curve;
  implicit_outer : BOOLEAN;
WHERE
  WR1: NOT (implicit_outer AND
       ('CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(boundaries)));
  WR2: (NOT implicit_outer) OR
       ('CONFIG_CONTROL_DESIGN.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
  WR3: SIZEOF (QUERY (temp <* boundaries |
       'CONFIG_CONTROL_DESIGN.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) <= 1;
  WR4: SIZEOF (QUERY (temp <* boundaries |
       temp\composite_curve_on_surface.basis_surface[1] :<>: 
       SELF.basis_surface)) = 0;
END_ENTITY; -- curve_bounded_surface

ENTITY curve_replica
  SUBTYPE OF (curve);
  parent_curve   : curve;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_curve.dim;
  WR2: acyclic_curve_replica(SELF,parent_curve);
END_ENTITY; -- curve_replica

ENTITY cylindrical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY; -- cylindrical_surface

ENTITY date
  SUPERTYPE OF (ONEOF (calendar_date, ordinal_date,
    week_of_year_and_day_date));
  year_component : year_number;
END_ENTITY; -- date

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY; -- date_and_time

ENTITY date_and_time_assignment
  ABSTRACT SUPERTYPE;
  assigned_date_and_time : date_and_time;
  role                   : date_time_role;
END_ENTITY; -- date_and_time_assignment

ENTITY date_time_role;
  name : label;
END_ENTITY; -- date_time_role

ENTITY dated_effectivity
  SUBTYPE OF (effectivity);
  effectivity_start_date : date_and_time;
  effectivity_end_date   : OPTIONAL date_and_time;
END_ENTITY; -- dated_effectivity

ENTITY definitional_representation
  SUBTYPE OF (representation);
WHERE
  WR1: 'CONFIG_CONTROL_DESIGN.PARAMETRIC_REPRESENTATION_CONTEXT' IN
       TYPEOF (SELF\representation.context_of_items);
END_ENTITY; -- definitional_representation

ENTITY degenerate_pcurve
  SUBTYPE OF (point);
  basis_surface      : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF(reference_to_curve\representation.items) = 1;
  WR2: 'CONFIG_CONTROL_DESIGN.CURVE' IN
       TYPEOF (reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation.items[1]\
       geometric_representation_item.dim = 2;
END_ENTITY; -- degenerate_pcurve

ENTITY design_context
  SUBTYPE OF (product_definition_context);
WHERE
  WR1: SELF.life_cycle_stage = 'design';
END_ENTITY; -- design_context

ENTITY design_make_from_relationship
  SUBTYPE OF (product_definition_relationship);
END_ENTITY; -- design_make_from_relationship

ENTITY dimensional_exponents;
  length_exponent                    : REAL;
  mass_exponent                      : REAL;
  time_exponent                      : REAL;
  electric_current_exponent          : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent       : REAL;
  luminous_intensity_exponent        : REAL;
END_ENTITY; -- dimensional_exponents

ENTITY directed_action
  SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY; -- directed_action

ENTITY direction
  SUBTYPE OF (geometric_representation_item);
  direction_ratios : LIST [2:3] OF REAL;
WHERE
  WR1: SIZEOF (QUERY (tmp <* direction_ratios | tmp <> 0)) > 0;
END_ENTITY; -- direction

ENTITY document;
  id          : identifier;
  name        : label;
  description : text;
  kind        : document_type;
UNIQUE
  UR1 : id;
END_ENTITY; -- document

ENTITY document_reference
  ABSTRACT SUPERTYPE;
  assigned_document : document;
  source            : label;
END_ENTITY; -- document_reference

ENTITY document_relationship;
  name              : label;
  description       : text;
  relating_document : document;
  related_document  : document;
END_ENTITY; -- document_relationship

ENTITY document_type;
  product_data_type : label;
END_ENTITY; -- document_type

ENTITY document_usage_constraint;
  source                : document;
  subject_element       : label;
  subject_element_value : text;
END_ENTITY; -- document_usage_constraint

ENTITY document_with_class
  SUBTYPE OF (document);
  class : identifier;
END_ENTITY; -- document_with_class

ENTITY edge
  SUPERTYPE OF (ONEOF (edge_curve, oriented_edge))
  SUBTYPE OF (topological_representation_item);
  edge_start : vertex;
  edge_end   : vertex;
END_ENTITY; -- edge

ENTITY edge_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  ebwm_boundary : SET [1:?] OF connected_edge_set;
END_ENTITY; -- edge_based_wireframe_model

ENTITY edge_based_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1:  SIZEOF (QUERY (it <* SELF\representation.items |
        NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL',
        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
        'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1
        ))) = 0;
  WR2:  SIZEOF (QUERY (it <* SELF\representation.items |
        SIZEOF(['CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL',
        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1
        )) >= 1;
  WR3:  SIZEOF (QUERY (ebwm <*
        QUERY (it <* SELF\representation.items |
        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (eb <*
        ebwm\edge_based_wireframe_model.ebwm_boundary |
        NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
        NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF (edges)))) = 0
        ))) = 0))) = 0;
  WR4:  SIZEOF (QUERY (ebwm <*
        QUERY (it <* SELF\representation.items |
        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (eb <*
        ebwm\edge_based_wireframe_model.ebwm_boundary |
        NOT (SIZEOF (QUERY (pline_edges <* QUERY (edges <* eb.ces_edges |
        'CONFIG_CONTROL_DESIGN.POLYLINE' IN
        TYPEOF (edges\edge_curve.edge_geometry)) |
        NOT (SIZEOF (pline_edges\edge_curve.edge_geometry\polyline.points)
        > 2))) = 0))) = 0))) = 0;
  WR5:  SIZEOF (QUERY (ebwm <*
        QUERY (it <* SELF\representation.items |
        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (eb <*
        ebwm\edge_based_wireframe_model.ebwm_boundary |
        NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
        NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN
        TYPEOF (edges.edge_start)) AND
        ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN
        TYPEOF (edges.edge_end))))) = 0))) = 0))) = 0;
  WR6:  SIZEOF (QUERY (ebwm <*
        QUERY (it <* SELF\representation.items |
        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (eb <*
        ebwm\edge_based_wireframe_model.ebwm_boundary |
        NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
        NOT (valid_wireframe_edge_curve
        (edges\edge_curve.edge_geometry, 'CONFIG_CONTROL_DESIGN')))) =
        0))) = 0))) = 0;
  WR7:  SIZEOF (QUERY (ebwm <*
        QUERY (it <* SELF\representation.items |
        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (eb <*
        ebwm\edge_based_wireframe_model.ebwm_boundary |
        NOT (SIZEOF (QUERY (edges <* eb.ces_edges |
        NOT((valid_wireframe_vertex_point
        (edges.edge_start\vertex_point.vertex_geometry,
        'CONFIG_CONTROL_DESIGN')) AND
        (valid_wireframe_vertex_point
        (edges.edge_end\vertex_point.vertex_geometry,
        'CONFIG_CONTROL_DESIGN'))))) = 0))) = 0))) = 0;
  WR8:  SIZEOF (QUERY (ebwm <*
        QUERY (it <* SELF\representation.items |
        'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (eb <*
        ebwm\edge_based_wireframe_model.ebwm_boundary |
        NOT (SIZEOF (QUERY (con_edges <* QUERY (edges <* eb.ces_edges |
        'CONFIG_CONTROL_DESIGN.CONIC' IN
        TYPEOF (edges\edge_curve.edge_geometry)) |
        NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN
        TYPEOF (con_edges\edge_curve.edge_geometry\conic.position)))) = 0
        ))) = 0))) = 0;
   WR9: SIZEOF (QUERY (mi <* QUERY (item <* SELF\representation.items |
        'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (item)) |
        NOT ('CONFIG_CONTROL_DESIGN.' +
        'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION'
        IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))
        = 0;
END_ENTITY; -- edge_based_wireframe_shape_representation

ENTITY edge_curve
  SUBTYPE OF (edge, geometric_representation_item);
  edge_geometry : curve;
  same_sense    : BOOLEAN;
END_ENTITY; -- edge_curve

ENTITY edge_loop
  SUBTYPE OF (loop, path);
DERIVE
  ne : INTEGER := SIZEOF(SELF\path.edge_list);
WHERE
  WR1: SELF\path.edge_list[1].edge_start :=:
       SELF\path.edge_list[ne].edge_end;
END_ENTITY; -- edge_loop

ENTITY effectivity
  SUPERTYPE OF (ONEOF (serial_numbered_effectivity, dated_effectivity,
    lot_effectivity));
  id : identifier;
END_ENTITY; -- effectivity

ENTITY elementary_surface
  SUPERTYPE OF (ONEOF (plane, cylindrical_surface, conical_surface,
    spherical_surface, toroidal_surface))
  SUBTYPE OF (surface);
  position : axis2_placement_3d;
END_ENTITY; -- elementary_surface

ENTITY ellipse
  SUBTYPE OF (conic);
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY; -- ellipse

ENTITY evaluated_degenerate_pcurve
  SUBTYPE OF (degenerate_pcurve);
  equivalent_point : cartesian_point;
END_ENTITY; -- evaluated_degenerate_pcurve

ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY; -- executed_action

ENTITY face
  SUPERTYPE OF (ONEOF (face_surface, oriented_face))
  SUBTYPE OF (topological_representation_item);
  bounds : SET [1:?] OF face_bound;
WHERE
  WR1: NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)));
  WR2: SIZEOF (QUERY (temp <* bounds |
       'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(temp))) <= 1;
END_ENTITY; -- face

ENTITY face_bound
  SUBTYPE OF (topological_representation_item);
  bound       : loop;
  orientation : BOOLEAN;
END_ENTITY; -- face_bound

ENTITY face_outer_bound
  SUBTYPE OF (face_bound);
END_ENTITY; -- face_outer_bound

ENTITY face_surface
  SUBTYPE OF (face, geometric_representation_item);
  face_geometry : surface;
  same_sense    : BOOLEAN;
END_ENTITY; -- face_surface

ENTITY faceted_brep
  SUBTYPE OF (manifold_solid_brep);
END_ENTITY; -- faceted_brep

ENTITY faceted_brep_shape_representation
SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* items |
       NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.FACETED_BREP',
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
       'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))) = 0;
  WR2: SIZEOF (QUERY (it <* items |
       SIZEOF(['CONFIG_CONTROL_DESIGN.FACETED_BREP',
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF(it)) = 1)) > 0;
  WR3: SIZEOF (QUERY (fbrep <* QUERY ( it <* items |
       'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF(it)) |
       NOT (SIZEOF (QUERY (csh <*
       msb_shells (fbrep, 'CONFIG_CONTROL_DESIGN') |
       NOT (SIZEOF (QUERY (fcs <* csh.cfs_faces |
       NOT (('CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN TYPEOF (fcs))
       AND
       (('CONFIG_CONTROL_DESIGN.PLANE' IN TYPEOF
       (fcs\face_surface.face_geometry))
       AND
       ('CONFIG_CONTROL_DESIGN.CARTESIAN_POINT' IN
       TYPEOF (fcs\face_surface.face_geometry\plane.position.location))))))
       = 0))) = 0))) = 0;
  WR4: SIZEOF (QUERY (fbrep <* QUERY ( it <* items |
       'CONFIG_CONTROL_DESIGN.FACETED_BREP' IN TYPEOF(it)) |
       NOT (SIZEOF (QUERY (csh <*
       msb_shells (fbrep, 'CONFIG_CONTROL_DESIGN') |
       NOT (SIZEOF (QUERY (fcs <* csh.cfs_faces |
       NOT (SIZEOF (QUERY (bnds <* fcs.bounds |
       'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1)))
       = 0))) = 0))) = 0;
  WR5: SIZEOF (QUERY (msb <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
       'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN
       TYPEOF (msb\manifold_solid_brep.outer))) = 0;
  WR6: SIZEOF (QUERY (brv <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.BREP_WITH_VOIDS' IN TYPEOF(it)) |
       NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
       csh\oriented_closed_shell.orientation)) = 0))) = 0;
  WR7: SIZEOF (QUERY (mi <*  QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF(it)) |
       NOT ('CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION' IN
       TYPEOF(mi\mapped_item.mapping_source.mapped_representation))))
       = 0;
END_ENTITY; -- faceted_brep_shape_representation

ENTITY functionally_defined_transformation;
  name        : label;
  description : text;
END_ENTITY; -- functionally_defined_transformation

ENTITY geometric_curve_set
  SUBTYPE OF (geometric_set);
WHERE
  WR1: SIZEOF (QUERY (temp <* SELF\geometric_set.elements |
       'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF(temp))) = 0;
END_ENTITY; -- geometric_curve_set

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY; -- geometric_representation_context

ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF (point, direction, vector, placement,
    cartesian_transformation_operator, curve, surface, edge_curve,
    face_surface, vertex_point, poly_loop, solid_model, 
    shell_based_surface_model, shell_based_wireframe_model, 
    edge_based_wireframe_model, geometric_set))
  SUBTYPE OF (representation_item);
DERIVE
  dim : dimension_count := dimension_of(SELF);
WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) |
       NOT ('CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN
       TYPEOF (using_rep.context_of_items)))) = 0;
END_ENTITY; -- geometric_representation_item

ENTITY geometric_set
  SUPERTYPE OF (geometric_curve_set)
  SUBTYPE OF (geometric_representation_item);
  elements : SET [1:?] OF geometric_set_select;
END_ENTITY; -- geometric_set

ENTITY geometrically_bounded_surface_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* items |
       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.GEOMETRIC_SET',
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
       'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0;
  WR2: SIZEOF (QUERY (it <* items |
       SIZEOF (['CONFIG_CONTROL_DESIGN.GEOMETRIC_SET',
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR3: SIZEOF (QUERY (mi <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT ('CONFIG_CONTROL_DESIGN.' +
       'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))
       = 0;
  WR4: SIZEOF (QUERY (gs <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (pnt <* QUERY (gsel <*
       gs\geometric_set.elements |
       'CONFIG_CONTROL_DESIGN.POINT' IN TYPEOF (gsel)) |
       NOT (gbsf_check_point(pnt, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0;
  WR5: SIZEOF (QUERY (gs <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cv <* QUERY (gsel <*
       gs\geometric_set.elements |
       'CONFIG_CONTROL_DESIGN.CURVE' IN TYPEOF (gsel)) |
       NOT (gbsf_check_curve(cv, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0;
  WR6: SIZEOF (QUERY (gs <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.GEOMETRIC_SET' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (sf <* QUERY (gsel <*
       gs\geometric_set.elements |
       'CONFIG_CONTROL_DESIGN.SURFACE' IN TYPEOF (gsel)) |
       NOT (gbsf_check_surface(sf, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0;
END_ENTITY; -- geometrically_bounded_surface_shape_representation

ENTITY geometrically_bounded_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF\representation.items |
       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET',
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
       'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF\representation.items |
       SIZEOF(['CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET',
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1
       )) >= 1;
  WR3: SIZEOF (QUERY (gcs <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (elem <* gcs\geometric_set.elements |
       NOT (valid_geometrically_bounded_wf_curve
       (elem, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0;
  WR4: SIZEOF (QUERY (gcs <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (pnts <* QUERY (elem <*
       gcs\geometric_set.elements |
       'CONFIG_CONTROL_DESIGN.POINT' IN TYPEOF (elem)) |
       NOT (valid_geometrically_bounded_wf_point
       (pnts, 'CONFIG_CONTROL_DESIGN')))) = 0))) = 0;
  WR5: SIZEOF (QUERY (gcs <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cnc <* QUERY (elem <*
       gcs\geometric_set.elements |
       'CONFIG_CONTROL_DESIGN.CONIC' IN TYPEOF (elem)) |
       NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF
       (cnc\conic.position)))) = 0))) = 0; 
  WR6: SIZEOF (QUERY (gcs <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (pline <* QUERY (elem <*
       gcs\geometric_set.elements |
       'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF(elem)) |
       NOT (SIZEOF (pline\polyline.points) > 2))) = 0))) = 0; 
  WR7: SIZEOF (QUERY (mi <* QUERY (item <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (item)) |
       NOT ('CONFIG_CONTROL_DESIGN.' +
       'GEOMETRICALLY_BOUNDED_WIREFRAME_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))
       = 0;
END_ENTITY; -- geometrically_bounded_wireframe_shape_representation

ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY; -- global_uncertainty_assigned_context

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET [1:?] OF unit;
END_ENTITY; -- global_unit_assigned_context

ENTITY hyperbola
  SUBTYPE OF (conic);
  semi_axis      : positive_length_measure;
  semi_imag_axis : positive_length_measure;
END_ENTITY; -- hyperbola

ENTITY intersection_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1])
       <> associated_surface(SELF\surface_curve.associated_geometry[2]);
END_ENTITY; -- intersection_curve

ENTITY item_defined_transformation;
  name             : label;
  description      : text;
  transform_item_1 : representation_item;
  transform_item_2 : representation_item;
END_ENTITY; -- item_defined_transformation

ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN
       TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY; -- length_measure_with_unit

ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1) AND
       (SELF\named_unit.dimensions.mass_exponent = 0) AND
       (SELF\named_unit.dimensions.time_exponent = 0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0);
END_ENTITY; -- length_unit

ENTITY line
  SUBTYPE OF (curve);
  pnt : cartesian_point;
  dir : vector;
WHERE
  WR1: dir.dim = pnt.dim;
END_ENTITY; -- line

ENTITY local_time;
  hour_component   : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone             : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY; -- local_time

ENTITY loop
  SUPERTYPE OF (ONEOF (vertex_loop, edge_loop, poly_loop))
  SUBTYPE OF (topological_representation_item);
END_ENTITY; -- loop

ENTITY lot_effectivity
  SUBTYPE OF (effectivity);
  effectivity_lot_id   : identifier;
  effectivity_lot_size : measure_with_unit;
END_ENTITY; -- lot_effectivity

ENTITY manifold_solid_brep
  SUBTYPE OF (solid_model);
  outer : closed_shell;
END_ENTITY; -- manifold_solid_brep

ENTITY manifold_surface_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* items |
       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL',
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
       'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0;
  WR2: SIZEOF (QUERY (it <* items |
       SIZEOF (['CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL',
       'CONFIG_CONTROL_DESIGN.MAPPED ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR3: SIZEOF (QUERY (mi <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.MAPPED ITEM' IN TYPEOF (it)) |
       NOT ('CONFIG_CONTROL_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))
       = 0;
  WR4: SIZEOF (QUERY (sbsm <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (sh <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.OPEN_SHELL',
       'CONFIG_CONTROL_DESIGN.CLOSED_SHELL']
       * TYPEOF (sh)) = 1))) = 0))) = 0;
  WR5: SIZEOF (QUERY (sbsm <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.FACE_SURFACE',
       'CONFIG_CONTROL_DESIGN.ORIENTED_FACE'] * TYPEOF (fa)) = 1))) = 0)))
       = 0))) = 0;
  WR6: SIZEOF (QUERY (sbsm <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (f_sf <* QUERY (fa <* cfs.cfs_faces |
       'CONFIG_CONTROL_DESIGN.FACE_SURFACE' IN TYPEOF (fa)) |
       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (f_sf))
       OR
       (SIZEOF (['CONFIG_CONTROL_DESIGN.OFFSET_SURFACE',
       'CONFIG_CONTROL_DESIGN.SURFACE_REPLICA'] * TYPEOF
       (f_sf\face_surface.face_geometry)) = 1)))) = 0))) = 0))) = 0; 
  WR7: SIZEOF (QUERY (sbsm <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (basis_surface_check(fa\face_surface.face_geometry,   
       'CONFIG_CONTROL_DESIGN'))))) = 0))) = 0))) = 0;
  WR8: SIZEOF (QUERY (sbsm <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (bnds <* fa.bounds |
       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.EDGE_LOOP',
       'CONFIG_CONTROL_DESIGN.VERTEX_LOOP']
       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
  WR9: SIZEOF (QUERY (sbsm <* QUERY (it <* items|
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
       NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF (oe.edge_element))))
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR10: SIZEOF (QUERY (sbsm <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'CONFIG_CONTROL_DESIGN.EDGE LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <* 
       elp_fbnds.bound\path.edge_list |
       'CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.CURVE_REPLICA',
       'CONFIG_CONTROL_DESIGN.OFFSET_CURVE_3D',
       'CONFIG_CONTROL_DESIGN.SURFACE_CURVE'] * 
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) 
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR11: SIZEOF (QUERY (sbsm <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
       NOT (basis_curve_check (oe.edge_element\edge_curve.edge_geometry,
       'CONFIG_CONTROL_DESIGN')))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR12: SIZEOF (QUERY(sbsm <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list|
       NOT (('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end))))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR13: SIZEOF (QUERY (sbsm <* QUERY (it <* items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('CONFIG_CONTROL_DESIGN.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa. bounds |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
       NOT ((SIZEOF (['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',
       'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',
       'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',
       'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['CONFIG_CONTROL_DESIGN.CARTESIAN_POINT',
       'CONFIG_CONTROL_DESIGN.DEGENERATE_PCURVE',
       'CONFIG_CONTROL_DESIGN.POINT_ON_CURVE',
       'CONFIG_CONTROL_DESIGN.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
END_ENTITY; -- manifold_surface_shape_representation

ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY; -- mapped_item

ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CONFIG_CONTROL_DESIGN.MASS_UNIT' IN
       TYPEOF (SELF\measure_with_unit.unit_component);
END_ENTITY; -- mass_measure_with_unit

ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0) AND
       (SELF\named_unit.dimensions.mass_exponent = 1) AND
       (SELF\named_unit.dimensions.time_exponent = 0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0);
END_ENTITY; -- mass_unit

ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF (length_measure_with_unit, mass_measure_with_unit,
    plane_angle_measure_with_unit, solid_angle_measure_with_unit,
    area_measure_with_unit, volume_measure_with_unit));
  value_component : measure_value;
  unit_component  : unit;
WHERE
  WR1: valid_units(SELF);
END_ENTITY; -- measure_with_unit

ENTITY mechanical_context
  SUBTYPE OF (product_context);
WHERE
  WR1: SELF.discipline_type = 'mechanical';
END_ENTITY; -- mechanical_context

ENTITY named_unit
  SUPERTYPE OF (ONEOF (si_unit, conversion_based_unit,
    context_dependent_unit) ANDOR ONEOF (length_unit, mass_unit,
    plane_angle_unit, solid_angle_unit, area_unit, volume_unit));
  dimensions : dimensional_exponents;
END_ENTITY; -- named_unit

ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY; -- next_assembly_usage_occurrence

ENTITY offset_curve_2d
  SUBTYPE OF (curve);
  basis_curve    : curve;
  distance       : length_measure;
  self_intersect : LOGICAL;
WHERE
  WR1: basis_curve.dim = 2;
END_ENTITY; -- offset_curve_2d

ENTITY offset_curve_3d
  SUBTYPE OF (curve);
  basis_curve    : curve;
  distance       : length_measure;
  self_intersect : LOGICAL;
  ref_direction  : direction;
WHERE
  WR1: (basis_curve.dim = 3) AND (ref_direction.dim = 3);
END_ENTITY; -- offset_curve_3d

ENTITY offset_surface
  SUBTYPE OF (surface);
  basis_surface  : surface;
  distance       : length_measure;
  self_intersect : LOGICAL;
END_ENTITY; -- offset_surface

ENTITY open_shell
  SUBTYPE OF (connected_face_set);
END_ENTITY; -- open_shell

ENTITY ordinal_date
SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND {1 <= day_component <= 365})
       OR
       (leap_year(SELF.year_component) AND {1 <= day_component <= 366});
END_ENTITY; -- ordinal_date

ENTITY organization;
  id          : OPTIONAL identifier;
  name        : label;
  description : text;
END_ENTITY; -- organization

ENTITY organization_relationship;
  name                  : label;
  description           : text;
  relating_organization : organization;
  related_organization  : organization;
END_ENTITY; -- organization_relationship

ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET [1:?] OF organization;
  description   : text;
END_ENTITY; -- organizational_address

ENTITY organizational_project;
  name                      : label;
  description               : text;
  responsible_organizations : SET [1:?] OF organization;
END_ENTITY; -- organizational_project

ENTITY oriented_closed_shell
  SUBTYPE OF (closed_shell);
  closed_shell_element : closed_shell;
  orientation          : BOOLEAN;
DERIVE
  SELF\connected_face_set.cfs_faces : SET [1:?] OF face :=
                                      conditional_reverse(SELF.orientation,
                                      SELF.closed_shell_element.cfs_faces);
WHERE
  WR1: NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN
       TYPEOF(SELF.closed_shell_element));
END_ENTITY; -- oriented_closed_shell

ENTITY oriented_edge
  SUBTYPE OF (edge);
  edge_element : edge;
  orientation  : BOOLEAN;
DERIVE
  SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
                         SELF.edge_element.edge_start,
                         SELF.edge_element.edge_end);
  SELF\edge.edge_end   : vertex := boolean_choose(SELF.orientation,
                         SELF.edge_element.edge_end,
                         SELF.edge_element.edge_start);
WHERE
  WR1: NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN
       TYPEOF (SELF.edge_element));
END_ENTITY; -- oriented_edge

ENTITY oriented_face
  SUBTYPE OF (face);
  face_element : face;
  orientation  : BOOLEAN;
DERIVE
  SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse
                     (SELF.orientation, SELF.face_element.bounds);
WHERE
  WR1: NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN
       TYPEOF(SELF.face_element));
END_ENTITY; -- oriented_face

ENTITY oriented_open_shell
  SUBTYPE OF (open_shell);
  open_shell_element : open_shell;
  orientation        : BOOLEAN;
DERIVE
  SELF\connected_face_set.cfs_faces : SET [1:?] OF face :=
                                      conditional_reverse(SELF.orientation,
                                      SELF.open_shell_element.cfs_faces);
WHERE
  WR1: NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN
       TYPEOF (SELF.open_shell_element));
END_ENTITY; -- oriented_open_shell

ENTITY oriented_path
  SUBTYPE OF (path);
  path_element : path;
  orientation  : BOOLEAN;
DERIVE
  SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge :=
                        conditional_reverse(SELF.orientation,
                        SELF.path_element.edge_list);
WHERE
  WR1: NOT ('CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN
       TYPEOF (SELF.path_element));
END_ENTITY; -- oriented_path

ENTITY outer_boundary_curve
  SUBTYPE OF (boundary_curve);
END_ENTITY; -- outer_boundary_curve

ENTITY parabola
  SUBTYPE OF (conic);
  focal_dist : length_measure;
WHERE
  WR1: focal_dist <> 0;
END_ENTITY; -- parabola

ENTITY parametric_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY; -- parametric_representation_context

ENTITY path
  SUPERTYPE OF (ONEOF (edge_loop, oriented_path))
  SUBTYPE OF (topological_representation_item);
  edge_list : LIST [1:?] OF UNIQUE oriented_edge;
WHERE
  WR1: path_head_to_tail (SELF);
END_ENTITY; -- path

ENTITY pcurve
  SUBTYPE OF (curve);
  basis_surface      : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF (reference_to_curve\representation.items) = 1;
  WR2: 'CONFIG_CONTROL_DESIGN.CURVE' IN
       TYPEOF(reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation.items[1]\
       geometric_representation_item.dim = 2;
END_ENTITY; -- pcurve

ENTITY person;
  id            : identifier;
  last_name     : OPTIONAL label;
  first_name    : OPTIONAL label;
  middle_names  : OPTIONAL LIST [1:?] OF label;
  prefix_titles : OPTIONAL LIST [1:?] OF label;
  suffix_titles : OPTIONAL LIST [1:?] OF label;
UNIQUE
  UR1 : id;
WHERE
  WR1: EXISTS (last_name) OR EXISTS (first_name);
END_ENTITY; -- person

ENTITY person_and_organization;
  the_person       : person;
  the_organization : organization;
END_ENTITY; -- person_and_organization

ENTITY person_and_organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_person_and_organization : person_and_organization;
  role                             : person_and_organization_role;
END_ENTITY; -- person_and_organization_assignment

ENTITY person_and_organization_role;
  name : label;
END_ENTITY; -- person_and_organization_role

ENTITY personal_address
  SUBTYPE OF (address);
  people      : SET [1:?] OF person;
  description : text;
END_ENTITY; -- personal_address

ENTITY placement
  SUPERTYPE OF (ONEOF (axis1_placement, axis2_placement_2d,
    axis2_placement_3d))
  SUBTYPE OF (geometric_representation_item);
  location : cartesian_point;
END_ENTITY; -- placement

ENTITY plane
SUBTYPE OF (elementary_surface);
END_ENTITY; -- plane

ENTITY plane_angle_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- plane_angle_measure_with_unit

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0) AND
       (SELF\named_unit.dimensions.mass_exponent = 0) AND
       (SELF\named_unit.dimensions.time_exponent = 0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0);
END_ENTITY; -- plane_angle_unit

ENTITY point
  SUPERTYPE OF (ONEOF (cartesian_point, point_on_curve, point_on_surface,
    point_replica, degenerate_pcurve))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- point

ENTITY point_on_curve
  SUBTYPE OF (point);
  basis_curve     : curve;
  point_parameter : parameter_value;
END_ENTITY; -- point_on_curve

ENTITY point_on_surface
  SUBTYPE OF (point);
  basis_surface     : surface;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
END_ENTITY; -- point_on_surface

ENTITY point_replica
  SUBTYPE OF (point);
  parent_pt      : point;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_pt.dim;
  WR2: acyclic_point_replica(SELF,parent_pt);
END_ENTITY; -- point_replica

ENTITY poly_loop
  SUBTYPE OF (loop, geometric_representation_item);
    polygon : LIST [3:?] OF UNIQUE cartesian_point;
END_ENTITY; -- poly_loop

ENTITY polyline
  SUBTYPE OF (bounded_curve);
  points : LIST [2:?] OF cartesian_point;
END_ENTITY; -- polyline

ENTITY product;
  id                 : identifier;
  name               : label;
  description        : text;
  frame_of_reference : SET [1:?] OF product_context;
UNIQUE
  UR1 : id;
END_ENTITY; -- product

ENTITY product_category;
  name        : label;
  description : OPTIONAL text;
END_ENTITY; -- product_category

ENTITY product_category_relationship;
  name         : label;
  description  : text;
  category     : product_category;
  sub_category : product_category;
WHERE
  WR1: acyclic_product_category_relationship(SELF,[SELF.sub_category]);
END_ENTITY; -- product_category_relationship

ENTITY product_concept;
  id             : identifier;
  name           : label;
  description    : text;
  market_context : product_concept_context;
UNIQUE
  UR1 : id;
END_ENTITY; -- product_concept

ENTITY product_concept_context
  SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY; -- product_concept_context

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY; -- product_context

ENTITY product_definition;
  id                 : identifier;
  description        : text;
  formation          : product_definition_formation;
  frame_of_reference : product_definition_context;
END_ENTITY; -- product_definition

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY; -- product_definition_context

ENTITY product_definition_effectivity
  SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
UNIQUE
  UR1 : usage, id;
END_ENTITY; -- product_definition_effectivity

ENTITY product_definition_formation;
  id          : identifier;
  description : text;
  of_product  : product;
UNIQUE
  UR1 : id, of_product;
END_ENTITY; -- product_definition_formation

ENTITY product_definition_formation_with_specified_source
  SUBTYPE OF (product_definition_formation);
  make_or_buy : source;
END_ENTITY; -- product_definition_formation_with_specified_source

ENTITY product_definition_relationship;
  id                          : identifier;
  name                        : label;
  description                 : text;
  relating_product_definition : product_definition;
  related_product_definition  : product_definition;
END_ENTITY; -- product_definition_relationship

ENTITY product_definition_shape
  SUBTYPE OF (property_definition);
UNIQUE
  UR1 : definition;
WHERE
  WR1: 'CONFIG_CONTROL_DESIGN.CHARACTERIZED_PRODUCT_DEFINITION'
       IN TYPEOF(SELF\property_definition.definition);
END_ENTITY; -- product_definition_shape

ENTITY product_definition_usage
  SUPERTYPE OF (assembly_component_usage)
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1 : id, relating_product_definition, related_product_definition;
WHERE
  WR1: acyclic_product_definition_relationship (SELF,
       [SELF\product_definition_relationship.related_product_definition],
       'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_RELATIONSHIP.' + (* POD *)
       'RELATED_PRODUCT_DEFINITION');
END_ENTITY; -- product_definition_usage

ENTITY product_definition_with_associated_documents
  SUBTYPE OF (product_definition);
  documentation_ids : SET [1:?] OF document;
END_ENTITY; -- product_definition_with_associated_documents

ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET [1:?] OF product;
END_ENTITY; -- product_related_product_category

ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY; -- promissory_usage_occurrence

ENTITY property_definition;
  name        : label;
  description : text;
  definition  : characterized_definition;
END_ENTITY; -- property_definition

ENTITY property_definition_representation;
  definition          : property_definition;
  used_representation : representation;
END_ENTITY; -- property_definition_representation

ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity : measure_with_unit;
END_ENTITY; -- quantified_assembly_component_usage

ENTITY quasi_uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY; -- quasi_uniform_curve

ENTITY quasi_uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY; -- quasi_uniform_surface

ENTITY rational_b_spline_curve
  SUBTYPE OF (b_spline_curve);
  weights_data : LIST [2:?] OF REAL;
DERIVE
  weights : ARRAY [0:upper_index_on_control_points] OF REAL :=
            list_to_array(weights_data, 0, upper_index_on_control_points);
WHERE
  WR1: SIZEOF(weights_data) =
       SIZEOF (SELF\b_spline_curve.control_points_list);
  WR2: curve_weights_positive (SELF);
END_ENTITY; -- rational_b_spline_curve

ENTITY rational_b_spline_surface
SUBTYPE OF (b_spline_surface);
  weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
DERIVE
  weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL :=
            make_array_of_array(weights_data, 0, u_upper, 0, v_upper);
WHERE
  WR1: (SIZEOF(weights_data) =
       SIZEOF(SELF\b_spline_surface.control_points_list)) AND
       (SIZEOF(weights_data[1]) =
       SIZEOF(SELF\b_spline_surface.control_points_list[1]));
  WR2: surface_weights_positive (SELF);
END_ENTITY; -- rational_b_spline_surface

ENTITY rectangular_composite_surface
  SUBTYPE OF (bounded_surface);
  segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
DERIVE
  n_u : INTEGER := SIZEOF(segments);
  n_v : INTEGER := SIZEOF(segments[1]);
WHERE
  WR1: [] = QUERY ( s <* segments | n_v <> SIZEOF(s));
  WR2: constraints_rectangular_composite_surface(SELF);
END_ENTITY; -- rectangular_composite_surface

ENTITY rectangular_trimmed_surface
  SUBTYPE OF (bounded_surface);
  basis_surface : surface;
  u1            : parameter_value;
  u2            : parameter_value;
  v1            : parameter_value;
  v2            : parameter_value;
  usense        : BOOLEAN;
  vsense        : BOOLEAN;
WHERE
  WR1: u1 <> u2;
  WR2: v1 <> v2;
  WR3: ((('CONFIG_CONTROL_DESIGN.ELEMENTARY_SURFACE' IN
       TYPEOF (basis_surface)) AND
       (NOT ('CONFIG_CONTROL_DESIGN.PLANE' IN TYPEOF (basis_surface)))) OR
       ('CONFIG_CONTROL_DESIGN.SURFACE_OF_REVOLUTION' IN
       TYPEOF (basis_surface))) OR (usense = (u2 > u1));
  WR4: (('CONFIG_CONTROL_DESIGN.SPHERICAL_SURFACE' IN
       TYPEOF (basis_surface)) OR
       ('CONFIG_CONTROL_DESIGN.TOROIDAL_SURFACE'
       IN TYPEOF (basis_surface))) OR (vsense = (v2 > v1));
END_ENTITY; -- rectangular_trimmed_surface

ENTITY reparametrised_composite_curve_segment
  SUBTYPE OF (composite_curve_segment);
  param_length : parameter_value;
WHERE
  WR1: param_length > 0;
END_ENTITY; -- reparametrised_composite_curve_segment

ENTITY representation;
  name             : label;
  items            : SET [1:?] OF representation_item;
  context_of_items : representation_context;
END_ENTITY; -- representation

ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?] OF representation FOR
                               context_of_items;
END_ENTITY; -- representation_context

ENTITY representation_item;
  name : label;
WHERE
  WR1: SIZEOF (using_representations(SELF)) > 0;
END_ENTITY; -- representation_item

ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET [1:?] OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(SELF.mapping_origin,
       SELF.mapped_representation.context_of_items);
END_ENTITY; -- representation_map

ENTITY representation_relationship;
  name        : label;
  description : text;
  rep_1       : representation;
  rep_2       : representation;
END_ENTITY; -- representation_relationship

ENTITY representation_relationship_with_transformation
  SUBTYPE OF (representation_relationship);
  transformation_operator : transformation;
WHERE
  WR1: SELF\representation_relationship.rep_1.context_of_items :<>:
       SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY; -- representation_relationship_with_transformation

ENTITY seam_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) =
       associated_surface(SELF\surface_curve.associated_geometry[2]);
  WR3: 'CONFIG_CONTROL_DESIGN.PCURVE' IN
       TYPEOF (SELF\surface_curve.associated_geometry[1]);
  WR4: 'CONFIG_CONTROL_DESIGN.PCURVE' IN
       TYPEOF (SELF\surface_curve.associated_geometry[2]);
END_ENTITY; -- seam_curve

ENTITY security_classification;
  name           : label;
  purpose        : text;
  security_level : security_classification_level;
END_ENTITY; -- security_classification

ENTITY security_classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_security_classification : security_classification;
END_ENTITY; -- security_classification_assignment

ENTITY security_classification_level;
  name : label;
END_ENTITY; -- security_classification_level

ENTITY serial_numbered_effectivity
  SUBTYPE OF (effectivity);
  effectivity_start_id : identifier;
  effectivity_end_id   : OPTIONAL identifier;
END_ENTITY; -- serial_numbered_effectivity

ENTITY shape_aspect;
  name                 : label;
  description          : text;
  of_shape             : product_definition_shape;
  product_definitional : LOGICAL;
END_ENTITY; -- shape_aspect

ENTITY shape_aspect_relationship;
  name                  : label;
  description           : text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect  : shape_aspect;
END_ENTITY; -- shape_aspect_relationship

ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
WHERE
  WR1: ('CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION' IN
       TYPEOF(SELF.definition.definition)) OR
       ('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN
       TYPEOF(SELF.definition));
  WR2: 'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN
       TYPEOF(SELF.used_representation);
END_ENTITY; -- shape_definition_representation

ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY; -- shape_representation

ENTITY shape_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: 'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN
       (TYPEOF (SELF\representation_relationship.rep_1) +
       TYPEOF(SELF\representation_relationship.rep_2));
END_ENTITY; -- shape_representation_relationship

ENTITY shell_based_surface_model
  SUBTYPE OF (geometric_representation_item);
  sbsm_boundary : SET [1:?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_surface_model(SELF);
END_ENTITY; -- shell_based_surface_model

ENTITY shell_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  sbwm_boundary : SET [1:?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_wireframe_model(SELF);
END_ENTITY; -- shell_based_wireframe_model

ENTITY shell_based_wireframe_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (it <* SELF\representation.items |
       NOT (SIZEOF(['CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL',
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM',
       'CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1
       ))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF\representation.items |
       SIZEOF(['CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL',
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM'] * TYPEOF (it)) = 1)) >= 1;
  WR3: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <* 
       ws\wire_shell.wire_shell_extent |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |
       NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
       NOT ('CONFIG_CONTROL_DESIGN.EDGE_CURVE' IN
       TYPEOF (el.edge_element)))) = 0))) = 0))) = 0))) = 0;
  WR4: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <* 
       ws\wire_shell.wire_shell_extent |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |
       NOT (SIZEOF (QUERY (pline_el <* QUERY (el <* eloop\path.edge_list |
       'CONFIG_CONTROL_DESIGN.POLYLINE' IN TYPEOF
       (el.edge_element\edge_curve.edge_geometry)) |
       NOT (SIZEOF (pline_el.edge_element\edge_curve.
       edge_geometry\polyline.points) > 2))) 
       = 0))) = 0))) = 0))) = 0;
  WR5: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <* 
       ws\wire_shell.wire_shell_extent |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |
       NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
       NOT (valid_wireframe_edge_curve
       (el.edge_element\edge_curve.edge_geometry,
       'CONFIG_CONTROL_DESIGN')))) = 0))) = 0))) = 0))) = 0;
  WR6: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <* 
       ws\wire_shell.wire_shell_extent |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |
       NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
       NOT(('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN 
       TYPEOF (el.edge_element.edge_start))
       AND
       ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN 
       TYPEOF (el.edge_element.edge_end))))) = 0))) = 0))) = 0))) = 0;
  WR7: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <* 
       ws\wire_shell.wire_shell_extent |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |
       NOT (SIZEOF (QUERY (el <* eloop\path.edge_list |
       NOT((valid_wireframe_vertex_point
       (el.edge_element.edge_start\vertex_point.vertex_geometry, 
       'CONFIG_CONTROL_DESIGN'))
       AND
       (valid_wireframe_vertex_point
       (el.edge_element.edge_end\vertex_point.vertex_geometry, 
       'CONFIG_CONTROL_DESIGN'))))) = 0)))
       = 0))) = 0))) = 0;
  WR8: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (eloop <* QUERY (wsb <* 
       ws\wire_shell.wire_shell_extent |
       'CONFIG_CONTROL_DESIGN.EDGE_LOOP' IN TYPEOF (wsb)) |
       NOT (SIZEOF (QUERY (con_edges <* QUERY (el <* eloop\path.edge_list |
       'CONFIG_CONTROL_DESIGN.CONIC' IN 
       TYPEOF (el.edge_element\edge_curve.edge_geometry)) |
       NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN
       TYPEOF (con_edges.edge_element\edge_curve.edge_geometry\
       conic.position)))) = 0))) = 0))) = 0))) = 0;
  WR9: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (vloop <* QUERY (wsb <* 
       ws\wire_shell.wire_shell_extent |
       'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF (wsb)) |
       NOT ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN
       TYPEOF (vloop.loop_vertex)))) = 0))) = 0))) = 0;
 WR10: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (ws <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF (sb)) |
       NOT (SIZEOF (QUERY (vloop <* QUERY (wsb <* 
       ws\wire_shell.wire_shell_extent |
       'CONFIG_CONTROL_DESIGN.VERTEX_LOOP' IN TYPEOF (wsb)) |
       NOT(valid_wireframe_vertex_point
       (vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry, 
       'CONFIG_CONTROL_DESIGN')))) = 0))) = 0))) = 0;
 WR11: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (vs <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF (sb)) |
       NOT ('CONFIG_CONTROL_DESIGN.VERTEX_POINT' IN
       TYPEOF (vs\vertex_shell.vertex_shell_extent.loop_vertex))))
       = 0))) = 0; 
 WR12: SIZEOF (QUERY (sbwm <* QUERY (it <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (vs <* QUERY (sb <*
       sbwm\shell_based_wireframe_model.sbwm_boundary |
       'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF (sb)) |
       NOT (valid_wireframe_vertex_point
       (vs\vertex_shell.vertex_shell_extent.loop_vertex\
       vertex_point.vertex_geometry,  'CONFIG_CONTROL_DESIGN'))))
       = 0))) = 0; 
 WR13: SIZEOF (QUERY (mi <* QUERY (item <* SELF\representation.items |
       'CONFIG_CONTROL_DESIGN.MAPPED_ITEM' IN TYPEOF (item)) |
       NOT ('CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))))
       = 0;
END_ENTITY; -- shell_based_wireframe_shape_representation

ENTITY si_unit
SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name   : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents :=
                               dimensions_for_si_unit(SELF.name);
END_ENTITY; -- si_unit

ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage : assembly_component_usage;
  next_usage  : next_assembly_usage_occurrence;
UNIQUE
  UR1 : upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition :=:
       upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition :=:
       next_usage.related_product_definition;
  WR4: upper_usage.related_product_definition :=:
       next_usage.relating_product_definition;
  WR5: NOT ('CONFIG_CONTROL_DESIGN.PROMISSORY_USAGE_OCCURRENCE' IN
       TYPEOF(upper_usage));
END_ENTITY; -- specified_higher_usage_occurrence

ENTITY solid_angle_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN
       TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- solid_angle_measure_with_unit

ENTITY solid_angle_unit
SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0) AND
       (SELF\named_unit.dimensions.mass_exponent = 0) AND
       (SELF\named_unit.dimensions.time_exponent = 0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0);
END_ENTITY; -- solid_angle_unit

ENTITY solid_model
  SUPERTYPE OF (manifold_solid_brep)
  SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- solid_model

ENTITY spherical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY; -- spherical_surface

ENTITY start_request
  SUBTYPE OF (action_request_assignment);
  items : SET [1:?] OF start_request_item;
END_ENTITY; -- start_request

ENTITY start_work
  SUBTYPE OF (action_assignment);
  items : SET [1:?] OF work_item;
END_ENTITY; -- start_work

ENTITY supplied_part_relationship
  SUBTYPE OF (product_definition_relationship);
END_ENTITY; -- supplied_part_relationship

ENTITY surface
  SUPERTYPE OF (ONEOF (elementary_surface, swept_surface, bounded_surface,
    offset_surface, surface_replica))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- surface

ENTITY surface_curve
  SUPERTYPE OF (ONEOF (intersection_curve, seam_curve))
  SUBTYPE OF (curve);
  curve_3d              : curve;
  associated_geometry   : LIST [1:2] OF pcurve_or_surface;
  master_representation : preferred_surface_curve_representation;
DERIVE
  basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: curve_3d.dim = 3;
  WR2: ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(associated_geometry[1]))
       OR (master_representation <> pcurve_s1);
  WR3: ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(associated_geometry[2]))
       OR (master_representation <> pcurve_s2);
  WR4: NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(curve_3d));
END_ENTITY; -- surface_curve

ENTITY surface_of_linear_extrusion
  SUBTYPE OF (swept_surface);
  extrusion_axis : vector;
END_ENTITY; -- surface_of_linear_extrusion

ENTITY surface_of_revolution
  SUBTYPE OF (swept_surface);
  axis_position : axis1_placement;
DERIVE
  axis_line : line := line(axis_position.location,
                           vector (axis_position.z, 1.0));
END_ENTITY; -- surface_of_revolution

ENTITY surface_patch;
  parent_surface : bounded_surface;
  u_transition   : transition_code;
  v_transition   : transition_code;
  u_sense        : BOOLEAN;
  v_sense        : BOOLEAN;
INVERSE
  using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR
                   segments;
WHERE
  WR1: NOT ('CONFIG_CONTROL_DESIGN.CURVE_BOUNDED_SURFACE' IN
       TYPEOF (parent_surface));
END_ENTITY; -- surface_patch

ENTITY surface_replica
  SUBTYPE OF (surface);
  parent_surface : surface;
  transformation : cartesian_transformation_operator_3d;
WHERE
  WR1: acyclic_surface_replica (SELF,parent_surface);
END_ENTITY; -- surface_replica

ENTITY swept_surface
  SUPERTYPE OF (ONEOF (surface_of_linear_extrusion, surface_of_revolution))
  SUBTYPE OF (surface);
  swept_curve : curve;
END_ENTITY; -- swept_surface

ENTITY topological_representation_item
  SUPERTYPE OF (ONEOF (vertex, edge, face_bound, face, connected_edge_set,
    connected_face_set, vertex_shell, wire_shell, (loop ANDOR path)))
  SUBTYPE OF (representation_item);
END_ENTITY; -- topological_representation_item

ENTITY toroidal_surface
  SUBTYPE OF (elementary_surface);
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
END_ENTITY; -- toroidal_surface

ENTITY trimmed_curve
  SUBTYPE OF (bounded_curve);
  basis_curve           : curve;
  trim_1                : SET [1:2] OF trimming_select;
  trim_2                : SET [1:2] OF trimming_select;
  sense_agreement       : BOOLEAN;
  master_representation : trimming_preference;
WHERE (* POD was XOR on both below *)
  WR1: (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
  WR2: (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
END_ENTITY; -- trimmed_curve

ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : text;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF
       (SELF\measure_with_unit.value_component))) OR
       (SELF\measure_with_unit.value_component >= 0);
END_ENTITY; -- uncertainty_measure_with_unit

ENTITY uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY; -- uniform_curve

ENTITY uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY; -- uniform_surface

ENTITY vector
  SUBTYPE OF (geometric_representation_item);
  orientation : direction;
  magnitude   : length_measure;
WHERE
  WR1: magnitude >= 0;
END_ENTITY; -- vector

ENTITY versioned_action_request;
  id          : identifier;
  version     : label;
  purpose     : text;
  description : text;
END_ENTITY; -- versioned_action_request

ENTITY vertex
  SUBTYPE OF (topological_representation_item);
END_ENTITY; -- vertex

ENTITY vertex_loop
  SUBTYPE OF (loop);
  loop_vertex : vertex;
END_ENTITY; -- vertex_loop

ENTITY vertex_point
SUBTYPE OF (vertex, geometric_representation_item);
  vertex_geometry : point;
END_ENTITY; -- vertex_point

ENTITY vertex_shell
  SUBTYPE OF (topological_representation_item);
    vertex_shell_extent : vertex_loop;
END_ENTITY; -- vertex_shell

ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'CONFIG_CONTROL_DESIGN.VOLUME_UNIT' IN TYPEOF(SELF\
       measure_with_unit.unit_component);
END_ENTITY; -- volume_measure_with_unit

ENTITY volume_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 3) AND
       (SELF\named_unit.dimensions.mass_exponent = 0) AND
       (SELF\named_unit.dimensions.time_exponent = 0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0);
END_ENTITY; -- volume_unit

ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component  : OPTIONAL day_in_week_number;
END_ENTITY; -- week_of_year_and_day_date

ENTITY wire_shell
  SUBTYPE OF (topological_representation_item);
    wire_shell_extent : SET [1:?] OF loop;
  WHERE
    wr1: NOT mixed_loop_type_set(wire_shell_extent);
END_ENTITY; -- wire_shell


RULE application_context_requires_ap_definition FOR
  (application_context, application_protocol_definition);
WHERE
  WR1: SIZEOF (QUERY (ac <* application_context |
       NOT (SIZEOF (QUERY (apd <* application_protocol_definition |
       (ac :=: apd.application)
       AND
       (apd.application_interpreted_model_schema_name =
       'config_control_design'))) = 1 ))) = 0;
END_RULE; --application_context_requires_ap_definition

RULE approval_requires_approval_date_time FOR (approval,
         approval_date_time);
WHERE
  WR1: SIZEOF (QUERY ( app <* approval |
       NOT (SIZEOF (QUERY (adt <* approval_date_time |
       app :=: adt.dated_approval)) = 1))) = 0;
END_RULE; -- approval_requires_approval_date_time

RULE approval_requires_approval_person_organization FOR (approval,
         approval_person_organization);
WHERE
  WR1: SIZEOF (QUERY (app <* approval |
       NOT (SIZEOF (QUERY (apo <* approval_person_organization |
       app :=: apo.authorized_approval)) >= 1))) = 0;
END_RULE; -- approval_requires_approval_person_organization

RULE approvals_are_assigned FOR
  (approval, approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (app <* approval |
       NOT (SIZEOF (QUERY (aa <* approval_assignment |
       app :=: aa.assigned_approval )) >= 1 ))) = 0;
END_RULE; -- approvals_are_assigned

RULE as_required_quantity FOR (measure_with_unit);
WHERE
  WR1: SIZEOF (QUERY (m <* measure_with_unit |
       ('CONFIG_CONTROL_DESIGN.DESCRIPTIVE_MEASURE' IN
       TYPEOF (m.value_component)) AND
       (NOT (m.value_component = 'as_required')))) = 0;
END_RULE; -- as_required_quantity

RULE certification_requires_approval FOR (certification,
  cc_design_approval);
WHERE
  WR1: SIZEOF (QUERY (cert <* certification |
       NOT (SIZEOF (QUERY (ccda <* cc_design_approval |
       cert IN ccda.items )) = 1 ))) = 0;
END_RULE; -- certification_requires_approval

RULE certification_requires_date_time FOR
  (certification, cc_design_date_and_time_assignment);
WHERE
  WR1: SIZEOF (QUERY (cert <* certification |
       NOT (SIZEOF (QUERY (ccdta <* cc_design_date_and_time_assignment |
       cert IN ccdta.items )) = 1 ))) = 0;
END_RULE; -- certification_requires_date_time

RULE change_request_requires_approval FOR
  (change_request, cc_design_approval);
WHERE
  WR1: SIZEOF (QUERY (cr <* change_request |
       NOT (SIZEOF (QUERY (ccda <* cc_design_approval |
       cr IN ccda.items )) = 1 ))) = 0;
END_RULE; -- change_request_requires_approval

RULE change_request_requires_date_time FOR
  (change_request, cc_design_date_and_time_assignment);
WHERE
  WR1: SIZEOF (QUERY (cr <* change_request |
       NOT (SIZEOF (QUERY (ccdta <* cc_design_date_and_time_assignment |
       cr IN ccdta.items )) = 1 ))) = 0;
END_RULE; -- change_request_requires_date_time

RULE change_request_requires_person_organization FOR
  (change_request,
  cc_design_person_and_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (cr <* change_request |
       NOT (SIZEOF (QUERY (ccpoa <*
       cc_design_person_and_organization_assignment |
       cr IN ccpoa.items )) >= 1 ))) = 0;
END_RULE; -- change_request_requires_person_organization

RULE change_requires_approval FOR
  (change, cc_design_approval);
WHERE
  WR1: SIZEOF (QUERY (chg <* change |
       NOT (SIZEOF (QUERY (ccda <* cc_design_approval |
       chg IN ccda.items )) = 1 ))) = 0;
END_RULE; -- change_requires_approval

RULE change_requires_date_time FOR
  (change, cc_design_date_and_time_assignment);
WHERE
  WR1: SIZEOF (QUERY (chg <* change |
       NOT (SIZEOF (QUERY (ccdta <* cc_design_date_and_time_assignment |
       (chg IN ccdta.items)
       AND (ccdta.role.name = 'start_date'))) = 1 ))) = 0;
END_RULE; -- change_requires_date_time

RULE compatible_dimension FOR (cartesian_point, direction,
         representation_context, geometric_representation_context);
WHERE
WR1: SIZEOF (QUERY (x <* cartesian_point |
     SIZEOF (QUERY (y <* geometric_representation_context |
     (item_in_context(x,y)) AND (HIINDEX (x.coordinates) <>
     y.coordinate_space_dimension))) >  0)) = 0;
WR2: SIZEOF (QUERY (x <* direction |
     SIZEOF (QUERY (y <* geometric_representation_context |
     (item_in_context(x,y)) AND (HIINDEX (x.direction_ratios) <>
     y.coordinate_space_dimension))) > 0)) = 0;
END_RULE; -- compatible_dimension

RULE configuration_item_requires_approval FOR
  (configuration_item, cc_design_approval);
WHERE
  WR1: SIZEOF (QUERY (ci <* configuration_item |
       NOT (SIZEOF (QUERY (ccda <* cc_design_approval |
       ci IN ccda.items )) = 1 ))) = 0;
END_RULE; -- configuration_item_requires_approval

RULE configuration_item_requires_person_organization FOR
  (configuration_item,
  cc_design_person_and_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (ci <* configuration_item |
       NOT (SIZEOF (QUERY (ccdpoa <*
       cc_design_person_and_organization_assignment |
       ci IN ccdpoa.items )) = 1 ))) = 0;
END_RULE; -- configuration_item_requires_person_organization

RULE contract_requires_approval FOR (contract, cc_design_approval);
WHERE
  WR1: SIZEOF (QUERY (c <* contract |
       NOT (SIZEOF (QUERY (ccda <* cc_design_approval |
       c IN ccda.items )) = 1 ))) = 0;
END_RULE; -- contract_requires_approval

RULE contract_requires_person_organization FOR
  (contract, cc_design_person_and_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (c <* contract |
       NOT (SIZEOF (QUERY (ccdpoa <*
       cc_design_person_and_organization_assignment |
       c IN ccdpoa.items )) = 1 ))) = 0;
END_RULE; -- contract_requires_person_organization

RULE coordinated_assembly_and_shape FOR (next_assembly_usage_occurrence);
WHERE
  WR1: SIZEOF (QUERY (nauo <* next_assembly_usage_occurrence |
       NOT assembly_shape_is_defined(nauo))) = 0;
END_RULE; -- coordinated_assembly_and_shape

RULE dependent_instantiable_action_directive FOR (action_directive);
WHERE
  WR1: SIZEOF (QUERY (ad <* action_directive |
       NOT (SIZEOF (USEDIN (ad, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_action_directive

RULE dependent_instantiable_approval_status FOR (approval_status);
WHERE
WR1: SIZEOF (QUERY (ast <* approval_status |
     NOT (SIZEOF (USEDIN (ast, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_approval_status

RULE dependent_instantiable_certification_type FOR (certification_type);
WHERE
  WR1: SIZEOF (QUERY (ct <* certification_type |
       NOT (SIZEOF (USEDIN (ct, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_certification_type

RULE dependent_instantiable_contract_type FOR (contract_type);
WHERE
  WR1: SIZEOF(QUERY ( ct <* contract_type |
       NOT (SIZEOF (USEDIN (ct, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_contract_type

RULE dependent_instantiable_date FOR (date);
WHERE
  WR1: SIZEOF (QUERY (dt <* date |
       NOT (SIZEOF(USEDIN (dt, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_date

RULE dependent_instantiable_date_time_role FOR (date_time_role);
WHERE
  WR1: SIZEOF (QUERY (dtr <* date_time_role |
       NOT (SIZEOF (USEDIN (dtr, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_date_time_role

RULE dependent_instantiable_document_type FOR (document_type);
WHERE
  WR1: SIZEOF (QUERY (dt <* document_type |
       NOT (SIZEOF (USEDIN (dt, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_document_type

RULE dependent_instantiable_named_unit FOR (named_unit);
WHERE
  WR1: SIZEOF (QUERY (nu <* named_unit |
       NOT (SIZEOF (USEDIN (nu, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_named_unit

RULE dependent_instantiable_person_and_organization_role FOR (
         person_and_organization_role);
WHERE
  WR1: SIZEOF (QUERY (poar <* person_and_organization_role |
       NOT (SIZEOF (USEDIN (poar, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_person_and_organization_role

RULE dependent_instantiable_representation_item FOR (representation_item);
WHERE
  WR1: SIZEOF (QUERY (ri <* representation_item |
       NOT (SIZEOF (USEDIN (ri, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_representation_item

RULE dependent_instantiable_security_classification_level FOR (
         security_classification_level);
WHERE
  WR1: SIZEOF (QUERY (scl <* security_classification_level |
       NOT (SIZEOF (USEDIN (scl, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_security_classification_level

RULE dependent_instantiable_shape_representation FOR (
         shape_representation);
WHERE
  WR1: SIZEOF (QUERY (sr <* shape_representation |
       NOT (SIZEOF(USEDIN(sr, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_shape_representation

RULE design_context_for_property FOR (product_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       (SIZEOF (USEDIN (pd, 'CONFIG_CONTROL_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') +
       QUERY (pdr <* USEDIN (pd, 'CONFIG_CONTROL_DESIGN.' +
       'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
       SIZEOF (USEDIN (pdr, 'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION.' +
       'DEFINITION')) >= 1)) >= 1) AND
       (NOT ('CONFIG_CONTROL_DESIGN.DESIGN_CONTEXT' IN
       TYPEOF (pd.frame_of_reference))))) = 0;
END_RULE; -- design_context_for_property

RULE document_to_product_definition FOR
  (cc_design_specification_reference, product_definition);
WHERE
  WR1: SIZEOF (QUERY (sp <* cc_design_specification_reference |
       NOT (((('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' +
       'RELATING_DOCUMENT' IN
       ROLESOF (sp\document_reference.assigned_document)) AND
       (SIZEOF (QUERY (it <* sp.items |
       NOT('CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION' IN
       TYPEOF (it)))) = 0)))
       OR
       (NOT ('CONFIG_CONTROL_DESIGN.DOCUMENT_RELATIONSHIP.' +
       'RELATING_DOCUMENT' IN
       ROLESOF (sp\document_reference.assigned_document)))))) = 0;
END_RULE; -- document_to_product_definition

RULE effectivity_requires_approval FOR
  (effectivity, cc_design_approval);
WHERE
  WR1: SIZEOF (QUERY (eff <* effectivity |
       NOT (SIZEOF (QUERY (ccda <* cc_design_approval |
       eff IN ccda.items )) = 1 ))) = 0;
END_RULE; -- effectivity_requires_approval

RULE geometric_representation_item_3d FOR
  (geometric_representation_item);
WHERE
  WR1: SIZEOF (QUERY (gri <* geometric_representation_item |
       NOT ((dimension_of (gri) = 3) OR
       (SIZEOF (bag_to_set (USEDIN (gri, '')) - bag_to_set (USEDIN (gri,
       'CONFIG_CONTROL_DESIGN.DEFINITIONAL_REPRESENTATION.ITEMS'))) = 0)
       ))) = 0;
END_RULE; -- geometric_representation_item_3d

RULE dependent_instantiable_parametric_representation_context FOR
  (parametric_representation_context);
WHERE
  WR1: SIZEOF (QUERY (prc <* parametric_representation_context |
       NOT (SIZEOF (USEDIN (prc, '')) >= 1))) = 0;
END_RULE;

RULE global_unit_assignment FOR (global_unit_assigned_context);
WHERE
  WR1: SIZEOF (QUERY (guac <* global_unit_assigned_context |
       NOT (SIZEOF (guac.units) = 3))) = 0;
  WR2: SIZEOF (QUERY (guac <* global_unit_assigned_context |
       NOT ((SIZEOF (QUERY (u <* guac.units |
       'CONFIG_CONTROL_DESIGN.LENGTH_UNIT' IN TYPEOF (u))) = 1) AND
       (SIZEOF (QUERY (u <* guac.units |
       'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_UNIT' IN TYPEOF (u))) = 1) AND
       (SIZEOF (QUERY (u <* guac.units |
       'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_UNIT' IN TYPEOF (u))) = 1
       )))) = 0;
END_RULE; -- global_unit_assignment

RULE no_shape_for_make_from FOR
  (design_make_from_relationship);
WHERE
  WR1: SIZEOF (QUERY (dmfr <* design_make_from_relationship |
       NOT (SIZEOF (QUERY (pd <* USEDIN (dmfr, 'CONFIG_CONTROL_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (pd))) =
       0))) = 0;
END_RULE; -- no_shape_for_make_from

RULE no_shape_for_supplied_part FOR
  (supplied_part_relationship);
WHERE
  WR1: SIZEOF (QUERY (spr <* supplied_part_relationship |
       NOT (SIZEOF (QUERY (pd <* USEDIN (spr, 'CONFIG_CONTROL_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'CONFIG_CONTROL_DESIGN.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (pd))) =
       0))) = 0;
END_RULE; -- no_shape_for_supplied_part

RULE acu_requires_security_classification FOR
  (assembly_component_usage,
   cc_design_security_classification);
WHERE
  WR1: SIZEOF (QUERY (acu <* assembly_component_usage |
       NOT (SIZEOF (QUERY (ccdsc <* cc_design_security_classification |
       acu IN ccdsc.items )) = 1 ))) = 0;
END_RULE; -- acu_requires_security_classification

RULE product_concept_requires_configuration_item FOR
  (product_concept, configuration_item);
WHERE
  WR1: SIZEOF (QUERY (pc <* product_concept |
       NOT (SIZEOF (QUERY (ci <* configuration_item |
       pc :=: ci.item_concept)) >=1 ))) = 0;
END_RULE; -- product_concept_requires_configuration_item

RULE product_definition_requires_approval FOR
  (product_definition, cc_design_approval);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       NOT (SIZEOF (QUERY (ccda <* cc_design_approval |
       pd IN ccda.items )) = 1 ))) = 0;
END_RULE; -- product_definition_requires_approval

RULE product_definition_requires_date_time FOR
  (product_definition, cc_design_date_and_time_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       NOT (SIZEOF (QUERY (ccdta <* cc_design_date_and_time_assignment |
       pd IN ccdta.items )) = 1 ))) = 0;
END_RULE; -- product_definition_requires_date_time

RULE product_definition_requires_person_organization FOR
  (product_definition,
  cc_design_person_and_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       NOT (SIZEOF (QUERY (ccdpoa <*
       cc_design_person_and_organization_assignment |
       pd IN ccdpoa.items )) = 1 ))) = 0;
END_RULE; -- product_definition_requires_person_organization

RULE product_requires_person_organization FOR
  (product, cc_design_person_and_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (prod <* product |
       NOT (SIZEOF (QUERY (ccdpoa <*
       cc_design_person_and_organization_assignment |
       prod IN ccdpoa.items )) = 1 ))) = 0;
END_RULE; -- product_requires_person_organization

RULE product_requires_product_category FOR
  (product, product_related_product_category);
WHERE
  WR1: SIZEOF (QUERY (prod <* product |
       NOT (SIZEOF (QUERY (prpc <* product_related_product_category |
       (prod IN prpc.products) AND
       (prpc.name IN ['assembly', 'inseparable_assembly', 'detail',
       'customer_furnished_equipment']))) = 1))) = 0;
END_RULE; -- product_requires_product_category

RULE product_requires_version FOR (product, product_definition_formation);
WHERE
  WR1: SIZEOF (QUERY (prod <* product |
       NOT (SIZEOF (QUERY (pdf <* product_definition_formation |
       prod :=: pdf.of_product )) >= 1 ))) = 0;
END_RULE; -- product_requires_version

RULE product_version_requires_approval FOR  (product_definition_formation,
  cc_design_approval);
WHERE
  WR1: SIZEOF (QUERY (pdf <* product_definition_formation |
       NOT (SIZEOF (QUERY (ccda <* cc_design_approval |
       pdf IN ccda.items )) = 1 ))) = 0;
END_RULE; -- product_version_requires_approval

RULE product_version_requires_person_organization FOR
  (product_definition_formation,
  cc_design_person_and_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (pdf <* product_definition_formation |
       NOT (SIZEOF (QUERY (ccdpoa <*
       cc_design_person_and_organization_assignment |
       (pdf IN ccdpoa.items) AND (ccdpoa.role.name = 'creator'))) = 1 ))) = 0;
  WR2: SIZEOF (QUERY (pdf <* product_definition_formation |
       NOT (SIZEOF (QUERY (ccdpoa <*
       cc_design_person_and_organization_assignment |
       (pdf IN ccdpoa.items) AND
       (ccdpoa.role.name IN ['design_supplier', 'part_supplier']))) >= 1)))
       = 0;
END_RULE; -- product_version_requires_person_organization

RULE product_version_requires_security_classification FOR
  (product_definition_formation, cc_design_security_classification);
WHERE
  WR1: SIZEOF (QUERY (pdf <* product_definition_formation |
       NOT (SIZEOF (QUERY (ccdsc <* cc_design_security_classification |
       pdf IN ccdsc.items )) = 1 ))) = 0;
END_RULE; -- product_version_requires_security_classification

RULE restrict_action_request_status FOR (action_request_status);
WHERE
  WR1: SIZEOF (QUERY (ars <* action_request_status |
       NOT (ars.status IN
       ['proposed', 'in_work', 'issued', 'hold']))) = 0;
END_RULE; -- restrict_action_request_status

RULE restrict_approval_status FOR (approval_status);
WHERE
  WR1: SIZEOF (QUERY (ast <* approval_status |
       NOT (ast.name IN
       ['approved', 'not_yet_approved', 'disapproved', 'withdrawn']))) = 0;
END_RULE; -- restrict_approval_status

RULE restrict_certification_type FOR (certification_type);
WHERE
  WR1: SIZEOF (QUERY (ct <* certification_type |
       NOT (ct.description IN
       ['design_supplier', 'part_supplier']))) = 0;
END_RULE; -- restrict_certification_type

RULE restrict_contract_type FOR (contract_type);
WHERE
  WR1: SIZEOF (QUERY (ct <* contract_type |
       NOT (ct.description IN ['fixed_price', 'cost_plus']))) = 0;
END_RULE; -- restrict_contract_type

RULE restrict_date_time_role FOR (date_time_role);
WHERE
  WR1: SIZEOF (QUERY (dtr <* date_time_role |
       NOT (dtr.name IN ['creation_date', 'request_date', 'release_date',
       'start_date', 'contract_date', 'certification_date', 'sign_off_date',
       'classification_date', 'declassification_date']))) = 0;
END_RULE; -- restrict_date_time_role

RULE restrict_document_type FOR (document_type);
WHERE
  WR1: SIZEOF (QUERY (dt <* document_type |
       NOT (dt.product_data_type IN
       ['material_specification', 'process_specification',
       'design_specification', 'surface_finish_specification',
       'cad_filename', 'drawing']))) = 0;
END_RULE; -- restrict_document_type

RULE restrict_person_organization_role FOR (person_and_organization_role);
WHERE
  WR1: SIZEOF (QUERY (por <* person_and_organization_role |
       NOT (por.name IN ['request_recipient', 'initiator', 'part_supplier',
       'design_supplier', 'configuration_manager', 'contractor',
       'classification_officer', 'creator', 'design_owner']))) = 0;
END_RULE; -- restrict_person_organization_role

RULE restrict_product_category_value FOR (product_related_product_category);
WHERE
  WR1: SIZEOF (QUERY (prpc <* product_related_product_category |
       NOT (prpc.name IN ['assembly', 'detail', 
       'customer_furnished_equipment', 'inseparable_assembly', 'cast',
       'coined', 'drawn', 'extruded', 'forged', 'formed', 'machined',
       'molded', 'rolled', 'sheared'])))
       = 0;
END_RULE; -- restrict_product_category_value

RULE restrict_security_classification_level FOR
  (security_classification_level);
WHERE
  WR1: SIZEOF (QUERY (scl <* security_classification_level |
       NOT (scl.name IN ['unclassified', 'classified', 'proprietary',
       'confidential', 'secret', 'top_secret']))) = 0;
END_RULE; -- restrict_security_classification_level

RULE security_classification_optional_date_time FOR
  (security_classification, cc_design_date_and_time_assignment);
WHERE
  WR1: SIZEOF (QUERY (sc <* security_classification |
       NOT (SIZEOF (QUERY (ccdta <* cc_design_date_and_time_assignment |
       (sc IN ccdta.items) AND
       ('declassification_date' = ccdta.role.name))) <= 1 ))) = 0;
END_RULE; -- security_classification_optional_date_time

RULE security_classification_requires_approval FOR
  (security_classification, cc_design_approval);
WHERE
  WR1: SIZEOF (QUERY (sc <* security_classification |
       NOT (SIZEOF (QUERY (ccda <* cc_design_approval |
       sc IN ccda.items )) = 1 ))) = 0;
END_RULE; -- security_classification_requires_approval

RULE security_classification_requires_date_time FOR
  (security_classification, cc_design_date_and_time_assignment);
WHERE
  WR1: SIZEOF (QUERY (sc <* security_classification |
       NOT (SIZEOF (QUERY (ccdta <* cc_design_date_and_time_assignment |
       (sc IN ccdta.items) AND
       ('classification_date' = ccdta.role.name))) = 1 ))) = 0;
END_RULE; -- security_classification_requires_date_time

RULE security_classification_requires_person_organization FOR
  (security_classification,
  cc_design_person_and_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (sc <* security_classification |
       NOT (SIZEOF (QUERY (ccdpoa <*
       cc_design_person_and_organization_assignment |
       sc IN ccdpoa.items )) = 1 ))) = 0;
END_RULE; -- security_classification_requires_person_organization

RULE start_request_requires_approval FOR
  (start_request, cc_design_approval);
WHERE
  WR1: SIZEOF (QUERY (sr <* start_request |
       NOT (SIZEOF (QUERY (ccda <* cc_design_approval |
       sr IN ccda.items )) = 1 ))) = 0;
END_RULE; -- start_request_requires_approval

RULE start_request_requires_date_time FOR
  (start_request, cc_design_date_and_time_assignment);
WHERE
  WR1: SIZEOF (QUERY (sr <* start_request |
       NOT (SIZEOF (QUERY (ccdta <* cc_design_date_and_time_assignment |
       sr IN ccdta.items )) = 1 ))) = 0;
END_RULE; -- start_request_requires_date_time

RULE start_request_requires_person_organization FOR (start_request,
  cc_design_person_and_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (sr <* start_request |
       NOT (SIZEOF (QUERY (ccdpoa <*
       cc_design_person_and_organization_assignment |
       sr IN ccdpoa.items )) >= 1 ))) = 0;
END_RULE; -- start_request_requires_person_organization

RULE start_work_requires_approval FOR
  (start_work, cc_design_approval);
WHERE
  WR1: SIZEOF (QUERY (sw <* start_work |
       NOT (SIZEOF (QUERY (ccda <* cc_design_approval |
       sw IN ccda.items )) = 1 ))) = 0;
END_RULE; -- start_work_requires_approval

RULE start_work_requires_date_time FOR
  (start_work, cc_design_date_and_time_assignment);
WHERE
  WR1: SIZEOF (QUERY (sw <* start_work |
       NOT (SIZEOF (QUERY (ccdta <* cc_design_date_and_time_assignment |
       (sw IN ccdta.items) 
       AND (ccdta.role.name = 'start_date'))) = 1 ))) = 0;
END_RULE; -- start_work_requires_date_time

RULE subtype_mandatory_action FOR (action);
WHERE
  WR1: SIZEOF (QUERY (act <* action |
       NOT ('CONFIG_CONTROL_DESIGN.DIRECTED_ACTION' IN TYPEOF(act)))) = 0;
END_RULE; -- subtype_mandatory_action

RULE subtype_mandatory_effectivity FOR
  (effectivity);
WHERE
  WR1: SIZEOF (QUERY (eff <* effectivity |
       NOT ((SIZEOF (['CONFIG_CONTROL_DESIGN.SERIAL_NUMBERED_EFFECTIVITY',
       'CONFIG_CONTROL_DESIGN.LOT_EFFECTIVITY',
       'CONFIG_CONTROL_DESIGN.DATED_EFFECTIVITY'] *
       TYPEOF (eff)) = 1) AND
       ('CONFIG_CONTROL_DESIGN.CONFIGURATION_EFFECTIVITY' IN TYPEOF(eff)))))
       = 0;
END_RULE; -- subtype_mandatory_effectivity

RULE subtype_mandatory_product_context FOR (product_context);
WHERE
  WR1: SIZEOF (QUERY (pc <* product_context |
       NOT ('CONFIG_CONTROL_DESIGN.MECHANICAL_CONTEXT' IN TYPEOF(pc)))) = 0;
END_RULE; -- subtype_mandatory_product_context

RULE subtype_mandatory_product_definition_formation FOR
  (product_definition_formation);
WHERE
  WR1: SIZEOF (QUERY (pdf <* product_definition_formation |
       NOT ('CONFIG_CONTROL_DESIGN.' +
       'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE' IN
       TYPEOF(pdf)))) = 0;
END_RULE; -- subtype_mandatory_product_definition_formation

RULE subtype_mandatory_product_definition_usage FOR
  (product_definition_usage);
WHERE
  WR1: SIZEOF (QUERY (pdu <* product_definition_usage |
       NOT ('CONFIG_CONTROL_DESIGN.' +
       'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdu)))) = 0;
END_RULE; -- subtype_mandatory_product_definition_usage

RULE subtype_mandatory_representation FOR (representation);
WHERE
  WR1: SIZEOF (QUERY (rep <* representation |
       NOT ('CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION' IN TYPEOF(rep))))
       = 0;
END_RULE; -- subtype_mandatory_representation

RULE subtype_mandatory_representation_context FOR
  (representation_context);
WHERE
  WR1: SIZEOF (QUERY (rep_cntxt <* representation_context |
       NOT ('CONFIG_CONTROL_DESIGN.GEOMETRIC_REPRESENTATION_CONTEXT' IN
       TYPEOF(rep_cntxt)))) = 0;
END_RULE; -- subtype_mandatory_representation_context

RULE subtype_mandatory_shape_representation FOR
  (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (sr <* shape_representation |
       NOT ((SIZEOF (['CONFIG_CONTROL_DESIGN.' +
       'ADVANCED_BREP_SHAPE_REPRESENTATION',
       'CONFIG_CONTROL_DESIGN.FACETED_BREP_SHAPE_REPRESENTATION',
       'CONFIG_CONTROL_DESIGN.MANIFOLD_SURFACE_SHAPE_REPRESENTATION',
       'CONFIG_CONTROL_DESIGN.EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION',
       'CONFIG_CONTROL_DESIGN.SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION',
       'CONFIG_CONTROL_DESIGN.' +
       'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
       'CONFIG_CONTROL_DESIGN.' +
       'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION'] *
       TYPEOF (sr)) = 1) OR
       (SIZEOF (QUERY (it <* sr\representation.items |
       NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF (it))))
       = 0) OR
       (SIZEOF (QUERY (sdr <* QUERY (pdr <* USEDIN (sr,
       'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
       'USED_REPRESENTATION') |
       'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
       TYPEOF (pdr)) | 
       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.SHAPE_ASPECT',
       'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT_RELATIONSHIP'] * TYPEOF
       (sdr.definition)) = 1))) = 0)))) = 0;
END_RULE; -- subtype_mandatory_shape_representation

RULE unique_version_change_order_rule FOR (change);
WHERE
  WR1: SIZEOF (QUERY (c <* change |
       NOT (unique_version_change_order (c.assigned_action)))) = 0;
END_RULE; -- unique_version_change_order_rule

RULE versioned_action_request_requires_solution FOR
  (versioned_action_request, action_request_solution);
WHERE
  WR1: SIZEOF (QUERY (ar <* versioned_action_request |
       NOT (SIZEOF (QUERY (ars <* action_request_solution |
       ar :=: ars.request)) >= 1))) = 0;
END_RULE; -- versioned_action_request_requires_solution

RULE versioned_action_request_requires_status FOR
  (versioned_action_request, action_request_status);
WHERE
  WR1: SIZEOF (QUERY (ar <* versioned_action_request |
       NOT (SIZEOF (QUERY (ars <* action_request_status |
       ar :=: ars.assigned_request)) = 1))) = 0;
END_RULE; -- versioned_action_request_requires_status


FUNCTION acyclic_curve_replica
  (rep: curve_replica; parent: curve): BOOLEAN;
IF NOT ('CONFIG_CONTROL_DESIGN.CURVE_REPLICA' IN TYPEOF(parent)) THEN
  RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
  RETURN(FALSE);
ELSE
  RETURN(acyclic_curve_replica(rep,parent\curve_replica.parent_curve));
END_IF;

END_FUNCTION; -- acyclic_curve_replica

FUNCTION acyclic_mapped_representation
  (parent_set: SET OF representation;
  children_set: SET OF representation_item): BOOLEAN;

LOCAL
  i : INTEGER;
  x : SET OF representation_item;
  y : SET OF representation_item;
END_LOCAL;
x := QUERY ( z <* children_set | ('CONFIG_CONTROL_DESIGN.MAPPED_ITEM'
    IN TYPEOF(z)) );
IF SIZEOF(x) > 0 THEN
  REPEAT i := 1 TO HIINDEX(x) BY 1;
    IF x[i]\mapped_item.mapping_source.mapped_representation IN
        parent_set THEN
      RETURN(FALSE);
    END_IF;
    IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item
        .mapping_source.mapped_representation,x[i]\mapped_item.
        mapping_source.mapped_representation.items) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
x := children_set - x;
IF SIZEOF(x) > 0 THEN
  REPEAT i := 1 TO HIINDEX(x) BY 1;
    y := QUERY ( z <* bag_to_set(USEDIN(x[i],'')) | (
        'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
    IF NOT acyclic_mapped_representation(parent_set,y) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
RETURN(TRUE);

END_FUNCTION; -- acyclic_mapped_representation

FUNCTION acyclic_point_replica
  (rep: point_replica; parent: point): BOOLEAN;
IF NOT ('CONFIG_CONTROL_DESIGN.POINT_REPLICA' IN TYPEOF(parent)) THEN
  RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
  RETURN(FALSE);
ELSE
  RETURN(acyclic_point_replica(rep,parent\point_replica.parent_pt));
END_IF;

END_FUNCTION; -- acyclic_point_replica

FUNCTION acyclic_product_category_relationship
  (relation: product_category_relationship;
  children: SET OF product_category): LOGICAL;

LOCAL
  i              : INTEGER;
  x              : SET OF product_category_relationship;
  local_children : SET OF product_category;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(children) BY 1;
  IF relation.category :=: children[i] THEN
    RETURN(FALSE);
  END_IF;
END_REPEAT;
x := bag_to_set(USEDIN(relation.category,'CONFIG_CONTROL_DESIGN.' +
    'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
local_children := children + relation.category;
IF SIZEOF(x) > 0 THEN
  REPEAT i := 1 TO HIINDEX(x) BY 1;
    IF NOT acyclic_product_category_relationship(x[i],local_children)
         THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
RETURN(TRUE);

END_FUNCTION; -- acyclic_product_category_relationship

FUNCTION acyclic_product_definition_relationship
  (relation: product_definition_relationship;
  relatives: SET OF product_definition;
  specific_relation: STRING): LOGICAL;

LOCAL
  i               : INTEGER;
  x               : SET OF product_definition_relationship;
  local_relatives : SET OF product_definition;
END_LOCAL;
REPEAT i := 1 TO HIINDEX(relatives) BY 1;
  IF relation.relating_product_definition :=: relatives[i] THEN
    RETURN(FALSE);
  END_IF;
END_REPEAT;
x := bag_to_set(USEDIN(relation.relating_product_definition,
    specific_relation));
local_relatives := relatives + relation.relating_product_definition;
IF SIZEOF(x) > 0 THEN
  REPEAT i := 1 TO HIINDEX(x) BY 1;
    IF NOT acyclic_product_definition_relationship(x[i],
        local_relatives,specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
RETURN(TRUE);

END_FUNCTION; -- acyclic_product_definition_relationship

FUNCTION acyclic_surface_replica
  (rep: surface_replica; parent: surface): BOOLEAN;
IF NOT ('CONFIG_CONTROL_DESIGN.SURFACE_REPLICA' IN TYPEOF(parent))
     THEN
  RETURN(TRUE);
END_IF;
IF parent :=: rep THEN
  RETURN(FALSE);
ELSE
  RETURN(acyclic_surface_replica(rep,parent\surface_replica.
      parent_surface));
END_IF;

END_FUNCTION; -- acyclic_surface_replica

FUNCTION assembly_shape_is_defined
  (assy: next_assembly_usage_occurrence) : BOOLEAN;
  LOCAL
        sdr_set : SET OF shape_definition_representation := [];
        srr_set : SET OF shape_representation_relationship := [];
  END_LOCAL;

  -- Gather all instances of shape_definition_representation where the
  -- component part has a representation defined for it.

  sdr_set := QUERY (pdr <* bag_to_set (USEDIN
             (assy.related_product_definition,
             'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
             'DEFINITION.DEFINITION')) |
             'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
             TYPEOF (pdr)) +
             QUERY (pdr <* bag_to_set (
             USEDIN (assy.related_product_definition,
             'CONFIG_CONTROL_DESIGN.' +
             'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION.' +
             'DEFINITION.RELATED_PRODUCT_DEFINITION')) |
             'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
             TYPEOF (pdr));

  -- If there is a representation defined for the component part

  IF SIZEOF (sdr_set) > 0 THEN

    -- For each representation of the shape of the component part gather all
    -- instances of shape_representation_relationship where the
    -- representation of component part is related to another 
    -- representation.

    REPEAT i := 1 TO HIINDEX (sdr_set);
      srr_set := QUERY (rr <* bag_to_set (
                 USEDIN (sdr_set[i]\
                 property_definition_representation.used_representation,
                 'CONFIG_CONTROL_DESIGN.REPRESENTATION_RELATIONSHIP.REP_2')) |
                 'CONFIG_CONTROL_DESIGN.SHAPE_REPRESENTATION_RELATIONSHIP' IN
                 TYPEOF (rr));

      -- If there is a shape_representation_relationship where the component
      -- part's shape_representation is related to another shape_-
      -- representation.

      IF SIZEOF (srr_set) > 0 THEN

        -- For each shape_representation_relationship in that set

        REPEAT j := 1 TO HIINDEX (srr_set);

          -- If the other shape_representation in the shape_representation_-
          -- relationship is the  shape_representation of the assembly
          -- product_definition in at least one instance.

          IF SIZEOF (QUERY (pdr <* bag_to_set (USEDIN
            (srr_set[j]\representation_relationship.rep_1,
            'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
            'USED_REPRESENTATION')) |
            'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
            TYPEOF (pdr)) *
            QUERY (pdr <* bag_to_set (
            USEDIN (assy.relating_product_definition,
            'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
            'USED_REPRESENTATION.DEFINITION')) |
            'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION'
            IN TYPEOF (pdr))) >= 1 THEN

            -- If the shape_representation_relationship and the product_-
            -- definition_relationship of each occurrence of the component
            -- and assembly relationship is not given via the
            -- context_dependent_shape_representation then return FALSE


            IF SIZEOF (QUERY (cdsr <*
              USEDIN (assy, 'CONFIG_CONTROL_DESIGN.' +
              'CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.' +
              'REPRESENTED_PRODUCT_RELATION') |
              NOT ((cdsr.represented_product_relation.definition :=: assy) AND
              (cdsr.representation_relation :=: srr_set[j])))) > 0
              THEN RETURN (FALSE);
            END_IF;
          END_IF;
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;

  -- If the shape of the component is not specified or there are no
  -- violations then return TRUE

  RETURN (TRUE);
END_FUNCTION; -- assembly_shape_is_defined

FUNCTION associated_surface
  (arg: pcurve_or_surface): surface;

LOCAL
  surf : surface;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(arg) THEN
  surf := arg.basis_surface;
ELSE
  surf := arg;
END_IF;
RETURN(surf);

END_FUNCTION; -- associated_surface

FUNCTION bag_to_set
  (the_bag : BAG OF GENERIC:intype) : SET OF GENERIC:intype;
  LOCAL
    the_set : SET OF GENERIC:intype := [];
    i       : INTEGER;
  END_LOCAL;

  IF SIZEOF (the_bag) > 0 THEN
    REPEAT i := 1 to HIINDEX (the_bag);
      the_set := the_set + the_bag[i];
    END_REPEAT;
  END_IF;

  RETURN (the_set);

END_FUNCTION; -- bag_to_set

FUNCTION base_axis
  (dim: INTEGER;
  axis1, axis2, axis3: direction): LIST [2:3] OF direction;

LOCAL
  u      : LIST [2:3] OF direction;
  vec    : direction;
  factor : REAL;
END_LOCAL;
IF dim = 3 THEN
  u[3] := NVL(normalise(axis3),direction([0,0,1]));
  u[1] := first_proj_axis(u[3],axis1);
  u[2] := second_proj_axis(u[3],u[1],axis2);
ELSE
  u[3] := ?;
  IF EXISTS(axis1) THEN
    u[1] := normalise(axis1);
    u[2] := orthogonal_complement(u[1]);
    IF EXISTS(axis2) THEN
      factor := dot_product(axis2,u[2]);
      IF factor < 0 THEN
        u[2].direction_ratios[1] := -u[2].direction_ratios[1];
        u[2].direction_ratios[2] := -u[2].direction_ratios[2];
      END_IF;
    END_IF;
  ELSE
    IF EXISTS(axis2) THEN
      u[2] := normalise(axis2);
      u[1] := orthogonal_complement(u[2]);
      u[1].direction_ratios[1] := -u[1].direction_ratios[1];
      u[1].direction_ratios[2] := -u[1].direction_ratios[2];
    ELSE
      u[1].direction_ratios[1] := 1;
      u[1].direction_ratios[2] := 0;
      u[2].direction_ratios[1] := 0;
      u[2].direction_ratios[2] := 1;
    END_IF;
  END_IF;
END_IF;
RETURN(u);

END_FUNCTION; -- base_axis

FUNCTION basis_curve_check
  (cv: curve; schema_name : STRING) : BOOLEAN;

  -- let those types pass that do not have references to curves

  IF SIZEOF ([schema_name + '.B_SPLINE_CURVE',
    schema_name + '.CONIC',
    schema_name + '.LINE',
    schema_name + '.POLYLINE'] * TYPEOF (cv)) = 1 THEN
    RETURN(TRUE);
  ELSE

    -- check in case curve_replica is the type of the input curve

    IF schema_name + '.CURVE_REPLICA' IN TYPEOF (cv) THEN
      RETURN (basis_curve_check(cv\curve_replica.parent_curve, schema_name));
    ELSE

      --check in case offset_curve_3d is the type of the input curve

      IF schema_name + '.OFFSET_CURVE_3D' IN TYPEOF (cv) THEN
        RETURN(basis_curve_check
        (cv\offset_curve_3d.basis_curve, schema_name));
      ELSE

          -- check in case pcurve is the type of the input curve

        IF schema_name + '.PCURVE' IN TYPEOF(cv) THEN
          IF SIZEOF ([schema_name + '.B_SPLINE_CURVE',
            schema_name + '.CONIC',
            schema_name + '.LINE',
            schema_name + '.POLYLINE'] *
            TYPEOF (cv\pcurve.reference_to_curve\representation.items[1]))
            = 1 THEN
            RETURN (basis_surface_check (cv\pcurve.basis_surface,
            schema_name));
          ELSE
            IF schema_name + '.CURVE_REPLICA'
              IN TYPEOF
              (cv\pcurve.reference_to_curve\representation.items[1]) THEN
              RETURN ((basis_curve_check
              (cv\pcurve.reference_to_curve\representation.items[1],
              schema_name)) AND
              (basis_surface_check (cv\pcurve.basis_surface,
              schema_name)));
            END_IF;
          END_IF;
          ELSE

          --check in case surface_curve is the type of the input curve

          IF schema_name + '.SURFACE_CURVE' IN TYPEOF(cv) THEN
            IF SIZEOF ([schema_name + '.B_SPLINE_CURVE',
              schema_name + '.CONIC',
              schema_name + '.LINE',
              schema_name + '.POLYLINE'] *
              TYPEOF (cv\surface_curve.curve_3d)) = 1 THEN

              REPEAT i := 1 TO SIZEOF (cv\surface_curve.associated_geometry);


                -- do for one or two associated_geometrys:

                IF schema_name + '.SURFACE' IN
                  TYPEOF (cv\surface_curve.associated_geometry[i]) THEN
                  IF NOT basis_surface_check
                    (cv\surface_curve.associated_geometry[i],
                    schema_name) THEN
                    RETURN(FALSE);
                  END_IF;
                ELSE
                  IF schema_name + '.PCURVE' IN
                    TYPEOF (cv\surface_curve.associated_geometry[i]) THEN
                    IF NOT basis_curve_check
                      (cv\surface_curve.associated_geometry[i],
                      schema_name) THEN RETURN(FALSE);
                    END_IF;
                  END_IF;
                END_IF;
              END_REPEAT;
            ELSE
              IF schema_name + '.CURVE_REPLICA' IN TYPEOF
                (cv\surface_curve.curve_3d) THEN
                IF NOT (basis_curve_check
                  (cv\curve_replica.parent_curve, schema_name)) THEN
                  RETURN (FALSE);
                END_IF;
              ELSE
                IF schema_name + '.OFFSET_CURVE_3D' IN TYPEOF
                  (cv\surface_curve.curve_3d) THEN
                  IF NOT (basis_curve_check
                    (cv\offset_curve_3d.basis_curve, schema_name)) THEN
                    RETURN (FALSE);
                  END_IF;
                ELSE
                  REPEAT i := 1 TO SIZEOF
                  (cv\surface_curve.associated_geometry);

                    -- do for one or two associated_geometrys:

                    IF schema_name + '.SURFACE' IN
                      TYPEOF (cv\surface_curve.associated_geometry[i]) THEN
                      IF NOT basis_surface_check
                        (cv\surface_curve.associated_geometry[i],
                        schema_name) THEN
                        RETURN(FALSE);
                      END_IF;
                    ELSE
                      IF schema_name + '.PCURVE' IN
                        TYPEOF (cv\surface_curve.associated_geometry[i]) THEN

                        IF NOT basis_curve_check
                          (cv\surface_curve.associated_geometry[i],
                          schema_name) THEN
                          RETURN(FALSE);
                        END_IF;
                      END_IF;
                    END_IF;
                  END_REPEAT;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION; -- basis_curve_check

FUNCTION basis_surface_check
  (surf : surface; schema_name : STRING) : BOOLEAN;


-- let those surface types pass that do not have references to surfaces

  IF SIZEOF([schema_name + '.B_SPLINE_SURFACE',
    schema_name + '.ELEMENTARY_SURFACE'] * TYPEOF(surf)) = 1 THEN
    RETURN(TRUE);
  ELSE
    IF schema_name + '.SWEPT_SURFACE' IN TYPEOF (surf) THEN
      RETURN (basis_curve_check
      (surf\swept_surface.swept_curve, schema_name));
    ELSE

      -- check in case offset_surface is the type of the input surface

      IF schema_name + '.OFFSET_SURFACE' IN TYPEOF (surf) THEN
        RETURN(basis_surface_check
        (surf\offset_surface.basis_surface, schema_name));
      ELSE

        -- check in case surface_replica is the type of the input surface

        IF schema_name + '.SURFACE REPLICA' IN TYPEOF(surf) THEN
          RETURN(basis_surface_check
          (surf\surface_replica.parent_surface, schema_name));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION; -- basis_surface_check

FUNCTION boolean_choose
  (b: BOOLEAN;
  choice1, choice2: GENERIC:item): GENERIC:item;
IF b THEN
  RETURN(choice1);
ELSE
  RETURN(choice2);
END_IF;

END_FUNCTION; -- boolean_choose

FUNCTION build_2axes
  (ref_direction: direction): LIST [2:2] OF direction;

LOCAL
  u : LIST [2:2] OF direction;
END_LOCAL;
u[1] := NVL(normalise(ref_direction),direction([1,0]));
u[2] := orthogonal_complement(u[1]);
RETURN(u);

END_FUNCTION; -- build_2axes

FUNCTION build_axes
  (axis, ref_direction: direction): LIST [3:3] OF direction;

LOCAL
  u : LIST [3:3] OF direction;
END_LOCAL;
u[3] := NVL(normalise(axis),direction([0,0,1]));
u[1] := first_proj_axis(u[3],ref_direction);
u[2] := normalise(cross_product(u[3],u[1])).orientation;
RETURN(u);

END_FUNCTION; -- build_axes

FUNCTION cc_design_date_time_correlation
  (e : cc_design_date_and_time_assignment ) : BOOLEAN;
  LOCAL
    dt_role : STRING;
  END_LOCAL;
    dt_role := e\date_and_time_assignment.role.name;
  CASE dt_role OF
    'creation_date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                'CONFIG_CONTROL_DESIGN.' +
                                'PRODUCT_DEFINITION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'request_date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                ['CONFIG_CONTROL_DESIGN.CHANGE_REQUEST' +
                                'CONFIG_CONTROL_DESIGN.START_REQUEST'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'release_date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                ['CONFIG_CONTROL_DESIGN.CHANGE' +
                                'CONFIG_CONTROL_DESIGN.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'start_date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                ['CONFIG_CONTROL_DESIGN.CHANGE' +
                                'CONFIG_CONTROL_DESIGN.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'sign_off_date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                'CONFIG_CONTROL_DESIGN.' +
                                'APPROVAL_PERSON_ORGANIZATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'contract_date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                'CONFIG_CONTROL_DESIGN.CONTRACT'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'certification_date'    : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                'CONFIG_CONTROL_DESIGN.CERTIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'classification_date'   : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                'CONFIG_CONTROL_DESIGN.' +
                                'SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'declassification_date' : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                'CONFIG_CONTROL_DESIGN.' +
                                'SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);
END_FUNCTION; -- cc_design_date_time_correlation

FUNCTION cc_design_person_and_organization_correlation
  (e : cc_design_person_and_organization_assignment ) : BOOLEAN;
  LOCAL
    po_role : STRING;
  END_LOCAL;
    po_role := e\person_and_organization_assignment.role.name;
  CASE po_role OF
    'request_recipient'      : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 SIZEOF(['CONFIG_CONTROL_DESIGN.' +
                                 'CHANGE_REQUEST',
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'START_REQUEST'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN(FALSE);
                               END_IF;
    'initiator'              : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 SIZEOF(['CONFIG_CONTROL_DESIGN.' +
                                 'CHANGE_REQUEST',
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'START_REQUEST',
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'START_WORK',
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'CHANGE'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN(FALSE);
                               END_IF;
    'creator'                : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 SIZEOF (['CONFIG_CONTROL_DESIGN.' +
                                 'PRODUCT_DEFINITION_FORMATION',
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'PRODUCT_DEFINITION'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN (FALSE);
                               END_IF;
    'part_supplier'          : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'PRODUCT_DEFINITION_FORMATION'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
    'design_supplier'        : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'PRODUCT_DEFINITION_FORMATION'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
    'design_owner'           : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'CONFIG_CONTROL_DESIGN.PRODUCT'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
    'configuration_manager'  : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'CONFIGURATION_ITEM'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
    'contractor'             : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'CONFIG_CONTROL_DESIGN.CONTRACT'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
    'classification_officer' : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'CONFIG_CONTROL_DESIGN.' +
                                 'SECURITY_CLASSIFICATION'
                                 IN TYPEOF (x))) THEN
                                 RETURN(FALSE);
                               END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);
END_FUNCTION; -- cc_design_person_and_organization_correlation

FUNCTION conditional_reverse
  (p: BOOLEAN; an_item: reversible_topology): reversible_topology;
IF p THEN
  RETURN(an_item);
ELSE
  RETURN(topology_reversed(an_item));
END_IF;

END_FUNCTION; -- conditional_reverse

FUNCTION constraints_composite_curve_on_surface
  (c: composite_curve_on_surface): BOOLEAN;

LOCAL
  n_segments : INTEGER := SIZEOF(c.segments);
END_LOCAL;
REPEAT k := 1 TO n_segments BY 1;
  IF ((NOT ('CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c\composite_curve
      .segments[k].parent_curve))) AND (NOT (
      'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c\composite_curve
      .segments[k].parent_curve)))) AND (NOT (
      'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\
      composite_curve.segments[k].parent_curve))) THEN
    RETURN(FALSE);
  END_IF;
END_REPEAT;
RETURN(TRUE);

END_FUNCTION; -- constraints_composite_curve_on_surface

FUNCTION constraints_geometry_shell_based_surface_model
  (m: shell_based_surface_model): BOOLEAN;

LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT j := 1 TO SIZEOF(m.sbsm_boundary) BY 1;
  IF (NOT ('CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(m.
      sbsm_boundary[j]))) AND (NOT (
      'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(m.sbsm_boundary[j])))
       THEN
    result := FALSE;
    RETURN(result);
  END_IF;
END_REPEAT;
RETURN(result);

END_FUNCTION; -- constraints_geometry_shell_based_surface_model

FUNCTION constraints_geometry_shell_based_wireframe_model
  (m: shell_based_wireframe_model): BOOLEAN;

LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT j := 1 TO SIZEOF(m.sbwm_boundary) BY 1;
  IF (NOT ('CONFIG_CONTROL_DESIGN.WIRE_SHELL' IN TYPEOF(m.
      sbwm_boundary[j]))) AND (NOT (
      'CONFIG_CONTROL_DESIGN.VERTEX_SHELL' IN TYPEOF(m.sbwm_boundary[j])))
       THEN
    result := FALSE;
    RETURN(result);
  END_IF;
END_REPEAT;
RETURN(result);

END_FUNCTION; -- constraints_geometry_shell_based_wireframe_model

FUNCTION constraints_param_b_spline
  (degree, up_knots, up_cp: INTEGER;
  knot_mult: LIST OF INTEGER;
  knots: LIST OF parameter_value): BOOLEAN;

LOCAL
  k      : INTEGER;
  l      : INTEGER;
  sum    : INTEGER;
  result : BOOLEAN := TRUE;
END_LOCAL;
sum := knot_mult[1];
REPEAT i := 2 TO up_knots BY 1;
  sum := sum + knot_mult[i];
END_REPEAT;
IF (((degree < 1) OR (up_knots < 2)) OR (up_cp < degree)) OR (sum <> (
    (degree + up_cp) + 2)) THEN
  result := FALSE;
  RETURN(result);
END_IF;
k := knot_mult[1];
IF (k < 1) OR (k > (degree + 1)) THEN
  result := FALSE;
  RETURN(result);
END_IF;
REPEAT i := 2 TO up_knots BY 1;
  IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
    result := FALSE;
    RETURN(result);
  END_IF;
  k := knot_mult[i];
  IF (i < up_knots) AND (k > degree) THEN
    result := FALSE;
    RETURN(result);
  END_IF;
  IF (i = up_knots) AND (k > (degree + 1)) THEN
    result := FALSE;
    RETURN(result);
  END_IF;
END_REPEAT;
RETURN(result);

END_FUNCTION; -- constraints_param_b_spline

FUNCTION constraints_rectangular_composite_surface
  (s: rectangular_composite_surface): BOOLEAN;
REPEAT i := 1 TO s.n_u BY 1;
  REPEAT j := 1 TO s.n_v BY 1;
    IF NOT (('CONFIG_CONTROL_DESIGN.B_SPLINE_SURFACE' IN TYPEOF(s.
        segments[i][j].parent_surface)) OR (
        'CONFIG_CONTROL_DESIGN.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s
        .segments[i][j].parent_surface))) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_REPEAT;
REPEAT i := 1 TO s.n_u - 1 BY 1;
  REPEAT j := 1 TO s.n_v BY 1;
    IF s.segments[i][j].u_transition = discontinuous THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_REPEAT;
REPEAT i := 1 TO s.n_u BY 1;
  REPEAT j := 1 TO s.n_v - 1 BY 1;
    IF s.segments[i][j].v_transition = discontinuous THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_REPEAT;
RETURN(TRUE);

END_FUNCTION; -- constraints_rectangular_composite_surface

FUNCTION cross_product
  (arg1, arg2: direction): vector;

LOCAL
  v2     : LIST [3:3] OF REAL;
  v1     : LIST [3:3] OF REAL;
  mag    : REAL;
  res    : direction;
  result : vector;
END_LOCAL;
IF ((NOT EXISTS(arg1)) OR (arg1.dim = 2)) OR ((NOT EXISTS(arg2)) OR (
    arg2.dim = 2)) THEN
  RETURN(?);
ELSE
  BEGIN
    v1 := normalise(arg1).direction_ratios;
    v2 := normalise(arg2).direction_ratios;
    res.direction_ratios[1] := (v1[2] * v2[3]) - (v1[3] * v2[2]);
    res.direction_ratios[2] := (v1[3] * v2[1]) - (v1[1] * v2[3]);
    res.direction_ratios[3] := (v1[1] * v2[2]) - (v1[2] * v2[1]);
    mag := 0;
    REPEAT i := 1 TO 3 BY 1;
      mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
    END_REPEAT;
    IF mag > 0 THEN
      result.orientation := res;
      result.magnitude := SQRT(mag);
    ELSE
      result.orientation := arg1;
      result.magnitude := 0;
    END_IF;
    RETURN(result);
  END;
END_IF;

END_FUNCTION; -- cross_product

FUNCTION curve_weights_positive
  (b: rational_b_spline_curve): BOOLEAN;

LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 0 TO b.upper_index_on_control_points BY 1;
  IF b.weights[i] <= 0 THEN
    result := FALSE;
    RETURN(result);
  END_IF;
END_REPEAT;
RETURN(result);

END_FUNCTION; -- curve_weights_positive

FUNCTION derive_dimensional_exponents
  (x: unit): dimensional_exponents;

LOCAL
  result : dimensional_exponents := dimensional_exponents(0,0,0,0,0,0,
            0);
END_LOCAL;
  result := x.dimensions;
RETURN(result);

END_FUNCTION; -- derive_dimensional_exponents

FUNCTION dimension_of
  (item : geometric_representation_item) :
  dimension_count;
  LOCAL
    x : SET OF representation;
    y : representation_context;
  END_LOCAL;

  -- Find the set of representation in which the item is used.

  x := using_representations(item);

  -- If there is such a representation, then determine the dimension_count
  -- of the associated geometric_representation_context - note that the
  -- RULE compatible_dimension ensures that the context_of_items is of type
  -- geometric_representation_context and has the same dimension_count for
  -- all values of x.

  IF SIZEOF(x) > 0 THEN
    y := x[1].context_of_items;
    RETURN (y\geometric_representation_context.coordinate_space_dimension);
  END_IF;
END_FUNCTION; -- dimension_of

FUNCTION dimensions_for_si_unit
  (n: si_unit_name): dimensional_exponents;
CASE n OF
  metre           :         RETURN(dimensional_exponents(1,0,0,0,0,0,0));
  gram            :         RETURN(dimensional_exponents(0,1,0,0,0,0,0));
  second          :         RETURN(dimensional_exponents(0,0,1,0,0,0,0));
  ampere          :         RETURN(dimensional_exponents(0,0,0,1,0,0,0));
  kelvin          :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
  mole            :         RETURN(dimensional_exponents(0,0,0,0,0,1,0));
  candela         :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
  radian          :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
  steradian       :         RETURN(dimensional_exponents(0,0,0,0,0,0,0));
  hertz           :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
  newton          :         RETURN(dimensional_exponents(1,1,-2,0,0,0,0));
  pascal          :         RETURN(dimensional_exponents(-1,1,-2,0,0,0,0));
  joule           :         RETURN(dimensional_exponents(2,1,-2,0,0,0,0));
  watt            :         RETURN(dimensional_exponents(2,1,-3,0,0,0,0));
  coulomb         :         RETURN(dimensional_exponents(0,0,1,1,0,0,0));
  volt            :         RETURN(dimensional_exponents(2,1,-3,-1,0,0,0));
  farad           :         RETURN(dimensional_exponents(-2,-1,4,1,0,0,0));
  ohm             :         RETURN(dimensional_exponents(2,1,-3,-2,0,0,0));
  siemens         :         RETURN(dimensional_exponents(-2,-1,3,2,0,0,0));
  weber           :         RETURN(dimensional_exponents(2,1,-2,-1,0,0,0));
  tesla           :         RETURN(dimensional_exponents(0,1,-2,-1,0,0,0));
  henry           :         RETURN(dimensional_exponents(2,1,-2,-2,0,0,0));
  degree_celsius  :         RETURN(dimensional_exponents(0,0,0,0,1,0,0));
  lumen           :         RETURN(dimensional_exponents(0,0,0,0,0,0,1));
  lux             :         RETURN(dimensional_exponents(-2,0,0,0,0,0,1));
  becquerel       :         RETURN(dimensional_exponents(0,0,-1,0,0,0,0));
  gray            :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
  sievert         :         RETURN(dimensional_exponents(2,0,-2,0,0,0,0));
  END_CASE;

END_FUNCTION; -- dimensions_for_si_unit

FUNCTION dot_product
  (arg1, arg2: direction): REAL;

LOCAL
  ndim   : INTEGER;
  scalar : REAL;
  vec1   : direction;
  vec2   : direction;
END_LOCAL;
IF (NOT EXISTS(arg1)) OR (NOT EXISTS(arg2)) THEN
  scalar := ?;
ELSE
  IF arg1.dim <> arg2.dim THEN
    scalar := ?;
  ELSE
    BEGIN
      vec1 := normalise(arg1);
      vec2 := normalise(arg2);
      ndim := arg1.dim;
      scalar := 0;
      REPEAT i := 1 TO ndim BY 1;
        scalar := scalar + (vec1.direction_ratios[i] * vec2.
            direction_ratios[i]);
      END_REPEAT;
    END;
  END_IF;
END_IF;
RETURN(scalar);

END_FUNCTION; -- dot_product

FUNCTION edge_reversed
  (an_edge: edge): edge;

LOCAL
  the_reverse : edge;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_EDGE' IN TYPEOF(an_edge) THEN
  the_reverse := oriented_edge(an_edge\oriented_edge.edge_element,NOT
      an_edge\oriented_edge.orientation);
ELSE
  the_reverse := oriented_edge(an_edge,FALSE);
END_IF;
RETURN(the_reverse);

END_FUNCTION; -- edge_reversed

FUNCTION face_bound_reversed
  (a_face_bound: face_bound): face_bound;

LOCAL
  the_reverse : face_bound;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound)
     THEN
(* ABF: This line differs from the function as defined in ISO 10303-42:1994.
The correct express has been substituted.
 the_reverse := face_bound(a_face_bound\face_bound.bound,
                   (NOT (a_face_bound\face_bound.orientation)) ) ||
                   face_outer_bound ();*)
      the_reverse := face_bound(a_face_bound\face_bound.bound,NOT 
          a_face_bound\face_bound.orientation);
ELSE
  the_reverse := face_bound(a_face_bound.bound,NOT a_face_bound.
      orientation);
END_IF;
RETURN(the_reverse);

END_FUNCTION; -- face_bound_reversed

FUNCTION face_reversed
  (a_face: face): face;

LOCAL
  the_reverse : face;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_FACE' IN TYPEOF(a_face) THEN
  the_reverse := oriented_face(a_face\oriented_face.face_element,NOT
      a_face\oriented_face.orientation);
ELSE
  the_reverse := oriented_face(a_face,FALSE);
END_IF;
RETURN(the_reverse);

END_FUNCTION; -- face_reversed

FUNCTION first_proj_axis
  (z_axis, arg: direction): direction;

LOCAL
  x_vec  : vector;
  v      : direction;
  z      : direction;
  x_axis : direction;
END_LOCAL;
IF ((NOT EXISTS(z_axis)) OR (NOT EXISTS(arg))) OR (arg.dim <> 3) THEN
  x_axis := ?;
ELSE
  z_axis := normalise(z_axis);
  IF NOT EXISTS(arg) THEN
    IF z_axis <> direction([1,0,0]) THEN
      v := direction([1,0,0]);
    ELSE
      v := direction([0,1,0]);
    END_IF;
  ELSE
    IF cross_product(arg,z).magnitude = 0 THEN
      RETURN(?);
    ELSE
      v := normalise(arg);
    END_IF;
  END_IF;
  x_vec := scalar_times_vector(dot_product(v,z),z_axis);
  x_axis := vector_difference(v,x_vec).orientation;
  x_axis := normalise(x_axis);
END_IF;
RETURN(x_axis);

END_FUNCTION; -- first_proj_axis

FUNCTION gbsf_check_curve
  (cv : curve; schema_name : STRING) : BOOLEAN;

  -- check whether the input has the right type

  IF NOT (schema_name + '.CURVE' IN TYPEOF (cv)) THEN RETURN(TRUE);
  END_IF;


  -- let those types pass that do not have any further references
  -- respectively rules to be applied

  IF SIZEOF ([schema_name + '.CIRCLE', schema_name + '.ELLIPSE']
    * TYPEOF(cv)) = 1 THEN RETURN(TRUE);
  ELSE

    -- the b_spline_curve shall not self intersect

    IF (schema_name + '.B_SPLINE_CURVE' IN TYPEOF(cv))
      THEN RETURN(NOT (cv\b_spline_curve.self_intersect));
    ELSE

      -- if the curve is a composite_curve, all of its segments shall be valid



      IF schema_name + '.COMPOSITE_CURVE' IN TYPEOF(cv) THEN
        RETURN (SIZEOF (QUERY (seg <* cv\composite_curve.segments |
        NOT (gbsf_check_curve(seg.parent_curve, schema_name)))) = 0);
      ELSE

        -- the curve_replica references other curves that need to be checked

        IF schema_name + '.CURVE_REPLICA' IN TYPEOF(cv) THEN
          RETURN (gbsf_check_curve
          (cv\curve_replica.parent_curve, schema_name));
        ELSE

          -- offset_curve_3d references a curve and shall not self intersect

          IF schema_name + '.OFFSET_CURVE_3D' IN TYPEOF(cv) THEN
            RETURN ((gbsf_check_curve
            (cv\offset_curve_3d.basis_curve, schema_name))
            AND
            (NOT cv\offset_curve_3d.self_intersect));
          ELSE

            -- pcurve references a curve - indirectly, and a basis_surface

            IF schema_name + '.PCURVE' IN TYPEOF(cv) THEN
              RETURN
              ((gbsf_check_curve
              (cv\pcurve.reference_to_curve\representation.items[1],
              schema_name)) AND
              (gbsf_check_surface
              (cv\pcurve.basis_surface, schema_name)));
            ELSE

              -- polyline shall have at least 3 points and shall only
              -- be used to represent an intersection_curve

              IF schema_name + '.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF (cv\polyline.points) > 3)  AND
                  (SIZEOF ((bag_to_set (USEDIN (cv,'')) -
                  bag_to_set (USEDIN (cv,
                  schema_name +
                  '.INTERSECTION_CURVE.BASIS_CURVE')))) = 0)
                  THEN RETURN (TRUE);
                END_IF;
              ELSE

                -- surface_curve references a curve_3d and one or two
                -- pcurves or one or two surface_curves or one of each

                IF schema_name + '.SURFACE_CURVE' IN TYPEOF(cv) THEN

                  -- if the curve reference is correct, check also the rest

                  IF gbsf_check_curve
                  (cv\surface_curve.curve_3d, schema_name) THEN
                    REPEAT i := 1 TO SIZEOF
                    (cv\surface_curve.associated_geometry);

                    -- do for one or two associated_geometrys:

                    IF schema_name + '.SURFACE' IN TYPEOF
                      (cv\surface_curve.associated_geometry[i]) THEN
                      IF NOT gbsf_check_surface
                        (cv\surface_curve.associated_geometry[i],
                        schema_name) THEN
                        RETURN(FALSE);
                      END_IF;
                    ELSE
                      IF schema_name + '.PCURVE' IN TYPEOF
                        (cv\surface_curve.associated_geometry[i]) THEN
                        IF NOT gbsf_check_curve
                          (cv\surface_curve.associated_geometry[i],
                          schema_name) THEN
                          RETURN(FALSE);
                        END_IF;
                      END_IF;
                    END_IF;
                  END_REPEAT;
                  RETURN(TRUE);
                END_IF;
              ELSE

                -- if the curve is a trimmed_curve

                IF (schema_name + '.TRIMMED_CURVE') IN TYPEOF (cv) THEN

                -- if a line, parabola or hyperbola is being trimmed,
                -- then valid

                  IF SIZEOF ([schema_name + '.LINE',
                  schema_name + '.PARABOLA',
                  schema_name + '.HYPERBOLA'] *
                  TYPEOF (cv\trimmed_curve.basis_curve)) = 1
                  THEN RETURN (TRUE);

                    -- otherwise, recursively check the basis curve

                    ELSE RETURN (gbsf_check_curve
                      (cv\trimmed_curve.basis_curve, schema_name));
                    END_IF;
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION; -- gbsf_check_curve

FUNCTION gbsf_check_point (pnt : point; schema_name : STRING) : BOOLEAN;

  -- check whether the input has the right type

  IF NOT (schema_name + '.POINT' IN TYPEOF (pnt)) THEN RETURN(TRUE);
  END_IF;

  IF schema_name + '.CARTESIAN_POINT' IN TYPEOF (pnt) THEN
    RETURN(TRUE);
  ELSE

  -- a point_on_curve needs to be checked for the validity of its curve;
  -- further references down the tree are taken care of by the function
  -- gbsf_check_curve

    IF schema_name + '.POINT_ON_CURVE' IN TYPEOF (pnt) THEN
      RETURN (gbsf_check_curve
      (pnt\point_on_curve.basis_curve, schema_name));
    ELSE

    -- a point_on_surface needs to be checked for the validity of its 
    -- surface further references down the tree are taken care of by 
    -- the function gbsf_check_surface

      IF schema_name + '.POINT_ON_SURFACE' IN TYPEOF (pnt) THEN
        RETURN(gbsf_check_surface
        (pnt\point_on_surface.basis_surface, schema_name));
      ELSE

      -- a degenerate_pcurve needs to be checked for the validity of its
      -- defining geometry further references down the tree are taken care
      -- of by the functions gbsf_check_curve and gbsf_check_surface;
      -- both shall return true to get a valid point

        IF schema_name + '.DEGENERATE_PCURVE' IN TYPEOF (pnt) THEN
          RETURN
          ((gbsf_check_curve
          (pnt\degenerate_pcurve.reference_to_curve\representation.items[1],
          schema_name))
          AND (gbsf_check_surface
          (pnt\degenerate_pcurve.basis_surface, schema_name)));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION; -- gbsf_check_point

FUNCTION gbsf_check_surface (sf : surface; schema_name : STRING) : BOOLEAN;

  -- check whether the input has the right type

  IF NOT (schema_name + '.SURFACE') IN TYPEOF (sf) THEN RETURN(TRUE);
  END_IF;

  -- b_spline_surface has a self_intersect attribute that shall be false

  IF schema_name + '.B_SPLINE_SURFACE' IN TYPEOF(sf) THEN
    RETURN(NOT (sf\b_spline_surface.self_intersect));
  ELSE

    -- basis surface types return true

    IF SIZEOF ([schema_name + '.SPHERICAL_SURFACE',
      schema_name + '.TOROIDAL_SURFACE'] * TYPEOF(sf)) = 3 THEN
      RETURN(TRUE);
    ELSE

      IF schema_name + '.CURVE_BOUNDED_SURFACE' IN TYPEOF(sf) THEN

      -- if there is a simple basis_surface, check the curves

        IF SIZEOF ([schema_name + '.CONICAL_SURFACE',
          schema_name + '.CYLINDRICAL_SURFACE',
          schema_name + '.PLANE'] * TYPEOF(sf)) = 1 THEN
          RETURN(SIZEOF (QUERY (bcurve <*
          sf\curve_bounded_surface.boundaries |
          NOT (gbsf_check_curve(bcurve, schema_name)))) = 0);

        ELSE

        -- recursively check the basis_surface and then the curves

          IF gbsf_check_surface
          (sf\curve_bounded_surface.basis_surface, schema_name) THEN
            RETURN(SIZEOF (QUERY (bcurve <*
            sf\curve_bounded_surface.boundaries |
            NOT (gbsf_check_curve(bcurve, schema_name)))) = 0);
          END_IF;
        END_IF;
      ELSE

        -- offset_surface references a surface and shall not self_intersect

        IF schema_name + '.OFFSET_SURFACE' IN TYPEOF(sf) THEN
          RETURN ((gbsf_check_surface
          (sf\offset_surface.basis_surface, schema_name))
          AND
          (NOT (sf\offset_surface.self_intersect)));
        ELSE

          -- rectangular_composite_surface references a matrix of surfaces

          IF schema_name + '.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) THEN


            REPEAT i := 1 TO SIZEOF
              (sf\rectangular_composite_surface.segments);
              REPEAT j := 1 TO SIZEOF
                (sf\rectangular_composite_surface.segments[i]);
                IF NOT (gbsf_check_surface
                  (sf\rectangular_composite_surface.segments[i][j].
                  parent_surface, schema_name))
                  THEN RETURN (FALSE);
                END_IF;
              END_REPEAT;
            END_REPEAT;
            RETURN(TRUE);
          ELSE

            -- rectangular_trimmed_surface has a basis_surface

            IF schema_name + '.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(sf) THEN

              IF  SIZEOF ([schema_name + '.CONICAL_SURFACE',
                schema_name + '.CYLINDRICAL_SURFACE',
                schema_name + '.PLANE'] * TYPEOF
                (sf\rectangular_trimmed_surface.basis_surface)) = 1 THEN
                RETURN (TRUE);
              ELSE
                RETURN(gbsf_check_surface
                (sf\rectangular_trimmed_surface.basis_surface, schema_name));
              END_IF;
            ELSE

              -- parent_surfaces need to be checked for their validity

              IF schema_name + '.SURFACE_REPLICA' IN TYPEOF (sf) THEN
                RETURN (gbsf_check_surface
                (sf\surface_replica.parent_surface, schema_name));
              ELSE

                -- and the swept_surface must have a valid swept_curve

                IF schema_name + '.SWEPT_SURFACE' IN TYPEOF(sf) THEN
                  RETURN(gbsf_check_curve
                  (sf\swept_surface.swept_curve, schema_name));
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(FALSE);
END_FUNCTION; -- gbsf_check_surface

FUNCTION get_basis_surface
  (c: curve_on_surface): SET [0:2] OF surface;

LOCAL
  surfs : SET [0:2] OF surface;
  n     : INTEGER;
END_LOCAL;
surfs := [];
IF 'CONFIG_CONTROL_DESIGN.PCURVE' IN TYPEOF(c) THEN
  surfs := [c\pcurve.basis_surface];
ELSE
  IF 'CONFIG_CONTROL_DESIGN.SURFACE_CURVE' IN TYPEOF(c) THEN
    n := SIZEOF(c\surface_curve.associated_geometry);
    REPEAT i := 1 TO n BY 1;
      surfs := surfs + associated_surface(c\surface_curve.
          associated_geometry[i]);
    END_REPEAT;
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
     THEN
  n := SIZEOF(c\composite_curve_on_surface.segments);
  surfs := get_basis_surface(c\composite_curve_on_surface.
           segments[1].parent_curve);
  IF n > 1 THEN
    REPEAT i := 2 TO n BY 1;
      surfs := surfs * get_basis_surface(c\composite_curve_on_surface.
               segments[i].parent_curve);
    END_REPEAT;
  END_IF;
END_IF;
RETURN(surfs);

END_FUNCTION; -- get_basis_surface

FUNCTION item_in_context
  (item: representation_item;
  cntxt: representation_context): BOOLEAN;

LOCAL
  i : INTEGER;
  y : BAG OF representation_item;
END_LOCAL;
IF SIZEOF(USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS') *
    cntxt.representations_in_context) > 0 THEN
  RETURN(TRUE);
ELSE
  y := QUERY ( z <* USEDIN(item,'') | (
      'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z)) );
  IF SIZEOF(y) > 0 THEN
    REPEAT i := 1 TO HIINDEX(y) BY 1;
      IF item_in_context(y[i],cntxt) THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
  END_IF;
END_IF;
RETURN(FALSE);

END_FUNCTION; -- item_in_context

FUNCTION leap_year
  (year: year_number): BOOLEAN;
IF (((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) =
     0) THEN
  RETURN(TRUE);
ELSE
  RETURN(FALSE);
END_IF;

END_FUNCTION; -- leap_year

FUNCTION list_face_loops
  (f: face): LIST [0:?] OF loop;

LOCAL
  loops : LIST [0:?] OF loop := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(f.bounds) BY 1;
  loops := loops + f.bounds[i].bound;
END_REPEAT;
RETURN(loops);

END_FUNCTION; -- list_face_loops

FUNCTION list_of_topology_reversed
  (a_list: list_of_reversible_topology_item
  ): list_of_reversible_topology_item;

LOCAL
  the_reverse : list_of_reversible_topology_item;
END_LOCAL;
the_reverse := [];
REPEAT i := 1 TO SIZEOF(a_list) BY 1;
  the_reverse := topology_reversed(a_list[i]) + the_reverse;
END_REPEAT;
RETURN(the_reverse);

END_FUNCTION; -- list_of_topology_reversed

FUNCTION list_to_array
  (lis: LIST [0:?] OF GENERIC:t;
  low, u: INTEGER
  ): ARRAY [low:u] OF GENERIC:t;

LOCAL
  n   : INTEGER;
  res : ARRAY [low:u] OF GENERIC:t;
END_LOCAL;
n := SIZEOF(lis);
IF n <> ((u - low) + 1) THEN
  RETURN(?);
ELSE
  REPEAT i := 1 TO n BY 1;
    res[(low + i) - 1] := lis[i];
  END_REPEAT;
  RETURN(res);
END_IF;

END_FUNCTION; -- list_to_array

FUNCTION list_to_set
  (l: LIST [0:?] OF GENERIC:t): SET OF GENERIC:t;

LOCAL
  s : SET OF GENERIC:t := [];
END_LOCAL;
REPEAT i := 1 TO SIZEOF(l) BY 1;
  s := s + l[i];
END_REPEAT;
RETURN(s);

END_FUNCTION; -- list_to_set

FUNCTION local_relatives_of_product_definitions
   (definition_set: SET OF product_definition;
   total_definitions: SET OF product_definition;
   relation_subtype: STRING): SET OF product_definition;

LOCAL
  i           : INTEGER;
  local_def   : SET OF product_definition := [];
  local_pdr   : SET OF product_definition_relationship := [];
  local_total : SET OF product_definition := [];
END_LOCAL;
REPEAT i := 1 TO HIINDEX(definition_set) BY 1;
  local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i],
      relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
END_REPEAT;
REPEAT i := 1 TO HIINDEX(local_pdr) BY 1;
  local_def := local_def + local_pdr[i].related_product_definition;
END_REPEAT;
IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
  RETURN(local_def);
ELSE
  local_total := total_definitions + local_def;
  RETURN(local_def + local_relatives_of_product_definitions(local_def
      - total_definitions,local_total,relation_subtype));
END_IF;

END_FUNCTION; -- local_relatives_of_product_definitions

FUNCTION make_array_of_array
  (lis: LIST [1:?] OF LIST [1:?] OF GENERIC:t;
  low1, u1, low2, u2: INTEGER
  ): ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;

LOCAL
  n2   : INTEGER;
  n1   : INTEGER;
  res  : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
  resl : LIST [1:?] OF ARRAY [low2:u2] OF GENERIC:t;
END_LOCAL;
n1 := SIZEOF(lis);
n2 := SIZEOF(lis[1]);
IF (n1 <> ((u1 - low1) + 1)) AND (n2 <> ((u2 - low2) + 1)) THEN
  RETURN(?);
END_IF;
REPEAT i := 1 TO n1 BY 1;
  IF SIZEOF(lis[i]) <> n2 THEN
    RETURN(?);
  END_IF;
END_REPEAT;
REPEAT i := 1 TO n1 BY 1;
  resl[i] := list_to_array(lis[i],low2,u2);
END_REPEAT;
res := list_to_array(resl,low1,u1);
RETURN(res);

END_FUNCTION; -- make_array_of_array

FUNCTION mixed_loop_type_set
  (l: SET [0:?] OF loop): LOGICAL;

LOCAL
  i              : INTEGER;
  poly_loop_type : LOGICAL;
END_LOCAL;
IF SIZEOF(l) <= 1 THEN
  RETURN(FALSE);
END_IF;
poly_loop_type := 'CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[1]);
REPEAT i := 2 TO SIZEOF(l) BY 1;
  IF ('CONFIG_CONTROL_DESIGN.POLY_LOOP' IN TYPEOF(l[i])) <>
      poly_loop_type THEN
    RETURN(TRUE);
  END_IF;
END_REPEAT;
RETURN(FALSE);

END_FUNCTION; -- mixed_loop_type_set

FUNCTION msb_shells
  (brep: manifold_solid_brep;
  schema_name: STRING): SET [1:?] OF closed_shell;
IF (schema_name + '.BREP_WITH_VOIDS') IN TYPEOF(brep) THEN
  RETURN(brep\brep_with_voids.voids + brep.outer);
ELSE
  RETURN([brep.outer]);
END_IF;

END_FUNCTION; -- msb_shells

FUNCTION normalise
  (arg: vector_or_direction): vector_or_direction;

LOCAL
  ndim   : INTEGER;
  v      : direction;
  vec    : vector;
  mag    : REAL;
  result : vector_or_direction;
END_LOCAL;
IF NOT EXISTS(arg) THEN
  result := ?;
ELSE
  ndim := arg.dim;
  IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
    BEGIN
      vec := arg;
      v := arg.orientation;
      IF arg.magnitude = 0 THEN
        RETURN(?);
      ELSE
        vec.magnitude := 1;
      END_IF;
    END;
  ELSE
    v := arg;
  END_IF;
  mag := 0;
  REPEAT i := 1 TO ndim BY 1;
    mag := mag + (v.direction_ratios[i] * v.direction_ratios[i]);
  END_REPEAT;
  IF mag > 0 THEN
    mag := SQRT(mag);
    REPEAT i := 1 TO ndim BY 1;
      v.direction_ratios[i] := v.direction_ratios[i] / mag;
    END_REPEAT;
    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg) THEN
      vec.orientation := v;
      result := vec;
    ELSE
      result := v;
    END_IF;
  ELSE
    RETURN(?);
  END_IF;
END_IF;
RETURN(result);

END_FUNCTION; -- normalise

FUNCTION orthogonal_complement
  (vec: direction): direction;

LOCAL
  result : direction;
END_LOCAL;
IF (vec.dim <> 2) OR (NOT EXISTS(vec)) THEN
  RETURN(?);
ELSE
  result.direction_ratios[1] := -vec.direction_ratios[2];
  result.direction_ratios[2] := vec.direction_ratios[1];
  RETURN(result);
END_IF;

END_FUNCTION; -- orthogonal_complement

FUNCTION path_head_to_tail
  (a_path: path): LOGICAL;

LOCAL
  n : INTEGER;
  p : LOGICAL := TRUE;
END_LOCAL;
n := SIZEOF(a_path.edge_list);
REPEAT i := 2 TO n BY 1;
  p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i]
      .edge_start);
END_REPEAT;
RETURN(p);

END_FUNCTION; -- path_head_to_tail

FUNCTION path_reversed
  (a_path: path): path;

LOCAL
  the_reverse : path;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_PATH' IN TYPEOF(a_path) THEN
  the_reverse := oriented_path(a_path\oriented_path.path_element,NOT
      a_path\oriented_path.orientation);
ELSE
  the_reverse := oriented_path(a_path,FALSE);
END_IF;
RETURN(the_reverse);

END_FUNCTION; -- path_reversed

FUNCTION relatives_of_product_definitions
  (definition_set: SET OF product_definition;
  relation_subtype: STRING): SET OF product_definition;

FUNCTION local_relatives_of_product_definitions
  (definition_set: SET OF product_definition;
  total_definitions: SET OF product_definition;
  relation_subtype: STRING): SET OF product_definition;

  LOCAL
    i           : INTEGER;
    local_def   : SET OF product_definition := [];
    local_pdr   : SET OF product_definition_relationship := [];
    local_total : SET OF product_definition := [];
  END_LOCAL;
  REPEAT i := 1 TO HIINDEX(definition_set) BY 1;
    local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i],
        relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(local_pdr) BY 1;
    local_def := local_def + local_pdr[i].related_product_definition;
  END_REPEAT;
  IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
    RETURN(local_def);
  ELSE
    local_total := total_definitions + local_def;
    RETURN(local_def + local_relatives_of_product_definitions(
        local_def - total_definitions,local_total,relation_subtype));
  END_IF;

END_FUNCTION; -- local_relatives_of_product_definitions
RETURN(local_relatives_of_product_definitions(definition_set,
    definition_set,relation_subtype));

END_FUNCTION; -- relatives_of_product_definitions

FUNCTION scalar_times_vector
  (scalar: REAL;
  vec: vector_or_direction): vector;

LOCAL
  v      : direction;
  mag    : REAL;
  result : vector;
END_LOCAL;
IF (NOT EXISTS(scalar)) OR (NOT EXISTS(vec)) THEN
  result := ?;
ELSE
  IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(vec) THEN
    v := vec.orientation;
    mag := scalar * vec.magnitude;
  ELSE
    v := vec;
    mag := scalar;
  END_IF;
  IF mag < 0 THEN
    REPEAT i := 1 TO SIZEOF(v.direction_ratios) BY 1;
      v.direction_ratios[i] := -v.direction_ratios[i];
    END_REPEAT;
    mag := -mag;
  END_IF;
  result.orientation := normalise(v);
  result.magnitude := mag;
END_IF;
RETURN(result);

END_FUNCTION; -- scalar_times_vector

FUNCTION second_proj_axis
  (z_axis, x_axis, arg: direction): direction;

LOCAL
  temp   : vector;
  v      : direction;
  y_axis : vector;
END_LOCAL;
IF NOT EXISTS(arg) THEN
  v := direction([0,1,0]);
ELSE
  v := arg;
END_IF;
temp := scalar_times_vector(dot_product(v,z_axis),z_axis);
y_axis := vector_difference(v,temp);
temp := scalar_times_vector(dot_product(v,x_axis),x_axis);
y_axis := vector_difference(y_axis,temp);
y_axis := normalise(y_axis);
RETURN(y_axis.orientation);

END_FUNCTION; -- second_proj_axis

FUNCTION set_of_topology_reversed
  (a_set: set_of_reversible_topology_item) :
  set_of_reversible_topology_item;

LOCAL
  the_reverse : set_of_reversible_topology_item;
END_LOCAL;
the_reverse := [];
REPEAT i := 1 TO SIZEOF(a_set) BY 1;
  the_reverse := the_reverse + topology_reversed(a_set[i]);
END_REPEAT;
RETURN(the_reverse);

END_FUNCTION; -- set_of_topology_reversed

FUNCTION shell_reversed
  (a_shell: shell): shell;

LOCAL
  the_reverse : shell;
END_LOCAL;
IF 'CONFIG_CONTROL_DESIGN.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell)
     THEN
  the_reverse := oriented_open_shell(a_shell\oriented_open_shell.
      open_shell_element,NOT a_shell\oriented_open_shell.orientation);
ELSE
  IF 'CONFIG_CONTROL_DESIGN.OPEN_SHELL' IN TYPEOF(a_shell) THEN
    the_reverse := oriented_open_shell(a_shell,FALSE);
  ELSE
    IF 'CONFIG_CONTROL_DESIGN.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell)
         THEN
      the_reverse := oriented_closed_shell(a_shell\
          oriented_closed_shell.closed_shell_element,NOT a_shell\
          oriented_closed_shell.orientation);
    ELSE
      IF 'CONFIG_CONTROL_DESIGN.CLOSED_SHELL' IN TYPEOF(a_shell) THEN
        the_reverse := oriented_closed_shell(a_shell,FALSE);
      ELSE
        the_reverse := ?;
      END_IF;
    END_IF;
  END_IF;
END_IF;
RETURN(the_reverse);

END_FUNCTION; -- shell_reversed

FUNCTION surface_weights_positive
  (b: rational_b_spline_surface): BOOLEAN;

LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 0 TO b.u_upper BY 1;
  REPEAT j := 0 TO b.v_upper BY 1;
    IF b.weights[i][j] <= 0 THEN
      result := FALSE;
      RETURN(result);
    END_IF;
  END_REPEAT;
END_REPEAT;
RETURN(result);

END_FUNCTION; -- surface_weights_positive

FUNCTION topology_reversed
  (an_item: reversible_topology): reversible_topology;
IF 'CONFIG_CONTROL_DESIGN.EDGE' IN TYPEOF(an_item) THEN
  RETURN(edge_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.PATH' IN TYPEOF(an_item) THEN
  RETURN(path_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.FACE_BOUND' IN TYPEOF(an_item) THEN
  RETURN(face_bound_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.FACE' IN TYPEOF(an_item) THEN
  RETURN(face_reversed(an_item));
END_IF;
IF 'CONFIG_CONTROL_DESIGN.SHELL' IN TYPEOF(an_item) THEN
  RETURN(shell_reversed(an_item));
END_IF;
IF 'SET' IN TYPEOF(an_item) THEN
  RETURN(set_of_topology_reversed(an_item));
END_IF;
IF 'LIST' IN TYPEOF(an_item) THEN
  RETURN(list_of_topology_reversed(an_item));
END_IF;
RETURN(?);

END_FUNCTION; -- topology_reversed

FUNCTION unique_version_change_order (c : action) : BOOLEAN;
  LOCAL
    ords       : action_directive := c\directed_action.directive;
    assign     : SET OF change_request := [];
    versions   : SET OF product_definition_formation := [];
  END_LOCAL;

  -- build the set of change_requests that are the assigned
  -- versioned_action_requests incorporated by the action_directive
  REPEAT i := 1 TO SIZEOF(ords.requests);
  assign := assign + QUERY (ara <* bag_to_set (USEDIN (ords.requests[i],
            'CONFIG_CONTROL_DESIGN.ACTION_REQUEST_ASSIGNMENT.' +
            'ASSIGNED_ACTION_REQUEST')) |
            'CONFIG_CONTROL_DESIGN.CHANGE_REQUEST' IN TYPEOF (ara));
  END_REPEAT;

  -- gather the product_definition_formations that are referenced by the
  -- change_requests

  REPEAT k := 1 TO SIZEOF(assign);
    versions := versions + assign[k].items;
  END_REPEAT;

  -- check that no product_definition_formation reference the same
  -- instance of product

  RETURN (SIZEOF (QUERY (vers <* versions |
          NOT (SIZEOF (QUERY (other_vers <* versions - vers |
          vers.of_product :=: other_vers.of_product)) = 0))) = 0);
END_FUNCTION; -- unique_version_change_order

FUNCTION using_representations
  (item : representation_item)
  : SET OF representation;
  LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF representation_item;
    i                  : INTEGER;
  END_LOCAL;

  -- Find the representations in which the item is used and add to the
  -- results set.

  result_bag := USEDIN(item,'CONFIG_CONTROL_DESIGN.REPRESENTATION.ITEMS');

  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;

  -- Find the set of representation_items in which item is used.

  intermediate_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
    'CONFIG_CONTROL_DESIGN.REPRESENTATION_ITEM' IN TYPEOF(z));

  -- If the set of intermediate items is not empty;

  IF SIZEOF(intermediate_items) > 0 THEN

    -- For each element in the set, recursively add the
    -- using_representations of that element.

    REPEAT i := 1 TO HIINDEX(intermediate_items);
      results := results + using_representations(intermediate_items[i]);
    END_REPEAT;
  END_IF;

  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening 
  -- representation_items).

  RETURN (results);
END_FUNCTION; -- using_representations


  FUNCTION valid_calendar_date(
               date: calendar_date
      ): LOGICAL;
    IF NOT ((1 <= date.day_component) AND (date.day_component <= 31))
         THEN
      RETURN(FALSE);
    END_IF;
    CASE date.month_component OF
      4 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      6 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      9 :         RETURN((1 <= date.day_component) AND (date.day_component 
            <= 30));
      11  :         RETURN((1 <= date.day_component) AND (date.
            day_component <= 30));
      2 :         BEGIN
          IF leap_year(date.year_component) THEN
            RETURN((1 <= date.day_component) AND (date.day_component <= 29));
          ELSE
            RETURN((1 <= date.day_component) AND (date.day_component <= 28));
          END_IF;
        END;
(* abf added--shtolo ate this line *)
        OTHERWISE: RETURN(TRUE); 
      END_CASE;

  END_FUNCTION; -- valid_calendar_date



FUNCTION valid_geometrically_bounded_wf_curve 
  (crv   : curve; schma : STRING) : BOOLEAN;

  -- check for valid basic curves

  IF SIZEOF ([schma + '.POLYLINE',
    schma + '.B_SPLINE_CURVE',
    schma + '.ELLIPSE',
    schma + '.CIRCLE'] * TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE

    -- if the curve is a trimmed_curve

    IF (schma + '.TRIMMED_CURVE') IN TYPEOF (crv) THEN

      -- if a line, parabola or hyperbola is being trimmed, then valid

      IF SIZEOF ([schma + '.LINE',
        schma + '.PARABOLA',
        schma + '.HYPERBOLA'] * TYPEOF (crv\trimmed_curve.basis_curve)) = 1
        THEN RETURN (TRUE);

        -- otherwise, recursively check the basis_curve

        ELSE RETURN (valid_geometrically_bounded_wf_curve
        (crv\trimmed_curve.basis_curve, schma));
      END_IF;
    ELSE

      -- recursively check the offset_curves basis curve

      IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF (crv)
        THEN RETURN (valid_geometrically_bounded_wf_curve
        (crv\offset_curve_3d.basis_curve, schma));
      ELSE

        -- recursively check the curve_replicas parent curve

        IF (schma + '.CURVE_REPLICA') IN TYPEOF (crv) THEN
          RETURN (valid_geometrically_bounded_wf_curve
          (crv\curve_replica.parent_curve, schma));
        ELSE

          -- recursively check the composite_curves segments

          IF (schma + '.COMPOSITE_CURVE') IN TYPEOF (crv) THEN
            RETURN (SIZEOF (QUERY (ccs <* crv\composite_curve.segments |
            NOT (valid_geometrically_bounded_wf_curve
            (ccs.parent_curve, schma))))
            = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION; -- valid_geometrically_bounded_wf_curve

FUNCTION valid_geometrically_bounded_wf_point
  (pnt : point; schma: STRING) : BOOLEAN;

  -- check for valid basis type

  IF (schma + '.CARTESIAN_POINT') IN TYPEOF (pnt)
    THEN RETURN (TRUE);
  ELSE

    -- if the input type is a point_on_curve then check for a valid
    -- geometrically bounded curve type as the basis

    IF (schma + '.POINT_ON_CURVE') IN TYPEOF (pnt)
      THEN RETURN (valid_geometrically_bounded_wf_curve
      (pnt\point_on_curve.basis_curve, schma));
    ELSE

      -- if the input type is a point_replica check for a valid parent point

      IF (schma + '.POINT_REPLICA') IN TYPEOF (pnt)
        THEN RETURN (valid_geometrically_bounded_wf_point
        (pnt\point_replica.parent_pt, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION; -- valid_geometrically_bounded_wf_point

FUNCTION valid_time
  (time: local_time): BOOLEAN;
IF EXISTS(time.second_component) THEN
  RETURN(EXISTS(time.minute_component));
ELSE
  RETURN(TRUE);
END_IF;

END_FUNCTION; -- valid_time

FUNCTION valid_units
  (m: measure_with_unit): BOOLEAN;
IF 'CONFIG_CONTROL_DESIGN.LENGTH_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(1,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.MASS_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(0,1,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.TIME_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(0,0,1,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(0,0,0,1,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.THERMODYNAMIC_TEMPERATURE_MEASURE' IN
    TYPEOF(m.value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(0,0,0,0,1,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(0,0,0,0,0,1,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(0,0,0,0,0,0,1) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(0,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(0,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.AREA_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(2,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.VOLUME_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(3,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.RATIO_MEASURE' IN TYPEOF(m.value_component)
     THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(0,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(1,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
IF 'CONFIG_CONTROL_DESIGN.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.
    value_component) THEN
  IF derive_dimensional_exponents(m.unit_component) <>
      dimensional_exponents(0,0,0,0,0,0,0) THEN
    RETURN(FALSE);
  END_IF;
END_IF;
RETURN(TRUE);

END_FUNCTION; -- valid_units

FUNCTION valid_wireframe_edge_curve
  (crv   : curve; schma : STRING) : BOOLEAN;

  -- check for valid basic curve types

  IF SIZEOF ([schma + '.LINE',
    schma + '.CIRCLE',
    schma + '.ELLIPSE',
    schma + '.PARABOLA',
    schma + '.HYPERBOLA',
    schma + '.B_SPLINE_CURVE',
    schma + '.POLYLINE'] * TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE

   -- recursively check for valid parent curves for curve_replica

    IF (schma + '.CURVE_REPLICA') IN TYPEOF(crv)
      THEN RETURN
      (valid_wireframe_edge_curve (crv\curve_replica.parent_curve, schma));
    ELSE

      -- recursively check for valid basis curves for offset_curve

      IF (schma + '.OFFSET_CURVE_3D') IN TYPEOF (crv)
        THEN RETURN
        (valid_wireframe_edge_curve (crv\offset_curve_3d.basis_curve, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION; -- valid_wireframe_edge_curve

FUNCTION valid_wireframe_vertex_point
  (pnt   : point; schma : STRING) : BOOLEAN;

  -- check for valid basic point type

  IF (schma + '.CARTESIAN_POINT' IN TYPEOF (pnt))
    THEN RETURN (TRUE);
  ELSE

    -- recursively check for valid basic point type as parents for a
    -- point_replica

    IF (schma + '.POINT_REPLICA') IN TYPEOF (pnt)
      THEN RETURN (valid_wireframe_vertex_point
      (pnt\point_replica.parent_pt, schma));
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION; -- valid_wireframe_vertex_point

FUNCTION vector_difference
  (arg1, arg2: vector_or_direction): vector;

LOCAL
  ndim   : INTEGER;
  mag2   : REAL;
  mag1   : REAL;
  mag    : REAL;
  res    : direction;
  vec1   : direction;
  vec2   : direction;
  result : vector;
END_LOCAL;
IF ((NOT EXISTS(arg1)) OR (NOT EXISTS(arg2))) OR (arg1.dim <> arg2.dim)
     THEN
  result := ?;
ELSE
  BEGIN
    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg1) THEN
      mag1 := arg1.magnitude;
      vec1 := arg1.orientation;
    ELSE
      mag1 := 1;
      vec1 := arg1;
    END_IF;
    IF 'CONFIG_CONTROL_DESIGN.VECTOR' IN TYPEOF(arg2) THEN
      mag2 := arg2.magnitude;
      vec2 := arg2.orientation;
    ELSE
      mag2 := 1;
      vec2 := arg2;
    END_IF;
    vec1 := normalise(vec1);
    vec2 := normalise(vec2);
    ndim := SIZEOF(vec1.direction_ratios);
    mag := 0;
    REPEAT i := 1 TO ndim BY 1;
      res.direction_ratios[i] := (mag1 * vec1.direction_ratios[i]) - (
          mag2 * vec2.direction_ratios[i]);
      mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
    END_REPEAT;
    IF mag > 0 THEN
      result.magnitude := SQRT(mag);
      result.orientation := res;
    ELSE
      result.magnitude := 0;
      result.orientation := vec1;
    END_IF;
  END;
END_IF;
RETURN(result);

END_FUNCTION; -- vector_difference

END_SCHEMA; -- config_control_design
