# This file is a Tcl script to test entry widgets in Tk.  It is
# organized in the standard fashion for Tcl tests.
#
# Copyright (c) 1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
#
# RCS: @(#) $Id$

package require tcltest 2.1
eval tcltest::configure $argv
tcltest::loadTestedCommands

set i 1
panedwindow .p
foreach {testName testData} {
    panedwindow-1.1 {-background
	"#ff0000" "#ff0000" non-existent {unknown color name "non-existent"}}
    panedwindow-1.2 {-bd
	4 4 badValue {bad screen distance "badValue"}}
    panedwindow-1.3 {-bg
	"#ff0000" "#ff0000" non-existent {unknown color name "non-existent"}}
    panedwindow-1.4 {-borderwidth
	1.3 1 badValue {bad screen distance "badValue"}}
    panedwindow-1.5 {-cursor
	arrow arrow badValue {bad cursor spec "badValue"}}
    panedwindow-1.6 {-handlesize
	20 20 badValue {bad screen distance "badValue"}}
    panedwindow-1.7 {-height
	20 20 badValue {bad screen distance "badValue"}}
    panedwindow-1.8 {-opaqueresize
	true 1 foo {expected boolean value but got "foo"}}
    panedwindow-1.9 {-orient
	horizontal horizontal
	badValue {bad orient "badValue": must be horizontal or vertical}}
    panedwindow-1.10 {-relief
	groove groove
	1.5 {bad relief "1.5": must be flat, groove, raised, ridge, solid, or sunken}}
    panedwindow-1.11 {-sashcursor
	arrow arrow badValue {bad cursor spec "badValue"}}
    panedwindow-1.12 {-sashpad
	1.3 1 badValue {bad screen distance "badValue"}}
    panedwindow-1.13 {-sashrelief
	groove groove
	1.5 {bad relief "1.5": must be flat, groove, raised, ridge, solid, or sunken}}
    panedwindow-1.14 {-sashwidth
	10 10 badValue {bad screen distance "badValue"}}
    panedwindow-1.15 {-showhandle
	true 1 foo {expected boolean value but got "foo"}}
    panedwindow-1.16 {-width
	402 402 badValue {bad screen distance "badValue"}}
} {
    lassign $testData optionName goodIn goodOut badIn badOut
    test ${testName}(good) "configuration options: $optionName" {
	.p configure $optionName $goodIn
	list [lindex [.p configure $optionName] 4] [.p cget $optionName]
    } [list $goodOut $goodOut]
    test ${testName}(bad) "configuration options: $optionName" -body {
	.p configure $optionName $badIn
    } -returnCodes error -result $badOut
    # Reset to default
    .p configure $optionName [lindex [.p configure $optionName] 3]
}
.p add [button .b]
.p add [button .c]
foreach {testName testData} {
    panedwindow-1a.1 {-after .c .c badValue {bad window path name "badValue"}}
    panedwindow-1a.2 {-before .c .c badValue {bad window path name "badValue"}}
    panedwindow-1a.3 {-height 10 10 badValue {bad screen distance "badValue"}}
    panedwindow-1a.4 {-hide false 0 foo {expected boolean value but got "foo"}}
    panedwindow-1a.5 {-minsize 10 10 badValue {bad screen distance "badValue"}}
    panedwindow-1a.6 {-padx 1.3 1 badValue {bad screen distance "badValue"}}
    panedwindow-1a.7 {-pady 1.3 1 badValue {bad screen distance "badValue"}}
    panedwindow-1a.8 {-sticky nsew nesw abcd {bad stickyness value "abcd": must be a string containing zero or more of n, e, s, and w}}
    panedwindow-1a.9 {-stretch alw always foo {bad stretch "foo": must be always, first, last, middle, or never}}
    panedwindow-1a.10 {-width 10 10 badValue {bad screen distance "badValue"}}
} {
    lassign $testData optionName goodIn goodOut badIn badOut
    test ${testName}(good) "configuration options: $optionName" {
	.p paneconfigure .b $optionName $goodIn
	list [lindex [.p paneconfigure .b $optionName] 4] \
	    [.p panecget .b $optionName]
    } [list $goodOut $goodOut]
    test ${testName}(bad) "configuration options: $optionName" -body {
	.p paneconfigure .b $optionName $badIn
    } -returnCodes error -result $badOut
    # Reset to default
    .p paneconfig .b $optionName [lindex [.p paneconfig .b $optionName] 3]
}
destroy .p .b .c

test panedwindow-2.1 {panedwindow widget command} {
    panedwindow .p
    set result [list [catch {.p foo} msg] $msg]
    destroy .p
    set result
} {1 {bad command "foo": must be add, cget, configure, forget, identify, panecget, paneconfigure, panes, proxy, or sash}}

test panedwindow-3.1 {panedwindow panes subcommand} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    set result [list [.p panes]]
    .p forget .b
    lappend result [.p panes]
    destroy .p .b .c
    set result
} [list [list .b .c] [list .c]]

test panedwindow-4.1 {forget subcommand} {
    panedwindow .p
    set result [list [catch {.p forget} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p forget widget ?widget ...?\""]
test panedwindow-4.2 {forget subcommand, forget one from start} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    set result [list [.p panes]]
    .p forget .b
    lappend result [.p panes]
    destroy .p .b .c
    set result
} [list {.b .c} .c]
test panedwindow-4.3 {forget subcommand, forget one from end} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    .p add [button .d]
    set result [list [.p panes]]
    .p forget .d
    update
    lappend result [.p panes]
    destroy .p .b .c .d
    set result
} [list {.b .c .d} {.b .c}]
test panedwindow-4.4 {forget subcommand, forget multiple} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    .p add [button .d]
    set result [list [.p panes]]
    .p forget .b .c
    update
    lappend result [.p panes]
    destroy .p .b .c .d
    set result
} [list {.b .c .d} .d]
test panedwindow-4.5 {forget subcommand, panes are unmapped} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    pack .p
    update

    set result [list [winfo ismapped .b] [winfo ismapped .c]]
    .p forget .b
    update

    lappend result [winfo ismapped .b] [winfo ismapped .c]
    destroy .p .b .c
    
    set result
} [list 1 1 0 1]
test panedwindow-4.6 {forget subcommand, changes reqsize of panedwindow} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -showhandle false
    .p add [frame .f -width 20 -height 20] [frame .g -width 20 -height 20]
    set result [list [winfo reqwidth .p]]
    .p forget .f
    lappend result [winfo reqwidth .p]
    destroy .p .f .g
    set result
} [list 44 20]

test panedwindow-5.1 {sash subcommand} {
    panedwindow .p
    set result [list [catch {.p sash} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p sash option ?arg ...?\""]
test panedwindow-5.2 {sash subcommand} {
    panedwindow .p
    set result [list [catch {.p sash foo} msg] $msg]
    destroy .p
    set result
} [list 1 "bad option \"foo\": must be coord, dragto, mark, or place"]

test panedwindow-6.1 {sash coord subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash coord} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p sash coord index\""]
test panedwindow-6.2 {sash coord subcommand, errors} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4
    set result [list [catch {.p sash coord 0} msg] $msg]
    destroy .p
    set result
} [list 1 "invalid sash index"]
test panedwindow-6.3 {sash coord subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash coord foo} msg] $msg]
    destroy .p
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-6.4 {sash coord subcommand sashes correctly placed} {
    panedwindow .p -borderwidth 0 -sashpad 2 -sashwidth 4 -showhandle false
    .p add [frame .p.f -width 20 -height 20] \
	    [frame .p.f2 -width 20 -height 20] \
	    [frame .p.f3 -width 20 -height 20]
    set result [.p sash coord 0]
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 22 0]
test panedwindow-6.5 {sash coord subcommand sashes correctly placed} {
    panedwindow .p -borderwidth 0 -sashpad 2 -sashwidth 4 -showhandle false
    .p add [frame .p.f -width 20 -height 20] \
	    [frame .p.f2 -width 20 -height 20] \
	    [frame .p.f3 -width 20 -height 20]
    set result [.p sash coord 1]
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 50 0]
test panedwindow-6.6 {sash coord subcommand, sashes correctly placed} {
    panedwindow .p -borderwidth 0 -sashpad 2 -sashwidth 4 -orient vertical \
            -showhandle false
    .p add [frame .p.f -width 20 -height 20] \
	    [frame .p.f2 -width 20 -height 20] \
	    [frame .p.f3 -width 20 -height 20]
    set result [.p sash coord 0]
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 0 22]
test panedwindow-6.7 {sash coord subcommand, sashes correctly placed} {
    panedwindow .p -borderwidth 0 -sashpad 2 -sashwidth 4 -orient vertical \
            -showhandle false
    .p add [frame .p.f -width 20 -height 20] \
	    [frame .p.f2 -width 20 -height 20] \
	    [frame .p.f3 -width 20 -height 20]
    set result [.p sash coord 1]
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 0 50]
test panedwindow-6.8 {sash coord subcommand, errors} {
    panedwindow .p
    set result [list \
	    [catch {.p sash coord -1} msg] $msg \
	    [catch {.p sash coord  0} msg] $msg \
	    [catch {.p sash coord  1} msg] $msg \
	    ]
    destroy .p
    set result
} [list 1 "invalid sash index" 1 "invalid sash index" 1 "invalid sash index"]
test panedwindow-6.9 {sash coord subcommand, errors} {
    # There are no sashes until you have 2 panes
    panedwindow .p
    .p add [frame .p.f]
    set result [list \
	    [catch {.p sash coord -1} msg] $msg \
	    [catch {.p sash coord  0} msg] $msg \
	    [catch {.p sash coord  1} msg] $msg \
	    ]
    destroy .p
    set result
} [list 1 "invalid sash index" 1 "invalid sash index" 1 "invalid sash index"]
test panedwindow-6.10 {sash coord subcommand, errors} {
    # There are no sashes until you have 2 panes
    panedwindow .p
    .p add [frame .p.f] [frame .p.f2]
    set result [list \
	    [catch {.p sash coord -1} msg] $msg \
	    [catch {.p sash coord  0} msg] \
	    [catch {.p sash coord  1} msg] $msg \
	    [catch {.p sash coord  2} msg] $msg \
	    ]
    destroy .p
    set result
} [list 1 "invalid sash index" 0 1 "invalid sash index" 1 "invalid sash index"]

test panedwindow-8.1 {sash mark subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash mark} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p sash mark index ?x y?\""]
test panedwindow-8.2 {sash mark subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash mark foo} msg] $msg]
    destroy .p
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-8.3 {sash mark subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash mark 0 foo bar} msg] $msg]
    destroy .p
    set result
} [list 1 "invalid sash index"]
test panedwindow-8.4 {sash mark subcommand, errors} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [list [catch {.p sash mark 0 foo bar} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-8.5 {sash mark subcommand, errors} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [list [catch {.p sash mark 0 0 bar} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "expected integer but got \"bar\""]
test panedwindow-8.6 {sash mark subcommand, mark defaults to 0 0} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [.p sash mark 0]
    destroy .p .b .c
    set result
} [list 0 0]
test panedwindow-8.7 {sash mark subcommand, set mark} {
    panedwindow .p
    .p add [button .b] [button .c]
    .p sash mark 0 10 10
    set result [.p sash mark 0]
    destroy .p .b .c
    set result
} [list 10 10]

test panedwindow-9.1 {sash dragto subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash dragto} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p sash dragto index x y\""]
test panedwindow-9.2 {sash dragto subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash dragto foo bar baz} msg] $msg]
    destroy .p
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-9.3 {sash dragto subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash dragto 0 foo bar} msg] $msg]
    destroy .p
    set result
} [list 1 "invalid sash index"]
test panedwindow-9.4 {sash dragto subcommand, errors} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [list [catch {.p sash dragto 0 foo bar} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-9.5 {sash dragto subcommand, errors} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [list [catch {.p sash dragto 0 0 bar} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "expected integer but got \"bar\""]
    
test panedwindow-10.1 {sash mark/sash dragto interaction} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -showhandle false
    .p add [frame .f -width 20 -height 20] [button .c -text foobar]
    .p sash mark 0 10 10
    .p sash dragto 0 20 10
    set result [.p sash coord 0]
    destroy .p .f .c
    set result
} [list 30 0]
test panedwindow-10.2 {sash mark/sash dragto interaction} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -orient vertical \
            -showhandle false
    .p add [frame .p.f -width 20 -height 20] [button .p.c -text foobar]
    .p sash mark 0 10 10
    .p sash dragto 0 10 20
    set result [.p sash coord 0]
    destroy .p .p.f .p.c
    set result
} [list 0 30]
test panedwindow-10.3 {sash mark/sash dragto, respects minsize}  {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -showhandle false
    .p add [frame .f -width 20 -height 20] [button .c] -minsize 15
    .p sash mark 0 20 10
    .p sash dragto 0 10 10
    set result [.p sash coord 0]
    destroy .p .f .c
    set result
} [list 15 0]

test panedwindow-11.1 {sash place subcommand, errors} {
    panedwindow .p
    set result [list [catch {.p sash place} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p sash place index x y\""]
test panedwindow-11.2 {sash place subcommand, errors} {
    destroy .p
    panedwindow .p
    list [catch {.p sash place foo bar baz} msg] $msg
} [list 1 "expected integer but got \"foo\""]
test panedwindow-11.3 {sash place subcommand, errors} {
    destroy .p
    panedwindow .p
    list [catch {.p sash place 0 foo bar} msg] $msg
} [list 1 "invalid sash index"]
test panedwindow-11.4 {sash place subcommand, errors} {
    destroy .p .b .c
    panedwindow .p
    .p add [button .b] [button .c]
    list [catch {.p sash place 0 foo bar} msg] $msg
} [list 1 "expected integer but got \"foo\""]
test panedwindow-11.5 {sash place subcommand, errors} {
    destroy .p .f .c .b
    panedwindow .p
    .p add [button .b] [button .c]
    list [catch {.p sash place 0 0 bar} msg] $msg
} [list 1 "expected integer but got \"bar\""]
test panedwindow-11.6 {sash place subcommand, moves sash} {
    destroy .p .f .c .b
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 20] [button .c]
    .p sash place 0 10 0
    .p sash coord 0
} [list 10 0]
test panedwindow-11.7 {sash place subcommand, moves sash} {
    destroy .p .f .c
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -orient vertical
    .p add [frame .f -width 20 -height 20] [button .c]
    .p sash place 0 0 10
    .p sash coord 0
} [list 0 10]
test panedwindow-11.8 {sash place subcommand, respects minsize} {
    destroy .p .f .c
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -showhandle false
    .p add [frame .f -width 20 -height 20] [button .c] -minsize 15
    .p sash place 0 10 0
    .p sash coord 0
} [list 15 0]
test panedwindow-11.9 {sash place subcommand, respects minsize} {
    destroy .p .f .c
    panedwindow .p
    .p add [frame .f -width 20 -height 20 -bg pink]
    list [catch {.p sash place 0 2 0} msg] $msg
} [list 1 {invalid sash index}]

test panedwindow-12.1 {moving sash changes size of pane to left} {
    destroy .p .f .c
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 4 -showhandle false
    .p add [frame .f -width 20 -height 20] [button .c -text foobar] -sticky nsew
    .p sash place 0 30 0
    pack .p
    update
    winfo width .f
} 30
test panedwindow-12.2 {moving sash changes size of pane to right} {
    destroy .p .f .f2
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 20] [frame .f2 -width 20 -height 20]
    pack .p
    update
    set result [winfo width .f2]
    .p sash place 0 30 0
    update
    lappend result [winfo width .f2]
} {20 10}
test panedwindow-12.3 {moving sash does not change reqsize of panedwindow} {
    destroy .p .f .f2
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 20] [frame .f2 -width 20 -height 20]
    .p sash place 0 30 0
    winfo reqwidth .p
} 44
test panedwindow-12.4 {moving sash changes size of pane above} {
    destroy .p .f .c
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .f -width 20 -height 10] [button .c -text foobar] -sticky nsew
    .p sash place 0 0 20
    pack .p
    update
    set result [winfo height .f]
    destroy .p .f .c
    set result
} 20
test panedwindow-12.5 {moving sash changes size of pane below} {
    destroy .p .f .f2
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .f -width 20 -height 10] [frame .f2 -width 20 -height 10]
    pack .p
    update
    set result [winfo height .f2]
    .p sash place 0 0 15
    update
    lappend result [winfo height .f2]
    destroy .p .f .f2
    set result
} {10 5}
test panedwindow-12.6 {moving sash does not change reqsize of panedwindow} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .f -width 20 -height 10] [frame .f2 -width 20 -height 10]
    set result [winfo reqheight .p]
    .p sash place 0 0 20
    lappend result [winfo reqheight .p]
    destroy .p .f .f2
    set result
} [list 24 24]
test panedwindow-12.7 {moving sash does not alter reqsize of widget} {
    destroy .p .f .f2
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .f -width 20 -height 10] [frame .f2 -width 20 -height 10]
    set result [winfo reqheight .f]
    .p sash place 0 0 20
    lappend result [winfo reqheight .f]
    destroy .p .f .f2
    set result
} [list 10 10]
test panedwindow-12.8 {moving sash restricted to minsize} {
    destroy .p .f .c
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 20] [button .c] -minsize 15
    .p sash place 0 10 0
    pack .p
    update
    set result [winfo width .f]
    destroy .p .f .c
    set result
} 15
test panedwindow-12.10 {moving sash restricted to minsize} {
    destroy .p .f .c
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .f -width 20 -height 30] [button .c] -minsize 10
    .p sash place 0 0 5
    pack .p
    update
    set result [winfo height .f]
    destroy .p .f .c
    set result
} 10
test panedwindow-12.12 {moving sash in unmapped window restricted to reqsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20]
    set result [list [.p sash coord 0]]
    .p sash place 0 100 0
    lappend result [.p sash coord 0]
    destroy .p .f .f2
    set result
} [list {20 0} {40 0}]
test panedwindow-12.13 {moving sash right pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20] \
	    [frame .f3 -width 20 -height 30]
    .p sash place 0 80 0
    set result [list [.p sash coord 0] [.p sash coord 1]]
    destroy .p .f .f2 .f3
    set result
} {{60 0} {64 0}}
test panedwindow-12.14 {moving sash left pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20] \
	    [frame .f3 -width 20 -height 30]
    .p sash place 1 0 0
    set result [list [.p sash coord 0] [.p sash coord 1]]
    destroy .p .f .f2 .f3
    set result
} {{0 0} {4 0}}
test panedwindow-12.15 {move sash in mapped window restricted to visible win} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20] \
	    [frame .f3 -width 20 -height 30]
    place .p -width 50
    update
    .p sash place 1 100 0
    update
    set result [.p sash coord 1]
    destroy .p .f .f2 .f3
    set result
} {46 0}
test panedwindow-12.16 {move sash in mapped window restricted to visible win} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20] \
	    [frame .f3 -width 20 -height 30]
    place .p -width 100
    update
    .p sash place 1 200 0
    update
    set result [.p sash coord 1]
    destroy .p .f .f2 .f3
    set result
} {96 0}
test panedwindow-12.17 {moving sash into "virtual" space on \
	last pane increases reqsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .f -width 20 -height 30] [frame .f2 -width 20 -height 20] \
	    [frame .f3 -width 20 -height 30]
    place .p -width 100
    set result [winfo reqwidth .p]
    update
    .p sash place 1 200 0
    update
    lappend result [winfo reqwidth .p]
    destroy .p .f .f2 .f3
    set result
} {68 100}
    
test panedwindow-13.1 {horizontal panedwindow lays out widgets properly} {
    panedwindow .p -showhandle false -borderwidth 2 -sashpad 2 -sashwidth 2
    foreach win {.p.f .p.f2 .p.f3} {.p add [frame $win -width 20 -height 10]}
    pack .p
    update
    set result {}
    foreach w [.p panes] {lappend result [winfo x $w] [winfo y $w]}
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 2 2 28 2 54 2]
test panedwindow-13.2 {vertical panedwindow lays out widgets properly} {
    panedwindow .p -showhandle false -borderwidth 2 -sashpad 2 -sashwidth 2 \
            -orient vertical
    foreach win {.p.f .p.f2 .p.f3} {.p add [frame $win -width 20 -height 10]}
    pack .p
    update
    set result {}
    foreach w [.p panes] {lappend result [winfo x $w] [winfo y $w]}
    destroy .p .p.f .p.f2 .p.f3
    set result
} [list 2 2 2 18 2 34]
test panedwindow-13.3 {horizontal panedwindow lays out widgets properly} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    foreach {win color} {.p.f blue .p.f2 green} {
	.p add [frame $win -width 20 -height 20 -bg $color] -padx 10 -pady 5 \
                -sticky ""
    }
    pack .p
    update
    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
    foreach win {.p.f .p.f2} {lappend result [winfo x $win] [winfo y $win]}
    .p paneconfigure .p.f -padx 0 -pady 0
    update
    lappend result [winfo reqwidth .p] [winfo reqheight .p]
    foreach win {.p.f .p.f2} {lappend result [winfo x $win] [winfo y $win]}
    destroy .p .p.f .p.f2
    set result
} [list 80 30 10 5 50 5 60 30 0 5 30 5]
test panedwindow-13.4 {vertical panedwindow lays out widgets properly} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0 \
            -orient vertical
    foreach win {.p.f .p.f2} {
	.p add [frame $win -width 20 -height 20] -padx 10 -pady 5 -sticky ""
    }
    pack .p
    update
    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
    foreach win {.p.f .p.f2} {lappend result [winfo x $win] [winfo y $win]}
    .p paneconfigure .p.f -padx 0 -pady 0
    update
    lappend result [winfo reqwidth .p] [winfo reqheight .p]
    foreach win {.p.f .p.f2} {lappend result [winfo x $win] [winfo y $win]}
    destroy .p .p.f .p.f2
    set result
} [list 40 60 10 5 10 35 40 50 10 0 10 25]
test panedwindow-13.5 {panedwindow respects reqsize of panes when possible} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    .p add [frame .p.f -width 20 -height 20] -sticky ""
    place .p -width 40
    update
    set result [list [winfo width .p.f]]
    .p.f configure -width 30
    update
    lappend result [winfo width .p.f]
    destroy .p .p.f
    set result
} [list 20 30]
test panedwindow-13.6 {panedwindow takes explicit widget width over reqwidth} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    .p add [frame .p.f -width 20 -height 20] -width 20 -sticky ""
    place .p -width 40
    update
    set result [list [winfo width .p.f]]
    .p.f configure -width 30
    update
    lappend result [winfo width .p.f]
    destroy .p .p.f
    set result
} [list 20 20]
test panedwindow-13.7 {horizontal panedwindow reqheight is max slave height} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    .p add [frame .p.f -width 20 -height 20] [frame .p.f2 -width 20 -height 20]
    set result [winfo reqheight .p]
    .p.f config -height 40
    lappend result [winfo reqheight .p]
    destroy .p .p.f .p.f2
    set result
} {20 40}
test panedwindow-13.8 {horizontal panedwindow reqheight is max slave height} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    foreach win {.p.f .p.f2} {.p add [frame $win -width 20 -height 20]}
    .p paneconfigure .p.f -height 15
    set result [winfo reqheight .p]
    .p.f config -height 40
    lappend result [winfo reqheight .p]
    destroy .p .p.f .p.f2
    set result
} {20 20}
test panedwindow-13.9 {panedwindow pane width overrides widget width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4
    foreach win {.p.f .p.f2} {.p add [frame $win -width 20 -height 20]}
    .p sash place 0 10 0
    pack .p
    update
    set result [winfo width .p.f]
    .p paneconfigure .p.f -width 30
    lappend result [winfo width .p.f]
    destroy .p .p.f .p.f2
    set result
} [list 10 10]
test panedwindow-13.10 {panedwindow respects reqsize of panes when possible} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    .p add [frame .p.f -width 20 -height 20] -sticky ""
    place .p -height 40
    update
    set result [list [winfo height .p.f]]
    .p.f configure -height 30
    update
    lappend result [winfo height .p.f]
    destroy .p .p.f
    set result
} [list 20 30]
test panedwindow-13.11 {panedwindow takes explicit height over reqheight} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    .p add [frame .p.f -width 20 -height 20] -height 20 -sticky ""
    place .p -height 40
    update
    set result [list [winfo height .p.f]]
    .p.f configure -height 30
    update
    lappend result [winfo height .p.f]
    destroy .p .p.f
    set result
} [list 20 20]
test panedwindow-13.12 {vertical panedwindow reqwidth is max slave width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    .p add [frame .p.f -width 20 -height 20] [frame .p.f2 -width 20 -height 20]
    set result [winfo reqwidth .p]
    .p.f config -width 40
    lappend result [winfo reqwidth .p]
    destroy .p .p.f .p.f2
    set result
} {20 40}
test panedwindow-13.13 {vertical panedwindow reqwidth is max slave width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    foreach win {.p.f .p.f2} {.p add [frame $win -width 20 -height 20]}
    .p paneconfigure .p.f -width 15
    set result [winfo reqwidth .p]
    .p.f config -width 40
    lappend result [winfo reqwidth .p]
    destroy .p .p.f .p.f2
    set result
} {20 20}
test panedwindow-13.14 {panedwindow pane height overrides widget width} {
    destroy .p
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 4 \
            -orient vertical
    foreach win {.p.f .p.f2} {.p add [frame $win -width 20 -height 20]}
    .p sash place 0 0 10
    pack .p
    update
    set result [winfo height .p.f]
    .p paneconfigure .p.f -height 30
    lappend result [winfo height .p.f]
    destroy .p
    set result
} [list 10 10]


test panedwindow-14.1 {PanestructureProc, widget yields managements} {
    # Check that the panedwindow correctly yields geometry management of
    # a slave when the slave is destroyed.

    # This test should not cause a core dump, and it should not cause
    # a memory leak.
    destroy .p .b
    panedwindow .p
    .p add [button .b]
    destroy .p
    pack .b
    destroy .b
    set result ""
} ""
test panedwindow-14.2 {PanedWindowLostSlaveProc, widget yields management} {
    # Check that the paned window correctly yields geometry management of
    # a slave when some other geometry manager steals the slave from us.
    
    # This test should not cause a core dump, and it should not cause a
    # memory leak.
    destroy .p .b
    panedwindow .p
    .p add [button .b]
    pack .p
    update
    pack .b
    update
    set result [.p panes]
    destroy .p .b
    set result
} {}

set stickysets [list n s e w sn ns en ne wn nw esn nse nsw nsew ""]
set stickygets [list n s e w ns ns ne ne nw nw nes nes nsw nesw ""]
set i 0
foreach s $stickysets g $stickygets {
    test panedwindow-15.[incr i] {panedwindow sticky settings} {
	destroy .p .b
	panedwindow .p -showhandle false
	.p add [button .b]
	.p paneconfigure .b -sticky $s
	set result [.p panecget .b -sticky]
	destroy .p .b
	set result
    } $g
}

set i 0
foreach s [list {}  n  s  e  w ns ew nw ne se sw nse nsw sew new news] \
	x [list 10 10 10 20  0 10  0  0 20 20  0  20   0   0   0    0] \
	y [list 10  0 20 10 10  0 10  0  0 20 20   0   0  20   0    0] \
	w [list 20 20 20 20 20 20 40 20 20 20 20  20  20  40  40   40] \
	h [list 20 20 20 20 20 40 20 20 20 20 20  40  40  20  20   40] {
    test panedwindow-16.[incr i] {panedwindow sticky works} {
	panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
	.p add [frame .p.f -height 20 -width 20 -bg red] -sticky $s
	place .p -width 40 -height 40
	update
	set result [list $s [winfo x .p.f] [winfo y .p.f] \
		[winfo width .p.f] [winfo height .p.f]]
	destroy .p .p.f
	set result
    } [list $s $x $y $w $h]
}

test panedwindow-17.1 {setting minsize when pane is too small snaps width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .p.f -height 20 -width 20 -bg red]
    set result [winfo reqwidth .p]
    .p paneconfigure .p.f -minsize 40
    lappend result [winfo reqwidth .p]
    destroy .p .p.f .p.f2
    set result
} [list 20 40]

test panedwindow-18.1 {MoveSash, move right} {
    set result {}
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    # Get the requested width of the paned window
    lappend result [winfo reqwidth .p]
    
    .p sash place 0 30 0
    
    # Get the reqwidth again, to make sure it hasn't changed
    lappend result [winfo reqwidth .p]

    # Check that the sash moved
    lappend result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 42 42 {30 0}]
test panedwindow-18.2 {MoveSash, move right (unmapped) clipped by reqwidth} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should be clipped by the reqwidth of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 40 0]
test panedwindow-18.3 {MoveSash, move right (mapped, width < reqwidth) clipped by width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }
    
    # Put the panedwindow up on the display and give it a width < reqwidth
    place .p -x 0 -y 0 -width 32
    update

    .p sash place 0 100 0
    
    # Get the new sash coord; it should be clipped by the visible width of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 30 0]
test panedwindow-18.4 {MoveSash, move right (mapped, width > reqwidth) clipped by width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }
    
    # Put the panedwindow up on the display and give it a width > reqwidth
    place .p -x 0 -y 0 -width 102
    update

    .p sash place 0 200 0
    
    # Get the new sash coord; it should be clipped by the visible width of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 100 0]
test panedwindow-18.5 {MoveSash, move right respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 30 0]
test panedwindow-18.6 {MoveSash, move right respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should have moved as far as possible.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 40 0]
test panedwindow-18.7 {MoveSash, move right pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 62 0]
test panedwindow-18.8 {MoveSash, move right pushes other sashes, respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 52 0]
test panedwindow-18.9 {MoveSash, move right respects minsize, exludes pad} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize 10 -padx 5
    }

    .p sash place 0 100 0
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 50 0]
test panedwindow-18.10 {MoveSash, move right, negative minsize becomes 0} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize -50
    }

    .p sash place 0 50 0
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [list [.p sash coord 0] [.p sash coord 1]]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list [list 50 0] [list 52 0]]
test panedwindow-18.11 {MoveSash, move left} {
    set result {}
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    # Get the requested width of the paned window
    lappend result [winfo reqwidth .p]
    
    .p sash place 0 10 0
    
    # Get the reqwidth again, to make sure it hasn't changed
    lappend result [winfo reqwidth .p]

    # Check that the sash moved
    lappend result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 42 42 {10 0}]
test panedwindow-18.12 {MoveSash, move left, can't move outside of window} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 -100 0
    
    # Get the new sash coord; it should be clipped by the reqwidth of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 0]
test panedwindow-18.13 {MoveSash, move left respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 10 0]
test panedwindow-18.14 {MoveSash, move left respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 22 0]
test panedwindow-18.15 {MoveSash, move left pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 0]
test panedwindow-18.16 {MoveSash, move left pushes other sashes, respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 10 0]
test panedwindow-18.17 {MoveSash, move left respects minsize, exludes pad} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize 10 -padx 5
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 42 0]
test panedwindow-18.18 {MoveSash, move left, negative minsize becomes 0} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    foreach w {.f1 .f2 .f3} c {red blue green} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize -50
    }

    .p sash place 1 10 0
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [list [.p sash coord 0] [.p sash coord 1]]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list [list 8 0] [list 10 0]]

test panedwindow-19.1 {MoveSash, move down} {
    set result {}
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    # Get the requested width of the paned window
    lappend result [winfo reqheight .p]
    
    .p sash place 0 0 30
    
    # Get the reqwidth again, to make sure it hasn't changed
    lappend result [winfo reqheight .p]

    # Check that the sash moved
    lappend result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 42 42 {0 30}]
test panedwindow-19.2 {MoveSash, move down (unmapped) clipped by reqheight} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should be clipped by the reqheight of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 40]
test panedwindow-19.3 {MoveSash, move down (mapped, height < reqheight) clipped by height} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }
    
    # Put the panedwindow up on the display and give it a height < reqheight
    place .p -x 0 -y 0 -height 32
    update

    .p sash place 0 0 100
    
    # Get the new sash coord; it should be clipped by the visible height of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 30]
test panedwindow-19.4 {MoveSash, move down (mapped, height > reqheight) clipped by height} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }
    
    # Put the panedwindow up on the display and give it a width > reqwidth
    place .p -x 0 -y 0 -height 102
    update

    .p sash place 0 0 200
    
    # Get the new sash coord; it should be clipped by the visible width of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 100]
test panedwindow-19.5 {MoveSash, move down respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 30]
test panedwindow-19.6 {MoveSash, move down respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 40]
test panedwindow-19.7 {MoveSash, move down pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 62]
test panedwindow-19.8 {MoveSash, move down pushes other sashes, respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 52]
test panedwindow-19.9 {MoveSash, move down respects minsize, exludes pad} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize 10 -pady 5
    }

    .p sash place 0 0 100
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 50]
test panedwindow-19.10 {MoveSash, move right, negative minsize becomes 0} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize -50
    }

    .p sash place 0 0 50
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [list [.p sash coord 0] [.p sash coord 1]]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list [list 0 50] [list 0 52]]
test panedwindow-19.11 {MoveSash, move up} {
    set result {}
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    # Get the requested width of the paned window
    lappend result [winfo reqheight .p]
    
    .p sash place 0 0 10
    
    # Get the reqwidth again, to make sure it hasn't changed
    lappend result [winfo reqheight .p]

    # Check that the sash moved
    lappend result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 42 42 {0 10}]
test panedwindow-19.12 {MoveSash, move up, can't move outside of window} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 0 0 -100
    
    # Get the new sash coord; it should be clipped by the reqwidth of
    # the panedwindow.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 0]
test panedwindow-19.13 {MoveSash, move up respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 0 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2

    set result
} [list 0 10]
test panedwindow-19.14 {MoveSash, move up respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 22]
test panedwindow-19.15 {MoveSash, move up pushes other sashes} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 0]
test panedwindow-19.16 {MoveSash, move up pushes other sashes, respects minsize} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] -sticky nsew -minsize 10
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible while
    # respecting minsizes.
    set result [.p sash coord 0]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 10]
test panedwindow-19.17 {MoveSash, move up respects minsize, exludes pad} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize 10 -pady 5
    }

    .p sash place 1 0 0
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [.p sash coord 1]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list 0 42]
test panedwindow-19.18 {MoveSash, move up, negative minsize becomes 0} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    foreach w {.f1 .f2 .f3} c {red blue green} {
	.p add [frame $w -height 20 -width 20 -bg $c] \
		-sticky nsew -minsize -50
    }

    .p sash place 1 0 10
    
    # Get the new sash coord; it should have moved as far as possible, 
    # respecting minsizes.
    set result [list [.p sash coord 0] [.p sash coord 1]]
    
    # Cleanup
    destroy .p .f1 .f2 .f3

    set result
} [list [list 0 8] [list 0 10]]

# The following tests check that the panedwindow is correctly computing its
# geometry based on the various configuration options that can affect the
# geometry.

test panedwindow-20.1 {ComputeGeometry, reqheight taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue]
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .f3 configure -height 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 60 20] [list 60 40]]
test panedwindow-20.2 {ComputeGeometry, reqheight taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue]
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .p paneconfigure .f3 -height 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 60 20] [list 60 40]]
test panedwindow-20.3 {ComputeGeometry, reqheight taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue] -pady 20
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .p paneconfigure .f3 -height 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 60 60] [list 60 80]]
test panedwindow-20.4 {ComputeGeometry, reqwidth taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0 \
            -orient vertical
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue]
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .f3 configure -width 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 20 60] [list 40 60]]
test panedwindow-20.5 {ComputeGeometry, reqwidth taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0 \
            -orient vertical
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue]
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .p paneconfigure .f3 -width 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 20 60] [list 40 60]]
test panedwindow-20.6 {ComputeGeometry, reqwidth taken from widgets} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 0 \
            -orient vertical
    foreach w {.f1 .f2 .f3} {
	.p add [frame $w -width 20 -height 20 -bg blue] -padx 20
    }
    set result [list [list [winfo reqwidth .p] [winfo reqheight .p]]]
    .p paneconfigure .f3 -width 40
    lappend result [list [winfo reqwidth .p] [winfo reqheight .p]]
    destroy .p .f1 .f2 .f3
    set result
} [list [list 60 60] [list 80 60]]

set i 6
foreach bd {0 2} {
    foreach sp {0 5} {
	foreach sw {0 3} {
	    foreach h {0 1} {
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, one slave, reqsize set properly} {
		    # With just one slave, sashpad and sashwidth should not
		    # affect the panedwindow's geometry, since no sash should
		    # ever be drawn.
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h
		    .p add [frame .p.f -width 20 -height 20 -bg red] -padx $h \
                            -sticky ""
		    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
		    destroy .p .p.f
		    set result
		} [list [expr {(2 * $bd) + 20 + (2 * $h)}] \
			[expr {(2 * $bd) + 20}]]
		
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, three panes, reqsize set properly} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h
		    foreach w {.p.f1 .p.f2 .p.f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
                                -sticky ""
		    }
		    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
		    destroy .p .p.f1 .p.f2 .p.f3
		    set result
		} [list [expr {(2 * $bd) + ($h?12:(2*$sw)) + (4*$sp) + 60}] \
			[expr {(2 * $bd) + 20}]]
		
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, sash coords} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h
		    foreach w {.f1 .f2 .f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
                                -sticky ""
		    }
		    set result [list [.p sash coord 0] [.p sash coord 1]]
		    destroy .p .f1 .f2 .f3
		    set result
		} [list [list [expr {$bd+20+($h?(6-$sw)/2:0)+$sp}] $bd] \
			[list [expr {$bd+40+($h?6+(6-$sw)/2:$sw)+(3*$sp)}] \
			    $bd]]

		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry/ArrangePanes, slave coords} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h
		    foreach w {.p.f1 .p.f2 .p.f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
				-sticky nsew -pady 3 -padx 11
		    }
		    pack .p
		    update
		    set result {}
		    foreach w {.p.f1 .p.f2 .p.f3} {
			lappend result [list [winfo x $w] [winfo y $w] \
				[winfo width $w] [winfo height $w]]
		    }
		    destroy .p .p.f1 .p.f2 .p.f3
		    set result
		} [list [list [expr {$bd+11}] [expr {$bd+3}] 20 20] \
			[list [expr {$bd+53+($h?6:$sw)+(2*$sp)}] \
			    [expr {$bd+3}] 20 20] \
			[list [expr {$bd+95+($h?12:2*$sw)+(4*$sp)}] \
			    [expr {$bd+3}] 20 20]]
		
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, one slave, vertical} {
		    # With just one slave, sashpad and sashwidth should not
		    # affect the panedwindow's geometry, since no sash should
		    # ever be drawn.
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -orient vertical -sashwidth $sw -handlesize 6 \
			    -showhandle $h
		    .p add [frame .f -width 20 -height 20 -bg red] -pady $h \
                            -sticky ""
		    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
		    destroy .p .f
		    set result
		} [list [expr {(2 * $bd) + 20}] \
			[expr {(2 * $bd) + 20 + (2 * $h)}]]
		
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, three panes, vertical} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h \
			    -orient vertical
		    foreach w {.f1 .f2 .f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
                                -sticky ""
		    }
		    set result [list [winfo reqwidth .p] [winfo reqheight .p]]
		    destroy .p .f1 .f2 .f3
		    set result
		} [list [expr {(2 * $bd) + 20}] \
			[expr {(2 * $bd) + ($h?12:(2*$sw)) + (4*$sp) + 60}]]
		
		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry, sash coords, vertical} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h \
			    -orient vertical
		    foreach w {.f1 .f2 .f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
                                -sticky ""
		    }
		    set result [list [.p sash coord 0] [.p sash coord 1]]
		    destroy .p .f1 .f2 .f3
		    set result
		} [list [list $bd [expr {$bd+20+($h?(6-$sw)/2:0)+$sp}]] \
			[list $bd \
			    [expr {$bd+40+($h?6+(6-$sw)/2:$sw)+(3*$sp)}]]]

		test panedwindow-20.[incr i]-$bd-$sp-$sw-$h \
			{ComputeGeometry/ArrangePanes, slave coords, vert} {
		    panedwindow .p -borderwidth $bd -sashpad $sp \
			    -sashwidth $sw -handlesize 6 -showhandle $h \
			    -orient vertical
		    foreach w {.p.f1 .p.f2 .p.f3} {
			.p add [frame $w -width 20 -height 20 -bg blue] \
				-sticky nsew -pady 11 -padx 3
		    }
		    pack .p
		    update
		    set result {}
		    foreach w {.p.f1 .p.f2 .p.f3} {
			lappend result [list [winfo x $w] [winfo y $w] \
				[winfo width $w] [winfo height $w]]
		    }
		    destroy .p .p.f1 .p.f2 .p.f3
		    set result
		} [list [list [expr {$bd+3}] [expr {$bd+11}] 20 20] \
			[list [expr {$bd+3}] \
			    [expr {$bd+53+($h?6:$sw)+(2*$sp)}] 20 20] \
			[list [expr {$bd+3}] \
			    [expr {$bd+95+($h?12:2*$sw)+(4*$sp)}] 20 20]]
	    }
	}
    }
}

test panedwindow-21.1 {destroyed widgets are removed from panedwindow} {
    panedwindow .p
    .p add [frame .f -width 20 -height 20 -bg blue]
    destroy .f
    set result [.p panes]
    destroy .p
    set result
} {}
test panedwindow-21.2 {destroyed slave causes geometry recomputation} {
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red]
    destroy .f
    set result [winfo reqwidth .p]
    destroy .p .f2
    set result
} 20
    
test panedwindow-22.1 {ArrangePanes, extra space is given to the last pane} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red] -sticky nsew
    place .p -width 100 -x 0 -y 0
    update
    set result [winfo width .f2]
    destroy .p .f1 .f2
    set result
} 78
test panedwindow-22.2 {ArrangePanes, extra space is given to the last pane} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red] -sticky nsew
    place .p -height 100 -x 0 -y 0
    update
    set result [winfo height .f2]
    destroy .p .f1 .f2
    set result
} 78
test panedwindow-22.3 {ArrangePanes, explicit height/width are preferred} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red] -sticky ""
    .p paneconfigure .f1 -width 10 -height 15
    pack .p
    update
    set result [list [winfo width .f1] [winfo height .f1]]
    destroy .p .f1 .f2
    set result
} {10 15}
test panedwindow-22.4 {ArrangePanes, panes clipped by size of pane} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red]
    .p sash place 0 10 0
    pack .p
    update
    set result [list [winfo width .f1] [winfo height .f1]]
    destroy .p .f1 .f2
    set result
} {10 20}
test panedwindow-22.5 {ArrangePanes, panes clipped by size of pane} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red]
    .p sash place 0 0 10
    pack .p
    update
    set result [list [winfo width .f1] [winfo height .f1]]
    destroy .p .f1 .f2
    set result
} {20 10}
test panedwindow-22.6 {ArrangePanes, height of pane taken from total height} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .p.f1 -width 20 -height 20 -bg blue] \
	    [frame .p.f2 -width 20 -height 40 -bg red] -sticky ""
    pack .p
    update
    set result [list [winfo y .p.f1]]
    destroy .p .p.f1 .p.f2
    set result
} 10
test panedwindow-22.8 {ArrangePanes, width of pane taken from total width} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    .p add [frame .p.f1 -width 20 -height 20 -bg blue] \
	    [frame .p.f2 -width 40 -height 40 -bg red] -sticky ""
    pack .p
    update
    set result [list [winfo x .p.f1]]
    destroy .p .p.f1 .p.f2
    set result
} 10
test panedwindow-22.9 {ArrangePanes, panes with width <= 0 are unmapped} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 40 -bg red]
    pack .p
    update
    set result [winfo ismapped .f1]
    .p sash place 0 0 0
    update
    lappend result [winfo ismapped .f1]
    destroy .p .f1 .f2
    set result
} {1 0}
test panedwindow-22.10 {ArrangePanes, panes with width <= 0 are unmapped} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .p.f1 -width 20 -height 20 -bg blue] \
	    [frame .p.f2 -width 20 -height 40 -bg red]
    pack .p
    update
    set result [winfo ismapped .p.f1]
    .p sash place 0 0 0
    update
    lappend result [winfo ismapped .p.f1]
    destroy .p .p.f1 .p.f2
    set result
} {1 0}
test panedwindow-22.11 {ArrangePanes, panes with width <= 0 are unmapped} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 -orient vertical
    .p add [frame .p.f1 -width 20 -height 20 -bg blue] \
	    [frame .p.f2 -width 20 -height 40 -bg red]
    pack .p
    update
    set result [winfo ismapped .p.f1]
    .p sash place 0 0 0
    update
    lappend result [winfo ismapped .p.f1]
    destroy .p .p.f1 .p.f2
    set result
} {1 0}
test panedwindow-22.12 {ArrangePanes, last pane shrinks} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red] -sticky nsew
    place .p -width 40 -x 0 -y 0
    update
    set result [winfo width .f2]
    destroy .p .f1 .f2
    set result
} 18
test panedwindow-22.13 {ArrangePanes, last pane shrinks} {
    panedwindow .p -showhandle false -borderwidth 0 -sashpad 0 -sashwidth 2 \
            -orient vertical
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 20 -bg red] -sticky nsew
    place .p -height 40 -x 0 -y 0
    update
    set result [winfo height .f2]
    destroy .p .f1 .f2
    set result
} 18
test panedwindow-22.14 {ArrangePanes, panedwindow resizes} {
    -body {
	panedwindow .p -width 200 -borderwidth 0
	frame .f1 -height 50 -bg blue
	set result [list]
	lappend result [winfo reqwidth .p] [winfo reqheight .p]
	.p add .f1
	pack .p
	lappend result [winfo reqwidth .p] [winfo reqheight .p]
    }
    -cleanup {destroy .p .f1}
    -result {200 1 200 50}
}
test panedwindow-22.15 {ArrangePanes, panedwindow resizes} {
    -body {
	panedwindow .p -height 200 -borderwidth 0 -orient vertical
	frame .f1 -width 50 -bg blue
	set result [list]
	lappend result [winfo reqwidth .p] [winfo reqheight .p]
	.p add .f1
	pack .p
	lappend result [winfo reqwidth .p] [winfo reqheight .p]
    }
    -cleanup {destroy .p .f1}
    -result {1 200 50 200}
}
test panedwindow-22.16 {ArrangePanes, last pane grows} {
    -body {
	panedwindow .p -showhandle false -height 50
	.p add [frame .f1 -width 50 -bg red] [frame .f2 -width 50 -bg white] \
		[frame .f3 -width 50 -bg blue] [frame .f4 -width 50 -bg green]
	.p sash place 1 250 0
	pack .p
	update
	set result [list]
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4] [winfo width .p]
	.p configure -width 300
	update
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4] [winfo width .p]
    }
    -cleanup {destroy .p .f1 .f2 .f3 .f4}
    -result {50 150 1 1 211 50 150 1 89 300}
}


test panedwindow-23.1 {PanedWindowReqProc, react to slave geometry changes} {
    # Basically just want to make sure that the PanedWindowReqProc is called
    panedwindow .p -borderwidth 0 -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 20 -height 20 -bg blue] \
	    [frame .f2 -width 20 -height 40 -bg red]
    set result [winfo reqheight .p]
    .f1 configure -height 80
    lappend result [winfo reqheight .p]
    destroy .p .f1 .f2
    set result
} {40 80}
test panedwindow-23.2 {PanedWindowReqProc, react to slave geometry changes} {
    panedwindow .p -orient horizontal -sashpad 0 -sashwidth 2
    .p add [frame .f1 -width 10] [frame .f2 -width 10]
    set result [winfo reqwidth .p]
    .f1 configure -width 20
    lappend result [winfo reqwidth .p]
    destroy .p .f1 .f2
    expr {[lindex $result 1] - [lindex $result 0]}
} {10}


test panedwindow-24.1 {ConfigurePanes, can't add panedwindow to itself} {
    panedwindow .p
    set result [list [catch {.p add .p} msg] $msg]
    destroy .p
    set result
} [list 1 "can't add .p to itself"]
test panedwindow-24.2 {ConfigurePanes, bad window throws error} {
    panedwindow .p
    set result [list [catch {.p add .b} msg] $msg]
    destroy .p
    set result
} [list 1 "bad window path name \".b\""]
test panedwindow-24.3 {ConfigurePanes, bad window aborts processing} {
    panedwindow .p
    button .b
    catch {.p add .b .a}
    set result [.p panes]
    destroy .p .b
    set result
} {}
test panedwindow-24.4 {ConfigurePanes, bad option aborts processing} {
    panedwindow .p
    button .b
    catch {.p add .b -sticky foobar}
    set result [.p panes]
    destroy .p .b
    set result
} {}
test panedwindow-24.5 {ConfigurePanes, after win isn't managed by panedwin} {
    panedwindow .p
    button .b
    button .c
    set result [list [catch {.p add .b -after .c} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "window \".c\" is not managed by .p"]
test panedwindow-24.6 {ConfigurePanes, before win isn't managed by panedwin} {
    panedwindow .p
    button .b
    button .c
    set result [list [catch {.p add .b -before .c} msg] $msg]
    destroy .p .b .c
    set result
} [list 1 "window \".c\" is not managed by .p"]
test panedwindow-24.7 {ConfigurePanes, -after {} is a no-op} {
    panedwindow .p
    .p add [button .b] [button .c]
    .p paneconfigure .b -after {}
    set result [.p panes]
    destroy .p .b .c
    set result
} {.b .c}
test panedwindow-24.8 {ConfigurePanes, -before {} is a no-op} {
    panedwindow .p
    .p add [button .b] [button .c]
    .p paneconfigure .b -before {}
    set result [.p panes]
    destroy .p .b .c
    set result
} {.b .c}
test panedwindow-24.9 {ConfigurePanes, new panes are added} {
    panedwindow .p
    .p add [button .b] [button .c]
    set result [.p panes]
    destroy .p .b .c
    set result
} {.b .c}
test panedwindow-24.10 {ConfigurePanes, options applied to all panes} {
    panedwindow .p
    .p add [button .b] [button .c] -sticky ne -height 5 -width 5 -minsize 10
    set result {}
    foreach w {.b .c} {
	set val {}
	foreach option {-sticky -height -width -minsize} {
	    lappend val $option [.p panecget $w $option]
	}
	lappend result $w $val
    }
    destroy .p .b .c
    set result
} [list .b {-sticky ne -height 5 -width 5 -minsize 10} \
	.c {-sticky ne -height 5 -width 5 -minsize 10}]
test panedwindow-24.11 {ConfigurePanes, existing panes are reconfigured} {
    panedwindow .p
    .p add [button .b] -sticky nw -height 10
    .p add .b [button .c] -sticky se -height 2
    set result [list [.p panes] \
	    [.p panecget .b -sticky] [.p panecget .b -height] \
	    [.p panecget .c -sticky] [.p panecget .c -height]]
    destroy .p .b .c
    set result
} [list {.b .c} es 2 es 2]
test panedwindow-24.12 {ConfigurePanes, widgets added to end by default} {
    panedwindow .p
    .p add [button .b]
    .p add [button .c]
    .p add [button .d]
    set result [.p panes]
    destroy .p .b .c .d
    set result
} {.b .c .d}
test panedwindow-24.13 {ConfigurePanes, -after, single addition} {
    panedwindow .p
    button .a
    button .b
    button .c

    .p add .a .b
    .p add .c -after .a
    set result [.p panes]
    destroy .p .a .b .c
    set result
} {.a .c .b}
test panedwindow-24.14 {ConfigurePanes, -after, multiple additions} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b
    .p add .c .d -after .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.a .c .d .b}
test panedwindow-24.15 {ConfigurePanes, -after, relocates existing widget} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c .d
    .p add .d -after .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.a .d .b .c}
test panedwindow-24.16 {ConfigurePanes, -after, relocates existing widgets} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c .d
    .p add .b .d -after .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.a .b .d .c}
test panedwindow-24.17 {ConfigurePanes, -after, relocates existing widgets} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c .d
    .p add .d .a -after .b
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.b .d .a .c}
test panedwindow-24.18 {ConfigurePanes, -after, relocates existing widgets} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c .d
    .p add .d .a -after .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.d .a .b .c}
test panedwindow-24.19 {ConfigurePanes, -after, after last window} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c
    .p add .d -after .c
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.a .b .c .d}
test panedwindow-24.20 {ConfigurePanes, -before, before first window} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c
    .p add .d -before .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.d .a .b .c}
test panedwindow-24.21 {ConfigurePanes, -before, relocate existing windows} {
    panedwindow .p
    button .a
    button .b
    button .c
    button .d

    .p add .a .b .c
    .p add .d .b -before .a
    set result [.p panes]
    destroy .p .a .b .c .d
    set result
} {.d .b .a .c}
test panedwindow-24.22 {ConfigurePanes, slave specified multiple times} {
    # This test should not cause a core dump

    panedwindow .p
    button .a
    button .b
    button .c

    .p add .a .a .b .c
    set result [.p panes]
    destroy .p .a .b .c
    set result
} {.a .b .c}
test panedwindow-24.23 {ConfigurePanes, slave specified multiple times} {
    # This test should not cause a core dump

    panedwindow .p
    button .a
    button .b
    button .c

    .p add .a .a .b .c
    .p add .a .b .a -after .c
    set result [.p panes]
    destroy .p .a .b .c
    set result
} {.c .a .b}
test panedwindow-24.24 {ConfigurePanes, panedwindow cannot manage toplevels} {
    panedwindow .p
    toplevel .t
    set result [list [catch {.p add .t} msg] $msg]
    destroy .p .t
    set result
} [list 1 "can't add toplevel .t to .p"]
test panedwindow-24.25 {ConfigurePanes, restrict possible panes} {
    panedwindow .p
    frame .f
    button .f.b
    set result [list [catch {.p add .f.b} msg] $msg]
    destroy .p .f .f.b
    set result
} [list 1 "can't add .f.b to .p"]
test panedwindow-24.26 {ConfigurePanes, restrict possible panes} {
    frame .f
    panedwindow .f.p
    button .b
    set result [list [catch {.f.p add .b} msg] $msg]
    destroy .f.p .f .b
    set result
} [list 0 ""]
test panedwindow-24.27 {ConfigurePanes, restrict possible panes} {
    panedwindow .p
    button .p.b
    set result [list [catch {.p add .p.b} msg] $msg]
    destroy .p .p.b
    set result
} [list 0 ""]
test panedwindow-24.28 {ConfigurePanes, restrict possible panes} {
    frame .f
    frame .f.f
    frame .f.f.f
    panedwindow .f.f.f.p
    button .b
    set result [list [catch {.f.f.f.p add .b} msg] $msg]
    destroy .f .f.f .f.f.f .f.f.f.p .b
    set result
} [list 0 ""]
test panedwindow-24.29.1 {ConfigurePanes, -hide works} {
    -body {
	panedwindow .p -showhandle false
	frame .f1 -width 40 -height 100 -bg red
	frame .f2 -width 40 -height 100 -bg white
	frame .f3 -width 40 -height 100 -bg blue
	frame .f4 -width 40 -height 100 -bg green
	.p add .f1 .f2 .f3 .f4
	pack .p
	update
	set result [list]
	lappend result [winfo ismapped .f1] [winfo ismapped .f2] \
		[winfo ismapped .f3] [winfo ismapped .f4]
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4] [winfo width .p]
	.p paneconfigure .f2 -hide 1
	update
	lappend result [winfo ismapped .f1] [winfo ismapped .f2] \
		[winfo ismapped .f3] [winfo ismapped .f4]
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4] [winfo width .p]
    }
    -cleanup {destroy .p .f1 .f2 .f3 .f4}
    -result {1 1 1 1 40 40 40 40 171 1 0 1 1 40 40 40 40 128}
}
test panedwindow-24.29.2 {ConfigurePanes, -hide works} {
    -body {
	panedwindow .p -showhandle false -width 130 -height 100
	frame .f1 -width 40 -bg red
	frame .f2 -width 40 -bg white
	frame .f3 -width 40 -bg blue
	frame .f4 -width 40 -bg green
	.p add .f1 .f2 .f3 .f4
	pack .p
	update
	set result [list]
	lappend result [winfo ismapped .f1] [winfo ismapped .f2] \
		[winfo ismapped .f3] [winfo ismapped .f4]
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4] [winfo width .p]
	.p paneconfigure .f2 -hide 1
	update
	lappend result [winfo ismapped .f1] [winfo ismapped .f2] \
		[winfo ismapped .f3] [winfo ismapped .f4]
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4] [winfo width .p]
    }
    -cleanup {destroy .p .f1 .f2 .f3 .f4}
    -result {1 1 1 0 39 40 40 1 130 1 0 1 1 40 40 40 42 130}
}
test panedwindow-24.29.3 {ConfigurePanes, -hide works, last pane stretches} {
    -body {
	panedwindow .p -showhandle false -width 200 -height 200 -borderwidth 0
	frame .f1 -width 50 -bg red
	frame .f2 -width 50 -bg green
	frame .f3 -width 50 -bg blue
	.p add .f1 .f2 .f3
	pack .p
	update
	set result [list]
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3]
	.p paneconfigure .f2 -hide 1
	update
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3]
    }
    -cleanup {destroy .p .f1 .f2 .f3}
    -result {50 50 94 50 50 147}
}
test panedwindow-24.29.4 {ConfigurePanes, -hide works, last pane stretches} {
    -body {
	panedwindow .p -showhandle false -width 200 -height 200 \
		-borderwidth 0 -orient vertical
	frame .f1 -height 50 -bg red
	frame .f2 -height 50 -bg green
	frame .f3 -height 50 -bg blue
	.p add .f1 .f2 .f3
	pack .p
	update
	set result [list]
	lappend result [winfo height .f1] [winfo height .f2] [winfo height .f3]
	.p paneconfigure .f2 -hide 1
	update
	lappend result [winfo height .f1] [winfo height .f2] [winfo height .f3]
    }
    -cleanup {destroy .p .f1 .f2 .f3}
    -result {50 50 94 50 50 147}
}

test panedwindow-24.30 {ConfigurePanes, -stretch first} {
    -body {
	panedwindow .p -showhandle false -height 100 -width 182
	frame .f1 -width 40 -bg red
	frame .f2 -width 40 -bg white
	frame .f3 -width 40 -bg blue
	frame .f4 -width 40 -bg green
	.p add .f1 .f2 .f3 .f4 -stretch first
	pack .p
	update
	set result [list]
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4]
	.p paneconfigure .f2 -hide 1
	update
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4]
    }
    -cleanup {destroy .p .f1 .f2 .f3 .f4}
    -result {51 40 40 40 94 40 40 40}
}
test panedwindow-24.31 {ConfigurePanes, -stretch middle} {
    -body {
	panedwindow .p -showhandle false -height 100 -width 182
	frame .f1 -width 40 -bg red
	frame .f2 -width 40 -bg white
	frame .f3 -width 40 -bg blue
	frame .f4 -width 40 -bg green
	.p add .f1 .f2 .f3 .f4 -stretch middle
	pack .p
	update
	set result [list]
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4]
	.p paneconfigure .f2 -hide 1
	update
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4]
    }
    -cleanup {destroy .p .f1 .f2 .f3 .f4}
    -result {40 45 46 40 40 45 94 40}
}
test panedwindow-24.32 {ConfigurePanes, -stretch always} {
    -body {
	panedwindow .p -showhandle false -height 100 -width 182
	frame .f1 -width 40 -bg red
	frame .f2 -width 40 -bg white
	frame .f3 -width 40 -bg blue
	frame .f4 -width 40 -bg green
	.p add .f1 .f2 .f3 .f4 -stretch always
	pack .p
	update
	set result [list]
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4]
	.p paneconfigure .f2 -hide 1
	update
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4]
    }
    -cleanup {destroy .p .f1 .f2 .f3 .f4}
    -result {42 43 43 43 58 43 58 58}
}
test panedwindow-24.33 {ConfigurePanes, -stretch never} {
    -body {
	panedwindow .p -showhandle false -height 100 -width 182
	frame .f1 -width 40 -bg red
	frame .f2 -width 40 -bg white
	frame .f3 -width 40 -bg blue
	frame .f4 -width 40 -bg green
	.p add .f1 .f2 .f3 .f4 -stretch never
	pack .p
	update
	set result [list]
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4]
	.p paneconfigure .f2 -hide 1
	update
	lappend result [winfo width .f1] [winfo width .f2] [winfo width .f3] \
		[winfo width .f4]
    }
    -cleanup {destroy .p .f1 .f2 .f3 .f4}
    -result {40 40 40 40 40 40 40 40}
}

test panedwindow-25.1 {Unlink, remove a paned with -before/-after refs} {
    # Bug 928413
    set result {}
    panedwindow .pw
    label .pw.l1 -text Label1
    label .pw.l2 -text Label2
    label .pw.l3 -text Label3
    .pw add .pw.l1
    .pw add .pw.l3
    .pw add .pw.l2 -before .pw.l3
    lappend result [.pw panecget .pw.l2 -before]
    destroy .pw.l3
    lappend result [.pw panecget .pw.l2 -before]
    .pw paneconfigure .pw.l2 -before .pw.l1
    lappend result [.pw panecget .pw.l2 -before]
    destroy .pw
    set result
} {.pw.l3 {} .pw.l1}

test panedwindow-26.1 {DestroyPanedWindow} {
    # This test should not result in any memory leaks.
    panedwindow .p
    foreach w {.a .b .c .d .e .f .g .h .i .j .k .l .m .n .o .q .r .s .t} {
	.p add [button $w]
    }
    foreach w {.a .b .c .d .e .f .g .h .i .j .k .l .m .n .o .p .q .r .s .t} {
	destroy $w
    }
    set result {}
} {}

test panedwindow-27.1 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 0]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.2 {PanedWindowIdentifyCoords, padding is included} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 20 0]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.3 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 22 0]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.4 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 24 0]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.5 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 26 0]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.6 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 26 -1]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.7 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 26 100]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.8 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 6
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 22 4]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.9 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 6
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 22 5]
    destroy .p .f .f2
    set result
} {0 handle}
test panedwindow-27.10 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 8
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 20 5]
    destroy .p .f .f2
    set result
} {0 handle}
test panedwindow-27.11 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 8
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 20 0]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.12 {PanedWindowIdentifyCoords} {
    panedwindow .p -showhandle false -bd 0 -sashwidth 2 -sashpad 2
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20] \
	    [frame .f3 -bg green -width 20 -height 20]
    set result [.p identify 48 0]
    destroy .p .f .f2 .f3
    set result
} {1 sash}
test panedwindow-27.13 {identify subcommand errors} {
    panedwindow .p -borderwidth 0 -sashpad 2 -sashwidth 4
    set result [list [catch {.p identify} msg] $msg]
    destroy .p
    set result
} [list 1 "wrong # args: should be \".p identify x y\""]
test panedwindow-27.14 {identify subcommand errors} {
    panedwindow .p
    set result [list [catch {.p identify foo bar} msg] $msg]
    destroy .p
    set result
} [list 1 "expected integer but got \"foo\""]
test panedwindow-27.14a {identify subcommand errors} {
    panedwindow .p
    set result [list [catch {.p identify 0 bar} msg] $msg]
    destroy .p
    set result
} [list 1 "expected integer but got \"bar\""]
test panedwindow-27.15 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 0]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.16 {PanedWindowIdentifyCoords, padding is included} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 20]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.17 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 22]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.18 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 24]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.19 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 26]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.20 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify -1 26]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.21 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 100 26]
    destroy .p .f .f2
    set result
} {}
test panedwindow-27.22 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 6 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 4 22]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.23 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 6 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 5 22]
    destroy .p .f .f2
    set result
} {0 handle}
test panedwindow-27.24 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 8 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 5 20]
    destroy .p .f .f2
    set result
} {0 handle}
test panedwindow-27.25 {PanedWindowIdentifyCoords} {
    panedwindow .p -bd 0 -sashwidth 2 -sashpad 2 -showhandle 1 -handlepad 5 \
	    -handlesize 8 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20]
    set result [.p identify 0 20]
    destroy .p .f .f2
    set result
} {0 sash}
test panedwindow-27.26 {PanedWindowIdentifyCoords} {
    panedwindow .p -showhandle false -bd 0 -sashwidth 2 -sashpad 2 -orient vertical
    .p add [frame .f -bg red -width 20 -height 20] \
	    [frame .f2 -bg blue -width 20 -height 20] \
	    [frame .f3 -bg green -width 20 -height 20]
    set result [.p identify 0 48]
    destroy .p .f .f2 .f3
    set result
} {1 sash}

test panedwindow-28.1 {destroy the window cleanly on error [Bug #616589]} {
    list [catch {panedwindow .p -bogusopt bogus} msg] $msg
} {1 {unknown option "-bogusopt"}}
test panedwindow-28.2 {destroy the window cleanly on rename [Bug #616589]} {
    destroy .p
    panedwindow .p
    rename .p {}
    winfo exists .p
} {0}


test panedwindow-29.1 {resizing width} {
    -body {
        panedwindow .p -bd 5
        frame .f1 -width 100 -height 50 -bg blue
        frame .f2 -width 100 -height 50 -bg red

        .p add .f1 -sticky news
        .p add .f2 -sticky news
        pack .p -side top -fill both -expand 1
        wm geometry . ""
        update
        # Note the width
        set a [winfo width .f2]
        # Increase the size by 10
        regexp {^(\d+)x(\d+)} [wm geometry .] -> w h
        wm geometry . [expr {$w + 10}]x$h
        update
        set b "$a [winfo width .f2]"
    }
    -cleanup {destroy .p .f1 .f2}
    -result {100 110}
}

test panedwindow-29.2 {resizing height} {
    -body {
        panedwindow .p -orient vertical -bd 5
        frame .f1 -width 50 -height 100 -bg blue
        frame .f2 -width 50 -height 100 -bg red

        .p add .f1 -sticky news
        .p add .f2 -sticky news
        pack .p -side top -fill both -expand 1
        wm geometry . ""
        update
        # Note the height
        set a [winfo height .f2]
        # Increase the size by 10
        regexp {^(\d+)x(\d+)} [wm geometry .] -> w h
        wm geometry . ${w}x[expr {$h + 10}]
        update
        set b "$a [winfo height .f2]"
    }
    -cleanup {destroy .p .f1 .f2}
    -result {100 110}
}

test panedwindow-30.1 {display on depths other than the default one} {
    -constraints {pseudocolor8 haveTruecolor24}
    -body {
	toplevel .t -visual {truecolor 24}
	pack [panedwindow .t.p]
	.t.p add [frame .t.p.f1] [frame .t.p.f2]
	update
	# If we got here, we didn't crash and that's good
    }
    -cleanup {destroy .t}
    -result {}
}
test panedwindow-30.2 {display on depths other than the default one} {
    -constraints {pseudocolor8 haveTruecolor24}
    -body {
	toplevel .t -visual {pseudocolor 8}
	pack [frame .t.f -visual {truecolor 24}]
	pack [panedwindow .t.f.p]
	.t.f.p add [frame .t.f.p.f1 -width 5] [frame .t.f.p.f2 -width 5]
	update
	.t.f.p proxy place 1 1
	update
	.t.f.p proxy forget
	update
	# If we got here, we didn't crash and that's good
    }
    -cleanup {destroy .t}
    -result {}
}

# cleanup
cleanupTests
return
