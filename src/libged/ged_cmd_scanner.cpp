/*             G E D _ C M D _ S C A N N E R . C P P
 * BRL-CAD
 *
 * Copyright (c) 2024-2025 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file ged_cmd_scanner.cpp
 *
 * Automatically scan for LIBGED plugin signatures in source code files in
 * order to extract information for use in build systems and management code.
 */

#include <cstdio>
#include <fstream>
#include <iostream>
#include <regex>
#include <string>
#include <vector>
#include <set>
#include <cstdlib>
#include <algorithm>
#include <map>

// Meta markers for detecting auto-generated outputs
const std::string GEN_MARKER = "// Auto-generated by ged_cmd_scanner for force static registration";
const std::string EXEC_API_MARKER = "// Auto-generated by ged_cmd_scanner for command exec API wrappers";

// Helper: read source paths from file (one per line)
std::vector<std::string> load_file_list(const std::string& path) {
    std::vector<std::string> files;
    std::ifstream fs(path);
    if (!fs.is_open()) {
	std::cerr << "Unable to open input list file: " << path << "\n";
	return files;
    }
    std::string line;
    while (std::getline(fs, line)) {
	const auto start = line.find_first_not_of(" \t\r\n");
	const auto end = line.find_last_not_of(" \t\r\n");
	if (start == std::string::npos || end == std::string::npos || line.empty())
	    continue;
	std::string clean = line.substr(start, end - start + 1);
	if (!clean.empty()) files.push_back(clean);
    }
    return files;
}

// Map ged_cmd_impl struct names to their command name strings, for robust lookup
using ImplNameToCmdMap = std::map<std::string, std::string>;

int main(int argc, const char *argv[])
{
    if (argc < 2) {
	std::cerr << "Usage:\n";
	std::cerr << "  ged_cmd_scanner [--input-list <input.txt>] [--gen-force-cpp <static.cpp>] [--gen-exec-api-cpp <exec_api.cpp> --gen-exec-api-hdr <exec_api.h>] <input_file1.cpp> ...\n";
	return EXIT_FAILURE;
    }

    bool gen_force_cpp = false;
    bool gen_exec_api_cpp = false;
    bool gen_exec_api_hdr = false;
    std::string cpp_file;
    std::string exec_api_file;
    std::string exec_api_hdr_file;
    std::string input_list_file;
    std::vector<std::string> input_files;

    // Parse args
    for (int i = 1; i < argc; ++i) {
	std::string arg(argv[i]);
	if (arg == "--gen-force-cpp") {
	    if (i + 1 < argc) {
		gen_force_cpp = true;
		cpp_file = argv[++i];
	    } else {
		std::cerr << "Missing filename after --gen-force-cpp\n";
		return EXIT_FAILURE;
	    }
	} else if (arg == "--gen-exec-api-cpp") {
	    if (i + 1 < argc) {
		gen_exec_api_cpp = true;
		exec_api_file = argv[++i];
	    } else {
		std::cerr << "Missing filename after --gen-exec-api-cpp\n";
		return EXIT_FAILURE;
	    }
	} else if (arg == "--gen-exec-api-hdr") {
	    if (i + 1 < argc) {
		gen_exec_api_hdr = true;
		exec_api_hdr_file = argv[++i];
	    } else {
		std::cerr << "Missing filename after --gen-exec-api-hdr\n";
		return EXIT_FAILURE;
	    }
	} else if (arg == "--input-list") {
	    if (i + 1 < argc) {
		input_list_file = argv[++i];
		continue;
	    } else {
		std::cerr << "Missing filename after --input-list\n";
		return EXIT_FAILURE;
	    }
	} else {
	    input_files.push_back(arg);
	}
    }

    if (!input_list_file.empty()) {
	std::vector<std::string> from_file = load_file_list(input_list_file);
	input_files.insert(input_files.end(), from_file.begin(), from_file.end());
    }

    // ========= Static registration extraction ==========
    std::set<std::string> static_cmd_symbols;
    std::regex reg_cmd_macro(R"(REGISTER_GED_COMMAND\s*\(\s*([A-Za-z0-9_]+)\s*\))");
    std::regex reg_label_macro(R"(LABEL_GED_COMMAND\s*\(\s*([A-Za-z0-9_]+)\s*\))");

    /* Phase 3: detect generalized registration macro with string command names */
    std::set<std::string> cmd_names;
    std::regex reg_bu_cmd_macro(R"(REGISTER_BU_PLUGIN_COMMAND\s*\(\s*\"([^\"]+)\"\s*,)");

    /* Phase 4: detect bu_plugin_cmd arrays used by the new plugin manifest pattern */
    std::regex reg_pcmd_name(R"(\{\s*\"([A-Za-z0-9?_]+)\"\s*,)");

    /* Phase 5: detect canonical TU-local command lists (token-based X-macro form)
     *
     * Expected form:
     *   #define GED_SOMETHING_COMMANDS(X, XID) \
     *     X(token, fn, opts) \
     *     XID(symbol, "cmdname", fn, opts)
     *
     * Notes:
     * - We intentionally parse *raw source*, not preprocessed output.
     * - Therefore, the list must be written literally in the TU.
     */
    std::regex reg_list_begin(R"(^\s*#\s*define\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(\s*X\s*,\s*XID\s*\)\s*\\\s*$)");
    std::regex reg_list_x_entry(R"(\bX\s*\(\s*([A-Za-z_][A-Za-z0-9_]*)\s*,\s*([A-Za-z_][A-Za-z0-9_]*)\s*,\s*([^\)]*)\)\s*\\?\s*$)");
    std::regex reg_list_xid_entry(R"(\bXID\s*\(\s*([A-Za-z_][A-Za-z0-9_]*)\s*,\s*\"((?:\\.|[^\"\\])*)\"\s*,\s*([A-Za-z_][A-Za-z0-9_]*)\s*,\s*([^\)]*)\)\s*\\?\s*$)");

    /* Phase 5 parsing pass */
    for (const auto &fname : input_files) {
	std::ifstream fs(fname);
	if (!fs.is_open()) {
	    // Keep consistent with other passes: warn and continue
	    std::cerr << "Unable to open file " << fname << "\n";
	    continue;
	}

	std::string sline;
	bool in_list = false;

	while (std::getline(fs, sline)) {

	    if (!in_list) {
		std::smatch lm;
		if (std::regex_match(sline, lm, reg_list_begin)) {
		    in_list = true;
		    continue;
		}
		// not in list; keep scanning
		continue;
	    }

	    // If we are in a list body:
	    // Parse X(...) and XID(...) entries. Ignore everything else.
	    {
		std::smatch xm;
		if (std::regex_search(sline, xm, reg_list_x_entry)) {
		    const std::string token = xm[1];
		    // static registration symbol is token##_cmd
		    static_cmd_symbols.insert(token + "_cmd");
		    // wrapper names are token strings by default
		    cmd_names.insert(token);
		}
	    }
	    {
		std::smatch xim;
		if (std::regex_search(sline, xim, reg_list_xid_entry)) {
		    const std::string sym = xim[1];
		    const std::string cmd = xim[2];
		    static_cmd_symbols.insert(sym);
		    // Maintain existing behavior: skip weird wrappers (e.g. "?")
		    if (!cmd.empty() && cmd.find('?') == std::string::npos) {
			cmd_names.insert(cmd);
		    }
		}
	    }

	    // End of macro list body detection:
	    // In a typical X-macro definition, each continued line ends with '\'.
	    // The last line *may* end without '\' (or could still have it).
	    // We treat a line that does NOT end with '\' as the end of the list.
	    //
	    // Also, empty lines typically would not be used in macro bodies, but
	    // if they appear they will end the list unless they also end with '\'.
	    bool ends_with_backslash = false;
	    {
		// strip trailing whitespace for test
		size_t end = sline.find_last_not_of(" \t\r\n");
		if (end != std::string::npos && sline[end] == '\\') {
		    ends_with_backslash = true;
		}
	    }
	    if (!ends_with_backslash) {
		in_list = false;
	    }
	}
	fs.close();
    }

    /* Existing Phase 1â€“4 parsing pass (legacy heuristics; kept for backwards compatibility) */
    for (const auto &fname : input_files) {
	std::ifstream fs(fname);
	if (!fs.is_open()) {
	    std::cerr << "Unable to open file " << fname << "\n";
	    continue;
	}
	std::string sline;
	while (std::getline(fs, sline)) {
	    std::smatch mm;
	    if (std::regex_search(sline, mm, reg_cmd_macro)) {
		static_cmd_symbols.insert(mm[1]);
	    }
	    std::smatch lm;
	    if (std::regex_search(sline, lm, reg_label_macro)) {
		static_cmd_symbols.insert(lm[1]);
	    }
	    /* Phase 3: capture command names from REGISTER_BU_PLUGIN_COMMAND */
	    std::smatch bm;
	    if (std::regex_search(sline, bm, reg_bu_cmd_macro)) {
		std::string cname = bm[1];
		if (!cname.empty() && cname.find('?') == std::string::npos)
		    cmd_names.insert(cname);
	    }
	    /* Phase 4: capture command names from bu_plugin_cmd initializers */
	    std::smatch pm;
	    if (std::regex_search(sline, pm, reg_pcmd_name)) {
		std::string cname = pm[1];
		if (!cname.empty() && cname.find('?') == std::string::npos)
		    cmd_names.insert(cname);
	    }
	}
	fs.close();
    }

    // ========= Wrapper API command name extraction =========
    // NOTE: cmd_names may already contain entries found via REGISTER_BU_PLUGIN_COMMAND or Phase 5.
    // We now supplement it with names found via ged_cmd_impl initializers.

    // Multi-line struct initializer support (`ged_cmd_impl` detection)
    std::regex reg_impl_begin(R"(struct\s+ged_cmd_impl\s+([A-Za-z0-9_]+)\s*=\s*\{)");
    std::regex reg_impl_cmd_str("\"([A-Za-z0-9?_]+)\"");

    for (const auto &fname : input_files) {
	std::ifstream fs(fname);
	if (!fs.is_open()) continue;
	std::string sline;
	bool in_cmd_impl = false;
	// After finding ged_cmd_impl, scan for first quoted string
	while (std::getline(fs, sline)) {
	    if (!in_cmd_impl) {
		if (std::regex_search(sline, reg_impl_begin)) {
		    in_cmd_impl = true;
		}
	    } else {
		std::smatch m;
		if (std::regex_search(sline, m, reg_impl_cmd_str)) {
		    std::string cmd = m[1];
		    if (cmd.find('?') == std::string::npos) {
			cmd_names.insert(cmd);
		    }
		    in_cmd_impl = false; // Only first quoted string used
		}
		// If struct ends without finding command, abort scanning
		if (sline.find("};") != std::string::npos || sline.find("}") != std::string::npos) {
		    in_cmd_impl = false;
		}
	    }
	}
	fs.close();
    }

    // Fallback for classic single-line initializers
    std::regex cmd_impl_regex(".*ged_cmd_impl.*");
    std::regex cmd_str_regex(".*\"([A-Za-z0-9?_]+)\".*");
    for (const auto &fname : input_files) {
	std::ifstream fs(fname);
	if (!fs.is_open()) continue;
	std::string sline;
	bool in_cmd_impl = false;
	while (std::getline(fs, sline)) {
	    if (in_cmd_impl) {
		std::smatch parsevar;
		if (std::regex_search(sline, parsevar, cmd_str_regex)) {
		    std::string cmd = parsevar.str(1);
		    if (cmd.find('?') != std::string::npos)
			continue;
		    cmd_names.insert(cmd);
		    in_cmd_impl = false;
		}
	    } else {
		if (std::regex_match(sline, cmd_impl_regex)) {
		    std::smatch parsevar;
		    if (std::regex_search(sline, parsevar, cmd_str_regex)) {
			std::string cmd = parsevar.str(1);
			if (cmd.find('?') != std::string::npos)
			    continue;
			cmd_names.insert(cmd);
		    } else {
			in_cmd_impl = true;
		    }
		}
	    }
	}
	fs.close();
    }

    // Supplement from macro+impl lookup for edge cases
    // Map ged_cmd_impl struct names to their command name strings, for robust lookup
    ImplNameToCmdMap impl_to_cmd;
    for (const auto &fname : input_files) {
	std::ifstream fs(fname);
	if (!fs.is_open()) continue;
	std::string sline;
	bool in_cmd_impl = false;
	std::string awaiting_cmdimpl_name;
	while (std::getline(fs, sline)) {
	    if (!in_cmd_impl) {
		std::smatch impl_begin;
		if (std::regex_search(sline, impl_begin, reg_impl_begin)) {
		    awaiting_cmdimpl_name = impl_begin[1];
		    in_cmd_impl = true;
		}
	    } else {
		std::smatch cmd_str_match;
		if (std::regex_search(sline, cmd_str_match, reg_impl_cmd_str)) {
		    std::string cmd_str = cmd_str_match[1];
		    if (cmd_str.find('?') == std::string::npos) // skip weird names
			impl_to_cmd[awaiting_cmdimpl_name] = cmd_str;
		    in_cmd_impl = false;
		}
		if (sline.find("};") != std::string::npos || sline.find("}") != std::string::npos) {
		    in_cmd_impl = false;
		}
	    }
	}
	fs.close();
    }
    for (const auto &macro_arg : static_cmd_symbols) {
	std::string suffix = "_cmd";
	if (macro_arg.size() > suffix.size() &&
		macro_arg.compare(macro_arg.size()-suffix.size(), suffix.size(), suffix) == 0)
	{
	    std::string impl_name = macro_arg + "_impl";
	    auto it = impl_to_cmd.find(impl_name);
	    if (it != impl_to_cmd.end()) {
		cmd_names.insert(it->second);
	    }
	}
    }

    // Sorted output for deterministic builds
    std::vector<std::string> static_cmd_sorted(static_cmd_symbols.begin(), static_cmd_symbols.end());
    std::sort(static_cmd_sorted.begin(), static_cmd_sorted.end());
    std::vector<std::string> cmds_sorted(cmd_names.begin(), cmd_names.end());
    std::sort(cmds_sorted.begin(), cmds_sorted.end());

    // Static registration file (--gen-force-cpp)
    if (gen_force_cpp) {
	std::ifstream testfs(cpp_file);
	if (testfs.is_open()) {
	    std::string first_line;
	    std::getline(testfs, first_line);
	    testfs.close();
	    if (first_line != GEN_MARKER) {
		std::cerr << "ERROR: " << cpp_file << " already exists but doesn't appear to be an auto-generated registration file.\n";
		std::cerr << "       Refusing to overwrite. Rename or remove the file to allow generation.\n";
		return EXIT_FAILURE;
	    }
	}
	std::ofstream ofs(cpp_file, std::ios::out | std::ios::trunc);
	if (!ofs.is_open()) {
	    std::cerr << "Cannot open output C++ file: " << cpp_file << "\n";
	    return EXIT_FAILURE;
	}
	ofs << GEN_MARKER << "\n";
	ofs << "#include \"plugin.h\"\n\n";
	for (const auto &cmd_macro : static_cmd_sorted) {
	    ofs << "extern \"C\" const struct ged_cmd * const __ged_cmd_ptr_" << cmd_macro << ";\n";
	}
	ofs << "\nextern \"C\" void ged_force_static_registration(void)\n{\n";
	for (const auto &cmd_macro : static_cmd_sorted) {
	    ofs << "    (void)ged_register_command(__ged_cmd_ptr_" << cmd_macro << ");\n";
	}
	ofs << "}\n";
	ofs.close();
	return EXIT_SUCCESS;
    }

    // Exec API wrapper header and source
    if (gen_exec_api_cpp && gen_exec_api_hdr) {
	// Header: generated from original ged_cmds.h content
	std::ofstream hdr(exec_api_hdr_file, std::ios::out | std::ios::trunc);
	if (!hdr.is_open()) {
	    std::cerr << "Cannot open output header file: " << exec_api_hdr_file << "\n";
	    return EXIT_FAILURE;
	}
	hdr << "/*                      G E D _ C M D S . H\n"
	    << " * BRL-CAD\n"
	    << " *\n"
	    << " * Copyright (c) 2024-2025 United States Government as represented by\n"
	    << " * the U.S. Army Research Laboratory.\n"
	    << " *\n"
	    << " * This library is free software; you can redistribute it and/or\n"
	    << " * modify it under the terms of the GNU Lesser General Public License\n"
	    << " * version 2.1 as published by the Free Software Foundation.\n"
	    << " *\n"
	    << " * This library is distributed in the hope that it will be useful, but\n"
	    << " * WITHOUT ANY WARRANTY; without even the implied warranty of\n"
	    << " * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n"
	    << " * Lesser General Public License for more details.\n"
	    << " *\n"
	    << " * You should have received a copy of the GNU Lesser General Public\n"
	    << " * License along with this file; see the file named COPYING for more\n"
	    << " * information.\n"
	    << " */\n"
	    << "/** @file ged_cmds.h\n"
	    << " *\n"
	    << " * Autogenerated header defining C function calls for LIBGED commands.  Under\n"
	    << " * the hood the commands are run with ged_exec, and calling ged_exec directly\n"
	    << " * will produce the same results calling these functions will.  However, raw\n"
	    << " * ged_exec calls provide no compile time checking as to whether a particular\n"
	    << " * LIBGED command is actually *available* as a LIBGED plugin.  Programs like\n"
	    << " * gsh need ged_exec because user inputs will be defining commands, but when\n"
	    << " * hard-coding LIBGED command executions into other functions or language\n"
	    << " * bindings that abstraction means disconnects can be detected ONLY with\n"
	    << " * run-time tests - the C/C++ compiler is helpless.\n"
	    << " *\n"
	    << " * Using the following functions in your code will allow you to know\n"
	    << " * immediately upon compilation when a change in BRL-CAD has removed or renamed\n"
	    << " * a command you are using.\n"
	    << " *\n"
	    << " * There is one additional difference between calling these wrappers and using\n"
	    << " * a raw ged_exec call.  The wrapper functions will set the argv[0] command\n"
	    << " * name for you if you have set it to NULL in your code.  The advantage of this\n"
	    << " * is to simplify code updating if a command is renamed - you will have only\n"
	    << " * one thing to update - the wrapper name - rather than needing to update both\n"
	    << " * the function name and the cmd string.  There is no harm in setting the string,\n"
	    << " * and the wrapper functions will not override or check a non-NULL argv[0] if one\n"
	    << " * is passed in.\n"
	    << " */\n\n";
	hdr << "#include \"common.h\"\n";
	hdr << "#include \"ged/defines.h\"\n";
	hdr << "#include \"ged/commands.h\"\n";
	hdr << "__BEGIN_DECLS\n";
	for (const auto &cmd : cmds_sorted) {
	    hdr << "GED_EXPORT extern int ged_exec_" << cmd << "(struct ged *, int, const char **);\n";
	}
	hdr << "__END_DECLS\n";
	hdr.close();

	// Source: always begins with #include "ged/ged_cmds.h"
	std::ofstream src(exec_api_file, std::ios::out | std::ios::trunc);
	if (!src.is_open()) {
	    std::cerr << "Cannot open output C++ file: " << exec_api_file << "\n";
	    return EXIT_FAILURE;
	}
	src << EXEC_API_MARKER << "\n";
	src << "#include \"ged/ged_cmds.h\"\n";
	for (const auto &cmd : cmds_sorted) {
	    src << "int ged_exec_" << cmd << "(struct ged *gedp, int argc, const char **argv) {\n";
	    src << "    static const char *cmdname = \"" << cmd << "\";\n";
	    src << "    if (!argv) return BRLCAD_ERROR;\n";
	    src << "    if (argc > 0 && !argv[0]) argv[0] = cmdname;\n";
	    src << "    if (!argv[0]) argv[0] = cmdname;\n";
	    src << "    return ged_exec(gedp, argc, argv);\n";
	    src << "}\n";
	}
	src.close();
	return EXIT_SUCCESS;
    } else if (gen_exec_api_cpp || gen_exec_api_hdr) {
	std::cerr << "ERROR: Both --gen-exec-api-cpp <cpp_file> and --gen-exec-api-hdr <hdr_file> must be specified together.\n";
	return EXIT_FAILURE;
    }

    // Fallback: stdout for plain list mode (rare, mostly for testing)
    for (const auto &cmd : cmds_sorted) {
	std::cout << cmd << "\n";
    }
    return EXIT_SUCCESS;
}

// Local Variables:
// tab-width: 8
// mode: C++
// c-basic-offset: 4
// indent-tabs-mode: t
// c-file-style: "stroustrup"
// End:
// ex: shiftwidth=4 tabstop=8 cino=N-s
