int: neg1 = -1;
var -100..100: AX :: output_var;
var -100..100: AY :: output_var;
var -100..100: AZ :: output_var;
var -100..100: BX :: output_var;
var -100..100: BY :: output_var;
var -100..100: BZ :: output_var;
var int : AXBX;
var int : AYBY;
var int : AZBZ;
var int : NAZBZ;
var int : AXAX;
var int : AYAY;
var int : AXY;
var int : AZAZ;
var int : AXYZ;
var int : BXBX;
var int : BYBY;
var int : BXY;
var int : BZBZ;
var int : BXYZ;
constraint int_times(AX, BX, AXBX);
constraint int_times(AY, BY, AYBY);
constraint int_times(AZ, BZ, AZBZ);
constraint int_times(AZBZ, neg1, NAZBZ);
constraint int_plus(AXBX, AYBY, NAZBZ);

constraint int_times(AX, AX, AXAX);
constraint int_times(AY, AY, AYAY);
constraint int_times(AZ, AZ, AZAZ);
constraint int_times(BX, BX, BXBX);
constraint int_times(BY, BY, BYBY);
constraint int_times(BZ, BZ, BZBZ);
constraint int_plus(AXAX, AYAY, AXY);
constraint int_plus(AXY, AZAZ, AXYZ);
constraint int_plus(BXBX, BYBY, BXY);
constraint int_plus(BXY, BZBZ, BXYZ);
constraint int_eq(AXYZ, BXYZ);
%constraint int_eq(AX, 32);
%solve minimize AY;
solve satisfy;
