/*             L E V E N S H T E I N _ U L L . H P P
 * BRL-CAD
 *
 * Published in 2025 by the United States Government.
 * This work is in the public domain.
 *
 * Generated via interaction with Github Copilot GPT-4.1
 */
/** @file levenshtein_ull.hpp
 *
 * Purpose of this routine is to be able to access the similarity of two
 * vectors of unsigned long long values generated by bu_data_hash.
 */

#pragma once
#include <vector>
#include <algorithm>
#include <cstddef>
#include <limits>
#include <cstdlib>

// Header-only Levenshtein distance for arrays of unsigned long long.
// Supports early abandonment with optional k.
// If distance > k, returns k+1.
namespace levenshtein_ull {

inline std::size_t distance(
	const std::vector<unsigned long long>& a,
	const std::vector<unsigned long long>& b,
	std::size_t k = std::numeric_limits<std::size_t>::max()
	) {
    const std::size_t len_a = a.size();
    const std::size_t len_b = b.size();

    if (len_a == 0) return std::min(len_b, k + 1);
    if (len_b == 0) return std::min(len_a, k + 1);

    if (k != std::numeric_limits<std::size_t>::max() &&
	    static_cast<std::size_t>(std::abs(static_cast<long long>(len_a) - static_cast<long long>(len_b))) > k)
	return k + 1;

    std::vector<std::size_t> prev_row(len_b + 1, 0);
    std::vector<std::size_t> curr_row(len_b + 1, 0);

    for (std::size_t j = 0; j <= len_b; ++j)
	prev_row[j] = j;

    for (std::size_t i = 1; i <= len_a; ++i) {
	std::size_t from = (i > k) ? i - k : 1;
	std::size_t to = std::min(len_b, i + k);

	curr_row[0] = i;

	// Fill band
	for (std::size_t j = from; j <= to; ++j) {
	    std::size_t cost = (a[i - 1] == b[j - 1]) ? 0 : 1;
	    std::size_t deletion = prev_row[j] + 1;
	    std::size_t insertion = curr_row[j - 1] + 1;
	    std::size_t substitution = prev_row[j - 1] + cost;
	    curr_row[j] = std::min({deletion, insertion, substitution});
	}

	if (from > 1)
	    curr_row[from - 1] = k + 1;
	if (to < len_b)
	    for (std::size_t j = to + 1; j <= len_b; ++j)
		curr_row[j] = k + 1;

	std::swap(prev_row, curr_row);
    }

    return (prev_row[len_b] <= k) ? prev_row[len_b] : k + 1;
}

} // namespace levenshtein_ull

// Local Variables:
// tab-width: 8
// mode: C++
// c-basic-offset: 4
// indent-tabs-mode: t
// c-file-style: "stroustrup"
// End:
// ex: shiftwidth=4 tabstop=8 cino=N-s
