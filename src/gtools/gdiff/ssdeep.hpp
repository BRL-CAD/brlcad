// Original source code was https://github.com/kolos450/SsdeepNET
//
// The MIT License (MIT)
//
// Copyright (c) 2015 kolos450
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// This C++ translation was generated via Github Copilot GPT-4.1
// 7/15/2025 Clifford Yapp (starseeker)
// License and BRL-CAD formatting applied manually.
//
// The following is an autogenerated example of comparing two hashes
// to get a similarity rating
//
// #include "ssdeep.hpp"
// #include <fstream>
// #include <vector>
// #include <iostream>
//
// std::vector<uint8_t> read_file(const std::string& filename) {
//     std::ifstream file(filename, std::ios::binary);
//     // Handle file open error
//     if (!file) throw std::runtime_error("Cannot open file: " + filename);
//     return std::vector<uint8_t>((std::istreambuf_iterator<char>(file)), {});
// }
//
// int main(int argc, char** argv) {
//     if (argc != 3) {
//         std::cerr << "Usage: " << argv[0] << " file1.bin file2.bin\n";
//         return 1;
//     }
//
//     try {
//         // Read both files as binary
//         std::vector<uint8_t> data1 = read_file(argv[1]);
//         std::vector<uint8_t> data2 = read_file(argv[2]);
//
//         ssdeep::FuzzyHash hasher;
//
//         std::string hash1 = hasher.compute(data1);
//         std::string hash2 = hasher.compute(data2);
//
//         std::cout << "File 1: " << argv[1] << "\nHash: " << hash1 << "\n";
//         std::cout << "File 2: " << argv[2] << "\nHash: " << hash2 << "\n";
//
//         int similarity = hasher.compare(hash1, hash2);
//         std::cout << "Similarity score: " << similarity << std::endl;
//     } catch (const std::exception& ex) {
//         std::cerr << "Error: " << ex.what() << std::endl;
//         return 1;
//     }
//
//     return 0;
// }

#pragma once
#include <string>
#include <vector>
#include <stdexcept>
#include <algorithm>
#include <cstdint>
#include <sstream>

namespace ssdeep {

// --- Constants ---
constexpr int ROLLING_WINDOW = 7;
constexpr int MIN_BLOCKSIZE = 3;
constexpr int SPAMSUM_LENGTH = 64;
constexpr int MAX_RESULT_LENGTH = 2 * SPAMSUM_LENGTH + 20;
constexpr char b64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// --- Rolling hash state ---
class Roll {
    public:
	Roll() { reset(); }

	void reset() {
	    a = b = c = n = 0;
	    std::fill(std::begin(window), std::end(window), 0);
	}

	void update(uint8_t x) {
	    a = (a - window[n % ROLLING_WINDOW] + x);
	    b = (b - a + ROLLING_WINDOW * x);
	    c = (c << 5) ^ x;
	    window[n % ROLLING_WINDOW] = x;
	    n++;
	}

	uint32_t sum() const {
	    return a + b + c;
	}

    private:
	uint32_t a, b, c, n;
	uint32_t window[ROLLING_WINDOW];
};

// --- FuzzyHash Algorithm class ---
class FuzzyHash {
    public:
	FuzzyHash() = default;

	// Compute fuzzy hash for bytes
	std::string compute(const std::vector<uint8_t>& data) {
	    if (data.empty()) return "";

	    int blocksize = pick_blocksize(static_cast<int>(data.size()));
	    std::string sig1 = produce_signature(data, blocksize);
	    std::string sig2 = produce_signature(data, blocksize * 2);

	    std::ostringstream out;
	    out << blocksize << ":" << sig1 << ":" << sig2;
	    return out.str();
	}

	// Compute fuzzy hash for string
	std::string compute(const std::string& str) {
	    std::vector<uint8_t> data(str.begin(), str.end());
	    return compute(data);
	}

	// Compare two fuzzy hashes
	int compare(const std::string& hash1, const std::string& hash2) const {
	    return CompareHashes(hash1, hash2);
	}

	// Static utility: compare two hashes (public)
	static int CompareHashes(const std::string& x, const std::string& y) {
	    if (x.empty() || y.empty()) throw std::invalid_argument("Input is null or empty.");
	    auto get_colon = [](const std::string& s, size_t from) { return s.find(':', from); };
	    auto get_comma = [](const std::string& s, size_t from) { return s.find(',', from); };
	    size_t colon1Pos = x.find(':');
	    size_t colon2Pos = y.find(':');
	    if (colon1Pos == std::string::npos || colon2Pos == std::string::npos)
		throw std::invalid_argument("Badly formed input.");
	    int blockSize1 = std::stoi(x.substr(0, colon1Pos));
	    int blockSize2 = std::stoi(y.substr(0, colon2Pos));
	    if (blockSize1 < 0 || blockSize2 < 0)
		throw std::invalid_argument("Badly formed input.");
	    if (blockSize1 != blockSize2 && blockSize1 != blockSize2 * 2 && blockSize2 != blockSize1 * 2) return 0;
	    size_t colon12Pos = get_colon(x, colon1Pos + 1), colon22Pos = get_colon(y, colon2Pos + 1);
	    if (colon12Pos == std::string::npos || colon22Pos == std::string::npos)
		throw std::invalid_argument("Badly formed input.");
	    size_t comma1Pos = get_comma(x, colon12Pos + 1), comma2Pos = get_comma(y, colon22Pos + 1);

	    std::string s1_1 = x.substr(colon1Pos + 1, colon12Pos - colon1Pos - 1);
	    std::string s2_1 = y.substr(colon2Pos + 1, colon22Pos - colon2Pos - 1);
	    std::string s1_2 = x.substr(colon12Pos + 1, (comma1Pos == std::string::npos ? x.length() : comma1Pos) - colon12Pos - 1);
	    std::string s2_2 = y.substr(colon22Pos + 1, (comma2Pos == std::string::npos ? y.length() : comma2Pos) - colon22Pos - 1);

	    if (s1_1.empty() || s2_1.empty() || s1_2.empty() || s2_2.empty())
		throw std::invalid_argument("Badly formed input.");

	    s1_1 = EliminateSequences(s1_1);
	    s2_1 = EliminateSequences(s2_1);
	    s1_2 = EliminateSequences(s1_2);
	    s2_2 = EliminateSequences(s2_2);

	    if (blockSize1 == blockSize2 && s1_1.size() == s2_1.size() && s1_1 == s2_1) return 100;

	    if (blockSize1 == blockSize2) {
		return std::max(
			ScoreStrings(s1_1, s2_1, blockSize1),
			ScoreStrings(s1_2, s2_2, blockSize1 * 2));
	    } else if (blockSize1 == blockSize2 * 2) {
		return ScoreStrings(s1_1, s2_2, blockSize1);
	    } else {
		return ScoreStrings(s1_2, s2_1, blockSize2);
	    }
	}

    private:
	// Pick blocksize to keep signatures within SPAMSUM_LENGTH
	static int pick_blocksize(int input_length) {
	    int blocksize = MIN_BLOCKSIZE;
	    while (blocksize * SPAMSUM_LENGTH < input_length) {
		blocksize *= 2;
	    }
	    return blocksize;
	}

	// Produce a base64 signature for a given blocksize
	std::string produce_signature(const std::vector<uint8_t>& data, int blocksize) {
	    std::string result;
	    Roll roll;
	    uint32_t h = 0;
	    for (size_t i = 0; i < data.size(); ++i) {
		roll.update(data[i]);
		h = (h * 31 + data[i]) & 0xFFFFFFFF;

		if (roll.sum() % blocksize == (blocksize - 1)) {
		    result += b64[h % 64];
		    if (result.size() >= SPAMSUM_LENGTH)
			break;
		    h = 0;
		}
	    }
	    if (result.size() < SPAMSUM_LENGTH && h != 0)
		result += b64[h % 64];
	    return result;
	}

	// FuzzyHash comparison helpers
	static std::string EliminateSequences(const std::string& str, int maxLen = 3) {
	    if (str.empty()) return str;
	    std::string result;
	    result.reserve(str.size());
	    char last_char = str[0];
	    int count = 1;
	    result.push_back(last_char);

	    for (size_t i = 1; i < str.size(); ++i) {
		if (str[i] == last_char) {
		    if (count < maxLen) result.push_back(str[i]);
		    count++;
		} else {
		    last_char = str[i];
		    count = 1;
		    result.push_back(str[i]);
		}
	    }
	    return (result.size() == str.size()) ? str : result;
	}

	static int EditDistance(const std::string& s1, const std::string& s2) {
	    constexpr int MaxLength = 64;
	    constexpr int InsertCost = 1, RemoveCost = 1, ReplaceCost = 2;
	    int t0[MaxLength + 1] = {0}, t1[MaxLength + 1] = {0};
	    int len1 = static_cast<int>(s1.size()), len2 = static_cast<int>(s2.size());

	    for (int i = 0; i <= len2; ++i) t0[i] = i;
	    for (int i = 0; i < len1; ++i) {
		t1[0] = i + 1;
		for (int j = 0; j < len2; ++j) {
		    int cost_a = t0[j + 1] + InsertCost;
		    int cost_d = t1[j] + RemoveCost;
		    int cost_r = t0[j] + (s1[i] == s2[j] ? 0 : ReplaceCost);
		    t1[j + 1] = std::min({cost_a, cost_d, cost_r});
		}
		std::swap(t0, t1);
	    }
	    return t0[len2];
	}

	static bool HasCommonSubstring(const std::string& s1, const std::string& s2) {
	    std::vector<uint32_t> hashes;
	    Roll state;
	    for (char c : s1) {
		state.update(static_cast<uint8_t>(c));
		hashes.push_back(state.sum());
	    }
	    state = Roll();
	    for (size_t i = 0; i < s2.size(); ++i) {
		state.update(static_cast<uint8_t>(s2[i]));
		uint32_t h = state.sum();
		if (i < ROLLING_WINDOW - 1) continue;
		for (size_t j = ROLLING_WINDOW - 1; j < hashes.size(); ++j) {
		    if (hashes[j] != 0 && hashes[j] == h) {
			size_t s2StartPos = i - ROLLING_WINDOW + 1;
			size_t s1StartPos = j - ROLLING_WINDOW + 1;
			if (s2StartPos + ROLLING_WINDOW > s2.size() || s1StartPos + ROLLING_WINDOW > s1.size()) continue;
			bool matched = true;
			for (int pos = 0; pos < ROLLING_WINDOW; ++pos) {
			    if (s1[s1StartPos + pos] != s2[s2StartPos + pos]) {
				matched = false; break;
			    }
			}
			if (matched) return true;
		    }
		}
	    }
	    return false;
	}

	static int ScoreStrings(const std::string& s1, const std::string& s2, int blockSize) {
	    int len1 = static_cast<int>(s1.size()), len2 = static_cast<int>(s2.size());
	    if (len1 > SPAMSUM_LENGTH || len2 > SPAMSUM_LENGTH) return 0;
	    if (!HasCommonSubstring(s1, s2)) return 0;
	    int score = EditDistance(s1, s2);
	    score = (score * SPAMSUM_LENGTH) / (len1 + len2);
	    score = (100 * score) / 64;
	    if (score >= 100) return 0;
	    score = 100 - score;
	    int matchSize = blockSize / MIN_BLOCKSIZE * std::min(len1, len2);
	    if (score > matchSize) score = matchSize;
	    return score;
	}
};

} // namespace ssdeep

// Local Variables:
// tab-width: 8
// mode: C++
// c-basic-offset: 4
// indent-tabs-mode: t
// c-file-style: "stroustrup"
// End:
// ex: shiftwidth=4 tabstop=8 cino=N-s
