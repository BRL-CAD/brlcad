// Original C# source code located at https://github.com/kolos450/SsdeepNET
//
// The MIT License (MIT)
//
// Copyright (c) 2015 kolos450
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// This C++ translation was generated and adjusted to do multipass reading for
// streaming large files using Github Copilot GPT-4.1
// July 2025 Clifford Yapp (starseeker)
//
// (SsdeepNET license and BRL-CAD formatting applied manually.)
//
// The following is an autogenerated example of comparing two hashes
// to get a similarity rating
//
// #include "ssdeep.hpp"
// #include <iostream>
// #include <exception>
//
// int main(int argc, char** argv) {
//     try {
//         if (argc != 3) {
//             std::cerr << "Usage: " << argv[0] << " file1 file2\n";
//             return 1;
//         }
//
//         std::string sig1 = ssdeep::FuzzyHash::compute_from_file(argv[1]);
//         std::string sig2 = ssdeep::FuzzyHash::compute_from_file(argv[2]);
//
//         std::cout << "Hash for " << argv[1] << ": " << sig1 << '\n';
//         std::cout << "Hash for " << argv[2] << ": " << sig2 << '\n';
//
//         int score = ssdeep::FuzzyHash::CompareHashes(sig1, sig2);
//         std::cout << "Similarity: " << score << std::endl;
//     } catch (const std::exception& ex) {
//         std::cerr << "Error: " << ex.what() << std::endl;
//         return 2;
//     } catch (...) {
//         std::cerr << "Unknown error occurred." << std::endl;
//         return 3;
//     }
//     return 0;
// }

#pragma once
#include <algorithm>
#include <cstdint>
#include <fstream>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

namespace ssdeep {

// --- Constants ---
constexpr size_t ROLLING_WINDOW = 7;
constexpr int MIN_BLOCKSIZE = 3;
constexpr size_t SPAMSUM_LENGTH = 64;
constexpr char b64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

// --- Rolling hash state ---
class Roll {
    public:
	Roll() { reset(); }

	void reset() {
	    a = b = c = n = 0;
	    std::fill(std::begin(window), std::end(window), 0);
	}

	void update(uint8_t x) {
	    a = (a - window[n % ROLLING_WINDOW] + x);
	    b = (b - a + ROLLING_WINDOW * x);
	    c = (c << 5) ^ x;
	    window[n % ROLLING_WINDOW] = x;
	    n++;
	}

	uint32_t sum() const {
	    return a + b + c;
	}

    private:
	uint32_t a, b, c, n;
	uint32_t window[ROLLING_WINDOW];
};

// --- FuzzyHash Algorithm class ---
//
// Suitable for very large files, but you must provide a filename (or an open
// std::istream& at position 0).
class FuzzyHash {
    public:
	static std::string compute_from_file(const std::string& filename) {
	    // 1. First pass: determine file size
	    std::ifstream fin(filename, std::ios::binary | std::ios::ate);
	    if (!fin) throw std::runtime_error("Cannot open file: " + filename);
	    std::streamoff file_size = fin.tellg();
	    if (file_size < 0)
		throw std::runtime_error("Could not determine file size.");
	    fin.clear();
	    fin.seekg(0, std::ios::beg);
	    size_t size = static_cast<size_t>(file_size);
	    size_t blocksize = pick_blocksize(size);
	    std::string sig1 = stream_signature(fin, blocksize);
	    fin.clear();
	    fin.seekg(0, std::ios::beg);
	    std::string sig2 = stream_signature(fin, blocksize * 2);

	    std::ostringstream out;
	    out << blocksize << ":" << sig1 << ":" << sig2;
	    return out.str();
	}

	// If you already know the file size, you can avoid the first pass.
	static std::string compute_from_stream(std::istream& in, size_t filesize) {
	    size_t blocksize = pick_blocksize(filesize);
	    std::string sig1 = stream_signature(in, blocksize);
	    in.clear();
	    in.seekg(0, std::ios::beg);
	    std::string sig2 = stream_signature(in, blocksize * 2);
	    std::ostringstream out;
	    out << blocksize << ":" << sig1 << ":" << sig2;
	    return out.str();
	}

	// Compare two fuzzy hashes
	static int CompareHashes(const std::string& x, const std::string& y) {
	    if (x.empty() || y.empty()) throw std::invalid_argument("Input is null or empty.");
	    auto get_colon = [](const std::string& s, size_t from) { return s.find(':', from); };
	    auto get_comma = [](const std::string& s, size_t from) { return s.find(',', from); };
	    size_t colon1Pos = x.find(':');
	    size_t colon2Pos = y.find(':');
	    if (colon1Pos == std::string::npos || colon2Pos == std::string::npos)
		throw std::invalid_argument("Badly formed input.");
	    int blockSize1 = std::stoi(x.substr(0, colon1Pos));
	    int blockSize2 = std::stoi(y.substr(0, colon2Pos));
	    if (blockSize1 < 0 || blockSize2 < 0)
		throw std::invalid_argument("Badly formed input.");
	    if (blockSize1 != blockSize2 && blockSize1 != blockSize2 * 2 && blockSize2 != blockSize1 * 2)
		return 0;
	    size_t colon12Pos = get_colon(x, colon1Pos + 1), colon22Pos = get_colon(y, colon2Pos + 1);
	    if (colon12Pos == std::string::npos || colon22Pos == std::string::npos)
		throw std::invalid_argument("Badly formed input.");
	    size_t comma1Pos = get_comma(x, colon12Pos + 1), comma2Pos = get_comma(y, colon22Pos + 1);

	    std::string s1_1 = x.substr(colon1Pos + 1, colon12Pos - colon1Pos - 1);
	    std::string s2_1 = y.substr(colon2Pos + 1, colon22Pos - colon2Pos - 1);
	    std::string s1_2 = x.substr(colon12Pos + 1, (comma1Pos == std::string::npos ? x.length() : comma1Pos) - colon12Pos - 1);
	    std::string s2_2 = y.substr(colon22Pos + 1, (comma2Pos == std::string::npos ? y.length() : comma2Pos) - colon22Pos - 1);

	    if (s1_1.empty() || s2_1.empty() || s1_2.empty() || s2_2.empty())
		throw std::invalid_argument("Badly formed input.");

	    s1_1 = EliminateSequences(s1_1);
	    s2_1 = EliminateSequences(s2_1);
	    s1_2 = EliminateSequences(s1_2);
	    s2_2 = EliminateSequences(s2_2);

	    if (blockSize1 == blockSize2 && s1_1.size() == s2_1.size() && s1_1 == s2_1)
		return 100;

	    if (blockSize1 == blockSize2) {
		return std::max(
			ScoreStrings(s1_1, s2_1, blockSize1),
			ScoreStrings(s1_2, s2_2, blockSize1 * 2));
	    } else if (blockSize1 == blockSize2 * 2) {
		return ScoreStrings(s1_1, s2_2, blockSize1);
	    } else {
		return ScoreStrings(s1_2, s2_1, blockSize2);
	    }
	}

    private:
	// Pick blocksize to keep signatures within SPAMSUM_LENGTH
	static size_t pick_blocksize(size_t input_length) {
	    size_t blocksize = MIN_BLOCKSIZE;
	    while (blocksize * SPAMSUM_LENGTH < input_length)
		blocksize *= 2;
	    return blocksize;
	}

	// Produce a base64 signature for a given blocksize
	static std::string stream_signature(std::istream& in, int blocksize) {
	    std::string result;
	    Roll roll;
	    uint32_t h = 0;
	    const size_t bufsize = 4096;
	    uint8_t buf[bufsize];
	    size_t processed = 0;
	    while (in) {
		in.read(reinterpret_cast<char*>(buf), static_cast<std::streamsize>(bufsize));
		std::streamsize n = in.gcount();
		for (size_t i = 0; i < static_cast<size_t>(n); ++i, ++processed) {
		    roll.update(buf[i]);
		    h = (h * 31 + buf[i]) & 0xFFFFFFFF;
		    if (roll.sum() % static_cast<uint32_t>(blocksize) == static_cast<uint32_t>(blocksize - 1)) {
			result += b64[h % 64];
			if (result.size() >= SPAMSUM_LENGTH)
			    return result;
			h = 0;
		    }
		}
	    }
	    if (result.size() < SPAMSUM_LENGTH && h != 0)
		result += b64[h % 64];
	    return result;
	}

	// FuzzyHash comparison helpers
	static std::string EliminateSequences(const std::string& str, int maxLen = 3) {
	    if (str.empty())
		return str;
	    std::string result;
	    result.reserve(str.size());
	    char last_char = str[0];
	    int count = 1;
	    result.push_back(last_char);

	    for (size_t i = 1; i < str.size(); ++i) {
		if (str[i] == last_char) {
		    if (count < maxLen) result.push_back(str[i]);
		    count++;
		} else {
		    last_char = str[i];
		    count = 1;
		    result.push_back(str[i]);
		}
	    }
	    return (result.size() == str.size()) ? str : result;
	}

	static size_t EditDistance(const std::string& s1, const std::string& s2) {
	    constexpr size_t MaxLength = 64;
	    constexpr size_t InsertCost = 1, RemoveCost = 1, ReplaceCost = 2;
	    size_t t0[MaxLength + 1] = {0}, t1[MaxLength + 1] = {0};
	    size_t len1 = s1.size(), len2 = s2.size();

	    for (size_t i = 0; i <= len2; ++i)
		t0[i] = i;
	    for (size_t i = 0; i < len1; ++i) {
		t1[0] = i + 1;
		for (size_t j = 0; j < len2; ++j) {
		    size_t cost_a = t0[j + 1] + InsertCost;
		    size_t cost_d = t1[j] + RemoveCost;
		    size_t cost_r = t0[j] + (s1[i] == s2[j] ? 0 : ReplaceCost);
		    t1[j + 1] = std::min({cost_a, cost_d, cost_r});
		}
		std::swap(t0, t1);
	    }
	    return t0[len2];
	}

	static bool HasCommonSubstring(const std::string& s1, const std::string& s2) {
	    std::vector<uint32_t> hashes;
	    Roll state;
	    for (char c : s1) {
		state.update(static_cast<uint8_t>(c));
		hashes.push_back(state.sum());
	    }
	    state = Roll();
	    for (size_t i = 0; i < s2.size(); ++i) {
		state.update(static_cast<uint8_t>(s2[i]));
		uint32_t h = state.sum();
		if (i + 1 < ROLLING_WINDOW)
		    continue;
		for (size_t j = ROLLING_WINDOW - 1; j < hashes.size(); ++j) {
		    if (hashes[j] != 0 && hashes[j] == h) {
			size_t s2StartPos = i + 1 - ROLLING_WINDOW;
			size_t s1StartPos = j + 1 - ROLLING_WINDOW;
			if (s2StartPos + ROLLING_WINDOW > s2.size() || s1StartPos + ROLLING_WINDOW > s1.size())
			    continue;
			bool matched = true;
			for (size_t pos = 0; pos < ROLLING_WINDOW; ++pos) {
			    if (s1[s1StartPos + pos] != s2[s2StartPos + pos]) {
				matched = false;
				break;
			    }
			}
			if (matched)
			    return true;
		    }
		}
	    }
	    return false;
	}

	static size_t ScoreStrings(const std::string& s1, const std::string& s2, int blockSize) {
	    size_t len1 = s1.size(), len2 = s2.size();
	    if (len1 > SPAMSUM_LENGTH || len2 > SPAMSUM_LENGTH)
		return 0;
	    if (!HasCommonSubstring(s1, s2))
		return 0;
	    size_t score = EditDistance(s1, s2);
	    score = (score * SPAMSUM_LENGTH) / (len1 + len2);
	    score = (100 * score) / 64;
	    if (score >= 100)
		return 0;
	    score = 100 - score;
	    size_t matchSize = blockSize / MIN_BLOCKSIZE * std::min(len1, len2);
	    if (score > matchSize)
		score = matchSize;
	    return score;
	}
};

} // namespace ssdeep

// Local Variables:
// tab-width: 8
// mode: C++
// c-basic-offset: 4
// indent-tabs-mode: t
// c-file-style: "stroustrup"
// End:
// ex: shiftwidth=4 tabstop=8 cino=N-s
