<html><head>
<title>BRL-CAD tabsub Man Page</title>
</head><body>
<h1>NAME</h1>
tabsub - macro expand an input table into an animation script
<h1>SYNOPSIS</h1>
<b>tabsub</b>
<b>template_file</b>
<b>&lt;table.final</b>
<b>&gt;&gt;script</b>
<h1>DESCRIPTION</h1>
<i>tabsub</i>
takes as input a data table on standard input
(such as might have been produced by
<i>tabinterp</i>(1)
or similar tool),
and a template file named on the command line.
For each row (line) of the input table, one complete copy of
the template file is output on standard output.
As the template is output,
any macro invocations in the template file are replaced with
the data values from the input table's current row.
In the input table, any blank lines or lines with a pound sign ('#')
as the first character are ignored, allowing comments to be
added to the input table.
<p>
Macro invocations in the template file all begin with an at-sign ('@').
In order to send an at-sign through to the output, a second at-sign
must immediately follow it, <i>e.g.</i> when '@@' is encountered in the
template, a single '@' is output.
To output the data value found in a given channel in the current
input row of the data table, the at-sign is followed by the channel
number, <i>e.g.</i> to output the value in channel four, specify '@4',
and to output the value in channel 42, specify '@42'.
In some circumstances it my be desirable to highlight the difference
between channel value substitution, and literal numeric values.
To facilitate this, the channel number may be enclosed in parenthesis
to explicitly delimit the macro invocation.  For example, channel
four could also be specified as '@(4)', and channel 42 as '@(42)'.
This second notation is generally preferred.
<p>
The
<i>tabsub</i>
program is intended primarily for creating scripts relating to animation.
To facilitate this, a variety of more complex macros also exist.
<p>
   @(line)
<p>
will output the row (line) number of the input table which is currently
being processed, with the first line being numbered zero.
This is useful for creating frame numbers, or other sequence tags
in the output.
<p>
   @(time)
<p>
will output the time value which is always found in the left-most column
of the current row.
<p>
The more complex macros can also take arguments.
If the first character of an argument is an at-sign ('@')
(or percent-sign ('%'), for backwards compatibility), then
the number that follows signifies an input channel substitution
as before.  Otherwise the value is taken literally.
<p>
The
<b>rot</b>
macro is used to convert three Euler angles given in degrees
into a rotation expressed as a
4x4 homogeneous transformation matrix.
<p>
   @(rot x_angle y_angle z_angle)
<p>
The arguments may be either numeric constants, column value macros,
or a combination of both.
The matrix is generated by calling the
<i>librt</i>(3)
routine
<b>mat_angles</b>
which performs the rotation around the Z axis first, then Y, then X.
For example, the macro
<p>
   @(rot 0 0 45)
<p>
creates the following matrix, a 45 degree rotation about Z:
<p>
<pre>
7.071067812e-01 -7.071067812e-01 0.000000000e+00 0.000000000e+00
7.071067812e-01 7.071067812e-01 -0.000000000e+00 0.000000000e+00
0.000000000e+00 0.000000000e+00 1.000000000e+00 0.000000000e+00
0.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+00
</pre>
<p>
Similarly, the macro
<p>
   @(rot @4 @5 90)
<p>
creates a rotation matrix where the angle of rotation around X is
taken from input channel four, the Y angle is taken from input channel five,
and the Z angle is fixed at 90 degrees.
<p>
The
<b>xlate</b>
macro converts three distances (which must be
specified in millimeters if the output script is destined for
processing by
<i>rt</i>(1)
or
<i>mged</i>(1))
into a translation expressed as a
4x4 homogeneous transformation matrix.
<p>
   @(xlate dx dy dz)
<p>
The matrix is generated by invoking the C macro
<b>MAT_DELTAS</b>
found in h/vmath.h.
For example, the macro
<p>
   @(xlate 100 -20 300)
creates the following matrix:
<p>
<pre>
1.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+02
0.000000000e+00 1.000000000e+00 0.000000000e+00 -2.000000000e+01
0.000000000e+00 0.000000000e+00 1.000000000e+00 3.000000000e+02
0.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+00
</pre>
<p>
Similarly, the macro
<p>
  @(xlate 13 @7 0)
<p>
creates a matrix where the origin is translated 13 units (mm) in X,
and the number of units found in input channel 7 in Y.
No translation occurs in Z.
<p>
The
<b>orient</b>
macro combines the operation of the
<b>rot</b>
zand
<b>xlate</b>
macros, and also offers optional scaling.
The invocation is one of:
<p>
   @(orient tx ty tz rx ry rz)
<br>
   @(orient tx ty tz rx ry rz scale)
<p>
where all rotation is done first, then the translation,
and then the scaling (if given).
<p>
The
<b>ae</b>
command converts
<i>mged</i>(1)
style azimuth and elevation angle given in degrees
into a rotation expressed as a
4x4 homogeneous transformation matrix.
<p>
   @(ae azimuth elevation)
<p>
The matrix is generated by calling the
<i>librt</i>(3)
routine
<b>mat_ae</b>
<p>
The
<b>quat</b>
command converts a quaternion into a
4x4 homogeneous transformation matrix.
<p>
   @(quat x y z w)
<p>
<p>
The
<b>fromto</b>
command is used to rotate the given axis to point in the same direction
as the vector formed by subtracting the 'next' point from the 'cur' point.
<p>
   @(fromto axis cur_x cur_y cur_z next_x next_y next_z)
<p>
The
<i>axis</i>
argument must be one of these six strings:
<i>+X, -X, +Y, -Y, +Z, -Z</i>,
where the axis letter is capitalized.
The matrix is generated by calling the
<i>librt</i>(3)
routine
<b>mat_fromto</b>
where the 'from' argument is derived from the
<i>axis</i>
given, and the 'to' argument is the unit-length difference 'next'-'cur'.
<h1>EXAMPLE1</h1>
<p>
Based upon the example started in the manual page for
<i>tabinterp</i>(1),
here is a Bourne shell script which will generate the
necessary template file using a ``here document'',
and then process the 8-channel output table
left in the file "table.final".
<p>
<pre>
#!/bin/sh
# This template will be instantiated once for each frame to be made.
cat &lt;&lt; EOF &gt; template

start @(line);
clean;
lookat_pt @(3) @(4) @(5);
viewsize @(7);
anim all.g/actor.g matrix rmul
 @(xlate @0 @1 @2);
anim all.g/light.r material rparam
 inten=@(6) angle=70 invisible=1;
end;
! framedone.sh actor.pix.@(line);

EOF
# This is the start of the animation script, which will be appended to below.
cat &lt;&lt; EOF &gt; script
viewsize 3000;
eye_pt -4.429280979044739e+03 -1.633722950749571e+03 -1.624787858562220e+03;
orientation 5.435778713738288e-01 4.980973490458696e-01 4.564221286261679e-01 4.980973490458693e-01;
#frame data follows
EOF
# Append the data for each frame
tabsub ./template &lt; table.final &gt;&gt; script
</pre>
<p>
<p>
The frame number is taken from the input table line number,
and substituted into the
<i>start</i>
command.
The main actor position is taken from channels 0,1,2 and applied
(as an "articulation") to the matrix located along the arc between
"all.g" and "actor.g" in the
<i>mged</i>
database.
The camera (eye) position stays fixed for this animation, but the
camera orientation is changed by substituting channels 3,4,5 into the
<i>lookat_pt</i>
command, and the viewsize (zoom lens setting) is changed by substituting
channel 7 into the
<i>viewsize</i>
command.
The argument to the light region's material property string
is replaced with a new string that spells out the current light parameters.
After the
<i>end</i>
command, a
<i>rt</i>(1)
shell escape is constructed, which will run a script called
"framedone.sh" with the given argument (which has been arranged
to be the file name of the
<i>pix</i>(5)
file that
<i>rt</i>(1)
just wrote, so that it can be post-processed, compressed,
sent to a video recorder, etc.
<p>
Try clipping this example out of the manual page
(usually found in /usr/brlcad/man/man1/tabsub.1)
and running it.
<h1>EXAMPLE2</h1>
<p>
In the
<i>tabinterp</i>(1)
manual page, mention was made of animating the flight of a rocket.
This partial example outlines how that might be accomplished.
<p>
<pre>
tabinterp &lt;&lt; EOF &gt; rocket.final
# Channel allocations:
#   0,1,2	position of base of rocket
#   3,4,5	next position of base of rocket
#
# Input table column allocations:  time, X, Y, Z
file rocket.table 0 1 2;
#
times 0 4 60;
#
# Assign interpolators to output channels
interp spline 0 1 2;
#
# Get +1 "look ahead" on values, for auto-guidance
next 3 0 1;
next 4 1 1;
next 5 2 1;
EOF
cat &lt;&lt; EOF &gt; rocket.template

start @(line);
clean;
anim all.g/rot.g matrix rmul
 @(xlate @0 @1 @2);
anim rot.g/rocket.g matrix rmul
  @(fromto +Z @0 @1 @2 @3 @4 @5);
end;
EOF
tabsub ./rocket.template &lt; rocket.final &gt;&gt; script
</pre>
<p>
<p>
The items worthy of note are the use of the
<i>tabinterp</i>(1)
<b>next</b>
command to place the position look-ahead into channels 3,4,5
and the matching use of the
<i>tabsub</i>
<b>fromto</b>
macro to convert the current and next positions into an
appropriate rotation.
In this case, the central axis of the rocket as found in the
<i>mged</i>(1)
database rises up the +Z axis.
Translating the rocket into position is handled one matrix
higher up the tree, using the
<b>xlate</b>
macro.
<h1>"POST PROCESSING"</h1>
<p>
<i>rt</i>
style animation scripts can be processed by
<i>rt</i>(1)
and
<i>remrt</i>(1)
by giving the
<b>-M</b>
option on the command line, and providing the script on standard input.
For example, the rocket animation might be run like this:
<p>
rt -M -V4:3 -w1440 -n972 -p90 -o rocket.pix rocket.g all.g &lt; script
<p>
to produce images in NTSC ("Academy" 4:3) aspect ratio at double the
normal resolution, suitable for later processing by
<i>pixhalve</i>(1).
<p>
The same animation can be previewed in near real-time using
<i>mged</i>(1).
For this example,
<i>mged</i>(1)
would be started with
<p>
   mged rocket.g
<p>
followed by attaching to an appropriate display device.
Then, these commands would be given:
<p>
   e all.g
   preview script
<p>
<i>mged</i>(1)
will process each frame as fast as it can, and update the screen.
<h1>"SEE ALSO"</h1>
tabinterp(1), xyz-pl(1), txyz-pl(1), cut(1), paste(1), rt(1), mged(1)
<h1>BUGS</h1>
There is presently a compiled-in
limit of 1023 channels in the input table.
<h1>AUTHOR</h1>
Michael John Muuss
<h1>SOURCE</h1>
The U. S. Army Research Laboratory
<br>
Aberdeen Proving Ground, Maryland  21005
<h1>"BUG REPORTS"</h1>
Reports of bugs or problems should be submitted via electronic
mail to &lt;devs@brlcad.org&gt;.
</body></html>
