<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../resources/standard/dtd/docbookx.dtd">

<book xmlns:xi="http://www.w3.org/2001/XInclude">
  <bookinfo>
    <title><application>BRL-CAD</application> Tutorial Series: Volume II - Introduction to MGED</title>
    <authorgroup>
      <author>
	<firstname>Lee</firstname>
	<surname>Butler</surname>
	<othername role='mi'>A</othername>
	<affiliation>
	  <shortaffil>ARL</shortaffil>
	  <orgname>Army Research Laboratory</orgname>
	  <orgdiv>Survivability/Lethality Analysis Directorate</orgdiv>
	  <address>
	    Aberdeen Proving Ground
	    <state>MD</state> 
	    <postcode>21005-5068</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>Eric</firstname>
	<surname>Edwards</surname>
	<othername role='mi'>W</othername>
	<affiliation>
	  <shortaffil>SURVICE</shortaffil>
	  <orgname>SURVICE Engineering Company</orgname>
	  <address>
	    <street>4695 Millennium Drive</street>
	    <city>Belcamp</city>
	    <state>MD</state> 
	    <postcode>21017-1505</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>Betty</firstname>
	<surname>Schueler</surname>
	<othername role='mi'>J</othername>
	<affiliation>
	  <shortaffil>QRI</shortaffil>
	  <orgname>Quantum Research International, Inc.</orgname>
	  <address>
	    <street>2014 Tollgate Rd, Suite 203</street>
	    <city>Bel Air</city>
	    <state>MD</state> 
	    <postcode>21014</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>Robert</firstname>
	<surname>Parker</surname>
	<othername role='mi'>G</othername>
	<affiliation>
	  <shortaffil>ARL</shortaffil>
	  <orgname>Army Research Laboratory</orgname>
	  <orgdiv>Survivability/Lethality Analysis Directorate</orgdiv>
	  <address>
	    Aberdeen Proving Ground
	    <state>MD</state> 
	    <postcode>21005-5068</postcode>
	  </address>
	</affiliation>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Anderson</surname>
	<othername role='mi'>R</othername>
	<affiliation>
	  <shortaffil>ARL</shortaffil>
	  <orgname>Army Research Laboratory</orgname>
	  <orgdiv>Survivability/Lethality Analysis Directorate</orgdiv>
	  <address>
	    Aberdeen Proving Ground
	    <state>MD</state> 
	    <postcode>21005-5068</postcode>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
    
    <publishername>Army Research Laboratory</publishername>
    <pubsnumber>ARL-SR-102</pubsnumber>
    <pubdate>April 2001</pubdate>
    
    <legalnotice>
      <para>Approved for public release; distribution is unlimited</para>
      
      <para>The findings in this report are not to be construed as an
      official Department of the Army position unless so designated 
      by other authorized documents.</para>
      
      <para>Citation of manufacturer's or trade names does not constitute
      an official endorsement or approval of the use thereof.</para>
      
      <para>Destroy this report when it is no longer needed. Do not return
      it to the originator.</para>
    </legalnotice>      
    
    <abstract>
      <para>
	Since 1979, the U.S. Army Research Laboratory has been developing and
	distributing the <application>BRL-CAD</application> constructive solid geometry (CSG) modeling
	package for a wide range of military and industrial applications. The
	package includes a large collection of tools and utilities including an
	interactive geometry editor, ray-tracing and generic framebuffer
	libraries, a network-distributed image-processing and signal-processing
	capability, and an embedded scripting language.
      </para>
      
      <para>
	As part of this effort, a multivolume tutorial series is being developed
	to assist users in the many features of the <application>BRL-CAD</application> package. The
	"Introduction to <application>MGED</application>," which is the second volume in the series, is
	intended to provide new users with a basic understanding of the
	<application>Multi-Device Geometry Editor</application> (<application>MGED</application>), 
	which is the heart of <application>BRL-CAD</application>. Other
	volumes focus on installation procedures, advanced features, and
	programming.
      </para>
    </abstract>
  </bookinfo>

  <preface>
    <title>Preface</title>
    <para>
      Since 1979, the U.S. Army Research Laboratory (formerly the Ballistic
      Research Laboratory) has been developing the <application>BRL-CAD</application> constructive solid
      geometry (CSG) modeling package for a wide range of military and
      industrial applications. The strength of the package lies in its ability
      to build realistic models of complex objects from a relatively small set
      of "primitive shapes" by employing the basic Boolean operations of union,
      subtraction, and intersection and by assigning real-world material
      attributes.
    </para>
    
    <para>
      The package comprises a large collection of tools, utilities, and
      libraries including an interactive geometry editor, ray-tracing and
      generic framebuffer libraries, a network-distributed image-processing and
      signal-processing capability, and an embedded scripting language.
    </para>
    
    <para>
      Although <application>BRL-CAD</application> has continued to mature in performance and utility,
      developers have strived to keep the package approachable and easy to use,
      as evidenced by the package's dual command formats, its newly renovated
      graphical user interface (GUI), and its customization potential through
      user scripting.
    </para>
    
    <para>
      In addition, a multivolume tutorial series is being developed to assist
      users in a variety of <application>BRL-CAD</application> areas and applications. The "Introduction to
      <application>MGED</application>," which is the second volume in the series, is intended to provide
      new users with a basic understanding of the <application>Multi-Device Geometry Editor</application>
      (<application>MGED</application>), which is the heart of the <application>BRL-CAD</application> package. Other volumes focus on
      installation procedures, advanced features, and programming.
    </para>
  </preface>
  
  <preface>
    <title>Acknowledgements</title>
    <para>
      The authors would like to thank Paul Tanenbaum, TraNese Christy, Sean
      Morrison, and the other members of the Advanced Computer Systems Team who
      reviewed this document in a timely manner and made many helpful
      suggestions to improve its accuracy and presentation.
    </para>
    
    <para>
      In addition, the authors would like to acknowledge team member Mike Muuss,
      who passed away while this volume was in preparation. Mike was the
      original architect of the <application>BRL-CAD</application> package and guided its development for
      20 years until his death on 20 November 2000. He embodied a unique blend
      of unparalleled intellect, unquenchable curiosity, and unending energy to
      advance the capabilities of everything and everyone he touched. A
      natural-born troubleshooter, Mike approached every job, big or small, with
      a passion for excellence and a child-like enthusiasm, which helped drive
      <application>BRL-CAD</application> far beyond expectations.
    </para>
    
    <para>
      Although he never got a chance to review this document, much of this work
      is a result of his vision and attention to detail. Therefore, the <application>BRL-CAD</application>
      Tutorial Series is dedicated to his memory. His sharp mind, his warm
      spirit, and his loyal friendship will be greatly missed.
    </para>
  </preface>

  <chapter id="Lesson-1">
    <title>Creating Primitive Shapes</title>
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="creating_primitive_shapes_overviewlist"/>
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="launching_mged"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="entering_commands"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="using_gui"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="open_new_database"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="create_new_database"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="assign_title"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="set_units"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="select_primitive"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="create_sphere_cmd_line"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="clear_window"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="draw_object"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="erase_from_window"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="create_sphere_gui"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="view_params"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="list_db_contents"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="kill_object"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="editing_commands"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="quitting"/> 
    <xi:include href="../../lessons/mged/creating_primitive_shapes.xml" xpointer="creating_primitive_shapes_review"/> 
  </chapter> 

  <chapter id="Lesson-2">
    <title>Learning the Viewing Options</title>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="learning_viewing_options_overviewlist"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="learning_viewing_options_intropara1"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="learning_viewing_options_intropara2"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="creating_radio"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="locating_viewing_info_cmd_window"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="viewing_system_elements"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="coord_sys_summary"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="view_radio_angles"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="shift_grips"/>
    <xi:include href="../../lessons/mged/learning_viewing_options.xml" xpointer="learning_viewing_options_review"/>
  </chapter>
  
  <chapter id="Lesson-3">
    <title>Using the Insert Command to Size and Place Shapes</title>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="using_insert_command_overviewlist"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="using_insert_command_intropara1"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="new_db_myShapes"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="sphere_make"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="using_in"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="args_on_one_line"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="command_combined_in"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="mged_naming_conventions"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="view_shapes"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="using_insert_command_quit"/>
    <xi:include href="../../lessons/mged/using_insert_command.xml" xpointer="using_insert_command_review"/>
  </chapter>

  <chapter id="Lesson-4">
    <title>Assigning Material Properties and Raytracing</title>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="assigning_material_properties_and_raytracing_overviewlist"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="assigning_material_properties_and_raytracing_opendb"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="create_region"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="assign_material_prop"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="clear_window_new_region"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="raytrace_model"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="layers_graphics_window"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="clear_graphics_window"/>
    <xi:include href="../../lessons/mged/assigning_material_properties_and_raytracing.xml" xpointer="assigning_material_properties_and_raytracing_review"/>
  </chapter>

  <chapter id="Lesson-5">
    <title>Lesson 5: Learning About Boolean Expressions</title>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="learning_boolean_expressions_overviewlist"/>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="boolean_tools"/>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="boolean_operations"/>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="making_regions_bool_ops"/>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="operator_precedence"/>
    <xi:include href="../../lessons/mged/learning_boolean_expressions.xml" xpointer="learning_boolean_operations_review"/>
  </chapter>

  <chapter id="Lesson-6">
    <title>Creating a Goblet</title>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="creating_a_goblet_overviewlist"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="creating_a_goblet_intro"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="goblet_new_database"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="create_edit_copy_goblet"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="making_goblet_regions"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="making_goblet_region_comb"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="goblet_view_data_tree"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="raytracing_goblet"/>
    <xi:include href="../../lessons/mged/creating_a_goblet.xml" xpointer="creating_goblet_review"/>
  </chapter>
  
  <chapter id="Lesson-7">
    <title>Assigning Material Properties to Your Goblet</title>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_material_properties_overviewlist"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_material_properties_intro1"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_review_opening_db"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_assign_colors"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_transparency_mirror"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_newforms_raytrace"/>
    <xi:include href="../../lessons/mged/goblet_material_properties.xml" xpointer="goblet_material_properties_review"/>
  </chapter>

  <chapter id="Lesson-8">
    <title>Assigning More Material Properties to Your Goblet</title>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_overviewlist"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_intro1"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_intro2"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_intro3"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_intro4"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_specular_diffuse"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_refractive_index"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_shininess"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_extinction"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_emission"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_shader_attributes"/>
    <xi:include href="../../lessons/mged/goblet_material_properties2.xml" xpointer="goblet_material_properties2_review"/>
 </chapter>

  <chapter id="Lesson-9">
    <title>Creating a Globe in a Display Box</title>
    <para>
      In previous lessons, you combined various shapes into new objects. These
      new objects have been created using solid building blocks, much like those
      used in a wooden toy truck. However, in real life, most of the objects
      that you will design will consist of an outside shell and various inside
      parts.
    </para>
    
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_in_display_overviewlist"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_in_display_newdb"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_create_display_box"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="create_globe_in_box"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_assign_mater_prop"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_move_rotate"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_use_color_tool"/>
    <xi:include href="../../lessons/mged/globe_in_display_box.xml" xpointer="globe_in_display_box_review"/>
  </chapter>
  
  <chapter id="Lesson-10">
    <title>Creating a Mug</title>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="creating_mug_overviewlist"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="creating_mug_intro1"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_new_db"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_outside_cyl"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_inside_cyl"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_handle"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_comb1"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_comb2"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_region"/>
    <xi:include href="../../lessons/mged/creating_mug.xml" xpointer="mug_review"/>
  </chapter>

  <chapter id="Lesson-11">
    <title>Refining the Mug</title>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="refining_mug_overviewlist"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="refining_mug_intro1"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="mug_mater_prop_mater_cmd"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="mug_raytrace1"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="mug_refining"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="mug_torus_cup_combine"/>
     <xi:include href="../../lessons/mged/refining_mug.xml" xpointer="refining_mug_review"/>
  </chapter>

  <chapter id="Lesson-12">
    <title>Creating the Mug Through the GUI</title>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_through_gui_overviewlist"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_through_gui_intro1"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_through_gui_intro2"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_create_body"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_create_handle"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_create_rim"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_create_combinations"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_make_region"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_check_tree"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_comb_edit_props"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_gui_raytracing"/>
     <xi:include href="../../lessons/mged/mug_through_gui.xml" xpointer="mug_through_gui_review"/>
  </chapter>
 
  <chapter id="lesson-13">
    <title>Placing Shapes in 3-D Space</title>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="placing_shapes_in_3d_overviewlist"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="placing_shapes_in_3d_intro1"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="placing_shapes_in_3d_intro2"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="placing_shapes_in_3d_intro3"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_create_tabletop"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_create_base"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_create_candle"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_create_flame"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_create_combination"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_check_data_tree"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_assign_mater_prop"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="candle_raytrace"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d.xml" xpointer="placing_shapes_in_3d_review"/>
  </chapter>

  <chapter id="lesson-14">
    <title>Gaining More Practice Placing Shapes in Space</title>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="placing_shapes_in_3d_2_overviewlist"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="placing_shapes_in_3d_2_intro1"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="placing_shapes_in_3d_2_intro2"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="candle_base_1st_sphere"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="draw_grid_feature"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="multipane_feature"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="copies_of_shapes"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="practice_make_regions_spheres"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="candle_base_spheres_combine"/>
     <xi:include href="../../lessons/mged/placing_shapes_in_3d_2.xml" xpointer="placing_shapes_in_3d_2_review"/>
  </chapter>

  <chapter id="lesson-15">
    <title>Creating a Toy Truck</title>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="creating_toy_truck_overviewlist"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="creating_toy_truck_intro1"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="creating_toy_truck_intro2"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_cab_in_cmd"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_hood_in_cmd"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_cab_wheel_well"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="ok_accept_apply_reset_cancel_dismiss"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_wheel_well_prim_edit_cpy"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_cab_shape_comb"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_body_in_cmd"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="prim_ed_wheel_wells"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_body_wheel_wells_comb"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_cab_body_region"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_wheels"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_wheels_region"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_regions_mater_props"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="on_screen_help"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="stacker_shading"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="using_stacker_shading"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_combine_regions"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="truck_raytracing"/>
     <xi:include href="../../lessons/mged/creating_toy_truck.xml" xpointer="creating_toy_truck_review"/>
  </chapter>



  <chapter id="lesson-16">
    <title>Learning Modeling Techniques and Structures</title>
    <para>
      In this lesson, you will be:
      <itemizedlist mark='bullet'>
	<listitem>
	  <para>Making the shapes of the walkie-talkie radio into regions.</para>
	</listitem>
	<listitem>
	  <para>Gathering the regions into an assembly combination.</para>
	</listitem>
	<listitem>
	  <para>Assigning material properties to the regions.</para>
	</listitem>
	<listitem>
	  <para>Adding internal components to the radio.</para>
	</listitem>
	<listitem>
	  <para>Creating specialty models of the radio.</para>
	</listitem>
	<listitem>
	  <para>Redefining the structure of the radio.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      In Lesson 2, we made the basic shapes of a walkie-talkie radio to gain
      experience in viewing objects. Now that we have successfully modeled a few
      simple objects, let's return to the radio to make it more realistic and,
      in so doing, discuss logical techniques and structures in modeling. When
      finished, our radio should look as follows:

      <figure>
	<title>Walkie-Talkie Radio</title>
	<screenshot>
	  <graphic fileref=".png"/>
	</screenshot>
      </figure>
    </para>
    <sect1>
      <title>Making the Shapes into Regions</title>
      <para>
	Open the database radio.g that you created in Lesson 2. In the Command
	Window, use the ls command to list all the contents of your radio. It
	should read as follows:
	
	<literallayout>
   ant.s btn.s knob.s

   body.s btn2.s spkr.s
	</literallayout>
	
	Now what does this list really contain? Parts to a model radio? Not
	really. What the list actually comprises is just a collection of shapes
	(which we have hinted at by using a .s suffix) that (1) do not have
	material properties, and therefore (2) do not occupy space.
      </para>
      <note>
	<para>
	  Remember, in <application>MGED</application> no shape truly becomes an object until it is        
	  included in a region, which, by definition, is an object or           
	  collection of objects that has a common material type.                
	</para>
      </note>
      <para>
	So our first order of business is to identify the major parts of the radio
	so we can properly define the regions. So far, our choices are fairly
	simple. The radio basically consists of (1) a body, which houses the
	speaker and all of the internal parts; (2) an antenna; (3) a volume
	control knob, and (4) a talk button. These should be our four regions.
      </para>
      <para>
	Most of these shapes were fairly straightforward to create, with each item
	consisting of just one or two primitive shapes. However, if we think of
	the radio as a real-world object, the body of the radio is actually more
	complex than just a solid box with a few shapes glued to its surface.
	(Remember that all objects are solid unless constructed to be otherwise.)
	Therefore, let's start with the main component of the radio-the body.
 
	<figure>
	  <title>The Body of the Radio</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	If we think about it, the body of a radio is actually a hollow case. So,
	the first thing we need to do is hollow out the case's interior to make
	room for internal components. To do this, we can use the inside command to
	create a shape, which we'll call cavity.s:
	
	<command>inside body.s cavity.s 1 1 1 1 1 1[Enter]</command>
	
	Now, we'll make a region called case.r and define it as what's left of
	body.s after cavity.s has been subtracted out. The command should look
	like this:
	
	<command>r case.r u body.s - cavity.s[Enter]</command>
      </para>
      <note>
	<para>
	  Remember that the inside command was originally created to hollow out 
	  objects such as gas tanks and boxes; however, it can also be used to  
	  create any new cutaway shape that has some relationship to a          
	  pre-existing shape.                                                   
	</para>
      </note>
      <para>
	With our case now made, we can proceed to cut several holes through this
	structure to accommodate the antenna, the volume control knob, and the
	talk button. To do this, we must subtract the three shapes from the case
	as follows:
	
	<command>r case.r - ant.s - knob.s - btn.s[Enter]</command>
	
	Finally, we need to "glue" the lip around the speaker to the case's front
	face by typing
	
	<command>r case.r u spkr.s[Enter]</command>
      </para>
      <para>
	Our body is now finished. Note that an experienced modeler would probably
	have combined the preceding three Boolean functions into a single command
	as follows:
	
	<command>r case.r u body.s - cavity.s - ant.s - knob.s - btn.s u spkr.s[Enter]</command>
	
	If we were to raytrace case.r at this point, we would see the following:
	<figure>
	  <title>Radio with Component Cutouts and Default Material Properties</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para>
	Note the hole for the antenna in the top of the case and the hole for the
	talk button on the side of the case. We will now fill these holes with
	their respective components.
      </para>
      <note>
	<para>
	  Precedence Review
	</para>
	<para>
	  The order in which these primitives were unioned and subtracted is    
	  important. We unioned in spkr. s last so that all the subtractions    
	  would apply to body.s. The rules of precedence for Boolean operators  
	  indicate that subtraction and intersection have a higher priority     
	  than union (meaning that they are performed first).                   
	</para>
	<para>
	  Although the following operation is not in proper <application>MGED</application> syntax, it     
	  does illustrate the implied parentheses that precede and follow the   
	  union operators in our last command:                                  
	
	  <command>r case.r u (body.s - cavity.s - ant.s - knob.s - btn.s) u (spkr.s)[Enter] </command>
	  
	  Optionally, we could've unioned in spkr.s before body.s as follows:   
	  
	  <command>r case.r u spkr.s u body.s - cavity.s - ant.s - knob.s - btn.s[Enter]</command> 
	</para>
	<para>
	  Let's consider, however, what would have happened if we had done the  
	  following:                                                            
	  
	  <command>r case.r u body.s u spkr.s - cavity.s - ant.s - knob.s - btn.s[Enter]</command> 
                                                                          
	  In this last case, operator precedence would have caused the program  
	  to subtract cavity.s, ant.s, knob.s, and btn.s from spkr.s. Nothing   
	  would have been subtracted from body.s. Therefore, the holes in the   
	  case would not have been created.                                     
	</para>
	<para>
	  Subtracting cavity.s, ant.s, knobs, and btn.s from spkr.s would have  
	  produced no apparent effect because they do not overlap the volume of 
	  spkr.s.                                                               
	</para>
      </note>
    </sect1>
    <sect1>
      <title>The Other Regions</title>
      <para>
	Making the talk button is simpler than making the case. The button
	consists of the union of two primitive shapes. To make them into a region,
	type
	
	<command>r button.r u btn.s u btn2.s[Enter]</command>
      </para>
      <para>
	The volume knob and antenna are even simpler. They are single primitive
	shapes that can be made into regions by typing
	
	<command>r knob.r u knob.s[Enter]</command>
	
	<command>r ant.r u ant.s[Enter]</command>
      </para>
    </sect1>
    <sect1>
      <title>Gathering the Regions into an Assembly Combination</title>
      <para>
	Now let's take all of the regions we have made so far and gather them into
	an assembly (or group) combination called radio.c so that we can keep all
	of these parts together. There are several ways to do this. One way would
	be to use a similar method to the one we used to make the regions:
	
	<command>comb radio.c u case.r u button.r u knob.r u ant.r[Enter]</command>
      </para>
      <para>
	A shortcut, however, would be to use the g (group) command as follows:
	
	<command>g radio.c case.r button.r knob.r ant.r[Enter]</command>
	
	Unlike the comb command, the g command assumes that all of the items
	specified will be unioned together, and so no Boolean operators need to be
	specified.
      </para>
      <para>
	A final improvement would include using the database name wildcard *.r to
	quickly and easily specify all of the regions in the database:
	
	<command>g radio.c *.r[Enter]</command>
	
	If we now tree radio.c, we should get the following output in the Command
	Window.
	<literallayout>
   radio.c/

   u case.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u button.r/R

   u btn.s

   u btn2.s

   u knob.r/R

   u knob.s

   u ant.r/R

   u ant.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Assigning Material Properties to the Regions</title>
      <para>
	Thus far, the objects we have created have no material properties other
	than the gray plastic that <application>MGED</application> assigns by default to any object without
	assigned material values. Now let's improve our design by assigning other
	material properties to the components.
      </para>
      <para>
	We'll give the antenna a realistic look by opening the Combination Editor,
	choosing ant.r from the drop-down Name menu, selecting mirror  from the
	drop-down  Shader menu, and clicking on Apply.
      </para>
      <para>
	We'll let the other components remain with the default plastic, but we'll
	assign them different colors. With the Combination Editor still open,
	select case.r from the drop-down Name menu, select the magenta option from
	the drop-down Color  menu, and then click Apply. Use the same method to
	assign the  volume control knob (knob.r) a blue color. For the talk button
	(button.r), let's keep it gray by leaving the default values in place. The
	design should appear similar to the following when raytraced in Underlay
	mode:
	
	<figure>
	  <title>Radio with Material Properties Assigned</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
      </para>
      <para> 
	As we look at our radio now, we can see that the antenna looks a little
	bit like a straw. In reality, it should have a small cap on the end so
	that we can raise and lower the antenna. We can approximate this shape by
	creating an ellipsoid (which we'll call ant2.s) and unioning it in with
	the rest of the antenna as follows:
	
	<command>in ant2.s ell1 2 2 94 0 0 1 3[Enter]</command>
	
	<command>r ant.r u ant2.s[Enter]</command>
      </para>
    </sect1>
    <sect1>
      <title>Adding Internal Components</title>
      <para>
	Our radio is looking more and more realistic; however, it is still just a
	hollow shell. Let's further improve it by making a circuit board to go
	inside the case. To do this, type:
	
	<command>in board.s rpp 3 4 1 31 1 47[Enter]</command>
	
	<command>r board.r u board.s[Enter]</command>
      </para>
      <para>
	Let's give the board a green semi-shiny color. The easiest way to do this
	is via the Combination Editor, but this time let's use the Command Line
	approach. Type:

	<command>mater board.r "plastic sh=4" 0 198 0 1[Enter]</command>
	
	Diagrammed, this command says to:
	<informaltable>
	  <tgroup cols='5'>
	    <tbody>
	      <row>
		<entry>mater</entry>
		<entry>board.r</entry>
		<entry>"plastic sh=4"</entry>
		<entry>0 198 0</entry>
		<entry>1</entry>
	      </row>
	      <row>
		<entry>Assign material properties to</entry>
		<entry>the region called board.r.</entry>
		<entry>Apply the plastic shader with a shininess of 4</entry>
		<entry>Give it a green color</entry>
		<entry>Inherit color material type</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </para>
      <para>
	Finally, we'll include the board with the rest of the components in
	radio.c as follows:
	
	<command>g radio.c board.r[Enter]</command>
	
	Our radio should now look like the following:
	
	<figure>
	  <title>Wireframe Radio with Circuit Board Added</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>

	In addition, the tree for radio.c should now look as follows:
	<literallayout>
   radio.c/

   u case.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u button.r/R

   u btn.s

   u btn2.s

   u knob.r/R

   u knob.s

   u ant.r/R

   u ant.s

   u ant2.s

   u board.r/R

   u board.s
	</literallayout>
      </para>
    </sect1>
    <sect1>
      <title>Making Specialty Models of the Radio</title>
      <para>
	Now, what would happen to the circuit board if we were to raytrace the
	radio at this point? It would disappear because it lies within the case.
	So how can we make the circuit board visible outside of the case?
      </para>
      <para>
	There are two common ways to do this: a transparent view and a cutaway
	view. Each method has its advantages and disadvantages. With the
	transparent view, the Boolean operations remain unchanged, but some of the
	material properties of the "outside shell" are altered to better view
	interior parts of the model. With the cutaway view, the material
	properties remain unchanged, but some of the Boolean operations are
	altered to remove parts of the model that are obstructing our view of
	other parts. We will try both ways to view the inside of our radio.
      </para>
      <para>
	Different Approaches to Creating Specialty Models
      </para>
      <para>
	An important point to note here is that the transparent and cutaway views
	are specialty models. They are similar in nature to items a manufacturer
	might make for special purposes. For example, an automobile manufacturer
	makes cars for everyday use, but also makes modified versions for display
	at certain events. The body panels might be replaced with a transparent
	material or be partially cut away to reveal interior components.
      </para>
      <para>
	Good modeling practice follows the same pattern. The actual model of an
	item should not have to be changed in order to create a specialty view of
	it. Instead, a modified version of the item should be created. Thus, the
	modeler will not have to worry about remembering to return the model to
	the original condition after its special-purpose use, and the modeler can
	also retain the "display model" for future use.
      </para>
      <para>
	There are two common approaches to making these specialty models: First,
	the modeler can copy the original and replace components with modified
	versions. Second, the modeler can create new, unique parts from scratch
	and construct the modified item. The method chosen is a matter of personal
	choice and is usually determined by the extent of the modifications being
	done and the complexity of the original object.
      </para>
      <sect2>
	<title>Transparent View</title>
	<para>
	  Making a specialty radio with a transparent case would probably be the
	  easiest way to view the circuit board inside. All we have to do is make a
	  copy of our present radio case and modify its material properties. We'll
	  call the specialty case case_clear.r. Type
	  
	  <command>cp case.r case_clear.r[Enter]</command>
	  
	  We can now use the Combination Editor to set the material properties on
	  this case without affecting the "master" design of the radio. When this
	  has been done, we can combine this modified case with the other unchanged
	  radio components and group them as a new specialty radio named
	  radio_clear.c.
	</para>
	<para>
	  To set the material properties of case_clear.r, choose plastic from the
	  drop-down menu to the right of the Shader entry box in the Combination
	  Editor. (Although this is the shader that is used by default, we want to
	  explicitly select it in order to change one of its values.) Now change the
	  Transparency of the case to a value of .8. Apply the change and close the
	  Combination Editor.
	</para>
	<para>
	  Finally, create the specialty radio combination by typing:
	  
	  <command>g radio_clear.c case_clear.r button.r knob.r ant.r board.r[Enter]</command>
	  
	  and then Blast the display with
	  
	  <command>B radio_clear.c[Enter]</command>
	</para>
	<para>
	  Now raytrace your design to view the resulting effect. The new transparent
	  case should appear similar to the following:
	  <figure>
	    <title>Transparent View of the Radio</title>
	    <screenshot>
	      <graphic fileref=".png"/>
	    </screenshot>
	  </figure>
	</para>
	<para>
	  As shown in the following tree diagram, the structure of this specialty
	  radio_clear.c is not much different than that of the regular radio.c. The
	  only difference is that case.c has been replaced with case_clear.c.
	  <literallayout>
   radio_clear.c/

   u case_clear.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u button.r/R

   u btn.s

   u btn2.s

   u knob.r/R

   u knob.s

   u ant.r/R

   u ant.s

   u ant2.s

   u board.r/R

   u board.s
	  </literallayout>
	</para>
	<note>
	  <para>
	    Notice in the preceding figure that the color chosen for the          
	    transparent case does influence the appearance of the internal        
	    objects. Although we made the circuit board green, the filter effect  
	    of the transparent magenta case-which allows no green light to enter  
	    or exit the case-causes the board to appear to be dark purple. This   
	    is okay in our situation. However, if accuracy in color is important  
	    in a model, the modeler should remember to select a neutral color     
	    (such as white or light gray) for the transparent object.             
	  </para>
	</note>
      </sect2>
      <sect2>
	<title>Cutaway View</title>
	<para>
	  Another way we can make the interior components of the radio visible is to
	  create a cutaway view. Although it is a little more complex to make than
	  the transparent view was, the cutaway view offers a particularly
	  interesting way to view geometry.
	</para>
	<para>
	There are several ways to make the cutaway view. Probably the easiest way
	is to use the "chainsaw" method to cut off part of the radio and reveal
	what is inside.
	</para>
	<para>
	  To do this, create an arb8 called cutaway.s, which will be used to cut off
	  the front corner of the radio. Because this is a cutting shape (i.e., it
	  is simply used to erase a portion of another shape and will not actually
	  be viewed), the dimensions of the arb8 are not critical. The only concern
	  is that cutaway.s be as tall as the case so that it completely removes a
	  corner from it.
	</para>
	<para>
	  Use the Shift Grips and multiple views (especially the Top view) to align
	  cutaway.s so that it angles diagonally across the top of the radio (as
	  shown in the following wireframe representation). When you've aligned the
	  shape the way you want it, create the following radio_cutaway.c
	  combination that unions in radio.c and subtracts out the shape (cutaway.s)
	  that is covering what you want to see (board.r):
	  
	  <command>comb radio_cutaway.c u radio.c - cutaway.s[Enter]</command>
  
	  <figure>
	    <title>Multipane View of Cutting Primitive</title>
	    <screenshot>
	      <graphic fileref=".png"/>
	    </screenshot>
	  </figure>
	</para>
	<para>
	  Blast the radio_cutaway.c combination onto the display and raytrace.
	  Depending on how your arb8 intersected the radio, the cutaway should look
	  similar to the following:
   
	  <figure>
	    <title>Cutaway View of Radio with Circuit Board Cut Off</title>
	    <screenshot>
	      <graphic fileref=".png"/>
	    </screenshot>
	  </figure>
	</para>
	<para>
	  Notice in the preceding figures that cutaway.s removes everything it
	  overlaps (including part of the circuit board). This is okay if we just
	  want to see inside the case. However, if we want to see all of the circuit
	  board and any other component overlapped by cutaway.s (e.g., button.r), we
	  would have to adjust our Boolean operations a little so that the cutaway
	  is subtracted only from our case.
	</para>
	<para>
	  To do this, we basically have two options: (1) we could move cutaway.s in
	  the structure so that it is subtracted from only case.r, or (2) we could
	  move cutaway.s in the structure so that it is subtracted from both body.s
	  and spkr.s, the two components that make up case.r. While both of these
	  options would produce the same effect, the first method requires just one
	  subtraction, whereas the second method potentially provides more control
	  by having the user select the individual components that will subtract out
	  the cutting shape.
	</para>
	<para>
	  Take a minute and compare the following trees for the cutaways we have
	  discussed so far. Especially note the position of cutaway.s in the
	  different structures. Also, note that when cutaway.s was subtracted from a
	  particular region or combination, the name of that region or combination
	  was changed. The reasoning behind this goes back to our original
	  discussion of specialty models. Remember that our purpose is to create a
	  new special-purpose model, not change the existing model. So, we must
	  change the name of any region or combination that contains any modified
	  components or structures. If we don't, the master model will also be
	  changed.
	</para>
	<para>*****Note - add figures showing tree structure - need to be redone*****</para>
      </sect2>
    </sect1>
    <sect1>
      <title>Redefining the Structure of the Radio</title>
      <para>
	As shapes are added in a design, the modeler often finds that the
	structure or association of components needs to change. Thus, we should
	pause at this point and consider how our radio is structured. While there
	are many ways to structure a model, two common modeling categories are
	location and functionality. For our radio, we have so far grouped
	everything together under the general category of Radio, as shown in the
	following:

  	<figure>
	  <title>Current Radio Structure</title>
	  <screenshot>
	    <graphic fileref=".png"/>
	  </screenshot>
	</figure>
       </para>
       <para>
	 If we wanted to categorize our components according to location, however,
	 we might structure the model as follows:
	 
	 <figure>
	   <title>Location-Based Structure of Radio</title>
	   <screenshot>
	     <graphic fileref=".png"/>
	   </screenshot>
	 </figure>
       </para>
       <para>
	 If we wanted to define our components according to functionality, we might
	 structure the model another way. For instance, to repair an actual radio,
	 we would open the case, take out the circuit board, fix it, and put it
	 back in. When taking out the board, however, the knob and button would
	 probably be attached to it in some way, and so they too would need to come
	 out. Accordingly, our structure should be changed as shown in the
	 following diagram to associate the knob and button with the circuit board.
	 
	 <figure>
	   <title>Function-Based Structure of Radio</title>
	   <screenshot>
	     <graphic fileref=".png"/>
	   </screenshot>
	 </figure>
       </para>
       <para>
	 To accomplish this restructuring according to functionality, create an
	 assembly called electronics.c to hold these components together. Type:
	 
	 <command>g electronics.c board.r knob.r button.r[Enter]</command>
	 
	 Of course, we now need to remove board.r, knob.r, and button.r from the
	 radio.c assembly so that when electronics.c is added to the radio.c
	 assembly, we won't have the knob and button included twice in the model.
	 To do this, use the rm (remove) command:
	 
	 <command>rm radio.c board.r knob.r button.r[Enter]</command>
	 
	 and then union in the electronics assembly:
	 
	 <command>g radio.c electronics.c[Enter]</command>
       </para>
       <para>
	 Now the tree for radio.c should appear as follows:
	 <literallayout>
   radio.c/

   u case.r/R

   u body.s

   - cavity.s

   - ant.s

   - knob.s

   - btn.s

   u spkr.s

   u ant.r/R

   u ant.s

   u ant2.s

   u electronics.c/

   u board.r/R

   u board.s

   u knob.r/R

   u knob.s

   u button.r/R

   u btn.s

   u btn2.s
	 </literallayout>
       </para>
       <para>
	 Now let's remake our cutaway view. This time, let's do what we discussed
	 earlier and make the cutaway remove material from only the case, showing
	 all the other components.
       </para>
       <para>
	 First, we need to get rid of the old radio_cutaway.c, which was based on
	 our previous structure. To do this, type
	 
	 <command>kill radio_cutaway.c[Enter]</command>
	 
	 and then remake the combination by typing
	 
	 <command>comb radio_cutaway.c u case.r - cutaway.s u electronics.c u ant.r[Enter]</command>
	 
	 Now when we Blast the display and raytrace radio_cutaway.c, we should see
	 the following:
	 <figure>
	   <title>View of Radio with Just the Case Cut Away</title>
	   <screenshot>
	     <graphic fileref=".png"/>
	   </screenshot>
	 </figure>
       </para>
    </sect1>
    <sect1>
      <title>Review</title>
      <para>
	In this lesson, you:
	<itemizedlist mark='bullet'>
	  <listitem>
	    <para>Made the shapes of the walkie-talkie radio into regions.</para>
	  </listitem>
	  <listitem>
	    <para>Gathered the regions into an assembly combination.</para>
	  </listitem>
	  <listitem>
	    <para>Assigned material properties to the regions.</para>
	  </listitem>
	  <listitem>
	    <para>Added internal components to the radio.</para>
	  </listitem>
	  <listitem>
	    <para>Created specialty models of the radio.</para>
	  </listitem>
	  <listitem>
	    <para>Redefined the structure of the radio.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect1>
  </chapter>

<appendix label="A">
  <title><application>MGED</application> Commands</title>
  <xi:include href="../../system/mged/mged_commands.xml" xpointer="mged_user_cmd_table"/>
  <xi:include href="../../system/mged/mged_commands.xml" xpointer="glossary"/>
</appendix>

</book>
