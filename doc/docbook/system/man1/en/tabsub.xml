<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- lifted from troff+man by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='tabsub1'>
<refmeta>
    <refentrytitle>TABSUB
</refentrytitle>
<manvolnum>1</manvolnum>
<refmiscinfo class='source'>BRL-CAD</refmiscinfo>
<refmiscinfo class='manual'>BRL-CAD</refmiscinfo>
</refmeta>

<refnamediv>
<refname>tabsub</refname>
<refpurpose>macro expand an input table into an animation script</refpurpose>
</refnamediv>
<!-- body begins here -->
<refsynopsisdiv xml:id='synopsis'>
<cmdsynopsis>
  <command>tabsub</command>
    <arg choice='plain'><replaceable>template_file</replaceable></arg>
    <arg choice='plain'>&lt;</arg>
    <arg choice='plain'><replaceable>table.final</replaceable></arg>
    <arg choice='plain'>&gt;&gt;</arg>
    <arg choice='plain'><replaceable>script</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>


<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para><command>tabsub</command>
takes as input a data table on standard input
(such as might have been produced by
<citerefentry><refentrytitle>tabinterp</refentrytitle><manvolnum>1</manvolnum></citerefentry>
or similar tool),
and a template file named on the command line.
For each row (line) of the input table, one complete copy of
the template file is output on standard output.
As the template is output,
any macro invocations in the template file are replaced with
the data values from the input table's current row.
In the input table, any blank lines or lines with a pound sign ('#')
as the first character are ignored, allowing comments to be
added to the input table.</para>

<para>Macro invocations in the template file all begin with an at-sign ('@').
In order to send an at-sign through to the output, a second at-sign
must immediately follow it, <emphasis remap='I'>e.g.</emphasis> when '@@' is encountered in the
template, a single '@' is output.
To output the data value found in a given channel in the current
input row of the data table, the at-sign is followed by the channel
number, <emphasis remap='I'>e.g.</emphasis> to output the value in channel four, specify '@4',
and to output the value in channel 42, specify '@42'.
In some circumstances it my be desirable to highlight the difference
between channel value substitution, and literal numeric values.
To facilitate this, the channel number may be enclosed in parenthesis
to explicitly delimit the macro invocation.  For example, channel
four could also be specified as '@(4)', and channel 42 as '@(42)'.
This second notation is generally preferred.</para>

<para>The
<command>tabsub</command>
program is intended primarily for creating scripts relating to animation.
To facilitate this, a variety of more complex macros also exist.</para>

<para>   @(line)</para>

<para>will output the row (line) number of the input table which is currently
being processed, with the first line being numbered zero.
This is useful for creating frame numbers, or other sequence tags
in the output.</para>

<para>   @(time)</para>

<para>will output the time value which is always found in the left-most column
of the current row.</para>

<para>The more complex macros can also take arguments.
If the first character of an argument is an at-sign ('@')
(or percent-sign ('%'), for backwards compatibility), then
the number that follows signifies an input channel substitution
as before.  Otherwise the value is taken literally.</para>

<para>The
<emphasis remap='B'>rot</emphasis>
macro is used to convert three Euler angles given in degrees
into a rotation expressed as a
4x4 homogeneous transformation matrix.</para>

<para>   @(rot x_angle y_angle z_angle)</para>

<para>The arguments may be either numeric constants, column value macros,
or a combination of both.
The matrix is generated by calling the
<citerefentry><refentrytitle>libbn</refentrytitle><manvolnum>3</manvolnum></citerefentry>
routine
<emphasis remap='B'>bn_mat_angles</emphasis>
which performs the rotation around the Z axis first, then Y, then X.
For example, the macro</para>

<para>   @(rot 0 0 45)</para>

<para>creates the following matrix, a 45 degree rotation about Z:</para>

<literallayout remap='.nf'>
<!-- .ne 4 -->
7.071067812e-01 -7.071067812e-01 0.000000000e+00 0.000000000e+00
7.071067812e-01 7.071067812e-01 -0.000000000e+00 0.000000000e+00
0.000000000e+00 0.000000000e+00 1.000000000e+00 0.000000000e+00
0.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+00
</literallayout> <!-- .fi -->

<para>Similarly, the macro</para>

<para>   @(rot @4 @5 90)</para>

<para>creates a rotation matrix where the angle of rotation around X is
taken from input channel four, the Y angle is taken from input channel five,
and the Z angle is fixed at 90 degrees.</para>

<para>The
<emphasis remap='B'>xlate</emphasis>
macro converts three distances (which must be
specified in millimeters if the output script is destined for
processing by
<citerefentry><refentrytitle>rt</refentrytitle><manvolnum>1</manvolnum></citerefentry>
or
<citerefentry><refentrytitle>mged</refentrytitle><manvolnum>1</manvolnum></citerefentry>)
into a translation expressed as a
4x4 homogeneous transformation matrix.</para>

<para>   @(xlate dx dy dz)</para>

<para>The matrix is generated by invoking the C macro
<emphasis remap='B'>MAT_DELTAS</emphasis>
found in h/vmath.h.
For example, the macro</para>

<para>   @(xlate 100 -20 300)
creates the following matrix:</para>

<literallayout remap='.nf'>
1.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+02
0.000000000e+00 1.000000000e+00 0.000000000e+00 -2.000000000e+01
0.000000000e+00 0.000000000e+00 1.000000000e+00 3.000000000e+02
0.000000000e+00 0.000000000e+00 0.000000000e+00 1.000000000e+00
</literallayout> <!-- .fi -->

<para>Similarly, the macro</para>

<para>  @(xlate 13 @7 0)</para>

<para>creates a matrix where the origin is translated 13 units (mm) in X,
and the number of units found in input channel 7 in Y.
No translation occurs in Z.</para>

<para>The
<emphasis remap='B'>orient</emphasis>
macro combines the operation of the
<emphasis remap='B'>rot</emphasis>
zand
<emphasis remap='B'>xlate</emphasis>
macros, and also offers optional scaling.
The invocation is one of:</para>

<para>   @(orient tx ty tz rx ry rz)
<!-- .br -->
   @(orient tx ty tz rx ry rz scale)</para>

<para>where all rotation is done first, then the translation,
and then the scaling (if given).</para>

<para>The
<emphasis remap='B'>ae</emphasis>
command converts
<citerefentry><refentrytitle>mged</refentrytitle><manvolnum>1</manvolnum></citerefentry>
style azimuth and elevation angle given in degrees
into a rotation expressed as a
4x4 homogeneous transformation matrix.</para>

<para>   @(ae azimuth elevation)</para>

<para>The matrix is generated by calling the
<citerefentry><refentrytitle>libbn</refentrytitle><manvolnum>3</manvolnum></citerefentry>
routine
<emphasis remap='B'>bn_mat_ae</emphasis></para>

<para>The
<emphasis remap='B'>arb_rot_pt</emphasis>
command generates an arbitrary rotation matrix, expressed
as a center of rotation, a second point defining the axis of
rotation, and an angle of rotation expressed as an angle in degrees
into a rotation expressed as a
4x4 homogeneous transformation matrix.</para>

<para>   @(arb_rot_pt p1[x] p1[y] p1[z] p2[x] p2[x] p2[z] ang)</para>

<para>The matrix is generated by calling the
<citerefentry><refentrytitle>libbn</refentrytitle><manvolnum>3</manvolnum></citerefentry>
routine
<emphasis remap='B'>bn_mat_arb_rot</emphasis></para>

<para>The
<emphasis remap='B'>arb_rot_dir</emphasis>
command generates an arbitrary rotation matrix, expressed
as a center of rotation, a direction vector defining the axis of rotation,
and an angle of rotation expressed as an angle in degrees
into a rotation expressed as a
4x4 homogeneous transformation matrix.
The direction vector need not be unit length.</para>

<para>   @(arb_rot_pt pt[x] pt[y] pt[z] dir[x] dir[x] dir[z] ang)</para>

<para>The matrix is generated by calling the
<citerefentry><refentrytitle>libbn</refentrytitle><manvolnum>3</manvolnum></citerefentry>
routine
<emphasis remap='B'>bn_mat_arb_rot</emphasis></para>

<para>The
<emphasis remap='B'>quat</emphasis>
command converts a quaternion into a
4x4 homogeneous transformation matrix.</para>

<para>   @(quat x y z w)</para>


<para>The
<emphasis remap='B'>fromto</emphasis>
command is used to rotate the given axis to point in the same direction
as the vector formed by subtracting the 'next' point from the 'cur' point.</para>

<para>   @(fromto axis cur_x cur_y cur_z next_x next_y next_z)</para>

<para>The
<emphasis remap='I'>axis</emphasis>
argument must be one of these six strings:
<emphasis remap='I'>+X, -X, +Y, -Y, +Z, -Z</emphasis>,
where the axis letter is capitalized.
The matrix is generated by calling the
<citerefentry><refentrytitle>libbn</refentrytitle><manvolnum>3</manvolnum></citerefentry>
routine
<emphasis remap='B'>bn_mat_fromto</emphasis>
where the 'from' argument is derived from the
<emphasis remap='I'>axis</emphasis>
given, and the 'to' argument is the unit-length difference 'next'-'cur'.</para>
</refsect1>

<refsect1 xml:id='rt_scriptlanguage_builtins'><title>RT SCRIPT-LANGUAGE BUILT-INS</title>
<para>It is worth noting that the "anim" command in the
<citerefentry><refentrytitle>rt</refentrytitle><manvolnum>1</manvolnum></citerefentry>
animation scripting language
also offers some of these capabilities via built-in shortcuts.
In addition to being able to provide the full 4x4 matrix as an
argument to the "anim ... matrix" command, there are special
keywords:
"xlate", "translate" which take 3 arguments
and pass them to the macro MAT_DELTAS,
"rot" which takes 3 arguments and passes them to bn_mat_angles(),
"scale" which takes one argument as a uniform scale factor
(e.g. a value of 2 makes the subtree twice as large, scaled around
the origin)
and
"scale_about" which passes 4 arguments (point and scale factor)
and calls bn_mat_scale_about_pt().
An example of making an ellipse 1/5th the original size looks like this:</para>

<para>   anim ellipse.r/ellipse.s matrix rarc
      scale_about 16.1309 46.6556 -3.72252    0.2;</para>

</refsect1>

<refsect1 xml:id='example1'><title>EXAMPLE1</title>
<para>Based upon the example started in the manual page for
<citerefentry><refentrytitle>tabinterp</refentrytitle><manvolnum>1</manvolnum></citerefentry>,
here is a Bourne shell script which will generate the
necessary template file using a "here document",
and then process the 8-channel output table
left in the file "table.final".</para>

<literallayout remap='.nf'>
#!/bin/sh
# This template will be instantiated once for each frame to be made.
cat &lt;&lt; EOF &gt; template

start @(line);
clean;
lookat_pt @(3) @(4) @(5);
viewsize @(7);
anim all.g/actor.g matrix rmul
 @(xlate @0 @1 @2);
anim all.g/light.r material rparam
 inten=@(6) angle=70 invisible=1;
end;
! framedone.sh actor.pix.@(line);

EOF
# This is the start of the animation script, which will be appended to below.
cat &lt;&lt; EOF &gt; script
viewsize 3000;
eye_pt -4.429280979044739e+03 -1.633722950749571e+03 -1.624787858562220e+03;
orientation 5.435778713738288e-01 4.980973490458696e-01 4.564221286261679e-01 4.980973490458693e-01;
#frame data follows
EOF
# Append the data for each frame
tabsub ./template &lt; table.final &gt;&gt; script
</literallayout> <!-- .fi -->


<para>The frame number is taken from the input table line number,
and substituted into the
<emphasis remap='I'>start</emphasis>
command.
The main actor position is taken from channels 0,1,2 and applied
(as an "articulation") to the matrix located along the arc between
"all.g" and "actor.g" in the
<emphasis remap='I'>mged</emphasis>
database.
The camera (eye) position stays fixed for this animation, but the
camera orientation is changed by substituting channels 3,4,5 into the
<emphasis remap='I'>lookat_pt</emphasis>
command, and the viewsize (zoom lens setting) is changed by substituting
channel 7 into the
<emphasis remap='I'>viewsize</emphasis>
command.
The argument to the light region's material property string
is replaced with a new string that spells out the current light parameters.
After the
<emphasis remap='I'>end</emphasis>
command, a
<citerefentry><refentrytitle>rt</refentrytitle><manvolnum>1</manvolnum></citerefentry>
shell escape is constructed, which will run a script called
"framedone.sh" with the given argument (which has been arranged
to be the file name of the
<citerefentry><refentrytitle>pix</refentrytitle><manvolnum>5</manvolnum></citerefentry>
file that
<citerefentry><refentrytitle>rt</refentrytitle><manvolnum>1</manvolnum></citerefentry>
just wrote, so that it can be post-processed, compressed,
sent to a video recorder, etc.</para>

<para>Try clipping this example out of the manual page
(usually found in /usr/brlcad/man/man1/tabsub.1)
and running it.</para>
</refsect1>

<refsect1 xml:id='example2'><title>EXAMPLE2</title>
<para>In the
<citerefentry><refentrytitle>tabinterp</refentrytitle><manvolnum>1</manvolnum></citerefentry>
manual page, mention was made of animating the flight of a rocket.
This partial example outlines how that might be accomplished.</para>

<literallayout remap='.nf'>
tabinterp &lt;&lt; EOF &gt; rocket.final
# Channel allocations:
#   0,1,2	position of base of rocket
#   3,4,5	next position of base of rocket
#
# Input table column allocations:  time, X, Y, Z
file rocket.table 0 1 2;
#
times 0 4 60;
#
# Assign interpolators to output channels
interp spline 0 1 2;
#
# Get +1 "look ahead" on values, for auto-guidance
next 3 0 1;
next 4 1 1;
next 5 2 1;
EOF
cat &lt;&lt; EOF &gt; rocket.template

start @(line);
clean;
anim all.g/rot.g matrix rmul
 @(xlate @0 @1 @2);
anim rot.g/rocket.g matrix rmul
  @(fromto +Z @0 @1 @2 @3 @4 @5);
end;
EOF
tabsub ./rocket.template &lt; rocket.final &gt;&gt; script
</literallayout> <!-- .fi -->


<para>The items worthy of note are the use of the
<citerefentry><refentrytitle>tabinterp</refentrytitle><manvolnum>1</manvolnum></citerefentry>
<emphasis remap='B'>next</emphasis>
command to place the position look-ahead into channels 3,4,5
and the matching use of the
<command>tabsub</command>
<emphasis remap='B'>fromto</emphasis>
macro to convert the current and next positions into an
appropriate rotation.
In this case, the central axis of the rocket as found in the
<citerefentry><refentrytitle>mged</refentrytitle><manvolnum>1</manvolnum></citerefentry>
database rises up the +Z axis.
Translating the rocket into position is handled one matrix
higher up the tree, using the
<emphasis remap='B'>xlate</emphasis>
macro.</para>
</refsect1>

<refsect1 xml:id='post_processing'><title>POST PROCESSING</title>
<para><emphasis remap='I'>rt</emphasis>
style animation scripts can be processed by
<citerefentry><refentrytitle>rt</refentrytitle><manvolnum>1</manvolnum></citerefentry>
and
<citerefentry><refentrytitle>remrt</refentrytitle><manvolnum>1</manvolnum></citerefentry>
by giving the
<option>-M</option>
option on the command line, and providing the script on standard input.
For example, the rocket animation might be run like this:</para>

<para>rt -M -V4:3 -w1440 -n972 -p90 -o rocket.pix rocket.g all.g &lt; script</para>

<para>to produce images in NTSC ("Academy" 4:3) aspect ratio at double the
normal resolution, suitable for later processing by
<citerefentry><refentrytitle>pixhalve</refentrytitle><manvolnum>1</manvolnum></citerefentry>.</para>

<para>The same animation can be previewed in near real-time using
<citerefentry><refentrytitle>mged</refentrytitle><manvolnum>1</manvolnum></citerefentry>.
For this example,
<citerefentry><refentrytitle>mged</refentrytitle><manvolnum>1</manvolnum></citerefentry>
would be started with</para>

<para>   mged rocket.g</para>

<para>followed by attaching to an appropriate display device.
Then, these commands would be given:</para>

<para>   e all.g
   preview script</para>

<para><citerefentry><refentrytitle>mged</refentrytitle><manvolnum>1</manvolnum></citerefentry>
will process each frame as fast as it can, and update the screen.</para>
</refsect1>

<refsect1 xml:id='see_also'><title>SEE ALSO</title>
<para><citerefentry><refentrytitle>tabinterp</refentrytitle><manvolnum>1</manvolnum></citerefentry>, <citerefentry><refentrytitle>xyz-plot3</refentrytitle><manvolnum>1</manvolnum></citerefentry>, <citerefentry><refentrytitle>cut</refentrytitle><manvolnum>1</manvolnum></citerefentry>, <citerefentry><refentrytitle>paste</refentrytitle><manvolnum>1</manvolnum></citerefentry>, <citerefentry><refentrytitle>rt</refentrytitle><manvolnum>1</manvolnum></citerefentry>, <citerefentry><refentrytitle>mged</refentrytitle><manvolnum>1</manvolnum></citerefentry></para>
</refsect1>

<refsect1 xml:id='bugs'><title>BUGS</title>
<para>There is presently a compiled-in
limit of 1023 channels in the input table.</para>

</refsect1>

<refsect1 xml:id='author'><title>AUTHOR</title>
<para>BRL-CAD Team</para>

</refsect1>

<refsect1 xml:id='copyright'><title>COPYRIGHT</title>
<para>This software is Copyright (c) 1992-2016 by the United States
Government as represented by U.S. Army Research Laboratory.</para>
</refsect1>

<refsect1 xml:id='bug_reports'><title>BUG REPORTS</title>
<para>Reports of bugs or problems should be submitted via electronic
mail to &lt;devs@brlcad.org&gt;.</para>
</refsect1>
</refentry>

