<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">

  <info>
    <title>NURBS Boolean Evaluation Development Guide</title>
    <author>
      <personname>
        <firstname>Nicholas</firstname>
        <surname>Reed</surname>
      </personname>
    </author>
  </info>

  <section>
    <title>NURBS Boolean Evaluation Using the brep Command</title>
    <section>
      <title>Known Limitations</title>
      <itemizedlist>
        <listitem><para>Frequently produces incorrect output due to unhandled intersection cases.</para></listitem>
        <listitem><para>Unoptimized performance.</para></listitem>
	<listitem><para>Material properties of source objects are discarded.</para></listitem>
	<listitem><para>Some primitive conversions to NURBS are ill-defined.</para></listitem>
	<listitem><para>Hollow objects are not built topologically continuous.</para></listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Overview of the Implementation</title>
    <section>
      <title>Description of Major Functions</title>
      <section>
	<title><filename>src/libbrep/boolean.cpp</filename></title>
	<synopsis>
	<![CDATA[
int
ON_Boolean(
    ON_Brep *evaluated_brep,
    const ON_Brep *brep1,
    const ON_Brep *brep2,
    op_type operation);
	]]>
	</synopsis>
	<para>
	In the nontrivial case where the bounding boxes of <parameter>brep1</parameter> and <parameter>brep2</parameter> intersect, <function>get_evaluated_faces</function> is called to get the trimmed NURBS faces of the evaluated boolean result. The faces are then combined into a single brep object returned via the <parameter>evaluated_brep</parameter> argument. 
	</para>
	<synopsis>
	<![CDATA[
ON_ClassArray< ON_SimpleArray<Trimmed Face *> >
get_evaluated_faces(
    const ON_Brep *brep1,
    const ON_Brep *brep2,
    op_type operation);
	]]>
	</synopsis>
	<para>
	The intersection curves between the faces of <parameter>brep1</parameter> and <parameter>brep2</parameter> are found by <function>get_face_intersection_curves</function>. These curves are used to split the original surfaces into pieces, each becoming a new trimmed NURBS face. The <function>categorize_trimmed_faces</function> function is used to identify which pieces, based on the boolean operation, are part of the evaluated result. Each <classname>TrimmedFace</classname> whose <varname>m_belong_to_final</varname> member is marked <constant>TrimmedFace::BELONG</constant> is used by <function>ON_Boolean</function> to create the final evaluated result.
	</para>
	<synopsis>
	<![CDATA[
ON_ClassArray< ON_SimpleArray<SSICurve> >
get_face_intersection_curves(
    ON_SimpleArray<Subsurface *> &surf_tree1,
    ON_SimpleArray<Subsurface *> &surf_tree2,
    const ON_Brep *brep1,
    const ON_Brep *brep2,
    op_type operation);
	]]>
	</synopsis>
	<para>
	    Each pair of <parameter>brep1</parameter> and <parameter>brep2</parameter> surfaces whose bounding boxes intersect are passed to the <function>ON_Intersect</function> surface-surface intersection routine. The surface-surface intersection curves are then clipped using the trimming curves of the associated faces by the <function>get_subcurves_inside_faces</function> routine.
	</para>
      </section>
      <section>
	<title><filename>src/libbrep/intersect.cpp</filename></title>
	<synopsis>
	<![CDATA[
int
ON_Intersect(const ON_Surface *surfA,
             const ON_Surface *surfB,
             ON_ClassArray<ON_SSX_EVENT> &x,
             double isect_tol,
             double overlap_tol,
             double fitting_tol,
             const ON_Interval *surfaceA_udomain,
             const ON_Interval *surfaceA_vdomain,
             const ON_Interval *surfaceB_udomain,
             const ON_Interval *surfaceB_vdomain,
             Subsurface *treeA,
             Subsurface *treeB);
	]]>
	</synopsis>
	<para>
	    The first stage of the surface-surface intersection algorithm attempts to identify overlap intersections (areas where the two surfaces are coincident). Our assumption is that the boundary curve of any overlap region must be formed from isocurves of the overlapping surfaces. Subcurves of isocurves that intersect both surfaces, such that the surfaces are coincident on one side of the curve but not the other, potentially form part of overlap boundaries. These curves are identified using <function>find_overlap_boundary_curves</function>, which may also return some intersection points and curves that aren't on overlap boundaries to avoid wasted effort. Then, the <function>split_overlaps_at_intersections</function> function is run, and curves that share endpoints are stitched together. Stitched curves that close to form loops are recorded as overlap intersection events.
	</para>
	<para>
	The second stage of the surface-surface intersection algorithm attempts to identify other intersection curves and points. The input surfaces <parameter>surfA</parameter> and <parameter>surfB</parameter> are subdivided into four subsurfaces, whose bounding boxes are tested in pairs for intersection. This subdivision repeats to a fixed depth determined by <constant>MAX_SSI_DEPTH</constant>. Subsurfaces that lie completely inside an overlap region identified in the first stage are discarded. Each final pair of subsurfaces with intersecting bounding boxes is approximated with two triangles. The triangles are then intersected, and the average of all intersection points is used as the initial guess for a Newton iterative solver, implemented by <function>newton_ssi</function>, which searches for a point close to the guess point which lies on both surfaces. Solved points that lies inside an overlap region identified in the first stage are discarded. Nearby points in the set of solved intersection points between <parameter>surfA</parameter> and <parameter>surfB</parameter> are then stitched together into polyline curves. If a line or conic curve can be fit to the polyline curves in 2d, the fit curve replaces the original <parameter>surfA</parameter> and/or <parameter>surfB</parameter> polyline curve. 
	</para>
      </section>
    </section>

    <section>
      <title>Visualizing the Algorithm</title>
      <para>Walking through an evaluation.</para>
    </section>

    <section>
      <title>The OpenNURBS API</title>
      <para>
        BRL-CAD leverages the OpenNURBS library primarily for its classes that represent general (NURBS) b-rep, surface, curve, and point geometry. The following sections describe the OpenNURBS library symbols most frequently used in the NURBS boolean evaluation implementation, with relevant usage notes.
      </para>
      <section>
        <title>Arrays</title>
        <para>
          OpenNURBS includes two general array classes similar to C++'s <classname>std::vector</classname>, <classname>ON_ClassArray</classname> and <classname>ON_SimpleArray</classname>. Besides having slightly friendlier interfaces, they also feature some higher-level member functions like <function>Reverse</function> and <function>Quicksort</function>.
        </para>
        <para>
          The primary difference between the two classes is that <classname>ON_SimpleArray</classname> doesn't bother constructing and destructing its items. This makes it more efficient than <classname>ON_ClassArray</classname>, but unsuitable for class objects (though pointers to objects are fine). <classname>ON_ClassArray</classname> requires items to have working copy/assignment functions.
        </para>
	<para>
	  The NURBS boolean evaluation implementation frequently employs a combined array of known size to index elements from two input objects. For example, if <parameter>brepA</parameter> has <inlineequation><mathphrase>i</mathphrase></inlineequation> faces and <parameter>brepB</parameter> has <inlineequation><mathphrase>j</mathphrase></inlineequation> faces, a single array of <inlineequation><mathphrase>i + j</mathphrase></inlineequation> elements is created.
	</para>
	<warning>
	  <para>
	    The OpenNURBS array classes do not check for out-of-bounds indexing. This isn't a problem in the simple case where items are added with <function>Append</function> and elements <inlineequation><mathphrase>[0, </mathphrase></inlineequation><function>Count()</function><inlineequation><mathphrase> - 1]</mathphrase></inlineequation> are iterated over.
	  </para>
	  <para>
	    However, if the array will be a fixed size whose items are assigned in a nonsequential order, both the <emphasis>capacity</emphasis> and <emphasis>count</emphasis> should be set, or else the reported <function>Count</function> will be incorrect, and copying arrays by assignment won't work.
	  </para>
	  <programlisting>
	<![CDATA[
	ON_ClassArray< ON_SimpleArray<SSICurve> > curves_array(face_count1 + face_count2);
	curves_array.SetCount(curves_array.Capacity());
	]]>
	  </programlisting>
	</warning>
      </section>
      <section>
        <title>Zero</title>
        <para>
          The OpenNURBS routines make extensive use of the symbol <varname>ON_ZERO_TOLERANCE</varname> in calculations to test if a result is to be considered equal to zero, or if two values are to be considered equal.
        </para>
        <note>
          <para>
            The NURBS boolean evaluation implementation frequently uses the function <function>ON_NearZero(double x, double tolerance = ON_ZERO_TOLERANCE)</function> to check if values are near zero, or to check if two values are identical (e.g <function>ON_NearZero(t - last_t)</function>).
          </para>
          <para>
            This function is also used to determine if objects are close enough to be considered intersecting: <function>ON_NearZero(pt.DistanceTo(other.pt), INTERSECTION_TOL)</function>.
          </para>
        </note>
      </section>
      <section>
	<title>2D and 3D Points</title>
	<para>
	  The <classname>ON_2dPoint</classname> and <classname>ON_3dPoint</classname> classes implement the expected operators allowing points to be easily summed and scaled.
	</para>
	<para>
	  The <function>operator[]</function> functions are notable because coordinates are not actually stored as arrays in these classes, but rather in the named members <varname>x</varname>, <varname>y</varname>, and <varname>z</varname>. So while accessing coordinates as <varname>pt[0]</varname>, <varname>pt[1]</varname> is possible, the more readable <varname>pt.x</varname>, <varname>pt.y</varname>, is more typically seen.
	</para>

	<para>
	  The most frequently used member function is <function><![CDATA[DistanceTo(const ON_3dPoint &p)]]></function>, used to check inter-point distances, either as part of an intersection test or to identify closeable gaps or duplicate points.
	</para>
	<note>
	  <para>
	    <classname>ON_2dPoint</classname> objects can be, and are, safely passed to functions that take <classname>ON_3dPoint</classname> arguments. The <classname>ON_3dPoint</classname> arguments are constructed from the provided <classname>ON_2dPoint</classname> objects, wth their <varname>z</varname> coordinates set to 0.
	  </para>
          <para>
            The NURBS boolean evaluation implementation frequently constructs 2D curves by populating an <classname>ON_3dPointArray</classname> with 2D points, rather than using an <classname>ON_2dPointArray</classname>, as the 3D version of the class (besides having additional useful member functions), can be used to initialize an <classname>ON_PolylineCurve</classname>.
          </para>
	</note>
      </section>
      <section>
	<title>Bounding Boxes</title>
        <para>
        <classname>ON_BoundingBox</classname> is returned by the <function>BoundingBox</function>, <function>GetTightBoundingBox</function>, and <function>GetBBox</function> functions, which are implemented by all geometry classes inheriting from <classname>ON_Geometry</classname>.
        </para>
        <para>
          The most commonly used members of <classname>ON_BoundingBox</classname> are <function>Diagonal</function> (usually in an expression such as <varname>bbox.Diagonal().Length()</varname> used as a scalar size estimate), and <function>IsPointIn</function> and <function>MinimumDistanceTo</function> (used in intersection tests).
        </para>
      </section>
      <section>
	<title>Domain Intervals</title>
	<para>
	  <classname>ON_Interval</classname> is used to represent the domains of parametric curves and surfaces. The domain <emphasis>starts</emphasis> at <varname>m_t[0]</varname> and <emphasis>ends</emphasis> at <varname>m_t[1]</varname>. These members can be set directly or via <function>Set(double t0, double t1)</function>.
	</para>
	<warning>
	  <para>
	    The start, end, and overall length of the domain are <emphasis>arbitrary</emphasis>, and <varname>m_t[0]</varname> need not be less than <varname>m_t[1]</varname>. If the numerically smaller or larger domain endpoint is needed, these should be accessed via the <function>Min</function> and <function>Max</function> member functions.
	  </para>
	</warning>
	<para>
	  The <function>ParameterAt(double x)</function> function translate a normalized parameter (from a domain starting at 0.0 and ending at 1.0) into a real parameter. Thus, the start of the domain is at <varname>domain.ParameterAt(0.0)</varname>, the midpoint is at <varname>domain.ParameterAt(.5)</varname>, etc.
	</para>
      </section>
      <section>
	<title>Parametric Curves</title>
	<para>
	  The most frequenlty used geomety class is <classname>ON_Curve</classname>, a generic container for parametric curves. The curve is interrogated by using the <function>PointAt(double t)</function> method to evaluate points at arbitrary values inside the curve's domain, which is specified by the <classname>ON_Interval</classname> returned by the <function>Domain()</function> method. The start and end points of the curve have dedicated access methods, <function>PointAtStart()</function> and <function>PointAtEnd()</function>.
	</para>
	<warning>
	  <para>
	    <function>PointAt</function> takes a real parameter; normalized parameters must be converted. For example, the midpoint of the curve can be found as <varname>curve->PointAt(curve->Domain().ParameterAt(.5))</varname>. <function>PointAt</function> <emphasis role="bold">does not check</emphasis> if the <parameter>t</parameter> value you give it is inside the curve's domain, so you have to get this right!
	  </para>
	</warning>
	<para>
	  All the <function>PointAt</function> methods return an <classname>ON_3dPoint</classname>, though in the common case where <classname>ON_Curve</classname> objects are representing 2d trim curves, the z coordinate will be 0.0.
	</para>
	<para>
	  The curve's domain is frequently reversed using the <function>Reverse()</function> method to facilitate stitching curves together. The function has a boolean <type>int</type> return value that must be checked.
	</para>
	<para>
	  <programlisting>
<![CDATA[
if (curveA->PointAtStart().DistanceTo(curveB->PointAtStart()) < dist_tol) {
  if (curveA->Reverse()) {
      curveA = link_curves(curveA, curveB);
  }
}
]]>
	  </programlisting>
	</para>
	<warning>
	  <para>
	    Comparing curve endpoints, or even just bounding boxes (retrived via the <function>BoundingBox()</function> method), is often sufficient in the context of different intersection and stitching procedures. However, it's important to keep in mind that in the general case, the shape of the curve between its endpoints or within its bounding box could be anything. For example, two curves with matching endpoints could both be linear, creating a degenerate loop. A curve whose endpoints are equal within the OpenNURBS <constant>ON_ZERO_TOLERANCE</constant> (testable using the <function>IsClosed()</function> method), may be self-intersecting, or degenerate to a point.
	  </para>
	</warning>
	<para>
	  A copy of the curve can be easily made using <function>Duplicate()</function>, which simply wraps a standard copy procedure:
	</para>
	<programlisting>
ON_Curve* Duplicate()
{
  ON_Curve *p = new ON_Curve;
  if (p) *p = *this;
  return p;
}
	</programlisting>
	<para>
	  This method is common to all OpenNURBS geometry classes, but curves are by far the most frequently duplicated objects. However, if curves are simply being retained from a working set of container objects, the curve pointers are freqently stolen rather than copied, with curve members set to <constant>NULL</constant> so that the curves aren't destructed with the containers.
	</para>
      </section>
      <section>
	<title>Lines</title>
	<para>
	  <classname>ON_Line</classname> is used to represent an infinite line, defined by two points, <varname>from</varname> and <varname>to</varname>.
	</para>

	<para>
	  <classname>ON_Line</classname> is not a subclass of <classname>ON_Curve</classname> and should not be confused with <classname>ON_LineCurve</classname> (which has an <classname>ON_Line</classname> member), though it does have some of the same methods as an <classname>ON_Curve</classname> class, including <function>PointAt(double t)</function>. However, because the line has an infinite domain, it can be evaluated at any <varname>t</varname> value, though evaluating at 0.0 returns <varname>from</varname> and evaluating at 1.0 returns <varname>to</varname>, as if the line was a parametric curve with a domain between 0.0 and 1.0.
	</para>

	<para>
	  <classname>ON_Line</classname> has helpful line-specific methods such as <function><![CDATA[ClosestPointTo(const ON_3dPoint &point)]]></function>. Again, because the line is treated as infinite, this function doesn't necessarily return a point in the segment between <varname>from</varname> and <varname>to</varname>.
	</para>

	<para>
	</para>
      </section>
      <section>
	<title>Surfaces</title>
	<para>
	  An <classname>ON_Surface</classname> has a similar interface to an <classname>ON_Curve</classname>, but adapted to support the surface's two domains, <parameter>u</parameter> and <parameter>v</parameter> (sometimes called <parameter>s</parameter> and <parameter>t</parameter>) which correspond with 0 and 1 (first example) or <parameter>x</parameter> and <parameter>y</parameter> (second example).
	</para>
	<example>
	  <title>Projecting an arbitrary <inlineequation><mathphrase>(u, v)</mathphrase></inlineequation> point into 3d.</title>
	  <programlisting>
<![CDATA[
ON_Interval udom = surface->Domain(0);
ON_Interval vdom = surface->Domain(1);
ON_3dPoint surf_midpt_3d = surface->PointAt(udom.ParameterAt(.5), vdom.ParameterAt(.5));
]]>
	  </programlisting>
	</example>
	<example>
	  <title>Projecting a trim-curve point into 3d.</title>
	  <programlisting>
<![CDATA[
ON_Interval tdom = trim_curve->Domain();
ON_3dPoint trim_midpt_uv = trim_curve->PointAt(tdom.ParameterAt(.5));
ON_3dPoint trim_midpt_3d = surface->PointAt(trim_midpt_uv.x, trim_midpt_uv.y);
]]>
	  </programlisting>
	</example>
      </section>
      <section>
	<title>Boundary Representation Objects</title>
	<para>
	  <classname>ON_Brep</classname> is the top-level OpenNURBS class used to represent the two input objects and the evaluated result of the <function>ON_Boolean</function> function. The geometry is encoded as a collection of faces, which for our purposes should be topologically connected to enclose solid volumes.
	</para>
	<para>
	  An object's faces are <classname>ON_BrepFace</classname> objects stored in the <classname>ON_Brep</classname> face array, <varname>m_F</varname>.
	</para>
	<para>
	  Each <classname>ON_BrepFace</classname> is defined as the subset of an <classname>ON_Surface</classname> lying inside the face's <glossterm>outerloop</glossterm> (a.k.a. the <glossterm>face boundary</glossterm>) and outside all of its <glossterm>innerloops</glossterm> (a.k.a. <glossterm>trim loops</glossterm> or just <glossterm>trims</glossterm>). 
	</para>
	<para>
	  The loops of an <classname>ON_BrepFace</classname> are listed in its loop array <varname>m_li</varname> as indexes into the associated <classname>ON_Brep</classname> object's <classname>ON_BrepLoop</classname> array, <varname>m_L</varname>. The first (and possibly only) loop listed in the face's loop index array is the outerloop, and all following loops are inner trim loops. The type of the loop is also recorded in the loop's <varname>m_type</varname> member.
	</para>
	<programlisting>
brep->m_L[brep->m_F[0]->m_li[0]].m_type;      // ON_BrepLoop::outer
brep->m_L[brep->m_F[0]->m_li[1]].m_type;      // ON_BrepLoop::inner
...
brep->m_L[*brep->m_F[0]->m_li.Last()].m_type; // ON_BrepLoop::inner
	</programlisting>
      </section>
      <section>
        <title>Intersection Events</title>
        <para>
          There are two OpenNURBS classes for representing intersections. <classname>ON_X_EVENT</classname> is used for curve-curve and curve-surface intersections. <classname>ON_SSX_EVENT</classname> is used for surface-surface intersections.
        </para>
        <para>
          These classes enumerate a number of intersection types. The <varname>m_type</varname> of intersection events is frequently checked to determine how to further process them over the course of the evaluation.
        </para>
        <variablelist>
          <varlistentry>
            <term><varname>ON_X_EVENT::ccx_overlap</varname></term>
            <listitem>
              <para>
                Two curves are coincident with one another over a portion of their domains.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><varname>ON_SSX_EVENT::ssx_overlap</varname></term>
            <listitem>
              <para>
                Two surfaces are coincident over a portion of their domains.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><varname>ON_SSX_EVENT::ssx_tangent</varname>, <varname>ON_SSX_EVENT::ssx_transverse</varname></term>
            <listitem>
              <para>
                Two surfaces intersect in a curve. If the normals of the surfaces are parallel over all points of the curve, the intersection is tangent, and transverse otherwise.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><varname>ON_SSX_EVENT::ssx_tangent_point</varname>, <varname>ON_SSX_EVENT::ssx_transverse_point</varname></term>
            <listitem>
              <para>
                Two surfaces intersect at a point. The intersection is tangent if the normals of the two surfaces are parallel at that point, and transverse otherwise.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <note>
          <para>
            An additional class, <classname>ON_PX_EVENT</classname> has been implemented as an extension to the OpenNURBS API to represent point-point, point-curve, and point-surface intersection events.
          </para>
        </note>
      </section>
      <section>
	<title>Pitfalls</title>
	<para>Mistakes made.</para>
      </section>
    </section>

    <section>
      <title>Code Conventions</title>
      <section>
	<title>Pitfalls</title>
	<para>Mistakes made.</para>
      </section>
    </section>

  </section>
</article>
