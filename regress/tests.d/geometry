#!/bin/sh
#
# g e o m e t r y
#
# This is the initial brlcad geometry test.  All of the supported primitives
# that have values set for the mged 'in' and 'db put' commands have 
# corresponding geometry created and then the resulting views are 
# raytraced and compared.  Different versions of supported databases may
# also be compared to each other and corresponding differences are
# logged.
#
###
# Source function library
. `dirname $0`/library

# this is not necessary, but including anyways for now
initializeVariable TEST "geometry"

start ( ) {
    
#
# these should be the brlcad "database names" that are used to create geometry in a geometry editor
#
PRIMITIVES="arb5 arb6 arb7 arb8 arbn ars bot cline dsp ebm ehy ell epa eto extrude grip half hf nmg nurb part pg pipe rec rhc rpc sketch sph submodel tgc tor vol xxx"
#
# these are the versions that are supported and considered valid
#
VER="4 5"

#
# Start of Primitive Arguments
###

#
# Arbitrary Regular Polyhedron with 4-faces (arb4) Arguments
# 
# in args =>
#
arb4_IN_ARGS="50 -50 -50 50 50 -50 50 50 50 -50 50 -50"
arb4_DB_ARGS="V1 {50 -50 -50} V2 {50 50 -50} V3 {50 50 50} V4 {50 50 50} V5 {-50 50 -50} V6 {-50 50 -50} V7 {-50 50 -50} V8 {-50 50 -50}"

#
# Arbitrary Regular Polyhedron with 5-faces (arb5) Arguments
# 
# in args =>
#
arb5_IN_ARGS="50 -50 -50 50 50 -50 50 50 50 50 -50 50 -50 0 0"
arb5_DB_ARGS="V1 {50 -50 -50} V2 {50 50 -50} V3 {50 50 50} V4 {50 -50 50} V5 {-50 0 0} V6 {-50 0 0} V7 {-50 0 0} V8 {-50 0 0}"

#
# Arbitrary Regular Polyhedron with 6-faces (arb6) Arguments
# 
# in args =>
#
arb6_IN_ARGS="50 -50 -50 50 50 -50 50 50 50 50 -50 50 -50 0 -50 -50 0 50"
arb6_DB_ARGS="V1 {50 -50 -50} V2 {50 50 -50} V3 {50 50 50} V4 {50 -50 50} V5 {-50 0 -50} V6 {-50 0 -50} V7 {-50 0 50} V8 {-50 0 50}"

#
# Arbitrary Regular Polyhedron with 7-faces (arb7) Arguments
# 
# in args =>
#
arb7_IN_ARGS="50 -50 -25 50 50 -25 50 50 75 50 -50 25 -50 -50 -25 -50 50 -25 -50 50 25"
arb7_DB_ARGS="V1 {50 -50 -25} V2 {50 50 -25} V3 {50 50 75} V4 {50 -50 25} V5 {-50 -50 -25} V6 {-50 50 -25} V7 {-50 50 25} V8 {-50 -50 -25}"

#
# Arbitrary Regular Polyhedron with 8-faces (arb8) Arguments
# 
# in args =>
#
arb8_IN_ARGS="50 -50 -50 50 50 -50 50 50 50 50 -50 50 -50 -50 -50 -50 50 -50 -50 50 50 -50 -50 50"
arb8_DB_ARGS="V1 {50 -50 -50} V2 {50 50 -50} V3 {50 50 50} V4 {50 -50 50} V5 {-50 -50 -50} V6 {-50 50 -50} V7 {-50 50 50} V8 {-50 -50 50}"

#
# (arbn) Arguments
# 
# in args =>
#
arbn_IN_ARGS=""
arbn_DB_ARGS=""

#
# (ars) Arguments
# 
# in args =>
#
ars_IN_ARGS="4 4 0 0 0 0 0 1 1 0 1 1 1 1 0 1 1 0 0 2 1 0 2 1 1 2 0 1 2 0 0 2.5"
ars_DB_ARGS="NC 4 PPC 4 C0 { { 0 0 0 } { 0 0 0 } { 0 0 0 } { 0 0 0 } } C1 { { 0 0 1 } { 1 0 1 } { 1 1 1 } { 0 1 1 } } C2 { { 0 0 2 } { 1 0 2 } { 1 1 2 } { 0 1 2 } } C3 { { 0 0 2.5 } { 0 0 2.5 } { 0 0 2.5 } { 0 0 2.5 } }"

#
# Bag O'Triangles (bot) Arguments
# 
# in args => name num_vertices num_triangles mode orientation vertex1 vertex2... face1 face2 ...
#
bot_IN_ARGS="4 4 2 1 0 0 0 50 0 0 50 50 0 50 50 50 0 1 2 1 2 3 0 1 3 0 2 3 "
bot_DB_ARGS="mode volume orient no V { { 0 0 0 } { 50 0 0 } { 50 50 0 } { 50 50 50 } } F { { 0 1 2 } { 1 2 3 } { 0 1 3 } { 0 2 3 } }"

#
# (cline) Arguments
# 
# in args =>
#
cline_IN_ARGS=""
cline_DB_ARGS=""

#
# (dsp) Arguments
# 
# in args =>
#
dsp_IN_ARGS=""
dsp_DB_ARGS=""

#
# Extruded Bitmap (ebm) Arguments
# 
# in args => bw_file width height extrusion_distance
#
ebm_IN_ARGS="${TEST}.ebm.bw 32 32 10"
ebm_DB_ARGS="F ${TEST}.ebm.bw W 32 N 32 H 10 M { 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 }"

#
# (ehy) Arguments
# 
# in args =>
#
ehy_IN_ARGS="0 0 0 0 0 180 75 0 0 50 80"
ehy_DB_ARGS="V {0 0 0} H {0 0 180} A {1 0 0} r_1 75 r_2 50 c 80"

#
# Ellipsoid (ell) Arguments
#
# in args => name type xvertex yvertex zvertex radius1 radius2 radius3
#
ell_IN_ARGS="0 0 0  45 0 0  0 30 0  0 0 15"
ell_DB_ARGS="V { 0 0 0 } A {45 0 0} B {0 30 0} C {0 0 15}"

#
# Elliptical Paraboloid (epa) Arguments
# 
# in args =>
#
epa_IN_ARGS="0 0 0  0 0 10  5 0 0 2"
epa_DB_ARGS="V {0 0 0} H {0 0 10} A {1 0 0} r_1 5 r_2 2"

#
# Elliptical Toroid (eto) Arguments
# 
# in args =>
#
eto_IN_ARGS="0 0 0 0 0 1 8 0 0 4 1 "
eto_DB_ARGS="V {0 0 0} N {0 0 1} C {0 0 4} r 8 r_d 1"

#
# (extrude) Arguments
# 
# in args =>
#
extrude_IN_ARGS=""
extrude_DB_ARGS=""

#
# (grip) Arguments
# 
# in args =>
#
grip_IN_ARGS=""
grip_DB_ARGS=""

#
# HALFSPACE (half) Arguments
# 
# in args => name type outward-pointing-normal distance-from-origin
#
half_IN_ARGS="0 0 1  0"
half_DB_ARGS="N {0 0 1} d 0"

#
# (hf) Arguments
# 
# in args =>
#
hf_IN_ARGS=""
hf_DB_ARGS=""

#
# (nmg) Arguments
# 
# in args =>
#
nmg_IN_ARGS=""
nmg_DB_ARGS=""

#
# (nurb) Arguments
# 
# in args =>
#
nurb_IN_ARGS=""
nurb_DB_ARGS=""

#
# (part) Arguments
# 
# in args => vertex vectorH v_radius h_radius
#
part_IN_ARGS="0 0 0  0 0 50  10 20"
part_DB_ARGS="V {0 0 0} H {0 0 50} r_v 10 r_h 20"

#
# (pg) Arguments
# 
# in args =>
#
pg_IN_ARGS=""
pg_DB_ARGS=""

#
# (pipe) Arguments
# 
# in args =>
#
pipe_IN_ARGS="6 0 0 0 10 12 25 100 0 0 10 12 25 100 100 0 10 12 25 100 100 100 10 12 25 100 100 200 10 12 25 100 200 200 10 12 25"
pipe_DB_ARGS="V0 { 0 0 0 } O0 12 I0 10 R0 25 V1 { 100 0 0 } O1 12 I1 10 R1 25 V2 { 100 100 0 } O2 12 I2 10 R2 25 V3 { 100 100 100 } O3 12 I3 10 R3 25 V4 { 100 100 200 } O4 12 I4 10 R4 25 V5 { 100 200 200 } O5 12 I5 10 R5 25"

#
# (rec) Arguments
# 
# in args => xvertex yvertex zvertex xheight yheight zheight
#            xradius1 yradius1 zradius1 xradius2 yradius2 zradius2
#
rec_IN_ARGS="0 0 0  0 0 50  40 0 0  0 10 0"
rec_DB_ARGS="V {0 0 0} H {0 0 50} A {40 0 0} B {0 10 0} C {40 0 0} D {0 10 0}"

#
# (rhc) Arguments
# 
# in args => xvertex yvertex zvertex xheight yheight zheight 
#            rect. half-width apex-to-asymptopes dist.
#
rhc_IN_ARGS="0 0 0 0 0 100 100 0 0 10 50"
rhc_DB_ARGS="V {0 0 0} H {0 0 100} B {100 0 0} r 10 c 50"

#
# (rpc) Arguments
# 
# in args =>
#
rpc_IN_ARGS="0 0 0  10 0 0 0 0 10 2"
rpc_DB_ARGS="V {0 0 0} H {10 0 0} B {0 0 10} r 2"

#
# (sketch) Arguments
# 
# in args =>
#
sketch_IN_ARGS=""
sketch_DB_ARGS=""

#
# Sphere (sph) Arguments
#
# Note that the sph is really an ell with all radii equal.
# 
# in args => name type xvertex yvertex zvertex radius1
#
sph_IN_ARGS="0 0 0 45"
sph_DB_ARGS="V { 0 0 0 } A {45 0 0} B {0 45 0} C {0 0 45}"

#
# (submodel) Arguments
# 
# in args =>
#
submodel_IN_ARGS=""
submodel_DB_ARGS=""

#
# (tgc) Arguments
#
# in args => xvertex yvertex zvertex xheight yheight zheight
#            xradiusA yradiusA zradiusA xradiusB yradiusB zradiusB
#            radiusC radiusD
tgc_IN_ARGS="0 0 0  0 0 50  40 0 0  0 10 0  20 5"
tgc_DB_ARGS="V {0 0 0} H {0 0 50} A {40 0 0} B {0 10 0} C {20 0 0} D {0 5 0}"
 
#
# Torus (tor) Arguments
#
# in args => name type xvertex yvertex zvertex xnormal ynormal znormal radius1 radius2
#
tor_IN_ARGS="0 0 0 0 0 1 30 20"
tor_DB_ARGS="V { 0 0 0 } H { 1 0 0 } r_a 50 r_h 25"

#
# (vol) Arguments
# 
# in args => file xNcells yNcells zNcells lower_threshold upper_threshold
#            xvoxelsize yvoxelsize zvoxelsize
#
vol_IN_ARGS="${TEST}.vol.bw 32 32 8 128 255 10 10 10"
vol_DB_ARGS="file ${TEST}.vol.bw w 32 n 32 d 8 lo 128 hi 255 size {10 10 10} mat {1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1}"

#
# (xxx) Arguments
# 
# in args =>
#
xxx_IN_ARGS=""
xxx_DB_ARGS=""

#
# End of Primitive Arguments
###

clean

PATH=$BRLCAD_ROOT/bin:$PATH

#
# iterate over primitives
#
for PRIM in $PRIMITIVES ; do

    unset IN_ARGS ; IN_ARGS="echo \$${PRIM}_IN_ARGS" ; IN_ARGS=`eval $IN_ARGS`
    unset DB_ARGS ; DB_ARGS="echo \$${PRIM}_DB_ARGS" ; DB_ARGS=`eval $DB_ARGS`

    if [ "x$IN_ARGS" = "x" ] && [ "x$DB_ARGS" = "x" ]  ; then
        warn "Primitive ${PRIM} has no arguments set, skipping"
    else

        log ""
        log "Evaluating $PRIM"
        log "===================="


        #
        # primitive specific tests and initialization
        #
	if [ "x${PRIM}" = "xebm" ]; then
            #
            # If the solid is an ebm, create the bitmap to extrude
	    #
	    gencolor -r205 0 16 32 64 128 | \
                dd of=${TEST}.ebm.bw bs=1024 count=1 >/dev/null 2>&1

            if [ $? != 0 ] ; then
                warn "gencolor failed to create ebm primitive bitmap datafile properly"
            fi

	elif [ "x${PRIM}" = "xvol" ]; then
	    #
	    # Create a 32x32x8 element voxel map by
	    # concatenating 8 bw files.
	    #
	    gencolor -r205 0 16 32 64 128 | \
                dd of=${TEST}.tmp.bw bs=1024 count=1 >/dev/null 2>&1
	    cat ${TEST}.tmp.bw > ${TEST}.vol.bw
	    gencolor -r205 16 32 64 128 0 | \
                dd of=${TEST}.tmp.bw bs=1024 count=1 >/dev/null 2>&1
	    cat ${TEST}.tmp.bw >> ${TEST}.vol.bw
	    gencolor -r205 32 64 128 0 16 | \
                dd of=${TEST}.tmp.bw bs=1024 count=1 >/dev/null 2>&1
	    cat ${TEST}.tmp.bw >> ${TEST}.vol.bw
	    gencolor -r205 64 128 0 16 32 | \
                dd of=${TEST}.tmp.bw bs=1024 count=1 >/dev/null 2>&1
	    cat ${TEST}.tmp.bw >> ${TEST}.vol.bw
	    gencolor -r205 128 0 16 32 64 | \
                dd of=${TEST}.tmp.bw bs=1024 count=1 >/dev/null 2>&1
	    cat ${TEST}.tmp.bw >> ${TEST}.vol.bw
	    gencolor -r205 0 16 32 64 128 | \
                dd of=${TEST}.tmp.bw bs=1024 count=1 >/dev/null 2>&1
	    cat ${TEST}.tmp.bw >> ${TEST}.vol.bw
	    gencolor -r205 16 32 64 128 0 | \
                dd of=${TEST}.tmp.bw bs=1024 count=1 >/dev/null 2>&1
	    cat ${TEST}.tmp.bw >> ${TEST}.vol.bw
	    gencolor -r205 32 64 128 0 16 | \
                dd of=${TEST}.tmp.bw bs=1024 count=1 >/dev/null 2>&1
	    cat ${TEST}.tmp.bw >> ${TEST}.vol.bw

            if expr "`ls -s ${TEST}.vol.bw | awk '{print $1}'`" = "0" ; then
                warn "failed to create vol primitive volume map datafile properly"
            fi
            rm ${TEST}.tmp.bw
	fi


        # make sure mged will run
        mged -c > /dev/null 2>&1 <<EOF
q
EOF
[ $? != 0 ] && bomb "MGED fails to run"


        #
        # Test 'in' command
        #
        for VERSION in $VER ; do
            mged -c > ${TEST}.${PRIM}.${VERSION}.mged.log 2>&1 <<EOF
# Start MGED script

set glob_compat_mode 0

set mged_default(db_version) $VERSION

puts "Opening database \[${TEST}.${PRIM}.${VERSION}.g\]"
opendb ${TEST}.${PRIM}.${VERSION}.g

set autosize 0
units mm

Z
viewsize 100 
ae 35 25

set inval "in ${PRIM}.in.s $PRIM $IN_ARGS"
puts "Running \[\$inval\]"
eval \$inval
saveview ${TEST}.${PRIM}.${VERSION}.in.rt

q

# End MGED script
EOF
            if [ $? != 0 ] ; then
                warn "v$VERSION $PRIM 'in' command failed"
            fi
        done
        # end loop over versions for in command



        #
        # Test 'putmat' command
        #
        for VERSION in $VER ; do
            mged -c > ${TEST}.${PRIM}.${VERSION}.mged.log 2>&1 <<EOF
###################
# Start MGED script

set glob_compat_mode 0

set mged_default(db_version) $VERSION

puts "Opening database \[${TEST}.${PRIM}.${VERSION}.g\]"
opendb ${TEST}.${PRIM}.${VERSION}.g

set autosize 0
units mm

Z
viewsize 100 
ae 35 25

set inval "in ${PRIM}.putmat.s $PRIM $IN_ARGS"
puts "Running \[\$inval\]"
eval \$inval

Z
viewsize 100 
ae 35 25
r ${PRIM}.putmat.r u ${PRIM}.putmat.s
# sca .5, rot 10 10 -10, tra 20 -20 20
set putmatval "putmat ${PRIM}.putmat.r/${PRIM}.putmat.s { 0.969846 -0.17101 -0.173648 19.3442  0.200706 0.96461 0.17101 -11.8579  0.138258 -0.200706 0.969846 26.1762  0 0 0 1 }"
puts "Running \[\$putmatval\]"
eval \$putmatval

push ${PRIM}.putmat.r
shader ${PRIM}.putmat.r {checker {s 4}}

Z
viewsize 100 
ae 35 25
e ${PRIM}.putmat.r
saveview ${TEST}.${PRIM}.${VERSION}.putmat.rt

q

# End MGED script
###################
EOF
            if [ $? != 0 ] ; then
                warn "v$VERSION $PRIM 'putmat' command failed"
            fi
        done
        # end loop over versions for putmat command


        #
        # Test make' command
        #
        for VERSION in $VER ; do
            mged -c > ${TEST}.${PRIM}.${VERSION}.mged.log 2>&1 <<EOF
###################
# Start MGED script

set glob_compat_mode 0

set mged_default(db_version) $VERSION

puts "Opening database \[${TEST}.${PRIM}.${VERSION}.g\]"
opendb ${TEST}.${PRIM}.${VERSION}.g

set autosize 0
units mm

Z
viewsize 100 
ae 35 25

set makeval "make ${PRIM}.make.s $PRIM"
puts "Running \[\$makeval\]"
eval \$makeval
saveview ${TEST}.${PRIM}.${VERSION}.make.rt

q

# End MGED script
###################
EOF
            if [ $? != 0 ] ; then
                warn "v$VERSION $PRIM 'make' command failed"
            fi
        done
        # end loop over versions for make command


        #
        # Test 'db put' command
        #
        for VERSION in $VER ; do
            mged -c > ${TEST}.${PRIM}.${VERSION}.mged.log 2>&1 <<EOF
###################
# Start MGED script

set glob_compat_mode 0

set mged_default(db_version) $VERSION

puts "Opening database \[${TEST}.${PRIM}.${VERSION}.g\]"
opendb ${TEST}.${PRIM}.${VERSION}.g

set autosize 0
units mm

Z
viewsize 100 
ae 35 25

set dbputval "db put ${PRIM}.dbput.s $PRIM $DB_ARGS"
puts "Running \[\$dbputval\]"
eval \$dbputval
e ${PRIM}.dbput.s
saveview ${TEST}.${PRIM}.${VERSION}.dbput.rt

q

# End MGED script
###################
EOF
            if [ $? != 0 ] ; then
                warn "v$VERSION $PRIM 'db put' command failed"
            fi
        done
        # end loop over versions for db put command

        #
        # Version databases are now created, so we test them
        #


        for VERSION in $VER ; do
            if [ -f ${TEST}.${PRIM}.${VERSION}.g ] ; then
            
                log "Raytracing"

                [ -f ./${TEST}.${PRIM}.${VERSION}.in.rt ] && ./${TEST}.${PRIM}.${VERSION}.in.rt -B
                [ $? != 0 ] && warn "v$VERSION $PRIM 'in' rt failed"

                [ -f ./${TEST}.${PRIM}.${VERSION}.putmat.rt ] && ./${TEST}.${PRIM}.${VERSION}.putmat.rt -B
                [ $? != 0 ] && warn "v$VERSION $PRIM 'putmat' rt failed"

                [ -f ./${TEST}.${PRIM}.${VERSION}.make.rt ] && ./${TEST}.${PRIM}.${VERSION}.make.rt -B
                [ $? != 0 ] && warn "v$VERSION $PRIM 'make' rt failed"

                [ -f ./${TEST}.${PRIM}.${VERSION}.dbput.rt ] && ./${TEST}.${PRIM}.${VERSION}.dbput.rt -B
                [ $? != 0 ] && warn "v$VERSION $PRIM 'db put' rt failed"

                log "Converting to ascii (g2asc)"
                g2asc ${TEST}.${PRIM}.${VERSION}.g ${TEST}.${PRIM}.${VERSION}.g2asc.asc > ${TEST}.${PRIM}.${VERSION}.g2asc.log 2>&1
                [ $? != 0 ] && warn "v$VERSION $PRIM 'g2asc' failed"
 
                log "Converting to binary (asc2g)"
                asc2g ${TEST}.${PRIM}.${VERSION}.g2asc.asc ${TEST}.${PRIM}.${VERSION}.g2asc.asc2g.g > ${TEST}.${PRIM}.${VERSION}.asc2g.log 2>&1
                [ $? != 0 ] && warn "v$VERSION $PRIM 'asc2g' failed"

                log "Database diffing (g_diff) v${VERSION} against current"
                g_diff -f ${TEST}.${PRIM}.${VERSION}.g2asc.asc2g.g ${TEST}.${PRIM}.${VERSION}.g
                [ $? != 0 ] && warn "v$VERSION $PRIM 'g_diff' failed"
            else
                warn "No v$VERSION database was created for ${PRIM}"
            fi
            
        done  
        # end loop over vers

        log "Done with ${PRIM}"

    fi
    # end of test if primitive has values set

done  
# end loop over primitives


    return 0
}


clean ( ) {
    if [ ! "x$TEST" = "x" ] ; then
        rm -f ${TEST}.* > /dev/null 2>&1
    fi

    return 0
}


regress $1

exit $?
