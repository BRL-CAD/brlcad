#!/bin/sh
#
# g e o m e t r y
#
# This is the initial brlcad geometry test.  All of the supported primitives
# that have values set for the mged 'in' and 'db put' commands have 
# corresponding geometry created and then the resulting views are 
# raytraced and compared.  Different versions of supported databases may
# also be compared to each other and corresponding differences are
# logged.
#
###
# Source function library
. `dirname $0`/library

# this is not necessary, but including anyways for now
initializeVariable TEST "geometry"

# initialize some variables, if not already set, to expected brlcadish values
initializeVariable PACKAGE_NAME brlcad
if [ "x$REGRESS_DIR" = "x" ] ; then
    if [ -d "$LPWD/../../$PACKAGE_NAME" ] ; then
        initializeVariable REGRESS_DIR "$LPWD/../.."
    elif [ -d "$LPWD/../$PACKAGE_NAME" ] ; then
        initializeVariable REGRESS_DIR "$LPWD/.."
    elif [ -d "$LPWD/$PACKAGE_NAME" ] ; then
        initializeVariable REGRESS_DIR "$LPWD"
    else
        warn "Unable to locate $PACKAGE_NAME (set REGRESS_DIR), using $LPWD anyways"
        initializeVariable REGRESS_DIR "$LPWD"
    fi
fi
__ARCH="$ARCH"
[ -x "${REGRESS_DIR}/brlcad/sh/machinetype.sh" ] && initializeVariable ARCH `${REGRESS_DIR}/brlcad/sh/machinetype.sh`
initializeVariable ARCH "$__ARCH"
__CADROOT="$BRLCAD_ROOT"
[ -d "${REGRESS_DIR}/${PACKAGE_NAME}.${ARCH}" ] && initializeVariable BRLCAD_ROOT "${REGRESS_DIR}/${PACKAGE_NAME}.${ARCH}"
initializeVariable BRLCAD_ROOT "$__CADROOT"


start ( ) {
    
#
# these should be the brlcad "database" names that are used to create geometry in a geometry editor
#
PRIMITIVES="arb4 arb5 arb6 arb7 arb8 arbn arg bot cline dsp ebm ehy ell epa eto extrude grip half hf nmg nurb part pg pipe rec rhc rpc sketch sph submodel tgc tor vol xxx"
#
# these are the versions that are supported and considered valid
#
VER="4 5"

#
# Start of Primitive Arguments
#
# Add 1) the full name of the primitive, 2) the 'in' command arg description,
#     3) 'in' command arguments, & 4) 'db put' command arguments.
###

#
# Arbitrary Regular Polyhedron with 4-faces (arb4) Arguments
# 
# in args =>
#
# arb4_IN_ARGS="50 -50 -50 50 50 -50 50 50 50 -50 50 -50"
# arb4_DB_ARGS="V1 {50 -50 -50} V2 {50 50 -50} V3 {50 50 50} V4 {50 50 50} V5 {-50 50 -50} V6 {-50 50 -50} V7 {-50 50 -50} V8 {-50 50 -50}"

#
# Arbitrary Regular Polyhedron with 5-faces (arb5) Arguments
# 
# in args =>
#
# arb5_IN_ARGS="50 -50 -50 50 50 -50 50 50 50 50 -50 50 -50 0 0"
# arb5_DB_ARGS="V1 {50 -50 -50} V2 {50 50 -50} V3 {50 50 50} V4 {50 -50 50} V5 {-50 0 0} V6 {-50 0 0} V7 {-50 0 0} V8 {-50 0 0}"

#
# Arbitrary Regular Polyhedron with 6-faces (arb6) Arguments
# 
# in args =>
#
# arb6_IN_ARGS="50 -50 -50 50 50 -50 50 50 50 50 -50 50 -50 0 -50 -50 0 50"
# arb6_DB_ARGS="V1 {50 -50 -50} V2 {50 50 -50} V3 {50 50 50} V4 {50 -50 50} V5 {-50 0 -50} V6 {-50 0 -50} V7 {-50 0 50} V8 {-50 0 50}"

#
# Arbitrary Regular Polyhedron with 7-faces (arb7) Arguments
# 
# in args =>
#
# arb7_IN_ARGS="50 -50 -25 50 50 -25 50 50 75 50 -50 25 -50 -50 -25 -50 50 -25 -50 50 25"
# arb7_DB_ARGS="V1 {50 -50 -25} V2 {50 50 -25} V3 {50 50 75} V4 {50 -50 25} V5 {-50 -50 -25} V6 {-50 50 -25} V7 {-50 50 25} V8 {-50 -50 -25}"

#
# Arbitrary Regular Polyhedron with 8-faces (arb8) Arguments
# 
# in args =>
#
arb8_IN_ARGS="50 -50 -50 50 50 -50 50 50 50 50 -50 50 -50 -50 -50 -50 50 -50 -50 50 50 -50 -50 50"
arb8_DB_ARGS="V1 {50 -50 -50} V2 {50 50 -50} V3 {50 50 50} V4 {50 -50 50} V5 {-50 -50 -50} V6 {-50 50 -50} V7 {-50 50 50} V8 {-50 -50 50}"

#
# (arbn) Arguments
# 
# in args =>
#
arbn_IN_ARGS=""
arbn_DB_ARGS=""

#
# (arg) Arguments
# 
# in args =>
#
arg_IN_ARGS=""
arg_DB_ARGS=""

#
# Bag O'Triangles (bot) Arguments
# 
# in args => name num_vertices num_triangles mode orientation vertex1 vertex2... face1 face2 ...
#
bot_IN_ARGS="4 4 2 1 0 0 0 50 0 0 50 50 0 50 50 50 0 1 2 1 2 3 0 1 3 0 2 3 "
bot_DB_ARGS="mode volume orient no V { { 0 0 0 } { 50 0 0 } { 50 50 0 } { 50 50 50 } } F { { 0 1 2 } { 1 2 3 } { 0 1 3 } { 0 2 3 } }"

#
# (cline) Arguments
# 
# in args =>
#
cline_IN_ARGS=""
cline_DB_ARGS=""

#
# (dsp) Arguments
# 
# in args =>
#
dsp_IN_ARGS=""
dsp_DB_ARGS=""

#
# Extruded Bitmap (ebm) Arguments
# 
# in args => bw_file width height extrusion_distance
#
ebm_IN_ARGS="ebm.bw 32 32 10"
ebm_DB_ARGS="F ebm.bw W 32 N 32 H 10 M { 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 }"

#
# (ehy) Arguments
# 
# in args =>
#
ehy_IN_ARGS="0 0 0 0 0 180 75 0 0 50 80"
ehy_DB_ARGS="V {0 0 0} H {0 0 180} A {1 0 0} r_1 75 r_2 50 c 80"

#
# Ellipsoid (ell) Arguments
#
# in args => name type xvertex yvertex zvertex radius1 radius2 radius3
#
ell_IN_ARGS="0 0 0  45 0 0  0 30 0  0 0 15"
ell_DB_ARGS="V { 0 0 0 } A {45 0 0} B {0 30 0} C {0 0 15}"

#
# Elliptical Paraboloid (epa) Arguments
# 
# in args =>
#
epa_IN_ARGS="0 0 0  0 0 10  5 0 0 2"
epa_DB_ARGS="V {0 0 0} H {0 0 10} A {1 0 0} r_1 5 r_2 2"

#
# Elliptical Toroid (eto) Arguments
# 
# in args =>
#
eto_IN_ARGS="0 0 0 0 0 1 8 0 0 4 1 "
eto_DB_ARGS="V {0 0 0} N {0 0 1} C {0 0 4} r 8 r_d 1"

#
# (extrude) Arguments
# 
# in args =>
#
extrude_IN_ARGS=""
extrude_DB_ARGS=""

#
# (grip) Arguments
# 
# in args =>
#
grip_IN_ARGS=""
grip_DB_ARGS=""

#
# HALFSPACE (half) Arguments
# 
# in args => name type outward-pointing-normal distance-from-origin
#
half_IN_ARGS="0 0 1  0"
half_DB_ARGS="N {0 0 1} d 0"

#
# (hf) Arguments
# 
# in args =>
#
hf_IN_ARGS=""
hf_DB_ARGS=""

#
# (nmg) Arguments
# 
# in args =>
#
nmg_IN_ARGS=""
nmg_DB_ARGS=""

#
# (nurb) Arguments
# 
# in args =>
#
nurb_IN_ARGS=""
nurb_DB_ARGS=""

#
# (part) Arguments
# 
# in args => vertex vectorH v_radius h_radius
#
part_IN_ARGS="0 0 0  0 0 50  10 20"
part_DB_ARGS="V {0 0 0} H {0 0 50} r_v 10 r_h 20"

#
# (pg) Arguments
# 
# in args =>
#
pg_IN_ARGS=""
pg_DB_ARGS=""

#
# (pipe) Arguments
# 
# in args =>
#
pipe_IN_ARGS="6 0 0 0 10 12 25 100 0 0 10 12 25 100 100 0 10 12 25 100 100 100 10 12 25 100 100 200 10 12 25 100 200 200 10 12 25"
pipe_DB_ARGS="V0 { 0 0 0 } O0 12 I0 10 R0 25 V1 { 100 0 0 } O1 12 I1 10 R1 25 V2 { 100 100 0 } O2 12 I2 10 R2 25 V3 { 100 100 100 } O3 12 I3 10 R3 25 V4 { 100 100 200 } O4 12 I4 10 R4 25 V5 { 100 200 200 } O5 12 I5 10 R5 25"

#
# (rec) Arguments
# 
# in args => xvertex yvertex zvertex xheight yheight zheight
#            xradius1 yradius1 zradius1 xradius2 yradius2 zradius2
#
rec_IN_ARGS="0 0 0  0 0 50  40 0 0  0 10 0"
rec_DB_ARGS="V {0 0 0} H {0 0 50} A {40 0 0} B {0 10 0} C {40 0 0} D {0 10 0}"

#
# (rhc) Arguments
# 
# in args => xvertex yvertex zvertex xheight yheight zheight 
#            rect. half-width apex-to-asymptopes dist.
#
rhc_IN_ARGS="0 0 0 0 0 100 100 0 0 10 50"
rhc_DB_ARGS="V {0 0 0} H {0 0 100} B {100 0 0} r 10 c 50"

#
# (rpc) Arguments
# 
# in args =>
#
rpc_IN_ARGS="0 0 0  10 0 0 0 0 10 2"
rpc_DB_ARGS="V {0 0 0} H {10 0 0} B {0 0 10} r 2"

#
# (sketch) Arguments
# 
# in args =>
#
sketch_IN_ARGS=""
sketch_DB_ARGS=""

#
# Sphere (sph) Arguments
#
# Note that the sph is really an ell with all radii equal.
# 
# in args => name type xvertex yvertex zvertex radius1
#
sph_IN_ARGS="0 0 0 45"
sph_DB_ARGS="V { 0 0 0 } A {45 0 0} B {0 45 0} C {0 0 45}"

#
# (submodel) Arguments
# 
# in args =>
#
submodel_IN_ARGS=""
submodel_DB_ARGS=""

#
# (tgc) Arguments
#
# in args => xvertex yvertex zvertex xheight yheight zheight
#            xradiusA yradiusA zradiusA xradiusB yradiusB zradiusB
#            radiusC radiusD
tgc_IN_ARGS="0 0 0  0 0 50  40 0 0  0 10 0  20 5"
tgc_DB_ARGS="V {0 0 0} H {0 0 50} A {40 0 0} B {0 10 0} C {20 0 0} D {0 5 0}"
 
#
# Torus (tor) Arguments
#
# in args => name type xvertex yvertex zvertex xnormal ynormal znormal radius1 radius2
#
tor_IN_ARGS="0 0 0 0 0 1 30 20"
tor_DB_ARGS="V { 0 0 0 } H { 1 0 0 } r_a 50 r_h 25"

#
# (vol) Arguments
# 
# in args =>
#
vol_IN_ARGS=""
vol_DB_ARGS=""

#
# (xxx) Arguments
# 
# in args =>
#
xxx_IN_ARGS=""
xxx_DB_ARGS=""

#
# Done
###

clean
PATH=$BRLCAD_ROOT/bin:$PATH

for PRIM in $PRIMITIVES ; do

    unset IN_ARGS ; IN_ARGS="echo \$${PRIM}_IN_ARGS" ; IN_ARGS=`eval $IN_ARGS`
    unset DB_ARGS ; DB_ARGS="echo \$${PRIM}_DB_ARGS" ; DB_ARGS=`eval $DB_ARGS`

    if [ "x$IN_ARGS" = "x" ] ; then
        warn "Primitive ${PRIM} has no arguments set, skipping"
    else

        #
        # If the solid is an ebm, create the bitmap to extrude
	#
	if [ "x${PRIM}" = "xebm" ]; then
	    gencolor -r205 0 16 32 64 128 | \
                dd of=ebm.bw bs=1024 count=1 >/dev/null 2>&1
	fi

        log ""
        log "Evaluating $PRIM"
        log "===================="

        mged -c <<EOF
#
# Start MGED script
#

set glob_compat_mode 0


foreach version { 4 5 } { 

    set mged_default(db_version) \$version

    puts "Opening database \[${TEST}.${PRIM}.\$version.g\]"
    opendb ${TEST}.${PRIM}.\$version.g

    set autosize 0
    units mm

    Z
    viewsize 100 
    ae 35 25

    #
    # Edit 'in' args 
    #
    set inval "in ${PRIM}.in.s $PRIM $IN_ARGS"
    puts "Running \[\$inval\]"
    eval \$inval
    saveview ${TEST}.${PRIM}.\$version.in.rt

    Z
    viewsize 100 
    ae 35 25
    set makeval "make ${PRIM}.make.s $PRIM"
    puts "Running \[\$makeval\]"
    eval \$makeval
    saveview ${TEST}.${PRIM}.\$version.make.rt

    Z
    viewsize 100 
    ae 35 25
                
    #
    # Edit 'db put' args 
    #
    set dbputval "db put ${PRIM}.dbput.s $PRIM $DB_ARGS"
    puts "Running \[\$dbputval\]"
    eval \$dbputval
    saveview ${TEST}.${PRIM}.\$version.dbput.rt

    Z
    viewsize 100 
    ae 35 25
    r ${PRIM}.in.r u ${PRIM}.in.s
    # sca .5, rot 10 10 -10, tra 20 -20 20
    set putmatval "putmat ${PRIM}.in.r/${PRIM}.in.s { 0.969846 -0.17101 -0.173648 19.3442  0.200706 0.96461 0.17101 -11.8579  0.138258 -0.200706 0.969846 26.1762  0 0 0 1 }"
    eval \$putmatval

    push ${PRIM}.in.r
    shader ${PRIM}.in.r {checker {s 4}}

    Z
    viewsize 100 
    ae 35 25
    e ${PRIM}.in.r
    saveview ${TEST}.${PRIM}.\$version.trans.rt
} 

q

#
# End MGED script
#

EOF

    for version in $VER ; do
        log "Testing v$version database for ${PRIM}"
        if [ -f ${TEST}.${PRIM}.${version}.g ] ; then

            [ -f ./${TEST}.${PRIM}.${version}.in.rt ] && ./${TEST}.${PRIM}.${version}.in.rt
            [ -f ./${TEST}.${PRIM}.${version}.make.rt ] && ./${TEST}.${PRIM}.${version}.make.rt
            [ -f ./${TEST}.${PRIM}.${version}.dbput.rt ] && ./${TEST}.${PRIM}.${version}.dbput.rt
            [ -f ./${TEST}.${PRIM}.${version}.trans.rt ] && ./${TEST}.${PRIM}.${version}.trans.rt
            log "	Done raytracing"
        
            log "	Converting to ascii (g2asc)"
            g2asc ${TEST}.${PRIM}.${version}.g ${TEST}.${PRIM}.asc
            log "	Converting to binary (asc2g)"
            asc2g ${TEST}.${PRIM}.asc ${TEST}.${PRIM}.${version}.asc2g.g
            log "	Database diffing (g_diff)"
            g_diff -f ${TEST}.${PRIM}.${version}.asc2g.g ${TEST}.${PRIM}.5.g
        else
            bomb "No v$version database was created for ${PRIM}"
        fi
        log "Done testing $version database for ${PRIM}"

    done  
    # end loop over vers

    fi
    # end of test if primitive has values set

done  
# end loop over primitives


    return 0
}

stop ( ) {
    bomb "stop unimplemented"
    return 0
}

status ( ) {
    bomb "status unimplemented"
    return 0
}

clean ( ) {
    [ ! "x$TEST" = "x" ] && rm -f ${TEST}.*

    return 0
}

case "$1" in
    start )
        start
        ;;
    stop )
        stop
        ;;
    restart )
        stop
        start
        ;;
    status )
        status
        ;;
    clean )
        clean
        ;;
    * )
        log "Usage: $0 {start|stop|restart|status}"
        exit 1
esac

exit $?

