#!/bin/sh
#
# g e o m e t r y
#
# This is the initial brlcad geometry test.  All of the supported primitives
# that have values set for the mged 'in' and 'db put' commands actually 
#
###
# Source function library
. `dirname $0`/library

# this is not necessary, but including anyways for now
initializeVariable TEST "geometry"

# initialize some variables, if not already set, to expected brlcadish values
initializeVariable PACKAGE_NAME brlcad
if [ "x$REGRESS_DIR" = "x" ] ; then
    if [ -d "$LPWD/../../$PACKAGE_NAME" ] ; then
        initializeVariable REGRESS_DIR "$LPWD/../.."
    elif [ -d "$LPWD/../$PACKAGE_NAME" ] ; then
        initializeVariable REGRESS_DIR "$LPWD/.."
    elif [ -d "$LPWD/$PACKAGE_NAME" ] ; then
        initializeVariable REGRESS_DIR "$LPWD"
    else
        bomb "Unable to locate $PACKAGE_NAME"
    fi
fi
__ARCH="$ARCH"
initializeVariable ARCH `${REGRESS_DIR}/brlcad/sh/machinetype.sh`
initializeVariable ARCH "$__ARCH"
initializeVariable BRLCAD_ROOT "${REGRESS_DIR}/${PACKAGE_NAME}.${ARCH}"


start ( ) {
    

# these should be the brlcad "database" names that are used to create geometry in a geometry editor
PRIMITIVES="arb arbn arg bot cline dsp ebm ehy ell epa eto extrude grip half hf nmg nurb part pg pipe rec rhc rpc sketch sph submodel tgc tor vol xxx"
VER="4 5"

for PRIM in $PRIMITIVES ; do

    log ""
    log "Evaluating $PRIM"
    log "===================="

    rm -f ${GEOMETRY}.*

    if [ "x${PRIM}_IN_ARGS" = "x" ] ; then
        warn "Primitive ${PRIM}_IN_ARGS has no arguments set, skipping"
    else

        unset IN_ARGS
        unset DB_ARGS
        initializeVariable IN_ARGS "${PRIM}_IN_ARGS"
        initializeVariable DB_ARGS "${PRIM}_DB_ARGS"

        mged -c <<EOF
#
# Start MGED script
#

set glob_compat_mode 0


    #
    # Start of Primitive Arguments
    #
    # Add 1) the full name of the primitive, 2) the 'in' command arg description,
    #     3) 'in' command arguments, & 4) 'db put' command arguments.
    ###

    #
    # (arb) Arguments
    # 
    # in args =>
    #
    set arb_IN_ARGS ""
    set arb_DB_ARGS ""

    #
    # (arbn) Arguments
    # 
    # in args =>
    #
    set arbn_IN_ARGS ""
    set arbn_DB_ARGS ""

    #
    # (arg) Arguments
    # 
    # in args =>
    #
    set arg_IN_ARGS ""
    set arg_DB_ARGS ""

    #
    # (bot) Arguments
    # 
    # in args =>
    #
    set bot_IN_ARGS ""
    set bot_DB_ARGS ""

    #
    # (cline) Arguments
    # 
    # in args =>
    #
    set cline_IN_ARGS ""
    set cline_DB_ARGS ""

    #
    # (dsp) Arguments
    # 
    # in args =>
    #
    set dsp_IN_ARGS ""
    set dsp_DB_ARGS ""

    #
    # (ebm) Arguments
    # 
    # in args =>
    #
    set ebm_IN_ARGS ""
    set ebm_DB_ARGS ""

    #
    # (ehy) Arguments
    # 
    # in args =>
    #
    set ehy_IN_ARGS "0 0 0 0 0 180 75 0 0 50 80"
    set ehy_DB_ARGS "V {0 0 0} H {0 0 180} A {1 0 0} r_1 75 r_2 50 c 80"

    #
    # Ellipsoid (ell) Arguments
    #
    # in args => name type xvertex yvertex zvertex radius1 radius2 radius3
    #
    set ell_IN_ARGS "0 0 0  45 0 0  0 30 0  0 0 15"
    set ell_DB_ARGS "V { 0 0 0 } A {45 0 0} B {0 30 0} C {0 0 15}"

    #
    # Elliptical Paraboloid (epa) Arguments
    # 
    # in args =>
    #
    set epa_IN_ARGS "0 0 0  0 0 10  5 0 0 2"
    set epa_DB_ARGS "epa V {0 0 0} H {0 0 10} A {1 0 0} r_1 5 r_2 2"

    #
    # (eto) Arguments
    # 
    # in args =>
    #
    set eto_IN_ARGS "0 0 0 0 0 1 8 0 0 4 1 "
    set eto_DB_ARGS "eto V {0 0 0} N {0 0 1} C {0 0 4} r 8 r_d 1"

    #
    # (extrude) Arguments
    # 
    # in args =>
    #
    set extrude_IN_ARGS ""
    set extrude_DB_ARGS ""

    #
    # (grip) Arguments
    # 
    # in args =>
    #
    set grip_IN_ARGS ""
    set grip_DB_ARGS ""

    #
    # (half) Arguments
    # 
    # in args =>
    #
    set half_IN_ARGS ""
    set half_DB_ARGS ""

    #
    # (hf) Arguments
    # 
    # in args =>
    #
    set hf_IN_ARGS ""
    set hf_DB_ARGS ""

    #
    # (nmg) Arguments
    # 
    # in args =>
    #
    set nmg_IN_ARGS ""
    set nmg_DB_ARGS ""

    #
    # (nurb) Arguments
    # 
    # in args =>
    #
    set nurb_IN_ARGS ""
    set nurb_DB_ARGS ""

    #
    # (part) Arguments
    # 
    # in args =>
    #
    set part_IN_ARGS ""
    set part_DB_ARGS ""

    #
    # (pg) Arguments
    # 
    # in args =>
    #
    set pg_IN_ARGS ""
    set pg_DB_ARGS ""

    #
    # (pipe) Arguments
    # 
    # in args =>
    #
    set pipe_IN_ARGS "6 0 0 0 10 12 25 100 0 0 10 12 25 100 100 0 10 12 25 100 100 100 10 12 25 100 100 200 10 12 25 100 200 200 10 12 25"
    set pipe_DB_ARGS "V0 { 0 0 0 } O0 12 I0 10 R0 25 V1 { 100 0 0 } O1 12 I1 10 R1 25 V2 { 100 100 0 } O2 12 I2 10 R2 25 V3 { 100 100 100 } O3 12 I3 10 R3 25 V4 { 100 100 200 } O4 12 I4 10 R4 25 V5 { 100 200 200 } O5 12 I5 10 R5 25"

    #
    # (rec) Arguments
    # 
    # in args => xvertex yvertex zvertex xheight yheight zheight
    #            xradius1 yradius1 zradius1 xradius2 yradius2 zradius2
    #
    set rec_IN_ARGS "0 0 0  0 0 50  40 0 0  0 10 0"
    set rec_DB_ARGS "V {0 0 0} H {0 0 50} A {40 0 0} B {0 10 0} C {40 0 0} D {0 10 0}"

    #
    # (rhc) Arguments
    # 
    # in args => xvertex yvertex zvertex xheight yheight zheight 
    #            rect. half-width apex-to-asymptopes dist.
    #
    set rhc_IN_ARGS "0 0 0 0 0 100 100 0 0 10 50"
    set rhc_DB_ARGS "V {0 0 0} H {0 0 100} B {100 0 0} r 10 c 50"

    #
    # (rpc) Arguments
    # 
    # in args =>
    #
    set rpc_IN_ARGS "0 0 0  10 0 0 0 0 10 2"
    set rpc_DB_ARGS "rpc V {0 0 0} H {10 0 0} B {0 0 10} r 2"

    #
    # (sketch) Arguments
    # 
    # in args =>
    #
    set sketch_IN_ARGS ""
    set sketch_DB_ARGS ""

    #
    # Sphere (sph) Arguments
    #
    # Note that the sph is really an ell with all radii equal.
    # 
    # in args => name type xvertex yvertex zvertex radius1
    #
    set sph_IN_ARGS "0 0 0 45"
    set sph_DB_ARGS "V { 0 0 0 } A {45 0 0} B {0 45 0} C {0 0 45}"

    #
    # (submodel) Arguments
    # 
    # in args =>
    #
    set submodel_IN_ARGS ""
    set submodel_DB_ARGS ""

    #
    # (tgc) Arguments
    #
    # in args => xvertex yvertex zvertex xheight yheight zheight
    #            xradiusA yradiusA zradiusA xradiusB yradiusB zradiusB
    #            radiusC radiusD
    set tgc_IN_ARGS "0 0 0  0 0 50  40 0 0  0 10 0  20 5"
    set tgc_DB_ARGS "V {0 0 0} H {0 0 50} A {40 0 0} B {0 10 0} C {20 0 0} D {0 5 0}"
 
    #
    # Torus (tor) Arguments
    #
    # in args => name type xvertex yvertex zvertex xnormal ynormal znormal radius1 radius2
    #
    set tor_IN_ARGS "0 0 0 0 0 1 30 20"
    set tor_DB_ARGS "V { 0 0 0 } H { 1 0 0 } r_a 50 r_h 25"

    #
    # (vol) Arguments
    # 
    # in args =>
    #
    set vol_IN_ARGS ""
    set vol_DB_ARGS ""

    #
    # (xxx) Arguments
    # 
    # in args =>
    #
    set xxx_IN_ARGS ""
    set xxx_DB_ARGS ""

    #
    # Done
    ###

foreach version { 4 5 } { 

    puts "Creating v\$version database"

    set mged_default(db_version) \$version

    opendb ${TEST}.${PRIM}.\$version.g

    set autosize 0
    units mm

    Z
    viewsize 100 
    ae 35 25

    #
    # Edit 'in' args 
    #
    set inval "in ${PRIM}.in.s $PRIM $IN_ARGS"
    eval \$inval
    saveview ${TEST}.${PRIM}.\$version.in.rt

    Z
    viewsize 100 
    ae 35 25
    make ${PRIM}.make.s $PRIM
    saveview ${TEST}.${PRIM}.\$version.make.rt

    Z
    viewsize 100 
    ae 35 25
                
    #
    # Edit 'db put' args 
    #
    set dbput "db put ${PRIM}.dbput.s $PRIM $DB_ARGS"
    eval \$dbput
    saveview ${TEST}.${PRIM}.\$version.dbput.rt

    Z
    viewsize 100 
    ae 35 25
    r ${PRIM}.in.r u ${PRIM}.in.s
    # sca .5, rot 10 10 -10, tra 20 -20 20
    set putmatval "putmat ${PRIM}.in.r/${PRIM}.in.s { 0.969846 -0.17101 -0.173648 19.3442  0.200706 0.96461 0.17101 -11.8579  0.138258 -0.200706 0.969846 26.1762  0 0 0 1 }"
    eval \$putmatval

    push ${PRIM}.in.r
    shader ${PRIM}.in.r {checker {s 4}}

    Z
    viewsize 100 
    ae 35 25
    e ${PRIM}.in.r
    saveview ${TEST}.${PRIM}.\$version.trans.rt
} 

q

#
# End MGED script
#

EOF

    for version in $VER ; do
        log "Testing v$version database"
        if [ -f ${TEST}.${PRIM}.${version}.g ] ; then

            [ -f ./${TEST}.${PRIM}.${version}.in.rt ] && ./${TEST}.${PRIM}.${version}.in.rt
            [ -f ./${TEST}.${PRIM}.${version}.make.rt ] && ./${TEST}.${PRIM}.${version}.make.rt
            [ -f ./${TEST}.${PRIM}.${version}.dbput.rt ] && ./${TEST}.${PRIM}.${version}.dbput.rt
            [ -f ./${TEST}.${PRIM}.${version}.trans.rt ] && ./${TEST}.${PRIM}.${version}.trans.rt
            log "	Done raytracing"
        
            log "	Converting to ascii (g2asc)"
            g2asc ${TEST}.${PRIM}.${version}.g ${TEST}.${PRIM}.asc
            log "	Converting to binary (asc2g)"
            asc2g ${TEST}.${PRIM}.asc ${TEST}.${PRIM}.${version}.asc2g.g
            log "	Database diffing (g_diff)"
            g_diff -f ${TEST}.${PRIM}.${version}.asc2g.g ${TEST}.${PRIM}.5.g
        else
            bomb "No v$version database was created"
        fi
        log "Done testing $version database"

    done  
    # end loop over vers

    fi
    # end of test if primitive has values set

done  
# end loop over primitives


    return 0
}

stop ( ) {
    bomb "stop unimplemented"
    return 0
}

status ( ) {
    bomb "status unimplemented"
    return 0
}


case "$1" in
    start )
        start
        ;;
    stop )
        stop
        ;;
    restart )
        stop
        start
        ;;
    status )
        status
        ;;
    * )
        log "Usage: $0 {start|stop|restart|status}"
        exit 1
esac

exit $?

