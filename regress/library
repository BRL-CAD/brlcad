#!/bin/sh
#
# library
#   is a general purpose sh utility library providing a set of environment
#   variables and function calls.  the primary intended usage is to aid the
#   brlcad regression testing suite.
#
###
#
# FUNCTIONS
#
#   initializeVariable
#       initializes a given variable to a defaultValue if it is not already set
#   getHostName
#       sets a var to the HOSTNAME from a variety of potential methods
#   log
#       writes output to a given log file
#   acquireLock
#       gets a file semaphore (!!! needs to be changed)
#   releaseLock
#       releases and creates a file semaphore that may be acquired
#   acquireSemaphore
#       !!!
#   releaseSemaphore
#       !!!
#
###
#
# GLOBALS
# 
#   LOG
#       output is sent to $LOG, and is /dev/tty by default
#   DEBUG  
#       when defined, extra call details will be sent to $LOG.
#       that means define DEBUG if you're modifying scripts for extra info
#   HOSTNAME
#       the host name derifed from 1) hostname command, 2) HOST env var,
#       3) HOSTNAME env var, 4) default "unknown" value
#   PWD
#       current working directory path where library is included
#
###############################################################################

# have to init LOG here so functions will output properly
if [ x$LOG = x ] ; then 
    LOG="/dev/tty" ; export LOG
fi
if [ ! x$DEBUG = x ]  ; then echo "LOG=$LOG" ; fi
#
# log [messageToWrite] [fileToWriteTo]
#
# log writes a given message out to a file name
#
log ( ) {
# for gratuitous logging...
#    if [ ! x$DEBUG = x ] ; then echo "log( \$1=[$1] \$2=[$2] )" >> $LOG ; fi

    MESSAGE="\$1"
    if [ "x$2" = "x" ] ; then FILE="$LOG" ; else FILE="$2" ; fi

    # check for explicit escape option support
    # try to find a decent echo with -e support
    LOGTEST=`echo -e "\t\ntest"`
    if [ `echo $LOGTEST | awk '{print $1}'` = "test" ] ; then
	ECHO="echo -e"

    # no -e support
    else 
	# need to do some extra checking since the sun5 /bin/echo sucks
	# see if default echo supports special chars
	LOGTEST=`echo "\t\ntest"`
	if [ "x`echo $LOGTEST | awk '{print $1}'`" = "xtest" ] ; then 
	    ECHO="echo"
	else
	    # for sun5 (built-in echo is poor)
	    LOGTEST=`/usr/bin/echo "\t\ntest"`
	    if [ "x`echo $LOGTEST | awk '{print $1}'`" = "xtest" ] ; then
		ECHO="/usr/bin/echo"
	    else
		echo "WARNING: cannot find decent echo"
		ECHO="echo"
	    fi
	fi
    fi

# for gratuitous logging...
#    if [ ! x$DEBUG = x ] ; then echo "log: ECHO=[${ECHO}] MESSAGE=[${MESSAGE}] FILE=[${FILE}]" >> $LOG ; fi

#    OUTPUT="$ECHO \"$MESSAGE\""
#    eval "$OUTPUT >> $FILE"
    eval "$ECHO \"$MESSAGE\" >> $FILE"
}


#
# initializeVariable variableName [defaultValue]
#
# initializes a variable to a given value unless that variable
# is already defined (e.g. already initialized).  this allows
# script variables to also be overridden by environment variables
#
initializeVariable ( ) {
    if [ ! x$DEBUG = x ] ; then log "initializeVariable( \$1=[$1] \$2=[$2] )" ; fi

    if [ x$1 = x ] ; then 
	log "initializeVariable: arg1 mismatch -- no variable name given"
	exit 
    else 
	VAR="$1"
    fi
    # do not need to check since may be empty anyways
    DEF="$2"

    # stupid name to variable translation is a bitch..especially on sun5

    # make sure a value is not already set for the variable being initialized
    PVAR="echo \$$VAR"
    if [ x`eval $PVAR` = x ] ; then
	CMD="$VAR=\"$DEF\""
	eval $CMD
	export $VAR
    fi

    if [ ! x$DEBUG = x ] ; then log "initializeVariable: $VAR=[`eval $PVAR`]" ; fi
}


#
# getHostName [variable] [defaultValue]
#
# attempts to derive the host name of the running machine.
# precedence is given to the HOSTNAME and HOST environment
# variables, then we try uname.  by default we set to
# the HOSTNAME environment variable
#
# returns the host name set
#
getHostName ( ) {
    if [ ! x$DEBUG = x ] ; then log "getHostName( \$1=[${1}] \$2=[${2}] )" ; fi

    if [ x$1 = x ] ; then 
	VAR="HOSTNAME"
    else 
	VAR="$1"
	# do not forget to check system
	initializeVariable $VAR "$HOST"
	if [ x$VAR = x ] ; then export $VAR="$HOSTNAME" ; fi
    fi
    if [ x$2 = x ] ; then DEFVAL="unknown" ; else DEFVAL="$2" ; fi

    # multiple inits work (without the ifthen mess) since the set should
    # not clobber a variable that already has a non-empty value set
    if [ ! x$VAR = x ] ; then initializeVariable $VAR `hostname` ; fi
    if [ ! x$VAR = x ] ; then initializeVariable $VAR $HOST ; fi
    if [ ! x$VAR = x ] ; then initializeVariable $VAR `uname -n` ; fi
    if [ ! x$VAR = x ] ; then initializeVariable $VAR $DEFVAL ; fi

    VARVAL="echo \$$VAR"
    if [ ! x$DEBUG = x ] ; then log "getHostName: ${VAR}=[`eval $VARVAL`]" ; fi

    # return value is only useful if DEBUG is off (since echo'd values are return values)
    # return `eval $VARVAL`
}


#
# acquireLock [lockFile] [retryCount] [waitLength]
#
acquireLock ( ) {
    if [ ! x$DEBUG = x ] ; then log "acquireLock( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi

    if [ x$1 = x ] ; then LOCK="local.lock" ; else LOCK="$1" ; fi
    if [ x$2 = x ] ; then RETRY="1" ; else RETRY="$2" ; fi
    if [ x$3 = x ] ; then WAIT="0" ; else WAIT="$3" ; fi

    while [ ! -f $LOCK ] ; do
	RETRY=`expr $RETRY - 1`
	if [ $RETRY -lt 1 ] ; then
	    log "ERROR: Unable to obtain $LOCK"
	    return 1
	fi
	log "Waiting for $LOCK... $RETRY attempts remain"
	sleep $WAIT
    done
    rm $LOCK
    log "Acquired $LOCK"

    return 0
}


#
# releaseLock [lockFile]
#
releaseLock ( ) {
    if [ ! x$DEBUG = x ] ; then log "releaseLock( \$1=[$1] )" ; fi

    if [ x$1 = x ] ; then LOCK="local.lock" ; else LOCK="$1" ; fi
    if [ -f $LOCK ] ; then
	log "WARNING: Lock [$LOCK] is already released"
	return 1
    fi
    touch $LOCK
    log "Released $LOCK"
    return 0
}

#
# mail {addressList} [subject] [body]
#
# mailer sends out a mail message with a given subject and given body to an address list
# addressList is required only if USER is not set
###
mail ( ) {
    if [ ! x$DEBUG = x ] ; then log "mail( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi

    if [ "x$1" = x ] ; then 
	if [ ! "x$USER" = x ] ; then
	    ADDRESS="$USER"
	else
	    log "mail: arg1 mismatch -- no e-mail address given, no USER set"
	    exit
	fi
    else
	ADDRESS="$1"
    fi
    if [ "x$2" = x ] ; then SUBJECT="" ; else SUBJECT="$2" ; fi
    if [ "x$3" = x ] ; then BODY="" ; else BODY=`echo $3` ; fi
    if [ "x$MAILER" = x ] ; then 
	MAILER=""
	for MAILER in /bin/mail /usr/bin/mail ; do
	    if [ -f $MAILER ] && [ -x $MAILER ] ; then
		break
	    fi
	done
    fi

    if [ ! x$DEBUG = x ] ; then log "mail: MAILER=[$MAILER] ADDRESS=[$ADDRESS] SUBJECT=[$SUBJECT]" ; fi

    # !!! should test validity of mail program existance

    MAILRUN="$MAILER -s \"$SUBJECT\" $ADDRESS"
    
    $MAILER -s "$SUBJECT" $ADDRESS <<EOF
$BODY 
EOF

    if [ $? != 0 ] ; then
	log "ERROR: mail failed"
    fi
}

# GLOBAL STUFF
# get a hostname and pwd to play with -- exports HOSTNAME and PWD accordingly
getHostName
initializeVariable PWD `pwd`
