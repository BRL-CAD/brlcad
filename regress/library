#!/bin/sh
#
# l i b r a r y
#
###
#   this is a general purpose sh utility library providing a set of environment
#   variables and function calls.  the primary intended usage is to aid the
#   brlcad regression testing suite.
#
#   do not copy the routines found here.  instead, include this library into
#   scripts as such:
#
#     . ./library
#
#   listed below are the functions and variables that are provided by sourcing
#   this script.  see the respective function for more details on what 
#   arguments it takes and how the function behaves.
#
###
#
# FUNCTIONS
#
#   initializeVariable
#       initializes a given variable to a defaultValue if it is not already set
#   setHostName
#       sets a var to the HOSTNAME from a variety of potential methods
#
#   log
#       writes output to a given log file
#   bomb
#       writes an error message to the log
#   warn
#       writes a warning message to the log, optionally bombing
#
#   acquireLock
#       creates a cooperative lock file ("blocks" when one already exists)
#   releaseLock
#       releases and/or removes a cooperative lock file (rm's the lock)
#   releaseAllLocks
#       releases all acquired locks (via internal _ACQUIRED_LOCKS)
#
#   acquireSemaphore
#       gets a cooperative file semaphore ("blocks" when one does not exist)
#   releaseSemaphore
#       releases and/or creates a cooperative file semaphore (touch's the 
#       semaphore)
#   releaseAllSemaphores
#       releases all acquired semaphores (via internal _ACQUIRED_SEMAPHORES)
#
###
#
# GLOBALS
# 
#   LOG
#       output is sent to $LOG, and is /dev/tty by default
#   DEBUG  
#       when defined, extra call details will be sent to $LOG.
#       that means define DEBUG if you're modifying scripts for extra info
#   HOSTNAME
#       the host name derifed from 1) hostname command, 2) HOST env var,
#       3) HOSTNAME env var, 4) default "unknown" value
#   LPWD
#       current working directory path where library is included
#
# INTERNAL  (do not use)
#
#   _ACQUIRED_LOCKS
#   _ACQUIRED_SEMAPHORES
#   _TEMP_DEBUG_OFF
#
###############################################################################

# have to init LOG here so functions will output properly
# common log defaults include /dev/tty, stdout, or stderr
if [ x$LOG = x ] ; then 
    LOG="stdout" ; export LOG
fi
#
# log [messageToWrite] [fileToWriteTo]
#
# log writes a given message out to a file name
# log should *never* call the inherited warn() or bomb() calls
#
log ( ) {
    MESSAGE="\$1"
    if [ "x$2" = "x" ] ; then FILE="$LOG" ; else FILE="$2" ; fi

    # convert stdout and stderr to the proper redirect
    if [ "x$FILE" = "xstdout" ] ; then 
	FILE=""
    elif [ "x$FILE" = "xstderr" ] ; then 
	FILE="1>&2"
    else
	FILE=">> $FILE"
    fi

    # this is the only call that sends debug after initialization since we want
    # to properly handle a "std???" set LOG var
    if [ x$_TEMP_DEBUG_OFF = x ] ; then
	# for gratuitous logging...
	if [ ! "x$DEBUG" = x ] ; then echo "log( \$1=[$1] \$2=[$2] )" $FILE ; fi
    fi


    # check for explicit escape option support
    # try to find a decent echo with -e support
    LOGTEST=`echo -e "\t\ntest"`
    if [ `echo $LOGTEST | awk '{print $1}'` = "test" ] ; then
	ECHO="echo -e"

    # no -e support
    else
	# need to do some extra checking since the sun5 /bin/echo sucks
	# see if default echo supports special chars
	LOGTEST=`echo "\t\ntest"`
	if [ "x`echo $LOGTEST | awk '{print $1}'`" = "xtest" ] ; then 
	    ECHO="echo"
	else
	    # for sun5 (built-in echo is poor)
	    LOGTEST=`/usr/bin/echo "\t\ntest"`
	    if [ "x`echo $LOGTEST | awk '{print $1}'`" = "xtest" ] ; then
		ECHO="/usr/bin/echo"
	    else
		echo "WARNING: cannot find decent echo"
		ECHO="echo"
	    fi
	fi
    fi

# for gratuitous logging...
#    if [ ! x$DEBUG = x ] ; then echo "log: ECHO=[${ECHO}] MESSAGE=[${MESSAGE}] FILE=[${FILE}]" >> $LOG ; fi

#    OUTPUT="$ECHO \"$MESSAGE\""
#    eval "$OUTPUT >> $FILE"
#    eval "$ECHO \"$MESSAGE\" >> $FILE"
    eval "$ECHO \"$MESSAGE\" $FILE"
}
# log the LOG var
if [ ! "x$DEBUG" = "x" ]  ; then log "LOG=$LOG" ; fi


#
# bomb [messageToWrite] [fileToWriteTo] [returnCode]
#
# writes a message out via the log facility and then exits returning a given 
# value. if the global _ACQUIRED_LOCKS or _ACQUIRED_SEMAPHORES variables are
# set (done by acquireLock() and acquireSemaphore()), then they are released
# prior to exiting.
#
# by default we write bomb output to stderr instead of stdout
# 
bomb ( ) {
    if [ x$_TEMP_DEBUG_OFF = x ] ; then
        if [ ! "x$DEBUG" = x ] ; then log "bomb( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi
    fi

    if [ "x$2" = "x" ] ; then BOMBLOG="$2" ; else BOMBLOG="$2" ; fi

    # need a check if dollar three is a number...
    if [ "x$3" = "x" ] ; then CODE=1 ; else CODE="$3" ; fi

    # turn off log debugging
    if [ ! "x$DEBUG" = x ] ; then export _TEMP_DEBUG_OFF=1 ; fi

    log "ERROR: $1" "$BOMBLOG"
    # explicitly display the error message to terminal if logging elsewhere
    # !!! may consider switching default behaviour to be stdout instead of terminal
    if [ ! "x$BOMBLOG" = "x/dev/tty" ] ; then 
	if [ "x$BOMBLOG" = "x" ] ; then
	    if [ ! "x$LOG" = "x/def/tty" ] ; then
		if [ -w /dev/tty ] ; then
		    log "ERROR: $1" "/dev/tty"
		fi
	    fi
	fi
    fi

    # turn log debugging back on if it was
    if [ ! "x$DEBUG" = x ] ; then unset _TEMP_DEBUG_OFF ; fi

    releaseAllLocks
    releaseAllSemaphores
    
    exit $CODE
}


#
# warn [messageToWrite] [fileToWriteTo] [noWarnings]
#
# writes a message out via the log facility and optionally will bomb instead of
# simply warn if NO_WARNINGS is set or specified, noWarnings arg overrides 
# (any non-zero value is true)
# 
# by default we write warn output to stderr instead of stdout
#
warn ( ) {
    if [ x$_TEMP_DEBUG_OFF = x ] ; then
        if [ ! "x$DEBUG" = x ] ; then log "warn( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi
    fi

    if [ "x$2" = "x" ] ; then WARNLOG="$2" ; else WARNLOG="$2" ; fi

    # should check if dollar three is a number...
    BOMB=0
    if [ ! x$NO_WARNINGS = x ] ; then BOMB=$NO_WARNINGS ; fi
    if [ ! "x$3" = "x" ] ; then BOMB=1 ; fi

    # turn off log debugging
    if [ ! "x$DEBUG" = x ] ; then export _TEMP_DEBUG_OFF=1 ; fi

    log "WARNING: $1" "$WARN"
    if [ ! "x$BOMB" = "x0" ] ; then
	bomb "fail on warnings is set so exiting now"
    fi

    # turn log debugging back on if it was
    if [ ! "x$DEBUG" = x ] ; then unset _TEMP_DEBUG_OFF ; fi
}


#
# initializeVariable variableName [defaultValue]
#
# initializes a variable to a given value unless that variable
# is already defined (e.g. already initialized).  this allows
# script variables to also be overridden by environment variables
#
initializeVariable ( ) {
    if [ ! "x$DEBUG" = "x" ] ; then log "initializeVariable( \$1=[$1] \$2=[$2] )" ; fi

    if [ "x$1" = "x" ] ; then 
	bomb "initializeVariable arg1 mismatch"
    else 
	VAR="$1"
    fi
    # do not need to check since may be empty anyways
    DEF="$2"

    # stupid name to variable translation is a bitch..especially on sun5

    # make sure a value is not already set for the variable being initialized
    PVAR="echo \$$VAR"
    if [ x`eval $PVAR` = x ] ; then
	CMD="$VAR=\"$DEF\""
	eval $CMD
	export $VAR
    fi

    if [ ! x$DEBUG = x ] ; then log "initializeVariable: $VAR=[`eval $PVAR`]" ; fi
}


#
# setHostName [variable] [defaultValue]
#
# attempts to derive the host name of the running machine.
# precedence is given to the HOSTNAME and HOST environment
# variables, then we try uname.  by default we set to
# the HOSTNAME environment variable
#
# returns the host name set
#
setHostName ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "setHostName( \$1=[${1}] \$2=[${2}] )" ; fi

    if [ "x$1" = x ] ; then 
	VAR="HOSTNAME"
    else 
	VAR="$1"
	# do not forget to check system
	initializeVariable $VAR "$HOST"
	if [ x$VAR = x ] ; then export $VAR=$HOSTNAME ; fi
    fi
    if [ "x$2" = x ] ; then DEFVAL="unknown" ; else DEFVAL=$2 ; fi

    VARVAL="echo \$$VAR"
    if [ ! "x$DEBUG" = x ] ; then log "setHostName: ${VAR}=[`eval $VARVAL`]" ; fi

    # multiple inits work (without the ifthen mess) since the set should
    # not clobber a variable that already has a non-empty value set
    if [ x`eval $VARVAL` = x ] ; then initializeVariable $VAR `hostname` ; fi
    if [ x`eval $VARVAL` = x ] ; then initializeVariable $VAR $HOST ; fi
    if [ x`eval $VARVAL` = x ] ; then initializeVariable $VAR `uname -n` ; fi
    if [ x`eval $VARVAL` = x ] ; then initializeVariable $VAR $DEFVAL ; fi

    # return value is only useful if DEBUG is off (since echo'd values are return values)
    if [ "x$DEBUG" = "x" ] ; then return "$VARVAL" ; fi
}

#
# acquireLock [lockName] [retryCount] [waitLength] [location]
#
# will create a file that will block subsequent calls to acquireLock until the 
# file lock is released.  a ".lock" extension is appended automatically to 
# distinguish between file locks and file semaphores.
# locks acquired are listed in the ACQUIRED_LOCKS global var
#
# if file exists then wait/fail
# else create lock file and log
#
acquireLock ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "acquireLock( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4] )" ; fi

    if [ "x$1" = x ] ; then NAME="local" ; else NAME="${1}" ; fi
    if [ "x$2" = x ] ; then RETRY=1 ; else RETRY=$2 ; fi
    if [ "x$3" = x ] ; then WAIT=0 ; else WAIT=$3 ; fi
    if [ "x$4" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then PREFIX="" ; else PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then PREFIX="$4" ; else PREFIX="${4}/" ; fi
    fi
    LOCK="${NAME}.lock"

    while [ -f ${PREFIX}$LOCK ] ; do
	RETRY=`expr $RETRY - 1`
	if [ $RETRY -lt 1 ] ; then
	    warn "Unable to obtain $LOCK in $PREFIX"
	    return 1
	fi
	log "Waiting for $LOCK ($WAIT seconds)... $RETRY attempts remain"
	sleep $WAIT
    done
    touch ${PREFIX}$LOCK
    if [ ! -w ${PREFIX}$LOCK ] ; then
        warn "Unable to write to lock file $LOCK in ${PREFIX}?"
    fi
    # save the PID of the acquiring process to the lock file
    log "PID: $$" "${PREFIX}$LOCK"
    # keep a list of the acquired locks up to date
    export _ACQUIRED_LOCKS="$_ACQUIRED_LOCKS ${PREFIX}$NAME"
    log "Acquired $LOCK"

    return 0
}


#
# releaseLock [lockName] [location]
#
# if file exists then remove and try unlog
# else warn and try unlog
#
releaseLock ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseLock( \$1=[$1] \$2=[$2] )" ; fi

    if [ "x$1" = x ] ; then NAME="local" ; else NAME="${1}" ; fi
    if [ "x$2" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ ! "x$DEBUG" = x ] ; then log "releaseLock: SWS=[$SWS]" ; fi
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then PREFIX="" ; else PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then PREFIX="$2" ; else PREFIX="${2}/" ; fi
    fi
    LOCK="${NAME}.lock"

    if [ ! "x$DEBUG" = x ] ; then log "releaseLock: PREFIX=[$PREFIX] LOCK=[$LOCK]" ; fi

    if [ ! -f "${PREFIX}$LOCK" ] ; then
	warn "Lock [$LOCK] is already released"
	# make sure the lock is not registered 
	if [ ! "x$_ACQUIRED_LOCKS" = "x" ] ; then
	    NEW_AL=""
	    for CL in $_ACQUIRED_LOCKS ; do
		if [ ! "x$CL" = "x${PREFIX}$NAME" ] ; then
		    NEW_AL="$NEW_AL $CL"
		fi
	    done
	    export _ACQUIRED_LOCKS="$NEW_AL"
	fi
	return 1
    fi
    rm ${PREFIX}$LOCK
    # unregister the lock with the _ACQUIRED_LOCKS var
    if [ ! "x$_ACQUIRED_LOCKS" = "x" ] ; then
	NEW_AL=""
	FOUND_LOCK=0
	for CL in $_ACQUIRED_LOCKS ; do
	    if [ "x$CL" = "x${PREFIX}$NAME" ] ; then
		FOUND_LOCK=1
	    else
		NEW_AL="$NEW_AL $CL"
	    fi
	done
	if [ x$FOUND_LOCK = x0 ] ; then
	    warn "bad bookkeeping -- _ACQUIRED_LOCKS is missing entry $NAME"
	fi
	export _ACQUIRED_LOCKS="$NEW_AL"
    else
	warn "bad bookkeeping -- _ACQUIRED_LOCKS is empty prior to a release of $NAME"
    fi
    log "Released $LOCK"
    return 0
}

#
# releaseAllLocks
#
releaseAllLocks ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseAllLocks() _ACQUIRED_LOCKS=[$_ACQUIRED_LOCKS]" ; fi

    if [ ! "x$_ACQUIRED_LOCKS" = x ] ; then
	for LOCK in $_ACQUIRED_LOCKS ; do
	    releaseLock $LOCK
	done
    fi
}

#
# acquireSemaphore [semaphoreName] [retryCount] [waitLength] [location]
#
# if file exists then remove file and log
# else wait/fail
#
acquireSemaphore ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "acquireSemaphore( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4] )" ; fi

    if [ "x$1" = x ] ; then NAME="local" ; else NAME="${1}" ; fi
    if [ "x$2" = x ] ; then RETRY=1 ; else RETRY=$2 ; fi
    if [ "x$3" = x ] ; then WAIT=0 ; else WAIT=$3 ; fi
    if [ "x$4" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then PREFIX="" ; else PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then PREFIX="$4" ; else PREFIX="${4}/" ; fi
    fi
    SEMAPHORE="${NAME}.semaphore"

    while [ ! -f ${PREFIX}$SEMAPHORE ] ; do
	RETRY=`expr $RETRY - 1`
	if [ $RETRY -lt 1 ] ; then
	    warn "Unable to obtain $SEMAPHORE in $PREFIX"
	    return 1
	fi
	log "Waiting for $SEMAPHORE ($WAIT seconds)... $RETRY attempts remain"
	sleep $WAIT
    done
    # we move instead of delete so that we can tell who has acquired the semaphore
    cp -f "${PREFIX}${SEMAPHORE}" "${PREFIX}${SEMAPHORE}.acquired"
    if [ ! -w ${PREFIX}${SEMAPHORE} ] ; then
        warn "Unable to write to semaphore file $SEMAPHORE in ${PREFIX}?"
    fi    
    log "HOLDING PID: $$" "${PREFIX}${SEMAPHORE}.acquired"
    export _ACQUIRED_SEMAPHORES="$_ACQUIRED_SEMAPHORES ${PREFIX}$NAME"
    log "Acquired $SEMAPHORE"

    return 0
}


#
# releaseSemaphore [semaphoreName]
#
# if file exists then warn and try unlog
# else create file and try unlog
#
releaseSemaphore ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseSemaphore( \$1=[$1] \$2=[$2] )" ; fi

    if [ "x$1" = x ] ; then NAME="local" ; else NAME="${1}" ; fi
    if [ "x$2" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	SWS=`echo $NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$SWS" = "x___ROOTED_NAME___" ] ; then PREFIX="" ; else PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	SWS=`echo $NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$SWS" = "x___END_SLASH___" ] ; then PREFIX="$2" ; else PREFIX="${2}/" ; fi
    fi
    SEMAPHORE="${NAME}.semaphore"

    if [ -f ${PREFIX}$SEMAPHORE ] ; then
	warn "Semaphore [$SEMAPHORE] is already released"
    fi

    # recreate the semaphore and remove the .acquired copy
    touch ${PREFIX}$SEMAPHORE

    if [ ! -w ${PREFIX}$SEMAPHORE ] ; then
        warn "Unable to write to semaphore file $SEMAPHORE in ${PREFIX}?"
    fi
    # save the PID of the process that last released this semaphore
    log "RELEASEOR PID: $$" "${PREFIX}${SEMAPHORE}"
    # unregister the semaphore with the _ACQUIRED_SEMAPHORES var
    if [ ! "x$_ACQUIRED_SEMAPHORES" = "x" ] ; then
	NEW_AS=""
	FOUND_SEM=0
	for SEM in $_ACQUIRED_SEMAPHORES ; do
	    if [ "x$SEM" = "x${PREFIX}$NAME" ] ; then
		FOUND_SEM=1
	    else
		NEW_AS="$NEW_AS $SEM"
	    fi
	done
	export _ACQUIRED_SEMAPHORES="$NEW_AS"

	if [ x$FOUND_SEM = x0 ] ; then
	    warn "bad bookkeeping -- _ACQUIRED_SEMAPHORES is missing entry $NAME"
	else
	    # if the file was properly registered, it should have a backup copy
	    if [ ! -f ${PREFIX}${SEMAPHORE}.acquired ] ; then
		warn "Acquired semaphore ${SEMAPHORE}'s backup copy disappeared in $PREFIX"
	    fi
	fi
	if [ ! -f ${PREFIX}${SEMAPHORE}.acquired ] ; then
	    rm ${PREFIX}${SEMAPHORE}.acquired
	fi
	log "Released $SEMAPHORE"
    else
	log "Created $SEMAPHORE"
    fi
    return 0
}

#
# releaseAllSemaphores
#
releaseAllSemaphores ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseAllSemaphores() _ACQUIRED_SEMAPHORES=[$_ACQUIRED_SEMAPHORES]" ; fi

    if [ ! "x$_ACQUIRED_SEMAPHORES" = x ] ; then
	for SEM in $_ACQUIRED_SEMAPHORES ; do
	    releaseSemaphore $SEM
	done
    fi
}


#
# mail {addressList} [subject] [body]
#
# mailer sends out a mail message with a given subject and given body to an address list
# addressList is required only if USER is not set
###
mail ( ) {
    if [ ! "x$DEBUG" = "x" ] ; then log "mail( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi

    if [ "x$1" = x ] ; then 
	if [ ! "x$USER" = x ] ; then
	    ADDRESS="$USER"
	else
	    log "mail: arg1 mismatch -- no e-mail address given, no USER set"
	    exit
	fi
    else
	ADDRESS="$1"
    fi
    if [ "x$2" = x ] ; then SUBJECT="" ; else SUBJECT="$2" ; fi
    if [ "x$3" = x ] ; then BODY="" ; else BODY=`echo $3` ; fi
    if [ "x$MAILER" = x ] ; then 
	MAILER=""
	for MAILER in /bin/mail /usr/bin/mail ; do
	    if [ -f $MAILER ] && [ -x $MAILER ] ; then
		break
	    fi
	done
    fi

    if [ ! "x$DEBUG" = "x" ] ; then log "mail: MAILER=[$MAILER] ADDRESS=[$ADDRESS] SUBJECT=[$SUBJECT]" ; fi

    # !!! should test validity of mail program existance

    MAILRUN="$MAILER -s \"$SUBJECT\" $ADDRESS"
    
    $MAILER -s "$SUBJECT" $ADDRESS <<EOF
$BODY 
EOF

    if [ $? != 0 ] ; then
	log "ERROR: mail failed"
    fi
}

# INTERNAL STUFF
###
# vars used to manage locks and semaphores
initializeVariable _ACQUIRED_LOCKS 
initializeVariable _ACQUIRED_SEMAPHORES

# GLOBAL STUFF
# set a hostname and pwd to play with -- exports HOSTNAME and LPWD accordingly
setHostName
initializeVariable LPWD `pwd`
