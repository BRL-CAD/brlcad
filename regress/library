#!/bin/sh
#
# l i b r a r y
#
###
#   this is a general purpose sh utility library providing a set of environment
#   variables and function calls.  the primary intended usage is to aid the
#   brlcad regression testing suite.
#
#   do not copy the routines found here.  instead, include this library into
#   scripts as such:
#
#     . ./library
#
#   listed below are the functions and variables that are provided by sourcing
#   this script.  see the respective function for more details on what 
#   arguments it takes and how the function behaves.
#
###
#
# FUNCTIONS
#
#   log
#       writes output to a given log file
#   plog
#       writes "pretty" output to a given log file in column format
#   bomb
#       writes an error message to the log
#   warn
#       writes a warning message to the log, optionally bombing
#
#   initializeVariable
#       initializes a given variable to a defaultValue if it is not already set
#   setHostName
#       sets a var to the HOSTNAME from a variety of potential methods
#   hostIsAlive
#       returns a boolean whether the given host/ip is alive (answers ping)
#   loadSourceFile
#       loads the requested file and evaluates the contents as script source
#
#   acquireLock
#       creates a cooperative lock file ("blocks" when one already exists)
#   releaseLock
#       releases and/or removes a cooperative lock file (rm's the lock)
#   releaseAllLocks
#       releases all locally acquired locks (via internal _ACQUIRED_LOCKS)
#
#   acquireSemaphore
#       gets a cooperative file semaphore ("blocks" when one does not exist)
#   releaseSemaphore
#       releases and/or creates a cooperative file semaphore (touch's the 
#       semaphore)
#   releaseAllSemaphores
#       releases all locally acquired semaphores (via internal 
#       _ACQUIRED_SEMAPHORES)
#
#   mail
#       mail a file with optional attachments to a user
#   cvsExport
#       perform a cvs export for given source tag
#   unpackArchive
#       unpack an archive in a variety of formats (tar files, tgz, zip, etc)
#
###
#
# GLOBALS
# 
#   LOG
#       output is sent to $LOG, and is /dev/tty by default
#   DEBUG  
#       when non-null defined, extra call details will be sent to $LOG.
#       that means define DEBUG if you're modifying scripts for extra info
#   HOSTNAME
#       the host name derifed from 1) hostname command, 2) HOST env var,
#       3) HOSTNAME env var, 4) default "unknown" value
#   ARCH
#       the complete architecture definition of this client as given by uname
#   LPWD
#       current working directory path where library is included
#
#   STYLE
#       set to color to take advantage of a terminal that supports
#       color output (though ansi escape sequences)
#   SETCOLOR_SUCCESS
#       set output color for a success statement
#   SETCOLOR_FAILURE
#       set output color for a failure statement
#   SETCOLOR_WARNING
#       set output color for a warning statement
#   SETCOLOR_NORMAL
#       set output color for a normal statement
#
#   LIBRARY_VERSION
#       version of this library file being used (majorRelease.minorRelease)
#   
#
# INTERNAL  (do not use)
#
#   _ACQUIRED_LOCKS
#   _ACQUIRED_SEMAPHORES
#   _TEMP_DEBUG_OFF
#
###############################################################################

# version of this library script file
LIBRARY_VERSION=1.0 ; export LIBRARY_VERSION

# have to init LOG here so functions will output properly
# common log defaults include /dev/tty, stdout, or stderr
if [ x$LOG = x ] ; then 
    LOG="stdout" ; export LOG
fi
#
# log [messageToWrite] [fileToWriteTo]
#
# log writes a given message out to a file name
# log should *never* call the inherited warn() or bomb() calls
#
log ( ) {
    __MESSAGE="\$1"
    if [ "x$2" = "x" ] ; then __FILE="$LOG" ; else __FILE="$2" ; fi

    # convert stdout and stderr to the proper redirect
    if [ "x$__FILE" = "xstdout" ] ; then 
	__FILE=""
    elif [ "x$__FILE" = "xstderr" ] ; then 
	__FILE="1>&2"
    else
	__FILE=">> $__FILE"
    fi

    # this is the only call that sends debug after initialization since we want
    # to properly handle a "std???" set LOG var
    if [ x$_TEMP_DEBUG_OFF = x ] ; then
	# for gratuitous logging...
	if [ ! "x$DEBUG" = x ] ; then echo "log( \$1=[$1] \$2=[$2] )" $__FILE ; fi
    fi


    # check for explicit escape option support
    # try to find a decent echo with -e support
    __LOGTEST=`echo -e "\t\ntest"`
    if [ `echo $__LOGTEST | awk '{print $1}'` = "test" ] ; then
	__ECHO="echo -e"
    # no -e support
    else
	# need to do some extra checking since the sun5 /bin/echo sucks
	# see if default echo supports special chars
	__LOGTEST=`echo "\t\ntest"`
	if [ "x`echo $__LOGTEST | awk '{print $1}'`" = "xtest" ] ; then 
	    __ECHO="echo"
	else
	    # for sun5 (built-in echo is poor)
	    __LOGTEST=`/usr/bin/echo "\t\ntest"`
	    if [ "x`echo $__LOGTEST | awk '{print $1}'`" = "xtest" ] ; then
		__ECHO="/usr/bin/echo"
	    else
		echo "WARNING: cannot find decent echo"
		__ECHO="echo"
	    fi
	fi
    fi

# for gratuitous logging...
#    if [ ! x$DEBUG = x ] ; then echo "log: __ECHO=[${__ECHO}] __MESSAGE=[${__MESSAGE}] __FILE=[${__FILE}]" >> $LOG ; fi

    eval "$__ECHO \"$__MESSAGE\" $__FILE"
}
# log the LOG var
if [ ! "x$DEBUG" = "x" ]  ; then log "LOG=$LOG" ; fi

#
# plog [messageToWrite] [fileToWriteTo] [columnWidth] [leadingEdge]
#
# plog "pretty writes" a given message out to a file name
# the columnWidth is the maximum length of a given column, while the
# leading edge is what kind of padding (if any) needs to go on the left
# of each line.
# plog, like log, should *never* call the inherited warn() or bomb() calls
#
plog ( ) {
    if [ "x$2" = "x" ] ; then __FILE="$LOG" ; else __FILE="$2" ; fi
    if [ "x$3" = "x" ] ; then __COLUMN="32000" ; else __COLUMN="$3" ; fi
    __LEAD="$4"

    # this is the only call that sends debug after initialization since we want
    # to properly handle a "std???" set LOG var
    if [ x$_TEMP_DEBUG_OFF = x ] ; then
	# for gratuitous logging...
	if [ ! "x$DEBUG" = x ] ; then echo "plog( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4] )" $__FILE ; fi
    fi

    # turn off log debugging
    if [ ! "x$DEBUG" = x ] ; then export _TEMP_DEBUG_OFF=1 ; fi

    __LINE=""
    __POS=0
# !!! some shells will have already expanded $1 -- need better method for handling newlines and the sort
    for __WORD in $1 ; do

# !!! see if all our systems support the -c option to wc since obviating awk will speed this up a little 
# (faster)        __SIZE="`echo $__WORD | wc -c`"

        __NEWLINE=`echo $__WORD | grep '\\\n'`
        if [ ! "x$__NEWLINE" = "x" ] ; then
            __SIZE=`expr -$__POS + -$__COLUMN`
        else
            __SIZE="`echo $__WORD | wc | awk '{print $3}'`"
            # add extra padding for a tab (!!! should convert to spaces)
            if [ ! "x`echo $__WORD | grep '\\\t'`" = "x" ] ; then
                __SIZE=`expr $__SIZE + 7`
            # add an extra space at the end of a sentance
            elif [ ! "x`echo $__WORD | grep '\\.$'`" = "x" ] ; then
                __SIZE=`expr $__SIZE + 1`
                __WORD="$__WORD "
            fi
        fi

        __NEWSIZE=`expr $__POS + $__SIZE + 1`

        if [ $__NEWSIZE -gt $__COLUMN ] ; then
            log "${__LEAD}${__LINE}" "$__FILE"
            __LINE="$__WORD"
            __POS="$__SIZE"
        elif [ $__NEWSIZE -lt 0 ] ; then
            log "${__LEAD}${__LINE} $__WORD" "$__FILE"
            __LINE=""
            __POS=0
        else
            __POS=$__NEWSIZE
            if [ "x$__LINE" = "x" ] ; then
                __LINE="$__WORD"
            else
                __LINE="${__LINE} $__WORD"
            fi
        fi
    done
    log "${__LEAD}${__LINE}" "$__FILE"

    # turn log debugging back on if it was
    if [ ! "x$DEBUG" = x ] ; then unset _TEMP_DEBUG_OFF ; fi

}


#
# bomb [messageToWrite] [fileToWriteTo] [returnCode]
#
# writes a message out via the log facility and then exits returning a given 
# value. if the global _ACQUIRED_LOCKS or _ACQUIRED_SEMAPHORES variables are
# set (done by acquireLock() and acquireSemaphore()), then they are released
# prior to exiting.
#
# by default we write bomb output to stderr instead of stdout
# 
bomb ( ) {
    if [ x$_TEMP_DEBUG_OFF = x ] ; then
        if [ ! "x$DEBUG" = x ] ; then log "bomb( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi
    fi

    if [ "x$2" = "x" ] ; then __BOMBLOG="$2" ; else __BOMBLOG="$2" ; fi

    # need a check if dollar three is a number...
    if [ "x$3" = "x" ] ; then __CODE=1 ; else __CODE="$3" ; fi

    # turn off log debugging
    if [ ! "x$DEBUG" = x ] ; then export _TEMP_DEBUG_OFF=1 ; fi

    log "ERROR: $1" "$__BOMBLOG"
    # explicitly display the error message to terminal if logging elsewhere
    # !!! may consider switching default behaviour to be stdout instead of terminal
    if [ ! "x$__BOMBLOG" = "x/dev/tty" ] ; then 
	if [ "x$__BOMBLOG" = "x" ] ; then
	    if [ ! "x$LOG" = "x/def/tty" ] ; then
		if [ -w /dev/tty ] ; then
		    log "ERROR: $1" "/dev/tty"
		fi
	    fi
	fi
    fi

    # turn log debugging back on if it was
    if [ ! "x$DEBUG" = x ] ; then unset _TEMP_DEBUG_OFF ; fi

    releaseAllLocks
    releaseAllSemaphores
    
    exit $__CODE
}


#
# warn [messageToWrite] [fileToWriteTo] [noWarnings]
#
# writes a message out via the log facility and optionally will bomb instead of
# simply warn if NO_WARNINGS is set or specified, noWarnings arg overrides 
# (any non-zero value is true)
# 
# by default we write warn output to stderr instead of stdout
#
warn ( ) {
    if [ x$_TEMP_DEBUG_OFF = x ] ; then
        if [ ! "x$DEBUG" = x ] ; then log "warn( \$1=[$1] \$2=[$2] \$3=[$3] )" ; fi
    fi

    if [ "x$2" = "x" ] ; then __WARNLOG="$2" ; else __WARNLOG="$2" ; fi

    # should check if dollar three is a number...
    __BOMB=0
    if [ ! x$NO_WARNINGS = x ] ; then __BOMB=$NO_WARNINGS ; fi
    if [ ! "x$3" = "x" ] ; then __BOMB=1 ; fi

    # turn off log debugging
    if [ ! "x$DEBUG" = x ] ; then export _TEMP_DEBUG_OFF=1 ; fi

    log "WARNING: $1" "$__WARN"
    if [ ! "x$__BOMB" = "x0" ] ; then
	bomb "fail on warnings is set so exiting now"
    fi

    # turn log debugging back on if it was
    if [ ! "x$DEBUG" = x ] ; then unset _TEMP_DEBUG_OFF ; fi
}


#
# initializeVariable variableName [defaultValue]
#
# initializes a variable to a given value unless that variable
# is already defined (e.g. already initialized).  this allows
# script variables to also be overridden by environment variables
#
initializeVariable ( ) {
    if [ ! "x$DEBUG" = "x" ] ; then log "initializeVariable( \$1=[$1] \$2=[$2] )" ; fi

    if [ "x$1" = "x" ] ; then 
	bomb "initializeVariable() arg1 mismatch"
    else 
	__VAR="$1"
    fi
    # do not need to check since may be empty anyways
    __DEF="$2"

    # stupid name to variable translation is a bitch..especially on sun5

    # make sure a value is not already set for the variable being initialized
    __PVAR="echo \$$__VAR"
    if [ x`eval $__PVAR` = x ] ; then
	__CMD="$__VAR=\"$__DEF\""
	eval $__CMD
	export $__VAR
    fi

    if [ ! x$DEBUG = x ] ; then log "initializeVariable: $__VAR=[`eval $__PVAR`]" ; fi
}


#
# setHostName [variable] [defaultValue]
#
# attempts to derive the host name of the running machine.
# precedence is given to the HOSTNAME and HOST environment
# variables, then we try uname.  by default we set to
# the HOSTNAME environment variable
#
setHostName ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "setHostName( \$1=[${1}] \$2=[${2}] )" ; fi

    if [ "x$1" = x ] ; then 
	__VAR="HOSTNAME"
    else 
	__VAR="$1"
	# do not forget to check system
	initializeVariable $__VAR "$HOST"
	if [ x$__VAR = x ] ; then $__VAR=$HOSTNAME ; export $__VAR ; fi
    fi
    if [ "x$2" = x ] ; then __DEFVAL="unknown" ; else __DEFVAL=$2 ; fi

    __VARVAL="echo \$$__VAR"
    if [ ! "x$DEBUG" = x ] ; then log "setHostName: ${__VAR}=[`eval $__VARVAL`]" ; fi

    # multiple inits work (without the ifthen mess) since the set should
    # not clobber a variable that already has a non-empty value set
    if [ x`eval $__VARVAL` = x ] ; then initializeVariable $__VAR `hostname` ; fi
    if [ x`eval $__VARVAL` = x ] ; then initializeVariable $__VAR $HOST ; fi
    if [ x`eval $__VARVAL` = x ] ; then initializeVariable $__VAR `uname -n` ; fi
    if [ x`eval $__VARVAL` = x ] ; then initializeVariable $__VAR $__DEFVAL ; fi
}

#
# hostIsAlive hostOrIP
#
# returns a boolean whether the given host or ip address is "valid" or not.
# a host is considered valid if it is responding to ping requests
#
hostIsAlive ( )  {
    if [ ! "x$DEBUG" = x ] ; then log "hostIsAlive( \$1=[${1} ) " ; fi

    if [ ! "x$1" = "x" ] ; then
        __HOST="$1"
    else 
        bomb "hostIsAlive() arg1 mismatch -- no host was given"
    fi

    if ping -c 2 $__HOST > /dev/null 2>&1 ; then
        return 0
    # handle cads odd location of ping
    elif /usr/etc/ping -c 2 $__HOST > /dev/null 2>&1 ; then
        return 0
    elif `which ping` -c 2 $__HOST > /dev/null 2>&1 ; then
        return 0
    fi

    # fail if we couldn't get a successful ping (after two tries)
    return 1
}


#
# loadResourceFile fileName
#
loadResourceFile ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "loadResourceFile( \$1=[${1} ) " ; fi

    if [ ! "x$1" = "x" ] ; then
        __FILE="$1"
    else 
        bomb "loadResourceFile() arg1 mismatch -- no file was given"
    fi

    if [ ! -f "$__FILE" ] ; then
        warn "Resource file [$__FILE] does not exist"
        return 1
    elif [ ! -r "$__FILE" ] ; then
        warn "Unable to read resource file [$__FILE]"
        return 1
    fi
    
    __RCSRC="`cat $__FILE`"
    eval $__RCSRC

    if [ $? != 0 ] ; then
        warn "Unable to properly load resource file"
        return 1
    fi

    return 0
}


#
# acquireLock [lockName] [retryCount] [waitLength] [location]
#
# will create a file that will block subsequent calls to acquireLock until the 
# file lock is released.  a ".lock" extension is appended automatically to 
# distinguish between file locks and file semaphores.
# locks acquired are listed in the ACQUIRED_LOCKS global var
#
# if file exists then wait/fail
# else create lock file and log
#
acquireLock ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "acquireLock( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4] )" ; fi

    if [ "x$1" = x ] ; then __NAME="local" ; else __NAME="${1}" ; fi
    if [ "x$2" = x ] ; then __RETRY=1 ; else __RETRY=$2 ; fi
    if [ "x$3" = x ] ; then __WAIT=0 ; else __WAIT=$3 ; fi
    if [ "x$4" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	__SWS=`echo $__NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$__SWS" = "x___ROOTED_NAME___" ] ; then __PREFIX="" ; else __PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	__SWS=`echo $__NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$__SWS" = "x___END_SLASH___" ] ; then __PREFIX="$4" ; else __PREFIX="${4}/" ; fi
    fi
    __LOCK="${__NAME}.lock"

    while [ -f ${__PREFIX}$__LOCK ] ; do
	__RETRY=`expr $__RETRY - 1`
	if [ $__RETRY -lt 1 ] ; then
	    warn "Unable to obtain $__LOCK in $__PREFIX"
            
            if [ ! "x$USER" = "x" ] ; then __USER="$USER" ; unset USER ; fi
            if [ ! "x$PID" = "x" ] ; then __PID="$USER" ; unset PID ; fi
            if [ ! "x$DATE" = "x" ] ; then __DATE="$USER" ; unset DATE ; fi
            loadResourceFile "${__PREFIX}$__LOCK"
            if [ ! "x$USER" = "x" ] ; then
                log "Timed out waiting for ${USER}'s lock held since ${DATE} (pid: $PID)"
            fi
            if [ ! "x$__USER" = "x" ] ; then USER="$__USER" ; unset __USER ; fi
            if [ ! "x$__PID" = "x" ] ; then PID="$__USER" ; unset __PID ; fi
            if [ ! "x$__DATE" = "x" ] ; then DATE="$__USER" ; unset __DATE ; fi
            
	    return 1
	fi
	log "Waiting for $__LOCK ($__WAIT seconds)... $__RETRY attempts remain"
	sleep $__WAIT
    done
    touch ${__PREFIX}$__LOCK
    if [ ! -w ${__PREFIX}$__LOCK ] ; then
        warn "Unable to write to lock file $__LOCK in ${__PREFIX}?"
    fi
    # save details about the acquiring process to the lock file
    if [ ! "x$USER" = "x" ] ; then log "USER=\"$USER\"" "${__PREFIX}$__LOCK" ; else log "USER=\"unknown\"" "${__PREFIX}$__LOCK" ; fi
    log "PID=\"$$\"" "${__PREFIX}$__LOCK"
    log "DATE=\"`date`\"" "${__PREFIX}$__LOCK"
    # keep a list of the acquired locks up to date
    _ACQUIRED_LOCKS="$_ACQUIRED_LOCKS ${__PREFIX}$__NAME" ; export _ACQUIRED_LOCKS
    log "Acquired $__LOCK"

    return 0
}


#
# releaseLock [lockName] [location]
#
# if file exists then remove and try unlog
# else warn and try unlog
#
releaseLock ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseLock( \$1=[$1] \$2=[$2] )" ; fi

    if [ "x$1" = x ] ; then __NAME="local" ; else __NAME="${1}" ; fi
    if [ "x$2" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	__SWS=`echo $__NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ ! "x$DEBUG" = x ] ; then log "releaseLock: __SWS=[$__SWS]" ; fi
	if [ "x$__SWS" = "x___ROOTED_NAME___" ] ; then __PREFIX="" ; else __PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	__SWS=`echo $__NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$__SWS" = "x___END_SLASH___" ] ; then __PREFIX="$2" ; else __PREFIX="${2}/" ; fi
    fi
    __LOCK="${__NAME}.lock"

    if [ ! "x$DEBUG" = x ] ; then log "releaseLock: __PREFIX=[$__PREFIX] __LOCK=[$__LOCK]" ; fi

    if [ ! -f "${__PREFIX}$__LOCK" ] ; then
	warn "Lock [$__LOCK] is already released"
	# make sure the lock is not registered 
	if [ ! "x$_ACQUIRED_LOCKS" = "x" ] ; then
	    __NEW_AL=""
	    for __CL in $_ACQUIRED_LOCKS ; do
		if [ ! "x$__CL" = "x${__PREFIX}$__NAME" ] ; then
		    __NEW_AL="$__NEW_AL $__CL"
		fi
	    done
	    _ACQUIRED_LOCKS="$__NEW_AL" ; export _ACQUIRED_LOCKS
	fi
	return 1
    fi
    rm ${__PREFIX}$__LOCK
    # unregister the lock with the _ACQUIRED_LOCKS var
    if [ ! "x$_ACQUIRED_LOCKS" = "x" ] ; then
	__NEW_AL=""
	__FOUND_LOCK=0
	for __CL in $_ACQUIRED_LOCKS ; do
	    if [ "x$__CL" = "x${__PREFIX}$__NAME" ] ; then
		__FOUND_LOCK=1
	    else
		__NEW_AL="$__NEW_AL $__CL"
	    fi
	done
	if [ x$__FOUND_LOCK = x0 ] ; then
	    warn "bad bookkeeping -- _ACQUIRED_LOCKS is missing entry $__NAME"
	fi
	_ACQUIRED_LOCKS="$__NEW_AL" ; export _ACQUIRED_LOCKS
    else
	warn "bad bookkeeping -- _ACQUIRED_LOCKS is empty prior to a release of $__NAME"
    fi
    log "Released $__LOCK"
    return 0
}

#
# releaseAllLocks
#
releaseAllLocks ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseAllLocks() _ACQUIRED_LOCKS=[$_ACQUIRED_LOCKS]" ; fi

    if [ ! "x$_ACQUIRED_LOCKS" = x ] ; then
	for __LOCK in $_ACQUIRED_LOCKS ; do
	    releaseLock $__LOCK
	done
    fi
}

#
# acquireSemaphore [semaphoreName] [retryCount] [waitLength] [location]
#
# if file exists then remove file and log
# else wait/fail
#
acquireSemaphore ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "acquireSemaphore( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4] )" ; fi

    if [ "x$1" = x ] ; then __NAME="local" ; else __NAME="${1}" ; fi
    if [ "x$2" = x ] ; then __RETRY=1 ; else __RETRY=$2 ; fi
    if [ "x$3" = x ] ; then __WAIT=0 ; else __WAIT=$3 ; fi
    if [ "x$4" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	__SWS=`echo $__NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$__SWS" = "x___ROOTED_NAME___" ] ; then __PREFIX="" ; else __PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	__SWS=`echo $__NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$__SWS" = "x___END_SLASH___" ] ; then __PREFIX="$4" ; else __PREFIX="${4}/" ; fi
    fi
    __SEMAPHORE="${__NAME}.semaphore"

    while [ ! -f ${__PREFIX}$__SEMAPHORE ] ; do
	__RETRY=`expr $__RETRY - 1`
	if [ $__RETRY -lt 1 ] ; then
	    warn "Unable to obtain $__SEMAPHORE in $__PREFIX"
	    return 1
	fi
	log "Waiting for $__SEMAPHORE ($__WAIT seconds)... $__RETRY attempts remain"
	sleep $__WAIT
    done
    # we move instead of delete so that we can tell who has acquired the semaphore
    mv -f "${__PREFIX}${__SEMAPHORE}" "${__PREFIX}${__SEMAPHORE}.acquired"
    if [ ! -w "${__PREFIX}${__SEMAPHORE}.acquired" ] ; then
        warn "Unable to write to acquired semaphore file ${__SEMAPHORE}.acquired in ${__PREFIX}"
    fi    
    # sanity check - make sure file is gone
    if [ -f "${__PREFIX}${__SEMAPHORE}" ] ; then
	warn "Unable to properly remove/acquire semaphore file ${__SEMAPHORE} in ${__PREFIX}"
	return 1
    fi

    if [ ! "x$USER" = "x" ] ; then log "USER=$USER" "${__PREFIX}${__SEMAPHORE}.acquired" ; else log "USER=unknown" "${__PREFIX}${__SEMAPHORE}.acquired" ; fi
    log "PID=$$" "${__PREFIX}${__SEMAPHORE}.acquired"
    log "DATE=`date`" "${__PREFIX}${__SEMAPHORE}.acquired"

    _ACQUIRED_SEMAPHORES="$_ACQUIRED_SEMAPHORES ${__PREFIX}$__NAME" ; export _ACQUIRED_SEMAPHORES
    log "Acquired $__SEMAPHORE"

    return 0
}


#
# releaseSemaphore [semaphoreName]
#
# if file exists then warn and try unlog
# else create file and try unlog
#
releaseSemaphore ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseSemaphore( \$1=[$1] \$2=[$2] )" ; fi

    if [ "x$1" = x ] ; then __NAME="local" ; else __NAME="${1}" ; fi
    if [ "x$2" = x ] ; then 
	# if we start with a slash, prefix is nothing (rooted name), otherwise use a relative path
	__SWS=`echo $__NAME | sed 's/^\/.*/___ROOTED_NAME___/'`
	if [ "x$__SWS" = "x___ROOTED_NAME___" ] ; then __PREFIX="" ; else __PREFIX="./" ; fi
    else 
	# if we end with a slash, no worries, otherwise, append one
	__SWS=`echo $__NAME | sed 's/.*\/$/___END_SLASH___/'`
	if [ "x$__SWS" = "x___END_SLASH___" ] ; then __PREFIX="$2" ; else __PREFIX="${2}/" ; fi
    fi
    __SEMAPHORE="${__NAME}.semaphore"

    if [ -f ${__PREFIX}$__SEMAPHORE ] ; then
	warn "Semaphore [$__SEMAPHORE] is already released"
    fi

    # recreate the semaphore
    touch ${__PREFIX}$__SEMAPHORE

    # get rid of the stale semaphore acquired file.
    # if the file was properly registered, it should have a backup copy
    if [ -f ${__PREFIX}${__SEMAPHORE}.acquired ] ; then
	rm -f ${__PREFIX}${__SEMAPHORE}.acquired
    else
	warn "Acquired semaphore ${__SEMAPHORE}'s backup copy disappeared in $__PREFIX"
    fi

    if [ ! -w ${__PREFIX}$__SEMAPHORE ] ; then
        warn "Unable to write to semaphore file $__SEMAPHORE in ${__PREFIX}?"
    fi
    # save the PID of the process that last released this semaphore
    if [ ! "x$USER" = "x" ] ; then log "USER=$USER" "${__PREFIX}${__SEMAPHORE}" ; else log "USER=unknown" "${__PREFIX}${__SEMAPHORE}" ; fi
    log "PID=$$" "${__PREFIX}${__SEMAPHORE}"
    log "DATE=`date`" "${__PREFIX}${__SEMAPHORE}"

    # unregister the semaphore with the _ACQUIRED_SEMAPHORES var
    if [ ! "x$_ACQUIRED_SEMAPHORES" = "x" ] ; then
	__NEW_AS=""
	__FOUND_SEM=0
	for __SEM in $_ACQUIRED_SEMAPHORES ; do
	    if [ "x$__SEM" = "x${__PREFIX}$__NAME" ] ; then
		__FOUND_SEM=1
	    else
		__NEW_AS="$__NEW_AS $__SEM"
	    fi
	done
	_ACQUIRED_SEMAPHORES="$__NEW_AS" ; export _ACQUIRED_SEMAPHORES

	if [ x$__FOUND_SEM = x0 ] ; then
	    warn "bad bookkeeping -- _ACQUIRED_SEMAPHORES is missing entry $__NAME"
	    log "Created ${__SEMAPHORE}??"
        else
	    log "Released $__SEMAPHORE"
	fi
    else
	log "Created $__SEMAPHORE"
    fi
    return 0
}

#
# releaseAllSemaphores
#
releaseAllSemaphores ( ) {
    if [ ! "x$DEBUG" = x ] ; then log "releaseAllSemaphores() _ACQUIRED_SEMAPHORES=[$_ACQUIRED_SEMAPHORES]" ; fi

    if [ ! "x$_ACQUIRED_SEMAPHORES" = x ] ; then
	for __SEM in $_ACQUIRED_SEMAPHORES ; do
	    releaseSemaphore $__SEM
	done
    fi
}


#
# mail {addressList} [subject] [body] [{attachmentTupleList}]
#
# mailer sends out a mail message with a given subject and given body to an address list
# addressList is required only if USER is not set
# attachmentTupleList is a 2-tuple pair of 'filename' and 'label' that will be attached
#   as a mime text attachment, single quote wrapping and label are both required
#   e.g. $4="'file1' 'label1' 'file2' 'label2' 'file3' 'label3' "
###
mail ( ) {
    if [ ! "x$DEBUG" = "x" ] ; then log "mail( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4])" ; fi

    if [ "x$1" = x ] ; then 
	if [ ! "x$USER" = x ] ; then
	    __ADDRESS="$USER"
	else
	    bomb "mail() arg1 mismatch -- no e-mail address given, no USER set"
	fi
    else
	__ADDRESS="$1"
    fi
    if [ "x$2" = x ] ; then __SUBJECT="" ; else __SUBJECT="$2" ; fi
    if [ "x$3" = x ] ; then __BODY="" ; else __BODY="$3" ; fi
    if [ ! "x$4" = x ] ; then __MULTI="yes"; __FILES="$4" ; else __MULTI="no"; __FILES="" ; fi
    # need sendmail to properly give mime types
    for __MAILER in /bin/sendmail /usr/lib/sendmail /usr/bin/sendmail /usr/sbin/sendmail ; do
	if [ -f "$__MAILER" ] && [ -x "$__MAILER" ] ; then
	    break
	fi
    done
    if [ ! -x "${__MAILER}" ] ; then
	warn "Unable to find sendmail -- hoping it is in path"
	__MAILER="sendmail"
    fi
    BOUNDARY="xxxxqwertyxxxx.${HOSTNAME}.$$"

    # find a decent echo (!!! may want to consolidate later with log)
    __LOGTEST=`echo -e "\t\ntest"`
    if [ `echo $__LOGTEST | awk '{print $1}'` = "test" ] ; then
	__ECHO="echo -e"
    # no -e support
    else
	# need to do some extra checking since the sun5 /bin/echo sucks
	# see if default echo supports special chars
	__LOGTEST=`echo "\t\ntest"`
	if [ "x`echo $__LOGTEST | awk '{print $1}'`" = "xtest" ] ; then 
	    __ECHO="echo"
	else
	    # for sun5 (built-in echo is poor)
	    __LOGTEST=`/usr/bin/echo "\t\ntest"`
	    if [ "x`echo $__LOGTEST | awk '{print $1}'`" = "xtest" ] ; then
		__ECHO="/usr/bin/echo"
	    else
		echo "WARNING: cannot find decent echo"
		__ECHO="echo"
	    fi
	fi
    fi
    __BODY=`$__ECHO $__BODY`

    # weed off files that are not readable
    __NEWFILES=""
    __FILEORLABEL="file"
    # set the field separator to a single quote
    __PIFS="$IFS"
    IFS="'"
    for __FILELABEL in $__FILES ; do
	IFS="$__PIFS"  # restore briefly so sed/awk do not screw up
	if [ "x`echo $__FILELABEL | awk '{print $1}'`" = "x" ] ; then continue ; fi

        if [ "x$__FILEORLABEL" = "xfile" ] ; then 
	    __FILE="$__FILELABEL"
	    __FILEORLABEL="label"
	else 
	    __LABEL=$__FILELABEL
	    if [ ! -f "$__FILE" ] ; then
		warn "Unable to read attachment file [$__FILE]"
	    else
		__NEWFILES="$__NEWFILES '$__FILE' '$__LABEL'"
	    fi
	    __FILEORLABEL="file"
	fi
	IFS="'"
    done
    IFS="$__PIFS"  # restore so sed/awk do not screw up
    if [ ! "x$__FILEORLABEL" = "xfile" ] ; then
	warn "Missing attachment file label, using null"
	__NEWFILES="$__NEWFILES ''"
    fi
    __FILES="$__NEWFILES"
    
    # !!! should test validity of mail program existance
    if [ ! "x$DEBUG" = "x" ] ; then log "mail: __MAILER=[$__MAILER] __ADDRESS=[$__ADDRESS] __SUBJECT=[$__SUBJECT] __ATTACHMENTS=[$__MUTLI]\nmail: __FILES=[$__FILES]" ; fi

    # if we weeded off all attachments, then turn off multi
    if [ "x$__FILES" = "x" ] ; then __MULTI="no" ; fi
    # if we have attachments, we need to loop over them and add them properly
    if [ "x$__MULTI" = "xyes" ] ; then
	__ATTACH=""

	__FILEORLABEL="file"
	# set the field separator to a single quote
	__PIFS="$IFS"
	IFS="'"
	for __FILELABEL in $__FILES ; do
	    IFS="$__PIFS"  # restore briefly so sed/awk do not screw up
	    if [ "x`echo $__FILELABEL | awk '{print $1}'`" = "x" ] ; then continue ; fi
	    
	    if [ "x$__FILEORLABEL" = "xfile" ] ; then 
		__FILE="$__FILELABEL"
		__FILEORLABEL="label"
	    else 
		__LABEL=$__FILELABEL
		__FILEORLABEL="file"
		
		# process the file/label pair now
		if [ ! "x$DEBUG" = "x" ] ; then log "Processing attachment: [${__FILE}]" ; fi
		__FILEBASE=`basename "$__FILE"`
		__ATTACH="${__ATTACH}
--${BOUNDARY}
Content-Type: text/plain; charset=US-ASCII; name=\"$__FILEBASE\"
Content-Description: ${__LABEL}
Content-Disposition: attachment; filename=\"$__FILEBASE\"
Content-Transfer-Encoding: 7bit

`cat \"$__FILE\"`
"

	    fi
	    IFS="'"
	done
	IFS="$__PIFS"  # restore field separator (awk chokes otherwise)

	# loop over outgoing address list
	for __ADDR in $__ADDRESS ; do
	    $__MAILER $__ADDR <<EOF
Subject: ${__SUBJECT}
MIME-Version: 1.0
Content-type: multipart/mixed; boundary="${BOUNDARY}"
Content-Transfer-Encoding: 7bit

This message is in MIME format.  The first part should be readable text,
while the remaining parts are likely unreadable without MIME-aware tools.
Send mail to lamas@arl.army.mil for more info.

--${BOUNDARY}
Content-Type: text/plain; charset=US-ASCII; name="e-mail.body"
Content-Description: ${__SUBJECT}
Content-Disposition: inline; filename="e-mail.body"
Content-Transfer-Encoding: 7bit
${__BODY}


${__ATTACH}

--${BOUNDARY}--
EOF
        done

    # otherwise we are not sending attachments
    else
	# loop over outgoing address list
	for __ADDR in $__ADDRESS ; do
	    $__MAILER $__ADDR <<EOF
Subject: ${__SUBJECT}
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII; name="e-mail.body"
Content-Disposition: inline; filename="e-mail.body"
Content-Transfer-Encoding: 7bit

${__BODY}

EOF
	done
    fi

    # check for failure and log if so
    if [ $? != 0 ] ; then
	log "ERROR: mail failed"
	return 1
    fi
    return 0
}


#
# cvsExport cvsTag cvsRoot [exportDir] [cvsBinary] [cvsLogfile]
#
cvsExport ( ) {
    if [ ! "x$DEBUG" = "x" ] ; then log "cvsExport( \$1=[$1] \$2=[$2] \$3=[$3] \$4=[$4])" ; fi

    if [ "x$1" = x ] ; then 
	if [ ! "x$CVS_TAG" = "x" ] ; then
	    __TAG="$CVS_TAG"
	else
	    bomb "cvsExport() arg1 mismatch -- no cvs tag given, no CVS_TAG set"
	fi
    else
	__TAG="$1"
    fi
    if [ "x$2" = x ] ; then 
	if [ ! "x$CVS_ROOT" = "x" ] ; then
	    __ROOT="$CVS_ROOT"
	else
	    bomb "cvsExport() arg2 mismatch -- no cvs root given, no CVS_ROOT set"
	fi
    else
	__ROOT="$2"
    fi
    if [ "x$3" = "x" ] ; then __DIR="." ; else __DIR="$3" ; fi
    if [ "x$4" = "x" ] ; then __BIN="cvs" ; else __BIN="$4" ; fi
    if [ "x$5" = "x" ] ; then __LOG="/dev/null" ; else __LOG="$5" ; fi

    if [ ! -d "$__DIR" ] ; then 
        warn "cvs export directory [$__DIR] does not exist" "$__LOG"
        log "Creating directory [$__DIR]" "$__LOG"
        mkdir -p "$__DIR"
    fi
    if [ ! -w "${__DIR}/." ] ; then
        log "ERROR: Unable to write to cvs export directory [$__DIR]" "$__LOG"
        return 1
    fi

    $__BIN -v > /dev/null 2>&1
    if [ $? != 0 ] ; then
	log "ERROR: cvs export failed (unable to run cvs [$__CVS])" "$__LOG"
	return 1
    fi

    log "Starting cvs export..." "$__LOG"
    log "Running [$__BIN -q -d $__ROOT export -D today -d $__DIR -N $__TAG >> ${__LOG} 2>&1]" "$__LOG"
    $CVS -q -d $__ROOT export -D today -d $__DIR -N $__TAG >> "$__LOG" 2>&1
    # make sure cvs export exited nicely
    if [ $? != 0 ] ; then 
        log "ERROR: cvs export failed" "${__LOG}"
        return 1
    fi

    log "OK: cvs export completed" "${__LOG}"
    return 0
}


#
# unpackArchive archive [extractDir]
#
# as it is, this function merely bombs on error, but it should return a
# truthvalue as to whether the unpacking succeeded or not and let the
# application handle the result.
unpackArchive ( ) {
    if [ ! "x$DEBUG" = "x" ] ; then log "cvsExport( \$1=[$1] \$2=[$2] )" ; fi

    if [ "x$1" = x ] ; then 
        bomb "unpackArchive() arg1 mismatch -- no archive given"
    else
        __ARCHIVE="$1"
    fi
    if [ "x$2" = "x" ] ; then 
        __SWS=`echo $__ARCHIVE | sed 's/^\/.*/___ROOTED_NAME___/'`
        if [ "x$__SWS" = "x___ROOTED_NAME___" ] ; then __DIR=`dirname $__ARCHIVE` ; else __DIR="./"; fi
    else 
        __DIR="$2"
    fi

    if [ ! -f "$__ARCHIVE" ] ; then
        bomb "Unable to find archive [$__ARCHIVE] for unpacking"
    elif [ ! -r "$__ARCHIVE" ] ; then
        bomb "Unable to read archive [$__ARCHIVE] for unpacking"
    fi

    # !!! this is minimal checking and support for right now
    #  we assume that the uncompressor is available and options are supported
    case "$__ARCHIVE" in
        *.tar )
            tar -C "$__DIR" -xf "$__ARCHIVE" ;;
        *.zip )
            unzip "$__ARCHIVE" ;;
        *.tar.Z )
            uncompress -c "$__ARCHIVE" | tar -C "$__DIR" -x ;;
        *.tar.gz | *.tgz )
            gzip -c -d "$__ARCHIVE" | tar -x -C "$__DIR" ;;
        *.tar.bz2 )
            bunzip2 -c "$__ARCHIVE" | tar -C "$__DIR" -x ;;
        * )
            bomb "Unsupported archive format" ;;
    esac

    if [ $? != 0 ] ; then 
        bomb "Archive unpacking failed"
    fi
}


# INTERNAL STUFF
###
# vars used to manage locks and semaphores
initializeVariable _ACQUIRED_LOCKS 
initializeVariable _ACQUIRED_SEMAPHORES

# GLOBAL STUFF
# set a hostname and pwd to play with -- exports HOSTNAME and LPWD accordingly
setHostName

initializeVariable ARCH "`uname -s`"

case $0 in
    # hard path to sourcing script
    /* )
        initializeVariable LPWD "`dirname $0`" ;;
    # relative path to sourcing script
    */* )
        initializeVariable LPWD "`pwd`/`dirname $0`" ;;
    # sourcing script is in the path
    * )
        initializeVariable LPWD "`pwd`" ;;
esac
if [ ! -f "$LPWD/library" ] ; then
    warn "Unable to properly initialize path to library source varaible [LPWD]"
fi

# set STYLE value to 'color' to invoke color logging output, set to anything
# else to get plain text output
initializeVariable STYLE "color"

# terminal sequence to move to that column. You could change this
# to something like "tput hpa ${RES_COL}" if your terminal supports it
MOVE_TO_COLUMN="echo -en \\033[60G"
# terminal sequence to set color to a 'success' color (currently: green)
SETCOLOR_SUCCESS="echo -en \\033[1;32m"
# terminal sequence to set color to a 'failure' color (currently: red)
SETCOLOR_FAILURE="echo -en \\033[1;31m"
# terminal sequence to set color to a 'warning' color (currently: yellow)
SETCOLOR_WARNING="echo -en \\033[1;33m"
# terminal sequence to reset to the default color.
SETCOLOR_NORMAL="echo -en \\033[0;39m"
