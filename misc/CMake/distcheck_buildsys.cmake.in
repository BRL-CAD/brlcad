# Empty elements in lists are of no interest
IF(COMMAND CMAKE_POLICY)
	CMAKE_POLICY(SET CMP0007 OLD)
ENDIF(COMMAND CMAKE_POLICY)
			
FILE(WRITE @CMAKE_BINARY_DIR@/distcheck_problem_files.txt "")
		
MACRO(CLEAR_REFERENCED filelist referencelist)
	FOREACH(ITEM ${${filelist}})
		LIST(FIND ${referencelist} ${ITEM} ISIGNORED)
		IF(NOT ISIGNORED MATCHES "-1")
			LIST(REMOVE_ITEM ${filelist} ${ITEM})
		ENDIF(NOT ISIGNORED MATCHES "-1")
	ENDFOREACH(ITEM ${${filelist}})
ENDMACRO(CLEAR_REFERENCED)

# The actual success/fail test is the first IF test on the distlist - the rest is pretty-printing
# and listing for later processing
function(DIST_TEST distlist srcdir workingdir)
	IF(${distlist})
		FOREACH(ITEM ${${distlist}})
			IF(workingdir)
				FILE(APPEND @CMAKE_BINARY_DIR@/distcheck_problem_files.txt "${workingdir}/${ITEM};")
			ELSE(workingdir)
				FILE(APPEND @CMAKE_BINARY_DIR@/distcheck_problem_files.txt "${ITEM};")
			ENDIF(workingdir)
		ENDFOREACH(ITEM ${${distlist}})
		LIST(SORT ${distlist})
		SET(dirpath ${srcdir}/${workingdir})
		SET(cmakelistsdir "")
		WHILE(NOT cmakelistsdir AND dirpath)
			IF(NOT EXISTS ${dirpath}/CMakeLists.txt)
				get_filename_component(dirname ${dirpath} NAME)
				get_filename_component(dirpath ${dirpath} PATH)
				SET(filespath ${dirname}${filespath})
			ELSE(NOT EXISTS ${dirpath}/CMakeLists.txt)
				SET(cmakelistsdir ${dirpath})
			ENDIF(NOT EXISTS ${dirpath}/CMakeLists.txt)
		ENDWHILE(NOT cmakelistsdir AND dirpath)
		IF(filespath)
			FOREACH(ITEM ${${distlist}}) 
				SET(displaylist ${displaylist} ${filespath}/${ITEM})
			ENDFOREACH(ITEM ${${distlist}}) 
		ELSE(filespath)
			SET(displaylist ${${distlist}})
		ENDIF(filespath)
		MESSAGE("\nFile(s) found in the source tree that are not accounted for in ${cmakelistsdir}/CMakeLists.txt:")
		FOREACH(ITEM ${displaylist})
			SET(printlist "${printlist} \n${ITEM}")
		ENDFOREACH(ITEM ${displaylist})
		MESSAGE("${printlist}\n")
	ENDIF(${distlist})
endfunction(DIST_TEST)

# Go with a function here because we want local variable scope
function(check_directory dir)
	IF(EXISTS ${CMAKE_ORIG_BINARY_DIR}/${dir}/cmakefiles.cmake)
		FILE(STRINGS ${CMAKE_ORIG_BINARY_DIR}/${dir}/cmakefiles.cmake DIR_FILES_LIST)
		LIST(REMOVE_DUPLICATES DIR_FILES_LIST)
		LIST(SORT DIR_FILES_LIST)
	ENDIF(EXISTS ${CMAKE_ORIG_BINARY_DIR}/${dir}/cmakefiles.cmake)
	IF(EXISTS ${CMAKE_ORIG_BINARY_DIR}/${dir}/cmakepaths.cmake)
		FILE(STRINGS ${CMAKE_ORIG_BINARY_DIR}/${dir}/cmakepaths.cmake ACTIVE_PATHS)
		LIST(REMOVE_DUPLICATES ACTIVE_PATHS)
	ENDIF(EXISTS ${CMAKE_ORIG_BINARY_DIR}/${dir}/cmakepaths.cmake)
	FILE(GLOB GROUND_TRUTH RELATIVE ${CMAKE_ORIG_SRC_DIR}/${dir} "${CMAKE_ORIG_SRC_DIR}/${dir}/*")
	CLEAR_REFERENCED(GROUND_TRUTH IGNORE_LIST)
	CLEAR_REFERENCED(GROUND_TRUTH ACTIVE_PATHS)
	CLEAR_REFERENCED(GROUND_TRUTH DIR_FILES_LIST)
	DIST_TEST(GROUND_TRUTH ${CMAKE_ORIG_SRC_DIR} ${dir})
	IF(ACTIVE_PATHS)
		FOREACH(dir_path ${ACTIVE_PATHS})
			IF(EXISTS ${CMAKE_ORIG_BINARY_DIR}/${dir}/${dir_path}/cmakefiles.cmake OR EXISTS ${CMAKE_ORIG_BINARY_DIR}/${dir}/${dir_path}/cmakepaths.cmake)
				check_directory(${dir}/${dir_path})
			ENDIF()
		ENDFOREACH(dir_path)
	ENDIF(ACTIVE_PATHS)
endfunction(check_directory)

# Start of test run - functions and macros are defined, now run them

MESSAGE("Checking source archive is in sync with build system: ...")
SET(IGNORE_LIST_CORE CMakeLists.txt Makefile.am ".svn" README pkgIndex.tcl tclIndex)
SET(CMAKE_ORIG_SRC_DIR @CMAKE_SOURCE_DIR@)
SET(CMAKE_ORIG_BINARY_DIR @CMAKE_BINARY_DIR@)

# First, handle toplevel directory
SET(IGNORE_LIST ${IGNORE_LIST_CORE})
FILE(STRINGS ${CMAKE_ORIG_BINARY_DIR}/cmakefiles.cmake DIR_FILES_LIST)
FILE(STRINGS ${CMAKE_ORIG_BINARY_DIR}/cmakepaths.cmake ACTIVE_PATHS)
LIST(REMOVE_DUPLICATES ACTIVE_PATHS)
LIST(REMOVE_DUPLICATES DIR_FILES_LIST)
LIST(SORT DIR_FILES_LIST)
FILE(GLOB GROUND_TRUTH RELATIVE ${CMAKE_ORIG_SRC_DIR} "${CMAKE_ORIG_SRC_DIR}/*")
CLEAR_REFERENCED(GROUND_TRUTH IGNORE_LIST)
CLEAR_REFERENCED(GROUND_TRUTH ACTIVE_PATHS)
CLEAR_REFERENCED(GROUND_TRUTH DIR_FILES_LIST)
DIST_TEST(GROUND_TRUTH ${CMAKE_ORIG_SRC_DIR} "")

# Then, handle any subdirectories that are active (TODO - remove global property in toplevel made unnecessary by this approach)
IF(ACTIVE_PATHS)
	FOREACH(dir_path ${ACTIVE_PATHS})
		check_directory(${dir_path})
	ENDFOREACH(dir_path ${ACTIVE_PATHS})
ENDIF(ACTIVE_PATHS)

FILE(READ @CMAKE_BINARY_DIR@/distcheck_problem_files.txt PROBLEM_FILES)
IF(PROBLEM_FILES)
	MESSAGE(FATAL_ERROR "Unaccounted-for source files present.")
ENDIF(PROBLEM_FILES)
# TODO - The following lines aren't active yet, and may need more sophisticated logic in the case of multiple
# distcheck runs to avoid repeated appendings, but should "tweak" CPack based on the distcheck results
FILE(APPEND @CMAKE_BINARY_DIR@/CPackConfig.cmake "SET(CPACK_IGNORE_FILES \"\${CPACK_IGNORE_FILES};${PROBLEM_FILES}\")\n")
FILE(APPEND @CMAKE_BINARY_DIR@/CPackSourceConfig.cmake "SET(CPACK_IGNORE_FILES \"\${CPACK_IGNORE_FILES};${PROBLEM_FILES}\")\n")
FILE(APPEND @CMAKE_BINARY_DIR@/CPackConfig.cmake "SET(CPACK_SOURCE_IGNORE_FILES \"\${CPACK_SOURCE_IGNORE_FILES};${PROBLEM_FILES}\")\n")
FILE(APPEND @CMAKE_BINARY_DIR@/CPackSourceConfig.cmake "SET(CPACK_SOURCE_IGNORE_FILES \"\${CPACK_SOURCE_IGNORE_FILES};${PROBLEM_FILES}\")\n")


# If we got this far, it worked
MESSAGE("Checking source archive is in sync with build system: Passed")

