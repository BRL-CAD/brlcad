<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Manpage of RE2C</title>
</head>
<body>
<h1>RE2C</h1>
Section: User Commands (1)<br />
Updated: @PACKAGE_DATE@<br />
<a href="#index">Index</a>
<hr />
<a name="lbAB" id="lbAB">&nbsp;</a>
<h2>NAME</h2>
<p>re2c - convert regular expressions to C/C++</p>
<a name="lbAC" id="lbAC">&nbsp;</a>
<h2>SYNOPSIS</h2>
<p><b>re2c</b> [<b>-bdefFghisuvVw1</b>] [<b>-o output</b>] [<b>-c</b> [<b>-t header</b>]] file</p>
<a name="lbAD" id="lbAD">&nbsp;</a>
<h2>DESCRIPTION</h2>
<p><b>re2c</b> is a preprocessor that generates C-based recognizers from
regular expressions. The input to <b>re2c</b> consists of C/C++ source
interleaved with comments of the form /*!re2c ... */ which contain scanner
specifications. In the output these comments are replaced with code that, when
executed, will find the next input token and then execute some user-supplied
token-specific code.</p>
<p>For example, given the following code</p>
<pre>
char *scan(char *p)
{
/*!re2c
        re2c:define:YYCTYPE  = "unsigned char";
        re2c:define:YYCURSOR = p;
        re2c:yyfill:enable   = 0;
        re2c:yych:conversion = 1;
        re2c:indent:top      = 1;
        [0-9]+          {return p;}
        [^]             {return (char*)0;}
*/
}
</pre>
<br />
<br />
<p><b>re2c -is</b> will generate</p>
<pre>
/* Generated by re2c on Sat Apr 16 11:40:58 1994 */
char *scan(char *p)
{
    {
        unsigned char yych;

        yych = (unsigned char)*p;
        if(yych &lt;= '/') goto yy4;
        if(yych &gt;= ':') goto yy4;
        ++p;
        yych = (unsigned char)*p;
        goto yy7;
yy3:
        {return p;}
yy4:
        ++p;
        yych = (unsigned char)*p;
        {return char*)0;}
yy6:
        ++p;
        yych = (unsigned char)*p;
yy7:
        if(yych &lt;= '/') goto yy3;
        if(yych &lt;= '9') goto yy6;
        goto yy3;
    }

}
</pre>
<br />
<br />
<p>You can place one /*!max:re2c */ comment that will output a "#define YYMAXFILL
&lt;n&gt;" line that holds the maximum number of characters 
required to parse the input. That is the maximum value YYFILL(n)
will receive. If -1 is in effect then YYMAXFILL can be triggered once 
after the last /*!re2c */.</p>
<p>You can also use /*!ignore:re2c */ blocks that allows to document the
scanner code and will not be part of the output.</p>
<a name="lbAE" id="lbAE">&nbsp;</a>
<h2>OPTIONS</h2>
<p><b>re2c</b> provides the following options:</p>
<dl compact="compact">
<dt><b>-?</b></dt>
<dd><b>-h</b> Invoke a short help.<br /><br /></dd>
<dt><b>-b</b></dt>
<dd>Implies <b>-s</b>. Use bit vectors as well in the attempt to coax better
code out of the compiler. Most useful for specifications with more than a few
keywords (e.g. for most programming languages).<br /><br /></dd>
<dt><b>-c</b></dt>
<dd>Used to support (f)lex-like condition support.<br /><br /></dd>
<dt><b>-d</b></dt>
<dd>Creates a parser that dumps information about the current position and in
which state the parser is while parsing the input. This is useful to debug
parser issues and states. If you use this switch you need to define a macro
<i>YYDEBUG</i> that is called like a function with two parameters: <i>void
YYDEBUG(int state, char current)</i>. The first parameter receives the state or
-1 and the second parameter receives the input at the current cursor.<br /><br /></dd>
<dt><b>-D</b></dt>
<dd>Emit Graphviz dot data. It can then be processed with e.g.
"dot -Tpng input.dot > output.png". Please note that scanners with many states
may crash dot.<br /><br /></dd>
<dt><b>-e</b></dt>
<dd>Cross-compile from an ASCII platform to an EBCDIC one.<br /><br /></dd>
<dt><b>-f</b></dt>
<dd>Generate a scanner with support for storable state. For details see below
at <b>SCANNER WITH STORABLE STATES</b>.<br /><br /></dd>
<dt><b>-F</b><dt>
<dd>Partial support for flex syntax. When this flag is active then named 
definitions must be surrounded by curly braces and can be defined without an
equal sign and the terminating semi colon. Instead names are treated as direct
double quoted strings.<br /><br /></dd>
<dt><b>-g</b></dt>
<dd>Generate a scanner that utilizes GCC's computed goto feature. That is re2c
generates jump tables whenever a decision is of a certain complexity (e.g. a 
lot of if conditions are otherwise necessary). This is only useable with GCC 
and produces output that cannot be compiled with any other compiler. Note that
this implies -b and that the complexity threshold can be configured using the
inplace configuration "cgoto:threshold".</dd>
<dt><b>-i</b></dt>
<dd>Do not output #line information. This is usefull when you want use a CMS
tool with the re2c output which you might want if you do not require your users
to have re2c themselves when building from your source. <b>-o output</b>
Specify the output file.<br /><br /></dd>
<dt><b>-r</b></dt>
<dd>Allows reuse of scanner definitions with '<b>/*!use:re2c</b>' after
'<b>/*!rules:re2c</b>'. In this mode no '<b>/*!re2c</b>' block and exactly one
'<b>/*!use:re2c</b>' must be present. The rules are being saved and used by
every '<b>/*!repeat:re2c</b>' block that follows. These blocks can contain
inplace configurations, especially '<b>re2c:flags:w</b>' and '<b>re2c:flags:u</b>'.
That way it is possible to create the same scanner multiple times for different
character types, different input mechanisms or different output mechanisms.
The '<b>/*!use:re2c</b>' blocks can also contain additional rules that will be
appended to the set of rules in '<b>/*!rules:re2c</b>'.
<br /><br /></dd>
<dt><b>-s</b></dt>
<dd>Generate nested ifs for some switches. Many compilers need this assist to
generate better code.<br /><br /></dd>
<dt><b>-t</b></dt>
<dd>Create a header file that contains types for the (f)lex-like condition support.
This can only be activated when <b>-c</b> is in use.<br /><br /></dd>
<dt><b>-u</b></dt>
<dd>Generate a parser that supports Unicode chars (UTF-32). This means the 
generated code can deal with any valid Unicode character up to 0x10FFFF. When
UTF-8 or UTF-16 needs to be supported you need to convert the incoming stream
to UTF-32 upon input yourself.<br /><br /></dd>
<dt><b>-v</b></dt>
<dd>Show version information.<br /><br /></dd>
<dt><b>-V</b></dt>
<dd>Show the version as a number XXYYZZ.<br /><br /></dd>
<dt><b>-w</b></dt>
<dd>Create a parser that supports wide chars (UCS-2). This implies <b>-s</b>
and cannot be used together with <b>-e</b> switch.<br /><br /></dd>
<dt><b>-1</b></dt>
<dd>Force single pass generation, this cannot be combined with -f and disables 
YYMAXFILL generation prior to last re2c block.<br /><br /></dd>
<dt><b>--no-generation-date</b></dt>
<dd>Suppress date output in the generated output so that it only shows the re2c
version.<br /><br /></dd>
<dt><b>--case-insensitive</b></dt>
<dd>All strings are case insensitive, so all "-expressions are treated
in the same way '-expressions are.<br /><br /></dd>
<dt><b>--case-inverted</b></dt>
<dd>Invert the meaning of single and double quoted strings.
With this switch single quotes are case sensitive and
double quotes are case insensitive.<br /><br /></dd>
</dl>
<br />
<br />
<a name="lbAF" id="lbAF">&nbsp;</a>
<h2>INTERFACE CODE</h2>
<p>Unlike other scanner generators, <b>re2c</b> does not generate complete
scanners: the user must supply some interface code. In particular, the user
must define the following macros or use the 
corresponding inplace configurations:</p>
<dl compact="compact">
<dt>YYCONDTYPE</dt>
<dd>In <b>-c</b> mode you can use <b>-t</b> to generate a file that contains the 
enumeration used as conditions. Each of the values refers to a condition of
a rule set.</dd>
<dt>YYCTXMARKER</dt>
<dd><i>l</i>-expression of type *YYCTYPE. The generated code saves context 
backtracking information in YYCTXMARKER. The user only  needs to define this 
macro if a scanner specification uses trailing context in one or more of its 
regular expressions.<br /><br /></dd>
<dt>YYCTYPE</dt>
<dd>Type used to hold an input symbol. Usually char or unsigned char.<br /><br /></dd>
<dt>YYCURSOR</dt>
<dd><i>l</i>-expression of type *YYCTYPE that points to the current input
symbol. The generated code advances YYCURSOR as symbols are matched. On entry,
YYCURSOR is assumed to point to the first character of the current token. On
exit, YYCURSOR will point to the first character of the following token.<br /><br /></dd>
<dt>YYDEBUG(<i>state</i>,<i>current</i>)</dt>
<dd>This is only needed if the <b>-d</b> flag was specified. It allows to
easily debug the generated parser by calling a user defined function for every
state. The function should have the following signature: <i>void YYDEBUG(int
state, char current)</i>. The first parameter receives the state or -1 and the
second parameter receives the input at the current cursor.<br /><br /></dd>
<dt>YYFILL(<i>n</i>)</dt>
<dd>The generated code "calls" YYFILL(n) when the buffer needs (re)filling: at
least <i>n</i> additional characters should be provided. YYFILL(n) should adjust
YYCURSOR, YYLIMIT, YYMARKER and YYCTXMARKER as needed. Note that for typical 
programming languages <i>n</i> will be the length of the longest keyword plus 
one. The user can place a comment of the form /*!max:re2c */ once to insert 
a YYMAXFILL definition that is set to the maximum length value. If -1 
switch is used then YYMAXFILL can be triggered only once after the 
last /*!re2c */ block.<br /><br /></dd>
<dt>YYGETCONDITION()</dt>
<dd>This define is used to get the condition prior to entering the scanner code
when using <b>-c</b> switch. The value must be initialized with a value from 
the enumeration YYCONDTYPE type.</dd>
<dt>YYGETSTATE()</dt>
<dd>The user only needs to define this macro if the <b>-f</b> flag was
specified. In that case, the generated code "calls" YYGETSTATE() at the very
beginning of the scanner in order to obtain the saved state. YYGETSTATE() must
return a signed integer. The value must be either -1, indicating that the
scanner is entered for the first time, or a value previously saved by
YYSETSTATE(s). In the second case, the scanner will resume operations right after
where the last YYFILL(n) was called.<br /><br /></dd>
<dt>YYLIMIT</dt>
<dd>Expression of type *YYCTYPE that marks the end of the buffer (YYLIMIT[-1] is
the last character in the buffer). The generated code repeatedly compares
YYCURSOR to YYLIMIT to determine when the buffer needs (re)filling.<br /><br /></dd>
<dt>YYMARKER</dt>
<dd><i>l</i>-expression of type *YYCTYPE. The generated code saves backtracking
information in YYMARKER. Some easy scanners might not use this.<br /><br /></dd>
<dt>YYMAXFILL</dt>
<dd>This will be automatically defined by /*!max:re2c */ blocks as explained
above.<br /><br /></dd>
<dt>YYSETCONDITION(<i>c</i>)</dt>
<dd>This define is used to set the condition in transition rules. This is only
being used when <b>-c</b> is active and transition rules are being used.<br /><br /></dd>
<dt>YYSETSTATE(<i>s</i>)</dt>
<dd>The user only needs to define this macro if the <b>-f</b> flag was
specified. In that case, the generated code "calls" YYSETSTATE just before
calling YYFILL(n). The parameter to YYSETSTATE(s) is a signed integer that uniquely
identifies the specific instance of YYFILL(n) that is about to be called. Should
the user wish to save the state of the scanner and have YYFILL(n) return to the
caller, all he has to do is store that unique identifer in a variable. Later,
when the scanner is called again, it will call YYGETSTATE() and resume
execution right where it left off. The generated code will contain 
both YYSETSTATE(s) and YYGETSTATE() even if YYFILL(n) is being
disabled.<br /><br /></dd>
</dl>
<br />
<br />
<a name="lbAG" id="lbAG">&nbsp;</a>
<h2>SCANNER WITH STORABLE STATES</h2>
<p>When the <b>-f</b> flag is specified, re2c generates a scanner that can
store its current state, return to the caller, and later resume operations
exactly where it left off.</p>
<p>The default operation of re2c is a "pull" model, where the scanner asks for
extra input whenever it needs it. However, this mode of operation assumes that
the scanner is the "owner" the parsing loop, and that may not always be
convenient.</p>
<p>Typically, if there is a preprocessor ahead of the scanner in the stream, or
for that matter any other procedural source of data, the scanner cannot "ask"
for more data unless both scanner and source live in a separate threads.</p>
<p>The <b>-f</b> flag is useful for just this situation : it lets users design
scanners that work in a "push" model, i.e. where data is fed to the scanner
chunk by chunk. When the scanner runs out of data to consume, it just stores
its state, and return to the caller. When more input data is fed to the
scanner, it resumes operations exactly where it left off.</p>
<p>When using the -f option re2c does not accept stdin because it has to do the 
full generation process twice which means it has to read the input twice. That
means re2c would fail in case it cannot open the input twice or reading the
input for the first time influences the second read attempt.</p>
<p>Changes needed compared to the "pull" model.</p>
<p>1. User has to supply macros YYSETSTATE() and YYGETSTATE(state)</p>
<p>2. The <b>-f</b> option inhibits declaration of <i>yych</i> and
<i>yyaccept</i>. So the user has to declare these. Also the user has to save
and restore these. In the example <i>examples/push.re</i> these are declared as
fields of the (C++) class of which the scanner is a method, so they do not need
to be saved/restored explicitly. For C they could e.g. be made macros that
select fields from a structure passed in as parameter. Alternatively, they
could be declared as local variables, saved with YYFILL(n) when it decides
to return and restored at entry to the function. Also, it could be more
efficient to save the state from YYFILL(n) because
YYSETSTATE(state) is called unconditionally. YYFILL(n) however does not
get <i>state</i> as parameter, so we would have to store state in a local
variable by YYSETSTATE(state).</p>
<p>3. Modify YYFILL(n) to return (from
the function calling it) if more input is needed.</p>
<p>4. Modify caller to recognise "more input is needed" and respond
appropriately.</p>
<p>5.The generated code will contain a switch block that is used to restores 
the last state by jumping behind the corrspoding YYFILL(n) call. This code is
automatically generated in the epilog of the first "/*!re2c */" block. 
It is possible to trigger generation of the YYGETSTATE() block earlier by 
placing a "/*!getstate:re2c */" comment. This is especially useful when
the scanner code should be wrapped inside a loop.</p>
<p>Please see examples/push.re for push-model scanner. The generated code can be
tweaked using inplace configurations "state:abort" and "state:nextlabel".</p>
<a name="lbAH" id="lbAH">&nbsp;</a>
<h2>SCANNER WITH CONDITION SUPPORT</h2>
<p>
You can preceed regular-expressions with a list of condition names when using the <b>-c</b>
switch. In this case <b>re2c</b> generates scanner blocks for each conditon. Where each of the
generated scanners has its own precondition. The precondition is given by the 
interface define <b>YYGETCONDITON</b> and must be of type <b>YYCONDTYPE</b>.
</p><p>
There are two special rule types. First, the rules of the condition '*' are 
merged to all  conditions. And second the empty condition list allows to 
provide a code block that does not have a scanner part. Meaning it does not 
allow any regular expression. The condition value referring to this special 
block is always the one with the enumeration value 0. This way the code of this
special rule can be used to initialize a scanner. It is in no way necessary to
have these rules: but sometimes it is helpful to have a dedicated uninitialized
condition state.
</p><p>
Non empty rules allow to specify the new condition, which makes them
transition rules. Besides generating calls for the define <b>YYSETCONDTITION</b>
no other special code is generated.
</p>
<p>
There is another kind of special rules that allow to prepend code to any code
block of all rules of a certain set of conditions or to all code blocks to all
rules. This can be helpful when some operation is common among rules. For
instance this can be used to store the length of the scanned string. These
special setup rules start with an exclamation mark followed by either a list
of conditions <b>&lt;! condition, ... &gt;</b> or a star <b>&lt;!*&gt;</b>.
When <b>re2c</b> generates the code for a rule whose state does not have a
setup rule and a star'd setup rule is present, than that code will be used
as setup code.
</p>
<a name="lbAI" id="lbAI">&nbsp;</a>
<h2>SCANNER SPECIFICATIONS</h2>
<p>Each scanner specification consists of a set of <i>rules</i>, <i>named
definitions</i> and <i>configurations</i>.</p>
<p><i>Rules</i> consist of a regular expression along with a block of C/C++
code that is to be executed when the associated <i>regular expression</i> is
matched. You can either
start the code with an opening curly brace or the sequence '<b>:=</b>'. When
the code with a curly brace then <b>re2c</b> counts the brace depth and stops looking
for code automatically. Otherwise curly braces are not allowed and <b>re2c</b> stops
looking for code at the first line that does not begin with whitespace.</p>
<dl compact="compact">
<dd><i>regular-expression</i> { <i>C/C++ code</i> }</dd>
<dd><i>regular-expression</i> := <i>C/C++ code</i></dd>
</dl>
<p>
If <b>-c</b> is active then each regular expression is preceeded by a list of 
comma separated condition names. Besides normal naming rules there are two 
special cases. A rule may contain the single condition name '*' and no contition 
name at all. In the latter case the rule cannot have a regular expression. Non 
empty rules may further more specify the new condition. In that case re2c will
generated the necessary code to chnage the condition automatically. Just as above
code can be started with a curly brace of the sequence '<b>:=</b>'. Further more
rules can use ':=>' as a shortcut to automatically generate code that not only
sets the new condition state but also continues execution with the new state. A
shortcut rule should not be used in a loop where there is code between the start
of the loop and the <b>re2c</b> block unless <i>re2c:cond:goto</i> is changed
to '<i>continue;</i>'. If code is necessary before all rule (though not simple
jumps) you can doso by using &lt;! pseudo-rules.
</p>
<dl compact="compact">
<dd>&lt;<i>condition-list</i>&gt; <i>regular-expression</i> { <i>C/C++ code</i> }</dd>
<dd>&lt;<i>condition-list</i>&gt; <i>regular-expression</i> := <i>C/C++ code</i></dd>
<dd>&lt;<i>condition-list</i>&gt; <i>regular-expression</i> =&gt; <i>condition</i> { <i>C/C++ code</i> }</dd>
<dd>&lt;<i>condition-list</i>&gt; <i>regular-expression</i> =&gt; <i>condition</i> := <i>C/C++ code</i></dd>
<dd>&lt;<i>condition-list</i>&gt; <i>regular-expression</i> :=&gt; <i>condition</i></dd>
<dd>&lt;<i>*</i>&gt; <i>regular-expression</i> { <i>C/C++ code</i> }</dd>
<dd>&lt;<i>*</i>&gt; <i>regular-expression</i> := <i>C/C++ code</i></dd>
<dd>&lt;<i>*</i>&gt; <i>regular-expression</i> =&gt; <i>condition</i> { <i>C/C++ code</i> }</dd>
<dd>&lt;<i>*</i>&gt; <i>regular-expression</i> =&gt; <i>condition</i> := <i>C/C++ code</i></dd>
<dd>&lt;<i>*</i>&gt; <i>regular-expression</i> :=&gt; <i>condition</i></dd>
<dd>&lt;&gt; { <i>C/C++ code</i> }</dd>
<dd>&lt;&gt; := <i>C/C++ code</i></dd>
<dd>&lt;&gt; =&gt; <i>condition</i> { <i>C/C++ code</i> }</dd>
<dd>&lt;&gt; =&gt; <i>condition</i> := <i>C/C++ code</i></dd>
<dd>&lt;&gt; :=&gt; <i>condition</i></dd>
<dd>&lt;!<i>condition-list</i>&gt; { <i>C/C++ code</i> }</dd>
<dd>&lt;!<i>condition-list</i>&gt; := <i>C/C++ code</i></dd>
<dd>&lt;!*&gt; { <i>C/C++ code</i> }</dd>
<dd>&lt;!*&gt; := <i>C/C++ code</i></dd>
</dl>
<p>Named definitions are of the form:</p>
<dl compact="compact">
<dd><i>name</i> = <i>regular expression</i>;</dd>
</dl>
<p>When <b>-F</b> is active, then named definitions are also of the form:</p>
<dl compact="compact">
<dd><i>name</i> <i>regular expression</i></dd>
</dl>
<p>Configurations look like named definitions whose names start with
"<b>re2c:</b>":</p>
<dl compact="compact">
<dd>re2c:<i>name</i> = <i>value</i>;</dd>
<dd>re2c:<i>name</i> = <b>"</b><i>value</i><b>"</b>;</dd>
</dl>
<a name="lbAJ" id="lbAJ">&nbsp;</a>
<h2>SUMMARY OF RE2C REGULAR EXPRESSIONS</h2>
<dl compact="compact">
<dt>"foo"</dt>
<dd>the literal string foo. ANSI-C escape sequences can be used.</dd>
<dt>'foo'</dt>
<dd>the literal string foo (characters [a-zA-Z] treated case-insensitive).
ANSI-C escape sequences can be used.</dd>
<dt>[xyz]</dt>
<dd>a "character class"; in this case, the regular expression matches either an
'x', a 'y', or a 'z'.</dd>
<dt>[abj-oZ]</dt>
<dd>a "character class" with a range in it; matches an 'a', a 'b', any letter
from 'j' through 'o', or a 'Z'.</dd>
<dt>[^<i>class</i>]</dt>
<dd>an inverted "character class".</dd>
<dt><i>r</i>\<i>s</i></dt>
<dd>match any <i>r</i> which isn't an <i>s</i>. <i>r</i> and <i>s</i> must be
regular expressions which can be expressed as character classes.</dd>
<dt><i>r</i>*</dt>
<dd>zero or more <i>r</i>'s, where <i>r</i> is any regular expression</dd>
<dt><i>r</i>+</dt>
<dd>one or more <i>r</i>'s</dd>
<dt><i>r</i>?</dt>
<dd>zero or one <i>r</i>'s (that is, "an optional <i>r</i>")</dd>
<dt>name</dt>
<dd>the expansion of the "named definition" (see above)</dd>
<dt>(<i>r</i>)</dt>
<dd>an <i>r</i>; parentheses are used to override precedence (see below)</dd>
<dt><i>rs</i></dt>
<dd>an <i>r</i> followed by an <i>s</i> ("concatenation")</dd>
<dt><i>r</i>|<i>s</i></dt>
<dd>either an <i>r</i> or an <i>s</i></dd>
<dt><i>r</i>/<i>s</i></dt>
<dd>an <i>r</i> but only if it is followed by an <i>s</i>. The <i>s</i> is not part of
the matched text. This type of regular expression is called "trailing context". A trailing 
context can only be the end of a rule and not part of a named definition.</dd>
<dt><i>r</i>{<i>n</i>}</dt>
<dd>matches <i>r</i> exactly <i>n</i> times.</dd>
<dt><i>r</i>{<i>n</i>,}</dt>
<dd>matches <i>r</i> at least <i>n</i> times.</dd>
<dt><i>r</i>{<i>n</i>,<i>m</i>}</dt>
<dd>matches <i>r</i> at least <i>n</i> but not more than <i>m</i> times.</dd>
<dt>.</dt>
<dd>match any character except newline (\n).</dd>
<dt><i>def</i></dt>
<dd>matches named definition as specified by <i>def</i> only if <b>-F</b> is
off. If the switch <b>-F</b> is active then this behaves like it was enclosed
in double quotes and matches the string <i>def</i>.</dd>
</dl>
<br />
<br />
<p>Character classes and string literals may contain octoal or hexadecimal
character definitions and the following set of escape sequences
(<b>\n</b>,<br />
 <b>\t</b>, <b>\v</b>, <b>\b</b>, <b>\r</b>, <b>\f</b>, <b>\a</b>, <b>\\</b>).
An octal character is defined by a backslash followed by its three octal digits
and a hexadecimal character is defined by backslash, a lower cased '<b>x</b>'
and its two hexadecimal digits or a backslash, an upper cased <b>X</b> and its
four hexadecimal digits.</p>
<p>re2c further more supports the c/c++ unicode notation. That is a backslash
followed by either a lowercased <b>u</b> and its four hexadecimal digits or an
uppercased <b>U</b> and its eight hexadecimal digits. However only in \fB-u\fP 
mode the generated code can deal with any valid Unicode character up to 
0x10FFFF.</p>
<p>Since characters greater <b>\X00FF</b> are not allowed in non unicode mode,
the only portable "<b>any</b>" rules are <b>(.|"\n")</b> and <b>[^]</b>.</p>
<p>The regular expressions listed above are grouped according to precedence,
from highest precedence at the top to lowest at the bottom. Those grouped
together have equal precedence.</p>
<a name="lbAK" id="lbAK">&nbsp;</a>
<h2>INPLACE CONFIGURATION</h2>
<p>It is possible to configure code generation inside re2c blocks. The
following lists the available configurations:</p>
<dl compact="compact">
<dt><i>re2c:cond:divider</i> <b>=</b> "/* *********************************** */" <b>;</b></dt>
<dd>Allows to customize the devider for condition blocks. You can use '@@' to 
put the name of the condition or ustomize the plaeholder
using <i>re2c:cond:divider@cond</i>.</dd>
<dt><i>re2c:cond:divider@cond</i> <b>=</b> @@ <b>;</b></dt>
<dd>Specify the placeholder that will be replaced with the condition name
in <i>re2c:cond:divider\fP</i>.</dd>
<dt><i>re2c:cond:goto</i> <b>=</b> "goto @@;" <b>;</b></dt>
<dd>Allows to customize the condition goto statements used with ':=>' style rules.
You can use '@@' to put the name of the condition or ustomize the plaeholder
using <i>re2c:cond:goto@cond</i>. You can also change this to 'continue;',
which would allow you to continue with the next loop cycle including any code
between loop start and re2c block.</dd>
<dt><i>re2c:cond:goto@cond</i> <b>=</b> @@ <b>;</b></dt>
<dd>Spcifies the placeholder that will be replaced with the condition label
in <i>re2c:cond:goto</i>.</dd>
<dt><i>re2c:indent:top</i> <b>=</b> 0 <b>;</b></dt>
<dd>Specifies the minimum number of indendation to use. Requires a numeric
value greater than or equal zero.</dd>
<dt><i>re2c:condprefix</i> <b>=</b> yyc_ <b>;</b></dt>
<dd>Allows to specify the prefix used for condition labels. That is this text is 
prepended to any condition label in the generated output file.</dd>
<dt><i>re2c:condenumprefix</i> <b>=</b> yyc <b>;</b></dt>
<dd>Allows to specify the prefix used for condition values. That is this text is 
prepended to any condition enum value in the generated output file.</dd>
<dt><i>re2c:indent:string</i> <b>=</b> "\t" <b>;</b></dt>
<dd>Specifies the string to use for indendation. Requires a string that should
contain only whitespace unless you need this for external tools. The easiest
way to specify spaces is to enclude them in single or double quotes. If you do
not want any indendation at all you can simply set this to <b>""</b>.</dd>
<dt><i>re2c:yych:conversion</i> <b>=</b> 0 <b>;</b></dt>
<dd>When this setting is non zero, then \*(re automatically generates conversion 
code whenever yych gets read. In this case the type must be defined using
<b>re2c:define:YYCTYPE</b>.</dd>
<dt><i>re2c:yych:emit</i> <b>=</b> 1 <b>;</b></dt>
<dd>Generation of \fByych\fP can be suppressed by setting this to 0.</dd>
<dt><i>re2c:yybm:hex</i> <b>=</b> 0 <b>;</b></dt>
<dd>If set to zero then a decimal table is being used else a hexadecimal table
will be generated.</dd>
<dt><i>re2c:yyfill:enable</i> <b>=</b> 1 <b>;</b></dt>
<dd>Set this to zero to suppress generation of YYFILL(n). When using this be sure
to verify that the generated scanner does not read behind input. Allowing
this behavior might introduce sever security issues to you programs.</dd>
<dt><i>re2c:yyfill:check</i> <b>=</b> 1 </b>;</b></dt>
<dd>This can be set 0 to suppress output of the pre condition using YYCURSOR and
YYLIMIT which becomes usefull when YYLIMIT + max(YYFILL) is always accessible.</dd>
<dt><i>re2c:yyfill:parameter</i> <b>=</b> 1 <b>;</b></dt>
<dd>Allows to suppress parameter passing to <b>YYFILL</b> calls. If set to zero 
then no parameter is passed to <b>YYFILL</b>. However <b>define:YYFILL@LEN</b>
allows to specify a replacement string for the actual length value. If set to
a non zero value then <b>YYFILL</b> usage will be followed by the number of 
requested characters in braces unless <b>re2c:define:YYFILL:naked</b> is set. 
Also look at <b>re2c:define:YYFILL:naked</b> and <b>re2c:define:YYFILL@LEN</b>.</dd>
<dt><i>re2c:startlabel</i> <b>=</b> 0 <b>;</b></dt>
<dd>If set to a non zero integer then the start label of the next scanner
blocks will be generated even if not used by the scanner itself. Otherwise the
normal <b>yy0</b> like start label is only being generated if needed. If set to
a text value then a label with that text will be generated regardless of
whether the normal start label is being used or not. This setting is being
reset to <b>0</b> after a start label has been generated.</dd>
<dt><i>re2c:labelprefix</i> <b>=</b> yy <b>;</b></dt>
<dd>Allows to change the prefix of numbered labels. The default is \fByy\fP and
can be set any string that is a valid label.</dd>
<dt><i>re2c:state:abort</i> <b>=</b> 0 <b>;</b></dt>
<dd>When not zero and switch -f is active then the YYGETSTATE block will 
contain a default case that aborts and a -1 case is used for initialization.</dd>
<dt><i>re2c:state:nextlabel</i> <b>=</b> 0 <b>;</b></dt>
<dd>Used when -f is active to control whether the YYGETSTATE block is 
followed by a yyNext: label line. Instead of using yyNext you can 
usually also use configuration <i>startlabel</i> to force a specific start label
or default to yy0 as start label. Instead of using a dedicated label it 
is often better to separate the YYGETSTATE code from the actual scanner code by
placing a "/*!getstate:re2c */" comment.</dd>
<dt><i>re2c:cgoto:threshold</i> <b>=</b> 9 <b>;</b></dt>
<dd>When -g is active this value specifies the complexity threshold that triggers
generation of jump tables rather than using nested if's and decision bitfields.
The threshold is compared against a calculated estimation of if-s needed where 
every used bitmap divides the threshold by 2.</dd>
<dt><i>re2c:yych:conversion</i> <b>=</b> 0 <b>;</b></dt>
<dd>When the input uses signed characters and <b>-s</b> or <b>-b</b> switches are
in effect re2c allows to automatically convert to the unsigned character type
that is then necessary for its internal single character. When this setting
is zero or an empty string the conversion is disabled. Using a non zero number
the conversion is taken from <b>YYCTYPE</b>. If that is given by an inplace
configuration that value is being used. Otherwise it will be <b>(YYCTYPE)</b>
and changes to that configuration are  no longer possible. When this setting is
a string the braces must be specified. Now assuming your input is a <b>char*</b>
buffer and you are using above mentioned switches you can set <b>YYCTYPE</b> to
<b>unsigned char</b> and this setting to either <b>1</b> or <b>"(unsigned char)"</b>.</dd>
<dt><i>re2c:define:define:YYCONDTYPE</i> <b>=</b> YYCONDTYPE <b>;</b></dt>
<dd>Enumeration used for condition support with <b>-c</b> mode.</dd>
<dt><i>re2c:define:YYCTXMARKER</i> <b>=</b> YYCTXMARKER <b>;</b></dt>
<dd>Allows to overwrite the define YYCTXMARKER and thus avoiding it by setting the
value to the actual code needed.</dd>
<dt><i>re2c:define:YYCTYPE</i> <b>=</b> YYCTYPE <b>;</b></dt>
<dd>Allows to overwrite the define YYCTYPE and thus avoiding it by setting the
value to the actual code needed.</dd>
<dt><i>re2c:define:YYCURSOR</i> <b>=</b> YYCURSOR <b>;</b></dt>
<dd>Allows to overwrite the define YYCURSOR and thus avoiding it by setting the
value to the actual code needed.</dd>
<dt><i>re2c:define:YYDEBUG</i> <b>=</b> YYDEBUG <b>;</b></dt>
<dd>Allows to overwrite the define \fBYYDEBUG\fP and thus avoiding it by setting the
value to the actual code needed.</dd>
<dt><i>re2c:define:YYFILL</i> <b>=</b> YYFILL <b>;</b></dt>
<dd>Allows to overwrite the define \fBYYFILL\fP and thus avoiding it by setting the
value to the actual code needed.</dd>
<dt><i>re2c:define:YYFILL:naked</i> <b>=</b> 0 <b>;</b></dt>
<dd>When set to 1 neither braces, parameter nor semicolon gets emitted.</dd>
<dt><i>re2c:define:YYFILL@LEN</i> <b>=</b> @@ <b>;</b></dt>
<dd>When using <b>re2c:define:YYFILL</b> and <b>re2c:yyfill:parameter</b> is 0 then
any occurence of this text inside <b>YYFILL</b> will be replaced with the actual
length value.</dd>
<dt><i>re2c:define:YYGETCONDITION</i> <b>=</b> YYGETCONDITION <b>;</b></dt>
<dd>Allows to overwrite the define <b>YYGETCONDITION</b>.</dd>
<dt><i>re2c:define:YYGETCONDITION:naked</i> <b>=</b> 0 <b>;</b></dt>
<dd>When set to 1 neither braces, parameter nor semicolon gets emitted.</dd>
<dt><i>re2c:define:YYGETSTATE</i> <b>=</b> YYGETSTATE <b>;</b></dt>
<dd>Allows to overwrite the define <b>YYGETSTATE</b> and thus avoiding it by setting the
value to the actual code needed.</dd>
<dt><i>re2c:define:YYGETSTATE:naked</i> <b>=</b> 0 <b>;</b></dt>
<dt>When set to 1 neither braces, parameter nor semicolon gets emitted.</dt>
<dt><i>re2c:define:YYLIMIT</i> <b>=</b> YYLIMIT <b>;</b></dt>
<dd>Allows to overwrite the define <b>YYLIMIT</b> and thus avoiding it by setting the
value to the actual code needed.</dd>
<dt><i>re2c:define:YYMARKER</i> <b>=</b> YYMARKER <b>;</b></dt>
<dd>Allows to overwrite the define <b>YYMARKER</b> and thus avoiding it by setting the
value to the actual code needed.</dd>
<dt><i>re2c:define:YYSETCONDITION</i> <b>=</b> YYSETCONDITION <b>;</b></dt>
<dd>Allows to overwrite the define <b>YYSETCONDITION</b>.</dd>
<dt><i>re2c:define:YYSETCONDITION@cond</i> <b>=</b> @@ <b>;</b></dt>
<dd>When using <b>re2c:define:YYSETCONDITION</b> then any occurence of this text 
inside <b>YYSETCONDITION</b> will be replaced with the actual new condition value.</dd>
<dt><i>re2c:define:YYSETSTATE</i> <b>=</b> YYSETSTATE <b>;</b></dt>
<dd>Allows to overwrite the define <b>YYSETSTATE</b> and thus avoiding it by setting the
value to the actual code needed.</dd>
<dt><i>re2c:define:YYSETSTATE:naked</i> <b>=</b> 0 <b>;</b></dt>
<dt>When set to 1 neither braces, parameter nor semicolon gets emitted.</dt>
<dt><i>re2c:define:YYSETSTATE@state</i> <b>=</b> @@ <b>;</b></dt>
<dd>When using <b>re2c:define:YYSETSTATE</b> then any occurence of this text 
inside <b>YYSETSTATE</b> will be replaced with the actual new state value.</dd>
<dt><i>re2c:label:yyFillLabel</i> <b>=</b> yyFillLabel <b>;</b></dt>
<dd>Allows to overwrite the name of the label yyFillLabel.</dd>
<dt><i>re2c:label:yyNext</i> <b>=</b> yyNext <b>;</b></dt>
<dd>Allows to overwrite the name of the label yyNext.</dd>
<dt><i>re2c:variable:yyaccept</i> <b>=</b> yyaccept <b>;</b></dt>
<dd>Allows to overwrite the name of the variable yyaccept.</dd>
<dt><i>re2c:variable:yybm</i> <b>=</b> yybm <b>;</b></dt>
<dd>Allows to overwrite the name of the variable yybm.</dd>
<dt><i>re2c:variable:yych</i> <b>=</b> yych <b>;</b></dt>
<dd>Allows to overwrite the name of the variable yych.</dd>
<dt><i>re2c:variable:yyctable</i> <b>=</b> yyctable <b>;</b></dt>
<dd>When both <b>-c</b> and <b>-g</b> are active then <b>re2c</b> uses this variable to 
generate a static jump table for YYGETCONDITION.</dd>
<dt><i>re2c:variable:yystable</i> <b>=</b> yystable <b>;</b></dt>
<dd>When both <b>-f</b> and <b>-g</b> are active then <b>re2c</b> uses this variable to 
generate a static jump table for YYGETSTATE.</dd>
<dt><i>re2c:variable:yytarget</i> <b>=</b> yytarget <b>;</b></dt>
<dd>Allows to overwrite the name of the variable yytarget.</dd>
</dl>
<a name="lbAL" id="lbAL">&nbsp;</a>
<h2>UNDERSTANDING RE2C</h2>
<p>The subdirectory lessons of the re2c distribution contains a few step by step
lessons to get you started with re2c. All examples in the lessons subdirectory
can be compiled and actually work.</p>
<a name="lbAM" id="lbAM">&nbsp;</a>
<h2>FEATURES</h2>
<p><b>re2c</b> does not provide a default action: the generated code assumes
that the input will consist of a sequence of tokens. Typically this can be
dealt with by adding a rule such as the one for unexpected characters in the
example above.</p>
<p>The user must arrange for a sentinel token to appear at the end of input
(and provide a rule for matching it): <b>re2c</b> does not provide an
&lt;&lt;EOF&gt;&gt; expression. If the source is from a null-byte terminated
string, a rule matching a null character will suffice. If the source is from a
file then you could pad the input with a newline (or some other character that 
cannot appear within another token); upon recognizing such a character check 
to see if it is the sentinel and act accordingly. And you can also use YYFILL(n)
to end the scanner in case not enough characters are available which is nothing
else then e detection of end of data/file.</p>
<a name="lbAN" id="lbAN">&nbsp;</a>
<h2>BUGS</h2>
<p>Difference only works for character sets.</p>
<p>The <b>re2c</b> internal algorithms need documentation.</p>
<a name="lbAO" id="lbAO">&nbsp;</a>
<h2>SEE ALSO</h2>
<p>flex(1), lex(1). More information on <b>re2c</b> can be found here:
<b><a href=
"http://re2c.org/">http://re2c.org/</a></b></p>
<a name="lbAP" id="lbAP">&nbsp;</a>
<h2>AUTHORS</h2>
<ul>
<li>Peter Bumbulis &lt;<a href=
"mailto:peter@csg.uwaterloo.ca">peter@csg.uwaterloo.ca</a>&gt;</li>
<li>Brian Young &lt;<a href=
"mailto:bayoung@acm.org">bayoung@acm.org</a>&gt;</li>
<li>Dan Nuffer &lt;<a href=
"mailto:nuffer@users.sourceforge.net">nuffer@users.sourceforge.net</a>&gt;</li>
<li>Marcus Boerger &lt;<a href=
"mailto:helly@users.sourceforge.net">helly@users.sourceforge.net</a>&gt;</li>
<li>Hartmut Kaiser &lt;<a href=
"mailto:hkaiser@users.sourceforge.net">hkaiser@users.sourceforge.net</a>&gt;</li>
<li>Emmanuel Mogenet &lt;<a href="mailto:mgix@mgix.com">mgix@mgix.com</a>&gt;
(added storable state)</li>
</ul>
<br />
<br />
<a name="lbAQ" id="lbAQ">&nbsp;</a>
<h2>VERSION INFORMATION</h2>
<p>This manpage describes <b>re2c</b>, version @PACKAGE_VERSION@.</p>
<hr />
<a name="index" id="index">&nbsp;</a>
<h2>Index</h2>
<dl>
<dt><a href="#lbAB">NAME</a><br /></dt>
<dt><a href="#lbAC">SYNOPSIS</a><br /></dt>
<dt><a href="#lbAD">DESCRIPTION</a><br /></dt>
<dt><a href="#lbAE">OPTIONS</a><br /></dt>
<dt><a href="#lbAF">INTERFACE CODE</a><br /></dt>
<dt><a href="#lbAG">SCANNER WITH STORABLE STATES</a><br /></dt>
<dt><a href="#lbAH">SCANNER WITH CONDITION SUPPORT</a><br /></dt>
<dt><a href="#lbAI">SCANNER SPECIFICATIONS</a><br /></dt>
<dt><a href="#lbAJ">SUMMARY OF RE2C REGULAR EXPRESSIONS</a><br /></dt>
<dt><a href="#lbAK">INPLACE CONFIGURATION</a><br /></dt>
<dt><a href="#lbAL">UNDERSTANDING RE2C</a><br /></dt>
<dt><a href="#lbAM">FEATURES</a><br /></dt>
<dt><a href="#lbAN">BUGS</a><br /></dt>
<dt><a href="#lbAO">SEE ALSO</a><br /></dt>
<dt><a href="#lbAP">AUTHORS</a><br /></dt>
<dt><a href="#lbAQ">VERSION INFORMATION</a><br /></dt>
</dl>
<br />
<br />
<hr />
<p>This document was created by man2html, using the manual pages.<br />
Date: @PACKAGE_DATE@</p>
</body>
</html>
