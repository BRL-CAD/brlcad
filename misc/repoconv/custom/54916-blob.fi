blob
data 25986
The Installation Guide to BRL-CAD
=================================

Please read this document if you are interested in installing BRL-CAD.

This document covers the basics of installing BRL-CAD from either a
source or binary distribution.  Please see the 'Reporting Problems'
section if you run into any trouble installing BRL-CAD.

Some platforms have additional platform-specific documentation
provided in the doc/ directory of the source distribution that should
be consulted if that is the platform you are installing on.  This
presently includes the following:

  doc/README.AIX        -- IBM's Advanced Interactive eXecutive OS
  doc/README.BSD        -- FreeBSD, NetBSD, OpenBSD, etc.
  doc/README.IRIX	-- SGI IRIX and IRIX64
  doc/README.Linux	-- Various Linux distributions
  doc/README.MacOSX	-- Apple Mac OS X
  doc/README.Solaris    -- Oracle Solaris, OpenIndiana (Illumos), etc.
  doc/README.Windows    -- Microsoft Windows
  doc/README.VAX        -- Virtual Address eXtension architecture from DEC.
                           One of the original BRL-CAD platforms. These
                           days, re-created using the simh simulator.


TABLE OF CONTENTS
-----------------
  Introduction
  Table of Contents
  Quick Installation
  Installing from Binary
  Installing from Source
  Testing Functionality
  Post-Installation
  Reporting Problems
  Configuration Options


QUICK INSTALLATION
------------------

Note that the downloaded files have two check sums calculated
automatically by the Source Forge file release system.  The values are
used to verify the integrity of the files as distributed.  Get those
data by clicking on the 'i' button at the end of each file's name.
You should ensure those data are retained and kept with the files if
you re-distribute them.


If you downloaded a binary distribution of BRL-CAD for your system,
please read the INSTALLING FROM BINARY section of this document down
below.  The rest of this quick installation section is only relevant
to source code distributions of BRL-CAD.

For the impatient or simplistic, the following steps should compile,
test, and install an optimized BRL-CAD quickly into the /usr/brlcad/rel-X.Y.Z
directory if CMake is installed on your system:

  gunzip brlcad-X.Y.Z.tar.gz
  tar -xvf brlcad-X.Y.Z.tar
  mkdir brlcad-build
  cd brlcad-build
  cmake ../brlcad-X.Y.Z -DBRLCAD_BUNDLED_LIBS=ON -DCMAKE_BUILD_TYPE=Release
  make
  make benchmark
  make regress
  make install   # as root, e.g. sudo make install

If any of the listed steps fail, then something unexpected happened.
See the REPORTING PROBLEMS section of this document to report the
problem or the INSTALLING FROM SOURCE section for more comprehensive
instructions.

Once installed, add /usr/brlcad/rel-X.Y.Z/bin to your path, and you should be
able to run any of the 400+ applications that constitute BRL-CAD.  For
example, to run the MGED solid modeler:

PATH=/usr/brlcad/rel-X.Y.Z/bin:$PATH ; export PATH
mged

If you use tcsh or another C-shell based command shell, use this
instead:

set path=( /usr/brlcad/rel-X.Y.Z/bin $path ) ; rehash
mged


INSTALLING FROM BINARY
----------------------

There are a variety of different kinds of binary distributions of
BRL-CAD.  Some of the binary distributions are sufficiently generic and
are simply a binary compressed tarball distribution.  Others are
specific to a particular platform such as Debian, Mac OS X, FreeBSD,
and Windows etc.


Generic Binary Distributions:

For the unspecialized binary distributions that are basically
compressed tarballs of the installation root, they should contain the
entire hierarchy of the distribution.  To put that hierarchy in its
"installed" location, you just create the directory and move the
expanded tarball contents:

gunzip BRL-CAD_7.2.4_Linux_ia64.tar.gz
tar -xvf BRL-CAD_7.2.4_Linux_ia64.tar
sudo mkdir /usr/brlcad/rel-7.2.4
sudo mv BRL-CAD_7.2.4_Linux_ia64/* /usr/brlcad/rel-7.2.4/

Of course, there are other compression options possible including zip
and bzip2.  By default, BRL-CAD expects to be installed into
/usr/brlcad/rel-7.2.4. On some platforms the binary may be relocatable,
but this is not guaranteed. It's recommended that you start from a source
distribution if you would like to install into an alternate installation
location.  That said, if you do desire to install and/or run BRL-CAD from
a different location, give it a try...on some platforms it will work.

Something to be aware of, even if a binary distribution IS relocatable:
it will use its local copies of things like libraries only so long as the
"final" installed target directory that the build was compiled for
does not contain a BRL-CAD installation.  Due to the way path logic
is set, an installed copy of a library in the correct location will
always be loaded first, regardless of the presence of a "local" copy.


Mac OS X Disk Mounting Image:

Mount the .dmg and run the Installer .pkg contained therein.  This
will install into /usr/brlcad/rel-X.Y.Z and will only require confirming that
your environment is set up properly (i.e. add /usr/brlcad/rel-X.Y.Z/bin to your
path) as described in the Quick Installation section.


INSTALLING FROM SOURCE
----------------------

There are a couple of ways to obtain the BRL-CAD sources, usually via
one of the following starting points:

  1) from a SVN checkout/export, or
  2) from a source distribution tarball

Using the latest SVN sources is recommended where possible since it
will have the latest changes.  See the corresponding section below for
details on how to install from either starting point.


Starting From a SVN Checkout/Export:

With CMake, there is no longer any difference between building from
a subversion checkout and a tarball--follow the Source Distribution
instructions below.

Starting From a Source Distribution:

There are many different ways to build BRL-CAD and depending on what
you need/want will determine which configuration options you should
use.  See the CONFIGURATION OPTIONS section below for details on how
to go about selecting which options are appropriate for you.

By default, the default configuration will prepare the build system
to perform a Debug build and install into the /usr/brlcad/dev-X.Y.Z
directory.   The CMAKE_INSTALL_PREFIX option may be used to change
that directory, or a Release build type may be specified to install to
/usr/brlcad/rel-X.Y.Z - more on this below.  The
tradition of non-system installation paths goes back a couple of decades
and is a convenient means to isolate the BRL-CAD solid modeling
system from your system, resolves conflicts, facilitates uninstalls,
and simplifies upgrades.  The default configuration is performed by
running `cmake'.  It is not required to do the build in a directory
different from your source directory, but it is much cleaner and
*highly* recommended - this guide will illustrate the build process
with the assumption that the BRL-CAD source code is in the directory
brlcad-7.2.4 and the directory intended to hold the build output is
brlcad-build, located in the same parent directory as brlcad-7.2.4:

  .
  ./brlcad-7.2.4
  ./brlcad-build

To start the build process, cd into brlcad-build and run CMake,
pointing it to the source directory:

  cd brlcad-build
  cmake ../brlcad-7.2.4

As mentioned earlier, CMake uses two "build types", controlled by
the CMAKE_BUILD_TYPE variable, that are useful for specific purposes:

* Debug (-DCMAKE_BUILD_TYPE=Debug) - Debug is the configuration that most
  developers will want to use when working on BRL-CAD.  It will add
  debug flags to the compile, and sets the default install directory to
  be /usr/brlcad/dev-X.Y.Z - in order to run the resulting installed
  binaries, the developer should ensure that the dev-X.Y.Z  path is
  first in their PATH environment variable.

* Release (-DCMAKE_BUILD_TYPE=Release) - A release build is intended for
  final consumption by end users and as such has optimizations enabled.
  It also sets the install path to /usr/brlcad/rel-X.Y.Z - best practice
  for release installation is to set up symbolic links in /usr/brlcad to
  point to the most current BRL-CAD release, while allowing older versions
  to remain installed on the system in case they are needed.

In both of these cases any individual variable may be overridden - for
example, setting -DCMAKE_INSTALL_PREFIX=/usr/brlcad in a Debug build will
override the ../brlcad-install default.  Build types are a convenient way
to bundle sets of settings, but they do not prevent overrides if a more
custom setup is needed.

By default, all components and functionality will be built.
Note that BRL-CAD does require and include several 3rd party
components.  If your system does not include a sufficient version of
those required 3rd party components, they will be automatically
configured for compilation.

If the autodetection mechanisms fail to produce a working configuration,
the next simplest approach is typically to enable ALL the third party
components - this is typically a well tested configuration, but will
increase both the build time and final install size of BRL-CAD on
the system.  To set this variable on the command line, use -D to
define BRLCAD_BUNDLED_LIBS for CMake:

  -DBRLCAD_BUNDLED_LIBS=Bundled

If the graphical interface (cmake-gui) is in use, it will list this
and other common options by default, allowing the user change them
graphically.  This is often quicker and more convenient than
defining options on the command line, but both will work.

You can also force on or off any individual 3rd party library by
setting the BRL-CAD variable for that feature to either on or off:

  -DBRLCAD_<LIBRARY>=ON

Other variables control BRL-CAD features.  For example, to NOT
enable functionality using OpenGL, set

  -DBRLCAD_ENABLE_OPENGL=OFF

To obtain an optimized build (for example, for BRL-CAD Benchmark
performance evaluation), enable BRLCAD_FLAGS_OPTIMIZATION:

  -DBRLCAD_FLAGS_OPTIMIZATION=ON

See the CONFIGURATION OPTIONS below for more details on all of the
possible settings.

You can specify options or preferences you want to always use by
default.  For example, to always enable all local libs the following
line can be added to your own configuration file:

  set(BRLCAD_BUNDLED_LIBS "Bundled" CACHE STRING "Enable all local libs")

You can define your own configuration file in one of three ways.  The
build system will search for the file in this order:

  ${BRLCAD_SOURCE_DIR}/../BRL-CAD_CONFIG.GLOBAL

  ${BRLCAD_SOURCE_DIR}/BRL-CAD_CONFIG.GLOBAL

  the file defined in the environment variable "BRLCAD_USER_GLOBAL_CONFIG_FILE"

The build system will use the first file defined that exists.

Once configured, you should be able to successfully build BRL-CAD via
make:

  make

(On multicore systems, adding the -j flag (e.g. -j6) is recommended)

Installing the Compilation:

After the build successfully completes and assuming the benchmark also
produces correct results, installation may begin.  Like any package,
you must have sufficient filesystem permissions to install.  To
install into a system location, you can generally either become a
super user via the su command and run

  make install

or on operating systems set up to use sudo:

  sudo make install


TESTING FUNCTIONALITY
---------------------

To test BRL-CAD before installation, you can run the BRL-CAD benchmark.
The benchmark will report if the results are correct, testing a
majority of the core functionality of BRL-CAD in addition to testing
your system's performance:

  make benchmark

Note that the benchmark target will build ONLY the pieces required for
the benchmark tests, unless a general make has already been performed.
For more testing, you can run the regression test suite:

  make regress


POST-INSTALLATION
-----------------

Permissions:

Something to be aware of with CMake installations is that umask settings
are ignored by current versions of CMake.  It is a common situation in
Unix environments to want "group" members to have read/write access -
to achieve this, after installation the following find command can be
run (of course, substituting the actual BRL-CAD version for X.Y.Z):

find /usr/brlcad/rel-X.Y.Z -type d -exec chmod ug+rwx {} \; -exec chmod o+rx {} \; -o -type f -exec chmod ug+rw {} \; -exec chmod o+r {} \;

The above 'find' line will set up permissions across a /usr/brlcad
rooted installation such that 'user' and 'group' will have read-write
access and 'other' will have read access consistently across all
files.


System PATH:

Normally, BRL-CAD's install directories are not in system PATH lists and
consequently BRL-CAD's executables will not be invokable without specifying
their full path.  This is normally handled in Unix environments by adding
the desired BRL-CAD installation's binary directory to the user's local path:

In the bash shell: export PATH=/usr/brlcad/rel-X.Y.Z:$PATH
In the csh shell:  setenv PATH /usr/brlcad/rel-X.Y.Z:$PATH

REPORTING PROBLEMS
------------------

Please report any bugs encountered to the project bug tracker at
http://sourceforge.net/tracker/?group_id=105292&atid=640802

Similarly, please post any request for feature enhancements or support
to http://sourceforge.net/tracker/?group_id=105292&atid=640805 and
http://sourceforge.net/tracker/?group_id=105292&atid=640803
respectively.


CONFIGURATION OPTIONS
---------------------

--- BRLCAD_BUNDLED_LIBS ---

Enables compilation of all 3rd party sources that are provided within a BRL-CAD
source distribution.  If used this option sets all other 3rd party library
build flags to ON by default.  However, that setting can be overridden by
manually setting individual variables. Default is "AUTO" - 3rd party sources
are compiled only if they are not detected as being available and functioning
as expected.

Aliases:  ENABLE_ALL


--- BRLCAD_ENABLE_OPENGL ---

Enable support for OpenGL based Display Managers in BRL-CAD.
Default depends on whether OpenGL is successfully detected -
if it is, default is to enable.

Aliases:  ENABLE_OPENGL


--- BRLCAD_ENABLE_RUNTIME_DEBUG ---

Enables support for application and library debugging facilities.
Disabling the run-time debugging facilities can provide a significant
(10%-30%) performance boost at the expense of extensive error
checking (that in turn help prevent corruption of your data).
Default is ;ON;, and should only be disabled for read-only render
work where performance is critical.

Aliases:  ENABLE_RUNTIME_DEBUG, ENABLE_RUN_TIME_DEBUG, ENABLE_RUNTIME_DEBUGGING
          ENABLE_RUN_TIME_DEBUGGING


--- BRLCAD_FLAGS_DEBUG ---

Add compiler flags to aid in program debugging.  Defaults to ON.

Aliases:  ENABLE_DEBUG, ENABLE_FLAGS_DEBUG, ENABLE_DEBUG_FLAGS


--- BRLCAD_ENABLE_COMPILER_WARNINGS ---

Use extra compiler warning flags when compiling C/C++ code.  Defaults to ON.

Aliases:  ENABLE_WARNINGS, ENABLE_COMPILER_WARNINGS


--- BRLCAD_ENABLE_STRICT ---

Causes all compilation warnings for C code to be treated as errors.  This is now
the default for BRL-CAD source code, and developers should address issues
discovered by these flags whenever possible rather than disabling strict
mode.

Aliases:  ENABLE_STRICT, ENABLE_STRICT_COMPILE, ENABLE_STRICT_COMPILE_FLAGS


--- BRLCAD_EXTRADOCS ---

The core option that enables and disables building of BRL-CAD's DocBook
based documentation (includes manuals and man pages for commands, among
other things.)  Defaults to ON, but only HTML and MAN formats are enabled
by default - PDF must be enabled separately by use of this option or one
of its aliases.  Note that you may set environment variable APACHE_FOP
to point to your locally installed fop executable file (which on Linux is
usually a shell script with 0755 permissions).

Aliases:  ENABLE_DOCS, ENABLE_EXTRA_DOCS, ENABLE_DOCBOOK


--- BRLCAD_REGEX ---

Option for enabling and disabling compilation of the Regular
Expression Library provided with BRL-CAD's source distribution.
Default is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option
and testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.

Aliases:  ENABLE_REGEX


--- BRLCAD_ZLIB ---

Option for enabling and disabling compilation of the zlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_ZLIB, ENABLE_LIBZ


--- BRLCAD_LEMON ---

Option for enabling and disabling compilation of the lemon parser
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_LEMON


--- BRLCAD_RE2C ---

Option for enabling and disabling compilation of the re2c scanner
utility provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_RE2C


--- BRLCAD_PERPLEX ---

Option for enabling and disabling compilation of the perplex scanner
generator provided with BRL-CAD's source distribution.  Default is
AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.  perplex requires a working re2c.

Aliases:  ENABLE_PERPLEX


--- BRLCAD_XSLTPROC ---

Option for enabling and disabling compilation of the xsltproc XML
transformation utility provided with BRL-CAD's source distribution.
Used for DocBook documentation processing.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
Depends on BRLCAD_EXTRADOCS.

Aliases:  ENABLE_XSLTPROC


--- BRLCAD_XMLLINT ---

Option for enabling and disabling compilation of the xmllint XML
validation utility provided with BRL-CAD's source distribution.  Used
for DocBook documentation validation.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_XMLLINT


--- BRLCAD_TERMLIB ---

Option for enabling and disabling compilation of the termlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO. (Except when building with Visual Studio, where it is
disabled. Windows does not support the termlib API.)

Aliases:  ENABLE_TERMLIB


--- BRLCAD_PNG ---

Option for enabling and disabling compilation of the Portable Network
Graphics library provided with BRL-CAD's source distribution.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.

Aliases:  ENABLE_PNG


--- BRLCAD_UTAHRLE ---

Option for enabling and disabling compilation of the Utah Raster
Toolkit library provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_UTAHRLE


--- BRLCAD_TCL ---

Option for enabling and disabling compilation of the Tcl library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_TCL


--- BRLCAD_TK ---

Option for enabling and disabling compilation of the Tk library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the BRLCAD_TCL option and testing first for a system version if
BRLCAD_BUNDLED_LIBS is also AUTO. Option for enabling and disabling
compilation of the Tk graphics package for Tcl provided with BRL-CAD's
source distribution.  Default is AUTO, auto-enabling if the BRLCAD_TCL
option is set to BUNDLED and testing first for a system version if
BRLCAD_TCL is set to AUTO or SYSTEM.  If BRLCAD_TK is set to BUNDLED,
local copy is built even if a system version is present.  This option
also depends on BRLCAD_ENABLE_TK being ON.

Aliases:  ENABLE_TK


--- BRLCAD_ITCL ---

Option for enabling and disabling compilation of the IncrTcl package
for Tcl objects provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_ITCL is set to BUNDLED, local copy is built even if
a system version is present.

Aliases:  ENABLE_ITCL


--- BRLCAD_ITK ---

Option for enabling and disabling compilation of the IncrTcl itk
package for Tk objects provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_ITK is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_ITK


--- BRLCAD_TOGL ---

Option for enabling and disabling compilation of the Togl package for
Tcl/Tk OpenGL support provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TOGL is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
either BRLCAD_ENABLE_OPENGL or BRLCAD_ENABLE_TK are OFF.

Aliases:  ENABLE_TOGL


--- BRLCAD_IWIDGETS ---

Option for enabling and disabling compilation of the IWidgets Tk
widget package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_IWIDGETS is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_IWIDGETS


--- BRLCAD_TKHTML ---

Option for enabling and disabling compilation of the Tkhtml HTML
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKHTML is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_TKHTML


--- BRLCAD_TKPNG ---

Option for enabling and disabling compilation of the tkpng PNG image
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKPNG is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_TKPNG


--- BRLCAD_TKTABLE ---

Option for enabling and disabling compilation of the Tktable graphical
table widget package provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TKTABLE is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_TKTABLE


--- BRLCAD_TKTREECTRL ---

Option for enabling and disabling compilation of the TkTreeCtrl graphical
table widget package provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TKTREECTRL is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_TKTREECTRL


--- BRLCAD_TKDND ---

Option for enabling and disabling compilation of the TkDnD 
drag-and-drop widget provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TKDND is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_TKDND


--- BRLCAD_OPENNURBS ---

Option for enabling and disabling compilation of the openNURBS library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_OPENNURBS


--- BRLCAD_SCL ---

Option for enabling and disabling compilation of the NIST Step Class
Libraries provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_SCL, ENABLE_STEP, ENABLE_STEP_CLASS_LIBRARIES


--- BRLCAD_LIBVDS ---

Option for enabling and disabling compilation of the libvds triangle
simplification library provided with BRL-CAD's source code.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.

Aliases:  ENABLE_VDS



*** Note - Do not add or edit configuration option descriptions and alias
   lists in this file - those entries are auto-generated from information in
   the toplevel CMakeLists.txt file and src/other/CMakeLists.txt - any changes
   should be made in those files.  The CMake configuration process will
   automatically re-generate INSTALL with the new descriptions and alias
   information.
blob
data 11605
#!/bin/sh
#
# This is a simple script to translate autotools style
# configure options into CMake variables.  The resulting
# translation is then run as a CMake configure.

srcpath=$(dirname $0)
options="$srcpath"
while [ "$1" != "" ]
do
   case $1
   in
     --enable-all)                options="$options -DBRLCAD_BUNDLED_LIBS=ON";
                                  shift;;
     --disable-all)                options="$options -DBRLCAD_BUNDLED_LIBS=OFF";
                                  shift;;
     --enable-opengl)                options="$options -DBRLCAD_ENABLE_OPENGL=ON";
                                  shift;;
     --disable-opengl)                options="$options -DBRLCAD_ENABLE_OPENGL=OFF";
                                  shift;;
     --enable-runtime-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-runtime-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-run-time-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-run-time-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-runtime-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-runtime-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-run-time-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-run-time-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=ON";
                                  shift;;
     --disable-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=OFF";
                                  shift;;
     --enable-flags-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=ON";
                                  shift;;
     --disable-flags-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=OFF";
                                  shift;;
     --enable-debug-flags)                options="$options -DBRLCAD_FLAGS_DEBUG=ON";
                                  shift;;
     --disable-debug-flags)                options="$options -DBRLCAD_FLAGS_DEBUG=OFF";
                                  shift;;
     --enable-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=ON";
                                  shift;;
     --disable-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=OFF";
                                  shift;;
     --enable-compiler-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=ON";
                                  shift;;
     --disable-compiler-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=OFF";
                                  shift;;
     --enable-strict)                options="$options -DBRLCAD_ENABLE_STRICT=ON";
                                  shift;;
     --disable-strict)                options="$options -DBRLCAD_ENABLE_STRICT=OFF";
                                  shift;;
     --enable-strict-compile)                options="$options -DBRLCAD_ENABLE_STRICT=ON";
                                  shift;;
     --disable-strict-compile)                options="$options -DBRLCAD_ENABLE_STRICT=OFF";
                                  shift;;
     --enable-strict-compile-flags)                options="$options -DBRLCAD_ENABLE_STRICT=ON";
                                  shift;;
     --disable-strict-compile-flags)                options="$options -DBRLCAD_ENABLE_STRICT=OFF";
                                  shift;;
     --enable-docs)                options="$options -DBRLCAD_EXTRADOCS=ON";
                                  shift;;
     --disable-docs)                options="$options -DBRLCAD_EXTRADOCS=OFF";
                                  shift;;
     --enable-extra-docs)                options="$options -DBRLCAD_EXTRADOCS=ON";
                                  shift;;
     --disable-extra-docs)                options="$options -DBRLCAD_EXTRADOCS=OFF";
                                  shift;;
     --enable-docbook)                options="$options -DBRLCAD_EXTRADOCS=ON";
                                  shift;;
     --disable-docbook)                options="$options -DBRLCAD_EXTRADOCS=OFF";
                                  shift;;
     --enable-regex)                options="$options -DBRLCAD_REGEX=BUNDLED";
                                  shift;;
     --disable-regex)                options="$options -DBRLCAD_REGEX=SYSTEM";
                                  shift;;
     --enable-zlib)                options="$options -DBRLCAD_ZLIB=BUNDLED";
                                  shift;;
     --disable-zlib)                options="$options -DBRLCAD_ZLIB=SYSTEM";
                                  shift;;
     --enable-libz)                options="$options -DBRLCAD_ZLIB=BUNDLED";
                                  shift;;
     --disable-libz)                options="$options -DBRLCAD_ZLIB=SYSTEM";
                                  shift;;
     --enable-lemon)                options="$options -DBRLCAD_LEMON=BUNDLED";
                                  shift;;
     --disable-lemon)                options="$options -DBRLCAD_LEMON=SYSTEM";
                                  shift;;
     --enable-re2c)                options="$options -DBRLCAD_RE2C=BUNDLED";
                                  shift;;
     --disable-re2c)                options="$options -DBRLCAD_RE2C=SYSTEM";
                                  shift;;
     --enable-perplex)                options="$options -DBRLCAD_PERPLEX=BUNDLED";
                                  shift;;
     --disable-perplex)                options="$options -DBRLCAD_PERPLEX=SYSTEM";
                                  shift;;
     --enable-xsltproc)                options="$options -DBRLCAD_XSLTPROC=BUNDLED";
                                  shift;;
     --disable-xsltproc)                options="$options -DBRLCAD_XSLTPROC=SYSTEM";
                                  shift;;
     --enable-xmllint)                options="$options -DBRLCAD_XMLLINT=BUNDLED";
                                  shift;;
     --disable-xmllint)                options="$options -DBRLCAD_XMLLINT=SYSTEM";
                                  shift;;
     --enable-termlib)                options="$options -DBRLCAD_TERMLIB=BUNDLED";
                                  shift;;
     --disable-termlib)                options="$options -DBRLCAD_TERMLIB=SYSTEM";
                                  shift;;
     --enable-png)                options="$options -DBRLCAD_PNG=BUNDLED";
                                  shift;;
     --disable-png)                options="$options -DBRLCAD_PNG=SYSTEM";
                                  shift;;
     --enable-utahrle)                options="$options -DBRLCAD_UTAHRLE=BUNDLED";
                                  shift;;
     --disable-utahrle)                options="$options -DBRLCAD_UTAHRLE=SYSTEM";
                                  shift;;
     --enable-tcl)                options="$options -DBRLCAD_TCL=BUNDLED";
                                  shift;;
     --disable-tcl)                options="$options -DBRLCAD_TCL=SYSTEM";
                                  shift;;
     --enable-tk)                options="$options -DBRLCAD_TK=BUNDLED";
                                  shift;;
     --disable-tk)                options="$options -DBRLCAD_TK=SYSTEM";
                                  shift;;
     --enable-itcl)                options="$options -DBRLCAD_ITCL=BUNDLED";
                                  shift;;
     --disable-itcl)                options="$options -DBRLCAD_ITCL=SYSTEM";
                                  shift;;
     --enable-itk)                options="$options -DBRLCAD_ITK=BUNDLED";
                                  shift;;
     --disable-itk)                options="$options -DBRLCAD_ITK=SYSTEM";
                                  shift;;
     --enable-togl)                options="$options -DBRLCAD_TOGL=BUNDLED";
                                  shift;;
     --disable-togl)                options="$options -DBRLCAD_TOGL=SYSTEM";
                                  shift;;
     --enable-iwidgets)                options="$options -DBRLCAD_IWIDGETS=BUNDLED";
                                  shift;;
     --disable-iwidgets)                options="$options -DBRLCAD_IWIDGETS=SYSTEM";
                                  shift;;
     --enable-tkhtml)                options="$options -DBRLCAD_TKHTML=BUNDLED";
                                  shift;;
     --disable-tkhtml)                options="$options -DBRLCAD_TKHTML=SYSTEM";
                                  shift;;
     --enable-tkpng)                options="$options -DBRLCAD_TKPNG=BUNDLED";
                                  shift;;
     --disable-tkpng)                options="$options -DBRLCAD_TKPNG=SYSTEM";
                                  shift;;
     --enable-tktable)                options="$options -DBRLCAD_TKTABLE=BUNDLED";
                                  shift;;
     --disable-tktable)                options="$options -DBRLCAD_TKTABLE=SYSTEM";
                                  shift;;
     --enable-tktreectrl)                options="$options -DBRLCAD_TKTREECTRL=BUNDLED";
                                  shift;;
     --disable-tktreectrl)                options="$options -DBRLCAD_TKTREECTRL=SYSTEM";
                                  shift;;
     --enable-tkdnd)                options="$options -DBRLCAD_TKDND=BUNDLED";
                                  shift;;
     --disable-tkdnd)                options="$options -DBRLCAD_TKDND=SYSTEM";
                                  shift;;
     --enable-opennurbs)                options="$options -DBRLCAD_OPENNURBS=BUNDLED";
                                  shift;;
     --disable-opennurbs)                options="$options -DBRLCAD_OPENNURBS=SYSTEM";
                                  shift;;
     --enable-scl)                options="$options -DBRLCAD_SCL=BUNDLED";
                                  shift;;
     --disable-scl)                options="$options -DBRLCAD_SCL=SYSTEM";
                                  shift;;
     --enable-step)                options="$options -DBRLCAD_SCL=BUNDLED";
                                  shift;;
     --disable-step)                options="$options -DBRLCAD_SCL=SYSTEM";
                                  shift;;
     --enable-step-class-libraries)                options="$options -DBRLCAD_SCL=BUNDLED";
                                  shift;;
     --disable-step-class-libraries)                options="$options -DBRLCAD_SCL=SYSTEM";
                                  shift;;
     --enable-vds)                options="$options -DBRLCAD_LIBVDS=BUNDLED";
                                  shift;;
     --disable-vds)                options="$options -DBRLCAD_LIBVDS=SYSTEM";
                                  shift;;
     --prefix=*)   	          inputstr=$1;
				  options="$options -DCMAKE_INSTALL_PREFIX=${inputstr#--prefix=}";
				  shift;;
     *) 	   	          echo "Warning: unknown option $1";
				  shift;;
   esac
done
echo cmake $options
cmake $options
blob
data 45101
#-----------------------------------------------------------------------
# Local Copies of External Libraries
#
# BRL-CAD depends on a variety of external libraries and tools -
# rather than fail if those requirements are not satisfied, we build
# local copies at need.
#
# There are three overall approaches to the handling of these
# dependencies:
#
# 1.  Auto - detect system libraries and use them if suitable,
#     otherwise build and use the local copy.  This is the default
#     approach.
#
# 2.  Bundled - regardless of system conditions, build and use all
#     bundled libraries.
#
# 3.  System - fail to build if the system libraries do not satisfy
#     requirements.  This is primarily useful for distributions that
#     want to ensure packages are using external libraries.
#
# In addition to the broad toplevel control, individual libraries can
# also be overridden - for example, if the toplevel setting is for
# Bundled libs, it is still possible to request a system library in
# individual cases.
#
#-----------------------------------------------------------------------

# Quiet all warnings in this directory
if(BRLCAD_DISABLE_SRC_OTHER_WARN)
  add_definitions(-w)
endif(BRLCAD_DISABLE_SRC_OTHER_WARN)

# Ideally we wouldn't need this, but in a few cases we're using
# BRL-CAD's include dirs.
include_directories(
  ${BRLCAD_BINARY_DIR}/include
  ${BRLCAD_SOURCE_DIR}/include
  )

# Most third party items have a list calling out files for distcheck -
# these are stored in files in the dlists directory.  Ignore that
# directory for distcheck
file(GLOB dlists "*.dist")
FOREACH(ITEM ${dlists})
  get_filename_component(dlist ${ITEM} NAME)
  CMAKEFILES(${dlist})
ENDFOREACH(ITEM ${dlists})

# For lower build levels, some of the third party components are not
# needed.  define some variables we can use for testing.
set(BRLCAD_LEVEL2 0)
set(BRLCAD_LEVEL3 0)
if(NOT BRLCAD_ENABLE_TARGETS)
  set(BRLCAD_LEVEL2 1)
  set(BRLCAD_LEVEL3 1)
else(NOT BRLCAD_ENABLE_TARGETS)
  if(${BRLCAD_ENABLE_TARGETS} GREATER 1)
    set(BRLCAD_LEVEL2 1)
  endif(${BRLCAD_ENABLE_TARGETS} GREATER 1)
  if(${BRLCAD_ENABLE_TARGETS} GREATER 2)
    set(BRLCAD_LEVEL3 1)
  endif(${BRLCAD_ENABLE_TARGETS} GREATER 2)
endif(NOT BRLCAD_ENABLE_TARGETS)

# At the start, clear the src/other subdirs list so repeated
# configures will correctly add the required directories
set(SRC_OTHER_ADDED_DIRS "" CACHE STRING "initialize 3rd party sub-directories list" FORCE)

#-----------------------------------------------------------------------------
# Load some CMake macros to handle the special case of third party libraries.
include(${BRLCAD_CMAKE_DIR}/ThirdParty.cmake)


# libregex library -  often needed by tools, so do this one first.
set(regex_ALIASES ENABLE_REGEX)
set(regex_DESCRIPTION "
Option for enabling and disabling compilation of the Regular
Expression Library provided with BRL-CAD's source distribution.
Default is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option
and testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.
")
THIRD_PARTY(regex libregex "" regex_ALIASES regex_DESCRIPTION)
BRLCAD_INCLUDE_FILE(regex.h HAVE_REGEX_H)

CHECK_LIBRARY_EXISTS(c regcomp "" HAVE_LIBC_REGEX)
if(BUILD_SHARED_LIBS AND HAVE_LIBC_REGEX AND "${BRLCAD_REGEX}" MATCHES "BUNDLED")
  # Our tests indicate that the system libc defines regex symbols, but
  # we're still building with our local libregex.
  #
  # Platform differences in default linker behavior make it difficult
  # to guarantee that our libregex symbols will override libc. We'll
  # avoid the issue by renaming our libregex symbols to be
  # incompatible with libc.

  # First we add definitions to our config file to rename all of the
  # regex function calls in our first-party code.
  CONFIG_H_APPEND(BRLCAD "#define regcomp  libregex_regcomp\n")
  CONFIG_H_APPEND(BRLCAD "#define regerror libregex_regerror\n")
  CONFIG_H_APPEND(BRLCAD "#define regexec  libregex_regexec\n")
  CONFIG_H_APPEND(BRLCAD "#define regfree  libregex_regfree\n")

  # Second, we add the same definitions to libregex to rename the
  # function declarations and definitions to match the calls.
  #
  # Note that this is necessary despite the fact that libregex/regex.h
  # includes common.h. Our config file is intentionally omitted from
  # common.h until after the third party dirs are processed, so the
  # above definitions don't affect libregex.
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regcomp=libregex_regcomp)
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regerror=libregex_regerror)
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regexec=libregex_regexec)
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regfree=libregex_regfree)
endif(BUILD_SHARED_LIBS AND HAVE_LIBC_REGEX AND "${BRLCAD_REGEX}" MATCHES "BUNDLED")

# Same deal for zlib Library - common requirement, deal with it up front
set(zlib_ALIASES ENABLE_ZLIB ENABLE_LIBZ)
set(zlib_DESCRIPTION "
Option for enabling and disabling compilation of the zlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(zlib libz "" zlib_ALIASES zlib_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libz/CTestTestfile.cmake)

#-----------------------------------------------------------------------------

#---------------------------------------------------------------------------------
# Local Copies of Tools
#---------------------------------------------------------------------------------

# Because we sometimes need to override system versions of tools, it
# is essential that the variables containing the executable to be run
# for each of the following tools use full paths - if just the name of
# the target is used, there is a chance that name is the same as the
# executable name itself.  In that case, if the system executable is
# in the path, it may get called instead of resolving to the compiled
# exectuable associated with the CMake target.  (Information from the
# CMake devs indicates this is not expected behavior, but at some
# point during the development efforts a problem apparently related to
# this came up.)  On single configuration systems we can reference
# specify the full path to the binary directory at CMake configure
# time, but this isn't possible for multi-configuration systems like
# Visual Studio since that path changes at run-time.  For those
# situations, CMake provides a variable CMAKE_CFG_INTDIR that will
# insert the correct logic for config-dependent paths.

# For those wanting to use a system version of the LEMON parser
# generator from sqlite, remember that the presence of /usr/bin/lemon
# is not enough.  LEMON needs a template file, lempar.c, and by
# default it needs it in the same directory as /usr/bin/lemon.  The
# typical approach to avoiding that requirement is to patch lemon,
# like this Gentoo ebuild:
#
# http://gentoo-overlays.zugaina.org/gentoo-zh/portage/dev-util/lemon/
#
# LEMON packages for other major Linux/BSD distros will do the same.
# BRL-CAD's FindLEMON.cmake macros will look for the template file in
# the executable directory first, and if not there will check in
# /usr/share/lemon (the location used by several distributions.)  If
# your distribution has a working lemon with the lempar.c template
# file in a custom location, specify the full path to the template
# with the variable LEMON_TEMPLATE - something like:
#
# cmake .. -DLEMON_TEMPLATE=/etc/lemon/lempar.c
#
# This is not to tell LEMON what template to use - that information is
# usually hardcoded in LEMON itself - but to let FindLEMON.cmake know
# there is a working LEMON installation.
set(lemon_ALIASES ENABLE_LEMON)
set(lemon_DESCRIPTION "
Option for enabling and disabling compilation of the lemon parser
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
if("${BRLCAD_BUNDLED_LIBS}" STREQUAL "BUNDLED" OR "${BRLCAD_LEMON}" MATCHES "BUNDLED")
  set(LEMON_TEMPLATE "${BRLCAD_SOURCE_DIR}/src/other/lemon/lempar.c")
endif("${BRLCAD_BUNDLED_LIBS}" STREQUAL "BUNDLED" OR "${BRLCAD_LEMON}" MATCHES "BUNDLED")
THIRD_PARTY_EXECUTABLE(lemon lemon "BRLCAD_LEVEL2" lemon_ALIASES lemon_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/lemon/Makefile)
# Unless some parent logic has already defined the macro, we need to
# load LEMON_Util to be able to define LEMON targets.
if(NOT COMMAND LEMON_TARGET)
  include(${BRLCAD_CMAKE_DIR}/LEMON_Util.cmake)
endif(NOT COMMAND LEMON_TARGET)

set(re2c_ALIASES ENABLE_RE2C)
set(re2c_DESCRIPTION "
Option for enabling and disabling compilation of the re2c scanner
utility provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY_EXECUTABLE(re2c re2c "BRLCAD_LEVEL2" re2c_ALIASES re2c_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/re2c/Makefile)

# Unless some parent logic has already defined the macro, we need to
# load RE2C_Util to be able to define RE2C targets.

if(NOT COMMAND RE2C_TARGET)
  include(${BRLCAD_SOURCE_DIR}/misc/CMake/RE2C_Util.cmake)
endif(NOT COMMAND RE2C_TARGET)

# Perplex is set up as a src/other sub-build, but at this time it is
# entirely a BRL-CAD effort and not distributed or maintained as its
# own project.

# For all BRL-CAD projects, we will use the perplex template in
# src/other/perplex
SET(PERPLEX_TEMPLATE "${CMAKE_CURRENT_SOURCE_DIR}/perplex/perplex_template.c" CACHE STRING "Perplex template file" FORCE)

set(perplex_ALIASES ENABLE_PERPLEX)
set(perplex_DESCRIPTION "
Option for enabling and disabling compilation of the perplex scanner
generator provided with BRL-CAD's source distribution.  Default is
AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.  perplex requires a working re2c.
")
THIRD_PARTY_EXECUTABLE(perplex perplex "BRLCAD_LEVEL2" perplex_ALIASES perplex_DESCRIPTION NOSYS)
# Unless some parent logic has already defined the macro, we need to
# load PERPLEX_Util to be able to define PERPLEX targets.
if(NOT COMMAND PERPLEX_TARGET)
  include(${BRLCAD_SOURCE_DIR}/misc/CMake/PERPLEX_Util.cmake)
endif(NOT COMMAND PERPLEX_TARGET)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/perplex/Makefile)

# libxml and libxslt tools for DocBook processing.  We build just
# enough library support to get these two tools working.
set(xsltproc_ALIASES ENABLE_XSLTPROC)
set(xsltproc_DESCRIPTION "
Option for enabling and disabling compilation of the xsltproc XML
transformation utility provided with BRL-CAD's source distribution.
Used for DocBook documentation processing.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
Depends on BRLCAD_EXTRADOCS.
")
THIRD_PARTY_EXECUTABLE(xsltproc xmltools "BRLCAD_EXTRADOCS;BRLCAD_LEVEL3" xsltproc_ALIASES xsltproc_DESCRIPTION)

# Used only when validating XML for schema compliance
# (BRLCAD_EXTRADOCS_VALIDATE must be on to use this, although it is compiled
# regardless if the xmltools subdirectory build is added.)
set(xmllint_ALIASES ENABLE_XMLLINT)
set(xmllint_DESCRIPTION "
Option for enabling and disabling compilation of the xmllint XML
validation utility provided with BRL-CAD's source distribution.  Used
for DocBook documentation validation.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY_EXECUTABLE(xmllint xmltools "BRLCAD_EXTRADOCS_VALIDATE;BRLCAD_LEVEL3" xmllint_ALIASES xmllint_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/xmltools/include)

# --------------------------------------------------------------------
# Third Party Sources
# --------------------------------------------------------------------
# Ignore the boost subdir - it's only used for the boost headers and
# is not compiled
CMAKEFILES(boost)

# The incrtTcl subdirectory isn't directly referenced, but its
# subdirectories are used - mark incrTcl as ignored
CMAKEFILES(incrTcl)

# Ignore the osl subdir
CMAKEFILES(osl)

# libtermlib Library Only on WIN32 will the combination of the build
# search tests and libtermlib fail to find a valid term, so set
# variables accordingly
if(NOT WIN32)
  set(HAVE_TERMLIB ON CACHE BOOL "Have some termlib" FORCE)
ELSE(NOT WIN32)
  set(BRLCAD_TERMLIB_BUILD "System" CACHE STRING "Disable libtermlib build on WIN32." FORCE)
  mark_as_advanced(BRLCAD_TERMLIB_BUILD)
  set(HAVE_TERMLIB OFF CACHE BOOL "Have some termlib" FORCE)
endif(NOT WIN32)
mark_as_advanced(HAVE_TERMLIB)

set(termlib_ALIASES ENABLE_TERMLIB)
set(termlib_DESCRIPTION "
Option for enabling and disabling compilation of the termlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO. (Except when building with Visual Studio, where it is
disabled. Windows does not support the termlib API.)
")
THIRD_PARTY(termlib libtermlib "HAVE_TERMLIB;BRLCAD_LEVEL2" termlib_ALIASES termlib_DESCRIPTION)
if(BRLCAD_TERMLIB_BUILD)
  set(HAVE_TERMCAP_H ON CACHE BOOL "src/other termlib is on" FORCE)
  mark_as_advanced(HAVE_TERMCAP_H)
endif(BRLCAD_TERMLIB_BUILD)

# libpng Library - Checks for ZLIB, so need to handle libpng AFTER
# zlib to set the variables if using a local copy of zlib.  If not
# using a local copy of zlib, FindZLIB results will be identical in
# both cases so there is no danger of harming the libpng setup.  The
# PNG CMake system needs some options set and some variables
# translated to fit BRL-CAD's standard assumptions, so handle that
# here as well.  BRL-CAD needs PNG's IO - turn it on (i.e. turn off
# the disabling flags)

set(PNG_NO_CONSOLE_IO OFF CACHE BOOL "Option to disable Console IO in PNG" FORCE)
mark_as_advanced(PNG_NO_CONSOLE_IO)
set(PNG_NO_STDIO OFF CACHE BOOL "Option to disable STDIO in PNG" FORCE)
mark_as_advanced(PNG_NO_STDIO)
set(SKIP_INSTALL_EXPORT ON CACHE BOOL "We dont't want export for this application" FORCE)
mark_as_advanced(SKIP_INSTALL_EXPORT)
set(PNG_MAN_DIR ${MAN_DIR} CACHE STRING "Set PNG_MAN_DIR to the global MAN_DIR" FORCE)
mark_as_advanced(PNG_MAN_DIR)
set(CMAKE_INSTALL_LIBDIR ${LIB_DIR})
set(png_ALIASES ENABLE_PNG)
set(png_DESCRIPTION "
Option for enabling and disabling compilation of the Portable Network
Graphics library provided with BRL-CAD's source distribution.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.
")
THIRD_PARTY(png libpng "BRLCAD_LEVEL2" png_ALIASES png_DESCRIPTION)
if(BRLCAD_PNG_BUILD)
  # PNG_LIB_NAME doesn't automatically propagate to toplevel due to
  # scoping of CMake variables - use get_directory_property to recover
  # the value and place it in the CACHE

  get_directory_property(PNG_LIBRARY DIRECTORY libpng DEFINITION PNG_LIB_NAME)
  set(PNG_LIBRARY "${PNG_LIBRARY}" CACHE STRING "libpng name for targets" FORCE)
ELSE(BRLCAD_PNG_BUILD)
  # The PNG CMake file seems to set PNG_PNG_INCLUDE_DIR rather than
  # PNG_INCLUDE_DIR, so a generic macro won't pick up the setting -
  # handle it here.

  set(PNG_INCLUDE_DIR ${PNG_PNG_INCLUDE_DIR} CACHE STRING "PNG include directory" FORCE)
endif(BRLCAD_PNG_BUILD)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/CTestTestfile.cmake)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng.pc)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng-config)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng${CMAKE_SHARED_LIBRARY_SUFFIX})
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng${CMAKE_STATIC_LIBRARY_SUFFIX})
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng.pc)
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng-config)
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng${CMAKE_SHARED_LIBRARY_SUFFIX})
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng${CMAKE_STATIC_LIBRARY_SUFFIX})
# Other PNG options to mark as advanced
mark_as_advanced(PNGARG)
mark_as_advanced(PNG_DEBUG)
mark_as_advanced(PNG_SHARED)
mark_as_advanced(PNG_STATIC)
mark_as_advanced(PNG_TESTS)
mark_as_advanced(uname_executable)


# libutahrle Library - The directory to perform ADD_SUBDIRECTORY on
# and the include directory for utahrle are different, so override the
# macro's setting of UTAHRLE_INCLUDE_DIR here.

set(utahrle_ALIASES ENABLE_UTAHRLE)
set(utahrle_DESCRIPTION "
Option for enabling and disabling compilation of the Utah Raster
Toolkit library provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(utahrle libutahrle "BRLCAD_LEVEL3" utahrle_ALIASES utahrle_DESCRIPTION NOSYS)
if(BRLCAD_UTAHRLE_BUILD)
  set(UTAHRLE_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/libutahrle/include" CACHE STRING "directory with rle.h header" FORCE)
  set(BRLCAD_UTAHRLE_INCLUDE_DIR "${UTAHRLE_INCLUDE_DIR}" CACHE STRING "directory with rle.h header" FORCE)
  mark_as_advanced(UTAHRLE_INCLUDE_DIR)
  mark_as_advanced(BRLCAD_UTAHRLE_INCLUDE_DIR)
endif(BRLCAD_UTAHRLE_BUILD)


# URTToolkit - Programs, not a library - needs libutahrle, but the
# "check for system install" logic will be different here.  Ignore for
# now, revisit later.

if(BRLCAD_LEVEL3)
  add_subdirectory(URToolkit)
endif(BRLCAD_LEVEL3)
include(${CMAKE_CURRENT_SOURCE_DIR}/URToolkit.dist)
CMAKEFILES_IN_DIR(URToolkit_ignore_files URToolkit)

# Tcl/Tk presents a number of complexities for BRL-CAD and CMake.
# BRL-CAD requires far more knowledge of the details of a Tcl/Tk
# installation than most programs, which unfortunately means the
# standard FindTCL.cmake is not sufficient. We have our own FindTCL
# routine which handles Tcl/Tk and its stubs, so trigger this using
# the THIRD_PARTY macro for TCL.

include(${BRLCAD_SOURCE_DIR}/misc/CMake/TCL_PKGINDEX.cmake)

# Set Tcl/Tk requirements for BRL-CAD so FindTCL.cmake knows what to reject
set(TCL_PATH_NOMATCH_PATTERNS "/usr/brlcad;brlcad-install;${CMAKE_INSTALL_PREFIX}" CACHE STRING "Paths to avoid when looking for tcl/tk" FORCE)
set(TCL_MIN_VERSION "8.5" CACHE STRING "Minimum acceptable Tcl/Tk version" FORCE)

if(BRLCAD_ENABLE_TK)
  set(TCL_REQUIRE_TK 1)
ELSE(BRLCAD_ENABLE_TK)
  set(TCL_REQUIRE_TK 0)
endif(BRLCAD_ENABLE_TK)

set(tcl_ALIASES ENABLE_TCL)
set(tcl_DESCRIPTION "
Option for enabling and disabling compilation of the Tcl library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.
")

THIRD_PARTY(tcl tcl "" tcl_ALIASES tcl_DESCRIPTION)
if(BRLCAD_TCL_BUILD)
  # Set the variables ourselves since FindTCL.cmake doesn't know about our build
  set(TCL_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/tcl)
  set(TCL_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
  set(TCL_LIBRARY tcl CACHE STRING "TCL_LIBRARY" FORCE)
  set(TCL_LIBRARIES tcl CACHE STRING "TCL_LIBRARY" FORCE)
  set(TCL_CONF_PREFIX "NONE-CMake" CACHE STRING "TCL_CONF_PREFIX" FORCE)
  set(TCL_STUB_LIBRARY tclstub CACHE STRING "TCL_LIBRARY" FORCE)
  set(TCL_STUB_LIBRARIES tclstub CACHE STRING "TCL_LIBRARY" FORCE)
  get_directory_property(TCL_INCLUDE_DIRS DIRECTORY tcl DEFINITION TCL_INCLUDE_DIRS)
  set(TCL_INCLUDE_DIRS "${TCL_INCLUDE_DIRS}" CACHE STRING "Tcl include paths" FORCE)
  set(TCL_INCLUDE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/tcl/generic" CACHE STRING "Tcl include path" FORCE)
  set(TCL_TCLSH_EXECUTABLE tclsh CACHE STRING "Tcl shell" FORCE)
  set(TCL_TCLSH tclsh CACHE STRING "Tcl shell" FORCE)
  get_directory_property(TCL_VERSION_MAJOR DIRECTORY tcl DEFINITION TCL_VERSION_MAJOR)
  set(TCL_VERSION_MAJOR "${TCL_VERSION_MAJOR}" CACHE STRING "Tcl MAJOR version" FORCE)
  get_directory_property(TCL_VERSION_MINOR DIRECTORY tcl DEFINITION TCL_VERSION_MINOR)
  set(TCL_VERSION_MINOR "${TCL_VERSION_MINOR}" CACHE STRING "Tcl MINOR version" FORCE)
  CONFIG_H_APPEND(BRLCAD "#define HAVE_TCL_H 1\n")
  CONFIG_H_APPEND(BRLCAD "#define TCL_SYSTEM_INITTCL_PATH \"\"\n")
  include(${CMAKE_CURRENT_SOURCE_DIR}/tcl.dist)
  CMAKEFILES_IN_DIR(tcl_ignore_files tcl)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/Makefile)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/man1)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/man3)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/mann)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/library/Makefile)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tcl8)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tcl8.5)
ELSE(BRLCAD_TCL_BUILD)
  if(${TCL_TCLSH_EXECUTABLE})
    BRLCAD_INCLUDE_FILE(tcl.h HAVE_TCL_H)
    # We're going to need the path to the system init.tcl for btclsh and bwish
    set(inittcl_script "
set filename \"${CMAKE_BINARY_DIR}/CMakeTmp/tcl_inittcl\"
set fileID [open $filename \"w\"]
puts $fileID $auto_path
close $fileID
exit
")
    set(inittcl_scriptfile "${CMAKE_BINARY_DIR}/CMakeTmp/tcl_inittcl.tcl")
    file(WRITE ${inittcl_scriptfile} ${inittcl_script})
    EXEC_PROGRAM(${TCL_TCLSH_EXECUTABLE} ARGS ${inittcl_scriptfile} OUTPUT_VARIABLE EXECOUTPUT)
    file(READ ${CMAKE_BINARY_DIR}/CMakeTmp/tcl_inittcl tcl_inittcl_raw)
    STRING(REGEX REPLACE "\n" "" tcl_inittcl_paths_1 ${tcl_inittcl_raw})
    STRING(REGEX REPLACE " " ";" tcl_inittcl_paths ${tcl_inittcl_paths_1})
    FIND_PATH(tcl_inittcl NAMES init.tcl PATHS ${tcl_inittcl_paths})
    mark_as_advanced(tcl_inittcl)
    CONFIG_H_APPEND(BRLCAD "#define TCL_SYSTEM_INITTCL_PATH \"${tcl_inittcl}\"\n")
  endif(${TCL_TCLSH_EXECUTABLE})
endif(BRLCAD_TCL_BUILD)
mark_as_advanced(TCL_COMPILE_DEBUG)
mark_as_advanced(TCL_COMPILE_STATS)
mark_as_advanced(TCL_DEBUG)
mark_as_advanced(TCL_ENABLE_64BIT)
mark_as_advanced(TCL_ENABLE_DLL_UNLOADING)
mark_as_advanced(TCL_ENABLE_LANGINFO)
mark_as_advanced(TCL_ENABLE_LOAD)
mark_as_advanced(TCL_OPTIMIZED)
mark_as_advanced(TCL_THREADS)
mark_as_advanced(TCL_TIMEZONE_DATA)
mark_as_advanced(M_LIBRARY)

# Depending on the Tcl/Tk results, look for packages required by BRL-CAD.  If
# building local Tcl/Tk, go ahead and enable all the packages as well - otherwise,
# check the found Tcl/Tk and enable what it doesn't supply.  If doing a non-graphical
# build, only compile extensions that don't use Tk.
include(${BRLCAD_CMAKE_DIR}/ThirdParty_TCL.cmake)

# The first package to settle is Tk itself
set(tk_ALIASES ENABLE_TK)
set(tk_DESCRIPTION "
Option for enabling and disabling compilation of the Tk library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the BRLCAD_TCL option and testing first for a system version if
BRLCAD_BUNDLED_LIBS is also AUTO. Option for enabling and disabling
compilation of the Tk graphics package for Tcl provided with BRL-CAD's
source distribution.  Default is AUTO, auto-enabling if the BRLCAD_TCL
option is set to BUNDLED and testing first for a system version if
BRLCAD_TCL is set to AUTO or SYSTEM.  If BRLCAD_TK is set to BUNDLED,
local copy is built even if a system version is present.  This option
also depends on BRLCAD_ENABLE_TK being ON.
")
THIRD_PARTY_TCL_PACKAGE(Tk tk "${TCL_TCLSH_EXECUTABLE}" "tcl" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL2" "tk" tk_ALIASES tk_DESCRIPTION)
if(BRLCAD_TK_BUILD)
  # Set the variables ourselves since FindTCL.cmake doesn't know about our build
  set(TCL_TK_LIBRARY tk CACHE STRING "TCL_TK_LIBRARY" FORCE)
  set(TCL_TK_CONF_PREFIX "NONE-CMake" CACHE STRING "TCL_TK_CONF_PREFIX" FORCE)
  set(TCL_LIBRARIES ${TCL_LIBRARIES} tk CACHE STRING "TCL_LIBRARIES" FORCE)
  set(TK_LIBRARY tk CACHE STRING "TK_LIBRARY" FORCE)
  set(TCL_STUB_LIBRARIES tkstub ${TCL_STUB_LIBRARIES} CACHE STRING "TCL_TK_STUBLIBRARIES" FORCE)
  set(TCL_TK_STUB_LIBRARY tkstub CACHE STRING "TCL_TK_STUB_LIBRARY" FORCE)
  set(TK_STUB_LIBRARY tkstub CACHE STRING "TK_STUB_LIBRARY" FORCE)
  set(TK_INCLUDE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/tk/generic" CACHE STRING "Tk include path" FORCE)
  set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${TK_INCLUDE_PATH} CACHE STRING "Tcl include paths" FORCE)
  if(WIN32)
    set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/tk/win ${CMAKE_CURRENT_SOURCE_DIR}/tk/xlib CACHE STRING "Tcl include paths" FORCE)
  endif(WIN32)
  set(TCL_WISH_EXECUTABLE wish CACHE STRING "Tk shell" FORCE)
  set(TK_WISH wish CACHE STRING "Tk shell" FORCE)
  if(WIN32)
    set(TK_SYSTEM_GRAPHICS "win32" CACHE STRING "Tk system graphics" FORCE)
  ELSEif(APPLE)
    if(OPENGL_USE_AQUA)
      set(TK_SYSTEM_GRAPHICS "aqua" CACHE STRING "Tk system graphics" FORCE)
    ELSE(OPENGL_USE_AQUA)
      set(TK_SYSTEM_GRAPHICS "x11" CACHE STRING "Tk system graphics" FORCE)
    endif(OPENGL_USE_AQUA)
  ELSEif(UNIX)
    set(TK_SYSTEM_GRAPHICS "x11" CACHE STRING "Tk system graphics" FORCE)
  endif(WIN32)
  CONFIG_H_APPEND(BRLCAD "#define HAVE_TK_H 1\n")
  mark_as_advanced(TK-ENABLE_FREETYPE)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/Makefile)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/man1)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/man3)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/mann)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/library/Makefile)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tk8.5)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tk8.5.13)
ELSE(BRLCAD_TK_BUILD)
  if(BRLCAD_ENABLE_TK)
    BRLCAD_INCLUDE_FILE(tk.h HAVE_TK_H)
  endif(BRLCAD_ENABLE_TK)
endif(BRLCAD_TK_BUILD)
mark_as_advanced(TK_INCLUDE_PATH)
mark_as_advanced(TK_LIBRARY)
mark_as_advanced(TK_STUB_LIBRARY)
mark_as_advanced(TK_SYSTEM_GRAPHICS)
mark_as_advanced(TK_WISH)
mark_as_advanced(TK_ENABLE_XFT)

# Now that Tcl/Tk is settled, define the HAVE_TK flag for the config.h
# file

if(BRLCAD_ENABLE_TK)
  set(HAVE_TK 1 CACHE STRING "C level Tk flag" FORCE)
  CONFIG_H_APPEND(BRLCAD "#cmakedefine HAVE_TK\n")
ELSE(BRLCAD_ENABLE_TK)
  set(HAVE_TK 0 CACHE STRING "C level Tk flag" FORCE)
endif(BRLCAD_ENABLE_TK)
mark_as_advanced(HAVE_TK)

# Tcl/Tk extensions need a variety of settings provided for them -
# take care of those here.  Because system Tcl/Tk installations are
# not guaranteed to have what is needed in the way of headers, go
# ahead and assign includedir settings based on the local sources even
# if system versions are enabled.  Ugly, but an unfortunate
# consequence of current Tcl/Tk coding styles

set(TCL_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/tcl)
set(TK_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/tk)
set(ITCL_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/incrTcl/itcl)
if(WIN32)
  set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/tcl/generic ${CMAKE_CURRENT_SOURCE_DIR}/tcl/win ${CMAKE_CURRENT_SOURCE_DIR}/tcl/libtommath)
  set(TK_INCLUDE_PATH ${TK_INCLUDE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/tk/generic ${CMAKE_CURRENT_SOURCE_DIR}/tk/xlib ${CMAKE_CURRENT_SOURCE_DIR}/tk/win ${CMAKE_CURRENT_SOURCE_DIR}/tk/bitmaps)
ELSE(WIN32)
  set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/tcl/generic ${CMAKE_CURRENT_SOURCE_DIR}/tcl/unix ${CMAKE_CURRENT_SOURCE_DIR}/tcl/libtommath)
  set(TK_INCLUDE_PATH ${TK_INCLUDE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/tk/generic ${CMAKE_CURRENT_SOURCE_DIR}/tk/unix ${CMAKE_CURRENT_SOURCE_DIR}/tk/bitmaps)
endif(WIN32)
set(ITCL_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/incrTcl/itcl/generic)
if(BRLCAD_TCL_BUILD)
  set(TCL_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
ELSE(BRLCAD_TCL_BUILD)
  get_filename_component(TCL_BIN_PREFIX ${TCL_LIBRARY} PATH)
endif(BRLCAD_TCL_BUILD)
if(BRLCAD_ENABLE_TK)
  if(BRLCAD_TK_BUILD)
    set(TK_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
    get_directory_property(TK_X11_INCLUDE_DIRS DIRECTORY tk DEFINITION TK_X11_INCLUDE_DIRS)
  ELSE(BRLCAD_TK_BUILD)
    if(TCL_TK_LIBRARY)
      get_filename_component(TK_BIN_PREFIX ${TCL_TK_LIBRARY} PATH)
    endif(TCL_TK_LIBRARY)
    if(X11_INCLUDE_DIR)
      set(TK_X11_INCLUDE_DIRS ${X11_INCLUDE_DIR})
    endif(X11_INCLUDE_DIR)
    if(X11_Xft_INCLUDE_PATH)
      set(TK_X11_INCLUDE_DIRS ${TK_X11_INCLUDE_DIRS}
	${X11_Xft_INCLUDE_PATH})
    endif(X11_Xft_INCLUDE_PATH)
    if(X11_Xrender_INCLUDE_PATH)
      set(TK_X11_INCLUDE_DIRS ${TK_X11_INCLUDE_DIRS}
	${X11_Xrender_INCLUDE_PATH})
    endif(X11_Xrender_INCLUDE_PATH)
    if(X11_Xscreensaver_INCLUDE_PATH)
      set(TK_X11_INCLUDE_DIRS ${TK_X11_INCLUDE_DIRS}
	${X11_Xscreensaver_INCLUDE_PATH})
    endif(X11_Xscreensaver_INCLUDE_PATH)
  endif(BRLCAD_TK_BUILD)
endif(BRLCAD_ENABLE_TK)


# First up, look for IncrTcl's Itcl.
set(itcl_ALIASES ENABLE_ITCL)
set(itcl_DESCRIPTION "
Option for enabling and disabling compilation of the IncrTcl package
for Tcl objects provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_ITCL is set to BUNDLED, local copy is built even if
a system version is present.
")
THIRD_PARTY_TCL_PACKAGE(Itcl incrTcl/itcl "${TCL_TCLSH_EXECUTABLE}" "tcl" "BRLCAD_LEVEL2" "itcl" itcl_ALIASES itcl_DESCRIPTION)
if(BRLCAD_ITCL_BUILD)
  set(ITCL_LIBRARY itcl CACHE STRING "ITCL_LIBRARY" FORCE)
  set(ITCL_STUB_LIBRARY itclstub CACHE STRING "ITCL_STUB_LIBRARY" FORCE)
  get_directory_property(ITCL_INCLUDE_DIRS DIRECTORY incrTcl/itcl DEFINITION ITCL_INCLUDE_DIRS)
  set(ITCL_INCLUDE_DIRS "${ITCL_INCLUDE_DIRS}" CACHE STRING "Itcl include paths" FORCE)
  set(ITCL_VERSION "3.4" CACHE STRING "ITCL_VERSION" FORCE)
  set(ITCL_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/incrTcl/itcl/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/itcl3.4)
ELSE(BRLCAD_ITCL_BUILD)
  # We have Itcl package AND Itcl library - we're good.
  set(ITCL_VERSION "${ITCL_PACKAGE_VERSION}" CACHE STRING "ITCL_VERSION" FORCE)
  set(ITCL_LIBRARY ${ITCL_LIBRARY} CACHE STRING "ITCL_LIBRARY" FORCE)
  if(ITCL_LIBRARY)
    get_filename_component(ITCL_BIN_PREFIX ${ITCL_LIBRARY} PATH)
  endif(ITCL_LIBRARY)
endif(BRLCAD_ITCL_BUILD)
CONFIG_H_APPEND(BRLCAD "#cmakedefine ITCL_VERSION	\"${ITCL_VERSION}\"\n")
mark_as_advanced(ITCL_LIBRARY)
mark_as_advanced(ITCL_STUB_LIBRARY)
mark_as_advanced(ITCL_INCLUDE_DIRS)
mark_as_advanced(ITCL_VERSION)

# Look for IncrTcl's Itk.
set(itk_ALIASES ENABLE_ITK)
set(itk_DESCRIPTION "
Option for enabling and disabling compilation of the IncrTcl itk
package for Tk objects provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_ITK is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Itk incrTcl/itk "${TCL_WISH_EXECUTABLE}" "tcl;itcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "itk" itk_ALIASES itk_DESCRIPTION)
if(BRLCAD_ITK_BUILD)
  # does not handle C library settings.
  set(ITK_LIBRARY itk CACHE STRING "ITK_LIBRARY" FORCE)
  set(ITK_VERSION "3.3" CACHE STRING "ITK_VERSION" FORCE)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/incrTcl/itk/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/itk3.4)
ELSE(BRLCAD_ITK_BUILD)
  # We have Itcl/Itk packages AND Itcl/Itk libraries - we're good.
  set(ITK_VERSION "${ITCL_VERSION}" CACHE STRING "ITK_VERSION" FORCE)
  set(ITK_LIBRARY ${ITK_LIBRARY} CACHE STRING "ITK_LIBRARY" FORCE)
  if(ITK_LIBRARY)
    get_filename_component(ITK_BIN_PREFIX ${ITK_LIBRARY} PATH)
  endif(ITK_LIBRARY)
endif(BRLCAD_ITK_BUILD)
mark_as_advanced(ITK_VERSION)
mark_as_advanced(ITK_LIBRARY)

# For now only turn on Togl for X11, but will need it everywhere
# eventually.  Will need some logic to both look for package require
# and the C library, as both APIs will be needed.

set(togl_ALIASES ENABLE_TOGL)
set(togl_DESCRIPTION "
Option for enabling and disabling compilation of the Togl package for
Tcl/Tk OpenGL support provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TOGL is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
either BRLCAD_ENABLE_OPENGL or BRLCAD_ENABLE_TK are OFF.
")
THIRD_PARTY_TCL_PACKAGE(Togl togl "${TCL_WISH_EXECUTABLE}" "tcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_ENABLE_OPENGL;BRLCAD_ENABLE_X11;BRLCAD_LEVEL3" "togl" togl_ALIASES togl_DESCRIPTION)
if(BRLCAD_TOGL_BUILD)
  set(TOGL_LIBRARIES togl CACHE STRING "TOGL_LIBRARIES" FORCE)
  set(TOGL_STUB_LIBRARIES toglstub CACHE STRING "TOGL_STUB_LIBRARIES" FORCE)
  set(TOGL_INCLUDE_DIRS "${CMAKE_CURRENT_BINARY_DIR}/togl/include;${CMAKE_CURRENT_SOURCE_DIR}/togl/include" CACHE STRING "Togl include path" FORCE)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/togl/pkgIndex.tcl
    ${CMAKE_CURRENT_BINARY_DIR}/togl/src/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/Togl2.1)
ELSE(BRLCAD_TOGL_BUILD)
  # No Togl enabled - fix this so a system one has a chance...
  #set(TOGL_LIBRARIES "" CACHE STRING "Tcl/Tk OpenGL disabled" FORCE)
  #set(TOGL_STUB_LIBRARIES "" CACHE STRING "Tcl/Tk OpenGL disabled" FORCE)
  #set(TOGL_INCLUDE_DIRS "" CACHE STRING "Tcl/Tk OpenGL disabled" FORCE)
  set(TOGL_INCLUDE_DIRS "${CMAKE_CURRENT_BINARY_DIR}/togl/include;${CMAKE_CURRENT_SOURCE_DIR}/togl/include" CACHE STRING "Togl include path" FORCE)
endif(BRLCAD_TOGL_BUILD)
mark_as_advanced(TOGL_LIBRARY)
mark_as_advanced(TOGL_LIBRARIES)
mark_as_advanced(TOGL_STUB_LIBRARIES)
mark_as_advanced(TOGL_INCLUDE_DIRS)

set(iwidgets_ALIASES ENABLE_IWIDGETS)
set(iwidgets_DESCRIPTION "
Option for enabling and disabling compilation of the IWidgets Tk
widget package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_IWIDGETS is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Iwidgets iwidgets "${TCL_WISH_EXECUTABLE}" "tcl;tk;itcl;itk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" iwidgets_ALIASES iwidgets_DESCRIPTION)
if(BRLCAD_IWIDGETS_BUILD)
  set(IWIDGETS_VERSION "4.0.1" CACHE STRING "IWIDGETS_VERSION" FORCE)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/iwidgets/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/Iwidgets4.0.1)
ELSE(BRLCAD_IWIDGETS_BUILD)
  set(IWIDGETS_VERSION "${IWIDGETS_PACKAGE_VERSION}" CACHE STRING "IWIDGETS_VERSION" FORCE)
endif(BRLCAD_IWIDGETS_BUILD)
CONFIG_H_APPEND(BRLCAD "#define IWIDGETS_VERSION \"${IWIDGETS_VERSION}\"\n")
mark_as_advanced(IWIDGETS_VERSION)

set(tkhtml_ALIASES ENABLE_TKHTML)
set(tkhtml_DESCRIPTION "
Option for enabling and disabling compilation of the Tkhtml HTML
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKHTML is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Tkhtml tkhtml "${TCL_WISH_EXECUTABLE}" "tcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tkhtml_ALIASES tkhtml_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tkhtml/pkgIndex.tcl)
DISTCLEAN(${CMAKE_BINARY_DIR}/lib/Tkhtml3.0)
#add_subdirectory(hv3)
#include(${CMAKE_CURRENT_SOURCE_DIR}/hv3.dist)
#CMAKEFILES_IN_DIR(hv3_ignore_files hv3)
#add_subdirectory(sqlite3)
#include(${CMAKE_CURRENT_SOURCE_DIR}/sqlite3.dist)
#CMAKEFILES_IN_DIR(sqlite3_ignore_files sqlite3)
CMAKEFILES(hv3)
CMAKEFILES(sqlite3)

set(tkpng_ALIASES ENABLE_TKPNG)
set(tkpng_DESCRIPTION "
Option for enabling and disabling compilation of the tkpng PNG image
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKPNG is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(tkpng tkpng "${TCL_WISH_EXECUTABLE}" "tcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tkpng_ALIASES tkpng_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tkpng/pkgIndex.tcl)
DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tkpng0.8)

set(tktable_ALIASES ENABLE_TKTABLE)
set(tktable_DESCRIPTION "
Option for enabling and disabling compilation of the Tktable graphical
table widget package provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TKTABLE is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Tktable tktable "${TCL_WISH_EXECUTABLE}" "tcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tktable_ALIASES tktable_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tktable/pkgIndex.tcl)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tktable/tktable_cfg.h)
DISTCLEAN(${CMAKE_BINARY_DIR}/lib/Tktable2.10)

set(tktreectrl_ALIASES ENABLE_TKTREECTRL)
set(tktreectrl_DESCRIPTION "
Option for enabling and disabling compilation of the TkTreeCtrl graphical
table widget package provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TKTREECTRL is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(tktreectrl tktreectrl "${TCL_WISH_EXECUTABLE}" "tcl;tk"
  "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tktreectrl_ALIASES tktreectrl_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tktreectrl/pkgIndex.tcl)
DISTCLEAN(${CMAKE_BINARY_DIR}/lib/TkTreeCtrl2.4)

set(tkdnd_ALIASES ENABLE_TKDND)
set(tkdnd_DESCRIPTION "
Option for enabling and disabling compilation of the TkDnD 
drag-and-drop widget provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TKDND is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(tkdnd tkdnd "${TCL_WISH_EXECUTABLE}" "tcl;tk"
  "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tkdnd_ALIASES tkdnd_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tkdnd/pkgIndex.tcl)
DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tkdnd2.6)


# OpenNURBS Library
set(opennurbs_ALIASES ENABLE_OPENNURBS)
set(opennurbs_DESCRIPTION "
Option for enabling and disabling compilation of the openNURBS library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(openNURBS openNURBS "" opennurbs_ALIASES opennurbs_DESCRIPTION NOSYS)

if(NOT MSVC)
  set(NOT_MSVC 1)
endif(NOT MSVC)
# STEP Class Libraries
# Need Lemon/Perplex to build STEP - conditionalize

# Set some options for the SCL build
set(SCL_PYTHON_GENERATOR OFF)
set(SCL_ENABLE_TESTING OFF)
set(SCL_ENABLE_COVERAGE OFF)
set(SCL_IS_SUBBUILD ON)
set(SCL_BUILD_TYPE "${CMAKE_BUILD_TYPE}")

set(scl_ALIASES ENABLE_SCL ENABLE_STEP ENABLE_STEP_CLASS_LIBRARIES)
set(scl_DESCRIPTION "
Option for enabling and disabling compilation of the NIST Step Class
Libraries provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(scl step "LEMON_EXECUTABLE;PERPLEX_EXECUTABLE;BRLCAD_LEVEL3"  scl_ALIASES scl_DESCRIPTION NOSYS)
if(BRLCAD_SCL_BUILD)
  set(FEDEX_PLUS_EXEC fedex_plus CACHE STRING "Fedex plus executable" FORCE)
  set(FEDEX_PLUS_EXECUTABLE_TARGET fedex_plus CACHE STRING "Fedex plus executable target" FORCE)
  mark_as_advanced(FEDEX_PLUS_EXEC)
  mark_as_advanced(FEDEX_PLUS_EXECUTABLE_TARGET)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/step/include/scl_cf.h.in)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/step/scl_version_string.h.txt)
endif(BRLCAD_SCL_BUILD)
mark_as_advanced(SCL_BUILD_TYPE)
mark_as_advanced(SCL_GENERATE_LEXER_PARSER)
mark_as_advanced(SCL_BUILD_SHARED_LIBS)
mark_as_advanced(SCL_BUILD_STATIC_LIBS)
mark_as_advanced(SCL_CPP_GENERATOR)
mark_as_advanced(SCL_ENABLE_COVERAGE)
mark_as_advanced(SCL_ENABLE_TESTING)
mark_as_advanced(SCL_PYTHON_GENERATOR)
mark_as_advanced(SCL_MEMMGR_ENABLE_CHECKS)

# Clipper polygon clipping library - for now, we're going to use our copy
if(BRLCAD_LEVEL2)
  add_subdirectory(clipper)
  include(${CMAKE_CURRENT_SOURCE_DIR}/clipper.dist)
  CMAKEFILES_IN_DIR(clipper_ignore_files clipper)
  DISTCLEAN(${CMAKE_CURRENT_SOURCE_DIR}/clipper/Makefile)
  set(CLIPPER_LIBRARY "clipper" CACHE STRING "Clipper library" FORCE)
  set(CLIPPER_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/clipper" CACHE STRING "Directory containing clipper header" FORCE)
  mark_as_advanced(CLIPPER_LIBRARY)
  mark_as_advanced(CLIPPER_INCLUDE_DIR)
else(BRLCAD_LEVEL2)
  CMAKEFILES(clipper)
endif(BRLCAD_LEVEL2)

# VDSlib - A View-Dependent Simplification and Rendering Library For
# the moment, this is marked NOSYS - it's possible that some Debian
# systems would have 0.9 of vdslib installed, but it's unmaintained
# and we're likely to be making changes.  If our own copy of VDSlib
# ever spins back off into its own project, revisit the NOSYS

if(BRLCAD_LEVEL2)
  set(libvds_ALIASES ENABLE_VDS)
  set(libvds_DESCRIPTION "
Option for enabling and disabling compilation of the libvds triangle
simplification library provided with BRL-CAD's source code.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.
")
  THIRD_PARTY(libvds libvds "" libvds_ALIASES libvds_DESCRIPTION NOSYS)
  set(LIBVDS_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/libvds" CACHE STRING "Directory containing libvds headers." FORCE)
endif(BRLCAD_LEVEL2)

# Bullet is not yet integrated as a src/other subbuild, but there is
# code that will make use of it if it is available.  If that code
# becomes sufficiently useful, Bullet will be integrated.  In the
# meantime, locate the find logic for that package here.

# Bullet physics library
if(BRLCAD_LEVEL2)
  find_package(Bullet)
  if(BULLET_FOUND)
    CONFIG_H_APPEND(BRLCAD "#define HAVE_BULLET 1\n")
  endif(BULLET_FOUND)
  # Let the rest of the package know the results
  set(BULLET_LIBRARIES "${BULLET_LIBRARIES}" CACHE STRING "Bullet libs" FORCE) 
  set(BULLET_FOUND "${BULLET_FOUND}" CACHE BOOL "Bullet status" FORCE) 
  mark_as_advanced(BULLET_INCLUDE_DIR)
endif(BRLCAD_LEVEL2)

# Adaptagrams is not yet integrated as a src/other subbuild, but there
# is code that will make use of it if it is available.  If that code
# becomes sufficiently useful, Adaptagrams will be integrated.  In the
# meantime, locate the find logic for that package here.

# Adaptagrams library
if(BRLCAD_LEVEL2)
  find_package(ADAPTAGRAMS)
  if(ADAPTAGRAMS_FOUND)
    CONFIG_H_APPEND(BRLCAD "#define HAVE_ADAPTAGRAMS 1\n")
  endif(ADAPTAGRAMS_FOUND)
  set(ADAPTAGRAMS_LIBRARIES "${ADAPTAGRAMS_LIBRARIES}" CACHE STRING "Adaptagrams libs" FORCE) 
  set(ADAPTAGRAMS_FOUND "${ADAPTAGRAMS_FOUND}" CACHE BOOL "Adaptagrams status" FORCE) 
endif(BRLCAD_LEVEL2)

# Poly2Tri CDT library
if(BRLCAD_LEVEL2)
  add_subdirectory(poly2tri)
  include(${CMAKE_CURRENT_SOURCE_DIR}/poly2tri.dist)
  CMAKEFILES_IN_DIR(poly2tri_ignore_files poly2tri)
  DISTCLEAN(${CMAKE_CURRENT_SOURCE_DIR}/poly2tri/Makefile)
  set(P2T_LIBRARY "p2t" CACHE STRING "Poly2Tri library" FORCE)
  set(P2T_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/poly2tri" CACHE STRING "Directory containing poly2tri header" FORCE)
  mark_as_advanced(P2T_LIBRARY)
  mark_as_advanced(P2T_INCLUDE_DIR)
else(BRLCAD_LEVEL2)
  CMAKEFILES(poly2tri)
endif(BRLCAD_LEVEL2)

# The jama/tnt headers are installed by default - BRL-CAD requires the
# altered headers to build (I think?)
add_subdirectory(tnt)
set(TNT_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/tnt" CACHE STRING "Directory containing tnt headers" FORCE)
CMAKEFILES(tnt)
mark_as_advanced(TNT_INCLUDE_DIR)

# Eigen is used for advanced linear algebra functionality It consists
# entirely of headers and does not need to be installed.
#
# TODO - replace jama/tnt with Eigen
#
CMAKEFILES(Eigen)

if(BRLCAD_ENABLE_OSL)
  add_subdirectory(osl)
endif(BRLCAD_ENABLE_OSL)

CMAKEFILES(Makefile.am)

# Local Variables:
# tab-width: 8
# mode: cmake
# indent-tabs-mode: t
# End:
# ex: shiftwidth=2 tabstop=8

blob
data 6874
# Minimum required version of CMake
CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
IF(COMMAND CMAKE_POLICY)
  CMAKE_POLICY(SET CMP0003 NEW)
ENDIF(COMMAND CMAKE_POLICY)

# set CMake project name
PROJECT(tkdnd)

SET(CMAKE_MODULE_PATH
  "${CMAKE_MODULE_PATH};${CMAKE_CURRENT_SOURCE_DIR}/CMake")
find_package(TCL)
find_package(X11)
include_directories(${CMAKE_CURRENT_BINARY_DIR})
include_directories(${CMAKE_CURRENT_SOURCE_DIR})

## ===========================================================================
##  Project Information
## ===========================================================================
PROJECT(tkdnd)
## Package version information:
set(PKG_NAME ${PROJECT_NAME} )
set(PKG_MAJOR_VERSION 2 )
set(PKG_MINOR_VERSION 6 )
set(PKG_BUILD_VERSION 0 )
## Author:
set(PKG_VENDOR        "Georgios Petasis" )

## Arange project version information...
set(PKG_VERSION "${PKG_MAJOR_VERSION}.${PKG_MINOR_VERSION}" )
set(PKG_NAME_VERSION  ${PKG_NAME}-${PKG_VERSION} )

## Package global definitions...
ADD_DEFINITIONS   ( -DPACKAGE_NAME="${PKG_NAME}" )
ADD_DEFINITIONS   ( -DPACKAGE_VERSION="${PKG_VERSION}" )
ADD_DEFINITIONS   ( -DPACKAGE_NAME_VERSION="${PKG_NAME_VERSION}" )
ADD_DEFINITIONS   ( -DTKDND_PACKAGE="${PKG_NAME}" )
ADD_DEFINITIONS   ( -DTKDND_VERSION="${PKG_VERSION}" )

## Package debug definitions...
# ADD_DEFINITIONS   ( -DDEBUG_CLIENTMESSAGE_HANDLER )

## ===========================================================================
##  Project sources
## ===========================================================================
if(WIN32)
  include_directories(${CMAKE_CURRENT_SOURCE_DIR}/win)
  set(PKG_SOURCES win/TkDND_OleDND.cpp)
  add_definitions(-DUNICODE )
  add_definitions(-D_UNICODE )
endif(WIN32)
if(APPLE)
  include_directories(${CMAKE_CURRENT_SOURCE_DIR}/macosx)
  set(PKG_SOURCES unix/macosx/macdnd.m)
  add_definitions(-DMAC_TK_COCOA)
  add_definitions(-std=gnu99)
  add_definitions(-x objective-c)
  add_definitions(-fobjc-gc)
  set(SYSTEM_LIBRARIES -framework Cocoa -framework Carbon)
endif(APPLE)
if(NOT APPLE AND NOT WIN32)
  include_directories(${CMAKE_CURRENT_SOURCE_DIR}/unix)
  include_directories(${X11_INCLUDE_DIR})
  set(PKG_SOURCES unix/TkDND_XDND.c unix/tkUnixSelect.c unix/Cursors.c)
  set(SYSTEM_LIBRARIES ${X11_LIBRARIES})
endif(NOT APPLE AND NOT WIN32)

##
## If we are building with MINGW, link statically to its libs...
##
if(MINGW)
  include(CheckCCompilerFlag)
  CHECK_C_COMPILER_FLAG(-static-libgcc    FLAG_static_libgcc    )
  CHECK_C_COMPILER_FLAG(-static-libstdc++ FLAG_static_libstdcpp )
  if(FLAG_static_libgcc )
    set(CMAKE_SHARED_LINKER_FLAGS
      "${CMAKE_SHARED_LINKER_FLAGS} -static-libgcc" )
  endif(FLAG_static_libgcc )
  if(FLAG_static_libstdcpp )
    set(CMAKE_SHARED_LINKER_FLAGS
      "${CMAKE_SHARED_LINKER_FLAGS} -static-libstdc++" )
  endif(FLAG_static_libstdcpp )
endif(MINGW )

## ===========================================================================
##  Tcl/Tk
## ===========================================================================

## Enable Tcl/Tk stubs globally...
add_definitions(-DUSE_TCL_STUBS)
add_definitions(-DUSE_TK_STUBS)
add_definitions(-DTCL_THREADS)
include_directories(${TCL_INCLUDE_PATH} ${TK_INCLUDE_PATH})

if(WIN32 AND NO_MSVCRT)
  string(REPLACE /MD  /MT  CMAKE_C_FLAGS_RELEASE   ${CMAKE_C_FLAGS_RELEASE}  )
  string(REPLACE /MDd /MTd CMAKE_C_FLAGS_DEBUG     ${CMAKE_C_FLAGS_DEBUG}    )
  string(REPLACE /MD  /MT  CMAKE_CXX_FLAGS_RELEASE ${CMAKE_CXX_FLAGS_RELEASE})
  string(REPLACE /MDd /MTd CMAKE_CXX_FLAGS_DEBUG   ${CMAKE_CXX_FLAGS_DEBUG}  )
  set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /nodefaultlib:MSVCRT.LIB" )
  set(CMAKE_EXE_LINKER_FLAGS_RELEASE "${CMAKE_EXE_LINKER_FLAGS_RELEASE} LIBCMT.LIB" )
  set(CMAKE_EXE_LINKER_FLAGS_DEBUG "${CMAKE_EXE_LINKER_FLAGS_DEBUG} LIBCMTD.LIB" )
  set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /nodefaultlib:MSVCRT.LIB" )
  set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE} LIBCMT.LIB" )
  set(CMAKE_SHARED_LINKER_FLAGS_DEBUG "${CMAKE_SHARED_LINKER_FLAGS_DEBUG} /nodefaultlib:LIBCMT.LIB LIBCMTD.LIB" )
  add_definitions(-D_STATIC_CPPLIB )
  add_definitions(-D_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES=1 )
  add_definitions(-D_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT=1 )
  add_definitions(-D_CRT_SECURE_NO_WARNINGS )
endif(WIN32 AND NO_MSVCRT )

add_library(tkdnd SHARED ${PKG_SOURCES})
target_link_libraries(tkdnd ${TCL_STUB_LIBRARY} ${TK_STUB_LIBRARY} ${SYSTEM_LIBRARIES})
set_target_properties(tkdnd PROPERTIES VERSION ${PKG_VERSION})
install(TARGETS tkdnd
  RUNTIME DESTINATION ${BIN_DIR}
  LIBRARY DESTINATION ${LIB_DIR}
  ARCHIVE DESTINATION ${LIB_DIR})

set(TKDND_MISC
  library/tkdnd.tcl
  library/tkdnd_compat.tcl
  library/tkdnd_macosx.tcl
  library/tkdnd_unix.tcl
  library/tkdnd_windows.tcl
  )

if(CMAKE_CONFIGURATION_TYPES)
  foreach(CFG_TYPE ${CMAKE_CONFIGURATION_TYPES})
    string(TOUPPER "${CFG_TYPE}" CFG_TYPE_UPPER)
    if(MSVC)
      set(libdir "${CMAKE_RUNTIME_OUTPUT_DIRECTORY_${CFG_TYPE_UPPER}}")
    else(MSVC)
      set(libdir "${CMAKE_LIBRARY_OUTPUT_DIRECTORY_${CFG_TYPE_UPPER}}")
    endif(MSVC)
    get_target_property(target_LIBLOCATION tkdnd LOCATION_${CFG_TYPE_UPPER})
    get_filename_component(target_LIBNAME ${target_LIBLOCATION} NAME)
    configure_file(pkgIndex.tcl.in ${CMAKE_LIBRARY_OUTPUT_DIRECTORY_${CFG_TYPE_UPPER}}/${PKG_NAME}${PKG_VERSION}/pkgIndex.tcl)
    DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY_${CFG_TYPE_UPPER}}/${pkgname}${pkgversion})
    file(COPY ${TKDND_MISC} DESTINATION ${CMAKE_BINARY_DIR_${CFG_TYPE_UPPER}}/${LIB_DIR}/${PKG_NAME}${PKG_VERSION})
  endforeach(CFG_TYPE ${CMAKE_CONFIGURATION_TYPES})
  if(MSVC)
    set(libdir "${CMAKE_INSTALL_PREFIX}/${BIN_DIR}")
  else(MSVC)
    set(libdir "${CMAKE_INSTALL_PREFIX}/${LIB_DIR}")
  endif(MSVC)
  configure_file(pkgIndex.tcl.in ${CMAKE_CURRENT_BINARY_DIR}/pkgIndex.tcl)
else(CMAKE_CONFIGURATION_TYPES)
  if(CMAKE_BUILD_TYPE)
    get_target_property(target_LIBLOCATION tkdnd LOCATION_${CMAKE_BUILD_TYPE})
  else(CMAKE_BUILD_TYPE)
    get_target_property(target_LIBLOCATION tkdnd LOCATION)
  endif(CMAKE_BUILD_TYPE)
  get_filename_component(target_LIBNAME ${target_LIBLOCATION} NAME)
  set(libdir "${CMAKE_LIBRARY_OUTPUT_DIRECTORY}")
  configure_file(pkgIndex.tcl.in ${libdir}/${PKG_NAME}${PKG_VERSION}/pkgIndex.tcl)
  set(libdir "${CMAKE_INSTALL_PREFIX}/${LIB_DIR}")
  configure_file(pkgIndex.tcl.in ${CMAKE_CURRENT_BINARY_DIR}/pkgIndex.tcl)
  file(COPY ${TKDND_MISC} DESTINATION ${CMAKE_BINARY_DIR}/${LIB_DIR}/${PKG_NAME}${PKG_VERSION})
endif(CMAKE_CONFIGURATION_TYPES)
install(FILES ${CMAKE_CURRENT_BINARY_DIR}/pkgIndex.tcl DESTINATION ${LIB_DIR}/${PKG_NAME}${PKG_VERSION})

install(FILES ${TKDND_MISC} DESTINATION ${LIB_DIR}/${PKG_NAME}${PKG_VERSION})

# Local Variables:
# tab-width: 8
# mode: cmake
# indent-tabs-mode: t
# End:
# ex: shiftwidth=2 tabstop=8

blob
data 8263
2012-11-27  Petasis George  <petasis@iit.demokritos.gr>
	* library/tkdnd_unix.tcl:
	* library/tkdnd_windows.tcl: Leave and Drop events do not report 0
        as root x/y (%X %Y). In case the underlying protocol does not support
        reporting the mouse coordinates for the specific event, the last known
        possition from the position event is used.

2012-08-26  Petasis George  <petasis@iit.demokritos.gr>
	TkDND 2.6 released.
	* unix/tkUnixSelect.c: Added a work-around for getting the selection
	under unix: since Tk does not always deliver SelectionNotify, we try
	to get the selection even if SelectionNotify has not been received.

2012-08-15  Petasis George  <petasis@iit.demokritos.gr>
	* unix/tkUnixSelect.c: Partially solved the problem with getting
	selection under unix. The solution was to try and get the selection,
	even if a SelectionNotify event has not been delivered.

2012-07-14  Petasis George  <petasis@iit.demokritos.gr>
	* unix/tkUnixSelect.c: Tests with Tcl_ThreadAlert(). It helps
	somewhat, but is not the solution for the problems when getting the
	selection.

2012-06-17  Petasis George  <petasis@iit.demokritos.gr>
	TkDND 2.5 released.
	* win/TkDND_OleDND.cpp: Fixes for type CF_HDROP.

2012-06-07  Petasis George  <petasis@iit.demokritos.gr>
	* demos/basic.tcl: Updated demo with support for colours, which only
	works for XDND right now.

	* unix/TkDND_XDND.c:
	* unix/tkUnixSelect.c: Implementation of unix (XDND) drags completed.

2012-06-06  Petasis George  <petasis@iit.demokritos.gr>
	* unix/Cursors.c: Ported cursors from TkDND 1.x to TkDND 2.x

2012-06-05  Petasis George  <petasis@iit.demokritos.gr>
	* library/tkdnd.tcl:
	* library/tkdnd_unix.tcl:
	* unix/tkUnixSelect.c:
	* unix/TkDND_XDND.c: Added support for initiating drags from Tk under
	unix. Despite incomplete, seems to work with GTK.

2012-06-02  Petasis George  <petasis@iit.demokritos.gr>
	* library/tkdnd_unix.tcl:
	* unix/TkDND_XDND.c:
	* unix/tkUnixSelect.c:
	* unix/tkSelect.h: Modifications to support Linux drops. Drops from
	GTK seem to always work, and drops from Qt seem to work most of the
	times.

2012-04-19  Petasis George  <petasis@iit.demokritos.gr>
	* win/Makefile: Updated the Windows Makefile, after a patch from
	Dave Bodenstab.

2012-04-12  Petasis George  <petasis@iit.demokritos.gr>
	TkDND 2.4 released.
	* library/tkdnd_unix.tcl:
	* unix/TkDND_XDND.c:
	* unix/tkUnixSelect.c:
	* unix/tkSelect.h: Modifications to support Linux drops.

	* tclconfig/*:
	* configure.in, Makefile.in: Updated to TEA 3.9.

	* library/tkdnd_unix.tcl: Removed braces from a comment in
	xdnd::_GetDroppedData, left from testing with TIP 370 preliminary
	implementation. SF Bug ID: 3516862

2012-03-03  Petasis George  <petasis@iit.demokritos.gr>
	TkDND 2.3 released.
	* library/tkdnd_windows.tcl:
	* win/OleDND.h:
	* win/TkDND_OleDND.cpp: Fix in TkDND_DropSource::QueryContinueDrag,
	to support dragging with all mouse buttons. Bug reported by
	Michael Fersch.

2011-09-24  Petasis George  <petasis@iit.demokritos.gr>
	* win/OleDND.h: Added definition of WINVER to version 5, when compiling
	with MinGW, which defines it with version 4. SF Bug ID: 3411338.

2011-09-23  Petasis George  <petasis@iit.demokritos.gr>
	* win/OleDND.h: Modified STRING_(s), to ease compilation with MinGW.
	Patch provided by Hans-Christoph Steiner. SF Bug ID: 3411338.

2011-09-22  Petasis George  <petasis@iit.demokritos.gr>
	* win/OleDND.h: Added a check if CF_DIBV5 is defined (i.e.
	WINVER < 0x0500). SF Bug ID: 3411338.

2011-03-18  Petasis George  <petasis@iit.demokritos.gr>
	* library/tkdnd_unix.tcl: Fixed a bug in xdnd::_GetDroppedData, where
	an improper error was thrown in case no common types were found between
	the drag source and drop target widgets. Now a more appropriate error
	is returned. Bug reported by Kevin Walzer.

2011-01-14  Petasis George  <petasis@iit.demokritos.gr>
	* library/tkdnd_unix.tcl: Added support for accepting drops, if
	TIP 370 is finally approved. Changes tested with a preliminary TIP 370
	implementation.

	* library/tkdnd_macosx.tcl: Fixed a bug reported by Kevin Walzer:
	macdnd::_GetDroppedData and xdnd::_GetDroppedData were missing the
	"time" argument, added in the XDND section for TIP 370 (if it gets
	accepted).

	* macosx/macdnd.m: Restored back a workarround by Kevin Walzer, as
	TkDND does not work well under all circumstances in OS X 10.6.
	(Reported by Kevin Walzer on 23 Dec 2010).

2010-08-03  Petasis George  <petasis@iit.demokritos.gr>
	TkDND 2.2 released.
	* library/tkdnd_windows.tcl:
	* win/OleDND.h: Fixes for compiling with UNICODE & _UNICODE.

2010-07-28  Petasis George  <petasis@iit.demokritos.gr>
	* win/Makefile: Updated.

	* library/tkdnd_unix.tcl:
	* library/tkdnd_windows.tcl: Fixed bug 2169256.

	* library/tkdnd.tcl: Fixed bug 2486830.

2010-06-16  Petasis George  <petasis@iit.demokritos.gr>
	* Makefile.in:
	* configure.in:
	* win/Makefile:
	* win/TkDND_OleDND.cpp:
	* unix/TkDND_XDND.c: Applied a patch from Andreas Kupries, which
	make the unix code compatible with compilers supporting C89 (i.e.
	AIX's cc). Also, the TEA files were updated.

	* /unix/TkDND_XDND.c: Fixed a bug in TkDND_RegisterTypesObjCmd.
	It seems that KDE wants the XdndAware property on the window these
	days, and not at the toplevel one.

2010-06-11  Petasis George  <petasis@iit.demokritos.gr>
	TkDND 2.1 released.

2010-05-05  Petasis George  <petasis@iit.demokritos.gr>
	* /macosx/macdnd.m: Several fixes. The most important are:
	Do not initiate a drag if the clipboard is empty (i.e. because we
	  cannot handle any of the provided types).
	Fixed drag icon slide when the drag is canceled.

2010-04-30  Petasis George  <petasis@iit.demokritos.gr>
	* /macosx/macdnd.m: Several changes:
	Moved drag operation inside TkDND_DoDragDropObjCmd. This means that
	  drag operation can be started with a Tk binding.
	Fixed the way drag types are declared in the drag clipboard. Now types
	  are reported correctly during drops.
	Added a tag in the DNDView class.
	Added a function to get the DNDView pointer from an NSView pointer.
	  Hopefully this will not permit to add more than one DNDView to any
	  view. This function always return a DNDView pointer (it creates a
	  new DNDView if a view does not already has one).

	The demos seem to work, although the garbage collector seems to print
	some messages during drags from Tk windows.

2010-04-06  Petasis George  <petasis@iit.demokritos.gr>
	* /macosx/macdnd.m: Some attempts towards drag support for OS X.

2010-01-03  Petasis George  <petasis@iit.demokritos.gr>
	* /library/tkdnd_macosx.tcl:
	* /macosx/macdnd.m: Changed the way dropped data is handled: during
	the drop event the data are converted into a utf-8 string (in case of
	dropping string data) or a Tcl list object of utf-8 filenames (in case
	of dropping files). The data object is stored directly in the
	tkdnd::macdnd::_dropped_data variable, instead of the selection
	clipboard. _GetDroppedData was modified to return this stored data.

2009-12-30  Petasis George  <petasis@iit.demokritos.gr>
	* /cmake:
	* /CMakeLists.txt: Added support for building TkDND with cmake (i.e.
	under windows).

2009-12-29  Petasis George  <petasis@iit.demokritos.gr>
	* /library/tkdnd_macosx.tcl:
	* /macosx/macdnd.m: Changes to better integrate the work done by
	Kevin Walzer with the rest of TkDND, since OS X seems to mimic the
	XDND implementation. tkdnd_macosx.tcl is now a stub file, with most of
	the work being done by the unix (XDND) code.
	I think that OS X drop support is now working.

2009-12-09  Petasis George  <petasis@iit.demokritos.gr>
	* /library/tkdnd_macosx.tcl:
	* /macosx/macdnd.m: Updates to better integrate the OS X type
	registration command with the rest of the TkDND internal API.

2009-12-01  Walzer Kevin    <kw@codebykevin.com>
	* /macosx/*: Initial support for drop targets under OS X (Cocoa).

2007-02-09  Petasis George  <petasis@iit.demokritos.gr>
	* /unix/TkDND_XDND.c: Fixed a bug in TkDND_RegisterTypesObjCmd, where
	Tk_Parent was used to determine if a provided path was a toplevel.
	Replaced by a check through Tk_IsTopLevel.
	Bug reported by Alain Bertrand <alain.mp.bertrand@tele2.be>

2006-04-24  Petasis George  <petasis@iit.demokritos.gr>
	* TkDND version 2.0 started.
blob
data 46775
#                   F I N D T C L . C M A K E
# BRL-CAD
#
# Copyright (c) 2010-2012 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
#
# 3. The name of the author may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
###
# - Find Tcl/Tk commands, includes and libraries.
#
# Copyright (c) 2010-2012 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# Copyright 2001-2009 Kitware, Inc.
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# 
# * Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
# 
# * Neither the names of Kitware, Inc., the Insight Software Consortium,
# the United States Government, the U.S. Army Research Laboratory,
# nor the names of their contributors may be used to endorse or promote
# products derived from this software without specific prior written
# permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#-----------------------------------------------------------------------
#
# There are quite a number of potential compilcations when it comes to
# Tcl/Tk, particularly in cases where multiple versions of Tcl/Tk are
# present on a system and the case of OSX, which my have Tk built for
# either X11 or Aqua.  On Windows there may be Cygwin installs of
# Tcl/Tk as well. 
#
# Several "design philosophy" decisions have to be made - what to report
# when multiple instances of Tcl/Tk are available, how much control to
# allow users, how to expose those controls, etc.  Here are the rules
# this particular implementation of FindTCL will strive to express:
#
# 1. If a parent CMakeLists.txt defines a specific TCL_PREFIX 
#    directory, don't look for or return any settings using
#    other Tcl/Tk installations, even if nothing is found
#    below TCL_PREFIX and other installations are present.
#    Report NOTFOUND instead.
#
# 2. There will be two variables for controlling which versions to
#    report, above and beyond the standard version option to
#    find_package:
#
#    TCL_MIN_VERSION
#    TCL_MAX_VERSION
#
#    These will be expected to have the form:
#
#    TCL_VERSION_MAJOR.TCL_VERSION_MINOR.TCL_VERSION_PATCH
#
#    although the PATCH_VERSION will be optional.  If
#    no PATCH_VERSION is specified, any patch version will
#    be regarded as satisfying the criteria of any version
#    number test applied.  If no versions are specified it
#    is assumed any will do.  Higher versions are preferred
#    over lower, within the above constraints.
#
# 3. Tk provides the option to compile either for
#    the "native" graphics system (aqua, win32, etc.) or for
#    X11 (which is also the native graphics system on Unix-type
#    platforms other than Mac OSX.)  There are situations were
#    a program or developer may want to require a particular
#    windowing system.  If that is the case they can make use
#    of the following two options:
#
#    TK_NATIVE_GRAPHICS
#    TK_X11_GRAPHICS
#
#    If NATIVE_GRAPHICS is set to ON, a Tcl/Tk system is 
#    reported found only if the reported graphics system
#    matches that of the current platform.  If X11_GRAPHICS
#    is on, a match is reported only if the windowing system
#    reports X11.  If neither option is ON, the windowing
#    system is not a factor in deciding to report
#    FOUND or NOTFOUND.  If BOTH are ON (why??) NATIVE_GRAPHICS
#    will override the TK_X11_GRAPHICS setting and set it
#    to OFF.
#
# 4. By default, if no prefix is specified, FindTCL will search
#    a list of directories and the system path for tcl libraries.
#    This list can be expanded by a parent CMakeLists.txt file
#    by specifying additional paths in this variable, which will
#    be checked before the system path.  Essentially, this lets
#    a configure process do a "soft set" of the TCL prefix - look
#    here first but if not found or constraints aren't satisfied 
#    check system paths:
#
#    TCL_ADDITIONAL_SEARCH_PATHS
#
# 5. On Apple platforms, there may be a "Framework" install of
#    Tcl/Tk. By default, FindTCL will start with this version
#    on OSX platforms if no TCL_PREFIX is specified, but will
#    move on to another installation if the Framework Tcl/Tk doesn't
#    satisfy other criteria.  If a developer wishes to REQUIRE a 
#    Framework build of Tcl/Tk and reject other installs even though
#    they may satisfy other criteria, they can enable the following 
#    option:
#
#    TCL_USE_FRAMEWORK_ONLY
#
# 6. If a developer needs ONLY Tcl, without the Tk graphics library,
#    they can disable the following option (on by default)
#  
#    TCL_REQUIRE_TK
#
# 7. If a developer needs Threads support in Tcl, they can enable
#    the following option (disabled by default)
#
#    TCL_REQUIRE_THREADS
#
# 8. Normally, FindTCL will assume that the intent is to compile
#    C code and will require headers.  If a developer needs Tcl/Tk
#    ONLY for the purposes of running tclsh or wish scripts and is
#    not planning to do any compiling, they can disable the following
#    option and FindTCL will report a Tcl/Tk installation without
#    headers as FOUND.
#
#    TCL_NEED_HEADERS
#
# 9. FindTCL will also typically require the stub libraries be present
#    If they are not needed, the parent CMakeLists.txt file can disable
#    the following variable (defaults to ON)
#
#    TCL_NEED_STUB_LIBS
#
#10. It may be that there are Tcl/Tk installations on a machine that
#    should NOT be found by Tcl/Tk for reasons other than those
#    available above - in that case, the parent CMakeLists.txt file
#    can list REGEX patterns identifying those locations in the
#    variable (empty by default):
#
#    TCL_PATH_NOMATCH_PATTERNS
#
#
# The following variables are set as the "standard" results from
# this script:
#
#  TCL_INCLUDE_DIRS         (will also include Tk header paths if Tk is enabled)
#  TCL_LIBRARIES            (will also include Tk libraries if Tk is enabled)
#  TCL_STUB_LIBRARIES       (will also include Tk stub libraries if Tk is enabled)
#  TCL_TCLSH_EXECUTABLE     (path to tclsh binary)
#  TCL_WISH_EXECUTABLE      (path to wish binary, set only if Tk is enabled)
#  TCL_ROOT_PATH 
#  TCL_FOUND                (set if all required features (Tk, threads, etc.) are found)
#  TCL_VERSION_STRING       (in the case where both Tcl and Tk are returned they,
#  TCL_VERSION_MAJOR         should both share the same version information.  If
#  TCL_VERSION_MINOR         a situation arises where they do not, it is a bug.)
#  TCL_VERSION_PATCH
#
# The following are not specifically called out by readme.txt but are
# useful when building TEA based extensions to Tcl/Tk
#
#  TCL_CONF_PREFIX          (path to parent dir of tclConfig.sh file)
#  TCL_TK_CONF_PREFIX       (path to parent dir of tkConfig.sh file)
#
# The readme.txt file discourages the use of XXX_LIBRARY settings in CMakeLists.txt files,
# but in the specific case of Tcl/Tk it is quite plausible to desire to specifically use
# only (say) the Tcl library, even if in the broader system Tk usage is also present.  
# For that reason, the following variables will be maintained:
#
#  TCL_LIBRARY              (path to just the Tcl library)
#  TCL_TK_LIBRARY           (path to just the Tk library, set only if Tk is enabled)
#  TCL_STUB_LIBRARY         (path to just the Tcl stub library)
#  TCL_TK_STUB_LIBRARY      (path to just the Tk stub library)
#
# Previous FindTCL implementations set a series of less verbose
# variables that did not strictly conform to the format defined by
# the readme.txt file in the CMake modules directory.  These are set,
# but should be regarded as deprecated.
#
#  TK_LIBRARY         = path to Tk library
#  TK_STUB_LIBRARY    = path to Tk stub library
#  TCL_INCLUDE_PATH   = path to directory containing tcl.h
#  TK_INCLUDE_PATH    = path to directory containing tk.h
#  TCL_TCLSH          = full path to tclsh binary
#  TK_WISH            = full path wo wish binary
#  
# Note:  In the special case where headers are not required, the *LIBRARIES, *LIBRARY,
# *CONF_PREFIX, and *_INCLUDE_DIRS variables are also not required. If
# all that is required is tclsh and/or wish, those are the only fixed
# requirements.  In most cases the other variables will also be populated
# but it is not guaranteed.

# Tcl/Tk tends to name things using version numbers, so we need a
# list of numbers to check 
set(TCL_POSSIBLE_MAJOR_VERSIONS 8)
set(TCL_POSSIBLE_MINOR_VERSIONS 6 5 4 3 2 1 0)

# Create the Tcl/Tk options if not already present
OPTION(TK_NATIVE_GRAPHICS "Require native Tk graphics." OFF)
OPTION(TK_X11_GRAPHICS "Require X11 Tk graphics." OFF)
OPTION(TCL_USE_FRAMEWORK_ONLY "Don't use any Tcl/Tk installation that isn't a Framework." OFF)
OPTION(TCL_REQUIRE_TK "Look for Tk installation, not just Tcl." ON)
OPTION(TCL_REQUIRE_THREADS "Reject a Tcl/Tk installation unless threads are enabled." OFF)
OPTION(TCL_NEED_HEADERS "Don't report a found Tcl/Tk unless headers are present." ON)
OPTION(TCL_NEED_STUB_LIBS "Don't report a found Tcl/Tk unless the stub libraries are present." ON)

# Sanity check the settings - can't require both Native and X11 if X11 isn't
# the native windowing system on the platform
if(WIN32 OR APPLE)
  if(TK_NATIVE_GRAPHICS AND TK_X11_GRAPHICS)
    message(STATUS "Warning - both Native and X11 graphics required on platform where X11 is not a native graphics layer - disabling X11 graphics.")
    set(TK_X11_GRAPHICS OFF CACHE BOOL "Require X11 Tk graphics." FORCE)
  endif(TK_NATIVE_GRAPHICS AND TK_X11_GRAPHICS)
endif(WIN32 OR APPLE)

#-----------------------------------------------------------------------------
# 
#                  Run-Time testing for Tcl/Tk features
#
#  This section specifically contains macros that write tcl scripts to
#  files in order to be run by tclsh/wish binaries found by other routines.
#  Routines here are intended to probe the details of the Tcl/Tk installation,
#  and should only be used to get information not obtainable through config
#  files or environment variables.
#
#-----------------------------------------------------------------------------

# Set up the logic for determing the tk windowingsystem.  
set(tkwin_script "
set filename \"${CMAKE_BINARY_DIR}/CMakeTmp/TK_WINDOWINGSYSTEM\"
set fileId [open $filename \"w\"]
set windowingsystem [tk windowingsystem]
puts $fileId $windowingsystem
close $fileId
exit
")
set(tkwin_scriptfile "${CMAKE_BINARY_DIR}/CMakeTmp/tk_windowingsystem.tcl")
macro(TK_GRAPHICS_SYSTEM wishcmd resultvar)
  set(${resultvar} "wm-NOTFOUND")
  file(WRITE ${tkwin_scriptfile} ${tkwin_script})
  EXEC_PROGRAM(${wishcmd} ARGS ${tkwin_scriptfile} OUTPUT_VARIABLE EXECOUTPUT)
  file(READ ${CMAKE_BINARY_DIR}/CMakeTmp/TK_WINDOWINGSYSTEM readresultvar)
  string(REGEX REPLACE "\n" "" "${resultvar}" "${readresultvar}")
endmacro()


# Set up the logic for determing the version of Tcl/Tk via running a script.
set(tclversion_script "
set filename \"${CMAKE_BINARY_DIR}/CMakeTmp/TCL_VERSION\"
set fileId [open $filename \"w\"]
puts $fileId $tcl_patchLevel
close $fileId
exit
")
set(tclversion_scriptfile "${CMAKE_BINARY_DIR}/CMakeTmp/tcl_version.tcl")
macro(TCL_GET_VERSION tclshcmd resultvar)
  set(${resultvar} "NOTFOUND")
  file(WRITE ${tclversion_scriptfile} ${tclversion_script})
  EXEC_PROGRAM(${tclshcmd} ARGS ${tclversion_scriptfile} OUTPUT_VARIABLE EXECOUTPUT)
  file(READ ${CMAKE_BINARY_DIR}/CMakeTmp/TCL_VERSION readresultvar)
  string(REGEX REPLACE "\n" "" "${resultvar}" "${readresultvar}")
endmacro()


# Set up the logic for determing if a particular Tcl is compiled threaded.
set(tclthreaded_script"
set filename \"${CMAKE_BINARY_DIR}/CMakeTmp/TCL_THREADED\"
set fileId [open $filename \"w\"]
if {[info exists tcl_platform(threaded)]} {puts $fileId 1}
close $fileId
exit
")
	set(tclthreaded_scriptfile "${CMAKE_BINARY_DIR}/CMakeTmp/tcl_threaded.tcl")
	macro(TCL_ISTHREADED tclshcmd resultvar)
	  set(${resultvar} "NOTFOUND")
	  file(WRITE ${tclthreaded_scriptfile} ${tclthreaded_script})
	  EXEC_PROGRAM(${tclshcmd} ARGS ${tclthreaded_scriptfile} OUTPUT_VARIABLE EXECOUTPUT)
	  file(READ ${CMAKE_BINARY_DIR}/CMakeTmp/TCL_THREADED readresultvar)
	  string(REGEX REPLACE "\n" "" "${resultvar}" "${readresultvar}")
	endmacro()

	#-----------------------------------------------------------------------------
	#
	#                 Routines dealing with version numbers
	#
	#-----------------------------------------------------------------------------

	# A routine to chop version numbers up into individual variables
	macro(SPLIT_TCL_VERSION_NUM versionnum)
	  string(REGEX REPLACE "([0-9]*).[0-9]*.?[0-9]*" "\\1" ${versionnum}_MAJOR "${${versionnum}}")
	  string(REGEX REPLACE "[0-9]*.([0-9]*).?[0-9]*" "\\1" ${versionnum}_MINOR "${${versionnum}}")
	  string(REGEX REPLACE "[0-9]*.[0-9]*.?([0-9]*)" "\\1" ${versionnum}_PATCH "${${versionnum}}")
	endmacro()    

	# If version information is supplied, use it to restrict the search space.  If EXACT,
	# peg min and max at the same value.  
	if(TCL_FIND_VERSION_MAJOR)
	  set(TCL_POSSIBLE_MAJOR_VERSIONS ${TCL_FIND_VERSION_MAJOR})
	endif(TCL_FIND_VERSION_MAJOR)
	if(TCL_FIND_VERSION_MINOR)
	  set(TCL_POSSIBLE_MINOR_VERSIONS ${TCL_FIND_VERSION_MINOR})
	endif(TCL_FIND_VERSION_MINOR)
	if(TCL_FIND_VERSION_EXACT)
	  set(TCL_MIN_VERSION ${TCL_FIND_VERSION})
	  set(TCL_MAX_VERSION ${TCL_FIND_VERSION})
	endif(TCL_FIND_VERSION_EXACT)

	# In various loops, we don't want to waste time checking for paths containing
	# version numbers incompatible with restrictions imposed by the min/max/exact
	# variables.  Define a version to validate a given version against those
	# variables, if they are defined.
	macro(VALIDATE_VERSION vstatus versionnum)
	  set(${vstatus} "NOTFOUND")
	  if(TCL_EXACT_VERSION)
	    if(${TCL_EXACT_VERSION} VERSION_EQUAL ${versionnum})
	      set(${vstatus} 1)
	    else()
	      set(${vstatus} 0)
	    endif()
	  else()
	    set(vminpass "NOTFOUND")
	    set(vmaxpass "NOTFOUND")
	    if(TCL_MIN_VERSION)
	      if(${versionnum} VERSION_LESS ${TCL_MIN_VERSION})
		set(vminpass 0)
	      else()
		set(vminpass 1)
	      endif()
	    else()
	      set(vminpass 1)
	    endif()
	    if(TCL_MAX_VERSION)
	      if(${versionnum} VERSION_GREATER ${TCL_MIN_VERSION})
		set(vmaxpass 0)
	      else()
		set(vmaxpass 1)
	      endif()
	    else()
	      set(vmaxpass 1)
	    endif() 
	    if(${vminpass} EQUAL 1 AND ${vmaxpass} EQUAL 1)
	      set(${vstatus} 1)
	    else()
	      set(${vstatus} 0)
	    endif()
	  endif()
	endmacro()


	#-----------------------------------------------------------------------------
	#
	#              Routines for defining sets of file system paths
	#
	#-----------------------------------------------------------------------------

	# For ActiveState's Tcl/Tk install on Windows, there are some specific
	# paths that may be needed.  This is a macro-ized version of the paths
	# found in CMake's FindTCL.cmake
	macro(WIN32TCLPATHS vararray extension)
	  if(WIN32)
	    get_filename_component(
	      ActiveTcl_CurrentVersion 
	      "[HKEY_LOCAL_MACHINE\\SOFTWARE\\ActiveState\\ActiveTcl;CurrentVersion]" 
	      NAME)
	    set(${vararray} ${${vararray}}
	      "[HKEY_LOCAL_MACHINE\\SOFTWARE\\ActiveState\\ActiveTcl\\${ActiveTcl_CurrentVersion}]/${extension}")
	    foreach(MAJORNUM ${TCL_POSSIBLE_MAJOR_VERSIONS})
	      foreach(MINORNUM ${TCL_POSSIBLE_MINOR_VERSIONS})
		set(${vararray} ${${vararray}} "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Scriptics\\Tcl\\${MAJORNUM}.${MINORNUM};Root]/${extension}")
	      endforeach()
	    endforeach()
	    set(${vararray} ${${vararray}} "C:/Tcl")
	  endif(WIN32)
	endmacro(WIN32TCLPATHS)




	macro(FIND_PROGRAM_PATHS PROGRAM_PATHS FOUND_PATHS majorlibnum minorlibnum)
	  set(PROGRAM_MIDPATH "bin;sbin")
	  set(PROGRAM_APPENDPATH "")
	  set(PROGRAM_SEARCH_PATHS "")
	  foreach(foundpath ${${FOUND_PATHS}})
	    foreach(midpath ${PROGRAM_MIDPATH})
	      set(PROGRAM_SEARCH_PATHS "${PROGRAM_SEARCH_PATHS};${foundpath}/${midpath}")
	      foreach(appendpath ${PROGRAM_APPENDPATH})
		set(PROGRAM_SEARCH_PATHS "${PROGRAM_SEARCH_PATHS};${foundpath}/${midpath}/${appendpath}")
	      endforeach(appendpath ${PROGRAM_APPENDPATH})
	    endforeach(midpath ${PROGRAM_MIDPATH})
	    set(CONFGENPATHS "")
	    foreach(genpath ${PROGRAM_SEARCH_PATHS})
	      set(CONFGENPATHS "${CONFGENPATHS};${genpath}${majorlibnum}${minorlibnum};${genpath}${majorlibnum}.${minorlibnum}")
	    endforeach(genpath ${PROGRAM_SEARCH_PATHS})
	    set(${PROGRAM_SEARCH_PATHS} "${PROGRAM_SEARCH_PATHS};${CONFGENPATHS}")
	  endforeach()
	  set(${PROGRAM_PATHS} ${PROGRAM_SEARCH_PATHS})
	endmacro()

	macro(FIND_LIBRARY_PATHS LIBRARY_PATHS FOUND_PATHS majorlibnum minorlibnum)
	  set(LIBRARY_MIDPATH "lib;lib64")
	  set(LIBRARY_APPENDPATH "tcl;tk;tcltk;tcltk/tcl;tcltk/tk")
	  set(LIBRARY_SEARCH_PATHS "")
	  foreach(foundpath ${${FOUND_PATHS}})
	    foreach(midpath ${LIBRARY_MIDPATH})
	      set(LIBRARY_SEARCH_PATHS "${LIBRARY_SEARCH_PATHS};${foundpath}/${midpath}")
	      foreach(appendpath ${LIBRARY_APPENDPATH})
		set(LIBRARY_SEARCH_PATHS "${LIBRARY_SEARCH_PATHS};${foundpath}/${midpath}/${appendpath}")
	      endforeach(appendpath ${LIBRARY_APPENDPATH})
	    endforeach(midpath ${LIBRARY_MIDPATH})
	    set(CONFGENPATHS "")
	    foreach(genpath ${LIBRARY_SEARCH_PATHS})
	      set(CONFGENPATHS "${CONFGENPATHS};${genpath}${majorlibnum}${minorlibnum};${genpath}${majorlibnum}.${minorlibnum}")
	    endforeach(genpath ${LIBRARY_SEARCH_PATHS})
	    set(${LIBRARY_SEARCH_PATHS} "${LIBRARY_SEARCH_PATHS};${CONFGENPATHS}")
	  endforeach()
	  set(${LIBRARY_PATHS} ${LIBRARY_SEARCH_PATHS})
	endmacro()

	macro(FIND_INCLUDE_PATHS INCLUDE_PATHS FOUND_PATHS majorlibnum minorlibnum)
	  set(INCLUDE_MIDPATH "include")
	  set(INCLUDE_APPENDPATH "tcl;tk;tcltk;tcltk/tcl;tcltk/tk")
	  set(INCLUDE_SEARCH_PATHS "")
	  foreach(foundpath ${${FOUND_PATHS}})
	    foreach(midpath ${INCLUDE_MIDPATH})
	      set(INCLUDE_SEARCH_PATHS "${INCLUDE_SEARCH_PATHS};${foundpath}/${midpath}")
	      foreach(appendpath ${INCLUDE_APPENDPATH})
		set(INCLUDE_SEARCH_PATHS "${INCLUDE_SEARCH_PATHS};${foundpath}/${midpath}/${appendpath}")
	      endforeach(appendpath ${INCLUDE_APPENDPATH})
	    endforeach(midpath ${INCLUDE_MIDPATH})
	    set(CONFGENPATHS "")
	    foreach(genpath ${INCLUDE_SEARCH_PATHS})
	      set(CONFGENPATHS "${CONFGENPATHS};${genpath}${majorlibnum}${minorlibnum};${genpath}${majorlibnum}.${minorlibnum}")
	    endforeach(genpath ${INCLUDE_SEARCH_PATHS})
	    set(${INCLUDE_SEARCH_PATHS} "${INCLUDE_SEARCH_PATHS};${CONFGENPATHS}")
	  endforeach()
	  set(${INCLUDE_PATHS} ${INCLUDE_SEARCH_PATHS})
	endmacro()


	macro(FIND_POSSIBLE_PATHS targetbinnames targetlibnames pathnames options)
	  set(PATH_RESULTS "")
	  foreach(MAJORNUM ${TCL_POSSIBLE_MAJOR_VERSIONS})
	    foreach(MINORNUM ${TCL_POSSIBLE_MINOR_VERSIONS})
	      foreach(SPATH ${${pathnames}})
		set(TCL_CURRENTPATH TCL-NOTFOUND)
		set(CURRENT_SEARCH_VERSION "${MAJORNUM}.${MINORNUM}")
		VALIDATE_VERSION(dosearch ${CURRENT_SEARCH_VERSION})
		if(dosearch)
		  FIND_PROGRAM_PATHS(BIN_POSSIBLE_PATHS SPATH ${MAJORNUM} ${MINORNUM})
		  FIND_LIBRARY_PATHS(LIB_POSSIBLE_PATHS SPATH ${MAJORNUM} ${MINORNUM})
		  foreach(targetbin ${targetbinnames})
		    if(TCL_CURRENTPATH MATCHES "NOTFOUND$")
		      find_program(TCL_CURRENTPATH NAMES ${targetbin}${MAJORNUM}.${MINORNUM} ${targetbin}${MAJORNUM}${MINORNUM} PATHS ${BIN_POSSIBLE_PATHS} ${options})
		    endif(TCL_CURRENTPATH MATCHES "NOTFOUND$")
		  endforeach(targetbin ${targetbinnames})
		  foreach(targetlib ${targetbinnames})
		    if(TCL_CURRENTPATH MATCHES "NOTFOUND$")
		      find_library(TCL_CURRENTPATH NAMES ${targetlib}${MAJORNUM}.${MINORNUM} ${targetlib}${MAJORNUM}${MINORNUM} PATHS ${LIB_POSSIBE_PATHS} ${options})
		    endif(TCL_CURRENTPATH MATCHES "NOTFOUND$")
		  endforeach(targetlib ${targetbinnames})
		endif(dosearch)
		if(TCL_CURRENTPATH)
		  list(APPEND PATH_RESULTS ${SPATH})
		  list(REMOVE_ITEM ${pathnames} ${SPATH})
		endif(TCL_CURRENTPATH)
	      endforeach(SPATH ${${pathnames}})
	    endforeach()
	  endforeach()
	  set(${pathnames} ${PATH_RESULTS})
	endmacro()


	macro(FIND_CONFIG_FILES FOUND_PATHS TARGET_LIST filename)
	  set(CONFIG_MIDPATH "lib;lib64;share")
	  set(CONFIG_APPENDPATH "tcl;tk;tcltk;tcltk/tcl;tcltk/tk")
	  foreach(foundpath ${${FOUND_PATHS}})
	    set(CONFIG_SEARCH_PATHS "")
	    foreach(midpath ${CONFIG_MIDPATH})
	      set(CONFIG_SEARCH_PATHS "${CONFIG_SEARCH_PATHS};${foundpath}/${midpath}")
	      foreach(appendpath ${CONFIG_APPENDPATH})
		set(CONFIG_SEARCH_PATHS "${CONFIG_SEARCH_PATHS};${foundpath}/${midpath}/${appendpath}")
	      endforeach(appendpath ${CONFIG_APPENDPATH})
	    endforeach(midpath ${CONFIG_MIDPATH})
	    set(CONFGENPATHS "")
	    foreach(MAJORNUM ${TCL_POSSIBLE_MAJOR_VERSIONS})
	      foreach(MINORNUM ${TCL_POSSIBLE_MINOR_VERSIONS})
		set(CURRENT_SEARCH_VERSION "${MAJORNUM}.${MINORNUM}")
		VALIDATE_VERSION(isvalid ${CURRENT_SEARCH_VERSION})
		if(isvalid)
		  foreach(genpath ${CONFIG_SEARCH_PATHS})
		    set(CONFGENPATHS "${CONFGENPATHS};${genpath}${MAJORNUM}${MINORNUM};${genpath}${MAJORNUM}.${MINORNUM}")
		  endforeach(genpath ${CONFIG_SEARCH_PATHS})
		endif(isvalid)
	      endforeach(MINORNUM ${TCL_POSSIBLE_MINOR_VERSIONS})
	    endforeach(MAJORNUM ${TCL_POSSIBLE_MAJOR_VERSIONS})
	    set(CONFIG_SEARCH_PATHS "${CONFIG_SEARCH_PATHS};${CONFGENPATHS}")
	    set(conffile "${filename}-NOTFOUND") 
	    find_file(conffile ${filename} PATHS ${CONFIG_SEARCH_PATHS} NO_SYSTEM_PATH)
	    if(NOT conffile MATCHES "NOTFOUND$")
	      set(${TARGET_LIST} "${${TARGET_LIST}}${conffile};")
	    endif(NOT conffile MATCHES "NOTFOUND$")
	  endforeach()
	endmacro()


	#-----------------------------------------------------------------------------
	#
	#              Routines for resetting Tcl/Tk variables
	#
	#-----------------------------------------------------------------------------


	macro(RESET_TCL_VARS)
	  set(TCL_VERSION_MAJOR "NOTFOUND")
	  set(TCL_VERSION_MINOR "NOTFOUND")
	  set(TCL_VERSION_PATCH "NOTFOUND")
	  set(TCL_INCLUDE_DIRS "NOTFOUND")
	  set(TCL_INCLUDE_PATH "NOTFOUND")
	  set(TCL_LIBRARIES "NOTFOUND")
	  set(TCL_LIBRARY "NOTFOUND")
	  set(TCL_STUB_LIBRARIES "NOTFOUND")
	  set(TCL_STUB_LIBRARY "NOTFOUND")
	  set(TCL_TCLSH "NOTFOUND")
	  set(TCL_TCLSH_EXECUTABLE "NOTFOUND")
	endmacro()

	macro(RESET_TK_VARS)
	  set(TK_VERSION_MAJOR "NOTFOUND")
	  set(TK_VERSION_MINOR "NOTFOUND")
	  set(TK_VERSION_PATCH "NOTFOUND")
	  set(TK_INCLUDE_PATH "NOTFOUND")
	  set(TCL_TK_LIBRARY "NOTFOUND")
	  set(TCL_TK_STUB_LIBRARY "NOTFOUND")
	  set(TCL_WISH_EXECUTABLE "NOTFOUND")
	  set(TK_WISH "NOTFOUND")
	endmacro()

	macro(VALIDATE_TCL_VARIABLES validvar)
	  if(NOT TCL_INCLUDE_PATH AND TCL_NEED_HEADERS)
	    set(${validvar} 0)
	  endif(NOT TCL_INCLUDE_PATH AND TCL_NEED_HEADERS)
	  if(NOT TCL_LIBRARY AND TCL_NEED_HEADERS)
	    set(${validvar} 0)
	  endif(NOT TCL_LIBRARY AND TCL_NEED_HEADERS)
	  if(NOT TCL_STUB_LIBRARY AND TCL_NEED_STUB_LIBS AND TCL_NEED_HEADERS)
	    set(${validvar} 0)
	  endif(NOT TCL_STUB_LIBRARY AND TCL_NEED_STUB_LIBS AND TCL_NEED_HEADERS)
	  if(NOT TCL_TCLSH_EXECUTABLE)
	    set(${validvar} 0)
	  endif(NOT TCL_TCLSH_EXECUTABLE)
	endmacro(VALIDATE_TCL_VARIABLES)


	macro(VALIDATE_TK_VARIABLES validvar)
	  if(NOT TK_INCLUDE_PATH AND TCL_NEED_HEADERS)
	    set(${validvar} 0)
	  endif(NOT TK_INCLUDE_PATH AND TCL_NEED_HEADERS)
	  if(NOT TCL_TK_LIBRARY AND TCL_NEED_HEADERS)
	    set(${validvar} 0)
	  endif(NOT TCL_TK_LIBRARY AND TCL_NEED_HEADERS)
	  if(NOT TCL_TK_STUB_LIBRARY AND TCL_NEED_STUB_LIBS AND TCL_NEED_HEADERS)
	    set(${validvar} 0)
	  endif(NOT TCL_TK_STUB_LIBRARY AND TCL_NEED_STUB_LIBS AND TCL_NEED_HEADERS)
	  if(NOT TCL_WISH_EXECUTABLE)
	    set(${validvar} 0)
	  endif(NOT TCL_WISH_EXECUTABLE)
	endmacro(VALIDATE_TK_VARIABLES)



	#-----------------------------------------------------------------------------
	#
	#       Routines for extracting variable values from Tcl/Tk config files
	#
	#-----------------------------------------------------------------------------

	macro(READ_TCLCONFIG_FILE tclconffile)
	  RESET_TCL_VARS()
	  set(TCL_CONF_FILE "")
	  file(READ ${tclconffile} TCL_CONF_FILE)
	  string(REGEX REPLACE "\r?\n" ";" ENT "${TCL_CONF_FILE}")
	  foreach(line ${ENT})
	    if(${line} MATCHES "TCL_MAJOR_VERSION")
	      string(REGEX REPLACE ".*TCL_MAJOR_VERSION='([0-9]*)'.*" "\\1" TCL_VERSION_MAJOR ${line})
	    endif(${line} MATCHES "TCL_MAJOR_VERSION")
	    if(${line} MATCHES "TCL_MINOR_VERSION")
	      string(REGEX REPLACE ".*TCL_MINOR_VERSION='([0-9]*)'.*" "\\1" TCL_VERSION_MINOR ${line})
	    endif(${line} MATCHES "TCL_MINOR_VERSION")
	    if(${line} MATCHES "TCL_PATCH_LEVEL")
	      string(REGEX REPLACE ".*TCL_PATCH_LEVEL='.([0-9]*)'.*" "\\1" TCL_VERSION_PATCH ${line})
	    endif(${line} MATCHES "TCL_PATCH_LEVEL")
	    if(${line} MATCHES "TCL_INCLUDE")
	      string(REGEX REPLACE ".*TCL_INCLUDE_SPEC='-I(.+)'.*" "\\1" TCL_INCLUDE_PATH ${line})
	    endif()
	    if(${line} MATCHES "TCL_PREFIX")
	      string(REGEX REPLACE ".*TCL_PREFIX='(.+)'" "\\1" TCL_PREFIX ${line})
	    endif()
	    if(${line} MATCHES "TCL_EXEC_PREFIX")
	      if(MSVC)
		set(TCL_EXE_SUFFIX ".exe")
	      else(MSVC)
		set(TCL_EXE_SUFFIX "")
	      endif(MSVC)
	      string(REGEX REPLACE ".*TCL_EXEC_PREFIX='(.+)'.*" "\\1" TCL_TCLSH_EXECUTABLE ${line})
	      IF (EXISTS "${TCL_TCLSH_EXECUTABLE}/bin/tclsh${TCL_VERSION_MAJOR}${TCL_VERSION_MINOR}${TCL_EXE_SUFFIX}")
		set(TCL_TCLSH_EXECUTABLE "${TCL_TCLSH_EXECUTABLE}/bin/tclsh${TCL_VERSION_MAJOR}${TCL_VERSION_MINOR}${TCL_EXE_SUFFIX}")
	      ELSEif(EXISTS "${TCL_TCLSH_EXECUTABLE}/bin/tclsh${TCL_VERSION_MAJOR}.${TCL_VERSION_MINOR}${TCL_EXE_SUFFIX}")
		set(TCL_TCLSH_EXECUTABLE "${TCL_TCLSH_EXECUTABLE}/bin/tclsh${TCL_VERSION_MAJOR}.${TCL_VERSION_MINOR}${TCL_EXE_SUFFIX}")
	      ELSEif(EXISTS "${TCL_TCLSH_EXECUTABLE}/bin/tclsh-${TCL_VERSION_MAJOR}${TCL_VERSION_MINOR}${TCL_EXE_SUFFIX}")
		set(TCL_TCLSH_EXECUTABLE "${TCL_TCLSH_EXECUTABLE}/bin/tclsh-${TCL_VERSION_MAJOR}${TCL_VERSION_MINOR}${TCL_EXE_SUFFIX}")
	      ELSEif(EXISTS "${TCL_TCLSH_EXECUTABLE}/bin/tclsh-${TCL_VERSION_MAJOR}.${TCL_VERSION_MINOR}${TCL_EXE_SUFFIX}")
		set(TCL_TCLSH_EXECUTABLE "${TCL_TCLSH_EXECUTABLE}/bin/tclsh-${TCL_VERSION_MAJOR}.${TCL_VERSION_MINOR}${TCL_EXE_SUFFIX}")
	      ELSEif(EXISTS "${TCL_TCLSH_EXECUTABLE}/bin/tclsh")
		set(TCL_TCLSH_EXECUTABLE "${TCL_TCLSH_EXECUTABLE}/bin/tclsh")
	      endif()
	    endif()
	    if(${line} MATCHES "TCL_STUB_LIB_PATH")
	      string(REGEX REPLACE ".*TCL_STUB_LIB_PATH='(.+)/lib.*" "\\1" TCL_STUB_LIB_PATH ${line})
	    endif()
	    if(${line} MATCHES "TCL_THREADS")
	      string(REGEX REPLACE ".*TCL_THREADS=(.+)" "\\1" TCL_THREADS ${line})
	    endif()
	  endforeach(line ${ENT})
	endmacro()


	macro(READ_TKCONFIG_FILE tkconffile)
	  RESET_TK_VARS()
	  set(TK_CONF_FILE "")
	  file(READ ${tkconffile} TK_CONF_FILE)
	  string(REGEX REPLACE "\r?\n" ";" ENT "${TK_CONF_FILE}")
	  foreach(line ${ENT})
	    if(${line} MATCHES "TK_MAJOR_VERSION")
	      string(REGEX REPLACE ".*TK_MAJOR_VERSION='([0-9]*)'.*" "\\1" TK_VERSION_MAJOR ${line})
	    endif(${line} MATCHES "TK_MAJOR_VERSION")
	    if(${line} MATCHES "TK_MINOR_VERSION")
	      string(REGEX REPLACE ".*TK_MINOR_VERSION='([0-9]*)'.*" "\\1" TK_VERSION_MINOR ${line})
	    endif(${line} MATCHES "TK_MINOR_VERSION")
	    if(${line} MATCHES "TK_PATCH_LEVEL")
	      string(REGEX REPLACE ".*TK_PATCH_LEVEL='.([0-9]*)'.*" "\\1" TK_VERSION_PATCH ${line})
	    endif(${line} MATCHES "TK_PATCH_LEVEL")
	    if(${line} MATCHES "TK_.*INCLUDE")
	      string(REGEX REPLACE ".*TK_.*INCLUDE.*='-I(.+)'.*" "\\1" TK_INCLUDE_PATH ${line})
	    endif()
	    if(${line} MATCHES "TK_PREFIX")
	      string(REGEX REPLACE ".*TK_PREFIX='(.+)'" "\\1" TK_PREFIX ${line})
	    endif()
	    if(${line} MATCHES "TK_EXEC_PREFIX")
	      if(MSVC)
		set(TK_EXE_SUFFIX ".exe")
	      else(MSVC)
		set(TK_EXE_SUFFIX "")
	      endif(MSVC)
	      string(REGEX REPLACE ".*TK_EXEC_PREFIX='(.+)'.*" "\\1" TCL_WISH_EXECUTABLE ${line})
	      IF (EXISTS "${TCL_WISH_EXECUTABLE}/bin/wish${TK_VERSION_MAJOR}${TK_VERSION_MINOR}${TK_EXE_SUFFIX}")
		set(TCL_WISH_EXECUTABLE "${TCL_WISH_EXECUTABLE}/bin/wish${TK_VERSION_MAJOR}${TK_VERSION_MINOR}${TK_EXE_SUFFIX}")
	      ELSEif(EXISTS "${TCL_WISH_EXECUTABLE}/bin/wish${TK_VERSION_MAJOR}.${TK_VERSION_MINOR}${TK_EXE_SUFFIX}")
		set(TCL_WISH_EXECUTABLE "${TCL_WISH_EXECUTABLE}/bin/wish${TK_VERSION_MAJOR}.${TK_VERSION_MINOR}${TK_EXE_SUFFIX}")
	      ELSEif(EXISTS "${TCL_WISH_EXECUTABLE}/bin/wish-${TK_VERSION_MAJOR}${TK_VERSION_MINOR}${TK_EXE_SUFFIX}")
		set(TCL_WISH_EXECUTABLE "${TCL_WISH_EXECUTABLE}/bin/wish-${TK_VERSION_MAJOR}${TK_VERSION_MINOR}${TK_EXE_SUFFIX}")
	      ELSEif(EXISTS "${TCL_WISH_EXECUTABLE}/bin/wish-${TK_VERSION_MAJOR}.${TK_VERSION_MINOR}${TK_EXE_SUFFIX}")
		set(TCL_WISH_EXECUTABLE "${TCL_WISH_EXECUTABLE}/bin/wish-${TK_VERSION_MAJOR}.${TK_VERSION_MINOR}${TK_EXE_SUFFIX}")
	      ELSEif(EXISTS "${TCL_WISH_EXECUTABLE}/bin/wish")
		set(TCL_WISH_EXECUTABLE "${TCL_WISH_EXECUTABLE}/bin/wish")
	      endif()
	    endif()
	  endforeach(line ${ENT})
	  if(NOT TK_INCLUDE_PATH)
	    set(TK_INCLUDE_PATH ${TCL_INCLUDE_PATH})
	  endif(NOT TK_INCLUDE_PATH)
	endmacro()


	#-----------------------------------------------------------------------------
	#
	#             Validate a Tcl/Tk installation based on options
	#
	#-----------------------------------------------------------------------------

	macro(VALIDATE_TCL validvar)
	  set(${validvar} 1)
	  VALIDATE_TCL_VARIABLES(${validvar})
	  if(TCL_TCLSH_EXECUTABLE)
	    TCL_GET_VERSION(${TCL_TCLSH_EXECUTABLE} CURRENT_SEARCH_VERSION)
	    VALIDATE_VERSION(dosearch ${CURRENT_SEARCH_VERSION})
	    if(NOT dosearch)
	      set(${validvar} 0)
	    endif(NOT dosearch)
	  endif(TCL_TCLSH_EXECUTABLE)
	  if(TCL_REQUIRE_THREADS AND TCL_TCLSH_EXECUTABLE)
	    TCL_ISTHREADED(${TCL_TCLSH_EXECUTABLE} TCL_THREADS)
	    if(NOT TCL_THREADS)
	      set(${validvar} 0)
	    endif(NOT TCL_THREADS)
	  endif(TCL_REQUIRE_THREADS AND TCL_TCLSH_EXECUTABLE)
	endmacro(VALIDATE_TCL)

	macro(VALIDATE_TK validvar)
	  set(${validvar} 1)
	  VALIDATE_TK_VARIABLES(${validvar})
	  if(TK_NATIVE_GRAPHICS OR TK_X11_GRAPHICS)
	    TK_GRAPHICS_SYSTEM(${TCL_WISH_EXECUTABLE} TK_SYSTEM_GRAPHICS)
	    if(APPLE AND TK_NATIVE_GRAPHICS)
	      if(NOT ${TK_SYSTEM_GRAPHICS} MATCHES "aqua")
		set(${validvar} 0)
	      endif()
	    endif()
	    if(WIN32 AND TK_NATIVE_GRAPHICS)
	      if(NOT ${TK_SYSTEM_GRAPHICS} MATCHES "win32")
		set(${validvar} 0)
	      endif()
	    endif()
	    if(TK_X11_GRAPHICS)
	      if(NOT ${TK_SYSTEM_GRAPHICS} MATCHES "x11")
		set(${validvar} 0)
	      endif()
	    endif()
	  endif(TK_NATIVE_GRAPHICS OR TK_X11_GRAPHICS)
	endmacro(VALIDATE_TK)


	#-----------------------------------------------------------------------------
	#
	#            Main Search Logic - Search for Tcl/Tk installations 
	#
	# The general rules for searching are as follows:
	#
	# 1.  If a prefix is specified, use only that prefix in the search - 
	#     do not attempt to find Tcl/Tk elsewhere on the system.
	#
	# 2.  If on Apple, check for Framework installations - they will be the
	#     first to be checked - potentially the only one(s) checked, depending
	#     on option settings.
	# 
	# 3.  If options allow/dictate, pull all environment variables that might
	#     point to Tcl/Tk paths and look for tclsh/wish/libtcl/libtk variations
	#     in those paths.  Use the paths that contain at least one of the
	#     binary/library files as a basis for generating paths to look for
	#     config files.
	# 
	# 4.  Search for config files, and if found read key variables from the
	#     files.  Config files are preferred when available, since they
	#     help to ensure the Find routines don't accidentally find mis-matched
	#     binary/library/include files.
	#
	# 5.  If config files found, use those paths to find full paths to binaries
	#     and libraries.
	#
	# 6.  If config files are NOT found, fall back on an ordered path search,
	#     with higher versions being preferred over lower.  This is done only
	#     to locate a runnable Tcl/Tk and will not set variables related to
	#     config files or include paths.  It is a last resort intended to
	#     allow systems that provide a stripped down Tcl/Tk to return useful
	#     results when the only functionality needed by the CMake project
	#     is to run tclsh/wish.
	#
	#-----------------------------------------------------------------------------

	# Because it is not out of the question for a build system to be building
	# its own local copy of Tcl/Tk (and hence define the needed variables
	# on its own) we check up front to see if all of the options have already
	# been satisfied by a mechanism other than find_package
	include(FindPackageHandleStandardArgs)
	set(PACKAGE_HANDLE_VARS "TCL_TCLSH_EXECUTABLE")
	set(TCL_TCLSH ${TCL_TCLSH_EXECUTABLE}) #Deprecated
	set(PACKAGE_HANDLE_VARS "${PACKAGE_HANDLE_VARS} TCL_TCLSH")
	if(TCL_NEED_HEADERS)
	  set(PACKAGE_HANDLE_VARS "${PACKAGE_HANDLE_VARS} TCL_LIBRARIES TCL_INCLUDE_DIRS TCL_CONF_PREFIX TCL_LIBRARY TCL_INCLUDE_PATH")
	  if(TCL_NEED_STUB_LIBS)
	    set(PACKAGE_HANDLE_VARS "${PACKAGE_HANDLE_VARS} TCL_STUB_LIBRARIES TCL_STUB_LIBRARY")
	  endif(TCL_NEED_STUB_LIBS)

	  if(TCL_REQUIRE_TK)
	    set(PACKAGE_HANDLE_VARS "${PACKAGE_HANDLE_VARS} TK_INCLUDE_PATH TCL_TK_CONF_PREFIX TCL_TK_LIBRARY TCL_WISH_EXECUTABLE")
	    set(TK_LIBRARY ${TCL_TK_LIBRARY}) # Deprecated
	    set(PACKAGE_HANDLE_VARS "${PACKAGE_HANDLE_VARS} TK_LIBRARY")
	    if(TCL_NEED_STUB_LIBS)
	      set(PACKAGE_HANDLE_VARS "${PACKAGE_HANDLE_VARS} TCL_TK_STUB_LIBRARY")
	      set(TK_STUB_LIBRARY ${TCL_TK_STUB_LIBRARY}) #Deprecated
	      set(PACKAGE_HANDLE_VARS "${PACKAGE_HANDLE_VARS} TK_STUB_LIBRARY")
	    endif(TCL_NEED_STUB_LIBS)
	  endif(TCL_REQUIRE_TK)
	else(TCL_NEED_HEADERS)
	  if(TCL_REQUIRE_TK)
	    set(PACKAGE_HANDLE_VARS "${PACKAGE_HANDLE_VARS} TCL_WISH_EXECUTABLE")
	    set(TK_WISH ${TCL_WISH_EXECUTABLE}) #Deprecated
	    set(PACKAGE_HANDLE_VARS "${PACKAGE_HANDLE_VARS} TK_WISH")
	  endif(TCL_REQUIRE_TK)
	endif(TCL_NEED_HEADERS)
	string(REGEX REPLACE " " ";" PACKAGE_HANDLE_VARS "${PACKAGE_HANDLE_VARS}")
	set(TCL_FOUND TRUE)
	foreach(REQUIRED_VAR ${PACKAGE_HANDLE_VARS})
	  if(NOT ${REQUIRED_VAR})
	    set(TCL_FOUND FALSE)
	  endif(NOT ${REQUIRED_VAR})
	endforeach(REQUIRED_VAR ${PACKAGE_HANDLE_VARS})


	# Try to be a bit forgiving with the TCL prefix - if someone gives the
	# full path to the lib directory, catch that by adding the parent path
	# to the list to check
	if(NOT TCL_FOUND)
	  if(TCL_PREFIX)
	    set(TCL_LIBRARY "NOTFOUND")
	    set(TCL_PREFIX_LIBDIRS ${TCL_PREFIX_LIBDIRS} ${TCL_PREFIX}/lib)
	    set(TCL_PREFIX_LIBDIRS ${TCL_PREFIX_LIBDIRS} ${TCL_PREFIX})
	    get_filename_component(TCL_LIB_PATH_PARENT "${TCL_PREFIX}" PATH)
	    set(TCL_PREFIX_LIBDIRS ${TCL_PREFIX_LIBDIRS} ${TCL_LIB_PATH_PARENT}/lib)
	    set(TCL_PREFIX_LIBDIRS ${TCL_PREFIX_LIBDIRS} ${TCL_LIB_PATH_PARENT})
	    list(REMOVE_DUPLICATES TCL_PREFIX_LIBDIRS)
	    FIND_LIBRARY_VERSIONS(tcl TCL_PREFIX_LIBDIRS NO_SYSTEM_PATH)
	    set(FOUND_FILES "${TCL_tcl_LIST}")
	    FIND_CONFIG_FILES(FOUND_FILES TCLCONFIG_LIST tclConfig.sh)
	    if(TCL_REQUIRE_TK)
	      FIND_LIBRARY_VERSIONS(tk TCL_PREFIX_LIBDIRS NO_SYSTEM_PATH)
	      set(FOUND_FILES "${TCL_tk_LIST}")
	      FIND_CONFIG_FILES(FOUND_FILES TKCONFIG_LIST tkConfig.sh)
	    endif(TCL_REQUIRE_TK)
	  else(TCL_PREFIX)
	    set(TCLCONFIG_LIST "")
	    if(APPLE)
	      include(CMakeFindFrameworks)
	      CMAKE_FIND_FRAMEWORKS(Tcl)
	      foreach(dir ${Tcl_FRAMEWORKS})
		set(tclconf "tclConfig.sh-NOTFOUND") 
		find_file(tclconf tclConfig.sh PATHS ${dir})
		mark_as_advanced(tclconf)
		if(NOT tclconf MATCHES "NOTFOUND$")
		  set(TCLCONFIG_LIST "${TCLCONFIG_LIST}${tclconf};")
		endif(NOT tclconf MATCHES "NOTFOUND$")
	      endforeach(dir ${Tcl_FRAMEWORKS})
	      if(TCL_REQUIRE_TK)
		CMAKE_FIND_FRAMEWORKS(Tk)
		foreach(dir ${Tk_FRAMEWORKS})
		  set(tkconf "tkConfig.sh-NOTFOUND") 
		  find_file(tkconf tkConfig.sh PATHS ${dir})
		  mark_as_advanced(tkconf)
		  if(NOT tkconf MATCHES "NOTFOUND$")
		    set(TKCONFIG_LIST "${TKCONFIG_LIST}${tkconf};")
		  endif(NOT tkconf MATCHES "NOTFOUND$")
		endforeach(dir ${Tk_FRAMEWORKS})
	      endif(TCL_REQUIRE_TK)
	    endif(APPLE)
	    if(NOT APPLE OR NOT TCL_USE_FRAMEWORK_ONLY)                                                                      
	      set(PATHLIST "$ENV{LD_LIBRARY_PATH}:$ENV{DYLD_LIBRARY_PATH}:$ENV{DYLD_FALLBACK_LIBRARY_PATH}:$ENV{PATH}")
	      set(PATHLIST "${TCL_ADDITIONAL_SEARCH_PATHS}:${PATHLIST}")
	      if(WIN32)
		WIN32TCLPATHS(PATHLIST "")
	      endif(WIN32)
	      string(REGEX REPLACE "/s?bin:" ":" PATHLIST "${PATHLIST}")
	      string(REGEX REPLACE "/s?bin;" ":" PATHLIST "${PATHLIST}")
	      string(REGEX REPLACE "/lib6?4?:" ":" PATHLIST "${PATHLIST}")
	      string(REGEX REPLACE "/lib6?4?;" ":" PATHLIST "${PATHLIST}")
	      string(REGEX REPLACE ":" ";" PATHLIST "${PATHLIST}")
	      list(REMOVE_DUPLICATES PATHLIST)
	      foreach(foundpath ${PATHLIST})
		foreach(pattern ${TCL_PATH_NOMATCH_PATTERNS})
		  if(foundpath MATCHES "${pattern}")
		    list(REMOVE_ITEM PATHLIST ${foundpath})
		  endif(foundpath MATCHES "${pattern}")
		endforeach(pattern ${TCL_PATH_NOMATCH_PATTERNS})
	      endforeach()
	      set(TCLPATHLIST "${PATHLIST}")
	      set(TKPATHLIST "${PATHLIST}")
	      FIND_POSSIBLE_PATHS("tclsh" "tcl" TCLPATHLIST NO_SYSTEM_PATH)
	      if(TCL_REQUIRE_TK)
		FIND_POSSIBLE_PATHS("wish" "tk" TKPATHLIST NO_SYSTEM_PATH)
	      endif(TCL_REQUIRE_TK)
	      # Hunt up tclConfig.sh files
	      FIND_CONFIG_FILES(TCLPATHLIST TCLCONFIG_LIST tclConfig.sh)
	      # Hunt up tkConfig.sh files 
	      FIND_CONFIG_FILES(TKPATHLIST TKCONFIG_LIST tkConfig.sh)
	    endif(NOT APPLE OR NOT TCL_USE_FRAMEWORK_ONLY)
	  endif(TCL_PREFIX)
	  set(TCLVALID 0)
	  RESET_TCL_VARS()
	  foreach(tcl_config_file ${TCLCONFIG_LIST}) 
	    if(NOT TCLVALID)
	      RESET_TCL_VARS()
	      READ_TCLCONFIG_file(${tcl_config_file})
	      set(TCLVALID 1)
	      set(CURRENTTCLVERSION "${TCL_VERSION_MAJOR}.${TCL_VERSION_MINOR}.${TCL_VERSION_PATCH}")
	      VALIDATE_VERSION(TCLVALID ${CURRENTTCLVERSION})
	      if(TCLVALID)
		get_filename_component(TCL_CONF_PREFIX "${tcl_config_file}" PATH)
		get_filename_component(TCL_LIBRARY_DIR2 "${TCL_CONF_PREFIX}" PATH)
		FIND_LIBRARY_PATHS(TCL_LIBRARY_SEARCH_PATHS TCL_PREFIX ${TCL_VERSION_MAJOR} ${TCL_VERSION_MINOR})
		set(TCL_LIBRARY_SEARCH_PATHS "${TCL_CONF_PREFIX};${TCL_LIBRARY_DIR2};${TCL_LIBRARY_SEARCH_PATHS}")
		find_library(TCL_LIBRARY tcl Tcl tcl${TCL_VERSION_MAJOR}.${TCL_VERSION_MINOR} tcl${TCL_VERSION_MAJOR}${TCL_VERSION_MINOR} PATHS ${TCL_LIBRARY_SEARCH_PATHS} NO_SYSTEM_PATH)
		find_library(TCL_STUB_LIBRARY tclstub${TCL_VERSION_MAJOR}.${TCL_VERSION_MINOR} tclstub${TCL_VERSION_MAJOR}${TCL_VERSION_MINOR} PATHS ${TCL_LIBRARY_SEARCH_PATHS} NO_SYSTEM_PATH)
	      endif(TCLVALID)
	      VALIDATE_TCL(TCLVALID)
	      if(TCLVALID)
		if(TCL_REQUIRE_TK)
		  set(TKVALID 0)
		  foreach(tk_config_file ${TKCONFIG_LIST})
		    if(NOT TKVALID)
		      RESET_TK_VARS()
		      READ_TKCONFIG_file(${tk_config_file})
		      set(TKVALID 0)
		      set(CURRENTTKVERSION "${TK_VERSION_MAJOR}.${TK_VERSION_MINOR}.${TK_VERSION_PATCH}")
		      set(vtcltkcompare 0)
		      if(${CURRENTTCLVERSION} VERSION_EQUAL ${CURRENTTKVERSION})
			set(TKVALID 1)
		      else()
			set(TKVALID 0)
		      endif()
		      if(TKVALID)
			get_filename_component(TCL_TK_CONF_PREFIX "${tk_config_file}" PATH)
			get_filename_component(TCL_TK_LIBRARY_DIR2 "${TCL_TK_CONF_PREFIX}" PATH)
			FIND_LIBRARY_PATHS(TCL_TK_LIBRARY_SEARCH_PATHS TK_PREFIX ${TK_VERSION_MAJOR} ${TK_VERSION_MINOR})
			set(TCL_TK_LIBRARY_SEARCH_PATHS "${TCL_TK_CONF_PREFIX};${TCL_TK_LIBRARY_DIR2};${TCL_TK_LIBRARY_SEARCH_PATHS}")
			find_library(TCL_TK_LIBRARY tk Tk tk${TK_VERSION_MAJOR}.${TK_VERSION_MINOR} tk${TK_VERSION_MAJOR}${TK_VERSION_MINOR} PATHS ${TCL_TK_LIBRARY_SEARCH_PATHS} NO_SYSTEM_PATH)
			find_library(TCL_TK_STUB_LIBRARY tkstub tkstub${TK_VERSION_MAJOR}.${TK_VERSION_MINOR} tkstub${TK_VERSION_MAJOR}${TK_VERSION_MINOR} PATHS ${TCL_TK_LIBRARY_SEARCH_PATHS} NO_SYSTEM_PATH)
			VALIDATE_TK(TKVALID)
		      endif(TKVALID)
		    endif(NOT TKVALID)
		  endforeach(tk_config_file ${TKCONFIG_LIST})
		  if(NOT TKVALID)
		    set(TCLVALID 0)
		    RESET_TCL_VARS()
		    RESET_TK_VARS()
		  endif(NOT TKVALID)
		endif(TCL_REQUIRE_TK)
	      endif(TCLVALID)
	    endif(NOT TCLVALID)
	  endforeach(tcl_config_file ${TCLCONFIG_LIST}) 

	  # If we still don't have anything by now, we may have a system without tclConfig.sh and tkConfig.sh
	  # Back to trying to guess values, using the TCLPATHLIST and TKPATHLIST arrays of paths. This is 
	  # attempted ONLY if we are looking for a Tcl/Tk installation to call as a scripting engine and not
	  # as C libraries to build against - the autotools/TEA based Tcl/Tk world requires those files be 
	  # present and any ExternalProject build attempting to use a Tcl/Tk installation without them would 
	  # not succeed.
	  if(NOT TCLVALID AND NOT TCL_NEED_HEADERS)
	    set(PATHLIST "${TCLPATHLIST};${TKPATHLIST}")
	    list(REMOVE_DUPLICATES PATHLIST)
	    foreach(MAJORNUM ${TCL_POSSIBLE_MAJOR_VERSIONS})
	      foreach(MINORNUM ${TCL_POSSIBLE_MINOR_VERSIONS})
		foreach(SPATH ${PATHLIST})
		  if(NOT TCLVALID)
		    RESET_TCL_VARS()
		    set(CURRENT_SEARCH_VERSION "${MAJORNUM}.${MINORNUM}")
		    VALIDATE_VERSION(dosearch ${CURRENT_SEARCH_VERSION})
		    if(dosearch)
		      FIND_LIBRARY_PATHS(TCL_LIBRARY_SEARCH_PATHS SPATH ${MAJORNUM} ${MINORNUM})
		      FIND_PROGRAM_PATHS(TCL_PROGRAM_SEARCH_PATHS SPATH ${MAJORNUM} ${MINORNUM})
		      find_program(TCL_TCLSH_EXECUTABLE NAMES tclsh${MAJORNUM}.${MINORNUM} tclsh${MAJORNUM}${MINORNUM} PATHS ${TCL_PROGRAM_SEARCH_PATHS} NO_SYSTEM_PATH)
		    endif(dosearch)
		    VALIDATE_TCL(TCLVALID)
		    if(TCLVALID)
		      if(TCL_REQUIRE_TK)
			set(TKVALID 0)
			RESET_TK_VARS()
			find_program(TCL_WISH_EXECUTABLE NAMES wish${MAJORNUM}.${MINORNUM} wish${MAJORNUM}${MINORNUM} PATHS ${TCL_PROGRAM_SEARCH_PATHS} NO_SYSTEM_PATH)
			VALIDATE_TK(TKVALID)
			if(NOT TKVALID)
			  set(TCLVALID 0)
			  RESET_TCL_VARS()
			  RESET_TK_VARS()
			endif(NOT TKVALID)	
		      endif(TCL_REQUIRE_TK)
		    else(TCLVALID)
		      RESET_TCL_VARS()
		    endif(TCLVALID)
		  endif(NOT TCLVALID)
		endforeach(SPATH ${PATHLIST})
	      endforeach()
	    endforeach()
	  endif(NOT TCLVALID AND NOT TCL_NEED_HEADERS)

	  # By this point we have found everything we're going to find - set variables to be exposed as results
	  set(TCL_TCLSH ${TCL_TCLSH_EXECUTABLE})
	  set(TK_WISH ${TCL_WISH_EXECUTABLE}) 
	  set(TK_LIBRARY ${TCL_TK_LIBRARY}) # Deprecated
	  set(TK_STUB_LIBRARY ${TCL_TK_STUB_LIBRARY}) 
	  set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_PATH} ${TK_INCLUDE_PATH})
	  set(TCL_LIBRARIES ${TCL_LIBRARY} ${TK_LIBRARY})
	  set(TCL_STUB_LIBRARIES ${TCL_STUB_LIBRARY} ${TK_STUB_LIBRARY})
	  set(TCL_ROOT_PATH ${TCL_CONF_PREFIX})
	  set(TCL_VERSION_STRING "${TCL_VERSION_MAJOR}.${TCL_VERSION_MINOR}.${TCL_VERSION_PATCH}")
	  FIND_PACKAGE_HANDLE_STANDARD_ARGS(TCL DEFAULT_MSG TCL_LIBRARY ${PACKAGE_HANDLE_VARS})
	  if(TCL_REQUIRE_TK)
	    set(TK_FIND_QUIETLY ${TCL_FIND_QUIETLY})
	    set(PACKAGE_HANDLE_VARS "${PACKAGE_HANDLE_VARS};TCL_LIBRARY")
	    FIND_PACKAGE_HANDLE_STANDARD_ARGS(TK DEFAULT_MSG TCL_TK_LIBRARY ${PACKAGE_HANDLE_VARS})
	  endif(TCL_REQUIRE_TK)

	  foreach(pkgvar ${PACKAGE_HANDLE_VARS})
	    set(${pkgvar} ${${pkgvar}} CACHE STRING "set by FindTCL" FORCE)
	  endforeach(pkgvar ${PACKAGE_HANDLE_VARS})

	endif(NOT TCL_FOUND)

	mark_as_advanced(
	  TCL_INCLUDE_DIRS
	  TCL_INCLUDE_PATH
	  TK_INCLUDE_PATH
	  TCL_LIBRARIES
	  TCL_LIBRARY
	  TCL_TK_LIBRARY
	  TK_LIBRARY
	  TCL_STUB_LIBRARIES
	  TCL_STUB_LIBRARY
	  TCL_TK_STUB_LIBRARY
	  TK_STUB_LIBRARY
	  TCL_TCLSH_EXECUTABLE
	  TCL_TCLSH
	  TCL_WISH_EXECUTABLE
	  TK_WISH
	  TCL_CONF_PREFIX
	  TCL_TK_CONF_PREFIX
	  )

	# Other variables to hide
	mark_as_advanced(
	  TCL_CURRENTPATH
	  TCL_MIN_VERSION
	  TCL_MAX_VERSION
	  TCL_NEED_HEADERS
	  TCL_NEED_STUB_LIBS
	  TCL_PATH_NOMATCH_PATTERNS
	  TCL_REQUIRE_THREADS
	  TCL_REQUIRE_TK
	  TCL_USE_FRAMEWORK_ONLY
	  TK_NATIVE_GRAPHICS
	  TK_X11_GRAPHICS
	  conffile
	  USE_TCL_STUBS
	  USE_TK_STUBS
	  )


	# Local Variables:
	# tab-width: 8
	# mode: cmake
	# indent-tabs-mode: t
	# End:
	# ex: shiftwidth=2 tabstop=8
blob
data 26152
#                   F I N D X 1 1 . C M A K E
# BRL-CAD
#
# Copyright (c) 2001-2012 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
#
# 3. The name of the author may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
###
# - Find X11 installation
# Try to find X11 on UNIX systems. The following values are defined
#  X11_FOUND        - True if X11 is available
#  X11_INCLUDE_DIR  - include directories to use X11
#  X11_LIBRARIES    - link against these to use X11
#
# and also the following more fine grained variables:
# Include paths: X11_ICE_INCLUDE_PATH,          X11_ICE_LIB,        X11_ICE_FOUND
#                X11_X11_INCLUDE_PATH,          X11_X11_LIB
#                X11_Xaccessrules_INCLUDE_PATH,                     X11_Xaccess_FOUND
#                X11_Xaccessstr_INCLUDE_PATH,                       X11_Xaccess_FOUND
#                X11_Xau_INCLUDE_PATH,          X11_Xau_LIB,        X11_Xau_FOUND
#                X11_Xcomposite_INCLUDE_PATH,   X11_Xcomposite_LIB, X11_Xcomposite_FOUND
#                X11_Xcursor_INCLUDE_PATH,      X11_Xcursor_LIB,    X11_Xcursor_FOUND
#                X11_Xdamage_INCLUDE_PATH,      X11_Xdamage_LIB,    X11_Xdamage_FOUND
#                X11_Xdmcp_INCLUDE_PATH,        X11_Xdmcp_LIB,      X11_Xdmcp_FOUND
#                                               X11_Xext_LIB,       X11_Xext_FOUND
#                X11_dpms_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_dpms_FOUND
#                X11_XShm_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_XShm_FOUND
#                X11_Xshape_INCLUDE_PATH,       (in X11_Xext_LIB),  X11_Xshape_FOUND
#                X11_xf86misc_INCLUDE_PATH,     X11_Xxf86misc_LIB,  X11_xf86misc_FOUND
#                X11_xf86vmode_INCLUDE_PATH,                        X11_xf86vmode_FOUND
#                X11_Xfixes_INCLUDE_PATH,       X11_Xfixes_LIB,     X11_Xfixes_FOUND
#                X11_Xft_INCLUDE_PATH,          X11_Xft_LIB,        X11_Xft_FOUND
#                X11_Xi_INCLUDE_PATH,           X11_Xi_LIB,         X11_Xi_FOUND
#                X11_Xinerama_INCLUDE_PATH,     X11_Xinerama_LIB,   X11_Xinerama_FOUND
#                X11_Xinput_INCLUDE_PATH,       X11_Xinput_LIB,     X11_Xinput_FOUND
#                X11_Xkb_INCLUDE_PATH,                              X11_Xkb_FOUND
#                X11_Xkblib_INCLUDE_PATH,                           X11_Xkb_FOUND
#                X11_Xpm_INCLUDE_PATH,          X11_Xpm_LIB,        X11_Xpm_FOUND
#                X11_XTest_INCLUDE_PATH,        X11_XTest_LIB,      X11_XTest_FOUND
#                X11_Xrandr_INCLUDE_PATH,       X11_Xrandr_LIB,     X11_Xrandr_FOUND
#                X11_Xrender_INCLUDE_PATH,      X11_Xrender_LIB,    X11_Xrender_FOUND
#                X11_Xscreensaver_INCLUDE_PATH, X11_Xscreensaver_LIB, X11_Xscreensaver_FOUND
#                X11_Xt_INCLUDE_PATH,           X11_Xt_LIB,         X11_Xt_FOUND
#                X11_Xutil_INCLUDE_PATH,                            X11_Xutil_FOUND
#                X11_Xv_INCLUDE_PATH,           X11_Xv_LIB,         X11_Xv_FOUND

#=============================================================================
# Copyright 2001-2009 Kitware, Inc.
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 
# * Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
# 
# * Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
# 
# * Neither the names of Kitware, Inc., the Insight Software Consortium,
#   nor the names of their contributors may be used to endorse or promote
#   products derived from this software without specific prior written
#   permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
# ------------------------------------------------------------------------------
# 
# The above copyright and license notice applies to distributions of
# CMake in source and binary form.  Some source files contain additional
# notices of original copyright by their contributors; see each source
# for details.  Third-party software packages supplied with CMake under
# compatible licenses provide their own copyright notices documented in
# corresponding subdirectories.
# 
# ------------------------------------------------------------------------------
# 
# CMake was initially developed by Kitware with the following sponsorship:
# 
#  * National Library of Medicine at the National Institutes of Health
#    as part of the Insight Segmentation and Registration Toolkit (ITK).
# 
#  * US National Labs (Los Alamos, Livermore, Sandia) ASC Parallel
#    Visualization Initiative.
# 
#  * National Alliance for Medical Image Computing (NAMIC) is funded by the
#    National Institutes of Health through the NIH Roadmap for Medical Research,
#    Grant U54 EB005149.
# 
#  * Kitware, Inc.
# 
#=============================================================================

MACRO(X11_FIND_INCLUDE_PATH component header)
  find_path(X11_${component}_INCLUDE_PATH ${header} ${X11_INC_SEARCH_PATH} NO_CMAKE_SYSTEM_PATH)
  set(X11_HDR_VARS ${X11_HDR_VARS} X11_${component}_INCLUDE_PATH)
  if(X11_${component}_INCLUDE_PATH)
    set(X11_HDR_PATHS ${X11_HDR_PATHS} ${X11_${component}_INCLUDE_PATH})
    list(REMOVE_DUPLICATES X11_HDR_PATHS)
  endif(X11_${component}_INCLUDE_PATH)
ENDMACRO(X11_FIND_INCLUDE_PATH)

MACRO(X11_FIND_LIB_PATH component libname)
  find_library(X11_${component}_LIB ${libname} ${X11_LIB_SEARCH_PATH} NO_CMAKE_SYSTEM_PATH)
  set(X11_LIB_VARS ${X11_LIB_VARS} X11_${component}_LIB)
  if(X11_${component}_LIB)
    get_filename_component(X11_${component}_DIR ${X11_${component}_LIB} PATH)
    set(X11_LIB_PATHS ${X11_LIB_PATHS} ${X11_${component}_DIR})
    list(REMOVE_DUPLICATES X11_LIB_PATHS)
  endif(X11_${component}_LIB)
ENDMACRO(X11_FIND_LIB_PATH)

if(UNIX)
  set(X11_FOUND 0)
  # X11 is never a framework and some header files may be
  # found in tcl on the mac
  set(CMAKE_FIND_FRAMEWORK_SAVE ${CMAKE_FIND_FRAMEWORK})
  set(CMAKE_FIND_FRAMEWORK NEVER)


  # See whether we're looking for 32 or 64 bit libraries,
  # and organize our search directories accordingly.  The
  # common convention is to use lib64 for 64 bit versions of
  # libraries, but some distributions (notably archlinux) 
  # use lib32 for 32 bit and lib for 64 bit.
  get_property(SEARCH_64BIT GLOBAL PROPERTY FIND_LIBRARY_USE_LIB64_PATHS)
  if(SEARCH_64BIT)
    set(64BIT_DIRS "/usr/lib64/X11;/usr/lib64;/usr/lib/x86_64-linux-gnu")
    if(EXISTS "/usr/lib32" OR NOT EXISTS "/usr/lib64")
      set(64BIT_DIRS ${64BIT_DIRS} /usr/lib/X11 /usr/lib)
    endif(EXISTS "/usr/lib32" OR NOT EXISTS "/usr/lib64")
  else(SEARCH_64BIT)
    set(32BIT_DIRS "/usr/lib32/X11;/usr/lib32;/usr/lib/i386-linux-gnu")
    if(EXISTS "/usr/lib64" OR NOT EXISTS "/usr/lib32")
      set(32BIT_DIRS ${32BIT_DIRS} /usr/lib/X11 /usr/lib)
    endif(EXISTS "/usr/lib64" OR NOT EXISTS "/usr/lib32")
  endif(SEARCH_64BIT)

  # Candidate directories for headers
  set(X11_INC_SEARCH_PATH
    /usr/X11/include
    /usr/X11R7/include
    /usr/X11R6/include
    /usr/include/X11
    /usr/local/include/X11
    /usr/local/include
    /usr/include
    /usr/openwin/share/include
    /usr/openwin/include
    /usr/pkg/xorg/include
    /opt/graphics/OpenGL/include
    )

  # Candidate directories for libraries.
  set(X11_LIB_SEARCH_PATH
    ${64BIT_DIRS}
    ${32BIT_DIRS}
    /usr/X11/lib
    /usr/X11R7/lib
    /usr/X11R6/lib
    /usr/openwin/lib
    /usr/pkg/xorg/lib
    )

  # Just in case, clear our lists
  set(X11_HDR_VARS)
  set(X11_HDR_PATHS)
  set(X11_LIB_VARS)
  set(X11_LIB_PATHS)
  
  # Find primary X11 headers
  X11_FIND_INCLUDE_PATH(X11		X11/X.h)
  X11_FIND_INCLUDE_PATH(Xlib		X11/Xlib.h)
  # Look for other X11 includes; keep the list sorted by name of the cmake X11_<component>_INCLUDE_PATH
  # variable (component doesn't need to match the include file name).
  X11_FIND_INCLUDE_PATH(ICE 		X11/ICE/ICE.h)
  X11_FIND_INCLUDE_PATH(Xaccessrules 	X11/extensions/XKBrules.h)
  X11_FIND_INCLUDE_PATH(Xaccessstr 	X11/extensions/XKBstr.h)
  X11_FIND_INCLUDE_PATH(Xau 		X11/Xauth.h)
  X11_FIND_INCLUDE_PATH(Xcomposite 	X11/extensions/Xcomposite.h)
  X11_FIND_INCLUDE_PATH(Xcursor 	X11/Xcursor/Xcursor.h)
  X11_FIND_INCLUDE_PATH(Xdamage 	X11/extensions/Xdamage.h)
  X11_FIND_INCLUDE_PATH(Xdmcp 		X11/Xdmcp.h)
  X11_FIND_INCLUDE_PATH(dpms 		X11/extensions/dpms.h)
  X11_FIND_INCLUDE_PATH(xf86misc 	X11/extensions/xf86misc.h)
  X11_FIND_INCLUDE_PATH(xf86vmode 	X11/extensions/xf86vmode.h)
  X11_FIND_INCLUDE_PATH(Xfixes		X11/extensions/Xfixes.h)
  X11_FIND_INCLUDE_PATH(Xft		X11/Xft/Xft.h)
  X11_FIND_INCLUDE_PATH(Xi		X11/extensions/XInput.h)
  X11_FIND_INCLUDE_PATH(Xinerama	X11/extensions/Xinerama.h)
  X11_FIND_INCLUDE_PATH(Xinput		X11/extensions/XInput.h)
  X11_FIND_INCLUDE_PATH(Xkb		X11/extensions/XKB.h)
  X11_FIND_INCLUDE_PATH(Xkblib		X11/XKBlib.h)
  X11_FIND_INCLUDE_PATH(Xpm		X11/xpm.h)
  X11_FIND_INCLUDE_PATH(XTest		X11/extensions/XTest.h)
  X11_FIND_INCLUDE_PATH(XShm		X11/extensions/XShm.h)
  X11_FIND_INCLUDE_PATH(Xrandr		X11/extensions/Xrandr.h)
  X11_FIND_INCLUDE_PATH(Xrender		X11/extensions/Xrender.h)
  X11_FIND_INCLUDE_PATH(Xscreensaver	X11/extensions/scrnsaver.h)
  X11_FIND_INCLUDE_PATH(Xshape		X11/extensions/shape.h)
  X11_FIND_INCLUDE_PATH(Xutil		X11/Xutil.h)
  X11_FIND_INCLUDE_PATH(Xt		X11/Intrinsic.h)
  X11_FIND_INCLUDE_PATH(Xv		X11/extensions/Xvlib.h)
  

  # Find primary X11 library
  X11_FIND_LIB_PATH(X11			X11)
  # Find additional X libraries. Keep list sorted by library name.
  X11_FIND_LIB_PATH(ICE			ICE)
  X11_FIND_LIB_PATH(SM			SM)
  X11_FIND_LIB_PATH(Xau			Xau)
  X11_FIND_LIB_PATH(Xcomposite		Xcomposite)
  X11_FIND_LIB_PATH(Xcursor		Xcursor)
  X11_FIND_LIB_PATH(Xdamage		Xdamage)
  X11_FIND_LIB_PATH(Xdmcp		Xdmcp)
  X11_FIND_LIB_PATH(Xext		Xext)
  X11_FIND_LIB_PATH(Xfixes		Xfixes)
  X11_FIND_LIB_PATH(Xft			Xft)
  X11_FIND_LIB_PATH(Xi			Xi)
  X11_FIND_LIB_PATH(Xinerama		Xinerama)
  X11_FIND_LIB_PATH(Xpm			Xpm)
  X11_FIND_LIB_PATH(Xrandr		Xrandr)
  X11_FIND_LIB_PATH(Xrender		Xrender)
  X11_FIND_LIB_PATH(Xscreensaver	Xss)
  X11_FIND_LIB_PATH(Xt			Xt)
  X11_FIND_LIB_PATH(XTest		Xtst)
  X11_FIND_LIB_PATH(Xv			Xv)
  X11_FIND_LIB_PATH(Xxf86misc		Xxf86misc)

  set(X11_LIBRARY_DIR "")
  if(X11_X11_LIB)
    get_filename_component(X11_LIBRARY_DIR ${X11_X11_LIB} PATH)
  endif(X11_X11_LIB)

  set(X11_INCLUDE_DIR) # start with empty list
  if(X11_X11_INCLUDE_PATH)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_X11_INCLUDE_PATH})
  endif(X11_X11_INCLUDE_PATH)

  if(X11_Xlib_INCLUDE_PATH)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xlib_INCLUDE_PATH})
  endif(X11_Xlib_INCLUDE_PATH)

  if(X11_Xutil_INCLUDE_PATH)
    set(X11_Xutil_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xutil_INCLUDE_PATH})
  endif(X11_Xutil_INCLUDE_PATH)

  if(X11_Xshape_INCLUDE_PATH)
    set(X11_Xshape_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xshape_INCLUDE_PATH})
  endif(X11_Xshape_INCLUDE_PATH)
  
  # We'll need a variable containing all X11 libraries found
  set(X11_LIBRARIES) # start with empty list

  if(X11_X11_LIB)
    set(X11_LIBRARIES ${X11_LIBRARIES} ${X11_X11_LIB})
  endif(X11_X11_LIB)

  if(X11_Xext_LIB)
    set(X11_Xext_FOUND TRUE)
    set(X11_LIBRARIES ${X11_LIBRARIES} ${X11_Xext_LIB})
  endif(X11_Xext_LIB)

  if(X11_Xt_LIB AND X11_Xt_INCLUDE_PATH)
    set(X11_Xt_FOUND TRUE)
  endif(X11_Xt_LIB AND X11_Xt_INCLUDE_PATH)

  if(X11_Xft_LIB AND X11_Xft_INCLUDE_PATH)
    set(X11_Xft_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xft_INCLUDE_PATH})
  endif(X11_Xft_LIB AND X11_Xft_INCLUDE_PATH)

  if(X11_Xv_LIB AND X11_Xv_INCLUDE_PATH)
    set(X11_Xv_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xv_INCLUDE_PATH})
  endif(X11_Xv_LIB AND X11_Xv_INCLUDE_PATH)

  if(X11_Xau_LIB AND X11_Xau_INCLUDE_PATH)
    set(X11_Xau_FOUND TRUE)
  endif(X11_Xau_LIB AND X11_Xau_INCLUDE_PATH)

  if(X11_Xdmcp_INCLUDE_PATH AND X11_Xdmcp_LIB)
    set(X11_Xdmcp_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xdmcp_INCLUDE_PATH})
  endif(X11_Xdmcp_INCLUDE_PATH AND X11_Xdmcp_LIB)

  if(X11_Xaccessrules_INCLUDE_PATH AND X11_Xaccessstr_INCLUDE_PATH)
    set(X11_Xaccess_FOUND TRUE)
    set(X11_Xaccess_INCLUDE_PATH ${X11_Xaccessstr_INCLUDE_PATH})
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xaccess_INCLUDE_PATH})
  endif(X11_Xaccessrules_INCLUDE_PATH AND X11_Xaccessstr_INCLUDE_PATH)

  if(X11_Xpm_INCLUDE_PATH AND X11_Xpm_LIB)
    set(X11_Xpm_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xpm_INCLUDE_PATH})
  endif(X11_Xpm_INCLUDE_PATH AND X11_Xpm_LIB)

  if(X11_Xcomposite_INCLUDE_PATH AND X11_Xcomposite_LIB)
    set(X11_Xcomposite_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xcomposite_INCLUDE_PATH})
  endif(X11_Xcomposite_INCLUDE_PATH AND X11_Xcomposite_LIB)

  if(X11_Xdamage_INCLUDE_PATH AND X11_Xdamage_LIB)
    set(X11_Xdamage_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xdamage_INCLUDE_PATH})
  endif(X11_Xdamage_INCLUDE_PATH AND X11_Xdamage_LIB)

  if(X11_XShm_INCLUDE_PATH)
    set(X11_XShm_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_XShm_INCLUDE_PATH})
  endif(X11_XShm_INCLUDE_PATH)

  if(X11_XTest_INCLUDE_PATH AND X11_XTest_LIB)
    set(X11_XTest_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_XTest_INCLUDE_PATH})
  endif(X11_XTest_INCLUDE_PATH AND X11_XTest_LIB)

  if(X11_Xi_INCLUDE_PATH AND X11_Xi_LIB)
    set(X11_Xi_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xi_INCLUDE_PATH})
  endif(X11_Xi_INCLUDE_PATH  AND X11_Xi_LIB)

  if(X11_Xinerama_INCLUDE_PATH AND X11_Xinerama_LIB)
    set(X11_Xinerama_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xinerama_INCLUDE_PATH})
  endif(X11_Xinerama_INCLUDE_PATH  AND X11_Xinerama_LIB)

  if(X11_Xfixes_INCLUDE_PATH AND X11_Xfixes_LIB)
    set(X11_Xfixes_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xfixes_INCLUDE_PATH})
  endif(X11_Xfixes_INCLUDE_PATH AND X11_Xfixes_LIB)

  if(X11_Xrender_INCLUDE_PATH AND X11_Xrender_LIB)
    set(X11_Xrender_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xrender_INCLUDE_PATH})
  endif(X11_Xrender_INCLUDE_PATH AND X11_Xrender_LIB)

  if(X11_Xrandr_INCLUDE_PATH AND X11_Xrandr_LIB)
    set(X11_Xrandr_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xrandr_INCLUDE_PATH})
  endif(X11_Xrandr_INCLUDE_PATH AND X11_Xrandr_LIB)

  if(X11_xf86misc_INCLUDE_PATH AND X11_Xxf86misc_LIB)
    set(X11_xf86misc_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_xf86misc_INCLUDE_PATH})
  endif(X11_xf86misc_INCLUDE_PATH  AND X11_Xxf86misc_LIB)

  if(X11_xf86vmode_INCLUDE_PATH)
    set(X11_xf86vmode_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_xf86vmode_INCLUDE_PATH})
  endif(X11_xf86vmode_INCLUDE_PATH)

  if(X11_Xcursor_INCLUDE_PATH AND X11_Xcursor_LIB)
    set(X11_Xcursor_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xcursor_INCLUDE_PATH})
  endif(X11_Xcursor_INCLUDE_PATH AND X11_Xcursor_LIB)

  if(X11_Xscreensaver_INCLUDE_PATH AND X11_Xscreensaver_LIB)
    set(X11_Xscreensaver_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xscreensaver_INCLUDE_PATH})
  endif(X11_Xscreensaver_INCLUDE_PATH AND X11_Xscreensaver_LIB)

  if(X11_dpms_INCLUDE_PATH)
    set(X11_dpms_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_dpms_INCLUDE_PATH})
  endif(X11_dpms_INCLUDE_PATH)

  if(X11_Xkb_INCLUDE_PATH AND X11_Xkblib_INCLUDE_PATH AND X11_Xlib_INCLUDE_PATH)
    set(X11_Xkb_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xkb_INCLUDE_PATH} )
  endif(X11_Xkb_INCLUDE_PATH AND X11_Xkblib_INCLUDE_PATH AND X11_Xlib_INCLUDE_PATH)

  if(X11_Xinput_INCLUDE_PATH AND X11_Xinput_LIB)
    set(X11_Xinput_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xinput_INCLUDE_PATH})
  endif(X11_Xinput_INCLUDE_PATH AND X11_Xinput_LIB)

  if(X11_ICE_LIB AND X11_ICE_INCLUDE_PATH)
    set(X11_ICE_FOUND TRUE)
  endif(X11_ICE_LIB AND X11_ICE_INCLUDE_PATH)

  # Deprecated variable for backwards compatibility with CMake 1.4
  if(X11_Xlib_INCLUDE_PATH AND X11_LIBRARIES)
    set(X11_FOUND 1)
  endif(X11_Xlib_INCLUDE_PATH AND X11_LIBRARIES)

  if(X11_FOUND)
    include(CheckFunctionExists)
    include(CheckLibraryExists)

    # Translated from an autoconf-generated configure script.
    # See libs.m4 in autoconf's m4 directory.
    if($ENV{ISC} MATCHES "^yes$")
      set(X11_X_EXTRA_LIBS -lnsl_s -linet)
    else($ENV{ISC} MATCHES "^yes$")
      set(X11_X_EXTRA_LIBS "")

      # See if XOpenDisplay in X11 works by itself.
      CHECK_LIBRARY_EXISTS("${X11_LIBRARIES}" "XOpenDisplay" "${X11_LIBRARY_DIR}" X11_LIB_X11_SOLO)
      if(NOT X11_LIB_X11_SOLO)
        # Find library needed for dnet_ntoa.
        CHECK_LIBRARY_EXISTS("dnet" "dnet_ntoa" "" X11_LIB_DNET_HAS_DNET_NTOA)
        if(X11_LIB_DNET_HAS_DNET_NTOA)
          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -ldnet)
        else(X11_LIB_DNET_HAS_DNET_NTOA)
          CHECK_LIBRARY_EXISTS("dnet_stub" "dnet_ntoa" "" X11_LIB_DNET_STUB_HAS_DNET_NTOA)
          if(X11_LIB_DNET_STUB_HAS_DNET_NTOA)
            SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -ldnet_stub)
          endif(X11_LIB_DNET_STUB_HAS_DNET_NTOA)
        endif(X11_LIB_DNET_HAS_DNET_NTOA)
      endif(NOT X11_LIB_X11_SOLO)

      # Find library needed for gethostbyname.
      CHECK_FUNCTION_EXISTS("gethostbyname" CMAKE_HAVE_GETHOSTBYNAME)
      if(NOT CMAKE_HAVE_GETHOSTBYNAME)
        CHECK_LIBRARY_EXISTS("nsl" "gethostbyname" "" CMAKE_LIB_NSL_HAS_GETHOSTBYNAME)
        if(CMAKE_LIB_NSL_HAS_GETHOSTBYNAME)
          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lnsl)
        else(CMAKE_LIB_NSL_HAS_GETHOSTBYNAME)
          CHECK_LIBRARY_EXISTS("bsd" "gethostbyname" "" CMAKE_LIB_BSD_HAS_GETHOSTBYNAME)
          if(CMAKE_LIB_BSD_HAS_GETHOSTBYNAME)
            SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lbsd)
          endif(CMAKE_LIB_BSD_HAS_GETHOSTBYNAME)
        endif(CMAKE_LIB_NSL_HAS_GETHOSTBYNAME)
      endif(NOT CMAKE_HAVE_GETHOSTBYNAME)

      # Find library needed for connect.
      CHECK_FUNCTION_EXISTS("connect" CMAKE_HAVE_CONNECT)
      if(NOT CMAKE_HAVE_CONNECT)
        CHECK_LIBRARY_EXISTS("socket" "connect" "" CMAKE_LIB_SOCKET_HAS_CONNECT)
        if(CMAKE_LIB_SOCKET_HAS_CONNECT)
          SET (X11_X_EXTRA_LIBS -lsocket ${X11_X_EXTRA_LIBS})
        endif(CMAKE_LIB_SOCKET_HAS_CONNECT)
      endif(NOT CMAKE_HAVE_CONNECT)

      # Find library needed for remove.
      CHECK_FUNCTION_EXISTS("remove" CMAKE_HAVE_REMOVE)
      if(NOT CMAKE_HAVE_REMOVE)
        CHECK_LIBRARY_EXISTS("posix" "remove" "" CMAKE_LIB_POSIX_HAS_REMOVE)
        if(CMAKE_LIB_POSIX_HAS_REMOVE)
          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lposix)
        endif(CMAKE_LIB_POSIX_HAS_REMOVE)
      endif(NOT CMAKE_HAVE_REMOVE)

      # Find library needed for shmat.
      CHECK_FUNCTION_EXISTS("shmat" CMAKE_HAVE_SHMAT)
      if(NOT CMAKE_HAVE_SHMAT)
        CHECK_LIBRARY_EXISTS("ipc" "shmat" "" CMAKE_LIB_IPS_HAS_SHMAT)
        if(CMAKE_LIB_IPS_HAS_SHMAT)
          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lipc)
        endif(CMAKE_LIB_IPS_HAS_SHMAT)
      endif(NOT CMAKE_HAVE_SHMAT)
    endif($ENV{ISC} MATCHES "^yes$")

    if(X11_ICE_FOUND)
      CHECK_LIBRARY_EXISTS("ICE" "IceConnectionNumber" "${X11_LIBRARY_DIR}"
        CMAKE_LIB_ICE_HAS_ICECONNECTIONNUMBER)
      if(CMAKE_LIB_ICE_HAS_ICECONNECTIONNUMBER)
        SET (X11_X_PRE_LIBS ${X11_ICE_LIB})
        if(X11_SM_LIB)
          SET (X11_X_PRE_LIBS ${X11_SM_LIB} ${X11_X_PRE_LIBS})
        endif(X11_SM_LIB)
      endif(CMAKE_LIB_ICE_HAS_ICECONNECTIONNUMBER)
    endif(X11_ICE_FOUND)

    # Build the final list of libraries.
    set(X11_LIBRARIES ${X11_X_PRE_LIBS} ${X11_LIBRARIES} ${X11_X_EXTRA_LIBS})

    # Check whether we're pulling headers from multiple directoreis
    list(LENGTH X11_HDR_PATHS HDR_PATH_CNT)
    if("${HDR_PATH_CNT}" GREATER 1)
      message("\nNote: FindX11 is returning headers found in multiple paths.  The user may wish to verify that components are not being returned from multiple X11 installations.\n")
      if(CMAKE_SEARCH_OSX_PATHS)
	if(NOT "${CMAKE_SEARCH_OSX_PATHS}" STREQUAL "SYSTEM")
	  message("Note that CMAKE_SEARCH_OSX_PATHS is set to ${CMAKE_SEARCH_OSX_PATHS} - if ${CMAKE_SEARCH_OSX_PATHS} has an incomplete installation of X11, that may cause this issue - a possible workaround is to set CMAKE_SEARCH_OSX_PATHS to SYSTEM and not use ${CMAKE_SEARCH_OSX_PATHS}.\n")
	endif(NOT "${CMAKE_SEARCH_OSX_PATHS}" STREQUAL "SYSTEM")
      endif(CMAKE_SEARCH_OSX_PATHS)
      foreach(pathitem ${X11_HDR_PATHS})
	message("Headers found in ${pathitem}:")
	foreach(varitem ${X11_HDR_VARS})
	  if("${${varitem}}" MATCHES "${pathitem}")
	    message("     ${varitem}:${${varitem}}")
	  endif("${${varitem}}" MATCHES "${pathitem}")
	endforeach(varitem ${X11_HDR_PATHS})
	message(" ")
      endforeach(pathitem ${X11_HDR_PATHS})
    endif("${HDR_PATH_CNT}" GREATER 1)

    list(LENGTH X11_LIB_PATHS LIB_PATH_CNT)
    if("${LIB_PATH_CNT}" GREATER 1)
      message("\nNote: FindX11 is returning libraries found in multiple paths.  The user may wish to verify that components are not being returned from multiple X11 installations.\n")
      if(CMAKE_SEARCH_OSX_PATHS)
	if(NOT "${CMAKE_SEARCH_OSX_PATHS}" STREQUAL "SYSTEM")
	  message("Note that CMAKE_SEARCH_OSX_PATHS is set to ${CMAKE_SEARCH_OSX_PATHS} - if ${CMAKE_SEARCH_OSX_PATHS} has an incomplete installation of X11, that may cause this issue - a possible workaround is to set CMAKE_SEARCH_OSX_PATHS to SYSTEM and not use ${CMAKE_SEARCH_OSX_PATHS}.\n")
	endif(NOT "${CMAKE_SEARCH_OSX_PATHS}" STREQUAL "SYSTEM")
      endif(CMAKE_SEARCH_OSX_PATHS)

      foreach(pathitem ${X11_LIB_PATHS})
	message("Libraries found in ${pathitem}:")
	foreach(varitem ${X11_LIB_VARS})
	  if("${${varitem}}" MATCHES "${pathitem}")
	    message("     ${varitem}:${${varitem}}")
	  endif("${${varitem}}" MATCHES "${pathitem}")
	endforeach(varitem ${X11_LIB_PATHS})
	message(" ")
      endforeach(pathitem ${X11_LIB_PATHS})
    endif("${LIB_PATH_CNT}" GREATER 1)

    include(FindPackageMessage)
    FIND_PACKAGE_MESSAGE(X11 "Found X11: ${X11_X11_LIB}"
      "[${X11_X11_LIB}][${X11_INCLUDE_DIR}]")
  else(X11_FOUND)
    if(X11_FIND_REQUIRED)
      message(FATAL_ERROR "Could not find X11")
    endif(X11_FIND_REQUIRED)
  endif(X11_FOUND)

  mark_as_advanced(
    X11_X11_INCLUDE_PATH
    X11_X11_LIB
    X11_Xext_LIB
    X11_Xau_LIB
    X11_Xau_INCLUDE_PATH
    X11_Xlib_INCLUDE_PATH
    X11_Xutil_INCLUDE_PATH
    X11_Xcomposite_INCLUDE_PATH
    X11_Xcomposite_LIB
    X11_Xaccess_INCLUDE_PATH
    X11_Xfixes_LIB
    X11_Xfixes_INCLUDE_PATH
    X11_Xrandr_LIB
    X11_Xrandr_INCLUDE_PATH
    X11_Xdamage_LIB
    X11_Xdamage_INCLUDE_PATH
    X11_Xrender_LIB
    X11_Xrender_INCLUDE_PATH
    X11_Xxf86misc_LIB
    X11_xf86misc_INCLUDE_PATH
    X11_xf86vmode_INCLUDE_PATH
    X11_Xi_LIB
    X11_Xi_INCLUDE_PATH
    X11_Xinerama_LIB
    X11_Xinerama_INCLUDE_PATH
    X11_XTest_LIB
    X11_XTest_INCLUDE_PATH
    X11_Xcursor_LIB
    X11_Xcursor_INCLUDE_PATH
    X11_dpms_INCLUDE_PATH
    X11_Xt_LIB
    X11_Xt_INCLUDE_PATH
    X11_Xdmcp_LIB
    X11_LIBRARIES
    X11_Xaccessrules_INCLUDE_PATH
    X11_Xaccessstr_INCLUDE_PATH
    X11_Xdmcp_INCLUDE_PATH
    X11_Xkb_INCLUDE_PATH
    X11_Xkblib_INCLUDE_PATH
    X11_Xscreensaver_INCLUDE_PATH
    X11_Xscreensaver_LIB
    X11_Xpm_INCLUDE_PATH
    X11_Xpm_LIB
    X11_Xinput_LIB
    X11_Xinput_INCLUDE_PATH
    X11_Xft_LIB
    X11_Xft_INCLUDE_PATH
    X11_Xshape_INCLUDE_PATH
    X11_Xv_LIB
    X11_Xv_INCLUDE_PATH
    X11_XShm_INCLUDE_PATH
    X11_ICE_LIB
    X11_ICE_INCLUDE_PATH
    X11_SM_LIB
    )
  set(CMAKE_FIND_FRAMEWORK ${CMAKE_FIND_FRAMEWORK_SAVE})
endif(UNIX)

# X11_FIND_REQUIRED_<component> could be checked too

# Local Variables:
# tab-width: 8
# mode: cmake
# indent-tabs-mode: t
# End:
# ex: shiftwidth=2 tabstop=8
blob
data 10545
#!/bin/bash -norc
dnl	This file is an input file used by the GNU "autoconf" program to
dnl	generate the file "configure", which is run during Tcl installation
dnl	to configure the system for the local environment.
#
# RCS: @(#) $Id$

#-----------------------------------------------------------------------
# Sample configure.in for Tcl Extensions.  The only places you should
# need to modify this file are marked by the string __CHANGE__
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# __CHANGE__
# Set your package name and version numbers here.
#
# This initializes the environment with PACKAGE_NAME and PACKAGE_VERSION
# set as provided.  These will also be added as -D defs in your Makefile
# so you can encode the package version directly into the source files.
#-----------------------------------------------------------------------

AC_INIT([tkdnd], [2.6])

#--------------------------------------------------------------------
# Call TEA_INIT as the first TEA_ macro to set up initial vars.
# This will define a ${TEA_PLATFORM} variable == "unix" or "windows"
# as well as PKG_LIB_FILE and PKG_STUB_LIB_FILE.
#--------------------------------------------------------------------

TEA_INIT([3.9])

AC_CONFIG_AUX_DIR(tclconfig)

#--------------------------------------------------------------------
# Load the tclConfig.sh file
#--------------------------------------------------------------------

TEA_PATH_TCLCONFIG
TEA_LOAD_TCLCONFIG

#--------------------------------------------------------------------
# Load the tkConfig.sh file if necessary (Tk extension)
#--------------------------------------------------------------------

TEA_PATH_TKCONFIG
TEA_LOAD_TKCONFIG

#-----------------------------------------------------------------------
# Handle the --prefix=... option by defaulting to what Tcl gave.
# Must be called after TEA_LOAD_TCLCONFIG and before TEA_SETUP_COMPILER.
#-----------------------------------------------------------------------

TEA_PREFIX

#-----------------------------------------------------------------------
# Standard compiler checks.
# This sets up CC by using the CC env var, or looks for gcc otherwise.
# This also calls AC_PROG_CC, AC_PROG_INSTALL and a few others to create
# the basic setup necessary to compile executables.
#-----------------------------------------------------------------------

TEA_SETUP_COMPILER

#-----------------------------------------------------------------------
# __CHANGE__
# Specify the C source files to compile in TEA_ADD_SOURCES,
# public headers that need to be installed in TEA_ADD_HEADERS,
# stub library C source files to compile in TEA_ADD_STUB_SOURCES,
# and runtime Tcl library files in TEA_ADD_TCL_SOURCES.
# This defines PKG(_STUB)_SOURCES, PKG(_STUB)_OBJECTS, PKG_HEADERS
# and PKG_TCL_SOURCES.
#-----------------------------------------------------------------------

#TEA_ADD_SOURCES([TkDND_XDND.c])
TEA_ADD_HEADERS([])
TEA_ADD_INCLUDES([])
TEA_ADD_LIBS([])
TEA_ADD_CFLAGS([])
TEA_ADD_STUB_SOURCES([])
TEA_ADD_TCL_SOURCES([library/tkdnd_compat.tcl library/tkdnd.tcl library/tkdnd_unix.tcl library/tkdnd_windows.tcl library/tkdnd_macosx.tcl])

#--------------------------------------------------------------------
# __CHANGE__
# A few miscellaneous platform-specific items:
#
# Define a special symbol for Windows (BUILD_sample in this case) so
# that we create the export library with the dll.
#
# Windows creates a few extra files that need to be cleaned up.
# You can add more files to clean if your extension creates any extra
# files.
#
# TEA_ADD_* any platform specific compiler/build info here.
#--------------------------------------------------------------------

if test "${TEA_PLATFORM}" = "windows" ; then
    AC_PROG_CXX
    CC=$CXX
    AC_CHECK_HEADER(Strsafe.h,
        [AC_DEFINE(HAVE_STRSAFE_H, 1, [Do we have <Strsafe.h>?])],
	[AC_DEFINE(NO_STRSAFE_H,   1, [Do we have <Strsafe.h>?])])
    TEA_ADD_CFLAGS([-DUNICODE -D_UNICODE])
    TEA_ADD_SOURCES([win/TkDND_OleDND.cpp])
    TEA_ADD_LIBS(kernel32.lib user32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib)

    ## Check if the compiler accepts -static-libstdc++...
    AC_CACHE_CHECK([if the compiler understands -static-libstdc++],
        tcl_cv_cc_staticlib, [
        hold_cflags=$CFLAGS; CFLAGS="$CFLAGS -static-libstdc++"
        AC_TRY_COMPILE(,, tcl_cv_cc_staticlib=yes, tcl_cv_cc_staticlib=no)
        CFLAGS=$hold_cflags])

    AC_DEFINE(BUILD_tkdnd, 1, [Build windows export dll])
    CLEANFILES="pkgIndex.tcl *.lib *.dll *.exp *.ilk *.pdb vc*.pch"
    #TEA_ADD_SOURCES([win/winFile.c])
    #TEA_ADD_INCLUDES([-I\"$(${CYGPATH} ${srcdir}/win)\"])
else
    CLEANFILES="pkgIndex.tcl"
    #TEA_ADD_SOURCES([unix/unixFile.c])
    #TEA_ADD_LIBS([-lsuperfly])
fi

if test "${TEA_WINDOWINGSYSTEM}" = "x11"; then
    TEA_ADD_SOURCES([unix/TkDND_XDND.c unix/tkUnixSelect.c unix/Cursors.c])
fi

if test "${TEA_WINDOWINGSYSTEM}" = "aqua"; then
    TEA_ADD_SOURCES([macosx/macdnd.m])
    TEA_ADD_CFLAGS([-DMAC_TK_COCOA -std=gnu99 -x objective-c -fobjc-gc])
    TEA_ADD_LIBS([-framework Cocoa -framework Carbon])
fi

AC_SUBST(CLEANFILES)

#--------------------------------------------------------------------
# __CHANGE__
# Choose which headers you need.  Extension authors should try very
# hard to only rely on the Tcl public header files.  Internal headers
# contain private data structures and are subject to change without
# notice.
# This MUST be called after TEA_LOAD_TCLCONFIG / TEA_LOAD_TKCONFIG
#--------------------------------------------------------------------

TEA_PUBLIC_TCL_HEADERS
#TEA_PRIVATE_TCL_HEADERS

TEA_PUBLIC_TK_HEADERS
TEA_PRIVATE_TK_HEADERS
TEA_PATH_X

#--------------------------------------------------------------------
# Check whether --enable-threads or --disable-threads was given.
# This auto-enables if Tcl was compiled threaded.
#--------------------------------------------------------------------

TEA_ENABLE_THREADS

#--------------------------------------------------------------------
# The statement below defines a collection of symbols related to
# building as a shared library instead of a static library.
#--------------------------------------------------------------------

TEA_ENABLE_SHARED

#--------------------------------------------------------------------
# This macro figures out what flags to use with the compiler/linker
# when building shared/static debug/optimized objects.  This information
# can be taken from the tclConfig.sh file, but this figures it all out.
#--------------------------------------------------------------------

TEA_CONFIG_CFLAGS

#--------------------------------------------------------------------
# Set the default compiler switches based on the --enable-symbols option.
#--------------------------------------------------------------------

TEA_ENABLE_SYMBOLS

#--------------------------------------------------------------------
# Everyone should be linking against the Tcl stub library.  If you
# can't for some reason, remove this definition.  If you aren't using
# stubs, you also need to modify the SHLIB_LD_LIBS setting below to
# link against the non-stubbed Tcl library.  Add Tk too if necessary.
#--------------------------------------------------------------------

AC_DEFINE(USE_TCL_STUBS, 1, [Use Tcl stubs])
AC_DEFINE(USE_TK_STUBS, 1, [Use Tk stubs])

#--------------------------------------------------------------------
# This macro generates a line to use when building a library.  It
# depends on values set by the TEA_ENABLE_SHARED, TEA_ENABLE_SYMBOLS,
# and TEA_LOAD_TCLCONFIG macros above.
#--------------------------------------------------------------------

TEA_MAKE_LIB

#--------------------------------------------------------------------
# Determine the name of the tclsh and/or wish executables in the
# Tcl and Tk build directories or the location they were installed
# into. These paths are used to support running test cases only,
# the Makefile should not be making use of these paths to generate
# a pkgIndex.tcl file or anything else at extension build time.
#--------------------------------------------------------------------

TEA_PROG_TCLSH
TEA_PROG_WISH

if test "${TEA_PLATFORM}" = "windows" ; then
  ## If the compiler accepts -static-libstdc++, modify the compiler
  ## and linker options...
  if test $tcl_cv_cc_staticlib = yes; then
      CFLAGS="$CFLAGS -static-libgcc -static-libstdc++"
      SHLIB_LD="$SHLIB_LD -static-libgcc -static-libstdc++"
  fi
fi

#--------------------------------------------------------------------
# The code makes use of PTR2INT, ensure the correct definition is
# picked from Tcl/Tk internal headers...
#--------------------------------------------------------------------
AC_CHECK_TYPE([intptr_t], [
    AC_DEFINE([HAVE_INTPTR_T], 1, [Do we have the intptr_t type?])], [
    AC_CACHE_CHECK([for pointer-size signed integer type], tcl_cv_intptr_t, [
    for tcl_cv_intptr_t in "int" "long" "long long" none; do
	if test "$tcl_cv_intptr_t" != none; then
	    AC_COMPILE_IFELSE([AC_LANG_BOOL_COMPILE_TRY([AC_INCLUDES_DEFAULT],
		    [[sizeof (void *) <= sizeof ($tcl_cv_intptr_t)]])],
		[tcl_ok=yes], [tcl_ok=no])
	    test "$tcl_ok" = yes && break; fi
    done])
    if test "$tcl_cv_intptr_t" != none; then
	AC_DEFINE_UNQUOTED([intptr_t], [$tcl_cv_intptr_t], [Signed integer
	   type wide enough to hold a pointer.])
    fi
])
AC_CHECK_TYPE([uintptr_t], [
    AC_DEFINE([HAVE_UINTPTR_T], 1, [Do we have the uintptr_t type?])], [
    AC_CACHE_CHECK([for pointer-size unsigned integer type], tcl_cv_uintptr_t, [
    for tcl_cv_uintptr_t in "unsigned int" "unsigned long" "unsigned long long" \
	    none; do
	if test "$tcl_cv_uintptr_t" != none; then
	    AC_COMPILE_IFELSE([AC_LANG_BOOL_COMPILE_TRY([AC_INCLUDES_DEFAULT],
		    [[sizeof (void *) <= sizeof ($tcl_cv_uintptr_t)]])],
		[tcl_ok=yes], [tcl_ok=no])
	    test "$tcl_ok" = yes && break; fi
    done])
    if test "$tcl_cv_uintptr_t" != none; then
	AC_DEFINE_UNQUOTED([uintptr_t], [$tcl_cv_uintptr_t], [Unsigned integer
	   type wide enough to hold a pointer.])
    fi
])

#--------------------------------------------------------------------
# Finally, substitute all of the various values into the Makefile.
# You may alternatively have a special pkgIndex.tcl.in or other files
# which require substituting th AC variables in.  Include these here.
#--------------------------------------------------------------------

AC_OUTPUT([Makefile pkgIndex.tcl])
blob
data 4474
# Load the tkdnd package
## Make sure that we can find the tkdnd package even if the user has not yet
## installed the package.
if {[catch {package require tkdnd}]} {
  set DIR [file dirname [file dirname [file normalize [info script]]]]
  source $DIR/library/tkdnd.tcl
  foreach dll [glob -type f $DIR/*tkdnd*[info sharedlibextension]] {
    tkdnd::initialise $DIR/library ../[file tail $dll] tkdnd
  }
}

# Create a widget that will be a drag source.
set text_data "hello from Tk! (\u20ac)"
set file_data [list /tmp/hello\u20ac [info script]]
grid [label .text_drag_source \
  -text "Text Drag Source ($text_data)"] -sticky snew -columnspan 2
grid [label .file_drag_source \
  -text "File Drag Source ($file_data)"] -sticky snew -columnspan 2
tkdnd::drag_source register .text_drag_source
tkdnd::drag_source register .file_drag_source
bind .text_drag_source <<DragInitCmd>> \
  [list drag_source DND_Text $text_data %e %W %s %X %Y %A]
bind .text_drag_source <<DragEndCmd>>  \
  [list drag_source DND_Text $text_data %e %W %s %X %Y %A]
bind .file_drag_source <<DragInitCmd>> \
  [list drag_source DND_Files $file_data %e %W %s %X %Y %A]
bind .file_drag_source <<DragEndCmd>> \
  [list drag_source DND_Files $file_data %e %W %s %X %Y %A]
proc drag_source {type data event path state x y action} {
  switch $event {
    <<DragInitCmd>> {return [list copy $type $data]}
    <<DragEndCmd>>  {puts "Drag action: $action (type: $type)"}
  }
};# drag_source

# Add some custom clipboard formats...
frame .colours
foreach colour {red green blue navy} {
  pack [label .colours.$colour -text $colour -fg white -bg $colour] \
    -side left -padx 2
  tkdnd::drag_source register .colours.$colour
  bind .colours.$colour <<DragInitCmd>> \
   "list copy DND_Color $colour"
}
grid .colours -sticky snew -columnspan 2

# Create a widget that can be a drop target.
grid [label .drop_target -text {Drop Target:} -bg yellow] \
     [label .drop_target_value -text {                  }] -sticky snew

# Register .drop_target as a drop target of every type!
tkdnd::drop_target register .drop_target *

# During drag and drop, the drop target receives information through 3
# virtual events: <<DropEnter>> <<DropPosition>> <<DropLeave>>
# The fields that can be used in the event callbacks, are given in "cmd",
# while their "label" is given in "itemList"...
set cmd {handle_event %e %W %X %Y %ST %TT %a %A %CST %CTT %t %T %b %D}
set itemList {Event Widget X Y Source_Types Target_Types Source_Actions Action
              Common_Source_Types Common_Target_Types Types Drop_Type
              Pressed_Keys Data}
# Add the various events...
bind .drop_target <<DropEnter>>      $cmd
bind .drop_target <<DropPosition>>   $cmd
bind .drop_target <<DropLeave>>      $cmd

# Add the generic <<Drop>> event. This will be called when more specilised
# drop event is not found for the drop.
bind .drop_target <<Drop>>           $cmd

# Add a specialised <<Drop>> event, when will be called if a file is dropped.
bind .drop_target <<Drop:DND_Files>> $cmd

# Add a special drop command for DND_Color...
bind .drop_target <<Drop:DND_Color>> $cmd 

# Create some widgets for showing event info.
foreach item $itemList {
  grid [label .[string tolower $item] -text [string map {_ \ } $item]:\
          -anchor w] [label .[string tolower $item]_val -width 30 -anchor w \
          -background white -foreground navy] -sticky snew -padx 1 -pady 1
}
grid columnconfigure . 1 -weight 1
grid rowconfigure . 1 -weight 1

proc handle_event $itemList {
  global itemList
  foreach item $itemList {
    .[string tolower $item]_val configure -text [set $item]
  }
  switch -glob $Event {
    <<DropEnter>>      {$Widget configure -bg green}
    <<DropLeave>>      {$Widget configure -bg yellow}
    <<Drop:DND_Color>> {
      $Widget configure -bg yellow
      .drop_target_value configure -text $Data
      ## Convert data into a Tk color: the colour data is a list of 4 elements
      ## (red green blue opacity), expressed as Hex numbers...
      set color "#"
      for {set i 0} {$i < 3} {incr i} {
        ## Just remove the 0x prefix...
        append color [string range [lindex $Data $i] 2 end]
      }
      .drop_target_value configure -background $color -foreground white
    }
    <<Drop>> -
    <<Drop:*>>         {
      $Widget configure -bg yellow
      .drop_target_value configure -text $Data \
           -background [. cget -background] -foreground black
    }
  }
  return copy
};# handle_event
blob
data 4201
#!/bin/sh
# The next line is executed by /bin/sh, but not tcl \
  exec wish8.4 "$0" ${1+"$@"}

##
## This file implements a drop target that is able to accept any type dropped.
##
## Check Tk version:
package require Tk 8.3

if {$::tcl_version == "8.3" && ![package vsatisfies $::tcl_patchLevel 8.3.3]} {
    tk_messageBox -type ok -icon error \
        -message "  =====> TkDND requires at least tk8.3.3! <====="
    exit 1
}

## Make sure that we can find the tkdnd package even if the user has not yet
## installed the package.
if {[catch {package require tkdnd} version]} {
  set DIR [file dirname [file dirname [file normalize [info script]]]]
  source $DIR/library/tkdnd.tcl
  foreach dll [glob -type f $DIR/*tkdnd*[info sharedlibextension]] {
    tkdnd::initialise $DIR/library ../[file tail $dll] tkdnd
  }
  set package_info "Found tkdnd package version (unknown)\n\
                  \nPackage loading info:\n\n$dll"
} else {
  set package_info "Found tkdnd package version $version\n\
                  \nPackage loading info:\n\n[package ifneeded tkdnd $version]"

}

## Place a listbox. This will be our drop target, which will also display the
## types supported by the drag source...
pack [listbox .typeList -height 25 -width 50] -side left -padx 2 -pady 2 \
        -fill y -expand 0
## A text widget to display the dropped data...
pack [text .data -height 25 -width 80] -side left -padx 2 -pady 2 -fill both \
        -expand 1
.data insert end $package_info
pack [button .exit -text {  Exit  } -command exit] -side bottom -pady 5 -padx 5

proc FillTypeListbox {listbox types type codes code actions action mods} {
    $listbox delete 0 end
    $listbox insert end {}
    $listbox insert end {        --- Types ---}
    $listbox itemconfigure end -foreground white -background red
    foreach t $types c $codes {
        $listbox insert end "$t ($c)"
    }
    $listbox insert end " * Current Type: \"$type\" ($code)"
    $listbox itemconfigure end -foreground red -background $::bg
    $listbox insert end " * Cross Platform Type:\
                          \"[tkdnd::platform_independent_type $type]\""
    $listbox itemconfigure end -foreground red -background $::bg

    $listbox insert end {}
    $listbox insert end {        --- Actions ---}
    $listbox itemconfigure end -foreground white -background blue
    eval $listbox insert end $actions
    $listbox insert end " * Current Action: \"$action\"..."
    $listbox itemconfigure end -foreground blue -background $::bg

    $listbox insert end {}
    $listbox insert end " * Modifiers: \"$mods\""
    $listbox itemconfigure end -foreground brown -background $::bg
}
proc FillData {text Data type code} {
    $text configure -state normal
    $text delete 1.0 end
    $text insert end "\n   --- Dropped Data --- (Type = \"$type\" $code)\n\n\n"
    ## Can the text be splitted as a list?
    switch -glob [tkdnd::platform_independent_type $type] {
      FileGroupDescriptor* {
        foreach item $Data {
          $text insert end "   *  \"$item\"\n"
	  if {[file exists $item]} {
	    $text insert end "      ->   File exists. Deleting...\n"
	    file delete -force $item
	  } else {
	    $text insert end "      ->   File missing...\n"
	  }
        }
      }
      DND_Files {
        foreach item $Data {
          $text insert end "   *  \"$item\"\n"
        }
      }
      DND_Text -
      default {
        $text insert end $Data
      }
    }
    $text configure -state disabled
}

update
set bg [.typeList cget -background]
set abg #8fbc8f

set type *
dnd bindtarget .typeList $type <DragEnter> ".typeList configure -bg $abg
FillTypeListbox .typeList %t %T %c %C %a %A %m
return \[lindex %A 0\]"
dnd bindtarget .typeList $type <Drag> \
        [dnd bindtarget .typeList $type <DragEnter>]
dnd bindtarget .typeList $type <Drop> \
        ".typeList configure -bg $bg; FillData .data %D %T %C"
dnd bindtarget .typeList $type <DragLeave> \
        ".typeList configure -bg $bg"
raise .

proc show_widget_under_cursor {} {
  puts "Mouse coordinates: [winfo pointerxy .]"
  puts "Widget under cursor: [winfo containing 200 200]"
  after 200 show_widget_under_cursor
};# show_widget_under_cursor
#show_widget_under_cursor
blob
data 21988
<HTML><HEAD><TITLE>Manpage of tkdnd</TITLE>
</HEAD><BODY>
<H1>tkdnd</H1>
Section: Tk Built-In Commands (n)<BR>Updated: 8.4<BR><A HREF="#index">Index</A>
<A HREF="http://localhost/cgi-bin/man/man2html">Return to Main Contents</A><HR>


<BR>



<PRE>
<BR>
<HR></PRE>




<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

tkdnd - Tk Drag and Drop Interface
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<B>tkdnd::drop_target register</B><I> window ?type-list?</I>
<BR>

<B>tkdnd::drop_target unregister</B><I> window</I>
<P>

<B>tkdnd::drag_source register</B><I> window ?type-list? ?mouse-button?</I>
<BR>

<B>tkdnd::drag_source unregister</B><I> window</I>
<P>

<B>tkdnd::platform_specific_types</B><I> type-list</I>
<BR>

<B>tkdnd::platform_independent_types</B><I> type-list</I>
<P>

<B>tkdnd::GetDropFileTempDirectory</B>
<BR>

<B>tkdnd::SetDropFileTempDirectory </B><I>directory</I>
<P>
<A NAME="lbAD">&nbsp;</A>
<H2>INTRODUCTION</H2>

The <B>tkdnd</B> family commands provide a Tcl interface to native,
platform specific drag and drop mechanism.
Under unix the drag &amp; drop protocol in use is the XDND protocol version 5
(also used by the Qt toolkit, and the KDE and GNOME desktops).
Under Windows, the OLE2 drag &amp; drop interfaces are used.
Under Macintosh, the Cocoa drag &amp; drop interfaces are used.
<P>

The <B>tkdnd</B> family can be built from source code using the standard configure; make; make install procedure. Cmake is also supported. Some binary package are available from the SourceForge download site, from ActiveState's ActiveTcl distribution, and elsewhere.
<P>

With the <B>tkdnd</B> family commands the user is able to register existing Tk
widgets as drag sources or drop targets, that are able to send or receive data
during drag and drop operations, encoded in specific types.
These types can be platform independent types like DND_Text and DND_Files or
platform specific types, like CF_UNICODETEXT or text/plain.
<P>

The legal forms for the <B>tkdnd</B> commands are:
<DL COMPACT>
<DT><B>tkdnd::drop_target register</B><I> window ?type-list?</I><DD>
This command will register <I>window</I> as a drop target. A drop target is a
widget than can accept a drop action. <I>window</I> must exist when this command
is executed and this command can be executed multiple times on a widget.
<P>
When <I>window</I> is registered as a drop target, and optional <I>type-list</I>
can be provided. This type list can contain one or more types that <I>window</I>
will accept during a drop action, and it can contain platform independent or
platform specific types. Platform independent are <B>DND_Text</B>
for dropping text portions and <B>DND_Files</B> for dropping a list of files
(which can contain one or multiple files) on <I>window</I>.
If <I>type-list</I> is not specified, it defaults to the empty list.
<DT><B>tkdnd::drop_target unregister</B><I> window</I><DD>
This command will stop <I>window</I> from being a drop target.
Thus, <I>window</I> will stop receiving events related to drop operations.
It is an error to use this command for a <I>window</I> that has not been
registered as a drop target with <B>tkdnd::drop_target register</B>.
<DT><B>tkdnd::drag_source register</B><I> window ?type-list? ?mouse-button?</I><DD>
This command will register <I>window</I> as a drag source. A drag source is a
widget than can start a drag action. <I>window</I> must exist when this command
is executed and this command can be executed multiple times on a widget.
<P>
When <I>window</I> is registered as a drag source, and optional <I>type-list</I>
can be provided. This type list can contain one or more types that <I>window</I>
will provide during a drag action, and it can contain platform independent or
platform specific types. Platform independent are <B>DND_Text</B>
for dropping text portions and <B>DND_Files</B> for dropping a list of files
(which can contain one or multiple files) on <I>window</I>. However, this type
list is indicative/informative. <I>window</I> can initiate a drag action with
even a different type list. If <I>type-list</I> is not specified, it defaults to
the empty list.
<P>
Finally, <I>mouse-button</I> is the mouse button that will be used for starting
the drag action. It can have any of the values 1 (left mouse button),
2 (middle mouse button - wheel) and 3 (right mouse button).
If <I>mouse-button</I> is not specified, it defaults to 1.
<DT><B>tkdnd::drag_source unregister</B><I> window</I><DD>
This command will stop <I>window</I> from being a drag source.
Thus, <I>window</I> will stop receiving events related to drag operations.
It is an error to use this command for a <I>window</I> that has not been
registered as a drag source with <B>tkdnd::drag_source register</B>.
<DT><B>tkdnd::platform_specific_types </B><I>type-list</I><DD>
This command will accept a list of types that can contain platform independnent
or platform specific types. A new list will be returned, where each platform
independent type in <I>type-list</I> will be substituted by one or more platform
specific types. Thus, the returned list may have more elements than
<I>type-list</I>.
<DT><B>tkdnd::platform_independent_types</B><I> type-list</I><DD>
This command will accept a list of types that can contain platform independnent
or platform specific types. A new list will be returned, where each platform
specific type in <I>type-list</I> will be substituted by one or more platform
independent types. Thus, the returned list may have more elements than
<I>type-list</I>.
<DT><B>tkdnd::GetDropFileTempDirectory</B><DD>
This command will return the temporary directory used by TkDND for storing
temporary files. When the package is loaded, this temporary directory will be
initialised to a proper directory according to the operating system. This
default initial value can be changed to be the value of the following
environmental variables: <B>TKDND_TEMP_DIR</B>, <B>TEMP</B>, <B>TMP</B>.
<DT><B>tkdnd::SetDropFileTempDirectory </B><I>directory</I><DD>
This command will change the temporary directory used by TkDND for storing
temporary files to <I>directory</I>.
</DL>
<A NAME="lbAE">&nbsp;</A>
<H2>SUPPORTED TYPES</H2>

In order to declare the format that the data that will transfered during
a drag and drop operation, all drag and drop protocols use the notion of types.
Unfortunately, each protocol defines its own, usually platform specific, types. Tkdnd, trying to maintain portability among different platforms, offers some
predefined types for some basic kinds of data, like text, and filenames.
Currently, the following predifined cross-platform values are available:
<DL COMPACT>
<DT><B>DND_Text</B>:<DD>
This type can be used for transfering textual data. Internally, it is translated
to the following platform specific formats:
<BR>

Windows: <B>CF_UNICODETEXT</B>, <B>CF_TEXT</B>.
<BR>

Unix: <B>text/plain;charset=UTF-8</B>, <B>text/plain</B>.
<BR>

Mac: <B>NSStringPboardType</B>
  <BR>
<DT><B>DND_Files</B>:<DD>
This type can be used for transfering a list of file names.
Internally, it is translated to the following platform specific formats:
<BR>

Windows: <B>CF_HDROP</B>.
<BR>

Unix: <B>text/uri-list</B>.
  <BR>

Mac: <B>NSFilenamesPboardType</B>.
<DT>Additionally to the platform independent types, tkdnd supports the following platform specific types:<DD>
<DT><B>Windows</B>:<DD>
<B>CF_UNICODETEXT</B>: Text transfer encoded in unicode.
<BR>

<B>CF_TEXT</B>: Text transfer with application dependent encoding. If an encoding
locale is specified through CF_LOCALE it is used, else the system encoding is
used for the conversion.
<BR>

<B>FileGroupDescriptor - FileContents</B>: These two types are used for
transfering a set of files that do not appear physically on disk, like files
from compressed folders or Outlook e-mail messages. File names are transfered as
in the CF_TEXT type, while file contents are transfered in binary. Tkdnd
retrieves both the file names and the file contents, and saves then in a
temporary directory. When the transfer is complete, the file names of the saved
files in the temporary folder are returned. Note that tkdnd support this type
pair only as drop targets and not as drag sources.
<BR>

<B>FileGroupDescriptorW - FileContents</B>: These two types are used for
transfering a set of files that do not appear physically on disk, like files
from compressed folders or Outlook e-mail messages. File names are transfered as
in the CF_UNICODETEXT type, while file contents are transfered in binary. Tkdnd
retrieves both the file names and the file contents, and saves then in a
temporary directory. When the transfer is complete, the file names of the saved
files in the temporary folder are returned. Note that tkdnd support this type
pair only as drop targets and not as drag sources.
<BR>

<B>CF_HDROP</B>: Files transfer encoded in UTF-8.
<DT><B>Unix</B>:<DD>
</DL>
<P>

Finally, format types used for drop types can have <B>wildcards</B>, following
the same rules as &quot;string match&quot;. For example, registering a drop target with
the type &quot;*&quot;, will accept any drop, no matter what the drop format is.
<A NAME="lbAF">&nbsp;</A>
<H2>EVENTS</H2>

Windows registered as either drop targets or drag sources, will receive certain
events, during drag and drop operations. As a result, the windows are expected
to have bindings for some of these events. Some events are mandatory (in the
sense that a drag or drop operation can be stopped if the bindings do not
exist), while others are not. However, it is a good practice to define bindings
for all events, so as the application will behave as expected during drag and
drop operations.
<P>
The tkdnd package defines a set of virtual events, that correspond to various
phases of a drag and drop operation. All windows that are either a drop target
or a drag source are expected to have bindings for (all) these events, created
with the <B>bind</B> Tk command. While these event bindings are regular Tk
events, they have a small difference from plain Tk events: most of them are
expected to return a value. Since Tk bindings cannot return a value, tkdnd does
not actually generate these events (i.e. through &quot;event generate&quot;). Instead,
tkdnd locates the script that has been bound to the virtual event, and directly
executes it, as a script. Apart from this small difference in how the events are
triggered, the events required by tkdnd can be viewed as regular events. In the
following two sections all virtual events defined by the tkdnd package are
presented.
<A NAME="lbAG">&nbsp;</A>
<H2>DROP TARGET EVENTS</H2>

A window registered as a drop target, is expected to have bindings for the
following virtual events:
<DL COMPACT>
<DT><B>&lt;&lt;DropEnter&gt;&gt;</B>:<DD>
This event is triggered when the mouse enters the window
during a drop action. The purpose of this event is to change the visual state of
the window, so as to notify the user whether the drop will be accepted or not.
The binding script is expected to return a single value that will define the
drop action. This returned action can be one of <B>copy</B>, <B>move</B>,
<B>link</B>, <B>ask</B>, <B>private</B> and <B>refuse_drop</B>. This event is not
mandatory, but if it is defined, it has to return an action. In case an action
is not returned, the drop is refused for this window.
<DT><B>&lt;&lt;DropPosition&gt;&gt;</B>:<DD>
This events is triggered when the mouse moves inside the
window during a drop action. The purpose of this event is to let window decide
if it will accept the drop and the action of the drop, if a drop is going to
happen at the specific mouse coordinates. Thus, the script binding for such an
event can get the mouse coordinates and the pressed modifier buttons (such as
ctrl, shift or alt), and is expected to return the drop action, which again must
be one of <B>copy</B>, <B>move</B>,
<B>link</B>, <B>ask</B>, <B>private</B> and <B>refuse_drop</B>. This event is not
mandatory, but if it is defined, it has to return an action. In case an action
is not returned, the drop is refused for this window.
<DT><B>&lt;&lt;DropLeave&gt;&gt;</B>:<DD>
This event is triggered when the mouse leaves outside the
area covered by window, whithout a drop happening. The binding of such an event
is expected to restore the visual state of the window to normal (i.e. the visual
state the window was in before the &lt;&lt;DropEnter&gt;&gt; event was triggered). The
binding for such an event is not expected to return a value.
<DT><B>&lt;&lt;Drop&gt;&gt;</B>:<DD>
This event is triggered by a drop action, and it is expected to
handle the dropped data and reset the visual state of the window. The binding
script is expected to return a value, which will be the action that has been
performed to the data and must be one of <B>copy</B>, <B>move</B>,
<B>link</B>, <B>ask</B>, <B>private</B> and <B>refuse_drop</B>. This event is not
mandatory, but if it is defined, it has to return an action. In case an action
is not returned, the drop is refused for this window.
<DT><B>&lt;&lt;Drop:</B><I>type</I><B>&gt;&gt;</B>:<DD>
This event is a specialisation of the generic
&lt;&lt;Drop&gt;&gt; event, augmented with a type. If such a binding exists and the drop
type matches <I>type</I>, this event binding will be executed, instead of the
generic &lt;&lt;Drop&gt;&gt; event binding. These events allow for easy specialisation of
drop bindings, according to the type of the dropped data. <I>type</I> can be
either a platform independent or a platform specific type. The binding script of
such an event is expected to return a value, which will be the action that has
been performed to the data and must be one of <B>copy</B>, <B>move</B>,
<B>link</B>, <B>ask</B>, <B>private</B> and <B>refuse_drop</B>. This event is not
mandatory, but if it is defined, it has to return an action. In case an action
is not returned, the drop is refused for this window.
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>DRAG SOURCE EVENTS</H2>

A window registered as a drag source, is expected to have bindings for the
following virtual events:
<DL COMPACT>
<DT><B>&lt;&lt;DragInitCmd&gt;&gt;</B>:<DD>
This event is triggered when a drag action is about to start. This is a
mandatory event (whose absence will cancel the drag action), and is responsible
for providing three things: the list of actions and format types supported by
the drag source, and of course the data to be dropped. Thus, the binding script
for such an event must return a list of three elements: the drop actions
supported by the drag source (which can be any of <B>copy</B>, <B>move</B>,
<B>link</B>, <B>ask</B>, and <B>private</B>), the format type list that the data
can be dropped as (which can be any platform independent or platform specific
type), and finally the data. A simple example of such a binding, is:

<DL COMPACT><DT><DD>
<PRE>

bind .drag_source &lt;&lt;DragInitCmd&gt;&gt; \
     {list copy DND_Text {Hellow world!}}

</PRE>

</DL>


<DT><B>&lt;&lt;DragEndCmd&gt;&gt;</B>:<DD>
This event is triggered when the drag action has finished (either when the drop
was succesful or not). Its main purpose is to process the dropped data according
to the drop action returned by the drop target. Binding for such an event
is not mandatory, and the binding is not expected to return a value.
</DL>
<A NAME="lbAI">&nbsp;</A>
<H2>BINDING SCRIPTS AND SUBSTITUTIONS</H2>

All bindings scripts defined for any of the virtual events above will be
executed in the same interpreter that was used for creating the window the 
event is bound to, and the binding script will executed at the global
level (i.e. only global variables will be accessible).
<P>
If the binding script contains any % characters, then substitutions will be
made, like in normal Tk binding scripts. Valid % specifiers are:
<DL COMPACT>
<DT><B>%%</B><DD>
Replaced with a single percent. 
<DT><B>%A</B><DD>
The current action of the drag/drop operation.
<DT><B>%a</B><DD>
The action list supported by the drag source. 
<DT><B>%b</B><DD>
The mouse button that is pressed during a drag/drop operation. Note that 
always a single mouse button is reported as pressed, even if more than one 
mouse buttons are actually pressed.
<DT><B>%c</B><DD>
The codes of the list of types supported by the drag source. All codes are in
octal format and have the same order as the list of types obtained through the
<B>%t</B> substitution.
<DT><B>%C</B><DD>
The code (in octal format) of the current type of the drag and drop operation.
<DT><B>%CTT</B><DD>
The list of types from the drop target type list that are common to the drag
source type list.
<DT><B>%CST</B><DD>
The list of types from the drag source type list that are common to the drop
target type list.
<DT><B>%D</B><DD>
The data that has been dropped. Under some platforms the data will be 
available before the drop has occured. The format of the data is the current
type of the drop operation.
<DT><B>%e</B><DD>
The name of the current virtual event. One of &lt;&lt;DropEnter&gt;&gt;, &lt;&lt;DropPosition&gt;&gt;,
&lt;&lt;DropLeave&gt;&gt;, &lt;&lt;Drop:<I>type</I>&gt;&gt;, &lt;&lt;Drop&gt;&gt;, &lt;&lt;DragInitCmd&gt;&gt;, &lt;&lt;DragEndCmd&gt;&gt;.
<DT><B>%L</B><DD>
The list of types supported by the drag source.
<DT><B>%m</B><DD>
The list of modifier keyboard keys that are pressed. 
Modifier keys are some special keys, like Shift, Control or Alt. 
Valid modifiers are &quot;shift&quot;, &quot;ctrl&quot; and &quot;alt&quot;. It is useful for
binding scripts of drop target events to examine this list of modifiers, as it
is quite usuall to change the action according to the state of some modifier
keys.
<DT><B>%ST</B><DD>
The list of types supported by the drag source.
<DT><B>%t</B><DD>
The list of types supported by the drag source.
<DT><B>%T</B><DD>
The current type of the drag and drop operation.
<DT><B>%TT</B><DD>
The list of types supported by the drop target.
<DT><B>%W</B><DD>
The window that the event is delivered to.
<DT><B>%X</B><DD>
The mouse pointer x coordinate, relative to the root window.
<DT><B>%Y</B><DD>
The mouse pointer y coordinate, relative to the root window.
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H2>SPECIFYING DROP TARGETS</H2>

Creating drop targets is easy: we have to only register a window as a drop
target with the list of format types it can accept, and add a few bindings. For
example, a window that accepts textual drops can be as follows:

<DL COMPACT><DT><DD>
<PRE>

label .drop_target -text {Text Drop Target!} -bg white
tkdnd::drop_target register .drop_target DND_Text
bind .drop_target &lt;&lt;DropEnter&gt;&gt; {%W configure -bg yellow; list copy}
bind .drop_target &lt;&lt;DropPosition&gt;&gt; {list copy}
bind .drop_target &lt;&lt;DropLeave&gt;&gt; {%W configure -bg white}
bind .drop_target &lt;&lt;Drop&gt;&gt; {%W configure -text %D; %W configure -bg white}

</PRE>

</DL>


From the above bindings, none is obligatory. However, we usually want to receive
dropped data (thus the &lt;&lt;Drop&gt;&gt; event must be handled) and we want to give
visual feedback to the users through the &lt;&lt;DropEnter&gt;&gt; and &lt;&lt;DropLeave&gt;&gt; events.
Finally, &lt;&lt;DropPosition&gt;&gt; is only necessary if we want to only accept drops on
specific areas of the window, or we want to change the drop action according to
the pressed modifiers.
<P>
Now, if we want to also add the ability to receive file drops, we could add:

<DL COMPACT><DT><DD>
<PRE>

tkdnd::drop_target register .drop_target DND_Files
bind .drop_target &lt;&lt;Drop:DND_Files&gt;&gt; \
   {puts %D; %W configure -bg white}

</PRE>

</DL>


Note that we have added a &quot;specialised&quot; drop binding, for the event
&lt;&lt;Drop:DND_Files&gt;&gt;: this means that when a text portion is dropped over the
window, the &lt;&lt;Drop&gt;&gt; event binding will be executed. But when a list of files is
dropped onto the window, the &lt;&lt;Drop:DND_Files&gt;&gt; event binding will be executed.
If we proceed and define a binding for the &lt;&lt;Drop:DND_Text&gt;&gt; event, the binding
of the &quot;general&quot; &lt;&lt;Drop&gt;&gt; event will never be executed.
<A NAME="lbAK">&nbsp;</A>
<H2>SPECIFYING DRAG SOURCES</H2>

In order to specify a drag source, we need to register a window as a drag
source:

<DL COMPACT><DT><DD>
<PRE>

tkdnd::drag_source register .text_drag_source

</PRE>

</DL>


The above command defines a drag source with an empty type list (and which will
be declared in the &lt;&lt;DragInitCmd&gt;&gt; event binding) and arranges mouse bindings
such as a drag will be started with the left mouse button.
Then, it is absolutely necessary to define a binding for the &lt;&lt;DragInitCmd&gt;&gt;:
this event binding must return the list of actions, the list of format types and
the actual data to be dropped:

<DL COMPACT><DT><DD>
<PRE>

bind .text_drag_source &lt;&lt;DragInitCmd&gt;&gt; \
     {list {copy move} DND_Text {Hello from Tk!}}

</PRE>

</DL>


And that was all!
<A NAME="lbAL">&nbsp;</A>
<H2>BUGS</H2>

<B>Unix:</B>
Dragging from Tk windows has not yet been implemented.
<BR>
<B>OS X:</B>
TkDND under OS X is built on top of the Cocoa framework. Thus, it is compatible
with Tk version &gt;= 8.6
<BR>

<A NAME="lbAM">&nbsp;</A>
<H2>KEYWORDS</H2>

dnd, drag and drop
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">INTRODUCTION</A><DD>
<DT><A HREF="#lbAE">SUPPORTED TYPES</A><DD>
<DT><A HREF="#lbAF">EVENTS</A><DD>
<DT><A HREF="#lbAG">DROP TARGET EVENTS</A><DD>
<DT><A HREF="#lbAH">DRAG SOURCE EVENTS</A><DD>
<DT><A HREF="#lbAI">BINDING SCRIPTS AND SUBSTITUTIONS</A><DD>
<DT><A HREF="#lbAJ">SPECIFYING DROP TARGETS</A><DD>
<DT><A HREF="#lbAK">SPECIFYING DRAG SOURCES</A><DD>
<DT><A HREF="#lbAL">BUGS</A><DD>
<DT><A HREF="#lbAM">KEYWORDS</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 23:51:03 GMT, January 03, 2010
</BODY>
</HTML>
blob
data 26132
'\"
'\" This software (tkDND) is copyrighted by:
'\"   George Petasis, National Centre for Scientific Research "Demokritos",
'\"   Aghia Paraskevi, Athens, Greece.
'\"   e-mail: petasis@iit.demokritos.gr
'\"    
'\" The following terms apply to all files associated
'\" with the software unless explicitly disclaimed in individual
'\" files.
'\"    
'\" The authors hereby grant permission to use, copy, modify, distribute,
'\" and license this software and its documentation for any purpose, provided
'\" that existing copyright notices are retained in all copies and that this
'\" notice is included verbatim in any distributions. No written agreement,
'\" license, or royalty fee is required for any of the authorized uses.
'\" Modifications to this software may be copyrighted by their authors
'\" and need not follow the licensing terms described here, provided that
'\" the new terms are clearly indicated on the first page of each file where
'\" they apply.
'\"    
'\" IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
'\" FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
'\" ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
'\" DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
'\" POSSIBILITY OF SUCH DAMAGE.
'\"    
'\" THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
'\" INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
'\" FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
'\" IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
'\" NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
'\" MODIFICATIONS.
'\" 
'\" The definitions below are for supplemental macros used in Tcl/Tk
'\" manual entries.
'\"
'\" .AP type name in/out ?indent?
'\"	Start paragraph describing an argument to a library procedure.
'\"	type is type of argument (int, etc.), in/out is either "in", "out",
'\"	or "in/out" to describe whether procedure reads or modifies arg,
'\"	and indent is equivalent to second arg of .IP (shouldn't ever be
'\"	needed;  use .AS below instead)
'\"
'\" .AS ?type? ?name?
'\"	Give maximum sizes of arguments for setting tab stops.  Type and
'\"	name are examples of largest possible arguments that will be passed
'\"	to .AP later.  If args are omitted, default tab stops are used.
'\"
'\" .BS
'\"	Start box enclosure.  From here until next .BE, everything will be
'\"	enclosed in one large box.
'\"
'\" .BE
'\"	End of box enclosure.
'\"
'\" .CS
'\"	Begin code excerpt.
'\"
'\" .CE
'\"	End code excerpt.
'\"
'\" .VS ?version? ?br?
'\"	Begin vertical sidebar, for use in marking newly-changed parts
'\"	of man pages.  The first argument is ignored and used for recording
'\"	the version when the .VS was added, so that the sidebars can be
'\"	found and removed when they reach a certain age.  If another argument
'\"	is present, then a line break is forced before starting the sidebar.
'\"
'\" .VE
'\"	End of vertical sidebar.
'\"
'\" .DS
'\"	Begin an indented unfilled display.
'\"
'\" .DE
'\"	End of indented unfilled display.
'\"
'\" .SO
'\"	Start of list of standard options for a Tk widget.  The
'\"	options follow on successive lines, in four columns separated
'\"	by tabs.
'\"
'\" .SE
'\"	End of list of standard options for a Tk widget.
'\"
'\" .OP cmdName dbName dbClass
'\"	Start of description of a specific option.  cmdName gives the
'\"	option's name as specified in the class command, dbName gives
'\"	the option's name in the option database, and dbClass gives
'\"	the option's class in the option database.
'\"
'\" .UL arg1 arg2
'\"	Print arg1 underlined, then print arg2 normally.
'\"
'\" RCS: @(#) $Id$
'\"
'\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
'\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1	\\fI\\$2\\fP	(\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
'\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
'\"	# BS - start boxed text
'\"	# ^y = starting y location
'\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
'\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
'\"	# VS - start vertical sidebar
'\"	# ^Y = starting y location
'\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
'\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
'\"	# Special macro to handle page bottom:  finish off current
'\"	# box/sidebar if in box/sidebar mode, then invoked standard
'\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
'\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
'\"	# DE - end display
.de DE
.fi
.RE
.sp
..
'\"	# SO - start of list of standard options
.de SO
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 4c 8c 12c
.ft B
..
'\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\fBoptions\\fR manual entry for details on the standard options.
..
'\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
'\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
'\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.de UL
\\$1\l'|0\(ul'\\$2
..
.TH tkdnd n 8.4 Tk "Tk Built-In Commands"
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
tkdnd \- Tk Drag and Drop Interface
.SH SYNOPSIS
\fBtkdnd::drop_target register\fI window ?type-list?\fR
.br
\fBtkdnd::drop_target unregister\fI window\fR
.PP
\fBtkdnd::drag_source register\fI window ?type-list? ?mouse-button?\fR
.br
\fBtkdnd::drag_source unregister\fI window\fR
.PP
\fBtkdnd::platform_specific_types\fI type-list\fR
.br
\fBtkdnd::platform_independent_types\fI type-list\fR
.PP
\fBtkdnd::GetDropFileTempDirectory\fR
.br
\fBtkdnd::SetDropFileTempDirectory \fIdirectory\fR

.SH INTRODUCTION
The \fBtkdnd\fR family commands provide a Tcl interface to native,
platform specific drag and drop mechanism.
Under Unix the drag & drop protocol in use is the XDND protocol version 5
(also used by the Qt toolkit, and the KDE and GNOME desktops). 
Under Windows, the OLE2 drag & drop interfaces are used.
Under Macintosh, the Cocoa drag and drop interfaces are used.
.PP
The \fbtkdnd\fR family can be built from source code using the standard configure; make; make install procedure. Cmake is also supported. Some binary package are available from the SourceForge download site, from ActiveState's ActiveTcl distribution, and elsewhere.
.PP
With the \fBtkdnd\fR family commands the user is able to register existing Tk
widgets as drag sources or drop targets, that are able to send or receive data
during drag and drop operations, encoded in specific types.
These types can be platform independent types like DND_Text and DND_Files or
platform specific types, like CF_UNICODETEXT or text/plain.
.PP
The legal forms for the \fBtkdnd\fR commands are:
.TP
\fBtkdnd::drop_target register\fI window ?type-list?\fR
This command will register \fIwindow\fR as a drop target. A drop target is a
widget than can accept a drop action. \fIwindow\fR must exist when this command
is executed and this command can be executed multiple times on a widget.

When \fIwindow\fR is registered as a drop target, and optional \fItype-list\fR
can be provided. This type list can contain one or more types that \fIwindow\fR
will accept during a drop action, and it can contain platform independent or
platform specific types. Platform independent are \fBDND_Text\fR
for dropping text portions and \fBDND_Files\fR for dropping a list of files
(which can contain one or multiple files) on \fIwindow\fR.
If \fItype-list\fR is not specified, it defaults to the empty list.
.TP
\fBtkdnd::drop_target unregister\fI window\fR
This command will stop \fIwindow\fR from being a drop target.
Thus, \fIwindow\fR will stop receiving events related to drop operations.
It is an error to use this command for a \fIwindow\fR that has not been
registered as a drop target with \fBtkdnd::drop_target register\fR.
.TP
\fBtkdnd::drag_source register\fI window ?type-list? ?mouse-button?\fR
This command will register \fIwindow\fR as a drag source. A drag source is a
widget than can start a drag action. \fIwindow\fR must exist when this command
is executed and this command can be executed multiple times on a widget.

When \fIwindow\fR is registered as a drag source, and optional \fItype-list\fR
can be provided. This type list can contain one or more types that \fIwindow\fR
will provide during a drag action, and it can contain platform independent or
platform specific types. Platform independent are \fBDND_Text\fR
for dropping text portions and \fBDND_Files\fR for dropping a list of files
(which can contain one or multiple files) on \fIwindow\fR. However, this type
list is indicative/informative. \fIwindow\fR can initiate a drag action with
even a different type list. If \fItype-list\fR is not specified, it defaults to
the empty list.

Finally, \fImouse-button\fR is the mouse button that will be used for starting
the drag action. It can have any of the values 1 (left mouse button),
2 (middle mouse button - wheel) and 3 (right mouse button).
If \fImouse-button\fR is not specified, it defaults to 1.
.TP
\fBtkdnd::drag_source unregister\fI window\fR
This command will stop \fIwindow\fR from being a drag source.
Thus, \fIwindow\fR will stop receiving events related to drag operations.
It is an error to use this command for a \fIwindow\fR that has not been
registered as a drag source with \fBtkdnd::drag_source register\fR.
.TP
\fBtkdnd::platform_specific_types \fItype-list\fR
This command will accept a list of types that can contain platform independnent
or platform specific types. A new list will be returned, where each platform
independent type in \fItype-list\fR will be substituted by one or more platform
specific types. Thus, the returned list may have more elements than
\fItype-list\fR.
.TP
\fBtkdnd::platform_independent_types\fI type-list\fR
This command will accept a list of types that can contain platform independnent
or platform specific types. A new list will be returned, where each platform
specific type in \fItype-list\fR will be substituted by one or more platform
independent types. Thus, the returned list may have more elements than
\fItype-list\fR.
.TP
\fBtkdnd::GetDropFileTempDirectory\fR
This command will return the temporary directory used by TkDND for storing
temporary files. When the package is loaded, this temporary directory will be
initialised to a proper directory according to the operating system. This
default initial value can be changed to be the value of the following
environmental variables: \fBTKDND_TEMP_DIR\fR, \fBTEMP\fR, \fBTMP\fR.
.TP
\fBtkdnd::SetDropFileTempDirectory \fIdirectory\fR
This command will change the temporary directory used by TkDND for storing
temporary files to \fIdirectory\fR.
.SH SUPPORTED TYPES
In order to declare the format that the data that will transfered during
a drag and drop operation, all drag and drop protocols use the notion of types.
Unfortunately, each protocol defines its own, usually platform specific, types. Tkdnd, trying to maintain portability among different platforms, offers some
predefined types for some basic kinds of data, like text, and filenames.
Currently, the following predifined cross-platform values are available:
.IP  \fBDND_Text\fR: 5
This type can be used for transfering textual data. Internally, it is translated
to the following platform specific formats:
.br
Windows: \fBCF_UNICODETEXT\fR, \fBCF_TEXT\fR.
.br
Unix: \fBtext/plain;charset=UTF-8\fR, \fBtext/plain\fR.
.br
Mac: \fBNSStringPboardType\fR.
.IP  \fBDND_Files\fR: 5
This type can be used for transfering a list of file names.
Internally, it is translated to the following platform specific formats:
.br
Windows: \fBCF_HDROP\fR.
.br
Unix: \fBtext/uri-list\fR.
.br
Mac: \fBNSFilenamesPboardType\fR.
.TP
Additionally to the platform independent types, tkdnd supports the following platform specific types:
.IP  \fBWindows\fR: 5
\fBCF_UNICODETEXT\fR: Text transfer encoded in unicode.
.br
\fBCF_TEXT\fR: Text transfer with application dependent encoding. If an encoding
locale is specified through CF_LOCALE it is used, else the system encoding is
used for the conversion.
.br
\fBFileGroupDescriptor - FileContents\fR: These two types are used for
transfering a set of files that do not appear physically on disk, like files
from compressed folders or Outlook e-mail messages. File names are transfered as
in the CF_TEXT type, while file contents are transfered in binary. Tkdnd
retrieves both the file names and the file contents, and saves then in a
temporary directory. When the transfer is complete, the file names of the saved
files in the temporary folder are returned. Note that tkdnd support this type
pair only as drop targets and not as drag sources.
.br
\fBFileGroupDescriptorW - FileContents\fR: These two types are used for
transfering a set of files that do not appear physically on disk, like files
from compressed folders or Outlook e-mail messages. File names are transfered as
in the CF_UNICODETEXT type, while file contents are transfered in binary. Tkdnd
retrieves both the file names and the file contents, and saves then in a
temporary directory. When the transfer is complete, the file names of the saved
files in the temporary folder are returned. Note that tkdnd support this type
pair only as drop targets and not as drag sources.
.br
\fBCF_HDROP\fR: Files transfer encoded in UTF-8.
.IP  \fBUnix\fR: 5
.PP
Finally, format types used for drop types can have \fBwildcards\fR, following
the same rules as "string match". For example, registering a drop target with
the type "*", will accept any drop, no matter what the drop format is.
.SH EVENTS
Windows registered as either drop targets or drag sources, will receive certain
events, during drag and drop operations. As a result, the windows are expected
to have bindings for some of these events. Some events are mandatory (in the
sense that a drag or drop operation can be stopped if the bindings do not
exist), while others are not. However, it is a good practice to define bindings
for all events, so as the application will behave as expected during drag and
drop operations.

The tkdnd package defines a set of virtual events, that correspond to various
phases of a drag and drop operation. All windows that are either a drop target
or a drag source are expected to have bindings for (all) these events, created
with the \fBbind\fR Tk command. While these event bindings are regular Tk
events, they have a small difference from plain Tk events: most of them are
expected to return a value. Since Tk bindings cannot return a value, tkdnd does
not actually generate these events (i.e. through "event generate"). Instead,
tkdnd locates the script that has been bound to the virtual event, and directly
executes it, as a script. Apart from this small difference in how the events are
triggered, the events required by tkdnd can be viewed as regular events. In the
following two sections all virtual events defined by the tkdnd package are
presented.
.SH DROP TARGET EVENTS
A window registered as a drop target, is expected to have bindings for the
following virtual events:
.TP
\fB<<DropEnter>>\fR:
This event is triggered when the mouse enters the window
during a drop action. The purpose of this event is to change the visual state of
the window, so as to notify the user whether the drop will be accepted or not.
The binding script is expected to return a single value that will define the
drop action. This returned action can be one of \fBcopy\fR, \fBmove\fR,
\fBlink\fR, \fBask\fR, \fBprivate\fR and \fBrefuse_drop\fR. This event is not
mandatory, but if it is defined, it has to return an action. In case an action
is not returned, the drop is refused for this window.
.TP
\fB<<DropPosition>>\fR:
This events is triggered when the mouse moves inside the
window during a drop action. The purpose of this event is to let window decide
if it will accept the drop and the action of the drop, if a drop is going to
happen at the specific mouse coordinates. Thus, the script binding for such an
event can get the mouse coordinates and the pressed modifier buttons (such as
ctrl, shift or alt), and is expected to return the drop action, which again must
be one of \fBcopy\fR, \fBmove\fR,
\fBlink\fR, \fBask\fR, \fBprivate\fR and \fBrefuse_drop\fR. This event is not
mandatory, but if it is defined, it has to return an action. In case an action
is not returned, the drop is refused for this window.
.TP
\fB<<DropLeave>>\fR:
This event is triggered when the mouse leaves outside the
area covered by window, whithout a drop happening. The binding of such an event
is expected to restore the visual state of the window to normal (i.e. the visual
state the window was in before the <<DropEnter>> event was triggered). The
binding for such an event is not expected to return a value.
.TP
\fB<<Drop>>\fR:
This event is triggered by a drop action, and it is expected to
handle the dropped data and reset the visual state of the window. The binding
script is expected to return a value, which will be the action that has been
performed to the data and must be one of \fBcopy\fR, \fBmove\fR,
\fBlink\fR, \fBask\fR, \fBprivate\fR and \fBrefuse_drop\fR. This event is not
mandatory, but if it is defined, it has to return an action. In case an action
is not returned, the drop is refused for this window.
.TP
\fB<<Drop:\fItype\fB>>\fR:
This event is a specialisation of the generic
<<Drop>> event, augmented with a type. If such a binding exists and the drop
type matches \fItype\fR, this event binding will be executed, instead of the
generic <<Drop>> event binding. These events allow for easy specialisation of
drop bindings, according to the type of the dropped data. \fItype\fR can be
either a platform independent or a platform specific type. The binding script of
such an event is expected to return a value, which will be the action that has
been performed to the data and must be one of \fBcopy\fR, \fBmove\fR,
\fBlink\fR, \fBask\fR, \fBprivate\fR and \fBrefuse_drop\fR. This event is not
mandatory, but if it is defined, it has to return an action. In case an action
is not returned, the drop is refused for this window.
.SH DRAG SOURCE EVENTS
A window registered as a drag source, is expected to have bindings for the
following virtual events:
.TP
\fB<<DragInitCmd>>\fR:
This event is triggered when a drag action is about to start. This is a
mandatory event (whose absence will cancel the drag action), and is responsible
for providing three things: the list of actions and format types supported by
the drag source, and of course the data to be dropped. Thus, the binding script
for such an event must return a list of three elements: the drop actions
supported by the drag source (which can be any of \fBcopy\fR, \fBmove\fR,
\fBlink\fR, \fBask\fR, and \fBprivate\fR), the format type list that the data
can be dropped as (which can be any platform independent or platform specific
type), and finally the data. A simple example of such a binding, is:
.CS
bind .drag_source <<DragInitCmd>> \\
     {list copy DND_Text {Hellow world!}}
.CE
.TP
\fB<<DragEndCmd>>\fR:
This event is triggered when the drag action has finished (either when the drop
was succesful or not). Its main purpose is to process the dropped data according
to the drop action returned by the drop target. Binding for such an event
is not mandatory, and the binding is not expected to return a value.
.SH BINDING SCRIPTS AND SUBSTITUTIONS
All bindings scripts defined for any of the virtual events above will be
executed in the same interpreter that was used for creating the window the 
event is bound to, and the binding script will executed at the global
level (i.e. only global variables will be accessible).

If the binding script contains any % characters, then substitutions will be
made, like in normal Tk binding scripts. Valid % specifiers are:
.IP \fB%%\fR 5
Replaced with a single percent. 
.IP  \fB%A\fR 5
The current action of the drag/drop operation.
.IP  \fB%a\fR 5
The action list supported by the drag source. 
.IP  \fB%b\fR 5
The mouse button that is pressed during a drag/drop operation. Note that 
always a single mouse button is reported as pressed, even if more than one 
mouse buttons are actually pressed.
.IP  \fB%c\fR 5
The codes of the list of types supported by the drag source. All codes are in
octal format and have the same order as the list of types obtained through the
\fB%t\fR substitution.
.IP  \fB%C\fR 5
The code (in octal format) of the current type of the drag and drop operation.
.IP  \fB%CTT\fR 5
The list of types from the drop target type list that are common to the drag
source type list.
.IP  \fB%CST\fR 5
The list of types from the drag source type list that are common to the drop
target type list.
.IP  \fB%D\fR 5
The data that has been dropped. Under some platforms the data will be 
available before the drop has occured. The format of the data is the current
type of the drop operation.
.IP  \fB%e\fR 5
The name of the current virtual event. One of <<DropEnter>>, <<DropPosition>>,
<<DropLeave>>, <<Drop:\fItype\fR>>, <<Drop>>, <<DragInitCmd>>, <<DragEndCmd>>.
.IP  \fB%L\fR 5
The list of types supported by the drag source.
.IP  \fB%m\fR 5
The list of modifier keyboard keys that are pressed. 
Modifier keys are some special keys, like Shift, Control or Alt. 
Valid modifiers are "shift", "ctrl" and "alt". It is useful for
binding scripts of drop target events to examine this list of modifiers, as it
is quite usuall to change the action according to the state of some modifier
keys.
.IP  \fB%ST\fR 5
The list of types supported by the drag source.
.IP  \fB%t\fR 5
The list of types supported by the drag source.
.IP  \fB%T\fR 5
The current type of the drag and drop operation.
.IP  \fB%TT\fR 5
The list of types supported by the drop target.
.IP  \fB%W\fR 5
The window that the event is delivered to.
.IP  \fB%X\fR 5
The mouse pointer x coordinate, relative to the root window.
.IP  \fB%Y\fR 5
The mouse pointer y coordinate, relative to the root window.
.SH SPECIFYING DROP TARGETS
Creating drop targets is easy: we have to only register a window as a drop
target with the list of format types it can accept, and add a few bindings. For
example, a window that accepts textual drops can be as follows:
.CS
label .drop_target -text {Text Drop Target!} -bg white
tkdnd::drop_target register .drop_target DND_Text
bind .drop_target <<DropEnter>> {%W configure -bg yellow; list copy}
bind .drop_target <<DropPosition>> {list copy}
bind .drop_target <<DropLeave>> {%W configure -bg white}
bind .drop_target <<Drop>> {%W configure -text %D; %W configure -bg white}
.CE
From the above bindings, none is obligatory. However, we usually want to receive
dropped data (thus the <<Drop>> event must be handled) and we want to give
visual feedback to the users through the <<DropEnter>> and <<DropLeave>> events.
Finally, <<DropPosition>> is only necessary if we want to only accept drops on
specific areas of the window, or we want to change the drop action according to
the pressed modifiers.

Now, if we want to also add the ability to receive file drops, we could add:
.CS
tkdnd::drop_target register .drop_target DND_Files
bind .drop_target <<Drop:DND_Files>> \\
   {puts %D; %W configure -bg white}
.CE
Note that we have added a "specialised" drop binding, for the event
<<Drop:DND_Files>>: this means that when a text portion is dropped over the
window, the <<Drop>> event binding will be executed. But when a list of files is
dropped onto the window, the <<Drop:DND_Files>> event binding will be executed.
If we proceed and define a binding for the <<Drop:DND_Text>> event, the binding
of the "general" <<Drop>> event will never be executed.
.SH SPECIFYING DRAG SOURCES
In order to specify a drag source, we need to register a window as a drag
source:
.CS
tkdnd::drag_source register .text_drag_source
.CE
The above command defines a drag source with an empty type list (and which will
be declared in the <<DragInitCmd>> event binding) and arranges mouse bindings
such as a drag will be started with the left mouse button.
Then, it is absolutely necessary to define a binding for the <<DragInitCmd>>:
this event binding must return the list of actions, the list of format types and
the actual data to be dropped:
.CS
bind .text_drag_source <<DragInitCmd>> \\
     {list {copy move} DND_Text {Hello from Tk!}}
.CE
And that was all!
.SH BUGS
\fBUnix:\fR
Dragging from Tk windows has not yet been implemented.
\fBOS X:\fR
TkDND under OS X is built on top of the Cocoa framework. Thus, it is compatible
with Tk version >= 8.6
.br
.SH KEYWORDS
dnd, drag and drop
blob
data 14350
#
# tkdnd.tcl --
# 
#    This file implements some utility procedures that are used by the TkDND
#    package.
#
# This software is copyrighted by:
# George Petasis, National Centre for Scientific Research "Demokritos",
# Aghia Paraskevi, Athens, Greece.
# e-mail: petasis@iit.demokritos.gr
#
# The following terms apply to all files associated
# with the software unless explicitly disclaimed in individual files.
#
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors
# and need not follow the licensing terms described here, provided that
# the new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
# DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
# MODIFICATIONS.
#

package require Tk

namespace eval tkdnd {
  variable _topw ".drag"
  variable _tabops
  variable _state
  variable _x0
  variable _y0
  variable _platform_namespace
  variable _drop_file_temp_dir
  variable _auto_update 1

  variable _windowingsystem

  bind TkDND_Drag1 <ButtonPress-1> {tkdnd::_begin_drag press  1 %W %s %X %Y}
  bind TkDND_Drag1 <B1-Motion>     {tkdnd::_begin_drag motion 1 %W %s %X %Y}
  bind TkDND_Drag2 <ButtonPress-2> {tkdnd::_begin_drag press  2 %W %s %X %Y}
  bind TkDND_Drag2 <B2-Motion>     {tkdnd::_begin_drag motion 2 %W %s %X %Y}
  bind TkDND_Drag3 <ButtonPress-3> {tkdnd::_begin_drag press  3 %W %s %X %Y}
  bind TkDND_Drag3 <B3-Motion>     {tkdnd::_begin_drag motion 3 %W %s %X %Y}
  
  # ----------------------------------------------------------------------------
  #  Command tkdnd::initialise: Initialise the TkDND package.
  # ----------------------------------------------------------------------------
  proc initialise { dir PKG_LIB_FILE PACKAGE_NAME} {
    variable _platform_namespace
    variable _drop_file_temp_dir
    variable _windowingsystem
    global env

    switch [tk windowingsystem] {
      x11 {
        set _windowingsystem x11
      }
      win32 -
      windows {
        set _windowingsystem windows
      }
      aqua  {
        set _windowingsystem aqua
      }
      default {
        error "unknown Tk windowing system"
      }
    }

    ## Get User's home directory: We try to locate the proper path from a set of
    ## environmental variables...
    foreach var {HOME HOMEPATH USERPROFILE ALLUSERSPROFILE APPDATA} {
      if {[info exists env($var)]} {
        if {[file isdirectory $env($var)]} {
          set UserHomeDir $env($var)
          break
        }
      }
    }

    ## Should use [tk windowingsystem] instead of tcl platform array:
    ## OS X returns "unix," but that's not useful because it has its own
    ## windowing system, aqua
    ## Under windows we have to also combine HOMEDRIVE & HOMEPATH...
    if {![info exists UserHomeDir] && 
        [string equal $_windowingsystem windows] &&
        [info exists env(HOMEDRIVE)] && [info exists env(HOMEPATH)]} {
      if {[file isdirectory $env(HOMEDRIVE)$env(HOMEPATH)]} {
        set UserHomeDir $env(HOMEDRIVE)$env(HOMEPATH)
      }
    }
    ## Have we located the needed path?
    if {![info exists UserHomeDir]} {
      set UserHomeDir [pwd]
    }
    set UserHomeDir [file normalize $UserHomeDir]
    
    ## Try to locate a temporary directory...
    foreach var {TKDND_TEMP_DIR TEMP TMP} {
      if {[info exists env($var)]} {
        if {[file isdirectory $env($var)] && [file writable $env($var)]} {
          set _drop_file_temp_dir $env($var)
          break
        }
      }
    }
    if {![info exists _drop_file_temp_dir]} {
      foreach _dir [list "$UserHomeDir/Local Settings/Temp" \
                         "$UserHomeDir/AppData/Local/Temp" \
                         /tmp \
                         C:/WINDOWS/Temp C:/Temp C:/tmp \
                         D:/WINDOWS/Temp D:/Temp D:/tmp] {
        if {[file isdirectory $_dir] && [file writable $_dir]} {
          set _drop_file_temp_dir $_dir
          break
        }
      }
    }
    if {![info exists _drop_file_temp_dir]} {
      set _drop_file_temp_dir $UserHomeDir
    }
    set _drop_file_temp_dir [file native $_drop_file_temp_dir]
    
    switch $_windowingsystem {
      x11 {
        source $dir/tkdnd_unix.tcl
        set _platform_namespace xdnd
      }
      win32 -
      windows {
        source $dir/tkdnd_windows.tcl
        set _platform_namespace olednd
      }
      aqua  {
        source $dir/tkdnd_unix.tcl
        source $dir/tkdnd_macosx.tcl
        set _platform_namespace macdnd
      }
      default {
        error "unknown Tk windowing system"
      }
    }
    load $PKG_LIB_FILE $PACKAGE_NAME
    source $dir/tkdnd_compat.tcl
  };# initialise

  proc GetDropFileTempDirectory { } {
    variable _drop_file_temp_dir
    return $_drop_file_temp_dir
  }
  proc SetDropFileTempDirectory { dir } {
    variable _drop_file_temp_dir
    set _drop_file_temp_dir $dir
  }
  
};# namespace tkdnd

# ----------------------------------------------------------------------------
#  Command tkdnd::drag_source
# ----------------------------------------------------------------------------
proc tkdnd::drag_source { mode path { types {} } { event 1 } } {
  set tags [bindtags $path]
  set idx  [lsearch $tags "TkDND_Drag*"]
  switch -- $mode {
    register {
      if { $idx != -1 } {
        bindtags $path [lreplace $tags $idx $idx TkDND_Drag$event]
      } else {
        bindtags $path [concat $tags TkDND_Drag$event]
      }
      set types [platform_specific_types $types]
      set old_types [bind $path <<DragSourceTypes>>]
      foreach type $types {
        if {[lsearch $old_types $type] < 0} {lappend old_types $type}
      }
      bind $path <<DragSourceTypes>> $old_types
    }
    unregister {
      if { $idx != -1 } {
        bindtags $path [lreplace $tags $idx $idx]
      }
    }
  }
};# tkdnd::drag_source

# ----------------------------------------------------------------------------
#  Command tkdnd::drop_target
# ----------------------------------------------------------------------------
proc tkdnd::drop_target { mode path { types {} } } {
  variable _windowingsystem
  set types [platform_specific_types $types]
  switch -- $mode {
    register {
      switch $_windowingsystem {
        x11 {
          _register_types $path [winfo toplevel $path] $types
        }
        win32 -
        windows {
          _RegisterDragDrop $path
          bind <Destroy> $path {+ tkdnd::_RevokeDragDrop %W}
        }
        aqua {
          macdnd::registerdragwidget [winfo toplevel $path] $types
        }
        default {
          error "unknown Tk windowing system"
        }
      }
      set old_types [bind $path <<DropTargetTypes>>]
      set new_types {}
      foreach type $types {
        if {[lsearch -exact $old_types $type] < 0} {lappend new_types $type}
      }
      if {[llength $new_types]} {
        bind $path <<DropTargetTypes>> [concat $old_types $new_types]
      }
    }
    unregister {
      switch $_windowingsystem {
        x11 {
        }
        win32 -
        windows {
          _RevokeDragDrop $path
        }
        aqua {
          error todo
        }
        default {
          error "unknown Tk windowing system"
        }
      }
      bind $path <<DropTargetTypes>> {}
    }
  }
};# tkdnd::drop_target

# ----------------------------------------------------------------------------
#  Command tkdnd::_begin_drag
# ----------------------------------------------------------------------------
proc tkdnd::_begin_drag { event button source state X Y } {
  variable _x0
  variable _y0
  variable _state

  switch -- $event {
    press {
      set _x0    $X
      set _y0    $Y
      set _state "press"
    }
    motion {
      if { ![info exists _state] } {
        # This is just extra protection. There seem to be
        # rare cases where the motion comes before the press.
        return
      }
      if { [string equal $_state "press"] } {
        if { abs($_x0-$X) > 3 || abs($_y0-$Y) > 3 } {
          set _state "done"
          _init_drag $button $source $state $X $Y
        }
      }
    }
  }
};# tkdnd::_begin_drag

# ----------------------------------------------------------------------------
#  Command tkdnd::_init_drag
# ----------------------------------------------------------------------------
proc tkdnd::_init_drag { button source state rootX rootY } {
  # Call the <<DragInitCmd>> binding.
  set cmd [bind $source <<DragInitCmd>>]
  if {[string length $cmd]} {
    set cmd [string map [list %W $source %X $rootX %Y $rootY \
                              %S $state  %e <<DragInitCmd>> %A \{\} \
                              %t [bind $source <<DragSourceTypes>>]] $cmd]
    set info [uplevel \#0 $cmd]
    if { $info != "" } {
      variable _windowingsystem
      foreach { actions types data } $info { break }
      set types [platform_specific_types $types]
      set action refuse_drop
      switch $_windowingsystem {
        x11 {
          set action [xdnd::_dodragdrop $source $actions $types $data $button]
        }
        win32 -
        windows {
          set action [_DoDragDrop $source $actions $types $data $button]
        }
        aqua {
          set action [macdnd::dodragdrop $source $actions $types $data]
        }
        default {
          error "unknown Tk windowing system"
        }
      }
      ## Call _end_drag to notify the widget of the result of the drag
      ## operation...
      _end_drag $button $source {} $action {} $data {} $state $rootX $rootY
    }
  }
};# tkdnd::_init_drag

# ----------------------------------------------------------------------------
#  Command tkdnd::_end_drag
# ----------------------------------------------------------------------------
proc tkdnd::_end_drag { button source target action type data result
                        state rootX rootY } {
  set rootX 0
  set rootY 0
  # Call the <<DragEndCmd>> binding.
  set cmd [bind $source <<DragEndCmd>>]
  if {[string length $cmd]} {
    set cmd [string map [list %W $source %X $rootX %Y $rootY \
                              %S $state %e <<DragEndCmd>> %A \{$action\}] $cmd]
    set info [uplevel \#0 $cmd]
    if { $info != "" } {
      variable _windowingsystem
      foreach { actions types data } $info { break }
      set types [platform_specific_types $types]
      switch $_windowingsystem {
        x11 {
          error "dragging from Tk widgets not yet supported"
        }
        win32 -
        windows {
          set action [_DoDragDrop $source $actions $types $data $button]
        }
        aqua {
          macdnd::dodragdrop $source $actions $types $data
        }
        default {
          error "unknown Tk windowing system"
        }
      }
      ## Call _end_drag to notify the widget of the result of the drag
      ## operation...
      _end_drag $button $source {} $action {} $data {} $state $rootX $rootY
    }
  }
};# tkdnd::_end_drag

# ----------------------------------------------------------------------------
#  Command tkdnd::platform_specific_types
# ----------------------------------------------------------------------------
proc tkdnd::platform_specific_types { types } {
  variable _platform_namespace
  return [${_platform_namespace}::_platform_specific_types $types]
}; # tkdnd::platform_specific_types

# ----------------------------------------------------------------------------
#  Command tkdnd::platform_independent_types
# ----------------------------------------------------------------------------
proc tkdnd::platform_independent_types { types } {
  variable _platform_namespace
  return [${_platform_namespace}::_platform_independent_types $types]
}; # tkdnd::platform_independent_types

# ----------------------------------------------------------------------------
#  Command tkdnd::platform_specific_type
# ----------------------------------------------------------------------------
proc tkdnd::platform_specific_type { type } {
  variable _platform_namespace
  return [${_platform_namespace}::_platform_specific_type $type]
}; # tkdnd::platform_specific_type

# ----------------------------------------------------------------------------
#  Command tkdnd::platform_independent_type
# ----------------------------------------------------------------------------
proc tkdnd::platform_independent_type { type } {
  variable _platform_namespace
  return [${_platform_namespace}::_platform_independent_type $type]
}; # tkdnd::platform_independent_type

# ----------------------------------------------------------------------------
#  Command tkdnd::bytes_to_string
# ----------------------------------------------------------------------------
proc tkdnd::bytes_to_string { bytes } {
  set string {}
  foreach byte $bytes {
    append string [binary format c $byte]
  }
  return $string
};# tkdnd::bytes_to_string

# ----------------------------------------------------------------------------
#  Command tkdnd::urn_unquote
# ----------------------------------------------------------------------------
proc tkdnd::urn_unquote {url} {
  set result ""
  set start 0
  while {[regexp -start $start -indices {%[0-9a-fA-F]{2}} $url match]} {
    foreach {first last} $match break
    append result [string range $url $start [expr {$first - 1}]]
    append result [format %c 0x[string range $url [incr first] $last]]
    set start [incr last]
  }
  append result [string range $url $start end]
  return $result
};# tkdnd::urn_unquote
blob
data 6191
#
# tkdnd_compat.tcl --
# 
#    This file implements some utility procedures, to support older versions
#    of the TkDND package.
#
# This software is copyrighted by:
# George Petasis, National Centre for Scientific Research "Demokritos",
# Aghia Paraskevi, Athens, Greece.
# e-mail: petasis@iit.demokritos.gr
#
# The following terms apply to all files associated
# with the software unless explicitly disclaimed in individual files.
#
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors
# and need not follow the licensing terms described here, provided that
# the new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
# DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
# MODIFICATIONS.
#

namespace eval compat {

};# namespace compat

# ----------------------------------------------------------------------------
#  Command ::dnd
# ----------------------------------------------------------------------------
proc ::dnd {method window args} {
  switch $method {
    bindtarget {
      switch [llength $args] {
        0 {return [tkdnd::compat::bindtarget0 $window]}
        1 {return [tkdnd::compat::bindtarget1 $window [lindex $args 0]]}
        2 {return [tkdnd::compat::bindtarget2 $window [lindex $args 0] \
                                                      [lindex $args 1]]}
        3 {return [tkdnd::compat::bindtarget3 $window [lindex $args 0] \
                                     [lindex $args 1] [lindex $args 2]]}
        4 {return [tkdnd::compat::bindtarget4 $window [lindex $args 0] \
                    [lindex $args 1] [lindex $args 2] [lindex $args 3]]}
      }
    }
    cleartarget {
      return [tkdnd::compat::cleartarget $window]
    }
    bindsource {
      switch [llength $args] {
        0 {return [tkdnd::compat::bindsource0 $window]}
        1 {return [tkdnd::compat::bindsource1 $window [lindex $args 0]]}
        2 {return [tkdnd::compat::bindsource2 $window [lindex $args 0] \
                                                      [lindex $args 1]]}
        3 {return [tkdnd::compat::bindsource3 $window [lindex $args 0] \
                                     [lindex $args 1] [lindex $args 2]]}
      }
    }
    clearsource {
      return [tkdnd::compat::clearsource $window]
    }
    drag {
      return [tkdnd::_init_drag $window "press" 0 0]
    }
  }
  error "invalid number of arguments!"
};# ::dnd

# ----------------------------------------------------------------------------
#  Command compat::bindtarget
# ----------------------------------------------------------------------------
proc compat::bindtarget0 {window} {
  return [bind $window <<DropTargetTypes>>]
};# compat::bindtarget0

proc compat::bindtarget1 {window type} {
  return [bindtarget2 $window $type <Drop>]
};# compat::bindtarget1

proc compat::bindtarget2 {window type event} {
  switch $event {
    <DragEnter> {return [bind $window <<DropEnter>>]}
    <Drag>      {return [bind $window <<DropPosition>>]}
    <DragLeave> {return [bind $window <<DropLeave>>]}
    <Drop>      {return [bind $window <<Drop>>]}
  }
};# compat::bindtarget2

proc compat::bindtarget3 {window type event script} {
  set type [normalise_type $type]
  ::tkdnd::drop_target register $window [list $type]
  switch $event {
    <DragEnter> {return [bind $window <<DropEnter>> $script]}
    <Drag>      {return [bind $window <<DropPosition>> $script]}
    <DragLeave> {return [bind $window <<DropLeave>> $script]}
    <Drop>      {return [bind $window <<Drop>> $script]}
  }
};# compat::bindtarget3

proc compat::bindtarget4 {window type event script priority} {
  return [bindtarget3 $window $type $event $script]
};# compat::bindtarget4

proc compat::normalise_type { type } {
  switch $type {
    text/plain -
    {text/plain;charset=UTF-8} -
    Text                       {return DND_Text}
    text/uri-list -
    Files                      {return DND_Files}
    default                    {return $type}
  }
};# compat::normalise_type

# ----------------------------------------------------------------------------
#  Command compat::bindsource
# ----------------------------------------------------------------------------
proc compat::bindsource0 {window} {
  return [bind $window <<DropTargetTypes>>]
};# compat::bindsource0

proc compat::bindsource1 {window type} {
  return [bindsource2 $window $type <Drop>]
};# compat::bindsource1

proc compat::bindsource2 {window type script} {
  ::tkdnd::drag_source register $window $type 2
  bind $window <<DragInitCmd>> "list {copy} %t \[$script\]"
};# compat::bindsource2

proc compat::bindsource3 {window type script priority} {
  return [bindsource2 $window $type $script]
};# compat::bindsource3

# ----------------------------------------------------------------------------
#  Command compat::cleartarget
# ----------------------------------------------------------------------------
proc compat::cleartarget {window} {
};# compat::cleartarget

# ----------------------------------------------------------------------------
#  Command compat::clearsource
# ----------------------------------------------------------------------------
proc compat::clearsource {window} {
};# compat::clearsource
blob
data 7305
#
# tkdnd_macosx.tcl --
# 
#    This file implements some utility procedures that are used by the TkDND
#    package.

#   This software is copyrighted by:
#   Georgios Petasis, Athens, Greece.
#   e-mail: petasisg@yahoo.gr, petasis@iit.demokritos.gr
#
#   Mac portions (c) 2009 Kevin Walzer/WordTech Communications LLC,
#   kw@codebykevin.com
#
#
# The following terms apply to all files associated
# with the software unless explicitly disclaimed in individual files.
#
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors
# and need not follow the licensing terms described here, provided that
# the new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
# DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
# MODIFICATIONS.
#

#basic API for Mac Drag and Drop

#two data types supported: strings and file paths

#two commands at C level: ::tkdnd::macdnd::registerdragwidget, ::tkdnd::macdnd::unregisterdragwidget

#data retrieval mechanism: text or file paths are copied from drag clipboard to system clipboard and retrieved via [clipboard get]; array of file paths is converted to single tab-separated string, can be split into Tcl list

if {[tk windowingsystem] eq "aqua" && "AppKit" ni [winfo server .]} {
  error {TkAqua Cocoa required}
}

namespace eval macdnd {
  variable _dropped_data
};# namespace macdnd

# ----------------------------------------------------------------------------
#  Command macdnd::_HandleEnter
# ----------------------------------------------------------------------------
proc macdnd::_HandleEnter { path drag_source typelist } {
  return [::tkdnd::xdnd::_HandleXdndEnter $path $drag_source $typelist]
};# macdnd::_HandleEnter

# ----------------------------------------------------------------------------
#  Command macdnd::_HandlePosition 
# ----------------------------------------------------------------------------
proc macdnd::_HandlePosition { drop_target rootX rootY } {
  return [::tkdnd::xdnd::_HandleXdndPosition $drop_target $rootX $rootY]
};# macdnd::_HandlePosition

# ----------------------------------------------------------------------------
#  Command macdnd::_HandleLeave
# ----------------------------------------------------------------------------
proc macdnd::_HandleLeave { args  } {
  return [::tkdnd::xdnd::_HandleXdndLeave]
};# macdnd::_HandleLeave

# ----------------------------------------------------------------------------
#  Command macdnd::_HandleDrop
# ----------------------------------------------------------------------------
proc macdnd::_HandleDrop { drop_target data args } {
  variable _dropped_data
  set _dropped_data $data
  return [::tkdnd::xdnd::_HandleXdndDrop 0]
};# macdnd::_HandleDrop

# ----------------------------------------------------------------------------
#  Command macdnd::_GetDroppedData
# ----------------------------------------------------------------------------
proc macdnd::_GetDroppedData { time } {
  variable _dropped_data
  return $_dropped_data
};# macdnd::_GetDroppedData
proc xdnd::_GetDroppedData { time } {
  return [::tkdnd::macdnd::_GetDroppedData $time]
};# xdnd::_GetDroppedData

# ----------------------------------------------------------------------------
#  Command macdnd::_GetDragSource
# ----------------------------------------------------------------------------
proc macdnd::_GetDragSource {  } {
  return [::tkdnd::xdnd::_GetDragSource]
};# macdnd::_GetDragSource

# ----------------------------------------------------------------------------
#  Command macdnd::_GetDropTarget
# ----------------------------------------------------------------------------
proc macdnd::_GetDropTarget {  } {
  return [::tkdnd::xdnd::_GetDropTarget]
};# macdnd::_GetDropTarget

# ----------------------------------------------------------------------------
#  Command macdnd::_supported_types
# ----------------------------------------------------------------------------
proc macdnd::_supported_types { types } {
  return [::tkdnd::xdnd::_supported_types $types]
}; # macdnd::_supported_types

# ----------------------------------------------------------------------------
#  Command macdnd::_platform_specific_types
# ----------------------------------------------------------------------------
proc macdnd::_platform_specific_types { types } {
  return [::tkdnd::xdnd::_platform_specific_types $types]
}; # macdnd::_platform_specific_types

# ----------------------------------------------------------------------------
#  Command macdnd::_normalise_data
# ----------------------------------------------------------------------------
proc macdnd::_normalise_data { type data } {
  return [::tkdnd::xdnd::_normalise_data $type $data]
}; # macdnd::_normalise_data

# ----------------------------------------------------------------------------
#  Command macdnd::_platform_specific_type
# ----------------------------------------------------------------------------
proc macdnd::_platform_specific_type { type } {
  switch $type {
    DND_Text   {return [list NSStringPboardType]}
    DND_Files  {return [list NSFilenamesPboardType]}
    default    {return [list $type]}
  }
}; # macdnd::_platform_specific_type
proc xdnd::_platform_specific_type { type } {
  return [::tkdnd::macdnd::_platform_specific_type $type]
}; # xdnd::_platform_specific_type

# ----------------------------------------------------------------------------
#  Command macdnd::_platform_independent_type
# ----------------------------------------------------------------------------
proc macdnd::_platform_independent_type { type } {
  switch $type {
    NSStringPboardType      {return DND_Text}
    NSFilenamesPboardType   {return DND_Files}
    default                 {return [list $type]}
  }
}; # macdnd::_platform_independent_type
proc xdnd::_platform_independent_type { type } {
  return [::tkdnd::macdnd::_platform_independent_type $type]
}; # xdnd::_platform_independent_type

# ----------------------------------------------------------------------------
#  Command macdnd::_supported_type
# ----------------------------------------------------------------------------
proc macdnd::_supported_type { type } {
  return 1
}; # macdnd::_supported_type
proc xdnd::_supported_type { type } {
  return [::tkdnd::macdnd::_supported_type $type]
}; # xdnd::_supported_type
blob
data 39443
#
# tkdnd_unix.tcl --
# 
#    This file implements some utility procedures that are used by the TkDND
#    package.
#
# This software is copyrighted by:
# George Petasis, National Centre for Scientific Research "Demokritos",
# Aghia Paraskevi, Athens, Greece.
# e-mail: petasis@iit.demokritos.gr
#
# The following terms apply to all files associated
# with the software unless explicitly disclaimed in individual files.
#
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors
# and need not follow the licensing terms described here, provided that
# the new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
# DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
# MODIFICATIONS.
#

namespace eval xdnd {
  variable _types {}
  variable _typelist {}
  variable _codelist {}
  variable _actionlist {}
  variable _pressedkeys {}
  variable _action {}
  variable _common_drag_source_types {}
  variable _common_drop_target_types {}
  variable _drag_source {}
  variable _drop_target {}

  variable _dragging 0

  variable _last_mouse_root_x 0
  variable _last_mouse_root_y 0

  proc debug {msg} {
    puts $msg
  };# debug
};# namespace xdnd

# ----------------------------------------------------------------------------
#  Command xdnd::_HandleXdndEnter
# ----------------------------------------------------------------------------
proc xdnd::_HandleXdndEnter { path drag_source typelist } {
  variable _typelist;                 set _typelist    $typelist
  variable _pressedkeys;              set _pressedkeys 1
  variable _action;                   set _action      {}
  variable _common_drag_source_types; set _common_drag_source_types {}
  variable _common_drop_target_types; set _common_drop_target_types {}
  variable _actionlist
  variable _drag_source;              set _drag_source $drag_source
  variable _drop_target;              set _drop_target {}
  variable _actionlist;               set _actionlist  \
                                           {copy move link ask private}

  variable _last_mouse_root_x;        set _last_mouse_root_x 0
  variable _last_mouse_root_y;        set _last_mouse_root_y 0
  # debug "\n==============================================================="
  # debug "xdnd::_HandleXdndEnter: path=$path, drag_source=$drag_source,\
  #        typelist=$typelist"
  # debug "xdnd::_HandleXdndEnter: ACTION: default"
  return default
};# xdnd::_HandleXdndEnter

# ----------------------------------------------------------------------------
#  Command xdnd::_HandleXdndPosition
# ----------------------------------------------------------------------------
proc xdnd::_HandleXdndPosition { drop_target rootX rootY {drag_source {}} } {
  variable _types
  variable _typelist
  variable _actionlist
  variable _pressedkeys
  variable _action
  variable _common_drag_source_types
  variable _common_drop_target_types
  variable _drag_source
  variable _drop_target

  variable _last_mouse_root_x;        set _last_mouse_root_x $rootX
  variable _last_mouse_root_y;        set _last_mouse_root_y $rootY

  # debug "xdnd::_HandleXdndPosition: drop_target=$drop_target,\
  #            _drop_target=$_drop_target, rootX=$rootX, rootY=$rootY"

  if {![info exists _drag_source] && ![string length $_drag_source]} {
    # debug "xdnd::_HandleXdndPosition: no or empty _drag_source:\
    #               return refuse_drop"
    return refuse_drop
  }

  if {$drag_source ne "" && $drag_source ne $_drag_source} {
    debug "XDND position event from unexpected source: $_drag_source\
           != $drag_source"
    return refuse_drop
  }

  ## Does the new drop target support any of our new types? 
  set _types [bind $drop_target <<DropTargetTypes>>]
  # debug ">> Accepted types: $drop_target $_types"
  if {[llength $_types]} {
    ## Examine the drop target types, to find at least one match with the drag
    ## source types...
    set supported_types [_supported_types $_typelist]
    foreach type $_types {
      foreach matched [lsearch -glob -all -inline $supported_types $type] {
        ## Drop target supports this type.
        lappend common_drag_source_types $matched
        lappend common_drop_target_types $type
      }
    }
  }
  
  # debug "\t($_drop_target) -> ($drop_target)"
  if {$drop_target != $_drop_target} {
    if {[string length $_drop_target]} {
      ## Call the <<DropLeave>> event.
      # debug "\t<<DropLeave>> on $_drop_target"
      set cmd [bind $_drop_target <<DropLeave>>]
      if {[string length $cmd]} {
        set _codelist $_typelist
        set cmd [string map [list %W $_drop_target %X $rootX %Y $rootY \
          %CST \{$_common_drag_source_types\} \
          %CTT \{$_common_drop_target_types\} \
          %ST  \{$_typelist\}    %TT \{$_types\} \
          %A   \{$_action\}      %a \{$_actionlist\} \
          %b   \{$_pressedkeys\} %m \{$_pressedkeys\} \
          %D   \{\}              %e <<DropLeave>> \
          %L   \{$_typelist\}    %% % \
          %t   \{$_typelist\}    %T  \{[lindex $_common_drag_source_types 0]\} \
          %c   \{$_codelist\}    %C  \{[lindex $_codelist 0]\} \
          ] $cmd]
        uplevel \#0 $cmd
      }
    }
    set _drop_target {}

    if {[info exists common_drag_source_types]} {
      set _action copy
      set _common_drag_source_types $common_drag_source_types
      set _common_drop_target_types $common_drop_target_types
      set _drop_target $drop_target
      ## Drop target supports at least one type. Send a <<DropEnter>>.
      # puts "<<DropEnter>> -> $drop_target"
      set cmd [bind $drop_target <<DropEnter>>]
      if {[string length $cmd]} {
        focus $drop_target
        set _codelist $_typelist
        set cmd [string map [list %W $drop_target %X $rootX %Y $rootY \
          %CST \{$_common_drag_source_types\} \
          %CTT \{$_common_drop_target_types\} \
          %ST  \{$_typelist\}    %TT \{$_types\} \
          %A   $_action          %a  \{$_actionlist\} \
          %b   \{$_pressedkeys\} %m  \{$_pressedkeys\} \
          %D   \{\}              %e  <<DropEnter>> \
          %L   \{$_typelist\}    %%  % \
          %t   \{$_typelist\}    %T  \{[lindex $_common_drag_source_types 0]\} \
          %c   \{$_codelist\}    %C  \{[lindex $_codelist 0]\} \
          ] $cmd]
        set _action [uplevel \#0 $cmd]
      }
    }
    set _drop_target $drop_target
  }
  
  set _action refuse_drop
  set _drop_target {}
  if {[info exists common_drag_source_types]} {
    set _action copy
    set _common_drag_source_types $common_drag_source_types
    set _common_drop_target_types $common_drop_target_types
    set _drop_target $drop_target
    ## Drop target supports at least one type. Send a <<DropPosition>>.
    set cmd [bind $drop_target <<DropPosition>>]
    if {[string length $cmd]} {
      set _codelist $_typelist
      set cmd [string map [list %W $drop_target %X $rootX %Y $rootY \
        %CST \{$_common_drag_source_types\} \
        %CTT \{$_common_drop_target_types\} \
        %ST  \{$_typelist\}    %TT \{$_types\} \
        %A   $_action          %a  \{$_actionlist\} \
        %b   \{$_pressedkeys\} %m  \{$_pressedkeys\} \
        %D   \{\}              %e  <<DropPosition>> \
        %L   \{$_typelist\}    %%  % \
        %t   \{$_typelist\}    %T  \{[lindex $_common_drag_source_types 0]\} \
        %c   \{$_codelist\}    %C  \{[lindex $_codelist 0]\} \
        ] $cmd]
      set _action [uplevel \#0 $cmd]
    }
  }
  # Return values: copy, move, link, ask, private, refuse_drop, default
  # debug "xdnd::_HandleXdndPosition: ACTION: $_action"
  return $_action
};# xdnd::_HandleXdndPosition

# ----------------------------------------------------------------------------
#  Command xdnd::_HandleXdndLeave
# ----------------------------------------------------------------------------
proc xdnd::_HandleXdndLeave {  } {
  variable _types
  variable _typelist
  variable _actionlist
  variable _pressedkeys
  variable _action
  variable _common_drag_source_types
  variable _common_drop_target_types
  variable _drag_source
  variable _drop_target
  variable _last_mouse_root_x
  variable _last_mouse_root_y
  if {![info exists _drop_target]} {set _drop_target {}}
  # debug "xdnd::_HandleXdndLeave: _drop_target=$_drop_target"
  if {[info exists _drop_target] && [string length $_drop_target]} {
    set cmd [bind $_drop_target <<DropLeave>>]
    if {[string length $cmd]} {
      set _codelist $_typelist
      set cmd [string map [list %W $_drop_target \
        %X $_last_mouse_root_x %Y $_last_mouse_root_y \
        %CST \{$_common_drag_source_types\} \
        %CTT \{$_common_drop_target_types\} \
        %ST  \{$_typelist\}    %TT \{$_types\} \
        %A   \{$_action\}      %a  \{$_actionlist\} \
        %b   \{$_pressedkeys\} %m  \{$_pressedkeys\} \
        %D   \{\}              %e  <<DropLeave>> \
        %L   \{$_typelist\}    %%  % \
        %t   \{$_typelist\}    %T  \{[lindex $_common_drag_source_types 0]\} \
        %c   \{$_codelist\}    %C  \{[lindex $_codelist 0]\} \
        ] $cmd]
      set _action [uplevel \#0 $cmd]
    }
  }
  foreach var {_types _typelist _actionlist _pressedkeys _action
               _common_drag_source_types _common_drop_target_types
               _drag_source _drop_target} {
    set $var {}
  }
};# xdnd::_HandleXdndLeave

# ----------------------------------------------------------------------------
#  Command xdnd::_HandleXdndDrop
# ----------------------------------------------------------------------------
proc xdnd::_HandleXdndDrop { time } {
  variable _types
  variable _typelist
  variable _actionlist
  variable _pressedkeys
  variable _action
  variable _common_drag_source_types
  variable _common_drop_target_types
  variable _drag_source
  variable _drop_target
  variable _last_mouse_root_x
  variable _last_mouse_root_y
  set rootX $_last_mouse_root_x
  set rootY $_last_mouse_root_y

  # puts "xdnd::_HandleXdndDrop: $time"

  if {![info exists _drag_source] && ![string length $_drag_source]} {
    return refuse_drop
  }
  if {![info exists _drop_target] && ![string length $_drop_target]} {
    return refuse_drop
  }
  if {![llength $_common_drag_source_types]} {return refuse_drop}
  ## Get the dropped data.
  set data [_GetDroppedData $time]
  ## Try to select the most specific <<Drop>> event.
  foreach type [concat $_common_drag_source_types $_common_drop_target_types] {
    set type [_platform_independent_type $type]
    set cmd [bind $_drop_target <<Drop:$type>>]
    if {[string length $cmd]} {
      set _codelist $_typelist
      set cmd [string map [list %W $_drop_target %X $rootX %Y $rootY \
        %CST \{$_common_drag_source_types\} \
        %CTT \{$_common_drop_target_types\} \
        %ST  \{$_typelist\}    %TT \{$_types\} \
        %A   $_action          %a \{$_actionlist\} \
        %b   \{$_pressedkeys\} %m \{$_pressedkeys\} \
        %D   [list $data]      %e <<Drop:$type>> \
        %L   \{$_typelist\}    %% % \
        %t   \{$_typelist\}    %T  \{[lindex $_common_drag_source_types 0]\} \
        %c   \{$_codelist\}    %C  \{[lindex $_codelist 0]\} \
        ] $cmd]
      return [uplevel \#0 $cmd]
    }
  }
  set cmd [bind $_drop_target <<Drop>>]
  if {[string length $cmd]} {
    set _codelist $_typelist
    set cmd [string map [list %W $_drop_target %X $rootX %Y $rootY \
      %CST \{$_common_drag_source_types\} \
      %CTT \{$_common_drop_target_types\} \
      %ST  \{$_typelist\}    %TT \{$_types\} \
      %A   $_action          %a \{$_actionlist\} \
      %b   \{$_pressedkeys\} %m \{$_pressedkeys\} \
      %D   [list $data]      %e <<Drop>> \
      %L   \{$_typelist\}    %% % \
      %t   \{$_typelist\}    %T  \{[lindex $_common_drag_source_types 0]\} \
      %c   \{$_codelist\}    %C  \{[lindex $_codelist 0]\} \
      ] $cmd]
    set _action [uplevel \#0 $cmd]
  }
  # Return values: XdndActionCopy, XdndActionMove,    XdndActionLink,
  #                XdndActionAsk,  XdndActionPrivate, refuse_drop
  return $_action
};# xdnd::_HandleXdndDrop

# ----------------------------------------------------------------------------
#  Command xdnd::_GetDroppedData
# ----------------------------------------------------------------------------
proc xdnd::_GetDroppedData { time } {
  variable _drag_source
  variable _drop_target
  variable _common_drag_source_types
  variable _use_tk_selection
  if {![llength $_common_drag_source_types]} {
    error "no common data types between the drag source and drop target widgets"
  }
  ## Is drag source in this application?
  if {[catch {winfo pathname -displayof $_drop_target $_drag_source} p]} {
    set _use_tk_selection 0
  } else {
    set _use_tk_selection 1
  }
  #set _use_tk_selection 1
  foreach type $_common_drag_source_types {
    # puts "TYPE: $type ($_drop_target)"
    # _get_selection $_drop_target $time $type
    if {$_use_tk_selection} {
      if {![catch {
        selection get -displayof $_drop_target -selection XdndSelection \
                      -type $type
                                              } result options]} {
        return [_normalise_data $type $result]
      }
    } else {
      # puts "_selection_get -displayof $_drop_target -selection XdndSelection \
      #                 -type $type -time $time"
      #after 100 [list focus -force $_drop_target]
      #after 50 [list raise [winfo toplevel $_drop_target]]
      if {![catch {
        _selection_get -displayof $_drop_target -selection XdndSelection \
                      -type $type -time $time
                                              } result options]} {
        return [_normalise_data $type $result]
      }
    }
  }
  return -options $options $result
};# xdnd::_GetDroppedData

# ----------------------------------------------------------------------------
#  Command xdnd::_GetDragSource
# ----------------------------------------------------------------------------
proc xdnd::_GetDragSource {  } {
  variable _drag_source
  return $_drag_source
};# xdnd::_GetDragSource

# ----------------------------------------------------------------------------
#  Command xdnd::_GetDropTarget
# ----------------------------------------------------------------------------
proc xdnd::_GetDropTarget {  } {
  variable _drop_target
  if {[string length $_drop_target]} {
    return [winfo id $_drop_target]
  }
  return 0
};# xdnd::_GetDropTarget

# ----------------------------------------------------------------------------
#  Command xdnd::_supported_types
# ----------------------------------------------------------------------------
proc xdnd::_supported_types { types } {
  set new_types {}
  foreach type $types {
    if {[_supported_type $type]} {lappend new_types $type}
  }
  return $new_types
}; # xdnd::_supported_types

# ----------------------------------------------------------------------------
#  Command xdnd::_platform_specific_types
# ----------------------------------------------------------------------------
proc xdnd::_platform_specific_types { types } {
  set new_types {}
  foreach type $types {
    set new_types [concat $new_types [_platform_specific_type $type]]
  }
  return $new_types
}; # xdnd::_platform_specific_types

# ----------------------------------------------------------------------------
#  Command xdnd::_normalise_data
# ----------------------------------------------------------------------------
proc xdnd::_normalise_data { type data } {
  # Tk knows how to interpret the following types:
  #    STRING, TEXT, COMPOUND_TEXT
  #    UTF8_STRING
  # Else, it returns a list of 8 or 32 bit numbers... 
  switch -glob $type {
    STRING - UTF8_STRING - TEXT - COMPOUND_TEXT {return $data}
    text/html     -
    text/plain    {
      if {[catch {
            encoding convertfrom utf-8 [tkdnd::bytes_to_string $data]
           } string]} {
        set string $data
      }
      return [string map {\r\n \n} $string]
    }
    text/uri-list* {
      if {[catch {
            encoding convertfrom utf-8 [tkdnd::bytes_to_string $data
          } string]} {
        set string $data
      }
      ## Get rid of \r\n
      set string [string trim [string map {\r\n \n} $string]]
      set files {}
      foreach quoted_file [split $string] {
        set file [tkdnd::urn_unquote $quoted_file]
        switch -glob $file {
          file://*  {lappend files [string range $file 7 end]}
          ftp://*   -
          https://* -
          http://*  {lappend files $quoted_file}
          default   {lappend files $file}
        }
      }
      return $files
    }
    application/x-color {
      return $data
    }
    text/x-moz-url - 
    application/q-iconlist -
    default    {return $data}
  }
}; # xdnd::_normalise_data

# ----------------------------------------------------------------------------
#  Command xdnd::_platform_specific_type
# ----------------------------------------------------------------------------
proc xdnd::_platform_specific_type { type } {
  switch $type {
    DND_Text   {return [list text/plain\;charset=utf-8 UTF8_STRING \
                             text/plain STRING TEXT COMPOUND_TEXT]}
    DND_Files  {return [list text/uri-list]}
    DND_Color  {return [list application/x-color]}
    default    {return [list $type]}
  }
}; # xdnd::_platform_specific_type

# ----------------------------------------------------------------------------
#  Command xdnd::_platform_independent_type
# ----------------------------------------------------------------------------
proc xdnd::_platform_independent_type { type } {
  switch -glob $type {
    UTF8_STRING         -
    STRING              -
    TEXT                -
    COMPOUND_TEXT       -
    text/plain*         {return DND_Text}
    text/uri-list*      {return DND_Files}
    application/x-color {return DND_Color}
    default             {return [list $type]}
  }
}; # xdnd::_platform_independent_type

# ----------------------------------------------------------------------------
#  Command xdnd::_supported_type
# ----------------------------------------------------------------------------
proc xdnd::_supported_type { type } {
  switch -glob [string tolower $type] {
    {text/plain;charset=utf-8} - text/plain -
    utf8_string - string - text - compound_text -
    text/uri-list* -
    application/x-color {return 1}
  }
  return 0
}; # xdnd::_supported_type

#############################################################################
##
##  XDND drag implementation
##
#############################################################################

# ----------------------------------------------------------------------------
#  Command xdnd::_selection_ownership_lost
# ----------------------------------------------------------------------------
proc xdnd::_selection_ownership_lost {} {
  variable _dragging
  set _dragging 0
};# _selection_ownership_lost

# ----------------------------------------------------------------------------
#  Command xdnd::_dodragdrop
# ----------------------------------------------------------------------------
proc xdnd::_dodragdrop { source actions types data button } {
  variable _dragging

  # puts "xdnd::_dodragdrop: source: $source, actions: $actions, types: $types,\
  #       data: \"$data\", button: $button"
  if {$_dragging} {
    ## We are in the middle of another drag operation...
    error "another drag operation in progress"
  }

  variable _dodragdrop_drag_source                $source
  variable _dodragdrop_drop_target                0
  variable _dodragdrop_drop_target_proxy          0
  variable _dodragdrop_actions                    $actions
  variable _dodragdrop_action_descriptions        $actions
  variable _dodragdrop_actions_len                [llength $actions]
  variable _dodragdrop_types                      $types
  variable _dodragdrop_types_len                  [llength $types]
  variable _dodragdrop_data                       $data
  variable _dodragdrop_transfer_data              {}
  variable _dodragdrop_button                     $button
  variable _dodragdrop_time                       0
  variable _dodragdrop_default_action             refuse_drop
  variable _dodragdrop_waiting_status             0
  variable _dodragdrop_drop_target_accepts_drop   0
  variable _dodragdrop_drop_target_accepts_action refuse_drop
  variable _dodragdrop_current_cursor             $_dodragdrop_default_action
  variable _dodragdrop_drop_occured               0
  variable _dodragdrop_selection_requestor        0

  ##
  ## If we have more than 3 types, the property XdndTypeList must be set on
  ## the drag source widget...
  ##
  if {$_dodragdrop_types_len > 3} {
    _announce_type_list $_dodragdrop_drag_source $_dodragdrop_types
  }

  ##
  ## Announce the actions & their descriptions on the XdndActionList &
  ## XdndActionDescription properties...
  ##
  _announce_action_list $_dodragdrop_drag_source $_dodragdrop_actions \
                        $_dodragdrop_action_descriptions

  ##
  ## Arrange selection handlers for our drag source, and all the supported types
  ##
  registerSelectionHandler $source $types

  ##
  ## Step 1: When a drag begins, the source takes ownership of XdndSelection.
  ##
  selection own -command ::tkdnd::xdnd::_selection_ownership_lost \
                -selection XdndSelection $source
  set _dragging 1

  ## Grab the mouse pointer...
  _grab_pointer $source $_dodragdrop_default_action

  ## Register our generic event handler...
  #  The generic event callback will report events by modifying variable
  #  ::xdnd::_dodragdrop_event: a dict with event information will be set as
  #  the value of the variable...
  _register_generic_event_handler

  ## Set a timeout for debugging purposes...
  #  after 60000 {set ::tkdnd::xdnd::_dragging 0}

  tkwait variable ::tkdnd::xdnd::_dragging
  _SendXdndLeave

  set _dragging 0
  _ungrab_pointer $source
  _unregister_generic_event_handler
  catch {selection clear -selection XdndSelection}
  unregisterSelectionHandler $source $types
};# xdnd::_dodragdrop

# ----------------------------------------------------------------------------
#  Command xdnd::_process_drag_events
# ----------------------------------------------------------------------------
proc xdnd::_process_drag_events {event} {
  # The return value from proc is normally 0. A non-zero return value indicates
  # that the event is not to be handled further; that is, proc has done all
  # processing that is to be allowed for the event
  variable _dragging
  if {!$_dragging} {return 0}
  # puts $event

  variable _dodragdrop_time
  set time [dict get $event time]
  set type [dict get $event type]
  if {$time < $_dodragdrop_time && ![string equal $type SelectionRequest]} {
    return 0
  }
  set _dodragdrop_time $time

  variable _dodragdrop_drag_source
  variable _dodragdrop_drop_target
  variable _dodragdrop_drop_target_proxy
  variable _dodragdrop_default_action
  switch $type {
    MotionNotify {
      set rootx  [dict get $event x_root]
      set rooty  [dict get $event y_root]
      set window [_find_drop_target_window $_dodragdrop_drag_source \
                                           $rootx $rooty]
      if {[string length $window]} {
        ## Examine the modifiers to suggest an action...
        set _dodragdrop_default_action [_default_action $event]
        ## Is it a Tk widget?
        # set path [winfo containing $rootx $rooty] 
        # puts "Window under mouse: $window ($path)"
        if {$_dodragdrop_drop_target != $window} {
          ## Send XdndLeave to $_dodragdrop_drop_target
          _SendXdndLeave
          ## Is there a proxy? If not, _find_drop_target_proxy returns the
          ## target window, so we always get a valid "proxy".
          set proxy [_find_drop_target_proxy $_dodragdrop_drag_source $window]
          ## Send XdndEnter to $window
          _SendXdndEnter $window $proxy
          ## Send XdndPosition to $_dodragdrop_drop_target
          _SendXdndPosition $rootx $rooty $_dodragdrop_default_action
        } else {
          ## Send XdndPosition to $_dodragdrop_drop_target
          _SendXdndPosition $rootx $rooty $_dodragdrop_default_action
        }
      } else {
        ## No window under the mouse. Send XdndLeave to $_dodragdrop_drop_target
        _SendXdndLeave
      }
    }
    ButtonPress {
    }
    ButtonRelease {
      variable _dodragdrop_button
      set button [dict get $event button]
      if {$button == $_dodragdrop_button} {
        ## The button that initiated the drag was released. Trigger drop...
        _SendXdndDrop
      }
      return 1
    }
    KeyPress {
    }
    KeyRelease {
      set keysym [dict get $event keysym]
      switch $keysym {
        Escape {
          ## The user has pressed escape. Abort...
          if {$_dragging} {set _dragging 0}
        }
      }
    }
    SelectionRequest {
      variable _dodragdrop_selection_requestor
      variable _dodragdrop_selection_property
      variable _dodragdrop_selection_selection
      variable _dodragdrop_selection_target
      variable _dodragdrop_selection_time
      set _dodragdrop_selection_requestor [dict get $event requestor]
      set _dodragdrop_selection_property  [dict get $event property]
      set _dodragdrop_selection_selection [dict get $event selection]
      set _dodragdrop_selection_target    [dict get $event target]
      set _dodragdrop_selection_time      $time
      return 0
    }
    default {
      return 0
    }
  }
  return 0
};# _process_drag_events

# ----------------------------------------------------------------------------
#  Command xdnd::_SendXdndEnter
# ----------------------------------------------------------------------------
proc xdnd::_SendXdndEnter {window proxy} {
  variable _dodragdrop_drag_source
  variable _dodragdrop_drop_target
  variable _dodragdrop_drop_target_proxy
  variable _dodragdrop_types
  variable _dodragdrop_waiting_status
  variable _dodragdrop_drop_occured
  if {$_dodragdrop_drop_target > 0} _SendXdndLeave
  if {$_dodragdrop_drop_occured} return
  set _dodragdrop_drop_target       $window
  set _dodragdrop_drop_target_proxy $proxy
  set _dodragdrop_waiting_status    0
  if {$_dodragdrop_drop_target < 1} return
  # puts "XdndEnter: $_dodragdrop_drop_target $_dodragdrop_drop_target_proxy"
  _send_XdndEnter $_dodragdrop_drag_source $_dodragdrop_drop_target \
                  $_dodragdrop_drop_target_proxy $_dodragdrop_types
};# xdnd::_SendXdndEnter

# ----------------------------------------------------------------------------
#  Command xdnd::_SendXdndPosition
# ----------------------------------------------------------------------------
proc xdnd::_SendXdndPosition {rootx rooty action} {
  variable _dodragdrop_drag_source
  variable _dodragdrop_drop_target
  if {$_dodragdrop_drop_target < 1} return
  variable _dodragdrop_drop_occured
  if {$_dodragdrop_drop_occured} return
  variable _dodragdrop_drop_target_proxy
  variable _dodragdrop_waiting_status
  ## Arrange a new XdndPosition, to be send periodically...
  variable _dodragdrop_xdnd_position_heartbeat
  catch {after cancel $_dodragdrop_xdnd_position_heartbeat}
  set _dodragdrop_xdnd_position_heartbeat [after 200 \
    [list ::tkdnd::xdnd::_SendXdndPosition $rootx $rooty $action]]
  if {$_dodragdrop_waiting_status} {return}
  # puts "XdndPosition: $_dodragdrop_drop_target $rootx $rooty $action"
  _send_XdndPosition $_dodragdrop_drag_source $_dodragdrop_drop_target \
                     $_dodragdrop_drop_target_proxy $rootx $rooty $action
  set _dodragdrop_waiting_status 1
};# xdnd::_SendXdndPosition

# ----------------------------------------------------------------------------
#  Command xdnd::_HandleXdndStatus
# ----------------------------------------------------------------------------
proc xdnd::_HandleXdndStatus {event} {
  variable _dodragdrop_drop_target
  variable _dodragdrop_waiting_status

  variable _dodragdrop_drop_target_accepts_drop
  variable _dodragdrop_drop_target_accepts_action
  set _dodragdrop_waiting_status 0
  foreach key {target accept want_position action x y w h} {
    set $key [dict get $event $key]
  }
  set _dodragdrop_drop_target_accepts_drop   $accept
  set _dodragdrop_drop_target_accepts_action $action
  if {$_dodragdrop_drop_target < 1} return
  variable _dodragdrop_drop_occured
  if {$_dodragdrop_drop_occured} return
  _update_cursor
  # puts "XdndStatus: $event"
};# xdnd::_HandleXdndStatus

# ----------------------------------------------------------------------------
#  Command xdnd::_HandleXdndFinished
# ----------------------------------------------------------------------------
proc xdnd::_HandleXdndFinished {event} {
  variable _dodragdrop_drop_target
  set _dodragdrop_drop_target 0
  variable _dragging
  if {$_dragging} {set _dragging 0}
  # puts "XdndFinished: $event"
};# xdnd::_HandleXdndFinished

# ----------------------------------------------------------------------------
#  Command xdnd::_SendXdndLeave
# ----------------------------------------------------------------------------
proc xdnd::_SendXdndLeave {} {
  variable _dodragdrop_drag_source
  variable _dodragdrop_drop_target
  if {$_dodragdrop_drop_target < 1} return
  variable _dodragdrop_drop_target_proxy
  # puts "XdndLeave: $_dodragdrop_drop_target"
  _send_XdndLeave $_dodragdrop_drag_source $_dodragdrop_drop_target \
                  $_dodragdrop_drop_target_proxy
  set _dodragdrop_drop_target 0
  variable _dodragdrop_drop_target_accepts_drop
  variable _dodragdrop_drop_target_accepts_action
  set _dodragdrop_drop_target_accepts_drop   0
  set _dodragdrop_drop_target_accepts_action refuse_drop
  variable _dodragdrop_drop_occured
  if {$_dodragdrop_drop_occured} return
  _update_cursor
};# xdnd::_SendXdndLeave

# ----------------------------------------------------------------------------
#  Command xdnd::_SendXdndDrop
# ----------------------------------------------------------------------------
proc xdnd::_SendXdndDrop {} {
  variable _dodragdrop_drag_source
  variable _dodragdrop_drop_target
  if {$_dodragdrop_drop_target < 1} {
    ## The mouse has been released over a widget that does not accept drops.
    _HandleXdndFinished {}
    return
  }
  variable _dodragdrop_drop_occured
  if {$_dodragdrop_drop_occured} {return}
  variable _dodragdrop_drop_target_proxy
  variable _dodragdrop_drop_target_accepts_drop
  variable _dodragdrop_drop_target_accepts_action

  set _dodragdrop_drop_occured 1
  _update_cursor clock

  if {!$_dodragdrop_drop_target_accepts_drop} {
    _SendXdndLeave
    _HandleXdndFinished {}
    return
  }
  # puts "XdndDrop: $_dodragdrop_drop_target"
  variable _dodragdrop_drop_timestamp
  set _dodragdrop_drop_timestamp [_send_XdndDrop \
                 $_dodragdrop_drag_source $_dodragdrop_drop_target \
                 $_dodragdrop_drop_target_proxy]
  set _dodragdrop_drop_target 0
  # puts "XdndDrop: $_dodragdrop_drop_target"
  ## Arrange a timeout for receiving XdndFinished...
  after 10000 [list ::tkdnd::xdnd::_HandleXdndFinished {}]
};# xdnd::_SendXdndDrop

# ----------------------------------------------------------------------------
#  Command xdnd::_update_cursor
# ----------------------------------------------------------------------------
proc xdnd::_update_cursor { {cursor {}}} {
  # puts "_update_cursor $cursor"
  variable _dodragdrop_current_cursor
  variable _dodragdrop_drag_source
  variable _dodragdrop_drop_target_accepts_drop
  variable _dodragdrop_drop_target_accepts_action

  if {![string length $cursor]} {
    set cursor refuse_drop
    if {$_dodragdrop_drop_target_accepts_drop} {
      set cursor $_dodragdrop_drop_target_accepts_action
    }
  }
  if {![string equal $cursor $_dodragdrop_current_cursor]} {
    _set_pointer_cursor $_dodragdrop_drag_source $cursor
    set _dodragdrop_current_cursor $cursor
  }
};# xdnd::_update_cursor

# ----------------------------------------------------------------------------
#  Command xdnd::_default_action
# ----------------------------------------------------------------------------
proc xdnd::_default_action {event} {
  variable _dodragdrop_actions
  variable _dodragdrop_actions_len
  if {$_dodragdrop_actions_len == 1} {return [lindex $_dodragdrop_actions 0]}
  
  set alt     [dict get $event Alt]
  set shift   [dict get $event Shift]
  set control [dict get $event Control]

  if {$shift && $control && [lsearch $_dodragdrop_actions link] != -1} {
    return link
  } elseif {$control && [lsearch $_dodragdrop_actions copy] != -1} {
    return copy
  } elseif {$shift && [lsearch $_dodragdrop_actions move] != -1} {
    return move
  } elseif {$alt && [lsearch $_dodragdrop_actions link] != -1} {
    return link
  }
  return default
};# xdnd::_default_action

# ----------------------------------------------------------------------------
#  Command xdnd::getFormatForType
# ----------------------------------------------------------------------------
proc xdnd::getFormatForType {type} {
  switch -glob [string tolower $type] {
    text/plain\;charset=utf-8 -
    utf8_string               {set format UTF8_STRING}
    text/plain                -
    string                    -
    text                      -
    compound_text             {set format STRING}
    text/uri-list*            {set format UTF8_STRING}
    application/x-color       {set format $type}
    default                   {set format $type}
  }
  return $format
};# xdnd::getFormatForType

# ----------------------------------------------------------------------------
#  Command xdnd::registerSelectionHandler
# ----------------------------------------------------------------------------
proc xdnd::registerSelectionHandler {source types} {
  foreach type $types {
    selection handle -selection XdndSelection \
                     -type $type \
                     -format [getFormatForType $type] \
                     $source [list ::tkdnd::xdnd::_SendData $type]
  }
};# xdnd::registerSelectionHandler

# ----------------------------------------------------------------------------
#  Command xdnd::unregisterSelectionHandler
# ----------------------------------------------------------------------------
proc xdnd::unregisterSelectionHandler {source types} {
  foreach type $types {
    catch {
      selection handle -selection XdndSelection \
                       -type $type \
                       -format [getFormatForType $type] \
                       $source {}
    }
  }
};# xdnd::unregisterSelectionHandler

# ----------------------------------------------------------------------------
#  Command xdnd::_convert_to_unsigned
# ----------------------------------------------------------------------------
proc xdnd::_convert_to_unsigned {data format} {
  switch $format {
    8  { set mask 0xff }
    16 { set mask 0xffff }
    32 { set mask 0xffffff }
    default {error "unsupported format $format"}
  }
  ## Convert signed integer into unsigned...
  set d [list]
  foreach num $data {
    lappend d [expr { $num & $mask }]
  }
  return $d
};# xdnd::_convert_to_unsigned

# ----------------------------------------------------------------------------
#  Command xdnd::_SendData
# ----------------------------------------------------------------------------
proc xdnd::_SendData {type offset bytes args} {
  variable _dodragdrop_drag_source
  variable _dodragdrop_data
  variable _dodragdrop_transfer_data
  set format 8
  if {$offset == 0} {
    ## Prepare the data to be transfered...
    switch -glob $type {
      text/plain* - UTF8_STRING - STRING - TEXT - COMPOUND_TEXT {
        binary scan [encoding convertto utf-8 $_dodragdrop_data] \
                    c* _dodragdrop_transfer_data
        set _dodragdrop_transfer_data \
           [_convert_to_unsigned $_dodragdrop_transfer_data $format]
      }
      text/uri-list* {
        set files [list]
        foreach file $_dodragdrop_data {
          switch -glob $file {
            *://*     {lappend files $file}
            default   {lappend files file://$file}
          }
        }
        binary scan [encoding convertto utf-8 "[join $files \r\n]\r\n"] \
                    c* _dodragdrop_transfer_data
        set _dodragdrop_transfer_data \
           [_convert_to_unsigned $_dodragdrop_transfer_data $format]
      }
      application/x-color {
        set format 16
        ## Try to understand the provided data: we accept a standard Tk colour,
        ## or a list of 3 values (red green blue) or a list of 4 values
        ## (red green blue opacity).
        switch [llength $_dodragdrop_data] {
          1 { set color [winfo rgb $_dodragdrop_drag_source $_dodragdrop_data]
              lappend color 65535 }
          3 { set color $_dodragdrop_data; lappend color 65535 }
          4 { set color $_dodragdrop_data }
          default {error "unknown color data: \"$_dodragdrop_data\""}
        }
        ## Convert the 4 elements into 16 bit values...
        set _dodragdrop_transfer_data [list]
        foreach c $color {
          lappend _dodragdrop_transfer_data [format 0x%04X $c]
        }
      }
      default {
        set format 32
        binary scan $_dodragdrop_data c* _dodragdrop_transfer_data
      }
    }
  }

  ##
  ## Data has been split into bytes. Count the bytes requested, and return them
  ##
  set data [lrange $_dodragdrop_transfer_data $offset [expr {$offset+$bytes-1}]]
  switch $format {
    8  {
      set data [encoding convertfrom utf-8 [binary format c* $data]]
    }
    16 {
      variable _dodragdrop_selection_requestor
      if {$_dodragdrop_selection_requestor} {
        ## Tk selection cannot process this format (only 8 & 32 supported).
        ## Call our XChangeProperty...
        set numItems [llength $data]
        variable _dodragdrop_selection_property
        variable _dodragdrop_selection_selection
        variable _dodragdrop_selection_target
        variable _dodragdrop_selection_time
        XChangeProperty $_dodragdrop_drag_source \
                        $_dodragdrop_selection_requestor \
                        $_dodragdrop_selection_property \
                        $_dodragdrop_selection_target \
                        $format \
                        $_dodragdrop_selection_time \
                        $data $numItems
        return -code break
      }
    }
    32 {
    }
    default {
      error "unsupported format $format"
    }
  }
  # puts "SendData: $type $offset $bytes $args ($_dodragdrop_data)"
  # puts "          $data"
  return $data
};# xdnd::_SendData
blob
data 15146
#
# tkdnd_windows.tcl --
# 
#    This file implements some utility procedures that are used by the TkDND
#    package.
#
# This software is copyrighted by:
# George Petasis, National Centre for Scientific Research "Demokritos",
# Aghia Paraskevi, Athens, Greece.
# e-mail: petasis@iit.demokritos.gr
#
# The following terms apply to all files associated
# with the software unless explicitly disclaimed in individual files.
#
# The authors hereby grant permission to use, copy, modify, distribute,
# and license this software and its documentation for any purpose, provided
# that existing copyright notices are retained in all copies and that this
# notice is included verbatim in any distributions. No written agreement,
# license, or royalty fee is required for any of the authorized uses.
# Modifications to this software may be copyrighted by their authors
# and need not follow the licensing terms described here, provided that
# the new terms are clearly indicated on the first page of each file where
# they apply.
# 
# IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
# FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
# ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
# DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# 
# THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
# IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
# NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
# MODIFICATIONS.
#

namespace eval olednd {
  variable _types {}
  variable _typelist {}
  variable _codelist {}
  variable _actionlist {}
  variable _pressedkeys {}
  variable _action {}
  variable _common_drag_source_types {}
  variable _common_drop_target_types {}
  variable _unhandled_types {}

  variable _last_mouse_root_x 0
  variable _last_mouse_root_y 0
};# namespace olednd

# ----------------------------------------------------------------------------
#  Command olednd::_HandleDragEnter
# ----------------------------------------------------------------------------
proc olednd::_HandleDragEnter { drop_target typelist actionlist pressedkeys
                                rootX rootY codelist } {
  variable _typelist;                 set _typelist    $typelist
  variable _codelist;                 set _codelist    $codelist
  variable _actionlist;               set _actionlist  $actionlist
  variable _pressedkeys;              set _pressedkeys $pressedkeys
  variable _action;                   set _action      {}
  variable _common_drag_source_types; set _common_drag_source_types {}
  variable _common_drop_target_types; set _common_drop_target_types {}

  variable _last_mouse_root_x;        set _last_mouse_root_x $rootX
  variable _last_mouse_root_y;        set _last_mouse_root_y $rootY

  # puts "olednd::_HandleDragEnter: drop_target=$drop_target,\
  #       typelist=$typelist, actionlist=$actionlist,\
  #       pressedkeys=$pressedkeys, rootX=$rootX, rootY=$rootY"
  focus $drop_target

  ## Does the new drop target support any of our new types? 
  variable _types; set _types [bind $drop_target <<DropTargetTypes>>]
  if {[llength $_types]} {
    ## Examine the drop target types, to find at least one match with the drag
    ## source types...
    set supported_types [_supported_types $_typelist]
    foreach type $_types {
      foreach matched [lsearch -glob -all -inline $supported_types $type] {
        ## Drop target supports this type.
        lappend common_drag_source_types $matched
        lappend common_drop_target_types $type
      }
    }
  }

  set _action refuse_drop
  if {[info exists common_drag_source_types]} {
    set _action copy
    set _common_drag_source_types $common_drag_source_types
    set _common_drop_target_types $common_drop_target_types
    ## Drop target supports at least one type. Send a <<DropEnter>>.
    set cmd [bind $drop_target <<DropEnter>>]
    if {[string length $cmd]} {
      set cmd [string map [list %W $drop_target %X $rootX %Y $rootY \
        %CST \{$_common_drag_source_types\} \
        %CTT \{$_common_drop_target_types\} \
        %ST  \{$_typelist\}    %TT \{$_types\} \
        %A   $_action          %a  \{$_actionlist\} \
        %b   \{$_pressedkeys\} %m  \{$_pressedkeys\} \
        %D   \{\}              %e  <<DropEnter>> \
        %L   \{$_typelist\}    %%  % \
        %t   \{$_typelist\}    %T  \{[lindex $_common_drag_source_types 0]\} \
        %c   \{$_codelist\}    %C  \{[lindex $_codelist 0]\} \
        ] $cmd]
      set _action [uplevel \#0 $cmd]
    }
  }
  if {$::tkdnd::_auto_update} {update}
  # Return values: copy, move, link, ask, private, refuse_drop, default
  return $_action
};# olednd::_HandleDragEnter

# ----------------------------------------------------------------------------
#  Command olednd::_HandleDragOver
# ----------------------------------------------------------------------------
proc olednd::_HandleDragOver { drop_target pressedkeys rootX rootY } {
  variable _types
  variable _typelist
  variable _codelist
  variable _actionlist
  variable _pressedkeys
  variable _action
  variable _common_drag_source_types
  variable _common_drop_target_types

  variable _last_mouse_root_x;        set _last_mouse_root_x $rootX
  variable _last_mouse_root_y;        set _last_mouse_root_y $rootY

  # puts "olednd::_HandleDragOver: drop_target=$drop_target,\
  #             pressedkeys=$pressedkeys, rootX=$rootX, rootY=$rootY"

  if {![llength $_common_drag_source_types]} {return refuse_drop}
  set _pressedkeys $pressedkeys
  set cmd [bind $drop_target <<DropPosition>>]
  if {[string length $cmd]} {
    set cmd [string map [list %W $drop_target %X $rootX %Y $rootY \
      %CST \{$_common_drag_source_types\} \
      %CTT \{$_common_drop_target_types\} \
      %ST  \{$_typelist\}    %TT \{$_types\} \
      %A   $_action          %a  \{$_actionlist\} \
      %b   \{$_pressedkeys\} %m  \{$_pressedkeys\} \
      %D   \{\}              %e  <<DropPosition>> \
      %L   \{$_typelist\}    %%  % \
      %t   \{$_typelist\}    %T  \{[lindex $_common_drag_source_types 0]\} \
      %c   \{$_codelist\}    %C  \{[lindex $_codelist 0]\} \
      ] $cmd]
    set _action [uplevel \#0 $cmd]
  }
  if {$::tkdnd::_auto_update} {update}
  # Return values: copy, move, link, ask, private, refuse_drop, default
  return $_action
};# olednd::_HandleDragOver

# ----------------------------------------------------------------------------
#  Command olednd::_HandleDragLeave
# ----------------------------------------------------------------------------
proc olednd::_HandleDragLeave { drop_target } {
  variable _types
  variable _typelist
  variable _codelist
  variable _actionlist
  variable _pressedkeys
  variable _action
  variable _common_drag_source_types
  variable _common_drop_target_types
  variable _last_mouse_root_x
  variable _last_mouse_root_y

  if {![llength $_common_drag_source_types]} {return}
  foreach var {_types _typelist _actionlist _pressedkeys _action
               _common_drag_source_types _common_drop_target_types} {
    set $var {}
  }

  set cmd [bind $drop_target <<DropLeave>>]
  if {[string length $cmd]} {
    set cmd [string map [list %W $drop_target \
      %X $_last_mouse_root_x %Y $_last_mouse_root_y \
      %CST \{$_common_drag_source_types\} \
      %CTT \{$_common_drop_target_types\} \
      %ST  \{$_typelist\}    %TT \{$_types\} \
      %A   \{$_action\}      %a  \{$_actionlist\} \
      %b   \{$_pressedkeys\} %m  \{$_pressedkeys\} \
      %D   \{\}              %e  <<DropLeave>> \
      %L   \{$_typelist\}    %%  % \
      %t   \{$_typelist\}    %T  \{[lindex $_common_drag_source_types 0]\} \
      %u   \{$_codelist\}    %C  \{[lindex $_codelist 0]\} \
      ] $cmd]
    set _action [uplevel \#0 $cmd]
  }
  if {$::tkdnd::_auto_update} {update}
};# olednd::_HandleDragLeave

# ----------------------------------------------------------------------------
#  Command olednd::_HandleXdndDrop
# ----------------------------------------------------------------------------
proc olednd::_HandleDrop { drop_target pressedkeys rootX rootY _type data } {
  variable _types
  variable _typelist
  variable _codelist
  variable _actionlist
  variable _pressedkeys
  variable _action
  variable _common_drag_source_types
  variable _common_drop_target_types
  set data [_normalise_data $_type $data]
  # puts "olednd::_HandleDrop: drop_target=$drop_target,\
  #             pressedkeys=$pressedkeys, rootX=$rootX, rootY=$rootY,\
  #             data=\"$data\""

  if {![llength $_common_drag_source_types]} {return refuse_drop}
  set _pressedkeys $pressedkeys
  ## Try to select the most specific <<Drop>> event.
  foreach type [concat $_common_drag_source_types $_common_drop_target_types] {
    set type [_platform_independent_type $type]
    set cmd [bind $drop_target <<Drop:$type>>]
    if {[string length $cmd]} {
      set cmd [string map [list %W $drop_target %X $rootX %Y $rootY \
        %CST \{$_common_drag_source_types\} \
        %CTT \{$_common_drop_target_types\} \
        %ST  \{$_typelist\}    %TT \{$_types\} \
        %A   $_action          %a \{$_actionlist\} \
        %b   \{$_pressedkeys\} %m \{$_pressedkeys\} \
        %D   [list $data]      %e <<Drop:$type>> \
        %L   \{$_typelist\}    %% % \
        %t   \{$_typelist\}    %T \{[lindex $_common_drag_source_types 0]\} \
        %c   \{$_codelist\}    %C  \{[lindex $_codelist 0]\} \
        ] $cmd]
      return [uplevel \#0 $cmd]
    }
  }
  set cmd [bind $drop_target <<Drop>>]
  if {[string length $cmd]} {
    set cmd [string map [list %W $drop_target %X $rootX %Y $rootY \
      %CST \{$_common_drag_source_types\} \
      %CTT \{$_common_drop_target_types\} \
      %ST  \{$_typelist\}    %TT \{$_types\} \
      %A   $_action          %a \{$_actionlist\} \
      %b   \{$_pressedkeys\} %m \{$_pressedkeys\} \
      %D   [list $data]      %e <<Drop>> \
      %L   \{$_typelist\}    %% % \
      %t   \{$_typelist\}    %T \{[lindex $_common_drag_source_types 0]\} \
      %c   \{$_codelist\}    %C  \{[lindex $_codelist 0]\} \
      ] $cmd]
    set _action [uplevel \#0 $cmd]
  }
  if {$::tkdnd::_auto_update} {update}
  # Return values: copy, move, link, ask, private, refuse_drop
  return $_action
};# olednd::_HandleXdndDrop

# ----------------------------------------------------------------------------
#  Command olednd::_GetDropTypes
# ----------------------------------------------------------------------------
proc olednd::_GetDropTypes { drop_target } {
  variable _common_drag_source_types
  return $_common_drag_source_types
};# olednd::_GetDropTypes

# ----------------------------------------------------------------------------
#  Command olednd::_GetDroppedData
# ----------------------------------------------------------------------------
proc olednd::_GetDroppedData {  } {
  variable _drop_target
  return [selection get -displayof $_drop_target \
                        -selection XdndSelection -type STRING]
};# olednd::_GetDroppedData

# ----------------------------------------------------------------------------
#  Command olednd::_GetDragSource
# ----------------------------------------------------------------------------
proc olednd::_GetDragSource {  } {
  variable _drag_source
  return $_drag_source
};# olednd::_GetDragSource

# ----------------------------------------------------------------------------
#  Command olednd::_GetDropTarget
# ----------------------------------------------------------------------------
proc olednd::_GetDropTarget {  } {
  variable _drop_target
  return [winfo id $_drop_target]
};# olednd::_GetDropTarget

# ----------------------------------------------------------------------------
#  Command olednd::_supported_types
# ----------------------------------------------------------------------------
proc olednd::_supported_types { types } {
  set new_types {}
  foreach type $types {
    if {[_supported_type $type]} {lappend new_types $type}
  }
  return $new_types
}; # olednd::_supported_types

# ----------------------------------------------------------------------------
#  Command olednd::_platform_specific_types
# ----------------------------------------------------------------------------
proc olednd::_platform_specific_types { types } {
  set new_types {}
  foreach type $types {
    set new_types [concat $new_types [_platform_specific_type $type]]
  }
  return $new_types
}; # olednd::_platform_specific_types

# ----------------------------------------------------------------------------
#  Command olednd::_platform_independent_types
# ----------------------------------------------------------------------------
proc olednd::_platform_independent_types { types } {
  set new_types {}
  foreach type $types {
    set new_types [concat $new_types [_platform_independent_type $type]]
  }
  return $new_types
}; # olednd::_platform_independent_types

# ----------------------------------------------------------------------------
#  Command olednd::_normalise_data
# ----------------------------------------------------------------------------
proc olednd::_normalise_data { type data } {
  switch $type {
    CF_HDROP   {return $data}
    DND_Text   {return [list CF_UNICODETEXT CF_TEXT]}
    DND_Files  {return [list CF_HDROP]}
    default    {return $data}
  }
}; # olednd::_normalise_data

# ----------------------------------------------------------------------------
#  Command olednd::_platform_specific_type
# ----------------------------------------------------------------------------
proc olednd::_platform_specific_type { type } {
  switch $type {
    DND_Text   {return [list CF_UNICODETEXT CF_TEXT]}
    DND_Files  {return [list CF_HDROP]}
    default    {
      # variable _unhandled_types
      # if {[lsearch -exact $_unhandled_types $type] == -1} {
      #   lappend _unhandled_types $type
      # }
      return [list $type]}
  }
}; # olednd::_platform_specific_type

# ----------------------------------------------------------------------------
#  Command olednd::_platform_independent_type
# ----------------------------------------------------------------------------
proc olednd::_platform_independent_type { type } {
  switch $type {
    CF_UNICODETEXT - CF_TEXT {return DND_Text}
    CF_HDROP                 {return DND_Files}
    default    {return [list $type]}
  }
}; # olednd::_platform_independent_type

# ----------------------------------------------------------------------------
#  Command olednd::_supported_type
# ----------------------------------------------------------------------------
proc olednd::_supported_type { type } {
  # return 1;
  switch $type {
    CF_UNICODETEXT - CF_TEXT -
    FileGroupDescriptor - FileGroupDescriptorW -
    CF_HDROP {return 1}
  }
  # Is the type in our known, but unhandled types?
  variable _unhandled_types
  if {[lsearch -exact $_unhandled_types $type] != -1} {return 1}
  return 0
}; # olednd::_supported_type
blob
data 2306
This software is copyrighted by:
   Georgios Petasis, Athens, Greece.
   e-mail: petasisg@yahoo.gr, petasis@iit.demokritos.gr

   Mac portions (c) 2009 Kevin Walzer/WordTech Communications LLC,
   kw@codebykevin.com

The following terms apply to all files associated with the
software unless explicitly disclaimed in individual files.

The authors hereby grant permission to use, copy, modify, distribute,
and license this software and its documentation for any purpose, provided
that existing copyright notices are retained in all copies and that this
notice is included verbatim in any distributions. No written agreement,
license, or royalty fee is required for any of the authorized uses.
Modifications to this software may be copyrighted by their authors
and need not follow the licensing terms described here, provided that
the new terms are clearly indicated on the first page of each file where
they apply.

IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
MODIFICATIONS.

GOVERNMENT USE: If you are acquiring this software on behalf of the
U.S. government, the Government shall have only "Restricted Rights"
in the software and related documentation as defined in the Federal 
Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you
are acquiring the software on behalf of the Department of Defense, the
software shall be classified as "Commercial Computer Software" and the
Government shall have only "Restricted Rights" as defined in Clause
252.227-7013 (c) (1) of DFARs.  Notwithstanding the foregoing, the
authors grant the U.S. Government and others acting in its behalf
permission to use and distribute the software in accordance with the
terms specified in this license. 
blob
data 26843
/*
 * macdnd.m --
 *
 *        This module implements drag and drop for Mac OS X.
 *
 * Copyright (c) 2009-2010 Kevin Walzer/WordTech Communications LLC.
 * Copyright (c) 2009-2010 Daniel A. Steffen <das@users.sourceforge.net>
 * Copyright (c) 2009-2010 Georgios P. Petasis <petasis@iit.demokritos.gr>
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 *
 */

#import <tcl.h>
#import <tk.h>
#import <tkInt.h>
#import <tkMacOSXInt.h>
#import <Cocoa/Cocoa.h>

#define TKDND_OSX_KEVIN_WORKARROUND

#define TkDND_Tag    1234

#define TkDND_TkWin(x)                                                  \
  (Tk_NameToWindow(interp, Tcl_GetString(x), Tk_MainWindow(interp)))

#define TkDND_Eval(objc)                                                \
  for (i=0; i<objc; ++i) Tcl_IncrRefCount(objv[i]);                     \
  if (Tcl_EvalObjv(interp, objc, objv, TCL_EVAL_GLOBAL) != TCL_OK)      \
    Tk_BackgroundError(interp);                                         \
  for (i=0; i<objc; ++i) Tcl_DecrRefCount(objv[i]);

#define TkDND_Status_Eval(objc)                                         \
  for (i=0; i<objc; ++i) Tcl_IncrRefCount(objv[i]);                     \
  status = Tcl_EvalObjv(interp, objc, objv, TCL_EVAL_GLOBAL);           \
  if (status != TCL_OK) Tk_BackgroundError(interp);                     \
  for (i=0; i<objc; ++i) Tcl_DecrRefCount(objv[i]);

#ifndef Tk_Interp
/*
 * Tk 8.5 has a new function to return the interpreter that is associated with a
 * window. Under 8.4 and earlier versions, simulate this function.
 */
#import "tkInt.h"
Tcl_Interp * TkDND_Interp(Tk_Window tkwin) {
  if (tkwin != NULL && ((TkWindow *)tkwin)->mainPtr != NULL) {
    return ((TkWindow *)tkwin)->mainPtr->interp;
  }
  return NULL;
}; /* Tk_Interp */
#define Tk_Interp TkDND_Interp
#endif /* Tk_Interp */


/*
 * Here we need to wrap Cocoa methods in Cocoa class: methods for initiating,
 * tracking, and terminating drag from inside and outside the application.
 */

@interface DNDView : NSView {
  NSDragOperation sourceDragMask;
  NSPasteboard   *sourcePasteBoard;
  NSMutableArray *draggedtypes;
  NSInteger       tag;
}

- (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender;
- (BOOL)prepareForDragOperation:(id <NSDraggingInfo>)sender;
- (BOOL)performDragOperation:(id <NSDraggingInfo>)sender;
- (NSDragOperation)draggingUpdated:(id < NSDraggingInfo >)sender;
- (int)draggingSourceOperationMaskForLocal:(BOOL)isLocal;
- (void)setTag:(NSInteger) t;
- (NSInteger)tag;
TkWindow* TkMacOSXGetTkWindow( NSWindow *w);
DNDView*  TkDND_GetDNDSubview(NSView *view, Tk_Window tkwin);
@end

@implementation DNDView

- (void)setTag:(NSInteger) t {
  tag = t;
}; /* setTag */

- (NSInteger)tag {
  return tag;
}; /* tag */

/*
 * Ripped from Tk-Cocoa source code to map Tk window to Cocoa window
 */
TkWindow* TkMacOSXGetTkWindow(NSWindow *w)  {
  Window window = TkMacOSXGetXWindow(w);
  TkDisplay *dispPtr = TkGetDisplayList();

  return (window != None ? (TkWindow *)Tk_IdToWindow(dispPtr->display, window) :
          NULL);
}; /* TkMacOSXGetTkWindow */

/*
 * TkDND_GetDNDSubview: returns the subview of type DNDView.
 * If such a view does not exist in the provided view, a new one is
 * added, and returned.
 */
DNDView* TkDND_GetDNDSubview(NSView *view, Tk_Window tkwin) {
  NSRect frame, bounds;
  DNDView* dnd_view = [view viewWithTag:TkDND_Tag];
#ifdef TKDND_OSX_KEVIN_WORKARROUND
  Rect bnds;
#endif /* TKDND_OSX_KEVIN_WORKARROUND */

  if (dnd_view == nil) {
    dnd_view = [[DNDView alloc] init];
    [dnd_view setTag:TkDND_Tag];
    [dnd_view mouseDown:NULL];
    if ([dnd_view superview] != view) {
      [view addSubview:dnd_view positioned:NSWindowBelow relativeTo:nil];
    }
    [view setAutoresizesSubviews:true];
    /*
     * Bug fix by Kevin Walzer: On 23 Dec 2010, Kevin reported that he has
     * found cases where the code below is needed, in order for DnD to work
     * correctly under Snow Leopard 10.6. So, I am restoring it...
     */
#ifdef TKDND_OSX_KEVIN_WORKARROUND
    /* Hack to make sure subview is set to take up entire geometry of window. */
    TkMacOSXWinBounds((TkWindow*)tkwin, &bnds);
    frame = NSMakeRect(bnds.left, bnds.top, 100000, 100000);
    frame.origin.y = 0;
    if (!NSEqualRects(frame, [dnd_view frame])) {
      [dnd_view setFrame:frame];
    }
#endif /* TKDND_OSX_KEVIN_WORKARROUND */
  }

#ifndef TKDND_OSX_KEVIN_WORKARROUND
  if (dnd_view == nil) return dnd_view;

  /* Ensure that we have the correct geometry... */
  frame = [view frame];
  if (!NSEqualRects(frame, [dnd_view frame])) {
    [dnd_view setFrame:frame];
  }

  bounds = [view bounds];
  if (!NSEqualRects(bounds, [dnd_view bounds])) {
    [dnd_view setBounds:bounds];
  }
#endif /* TKDND_OSX_KEVIN_WORKARROUND */
  return dnd_view;
}; /* TkDND_GetDNDSubview */

/* Set flags for local DND operations, i.e. dragging within a single
   application window.*/
- (int)draggingSourceOperationMaskForLocal:(BOOL)isLocal {
  if (isLocal) return NSDragOperationCopy;
  return NSDragOperationCopy|NSDragOperationMove|NSDragOperationLink;
}

/*******************************************************************************
 *******************************************************************************
 ***** Drop Target Operations                                              *****
 *******************************************************************************
 *******************************************************************************/

/*
 * Standard Cocoa method for entering drop target;
 * Calls tkdnd::macdnd::_HandleEnter
 */
- (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender {
  static char *DropActions[] = {
    "copy", "move", "link", "ask",  "private", "refuse_drop", "default",
    (char *) NULL
  };
  enum dropactions {
    ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate,
    refuse_drop, ActionDefault
  };

  TkWindow *winPtr   = TkMacOSXGetTkWindow([self window]);
  Tk_Window tkwin    = (Tk_Window) winPtr;
  Tcl_Interp *interp = Tk_Interp(tkwin);
  sourcePasteBoard   = [sender draggingPasteboard];

  Tcl_Obj* objv[4], *element, *result;
  int i, index, status;

  objv[0] = Tcl_NewStringObj("tkdnd::macdnd::_HandleEnter", -1);
  objv[1] = Tcl_NewStringObj(Tk_PathName(tkwin), -1);
  objv[2] = Tcl_NewLongObj(0);
  objv[3] = Tcl_NewListObj(0, NULL);
  /*
   * Search for known types...
   */
  if ([[sourcePasteBoard types] containsObject:NSStringPboardType]) {
    element = Tcl_NewStringObj("NSStringPboardType", -1);
    Tcl_ListObjAppendElement(NULL, objv[3], element);
  }
  if ([[sourcePasteBoard types] containsObject:NSFilenamesPboardType]) {
    element = Tcl_NewStringObj("NSFilenamesPboardType", -1);
    Tcl_ListObjAppendElement(NULL, objv[3], element);
  }
  /* Evaluate the command and get the result...*/
  TkDND_Status_Eval(4);
  // printf("Status=%d (%d)\n", status, TCL_OK);fflush(0);
  if (status != TCL_OK) {
    /* An error has happened. Cancel the drop! */
    return NSDragOperationNone;
  }
  /* We have a result: the returned action... */
  result = Tcl_GetObjResult(interp); Tcl_IncrRefCount(result);
  status = Tcl_GetIndexFromObj(interp, result, (const char **) DropActions,
                               "dropactions", 0, &index);
  Tcl_DecrRefCount(result);
  if (status != TCL_OK) index = refuse_drop;
  switch ((enum dropactions) index) {
    case ActionDefault:
    case ActionCopy:
      return NSDragOperationCopy;
    case ActionMove:
      return NSDragOperationMove;
    case ActionAsk:
      return NSDragOperationGeneric;
    case ActionPrivate:
      return NSDragOperationPrivate;
    case ActionLink:
      return NSDragOperationLink;
    case refuse_drop: {
      return NSDragOperationNone; /* Refuse drop. */
    }
  }
  return NSDragOperationNone;
}; /* draggingEntered */

- (NSDragOperation)draggingUpdated:(id < NSDraggingInfo >)sender {
  static char *DropActions[] = {
    "copy", "move", "link", "ask",  "private", "refuse_drop", "default",
    (char *) NULL
  };
  enum dropactions {
    ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate,
    refuse_drop, ActionDefault
  };
  Tk_Window mouse_tkwin;
  NSPoint mouseLoc;

  TkWindow *winPtr   = TkMacOSXGetTkWindow([self window]);
  Tk_Window tkwin    = (Tk_Window) winPtr;
  Tcl_Interp *interp = Tk_Interp(tkwin);
  sourcePasteBoard   = [sender draggingPasteboard];
  /* Get the coordinates of the cursor... */
  mouseLoc = [NSEvent mouseLocation];

  Tcl_Obj* objv[4], *result;
  int i, index, status;

  /*
   * Map the coordinates to the target window: must substract mouseLocation
   * from screen height because Cocoa orients to bottom of screen, Tk to
   * top...
   */
  float rootX = mouseLoc.x;
  float rootY = mouseLoc.y;
  float screenheight = [[[NSScreen screens] objectAtIndex:0] frame].size.height;

  /* Convert Cocoa screen cordinates to Tk coordinates... */
  float tk_Y  = screenheight - rootY;
  mouse_tkwin = Tk_CoordsToWindow(rootX, tk_Y, tkwin);
  if (mouse_tkwin == NULL) return NSDragOperationNone;

  objv[0] = Tcl_NewStringObj("tkdnd::macdnd::_HandlePosition", -1);
  objv[1] = Tcl_NewStringObj(Tk_PathName(mouse_tkwin), -1);
  objv[2] = Tcl_NewIntObj(rootX);
  objv[3] = Tcl_NewIntObj(rootY);

  /* Evaluate the command and get the result...*/
  TkDND_Status_Eval(4);

  //  printf("Status=%d (%d)\n", status, TCL_OK);fflush(0);
  if (status != TCL_OK) {
    /* An error has happened. Cancel the drop! */
    return NSDragOperationNone;
  }
  /* We have a result: the returned action... */
  result = Tcl_GetObjResult(interp); Tcl_IncrRefCount(result);
  status = Tcl_GetIndexFromObj(interp, result, (const char **) DropActions,
                               "dropactions", 0, &index);
  Tcl_DecrRefCount(result);
  if (status != TCL_OK) index = refuse_drop;
  switch ((enum dropactions) index) {
    case ActionDefault:
    case ActionCopy:
      return NSDragOperationCopy;
    case ActionMove:
      return NSDragOperationMove;
    case ActionAsk:
      return NSDragOperationGeneric;
    case ActionPrivate:
      return NSDragOperationPrivate;
    case ActionLink:
      return NSDragOperationLink;
    case refuse_drop: {
      return NSDragOperationNone; /* Refuse drop. */
    }
  }
  return NSDragOperationNone;
}; /* draggingUpdated */

//prepare to perform drag operation
- (BOOL)prepareForDragOperation:(id <NSDraggingInfo>)sender {
  sourcePasteBoard = [sender draggingPasteboard];
  return YES;
}; /* prepareForDragOperation */

/*
 * Standard Cocoa method for handling drop operation
 * Calls tkdnd::macdnd::_HandleDrop
 */
- (BOOL)performDragOperation:(id <NSDraggingInfo>)sender {
  static char *DropActions[] = {
    "copy", "move", "link", "ask",  "private", "refuse_drop", "default", "",
    (char *) NULL
  };
  enum dropactions {
    ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate,
    refuse_drop, ActionDefault, NoReturnedAction
  };
  TkWindow *winPtr   = TkMacOSXGetTkWindow([self window]);
  Tk_Window tkwin    = (Tk_Window) winPtr;
  Tcl_Interp *interp = Tk_Interp(tkwin);
  sourcePasteBoard   = [sender draggingPasteboard];
  Tcl_Obj *data      = NULL;

  /* Retrieve string data from clipboard... */
  NSArray    *types           = [sourcePasteBoard types];
  NSString   *pasteboardvalue = nil;
  for (NSString *type in types) {
    if ([type isEqualToString:NSStringPboardType]) {
      /* String type... */
      pasteboardvalue = [sourcePasteBoard stringForType:NSStringPboardType];
      data = Tcl_NewStringObj([pasteboardvalue UTF8String], -1);
    } else if ([type isEqualToString:NSFilenamesPboardType]) {
      Tcl_Obj *element;
      data = Tcl_NewListObj(0, NULL);
      /* File array... */
      NSArray *files =
        [sourcePasteBoard propertyListForType:NSFilenamesPboardType];
      for (NSString *filename in files) {
        element = Tcl_NewStringObj([filename UTF8String], -1);
        if (element == NULL) continue;
        Tcl_IncrRefCount(element);
        Tcl_ListObjAppendElement(interp, data, element);
        Tcl_DecrRefCount(element);
      }
    }
  }
  if (data == NULL) data = Tcl_NewStringObj(NULL, 0);

  Tcl_Obj* objv[3], *result;
  int i, index, status;

  objv[0] = Tcl_NewStringObj("tkdnd::macdnd::_HandleDrop", -1);
  objv[1] = Tcl_NewStringObj(Tk_PathName(tkwin), -1);
  objv[2] = data;

  /* Evaluate the command and get the result...*/
  TkDND_Status_Eval(3);
  //  printf("Status=%d (%d)\n", status, TCL_OK);fflush(0);
  if (status != TCL_OK) {
    /* An error has happened. Cancel the drop! */
    return NO;
  }
  /* We have a result: the returned action... */
  result = Tcl_GetObjResult(interp); Tcl_IncrRefCount(result);
  status = Tcl_GetIndexFromObj(interp, result, (const char **) DropActions,
                               "dropactions", 0, &index);
  Tcl_DecrRefCount(result);
  if (status != TCL_OK) index = NoReturnedAction;
  switch ((enum dropactions) index) {
    case NoReturnedAction:
    case ActionDefault:
    case ActionCopy:
    case ActionMove:
    case ActionAsk:
    case ActionPrivate:
    case ActionLink:
      return YES;
    case refuse_drop: {
      return NO; /* Refuse drop. */
    }
  }
  return YES;
}; /* performDragOperation */

/*
 * Standard Cocoa method for handling drop operation
 * Calls tkdnd::macdnd::_HandleXdndDrop
 */
- (void)draggingExited:(id < NSDraggingInfo >)sender {
  TkWindow *winPtr   = TkMacOSXGetTkWindow([self window]);
  Tk_Window tkwin    = (Tk_Window) winPtr;
  Tcl_Interp *interp = Tk_Interp(tkwin);
  sourcePasteBoard   = [sender draggingPasteboard];

  Tcl_Obj* objv[4];
  int i;

  objv[0] = Tcl_NewStringObj("tkdnd::macdnd::_HandleLeave", -1);
  objv[1] = Tcl_NewStringObj(Tk_PathName(tkwin), -1);
  objv[2] = Tcl_NewLongObj(0);
  objv[3] = Tcl_NewListObj(0, NULL);

  /* Evaluate the command and get the result...*/
  TkDND_Eval(4);
}; /* draggingExited */

@end

/*
 * End Cocoa class methods: now we begin Tcl functions calling the class methods
 */

/******************************************************************************
 ******************************************************************************
 ***** Drag Source Operations                                             *****
 ******************************************************************************
 ******************************************************************************/

/*
 * Implements drag source in Tk windows
 */
int TkDND_DoDragDropObjCmd(ClientData clientData, Tcl_Interp *interp,
                           int objc, Tcl_Obj *CONST objv[]) {
  Tcl_Obj         **elem;
  int               actions = 0;
  int               status, elem_nu, i, index;
  Tk_Window         path;
  Drawable          d;
  NSView           *view;
  DNDView          *dragview;
  NSImage          *dragicon = NULL;
  static char *DropTypes[] = {
    "NSStringPboardType", "NSFilenamesPboardType",
    (char *) NULL
  };
  enum droptypes {
    TYPE_NSStringPboardType, TYPE_NSFilenamesPboardType
  };
  static char *DropActions[] = {
    "copy", "move", "link", "ask",  "private", "refuse_drop",
    "default",
    (char *) NULL
  };
  enum dropactions {
    ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate,
    refuse_drop, ActionDefault
  };
  bool added_string = false, added_filenames = false, perform_drag = false;

  if (objc != 5) {
    Tcl_WrongNumArgs(interp, 1, objv, "path actions types data");
    return TCL_ERROR;
  }
  Tcl_ResetResult(interp);

  /* Process drag actions. */
  status = Tcl_ListObjGetElements(interp, objv[2], &elem_nu, &elem);
  if (status != TCL_OK) return status;
  for (i = 0; i < elem_nu; i++) {
    status = Tcl_GetIndexFromObj(interp, elem[i], (const char **)DropActions,
                                 "dropactions", 0, &index);
    if (status != TCL_OK) return status;
    switch ((enum dropactions) index) {
      case ActionCopy:    actions |= NSDragOperationCopy;    break;
      case ActionMove:    actions |= NSDragOperationMove;    break;
      case ActionLink:    actions |= NSDragOperationLink;    break;
      case ActionAsk:     actions |= NSDragOperationGeneric; break;
      case ActionPrivate: actions |= NSDragOperationPrivate; break;
      case ActionDefault: /* not supported */;               break;
      case refuse_drop:   /* not supported */;               break;
    }
  }

  /* Get the object that holds this Tk Window... */
  path = Tk_NameToWindow(interp, Tcl_GetString(objv[1]), Tk_MainWindow(interp));
  if (path == NULL) return TCL_ERROR;
  d = Tk_WindowId(path);
  if (d == None) return TCL_ERROR;
  /* Get the NSView from Tk window and add subview to serve as drag source */
  view     = TkMacOSXGetRootControl(d);
  if (view == NULL) return TCL_ERROR;
  /* Get the DNDview for this view... */
  dragview = TkDND_GetDNDSubview(view, path);
  if (dragview == NULL) return TCL_ERROR;

  /* Process drag types. */
  status = Tcl_ListObjGetElements(interp, objv[3], &elem_nu, &elem);
  if (status != TCL_OK) return status;

  /* Initialize array of drag types... */
  NSMutableArray *draggedtypes=[[NSMutableArray alloc] init];
  /* Iterate over all data, to collect the types... */
  for (i = 0; i < elem_nu; i++) {
    status = Tcl_GetIndexFromObj(interp, elem[i], (const char **) DropTypes,
                                 "dropactions", 0, &index);
    if (status != TCL_OK) continue;
    switch ((enum droptypes) index) {
      case TYPE_NSStringPboardType: {
        if (!added_string) {
          [draggedtypes addObject: NSStringPboardType];
          added_string = true;
          perform_drag = true;
        }
        break;
      }
      case TYPE_NSFilenamesPboardType: {
        if (!added_filenames) {
          [draggedtypes addObject: NSFilenamesPboardType];
          added_filenames = true;
          perform_drag    = true;
        }
        break;
      }
    }
  }

  if (!perform_drag) {
    /* No need to start a drag, the clipboard will be empty... */
    Tcl_SetResult(interp, "refuse_drop", TCL_STATIC);
    return TCL_OK;
  }

  /*
   * Get pasteboard. Make sure it is NSDragPboard; this will make data available
   * to drop targets via [sender draggingPasteboard]
   */
  NSPasteboard *dragpasteboard = [NSPasteboard pasteboardWithName:NSDragPboard];
  [dragpasteboard declareTypes:draggedtypes owner:dragview];

  /*
   * We need an icon for the drag:
   * Interate over data types to process dragged data and display
   * the correct drag icon.
   */
  for (i = 0; i < elem_nu; i++) {
    status = Tcl_GetIndexFromObj(interp, elem[i], (const char **) DropTypes,
                                 "dropactions", 0, &index);
    if (status == TCL_OK) {
      switch ((enum droptypes) index) {
        case TYPE_NSStringPboardType: {
          /* Place the string into the clipboard. */
          NSString *datastring =
             [NSString stringWithUTF8String:Tcl_GetString(objv[4])];
            [dragpasteboard setString:datastring forType:NSStringPboardType];

          /* Create a custom icon: draw dragged string into drag icon,
           * make sure icon is large enough to contain several lines of text */
          if (dragicon == NULL) {
            dragicon = [[NSImage alloc]
              initWithSize:NSMakeSize(Tk_Width(path), Tk_Height(path))];
            [dragicon lockFocus];
            [[NSColor clearColor] set];
            NSRectFill(NSMakeRect(0, 0, 1000,1000));
            [datastring drawAtPoint: NSZeroPoint withAttributes: nil];
            [dragicon unlockFocus];
          }
          break;
        }
        case TYPE_NSFilenamesPboardType: {
          NSMutableArray *filelist = [[NSMutableArray alloc] init];

          /* Place the filenames into the clipboard. */
          status = Tcl_ListObjGetElements(interp, objv[4], &elem_nu, &elem);
          if ( status == TCL_OK) {
            for (i = 0; i < elem_nu; i++) {
              /* Get string value of file name from list */
              char* filename = Tcl_GetString(elem[i]);
              /* Convert file names to NSSString, add to NSMutableArray,
               * and set pasteboard type */
              NSString *filestring = [NSString stringWithUTF8String:filename];
              [filelist addObject: filestring];
            }
          }
          /* This successfully writes the file path data to the clipboard,
           * and it is available to other non-Tk applications... */
          [dragpasteboard setPropertyList:filelist
                                  forType:NSFilenamesPboardType];

          /* Set the correct icon depending on whether a single file
           * [iconForFileType] or multiple files [NSImageNameMultipleDocuments]
           * have been placed into the clipboard... */
          if (dragicon == NULL) {
            if ([filelist count] == 1) {
              NSString *pathtype = [[filelist objectAtIndex:0] pathExtension];
              dragicon = [[NSWorkspace sharedWorkspace] 
                                       iconForFileType:pathtype];
            } else {
              dragicon = [NSImage imageNamed:NSImageNameMultipleDocuments];
            }
          }
          break;
        }
      }
    } else {
      /* An unknown (or user defined) type. Silently skip it... */
    }
  }

  /* Do drag & drop... */

  /* Ensure that we always have a drag icon. If not, use a default one... */
  if (dragicon == NULL) {
    dragicon = [NSImage imageNamed:NSImageNameIconViewTemplate];
  }

  NSSize dragOffset = NSMakeSize(0.0, 0.0);

  /* Get the mouse coordinates, so as the icon can slide back at the correct
   * location, if the drag is cancelled. */
  NSPoint global         = [NSEvent mouseLocation];
  NSPoint imageLocation  = [[dragview window] convertScreenToBase:global];
  NSEvent *event = [NSEvent mouseEventWithType:NSLeftMouseDragged
                                      location:imageLocation
                                 modifierFlags:NSLeftMouseDownMask
                                     timestamp:0
                                  windowNumber:[[dragview window] windowNumber]
                                       context:NULL
                                   eventNumber:0
                                    clickCount:0
                                      pressure:0];

  /* Initiate the drag operation... */
  [dragview dragImage:dragicon
                   at:imageLocation
               offset:dragOffset
                event:event
           pasteboard:dragpasteboard
               source:dragview
            slideBack:YES];

  /* Get the drop action... */

  /* There is no way we can know the drag action! */
  Tcl_SetResult(interp, "copy", TCL_STATIC);
  return TCL_OK;
}; /* TkDND_DoDragDropObjCmd */

/*
 * Register: add a Cocoa subview to serve as drop target;
 *           register dragged data types
 */
int TkDND_RegisterDragWidgetObjCmd(ClientData clientData, Tcl_Interp *ip,
                                   int objc, Tcl_Obj *CONST objv[]) {
  Tcl_Obj **type;
  int typec, i, len;
  char *str;
  bool added_string = false, added_filenames = false;

  if (objc != 3) {
    Tcl_WrongNumArgs(ip, 1, objv, "path types-list");
    return TCL_ERROR;
  }

  /*
   * Get the list of desired drop target types...
   */
  if (Tcl_ListObjGetElements(ip, objv[2], &typec, &type) != TCL_OK) {
    return TCL_ERROR;
  }

  /* Get window information for drop target... */
  Tk_Window path;
  path = Tk_NameToWindow(ip, Tcl_GetString(objv[1]), Tk_MainWindow(ip));
  if (path == NULL) return TCL_ERROR;

  Tk_MakeWindowExist(path);
  Tk_MapWindow(path);
  Drawable d = Tk_WindowId(path);

  /* Get NSView from Tk window and add subview to serve as drop target */
  NSView  *view = TkMacOSXGetRootControl(d);
  DNDView *dropview  = TkDND_GetDNDSubview(view, path);
  if (dropview == NULL) return TCL_ERROR;

  /* Initialize array of drag types */
  NSMutableArray *draggedtypes=[[NSMutableArray alloc] init];

  /*
   * Iterate over all requested types...
   */
  for (i = 0; i < typec; ++i) {
    str = Tcl_GetStringFromObj(type[i], &len);
    if (strncmp(str, "*", len) == 0) {
      /* A request for all available types... */
      if (!added_string) {
        [draggedtypes addObject: NSStringPboardType];
        added_string = true;
      }
      if (!added_filenames) {
        [draggedtypes addObject: NSFilenamesPboardType];
        added_filenames = true;
      }
    } else if (strncmp(str, "NSStringPboardType", len) == 0) {
      if (!added_string) {
        [draggedtypes addObject: NSStringPboardType];
        added_string = true;
      }
    } else if (strncmp(str, "NSFilenamesPboardType", len) == 0) {
      if (!added_filenames) {
        [draggedtypes addObject: NSFilenamesPboardType];
        added_filenames = true;
      }
    } else {
      /* Do what? Raise an error or silently ignore the unknown type? */
    }
  }

  /* Finally, register the drag types... */
  [dropview registerForDraggedTypes:draggedtypes];

  return TCL_OK;
}; /* TkDND_RegisterDragWidgetObjCmd */

/* Unregister the drag widget */
int TkDND_UnregisterDragWidgetObjCmd(ClientData clientData, Tcl_Interp *ip,
                                     int objc, Tcl_Obj *CONST objv[]) {
  if (objc != 2) {
    Tcl_WrongNumArgs(ip, 1, objv, "path");
    return TCL_ERROR;
  }

  /* Get NSView from TK window... */
  Tk_Window path = Tk_NameToWindow(ip, Tcl_GetString(objv[1]),
                                       Tk_MainWindow(ip));

  if (path == NULL) return TCL_ERROR;

  Drawable d         = Tk_WindowId(path);
  NSView  *view      = TkMacOSXGetRootControl(d);
  DNDView *dropview  = TkDND_GetDNDSubview(view, path);
  if (dropview == NULL) return TCL_ERROR;
  [dropview unregisterDraggedTypes];

  return TCL_OK;
}; /* TkDND_UnregisterDragWidgetObjCmd */

/*
 * Initalize the package in the tcl interpreter, create tcl commands...
 */
int Tkdnd_Init (Tcl_Interp *interp) {

  if (Tcl_InitStubs(interp, "8.5", 0) == NULL) {
    return TCL_ERROR;
  }

  if (Tk_InitStubs(interp, "8.5", 0) == NULL) {
    return TCL_ERROR;
  }

  Tcl_CreateObjCommand(interp, "::macdnd::registerdragwidget",
                       TkDND_RegisterDragWidgetObjCmd,
                       (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);
  Tcl_CreateObjCommand(interp, "::macdnd::unregisterdragwidget",
                       TkDND_UnregisterDragWidgetObjCmd,
                       (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);
  Tcl_CreateObjCommand(interp, "::macdnd::dodragdrop",
                       TkDND_DoDragDropObjCmd,
                       (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL);

  if (Tcl_PkgProvide(interp, PACKAGE_NAME, PACKAGE_VERSION) != TCL_OK) {
    return TCL_ERROR;
  }

  return TCL_OK;
}; /* Tkdnd_Init */

int Tkdnd_SafeInit(Tcl_Interp *ip) {
  return Tkdnd_Init(ip);
}; /* Tkdnd_SafeInit */
blob
data 207
#
# Tcl package index file
#
set libfile [file join "@libdir@" @target_LIBNAME@]
package ifneeded tkdnd @PKG_VERSION@ \
  "source [file join $dir tkdnd.tcl] ; \
   tkdnd::initialise \{$dir\} $libfile tkdnd"
blob
data 34259
2012-04-03  Jan Nijtmans  <nijtmans@users.sf.net>

	* tcl.m4: [Bug 3511806] Compiler checks too early
	This change allows to build the cygwin and mingw32 ports of
	Tcl/Tk extensions to build out-of-the-box using a native or
	cross-compiler.

2011-04-02  Jan Nijtmans  <nijtmans@users.sf.net>

	* install-sh: Fix issue with library stripping in install-sh
	 (backported from kevin_walzer's patch from Tcl 8.6 trunk)

2011-04-05  Andreas Kupries  <andreask@activestate.com>

	* tcl.m4: Applied patch by Jeff Lawson. Nicer error message when
	  tclConfig.sh was not found.

2010-12-15  Stuart Cassoff  <stwo@users.sourceforge.net>

	* install-sh: Upgrade to newer install-sh and use it.
	* tcl.m4:

2010-12-14  Stuart Cassoff  <stwo@users.sourceforge.net>

	* tcl.m4: Better building on OpenBSD.

2010-12-14  Jan Nijtmans  <nijtmans@users.sf.net>

	* tcl.m4: when using gcc, don't try to determine Win64 SDK

2010-12-12  Jan Nijtmans  <nijtmans@users.sf.net>

	* tcl.m4: Determine correctly a cross-compiler-windres

2010-11-23  Jan Nijtmans  <nijtmans@users.sf.net>

	* tcl.m4: add some cross-compile support, borrowed from Tcl 8.6

2010-09-16  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: correct HP-UX LDFLAGS (only used when building big shell)

2010-09-14  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: add extra if check for .manifest file generation
	Add notice about package name and version being built.

2010-09-09  Jan Nijtmans  <nijtmans@users.sf.net>

	* tcl.m4: [FREQ #3058486] TEA_LOAD_CONFIG doesn't set all BUILD_ vars
	Slightly related: defining BUILD_$1 on all platforms - not only win -
	allows the -fvisibility feature to be used in extensions as well, at
	least if you compile against tcl >= 8.5.

2010-08-26  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: ensure safe quoting for autoheader usage

2010-08-19  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: add TEA_ADD_CLEANFILES macro to make adding cleanfiles
	easier, and add *.exp to CLEANFILES Windows default.
	(TEA_MAKE_LIB): Enhanced to check for MSVC that requires manifests
	and auto-embed it into proj DLL via MAKE_SHARED_LIB.  Also define
	VC_MANIFEST_EMBED_DLL and VC_MANIFEST_EMBED_EXE that do the same
	magic in case it is needed for extended TEA projects.

2010-08-16  Jeff Hobbs  <jeffh@ActiveState.com>

	*** Bump to TEA_VERSION 3.9 ***
	If upgrading from TEA_VERSION 3.8, copy over tcl.m4, change
	TEA_INIT to use 3.9 and reconfigure (ac-2.59+).
	BUILD_${PACKAGE_NAME} will be auto-defined on Windows for
	correct setting of TCL_STORAGE_CLASS.
	TEA_LOAD_CONFIG users should remove the SHLIB_LD_LIBS setting done
	in configure.in (LIBS will be automagically populated by
	TEA_LOAD_CONFIG).
	TEA_EXPORT_CONFIG has been added for ${pkg}Config.sh creators
	SHLIB_LD_FLAGS was deprecated a while ago, remove it if it is
	still in your Makefile.in.

	* tcl.m4: add /usr/lib64 to set of auto-search dirs. [Bug 1230554]
	Auto-define BUILD_$PACKAGE_NAME so users don't need to.  This
	needs to correspond with $pkg.h define magic for TCL_STORAGE_CLASS.
	Auto-define CLEANFILES.  Users can expand it.
	(SHLIB_LD_LIBS): define to '${LIBS}' default and change it only if
	necessary.  Platforms not using this may simply not work or have
	very funky linkers.
	(TEA_LOAD_CONFIG): When loading config for another extension,
	auto-add stub libraries found with TEA_ADD_LIBS.  Eases
	configure.in for modules like itk and img::*.
	(TEA_EXPORT_CONFIG): Add standardized function for exporting a
	${pkg}Config.sh.  See use by img::* and itcl.

2010-08-12  Jeff Hobbs  <jeffh@ActiveState.com>

	*** Bump to TEA_VERSION 3.8 ***
	If upgrading from TEA_VERSION 3.7, copy over tcl.m4, change
	TEA_INIT to use 3.8 and reconfigure (ac-2.59+).
	No other changes should be necessary.

	* tcl.m4: remove more vestigial bits from removed platforms.
	Add back SCO_SV-3.2*.
	Remove use of DL_LIBS and DL_OBJS and related baggage - these are
	only needed by the core to support 'load'.
	Allow for macosx in TEA_ADD_SOURCES.
	Correct check for found_xincludes=no in TEA_PATH_UNIX_X.

2010-08-11  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: remove the following old platform configurations:
	UNIX_SV*|UnixWare-5*, SunOS-4.*, SINIX*5.4*, SCO_SV-3.2*<readded>,
	OSF1-1.*, NEXTSTEP-*, NetBSD-1.*|FreeBSD-[[1-2]].*, MP-RAS-*,
	IRIX-5.*, HP-UX-*.08.*|HP-UX-*.09.*|HP-UX-*.10.*, dgux*,
	BSD/OS-2.1*|BSD/OS-3*
	(AIX): drop AIX-pre4 support and use of ldAix, use -bexpall/-brtl

2010-07-05  Jan Nijtmans  <nijtmans@users.sf.net>

	* tcl.m4: [Patch #1055668] removal of exported internals from
	tclInt.h (EXTERN macro)

2010-04-14  Jan Nijtmans  <nijtmans@users.sf.net>

	* tcl.m4    - Backport a lot of quoting fixes from tcl8.6/unix/tcl.m4
	            - Fix determination of CYGPATH for CYGWIN
	  With those fixes, itcl and tdbc compile fine with CYGWIN

2010-04-06  Jan Nijtmans  <nijtmans@users.sf.net>

	* install-sh         [Bug 2982540] configure and install* script files
	                     should always have LF

2010-02-19  Stuart Cassoff  <stwo@users.sourceforge.net>

	* tcl.m4: Correct compiler/linker flags for threaded builds on
	OpenBSD.

2010-01-19  Jan Nijtmans  <nijtmans@users.sf.net>

	* tcl.m4: Detect CYGWIN variant: win32 or unix

2010-01-03  Donal K. Fellows  <dkf@users.sf.net>

	* unix/tcl.m4 (TEA_CONFIG_CFLAGS): [Tcl Bug 1636685]: Use the
	configuration for modern FreeBSD suggested by the FreeBSD porter.

2009-10-22  Jan Nijtmans  <nijtmans@users.sf.net>

	* tcl.m4: [Tcl Patch #2883533] tcl.m4 support for Haiku OS

2009-04-27  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_CONFIG_CFLAGS): harden the check to add _r to CC on
	AIX with threads.

2009-04-10  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): check for 64-bit TkAqua.

2009-03-26  Jan Nijtmans  <nijtmans@users.sf.net>

	* tclconfig/tcl.m4: Adapt LDFLAGS and LD_SEARCH_FLAGS
	together with SHLIB_LD definition to unbreak building on HPUX.

2009-03-20  Andreas Kupries  <andreask@activestate.com>

	* tclconfig/tcl.m4: Changed SHLIB_LD definition to unbreak
	building on HPUX.

2009-03-16  Joe English  <jenglish@users.sourceforge.net>

	* tcl.m4(TEA_PUBLIC_TK_HEADERS): Look at ${TK_INCLUDE_SPEC}
	(found in tkConfig.sh) when trying to guess where tk.h might be
	[Patch 1960628].

2009-03-11  Joe English  <jenglish@users.sourceforge.net>

	* tcl.m4: Allow ${SHLIB_SUFFIX} to be overridden at
	configure-time [Patch 1960628].  Also fix some comment typos,
	and an uninitialized variable bug-waiting-to-happen.

2008-12-21  Jan Nijtmans  <nijtmans@users.sf.net>

	* tcl.m4: [Bug 2073255] Tcl_GetString(NULL) doesn't crash on HP-UX
	          (this bug report was for Tcl, but holds for TEA as well.)

2008-12-20  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4: sync with tdbc tcl.m4 changes
	(SunOS-5.11): Sun cc SHLIB_LD: use LDFLAGS_DEFAULT instead of LDFLAGS

2008-12-02  Jeff Hobbs  <jeffh@ActiveState.com>

	*** Bump to TEA_VERSION 3.7 ***

	* tcl.m4: in private header check, check for <plat>Port.h instead
	of Int.h to ensure all private headers are available.

2008-11-04  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): sync TEA_PRIVATE_TK_HEADERS handling of
	Tk.framework PrivateHeaders with TEA_PRIVATE_TCL_HEADERS.

2008-11-04  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_PATH_TCLCONFIG, TEA_PATH_TKCONFIG): exit with error
	when tclConfig.sh cannot be found. [Bug #1997760]
	(TEA_PRIVATE_TCL_HEADERS, TEA_PRIVATE_TK_HEADERS): allow for
	finding the headers installed in the public areas, e.g. a result of
	make install-private-headers. [Bug #1631922]

2008-08-12  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): link shlib with current and compatiblity version
	flags; look for libX11.dylib when searching for X11 libraries.

2008-06-12  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (SunOS-5.11): fix 64bit amd64 support with gcc & Sun cc.

2008-03-27  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (SunOS-5.1x): fix 64bit support for Sun cc. [Bug 1921166]

2008-02-01  Donal K. Fellows  <donal.k.fellows@man.ac.uk>

	* tcl.m4 (TEA_CONFIG_CFLAGS): Updated to work at least in part with
	more modern VC versions. Currently just made the linker flags more
	flexible; more work may be needed.

2007-10-26  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): add support for 64-bit X11.

2007-10-23  Jeff Hobbs  <jeffh@ActiveState.com>

	*** Tagged tea-3-branch to start TEA 4 development on HEAD ***

2007-09-17  Joe English  <jenglish@users.sourceforge.net>

	* tcl.m4: use '${CC} -shared' instead of 'ld -Bshareable'
	to build shared libraries on current NetBSDs [Bug 1749251].

2007-09-15  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4: 	replace all direct references to compiler by ${CC} to
			enable CC overriding at configure & make time.
	(SunOS-5.1x):	replace direct use of '/usr/ccs/bin/ld' in SHLIB_LD by
			'cc' compiler driver.

2007-08-08  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: check Ttk dir for Tk private headers (8.5).
	Add some comments to other bits.

2007-06-25  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_PROG_TCLSH, TEA_PROG_WISH): move where / is added.

2007-06-13  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: fix --with-tkinclude alignment. [Bug 1506111]

2007-06-06  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): fix 64bit arch removal in fat 32&64bit builds.

2007-05-18  Donal K. Fellows  <donal.k.fellows@man.ac.uk>

	* tcl.m4: Added quoting so that paths with spaces cause fewer
	problems.

2007-03-07  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): s/CFLAGS/CPPFLAGS/ in -mmacosx-version-min check.

2007-02-15  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: correct private header check to search in generic subdir

2007-02-09  Jeff Hobbs  <jeffh@ActiveState.com>

	*** Bump to TEA_VERSION 3.6 ***

	* tcl.m4: correct -d to -f
	(TEA_CONFIG_CFLAGS): SHLIB_SUFFIX is .so on HP ia64 [Bug 1615058]

2007-02-08  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_PRIVATE_TCL_HEADERS, TEA_PRIVATE_TK_HEADERS): check
	that the dirs actually have private headers. [Bug 1631922]

2007-02-04  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4: add caching to -pipe check.

2007-01-25  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4: integrate CPPFLAGS into CFLAGS as late as possible and
	move (rather than duplicate) -isysroot flags from CFLAGS to CPPFLAGS to
	avoid errors about multiple -isysroot flags from some older gcc builds.

2006-01-19  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4: ensure CPPFLAGS env var is used when set. [Bug 1586861]
	(Darwin): add -isysroot and -mmacosx-version-min flags to CPPFLAGS when
	present in CFLAGS to avoid discrepancies between what headers configure
	sees during preprocessing tests and compiling tests.

2006-12-19  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): --enable-64bit: verify linking with 64bit -arch flag
	succeeds before enabling 64bit build.

2006-12-16  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Linux): fix previous change to use makefile variable
	LDFLAGS_DEFAULT instead of LDFLAGS in SHLIB_LD, to ensure linker
	flags in sampleextension Makefile are picked up.

2006-11-26  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Linux): --enable-64bit support. [Patch 1597389], [Bug 1230558]

2006-08-18  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): add support for --enable-64bit on x86_64, for
	universal builds including x86_64 and for use of -mmacosx-version-min
	instead of MACOSX_DEPLOYMENT_TARGET. For Tk extensions, remove 64-bit
	arch flags from CFLAGS like in the Tk configure, as neither TkAqua nor
	TkX11 can be built for 64-bit at present.

2006-03-28  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: []-quote AC_DEFUN functions.
	(TEA_PATH_TKCONFIG): Fixed Windows-specific check for tkConfig.sh.
	(TEA_MAKE_LIB): Prepend 'lib' for Windows-gcc configs.

2006-03-07  Joe English  <jenglish@users.sourceforge.net>

	* tcl.m4: Set SHLIB_LD_FLAGS='${LIBS}' on NetBSD,
	as per the other *BSD variants [Bug 1334613].

2006-01-25  Jeff Hobbs  <jeffh@ActiveState.com>

	*** Bump to TEA version 3.5 ***

	* tcl.m4: keep LD_SEARCH_FLAGS and CC_SEARCH_FLAGS synchronous
	with core tcl.m4 meaning.

2006-01-24  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): use makefile variable LDFLAGS_DEFAULT instead of
	LDFLAGS in SHLIB_LD, to ensure linker flags in sampleextension Makefile
	are picked up. [Bug 1403343]

2006-01-23  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: add C:/Tcl/lib and C:/Progra~1/Tcl/lib dirs to check for
	*Config.sh on Windows. [Bug 1407544]

2006-01-23  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): for Tk extensions, remove -arch ppc64 from CFLAGS
	like in the Tk configure, as neither TkAqua nor TkX11 can be built for
	64bit at present (no 64bit GUI libraries).

2006-01-22  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: restore system=windows on Windows.
	Remove error if 'ar' isn't found (it may not be on Windows).
	Do not add -lxnet or define _XOPEN_SOURCE on HP-UX by default.
	Ensure the C|LDFLAGS_DEFAULT gets the fully sub'd value at
	configure time.

2006-01-10  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4: add caching, use AC_CACHE_CHECK instead of AC_CACHE_VAL
	where possible, consistent message quoting, sync relevant
	tcl/unix/tcl.m4 HEAD changes and gratuitous formatting differences
	(notably sunc removal of support for for ancient BSD's, IRIX 4,
	RISCos and Ultrix by kennykb), Darwin improvements to
	TEA_LOAD_*CONFIG to make linking work against Tcl/Tk frameworks
	installed in arbitrary location, change TEA_PROG_* search order
	(look in *_BIN_DIR parents before *_PREFIX).

2006-01-05  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: add dkf's system config refactor

2006-01-04  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: remove extraneous ' that causes bash 3.1 to choke

2005-12-19  Joe English  <jenglish@users.sourceforge.net>

	* tcl.m4 (TEA_PATH_TCLCONFIG &c): Look for tclConfig.sh &c
	in ${libdir}, where they are installed by default [Patch #1377407].

2005-12-05  Don Porter  <dgp@users.sf.net>

	* tcl.m4 (TEA_PUBLIC_*_HEADERS):	Better support for finding
	header files for uninstalled Tcl and Tk.

2005-12-02  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: correctly bump TEA_VERSION var to 3.4

2005-12-01  Daniel Steffen  <das@users.sourceforge.net>

	* unix/tcl.m4 (Darwin): fixed error when MACOSX_DEPLOYMENT_TARGET unset

2005-11-29  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4:  *** Bump to TEA version 3.4 ***
	Add Windows x64 build support.
	Remove TEA_PATH_NOSPACE and handle the problem with ""s where
	necessary - the macro relied on TCLSH_PROG which didn't work for
	cross-compiles.

2005-11-27  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): add 64bit support, add CFLAGS to SHLIB_LD to
	support passing -isysroot in env(CFLAGS) to configure (flag can't
	be present twice, so can't be in both CFLAGS and LDFLAGS during
	configure), don't use -prebind when deploying on 10.4.
	(TEA_ENABLE_LANGINFO, TEA_TIME_HANDLER): add/fix caching.

2005-10-30  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4: fixed two tests for TEA_WINDOWINGSYSTEM = "aqua" that
	should have been for `uname -s` = "Darwin" instead; added some
	missing quoting.
	(TEA_PROG_TCLSH, TEA_PROG_WISH): fix incorrect assumption that
	install location of tclConfig.sh/tkConfig.sh allows to determine
	the tclsh/wish install dir via ../bin. Indeed tcl/tk can be
	configured with arbitrary --libdir and --bindir (independent of
	prefix) and such a configuration is in fact standard with Darwin
	framework builds. At least now also check ${TCL_PREFIX}/bin
	resp. ${TK_PREFIX}/bin for presence of tclsh resp. wish (if tcl/tk
	have been configured with arbitrary --bindir, this will still not
	find them, for a general solution *Config.sh would need to contain
	the values of bindir/libdir/includedir passed to configure).

2005-10-07  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: Fix Solaris 5.10 check and Solaris AMD64 64-bit builds.

2005-10-04  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_PRIVATE_TCL_HEADERS): add / to finish sed macro
	(TEA_ENABLE_THREADS): don't check for pthread_attr_setstacksize func

2005-09-13  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: *** Update to TEA version 3.3 ***
	define TEA_WINDOWINGSYSTEM in TEA_LOAD_TKCONFIG.
	Make --enable-threads the default (users can --disable-threads).
	Improve AIX ${CC}_r fix to better check existing ${CC} value.
	Do the appropriate evals to not require the *TOP_DIR_NATIVE vars
	be set for extensions that use private headers.
	Make aqua check for Xlib compat headers the same as win32.

2005-07-26  Mo DeJong  <mdejong@users.sourceforge.net>

	* tcl.m4 (TEA_PROG_TCLSH, TEA_BUILD_TCLSH,
	TEA_PROG_WISH, TEA_BUILD_WISH): Remove
	TEA_BUILD_TCLSH and TEA_BUILD_WISH because
	of complaints that it broke the build when
	only an installed version of Tcl was available
	at extension build time. The TEA_PROG_TCLSH and
	TEA_PROG_WISH macros will no longer search the
	path at all. The build tclsh or installed
	tclsh shell will now be found by TEA_PROG_TCLSH.

2005-07-24  Mo DeJong  <mdejong@users.sourceforge.net>

	* tcl.m4 (TEA_PROG_TCLSH, TEA_BUILD_TCLSH,
	TEA_PROG_WISH, TEA_BUILD_WISH):
	Split confused search for tclsh on PATH and
	build and install locations into two macros.
	TEA_PROG_TCLSH and TEA_PROG_WISH search the
	system PATH for an installed tclsh or wish.
	The TEA_BUILD_TCLSH and TEA_BUILD_WISH
	macros determine the name of tclsh or
	wish in the Tcl or Tk build directory even
	if tclsh or wish has not yet been built.
	[Tcl bug 1160114]
	[Tcl patch 1244153]

2005-06-23  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (TEA_PRIVATE_TK_HEADERS): add ${TK_SRC_DIR}/macosx to
	TK_INCLUDES when building against TkAqua.

	* tcl.m4 (TEA_PATH_X): fixed missing comma in AC_DEFINE

	* tcl.m4: changes to better support framework builds of Tcl and Tk out
	of the box: search framework install locations for *Config.sh, and if in
	presence of a framework build, use the framework's Headers and
	PrivateHeaders directories for public and private includes. [FR 947735]

2005-06-18  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): add -headerpad_max_install_names to LDFLAGS to
	ensure we can always relocate binaries with install_name_tool.

2005-06-04  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (TEA_PATH_X): for TEA_WINDOWINGSYSTEM == aqua, check if xlib
	compat headers are available in tkheaders location, otherwise add xlib
	sourcedir to TK_XINCLUDES.

2005-04-25  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4: added AC_DEFINE* descriptions (from core tcl.m4) to allow
	use with autoheader.
	(Darwin): added configure checks for recently added linker flags
	-single_module and -search_paths_first to allow building with older
	tools (and on Mac OS X 10.1), use -single_module in SHLIB_LD.
	(TEA_MISSING_POSIX_HEADERS): added caching of dirent.h check.
	(TEA_BUGGY_STRTOD): added caching (sync with core tcl.m4).

2005-03-24  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_TCL_64BIT_FLAGS): use Tcl header defaults for wide
	int type only on Windows when __int64 is detected as valid.

2005-03-24  Don Porter  <dgp@users.sf.net>

	* README.txt:	Update reference to "SC_* macros" to "TEA_* macros".
	* tcl.m4:	Incorporated recent improvements in SC_PATH_TCLCONFIG
	and SC_PATH_TKCONFIG into TEA_PATH_TCLCONFIG and TEA_PATH_TKCONFIG.
	Corrected search path in TEA_PATH_CONFIG and added
	AC_SUBST($1_BIN_DIR) to TEA_LOAD_CONFIG so that packages that load
	the configuration of another package can know where they loaded
	it from.

2005-03-18  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_CONFIG_CFLAGS): correct 2005-03-17 change to have
	variant LD_SEARCH_FLAGS for gcc and cc builds.

	* tcl.m4 (TEA_PROG_TCLSH, TEA_PROG_WISH): correct x-compile check.

2005-03-17  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: Correct gcc build and HP-UX-11.

2005-02-08  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_ADD_LIBS): don't touch lib args starting with -.
	(TEA_CONFIG_CFLAGS): only define _DLL for CE in shared build.
	(TEA_MAKE_LIB): set RANLIB* to : on Windows (it's not needed).

2005-02-01  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: redo of 2005-01-27 changes to correctly handle paths
	with spaces.  Win/CE and Win/64 builds now require a prebuilt
	tclsh to handle conversion to short pathnames.  This is done in
	the new TEA_PATH_NOSPACE macro.  For Win/CE|64, make CC just the
	compiler and move the necessary includes to CFLAGS.
	(TEA_CONFIG_CFLAGS): Add Solaris 64-bit gcc build support.
	(TEA_PROG_TCLSH, TEA_PROG_WISH): Allow TCLSH_PROG and WISH_PROG to
	be set in the env and prevent resetting.
	(TEA_ADD_LIBS): On Windows using GCC (mingw), convert foo.lib
	args to -lfoo, for use with mingw.
		*** POTENTIAL INCOMPATABILITY ***
	(TEA_CONFIG_CFLAGS): Fix AIX gcc builds to work out-of-box.
	Bumped TEA to 3.2.

2005-01-27  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: remove cygpath calls to support msys.
	Update base CE build assumption to "420,ARMV4,ARM,Pocket PC 2003".
	Make STLIB_LD use $LINKBIN -lib.

2005-01-25  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (Darwin): fixed bug with static build linking to dynamic
	library in /usr/lib etc instead of linking to static library earlier
	in search path. [Tcl Bug 956908]
	Removed obsolete references to Rhapsody.

2004-12-29  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: Updates for VC7 compatibility, fixing CFLAGS and LDFLAGS
	options, using better default -O levels. [Bug 1092952, 1091967]

2004-12-29  Joe English  <jenglish@users.sourceforge.net>

	* tcl.m4: Do not use ${DBGX} suffix when building
	shared libraries [patch #1081595, TIP #34]

2004-09-07  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_CONFIG_CFLAGS): support eVC4 Win/CE builds

2004-08-10  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_INIT, TEA_PREFIX): update handling of exec_prefix to
	work around subdir configures since autoconf only propagates the
	prefix (not exec_prefix).

2004-07-23  Daniel Steffen  <das@users.sourceforge.net>

	* tcl.m4 (TEA_CONFIG_CFLAGS): Darwin section: brought inline with
	Tcl 8.5 HEAD config, removed core specific & obsolete settings.

2004-07-22  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_PATH_X): check in TK_DEFS for MAC_OSX_TK to see if
	we are compiling on Aqua.  Add TEA_WINDOWINGSYSTEM var that
	reflects 'tk windowingsystem' value.

2004-07-16  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_ENABLE_THREADS): force a threaded build when
	building against a threaded core.
	(CFLAGS_WARNING): Remove -Wconversion for gcc builds
	(TEA_CONFIG_CFLAGS): Reorder configure.in for better 64-bit build
	configuration, replacing EXTRA_CFLAGS with CFLAGS.  [Bug #874058]
	Update to latest Tcl 8.5 head config settings.
	Call this TEA version 3.1.

2004-04-29  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_TCL_64BIT_FLAGS): replace AC_TRY_RUN test with
	AC_TRY_COMPILE for the long vs. long long check. (kenny)

2004-04-26  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_TCL_64BIT_FLAGS): update against core tcl.m4 to
	define TCL_WIDE_INT_IS_LONG if 'using long'.

2004-03-19  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: correct Windows builds getting LDFLAGS info in MAKE_LIB

2004-02-11  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: correct TCL_INCLUDES for private headers on Windows - it
	doesn't need the eval.

2004-02-10  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: don't require TK_INCLUDES and TCL_INCLUDES to have the
	DIR_NATIVE vars defined when using private headers on unix.
	Allow $... to TEA_ADD_SOURCES for constructs like
	TEA_ADD_SOURCES([\$(WIN_OBJECTS)]), that allow the developer to
	place more in the Makefile.in.
	tkUnixPort.h checks for HAVE_LIMITS_H, so do both HAVE and
	CHECK on limits.h

2003-12-10  Jeff Hobbs  <jeffh@ActiveState.com>

	* Makefile.in:      added TEA_ADD_LIBS, TEA_ADD_INCLUDES and
	* configure:        TEA_ADD_CFLAGS to configurable parameters with
	* configure.in:     PKG_* equivs in the Makefile.  This allows the
	* tclconfig/tcl.m4: user to worry less about actual magic VAR names.
	Corrected Makefile.in to note that TEA_ADD_TCL_SOURCES requires
	exact file names.

2003-12-09  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: updated OpenBSD support based on [Patch #775246] (cassoff)

2003-12-05  Jeff Hobbs  <jeffh@ActiveState.com>

	* configure:
	* configure.in:
	* Makefile.in (VPATH): readd $(srcdir) to front of VPATH as the
	first part of VPATH can get chopped off.
	Change .c.$(OBJEXT) rule to .c.@OBJEXT@ to support more makes.
	* tclconfig/tcl.m4: add TEA_ADD_STUB_SOURCES to support libstub
	generation and TEA_ADD_TCL_SOURCES to replace RUNTIME_SOURCES as
	the way the user specifies library files.

2003-12-03  Jeff Hobbs  <jeffh@ActiveState.com>

	* configure:           Update of TEA spec to (hopefully) simplify
	* configure.in:        some aspects of TEA by making use of more
	* Makefile.in:         AC 2.5x features.  Use PACKAGE_NAME (instead
	* generic/tclsample.c: of PACKAGE) and PACKAGE_VERSION (instead of
	* tclconfig/tcl.m4:    VERSION) arguments to AC_INIT as the TEA
	package name and version.
	Provide a version argument to TEA_INIT - starting with 3.0.
	Drop all use of interior shell substs that older makefiles didn't
	like.  Use PKG_* naming convention instead.
	Move specification of source files and public headers into
	configure.in with TEA_ADD_SOURCES and TEA_ADD_HEADERS.  These will
	be munged during ./configure into the right obj file names (no
	$(SOURCES:.c=.obj) needed).
	There is almost nothing that should be touched in Makefile.in now
	for the developer.  May want to add a TEA_ADD_TCL_SOURCES for the
	RUNTIME_SOURCES that remains.
	Use SHLID_LD_FLAGS (instead of SHLID_LDFLAGS) as Tcl does.
	Only specify the user requested LDFLAGS/CFLAGS in the Makefile,
	don't mention the _OPTIMIZE/_DEBUG variants.

2003-10-15  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: create a TEA_SETUP_COMPILER_CC the precedes the
	TEA_SETUP_COMPILER macro.  They are split so the check for CC
	occurs before any use of CC.  Also add AC_PROG_CPP to the compiler
	checks.

2003-10-06  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: Updated for autoconf 2.5x prereq.
	Where TCL_WIDE_INT_TYPE would be __int64, defer to the code checks
	in tcl.h, which also handles TCL_LL_MODIFIER* properly.

2003-04-22  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: correct default setting of ARCH for WinCE builds.
	Correct \ escaping for CE sed macros.

2003-04-10  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: replace $(syscal) construct with older `syscall` for
	systems where sh != bash.

2003-04-09  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_WITH_CELIB): add --enable-wince and --with-celib
	options for Windows/CE compilation support.  Requires the
	Microsoft eMbedded SDK and Keuchel's celib emulation layer.

2003-02-18  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_ENABLE_THREADS): Make sure -lpthread gets passed on
	the link line when checking for the pthread_attr_setstacksize
	symbol. (dejong)

	* tcl.m4 (TEA_SETUP_COMPILER): added default calls to
	TEA_TCL_EARLY_FLAGS, TEA_TCL_64BIT_FLAGS,
	TEA_MISSING_POSIX_HEADERS and TEA_BUGGY_STRTOD.

2003-02-14  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: correct HP-UX ia64 --enable-64bit build flags

2003-01-29  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: check $prefix/lib as well as $exec_prefix/lib when
	looking for tcl|tkConfig.sh, as this check is done before we would
	set exec_prefix when the user does not define it.

2003-01-21  Mo DeJong  <mdejong@users.sourceforge.net>

	* tcl.m4 (TEA_CONFIG_CFLAGS): Fix build support
	for mingw, the previous implementation would
	use VC++ when compiling with mingw gcc. Don't
	pass -fPIC since gcc always compiles pic code
	under win32. Change some hard coded cases
	of gcc to ${CC}.

2002-10-15  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: move the CFLAGS definition from TEA_ENABLE_SHARED to
	TEA_MAKE_LIB because setting too early confuses other AC_* macros.
	Correct the HP-11 SHLIB_LD_LIBS setting.

	* tcl.m4: add the CFLAGS definition into TEA_ENABLE_SHARED and
	make it pick up the env CFLAGS at configure time.

2002-10-09  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: add --enable-symbols=mem option to enable TCL_MEM_DEBUG.
	Improved AIX 64-bit build support, allow it on AIX-4 as well.
	Enable 64-bit HP-11 compilation with gcc.
	Enable 64-bit IRIX64-6 cc build support.
	Correct FreeBSD thread library linkage.
	Add OSF1 static build support.
	Improve SunOS-5 shared build SHLIB_LD macro.

2002-07-20  Zoran Vasiljevic  <zoran@archiware.com>

	* tcl.m4: Added MINGW32 to list of systems checked for Windows build.
	Also, fixes some indentation issues with "--with-XXX" options.

2002-04-23  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_ENABLE_THREADS): added USE_THREAD_ALLOC define to
	use new threaded allocatory by default on Unix for Tcl 8.4.
	(TEA_CONFIG_CFLAGS): corrected LD_SEARCH_FLAGS for FreeBSD-3+.

2002-04-22  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4 (TEA_SETUP_COMPILER): removed call to AC_CYGWIN so that
	we can use autoconf 2.5x as well as 2.13.  This prevents us from
	being able to warn against the use of cygwin gcc at configure
	time, but allows autoconf 2.5x, which is what is shipped with most
	newer systems.

2002-04-11  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: Enabled COFF as well as CV style debug info with
	--enable-symbols to allow Dr. Watson users to see function info.
	More info on debugging levels can be obtained at:
	http://msdn.microsoft.com/library/en-us/dnvc60/html/gendepdebug.asp

2002-04-03  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: change all SC_* macros to TEA_*.  The SC_ was for
	Scriptics, which is no more.  TEA represents a better, independent
	prefix that won't need changing.
	Added preliminary mingw gcc support. [Patch #538772]
	Added TEA_PREFIX macro that handles defaulting the prefix and
	exec_prefix vars to those used by Tcl if none were specified.
	Added TEA_SETUP_COMPILER macro that encompasses the AC_PROG_CC
	check and several other basic AC_PROG checks needed for making
	executables.  This greatly simplifies user's configure.in files.
	Collapsed AIX-5 defines into AIX-* with extra checks for doing the
	ELF stuff on AIX-5-ia64.
	Updated TEA_ENABLE_THREADS to take an optional arg to allow
	switching it on by default (for Thread) and add sanity checking to
	warn the user if configuring threads incompatibly.

2002-03-29  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: made sure that SHLIB_LDFLAGS was set to LDFLAGS_DEFAULT.
	Removed --enable-64bit support for AIX-4 because it wasn't correct.
	Added -MT or -MD Windows linker switches to properly support
	symbols-enabled builds.

2002-03-28  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: called AC_MSG_ERROR when SC_TEA_INIT wasn't called first
	instead of calling it as that inlines it each time in shell code.
	Changed Windows CFLAGS_OPTIMIZE to use -O2 instead of -Oti.
	Noted TCL_LIB_VERSIONS_OK=nodots for Windows builds.
	A few changes to support itcl (and perhaps others):
	Added support for making your own stub libraries to SC_MAKE_LIB.
	New SC_PATH_CONFIG and SC_LOAD_CONFIG that take a package name arg
	and find that ${pkg}Config.sh file.  itk uses this for itcl.

2002-03-27  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: made SC_LOAD_TKCONFIG recognize when working with a Tk
	build dir setup.
	Added EXTRA_CFLAGS and SHLIB_LD_LIBS substs to SC_CONFIG_CFLAGS.
	Added XLIBSW onto LIBS when it is defined.
	Remove TCL_LIBS from MAKE_LIB and correctly use SHLIB_LD_LIBS
	instead to not rely as much on tclConfig.sh cached info.
	Add TK_BIN_DIR to paths to find wish in SC_PROG_WISH.
	These move towards making TEA much more independent of *Config.sh.

2002-03-19  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: corrected forgotten (UN)SHARED_LIB_SUFFIX and
	SHLIB_SUFFIX defines for Win.
	(SC_PATH_X): made this only do the check on unix platforms.

2002-03-12  Jeff Hobbs  <jeffh@ActiveState.com>

	* README.txt: updated to reflect fewer files

2002-03-06  Jeff Hobbs  <jeffh@ActiveState.com>

	* config.guess (removed):
	* config.sub (removed): removed unnecessary files

	* installFile.tcl (removed):
	* mkinstalldirs (removed): these aren't really necessary for
	making TEA work

	* tcl.m4 (SC_PUBLIC_TCL_HEADERS, SC_PUBLIC_TK_HEADERS): don't
	check /usr(/local)/include for includes on Windows when not using
	gcc

2002-03-05  Jeff Hobbs  <jeffh@ActiveState.com>

	* tcl.m4: added warnings on Windows, removed RELPATH define and
	added TCL_LIBS to MAKE_LIB macro.

	This import represents 2.0.0, or a new start at attempting to
	make TEA much easier for C extension developers.

	**** moved from tclpro project to core tcl project, ****
	**** renamed to 'tclconfig'                         ****

2001-03-15    Karl Lehenbauer <karl@procplace.com>

	* installFile.tcl: Added updating of the modification time of
	  the target file whether we overwrote it or decided that it
	  hadn't changed.  This was necessary for us to be able to
	  determine whether or not a module install touched the file.

2001-03-08    Karl Lehenbauer <karl@procplace.com>

	* installFile.tcl: Added support for converting new-style (1.1+)
	  Cygnus drive paths to Tcl-style.

2001-01-15    <brent.welch@interwoven.com>

	* tcl.m4: Added FreeBSD clause.

2001-01-03    <brent.welch@interwoven.com>

	* tcl.m4: Fixed typo in SC_LIB_SPEC where it is checking
	for exec-prefix.

2000-12-01    <brent.welch@interwoven.com>

	* tcl.m4: Concatenated most of the Ajuba acsite.m4 file
	so we don't need to modify the autoconf installation.
	* config.guess:
	* config.sub:
	* installFile.tcl:
	Added files from the itcl config subdirectory,
	which should go away.

2000-7-29    <welch@ajubasolutions.com>

	* Fixed the use of TCL_SRC_DIR and TK_SRC_DIR within
	TCL_PRIVATE_INCLUDES and TK_PRIVATE_INCLUDES to match their recent
	change from $(srcdir) to $(srcdir)/..
blob
data 812
These files comprise the basic building blocks for a Tcl Extension
Architecture (TEA) extension.  For more information on TEA see:

	http://www.tcl.tk/doc/tea/

This package is part of the Tcl project at SourceForge, and latest
sources should be available there:

	http://tcl.sourceforge.net/

This package is a freely available open source package.  You can do
virtually anything you like with it, such as modifying it, redistributing
it, and selling it either in whole or in part.

CONTENTS
========
The following is a short description of the files you will find in
the sample extension.

README.txt	This file

install-sh	Program used for copying binaries and script files
		to their install locations.

tcl.m4		Collection of Tcl autoconf macros.  Included by a package's
		aclocal.m4 to define TEA_* macros.
blob
data 13870
#!/bin/sh
# install - install a program, script, or datafile

scriptversion=2011-04-20.01; # UTC

# This originates from X11R5 (mit/util/scripts/install.sh), which was
# later released in X11R6 (xc/config/util/install.sh) with the
# following copyright and license.
#
# Copyright (C) 1994 X Consortium
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name of the X Consortium shall not
# be used in advertising or otherwise to promote the sale, use or other deal-
# ings in this Software without prior written authorization from the X Consor-
# tium.
#
#
# FSF changes to this file are in the public domain.
#
# Calling this script install-sh is preferred over install.sh, to prevent
# `make' implicit rules from creating a file called install from it
# when there is no Makefile.
#
# This script is compatible with the BSD install script, but was written
# from scratch.

nl='
'
IFS=" ""	$nl"

# set DOITPROG to echo to test this script

# Don't use :- since 4.3BSD and earlier shells don't like it.
doit=${DOITPROG-}
if test -z "$doit"; then
  doit_exec=exec
else
  doit_exec=$doit
fi

# Put in absolute file names if you don't have them in your path;
# or use environment vars.

chgrpprog=${CHGRPPROG-chgrp}
chmodprog=${CHMODPROG-chmod}
chownprog=${CHOWNPROG-chown}
cmpprog=${CMPPROG-cmp}
cpprog=${CPPROG-cp}
mkdirprog=${MKDIRPROG-mkdir}
mvprog=${MVPROG-mv}
rmprog=${RMPROG-rm}
stripprog=${STRIPPROG-strip}

posix_glob='?'
initialize_posix_glob='
  test "$posix_glob" != "?" || {
    if (set -f) 2>/dev/null; then
      posix_glob=
    else
      posix_glob=:
    fi
  }
'

posix_mkdir=

# Desired mode of installed file.
mode=0755

chgrpcmd=
chmodcmd=$chmodprog
chowncmd=
mvcmd=$mvprog
rmcmd="$rmprog -f"
stripcmd=

src=
dst=
dir_arg=
dst_arg=

copy_on_change=false
no_target_directory=

usage="\
Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
   or: $0 [OPTION]... SRCFILES... DIRECTORY
   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
   or: $0 [OPTION]... -d DIRECTORIES...

In the 1st form, copy SRCFILE to DSTFILE.
In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
In the 4th, create DIRECTORIES.

Options:
     --help     display this help and exit.
     --version  display version info and exit.

  -c            (ignored)
  -C            install only if different (preserve the last data modification time)
  -d            create directories instead of installing files.
  -g GROUP      $chgrpprog installed files to GROUP.
  -m MODE       $chmodprog installed files to MODE.
  -o USER       $chownprog installed files to USER.
  -s            $stripprog installed files.
  -S            $stripprog installed files.
  -t DIRECTORY  install into DIRECTORY.
  -T            report an error if DSTFILE is a directory.

Environment variables override the default commands:
  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
  RMPROG STRIPPROG
"

while test $# -ne 0; do
  case $1 in
    -c) ;;

    -C) copy_on_change=true;;

    -d) dir_arg=true;;

    -g) chgrpcmd="$chgrpprog $2"
	shift;;

    --help) echo "$usage"; exit $?;;

    -m) mode=$2
	case $mode in
	  *' '* | *'	'* | *'
'*	  | *'*'* | *'?'* | *'['*)
	    echo "$0: invalid mode: $mode" >&2
	    exit 1;;
	esac
	shift;;

    -o) chowncmd="$chownprog $2"
	shift;;

    -s) stripcmd=$stripprog;;

    -S) stripcmd="$stripprog $2" 
	shift;; 

    -t) dst_arg=$2
	shift;;

    -T) no_target_directory=true;;

    --version) echo "$0 $scriptversion"; exit $?;;

    --)	shift
	break;;

    -*)	echo "$0: invalid option: $1" >&2
	exit 1;;

    *)  break;;
  esac
  shift
done

if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
  # When -d is used, all remaining arguments are directories to create.
  # When -t is used, the destination is already specified.
  # Otherwise, the last argument is the destination.  Remove it from $@.
  for arg
  do
    if test -n "$dst_arg"; then
      # $@ is not empty: it contains at least $arg.
      set fnord "$@" "$dst_arg"
      shift # fnord
    fi
    shift # arg
    dst_arg=$arg
  done
fi

if test $# -eq 0; then
  if test -z "$dir_arg"; then
    echo "$0: no input file specified." >&2
    exit 1
  fi
  # It's OK to call `install-sh -d' without argument.
  # This can happen when creating conditional directories.
  exit 0
fi

if test -z "$dir_arg"; then
  do_exit='(exit $ret); exit $ret'
  trap "ret=129; $do_exit" 1
  trap "ret=130; $do_exit" 2
  trap "ret=141; $do_exit" 13
  trap "ret=143; $do_exit" 15

  # Set umask so as not to create temps with too-generous modes.
  # However, 'strip' requires both read and write access to temps.
  case $mode in
    # Optimize common cases.
    *644) cp_umask=133;;
    *755) cp_umask=22;;

    *[0-7])
      if test -z "$stripcmd"; then
	u_plus_rw=
      else
	u_plus_rw='% 200'
      fi
      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
    *)
      if test -z "$stripcmd"; then
	u_plus_rw=
      else
	u_plus_rw=,u+rw
      fi
      cp_umask=$mode$u_plus_rw;;
  esac
fi

for src
do
  # Protect names starting with `-'.
  case $src in
    -*) src=./$src;;
  esac

  if test -n "$dir_arg"; then
    dst=$src
    dstdir=$dst
    test -d "$dstdir"
    dstdir_status=$?
  else

    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
    # might cause directories to be created, which would be especially bad
    # if $src (and thus $dsttmp) contains '*'.
    if test ! -f "$src" && test ! -d "$src"; then
      echo "$0: $src does not exist." >&2
      exit 1
    fi

    if test -z "$dst_arg"; then
      echo "$0: no destination specified." >&2
      exit 1
    fi

    dst=$dst_arg
    # Protect names starting with `-'.
    case $dst in
      -*) dst=./$dst;;
    esac

    # If destination is a directory, append the input filename; won't work
    # if double slashes aren't ignored.
    if test -d "$dst"; then
      if test -n "$no_target_directory"; then
	echo "$0: $dst_arg: Is a directory" >&2
	exit 1
      fi
      dstdir=$dst
      dst=$dstdir/`basename "$src"`
      dstdir_status=0
    else
      # Prefer dirname, but fall back on a substitute if dirname fails.
      dstdir=`
	(dirname "$dst") 2>/dev/null ||
	expr X"$dst" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	     X"$dst" : 'X\(//\)[^/]' \| \
	     X"$dst" : 'X\(//\)$' \| \
	     X"$dst" : 'X\(/\)' \| . 2>/dev/null ||
	echo X"$dst" |
	    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
		   s//\1/
		   q
		 }
		 /^X\(\/\/\)[^/].*/{
		   s//\1/
		   q
		 }
		 /^X\(\/\/\)$/{
		   s//\1/
		   q
		 }
		 /^X\(\/\).*/{
		   s//\1/
		   q
		 }
		 s/.*/./; q'
      `

      test -d "$dstdir"
      dstdir_status=$?
    fi
  fi

  obsolete_mkdir_used=false

  if test $dstdir_status != 0; then
    case $posix_mkdir in
      '')
	# Create intermediate dirs using mode 755 as modified by the umask.
	# This is like FreeBSD 'install' as of 1997-10-28.
	umask=`umask`
	case $stripcmd.$umask in
	  # Optimize common cases.
	  *[2367][2367]) mkdir_umask=$umask;;
	  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;

	  *[0-7])
	    mkdir_umask=`expr $umask + 22 \
	      - $umask % 100 % 40 + $umask % 20 \
	      - $umask % 10 % 4 + $umask % 2
	    `;;
	  *) mkdir_umask=$umask,go-w;;
	esac

	# With -d, create the new directory with the user-specified mode.
	# Otherwise, rely on $mkdir_umask.
	if test -n "$dir_arg"; then
	  mkdir_mode=-m$mode
	else
	  mkdir_mode=
	fi

	posix_mkdir=false
	case $umask in
	  *[123567][0-7][0-7])
	    # POSIX mkdir -p sets u+wx bits regardless of umask, which
	    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
	    ;;
	  *)
	    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
	    trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0

	    if (umask $mkdir_umask &&
		exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
	    then
	      if test -z "$dir_arg" || {
		   # Check for POSIX incompatibilities with -m.
		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
		   # other-writeable bit of parent directory when it shouldn't.
		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
		   case $ls_ld_tmpdir in
		     d????-?r-*) different_mode=700;;
		     d????-?--*) different_mode=755;;
		     *) false;;
		   esac &&
		   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
		     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
		     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
		   }
		 }
	      then posix_mkdir=:
	      fi
	      rmdir "$tmpdir/d" "$tmpdir"
	    else
	      # Remove any dirs left behind by ancient mkdir implementations.
	      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
	    fi
	    trap '' 0;;
	esac;;
    esac

    if
      $posix_mkdir && (
	umask $mkdir_umask &&
	$doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
      )
    then :
    else

      # The umask is ridiculous, or mkdir does not conform to POSIX,
      # or it failed possibly due to a race condition.  Create the
      # directory the slow way, step by step, checking for races as we go.

      case $dstdir in
	/*) prefix='/';;
	-*) prefix='./';;
	*)  prefix='';;
      esac

      eval "$initialize_posix_glob"

      oIFS=$IFS
      IFS=/
      $posix_glob set -f
      set fnord $dstdir
      shift
      $posix_glob set +f
      IFS=$oIFS

      prefixes=

      for d
      do
	test -z "$d" && continue

	prefix=$prefix$d
	if test -d "$prefix"; then
	  prefixes=
	else
	  if $posix_mkdir; then
	    (umask=$mkdir_umask &&
	     $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
	    # Don't fail if two instances are running concurrently.
	    test -d "$prefix" || exit 1
	  else
	    case $prefix in
	      *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
	      *) qprefix=$prefix;;
	    esac
	    prefixes="$prefixes '$qprefix'"
	  fi
	fi
	prefix=$prefix/
      done

      if test -n "$prefixes"; then
	# Don't fail if two instances are running concurrently.
	(umask $mkdir_umask &&
	 eval "\$doit_exec \$mkdirprog $prefixes") ||
	  test -d "$dstdir" || exit 1
	obsolete_mkdir_used=true
      fi
    fi
  fi

  if test -n "$dir_arg"; then
    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
  else

    # Make a couple of temp file names in the proper directory.
    dsttmp=$dstdir/_inst.$$_
    rmtmp=$dstdir/_rm.$$_

    # Trap to clean up those temp files at exit.
    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0

    # Copy the file name to the temp name.
    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&

    # and set any options; do chmod last to preserve setuid bits.
    #
    # If any of these fail, we abort the whole thing.  If we want to
    # ignore errors from any of these, just make sure not to ignore
    # errors from the above "$doit $cpprog $src $dsttmp" command.
    #
    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&

    # If -C, don't bother to copy if it wouldn't change the file.
    if $copy_on_change &&
       old=`LC_ALL=C ls -dlL "$dst"	2>/dev/null` &&
       new=`LC_ALL=C ls -dlL "$dsttmp"	2>/dev/null` &&

       eval "$initialize_posix_glob" &&
       $posix_glob set -f &&
       set X $old && old=:$2:$4:$5:$6 &&
       set X $new && new=:$2:$4:$5:$6 &&
       $posix_glob set +f &&

       test "$old" = "$new" &&
       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
    then
      rm -f "$dsttmp"
    else
      # Rename the file to the real destination.
      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||

      # The rename failed, perhaps because mv can't rename something else
      # to itself, or perhaps because mv is so ancient that it does not
      # support -f.
      {
	# Now remove or move aside any old file at destination location.
	# We try this two ways since rm can't unlink itself on some
	# systems and the destination file might be busy for other
	# reasons.  In this case, the final cleanup might fail but the new
	# file should still install successfully.
	{
	  test ! -f "$dst" ||
	  $doit $rmcmd -f "$dst" 2>/dev/null ||
	  { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
	    { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
	  } ||
	  { echo "$0: cannot unlink or rename $dst" >&2
	    (exit 1); exit 1
	  }
	} &&

	# Now rename the file to the real destination.
	$doit $mvcmd "$dsttmp" "$dst"
      }
    fi || exit 1

    trap '' 0
  fi
done

# Local variables:
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-time-zone: "UTC"
# time-stamp-end: "; # UTC"
# End:
blob
data 133403
# tcl.m4 --
#
#	This file provides a set of autoconf macros to help TEA-enable
#	a Tcl extension.
#
# Copyright (c) 1999-2000 Ajuba Solutions.
# Copyright (c) 2002-2005 ActiveState Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

AC_PREREQ(2.57)

dnl TEA extensions pass us the version of TEA they think they
dnl are compatible with (must be set in TEA_INIT below)
dnl TEA_VERSION="3.9"

# Possible values for key variables defined:
#
# TEA_WINDOWINGSYSTEM - win32 aqua x11 (mirrors 'tk windowingsystem')
# TEA_PLATFORM        - windows unix
#

#------------------------------------------------------------------------
# TEA_PATH_TCLCONFIG --
#
#	Locate the tclConfig.sh file and perform a sanity check on
#	the Tcl compile flags
#
# Arguments:
#	none
#
# Results:
#
#	Adds the following arguments to configure:
#		--with-tcl=...
#
#	Defines the following vars:
#		TCL_BIN_DIR	Full path to the directory containing
#				the tclConfig.sh file
#------------------------------------------------------------------------

AC_DEFUN([TEA_PATH_TCLCONFIG], [
    dnl TEA specific: Make sure we are initialized
    AC_REQUIRE([TEA_INIT])
    #
    # Ok, lets find the tcl configuration
    # First, look for one uninstalled.
    # the alternative search directory is invoked by --with-tcl
    #

    if test x"${no_tcl}" = x ; then
	# we reset no_tcl in case something fails here
	no_tcl=true
	AC_ARG_WITH(tcl,
	    AC_HELP_STRING([--with-tcl],
		[directory containing tcl configuration (tclConfig.sh)]),
	    with_tclconfig="${withval}")
	AC_MSG_CHECKING([for Tcl configuration])
	AC_CACHE_VAL(ac_cv_c_tclconfig,[

	    # First check to see if --with-tcl was specified.
	    if test x"${with_tclconfig}" != x ; then
		case "${with_tclconfig}" in
		    */tclConfig.sh )
			if test -f "${with_tclconfig}"; then
			    AC_MSG_WARN([--with-tcl argument should refer to directory containing tclConfig.sh, not to tclConfig.sh itself])
			    with_tclconfig="`echo "${with_tclconfig}" | sed 's!/tclConfig\.sh$!!'`"
			fi ;;
		esac
		if test -f "${with_tclconfig}/tclConfig.sh" ; then
		    ac_cv_c_tclconfig="`(cd "${with_tclconfig}"; pwd)`"
		else
		    AC_MSG_ERROR([${with_tclconfig} directory doesn't contain tclConfig.sh])
		fi
	    fi

	    # then check for a private Tcl installation
	    if test x"${ac_cv_c_tclconfig}" = x ; then
		for i in \
			../tcl \
			`ls -dr ../tcl[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
			`ls -dr ../tcl[[8-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ../tcl[[8-9]].[[0-9]]* 2>/dev/null` \
			../../tcl \
			`ls -dr ../../tcl[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
			`ls -dr ../../tcl[[8-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ../../tcl[[8-9]].[[0-9]]* 2>/dev/null` \
			../../../tcl \
			`ls -dr ../../../tcl[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
			`ls -dr ../../../tcl[[8-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ../../../tcl[[8-9]].[[0-9]]* 2>/dev/null` ; do
		    if test "${TEA_PLATFORM}" = "windows" \
			    -a -f "$i/win/tclConfig.sh" ; then
			ac_cv_c_tclconfig="`(cd $i/win; pwd)`"
			break
		    fi
		    if test -f "$i/unix/tclConfig.sh" ; then
			ac_cv_c_tclconfig="`(cd $i/unix; pwd)`"
			break
		    fi
		done
	    fi

	    # on Darwin, check in Framework installation locations
	    if test "`uname -s`" = "Darwin" -a x"${ac_cv_c_tclconfig}" = x ; then
		for i in `ls -d ~/Library/Frameworks 2>/dev/null` \
			`ls -d /Library/Frameworks 2>/dev/null` \
			`ls -d /Network/Library/Frameworks 2>/dev/null` \
			`ls -d /System/Library/Frameworks 2>/dev/null` \
			; do
		    if test -f "$i/Tcl.framework/tclConfig.sh" ; then
			ac_cv_c_tclconfig="`(cd $i/Tcl.framework; pwd)`"
			break
		    fi
		done
	    fi

	    # TEA specific: on Windows, check in common installation locations
	    if test "${TEA_PLATFORM}" = "windows" \
		-a x"${ac_cv_c_tclconfig}" = x ; then
		for i in `ls -d C:/Tcl/lib 2>/dev/null` \
			`ls -d C:/Progra~1/Tcl/lib 2>/dev/null` \
			; do
		    if test -f "$i/tclConfig.sh" ; then
			ac_cv_c_tclconfig="`(cd $i; pwd)`"
			break
		    fi
		done
	    fi

	    # check in a few common install locations
	    if test x"${ac_cv_c_tclconfig}" = x ; then
		for i in `ls -d ${libdir} 2>/dev/null` \
			`ls -d ${exec_prefix}/lib 2>/dev/null` \
			`ls -d ${prefix}/lib 2>/dev/null` \
			`ls -d /usr/local/lib 2>/dev/null` \
			`ls -d /usr/contrib/lib 2>/dev/null` \
			`ls -d /usr/lib 2>/dev/null` \
			`ls -d /usr/lib64 2>/dev/null` \
			; do
		    if test -f "$i/tclConfig.sh" ; then
			ac_cv_c_tclconfig="`(cd $i; pwd)`"
			break
		    fi
		done
	    fi

	    # check in a few other private locations
	    if test x"${ac_cv_c_tclconfig}" = x ; then
		for i in \
			${srcdir}/../tcl \
			`ls -dr ${srcdir}/../tcl[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
			`ls -dr ${srcdir}/../tcl[[8-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ${srcdir}/../tcl[[8-9]].[[0-9]]* 2>/dev/null` ; do
		    if test "${TEA_PLATFORM}" = "windows" \
			    -a -f "$i/win/tclConfig.sh" ; then
			ac_cv_c_tclconfig="`(cd $i/win; pwd)`"
			break
		    fi
		    if test -f "$i/unix/tclConfig.sh" ; then
			ac_cv_c_tclconfig="`(cd $i/unix; pwd)`"
			break
		    fi
		done
	    fi
	])

	if test x"${ac_cv_c_tclconfig}" = x ; then
	    TCL_BIN_DIR="# no Tcl configs found"
	    AC_MSG_ERROR([Can't find Tcl configuration definitions. Use --with-tcl to specify a directory containing tclConfig.sh])
	else
	    no_tcl=
	    TCL_BIN_DIR="${ac_cv_c_tclconfig}"
	    AC_MSG_RESULT([found ${TCL_BIN_DIR}/tclConfig.sh])
	fi
    fi
])

#------------------------------------------------------------------------
# TEA_PATH_TKCONFIG --
#
#	Locate the tkConfig.sh file
#
# Arguments:
#	none
#
# Results:
#
#	Adds the following arguments to configure:
#		--with-tk=...
#
#	Defines the following vars:
#		TK_BIN_DIR	Full path to the directory containing
#				the tkConfig.sh file
#------------------------------------------------------------------------

AC_DEFUN([TEA_PATH_TKCONFIG], [
    #
    # Ok, lets find the tk configuration
    # First, look for one uninstalled.
    # the alternative search directory is invoked by --with-tk
    #

    if test x"${no_tk}" = x ; then
	# we reset no_tk in case something fails here
	no_tk=true
	AC_ARG_WITH(tk,
	    AC_HELP_STRING([--with-tk],
		[directory containing tk configuration (tkConfig.sh)]),
	    with_tkconfig="${withval}")
	AC_MSG_CHECKING([for Tk configuration])
	AC_CACHE_VAL(ac_cv_c_tkconfig,[

	    # First check to see if --with-tkconfig was specified.
	    if test x"${with_tkconfig}" != x ; then
		case "${with_tkconfig}" in
		    */tkConfig.sh )
			if test -f "${with_tkconfig}"; then
			    AC_MSG_WARN([--with-tk argument should refer to directory containing tkConfig.sh, not to tkConfig.sh itself])
			    with_tkconfig="`echo "${with_tkconfig}" | sed 's!/tkConfig\.sh$!!'`"
			fi ;;
		esac
		if test -f "${with_tkconfig}/tkConfig.sh" ; then
		    ac_cv_c_tkconfig="`(cd "${with_tkconfig}"; pwd)`"
		else
		    AC_MSG_ERROR([${with_tkconfig} directory doesn't contain tkConfig.sh])
		fi
	    fi

	    # then check for a private Tk library
	    if test x"${ac_cv_c_tkconfig}" = x ; then
		for i in \
			../tk \
			`ls -dr ../tk[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
			`ls -dr ../tk[[8-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ../tk[[8-9]].[[0-9]]* 2>/dev/null` \
			../../tk \
			`ls -dr ../../tk[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
			`ls -dr ../../tk[[8-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ../../tk[[8-9]].[[0-9]]* 2>/dev/null` \
			../../../tk \
			`ls -dr ../../../tk[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
			`ls -dr ../../../tk[[8-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ../../../tk[[8-9]].[[0-9]]* 2>/dev/null` ; do
		    if test "${TEA_PLATFORM}" = "windows" \
			    -a -f "$i/win/tkConfig.sh" ; then
			ac_cv_c_tkconfig="`(cd $i/win; pwd)`"
			break
		    fi
		    if test -f "$i/unix/tkConfig.sh" ; then
			ac_cv_c_tkconfig="`(cd $i/unix; pwd)`"
			break
		    fi
		done
	    fi

	    # on Darwin, check in Framework installation locations
	    if test "`uname -s`" = "Darwin" -a x"${ac_cv_c_tkconfig}" = x ; then
		for i in `ls -d ~/Library/Frameworks 2>/dev/null` \
			`ls -d /Library/Frameworks 2>/dev/null` \
			`ls -d /Network/Library/Frameworks 2>/dev/null` \
			`ls -d /System/Library/Frameworks 2>/dev/null` \
			; do
		    if test -f "$i/Tk.framework/tkConfig.sh" ; then
			ac_cv_c_tkconfig="`(cd $i/Tk.framework; pwd)`"
			break
		    fi
		done
	    fi

	    # check in a few common install locations
	    if test x"${ac_cv_c_tkconfig}" = x ; then
		for i in `ls -d ${libdir} 2>/dev/null` \
			`ls -d ${exec_prefix}/lib 2>/dev/null` \
			`ls -d ${prefix}/lib 2>/dev/null` \
			`ls -d /usr/local/lib 2>/dev/null` \
			`ls -d /usr/contrib/lib 2>/dev/null` \
			`ls -d /usr/lib 2>/dev/null` \
			`ls -d /usr/lib64 2>/dev/null` \
			; do
		    if test -f "$i/tkConfig.sh" ; then
			ac_cv_c_tkconfig="`(cd $i; pwd)`"
			break
		    fi
		done
	    fi

	    # TEA specific: on Windows, check in common installation locations
	    if test "${TEA_PLATFORM}" = "windows" \
		-a x"${ac_cv_c_tkconfig}" = x ; then
		for i in `ls -d C:/Tcl/lib 2>/dev/null` \
			`ls -d C:/Progra~1/Tcl/lib 2>/dev/null` \
			; do
		    if test -f "$i/tkConfig.sh" ; then
			ac_cv_c_tkconfig="`(cd $i; pwd)`"
			break
		    fi
		done
	    fi

	    # check in a few other private locations
	    if test x"${ac_cv_c_tkconfig}" = x ; then
		for i in \
			${srcdir}/../tk \
			`ls -dr ${srcdir}/../tk[[8-9]].[[0-9]].[[0-9]]* 2>/dev/null` \
			`ls -dr ${srcdir}/../tk[[8-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ${srcdir}/../tk[[8-9]].[[0-9]]* 2>/dev/null` ; do
		    if test "${TEA_PLATFORM}" = "windows" \
			    -a -f "$i/win/tkConfig.sh" ; then
			ac_cv_c_tkconfig="`(cd $i/win; pwd)`"
			break
		    fi
		    if test -f "$i/unix/tkConfig.sh" ; then
			ac_cv_c_tkconfig="`(cd $i/unix; pwd)`"
			break
		    fi
		done
	    fi
	])

	if test x"${ac_cv_c_tkconfig}" = x ; then
	    TK_BIN_DIR="# no Tk configs found"
	    AC_MSG_ERROR([Can't find Tk configuration definitions. Use --with-tk to specify a directory containing tkConfig.sh])
	else
	    no_tk=
	    TK_BIN_DIR="${ac_cv_c_tkconfig}"
	    AC_MSG_RESULT([found ${TK_BIN_DIR}/tkConfig.sh])
	fi
    fi
])

#------------------------------------------------------------------------
# TEA_LOAD_TCLCONFIG --
#
#	Load the tclConfig.sh file
#
# Arguments:
#
#	Requires the following vars to be set:
#		TCL_BIN_DIR
#
# Results:
#
#	Subst the following vars:
#		TCL_BIN_DIR
#		TCL_SRC_DIR
#		TCL_LIB_FILE
#
#------------------------------------------------------------------------

AC_DEFUN([TEA_LOAD_TCLCONFIG], [
    AC_MSG_CHECKING([for existence of ${TCL_BIN_DIR}/tclConfig.sh])

    if test -f "${TCL_BIN_DIR}/tclConfig.sh" ; then
        AC_MSG_RESULT([loading])
	. "${TCL_BIN_DIR}/tclConfig.sh"
    else
        AC_MSG_RESULT([could not find ${TCL_BIN_DIR}/tclConfig.sh])
    fi

    # eval is required to do the TCL_DBGX substitution
    eval "TCL_LIB_FILE=\"${TCL_LIB_FILE}\""
    eval "TCL_STUB_LIB_FILE=\"${TCL_STUB_LIB_FILE}\""

    # If the TCL_BIN_DIR is the build directory (not the install directory),
    # then set the common variable name to the value of the build variables.
    # For example, the variable TCL_LIB_SPEC will be set to the value
    # of TCL_BUILD_LIB_SPEC. An extension should make use of TCL_LIB_SPEC
    # instead of TCL_BUILD_LIB_SPEC since it will work with both an
    # installed and uninstalled version of Tcl.
    if test -f "${TCL_BIN_DIR}/Makefile" ; then
        TCL_LIB_SPEC="${TCL_BUILD_LIB_SPEC}"
        TCL_STUB_LIB_SPEC="${TCL_BUILD_STUB_LIB_SPEC}"
        TCL_STUB_LIB_PATH="${TCL_BUILD_STUB_LIB_PATH}"
    elif test "`uname -s`" = "Darwin"; then
	# If Tcl was built as a framework, attempt to use the libraries
	# from the framework at the given location so that linking works
	# against Tcl.framework installed in an arbitrary location.
	case ${TCL_DEFS} in
	    *TCL_FRAMEWORK*)
		if test -f "${TCL_BIN_DIR}/${TCL_LIB_FILE}"; then
		    for i in "`cd "${TCL_BIN_DIR}"; pwd`" \
			     "`cd "${TCL_BIN_DIR}"/../..; pwd`"; do
			if test "`basename "$i"`" = "${TCL_LIB_FILE}.framework"; then
			    TCL_LIB_SPEC="-F`dirname "$i" | sed -e 's/ /\\\\ /g'` -framework ${TCL_LIB_FILE}"
			    break
			fi
		    done
		fi
		if test -f "${TCL_BIN_DIR}/${TCL_STUB_LIB_FILE}"; then
		    TCL_STUB_LIB_SPEC="-L`echo "${TCL_BIN_DIR}"  | sed -e 's/ /\\\\ /g'` ${TCL_STUB_LIB_FLAG}"
		    TCL_STUB_LIB_PATH="${TCL_BIN_DIR}/${TCL_STUB_LIB_FILE}"
		fi
		;;
	esac
    fi

    # eval is required to do the TCL_DBGX substitution
    eval "TCL_LIB_FLAG=\"${TCL_LIB_FLAG}\""
    eval "TCL_LIB_SPEC=\"${TCL_LIB_SPEC}\""
    eval "TCL_STUB_LIB_FLAG=\"${TCL_STUB_LIB_FLAG}\""
    eval "TCL_STUB_LIB_SPEC=\"${TCL_STUB_LIB_SPEC}\""

    AC_SUBST(TCL_VERSION)
    AC_SUBST(TCL_PATCH_LEVEL)
    AC_SUBST(TCL_BIN_DIR)
    AC_SUBST(TCL_SRC_DIR)

    AC_SUBST(TCL_LIB_FILE)
    AC_SUBST(TCL_LIB_FLAG)
    AC_SUBST(TCL_LIB_SPEC)

    AC_SUBST(TCL_STUB_LIB_FILE)
    AC_SUBST(TCL_STUB_LIB_FLAG)
    AC_SUBST(TCL_STUB_LIB_SPEC)

    AC_MSG_CHECKING([platform])
    hold_cc=$CC; CC="$TCL_CC"
    AC_TRY_COMPILE(,[
	    #ifdef _WIN32
		#error win32
	    #endif
    ], TEA_PLATFORM="unix",
	    TEA_PLATFORM="windows"
    )
    CC=$hold_cc
    AC_MSG_RESULT($TEA_PLATFORM)

    # The BUILD_$pkg is to define the correct extern storage class
    # handling when making this package
    AC_DEFINE_UNQUOTED(BUILD_${PACKAGE_NAME}, [],
	    [Building extension source?])
    # Do this here as we have fully defined TEA_PLATFORM now
    if test "${TEA_PLATFORM}" = "windows" ; then
	EXEEXT=".exe"
	CLEANFILES="$CLEANFILES *.lib *.dll *.pdb *.exp"
    fi

    # TEA specific:
    AC_SUBST(CLEANFILES)
    AC_SUBST(TCL_LIBS)
    AC_SUBST(TCL_DEFS)
    AC_SUBST(TCL_EXTRA_CFLAGS)
    AC_SUBST(TCL_LD_FLAGS)
    AC_SUBST(TCL_SHLIB_LD_LIBS)
])

#------------------------------------------------------------------------
# TEA_LOAD_TKCONFIG --
#
#	Load the tkConfig.sh file
#
# Arguments:
#
#	Requires the following vars to be set:
#		TK_BIN_DIR
#
# Results:
#
#	Sets the following vars that should be in tkConfig.sh:
#		TK_BIN_DIR
#------------------------------------------------------------------------

AC_DEFUN([TEA_LOAD_TKCONFIG], [
    AC_MSG_CHECKING([for existence of ${TK_BIN_DIR}/tkConfig.sh])

    if test -f "${TK_BIN_DIR}/tkConfig.sh" ; then
        AC_MSG_RESULT([loading])
	. "${TK_BIN_DIR}/tkConfig.sh"
    else
        AC_MSG_RESULT([could not find ${TK_BIN_DIR}/tkConfig.sh])
    fi

    # eval is required to do the TK_DBGX substitution
    eval "TK_LIB_FILE=\"${TK_LIB_FILE}\""
    eval "TK_STUB_LIB_FILE=\"${TK_STUB_LIB_FILE}\""

    # If the TK_BIN_DIR is the build directory (not the install directory),
    # then set the common variable name to the value of the build variables.
    # For example, the variable TK_LIB_SPEC will be set to the value
    # of TK_BUILD_LIB_SPEC. An extension should make use of TK_LIB_SPEC
    # instead of TK_BUILD_LIB_SPEC since it will work with both an
    # installed and uninstalled version of Tcl.
    if test -f "${TK_BIN_DIR}/Makefile" ; then
        TK_LIB_SPEC="${TK_BUILD_LIB_SPEC}"
        TK_STUB_LIB_SPEC="${TK_BUILD_STUB_LIB_SPEC}"
        TK_STUB_LIB_PATH="${TK_BUILD_STUB_LIB_PATH}"
    elif test "`uname -s`" = "Darwin"; then
	# If Tk was built as a framework, attempt to use the libraries
	# from the framework at the given location so that linking works
	# against Tk.framework installed in an arbitrary location.
	case ${TK_DEFS} in
	    *TK_FRAMEWORK*)
		if test -f "${TK_BIN_DIR}/${TK_LIB_FILE}"; then
		    for i in "`cd "${TK_BIN_DIR}"; pwd`" \
			     "`cd "${TK_BIN_DIR}"/../..; pwd`"; do
			if test "`basename "$i"`" = "${TK_LIB_FILE}.framework"; then
			    TK_LIB_SPEC="-F`dirname "$i" | sed -e 's/ /\\\\ /g'` -framework ${TK_LIB_FILE}"
			    break
			fi
		    done
		fi
		if test -f "${TK_BIN_DIR}/${TK_STUB_LIB_FILE}"; then
		    TK_STUB_LIB_SPEC="-L` echo "${TK_BIN_DIR}"  | sed -e 's/ /\\\\ /g'` ${TK_STUB_LIB_FLAG}"
		    TK_STUB_LIB_PATH="${TK_BIN_DIR}/${TK_STUB_LIB_FILE}"
		fi
		;;
	esac
    fi

    # eval is required to do the TK_DBGX substitution
    eval "TK_LIB_FLAG=\"${TK_LIB_FLAG}\""
    eval "TK_LIB_SPEC=\"${TK_LIB_SPEC}\""
    eval "TK_STUB_LIB_FLAG=\"${TK_STUB_LIB_FLAG}\""
    eval "TK_STUB_LIB_SPEC=\"${TK_STUB_LIB_SPEC}\""

    # TEA specific: Ensure windowingsystem is defined
    if test "${TEA_PLATFORM}" = "unix" ; then
	case ${TK_DEFS} in
	    *MAC_OSX_TK*)
		AC_DEFINE(MAC_OSX_TK, 1, [Are we building against Mac OS X TkAqua?])
		TEA_WINDOWINGSYSTEM="aqua"
		;;
	    *)
		TEA_WINDOWINGSYSTEM="x11"
		;;
	esac
    elif test "${TEA_PLATFORM}" = "windows" ; then
	TEA_WINDOWINGSYSTEM="win32"
    fi

    AC_SUBST(TK_VERSION)
    AC_SUBST(TK_BIN_DIR)
    AC_SUBST(TK_SRC_DIR)

    AC_SUBST(TK_LIB_FILE)
    AC_SUBST(TK_LIB_FLAG)
    AC_SUBST(TK_LIB_SPEC)

    AC_SUBST(TK_STUB_LIB_FILE)
    AC_SUBST(TK_STUB_LIB_FLAG)
    AC_SUBST(TK_STUB_LIB_SPEC)

    # TEA specific:
    AC_SUBST(TK_LIBS)
    AC_SUBST(TK_XINCLUDES)
])

#------------------------------------------------------------------------
# TEA_PROG_TCLSH
#	Determine the fully qualified path name of the tclsh executable
#	in the Tcl build directory or the tclsh installed in a bin
#	directory. This macro will correctly determine the name
#	of the tclsh executable even if tclsh has not yet been
#	built in the build directory. The tclsh found is always
#	associated with a tclConfig.sh file. This tclsh should be used
#	only for running extension test cases. It should never be
#	or generation of files (like pkgIndex.tcl) at build time.
#
# Arguments
#	none
#
# Results
#	Subst's the following values:
#		TCLSH_PROG
#------------------------------------------------------------------------

AC_DEFUN([TEA_PROG_TCLSH], [
    AC_MSG_CHECKING([for tclsh])
    if test -f "${TCL_BIN_DIR}/Makefile" ; then
        # tclConfig.sh is in Tcl build directory
        if test "${TEA_PLATFORM}" = "windows"; then
            TCLSH_PROG="${TCL_BIN_DIR}/tclsh${TCL_MAJOR_VERSION}${TCL_MINOR_VERSION}${TCL_DBGX}${EXEEXT}"
        else
            TCLSH_PROG="${TCL_BIN_DIR}/tclsh"
        fi
    else
        # tclConfig.sh is in install location
        if test "${TEA_PLATFORM}" = "windows"; then
            TCLSH_PROG="tclsh${TCL_MAJOR_VERSION}${TCL_MINOR_VERSION}${TCL_DBGX}${EXEEXT}"
        else
            TCLSH_PROG="tclsh${TCL_MAJOR_VERSION}.${TCL_MINOR_VERSION}${TCL_DBGX}"
        fi
        list="`ls -d ${TCL_BIN_DIR}/../bin 2>/dev/null` \
              `ls -d ${TCL_BIN_DIR}/..     2>/dev/null` \
              `ls -d ${TCL_PREFIX}/bin     2>/dev/null`"
        for i in $list ; do
            if test -f "$i/${TCLSH_PROG}" ; then
                REAL_TCL_BIN_DIR="`cd "$i"; pwd`/"
                break
            fi
        done
        TCLSH_PROG="${REAL_TCL_BIN_DIR}${TCLSH_PROG}"
    fi
    AC_MSG_RESULT([${TCLSH_PROG}])
    AC_SUBST(TCLSH_PROG)
])

#------------------------------------------------------------------------
# TEA_PROG_WISH
#	Determine the fully qualified path name of the wish executable
#	in the Tk build directory or the wish installed in a bin
#	directory. This macro will correctly determine the name
#	of the wish executable even if wish has not yet been
#	built in the build directory. The wish found is always
#	associated with a tkConfig.sh file. This wish should be used
#	only for running extension test cases. It should never be
#	or generation of files (like pkgIndex.tcl) at build time.
#
# Arguments
#	none
#
# Results
#	Subst's the following values:
#		WISH_PROG
#------------------------------------------------------------------------

AC_DEFUN([TEA_PROG_WISH], [
    AC_MSG_CHECKING([for wish])
    if test -f "${TK_BIN_DIR}/Makefile" ; then
        # tkConfig.sh is in Tk build directory
        if test "${TEA_PLATFORM}" = "windows"; then
            WISH_PROG="${TK_BIN_DIR}/wish${TK_MAJOR_VERSION}${TK_MINOR_VERSION}${TK_DBGX}${EXEEXT}"
        else
            WISH_PROG="${TK_BIN_DIR}/wish"
        fi
    else
        # tkConfig.sh is in install location
        if test "${TEA_PLATFORM}" = "windows"; then
            WISH_PROG="wish${TK_MAJOR_VERSION}${TK_MINOR_VERSION}${TK_DBGX}${EXEEXT}"
        else
            WISH_PROG="wish${TK_MAJOR_VERSION}.${TK_MINOR_VERSION}${TK_DBGX}"
        fi
        list="`ls -d ${TK_BIN_DIR}/../bin 2>/dev/null` \
              `ls -d ${TK_BIN_DIR}/..     2>/dev/null` \
              `ls -d ${TK_PREFIX}/bin     2>/dev/null`"
        for i in $list ; do
            if test -f "$i/${WISH_PROG}" ; then
                REAL_TK_BIN_DIR="`cd "$i"; pwd`/"
                break
            fi
        done
        WISH_PROG="${REAL_TK_BIN_DIR}${WISH_PROG}"
    fi
    AC_MSG_RESULT([${WISH_PROG}])
    AC_SUBST(WISH_PROG)
])

#------------------------------------------------------------------------
# TEA_ENABLE_SHARED --
#
#	Allows the building of shared libraries
#
# Arguments:
#	none
#
# Results:
#
#	Adds the following arguments to configure:
#		--enable-shared=yes|no
#
#	Defines the following vars:
#		STATIC_BUILD	Used for building import/export libraries
#				on Windows.
#
#	Sets the following vars:
#		SHARED_BUILD	Value of 1 or 0
#------------------------------------------------------------------------

AC_DEFUN([TEA_ENABLE_SHARED], [
    AC_MSG_CHECKING([how to build libraries])
    AC_ARG_ENABLE(shared,
	AC_HELP_STRING([--enable-shared],
	    [build and link with shared libraries (default: on)]),
	[tcl_ok=$enableval], [tcl_ok=yes])

    if test "${enable_shared+set}" = set; then
	enableval="$enable_shared"
	tcl_ok=$enableval
    else
	tcl_ok=yes
    fi

    if test "$tcl_ok" = "yes" ; then
	AC_MSG_RESULT([shared])
	SHARED_BUILD=1
    else
	AC_MSG_RESULT([static])
	SHARED_BUILD=0
	AC_DEFINE(STATIC_BUILD, 1, [Is this a static build?])
    fi
    AC_SUBST(SHARED_BUILD)
])

#------------------------------------------------------------------------
# TEA_ENABLE_THREADS --
#
#	Specify if thread support should be enabled.  If "yes" is specified
#	as an arg (optional), threads are enabled by default, "no" means
#	threads are disabled.  "yes" is the default.
#
#	TCL_THREADS is checked so that if you are compiling an extension
#	against a threaded core, your extension must be compiled threaded
#	as well.
#
#	Note that it is legal to have a thread enabled extension run in a
#	threaded or non-threaded Tcl core, but a non-threaded extension may
#	only run in a non-threaded Tcl core.
#
# Arguments:
#	none
#
# Results:
#
#	Adds the following arguments to configure:
#		--enable-threads
#
#	Sets the following vars:
#		THREADS_LIBS	Thread library(s)
#
#	Defines the following vars:
#		TCL_THREADS
#		_REENTRANT
#		_THREAD_SAFE
#
#------------------------------------------------------------------------

AC_DEFUN([TEA_ENABLE_THREADS], [
    AC_ARG_ENABLE(threads,
	AC_HELP_STRING([--enable-threads],
	    [build with threads]),
	[tcl_ok=$enableval], [tcl_ok=yes])

    if test "${enable_threads+set}" = set; then
	enableval="$enable_threads"
	tcl_ok=$enableval
    else
	tcl_ok=yes
    fi

    if test "$tcl_ok" = "yes" -o "${TCL_THREADS}" = 1; then
	TCL_THREADS=1

	if test "${TEA_PLATFORM}" != "windows" ; then
	    # We are always OK on Windows, so check what this platform wants:

	    # USE_THREAD_ALLOC tells us to try the special thread-based
	    # allocator that significantly reduces lock contention
	    AC_DEFINE(USE_THREAD_ALLOC, 1,
		[Do we want to use the threaded memory allocator?])
	    AC_DEFINE(_REENTRANT, 1, [Do we want the reentrant OS API?])
	    if test "`uname -s`" = "SunOS" ; then
		AC_DEFINE(_POSIX_PTHREAD_SEMANTICS, 1,
			[Do we really want to follow the standard? Yes we do!])
	    fi
	    AC_DEFINE(_THREAD_SAFE, 1, [Do we want the thread-safe OS API?])
	    AC_CHECK_LIB(pthread,pthread_mutex_init,tcl_ok=yes,tcl_ok=no)
	    if test "$tcl_ok" = "no"; then
		# Check a little harder for __pthread_mutex_init in the same
		# library, as some systems hide it there until pthread.h is
		# defined.  We could alternatively do an AC_TRY_COMPILE with
		# pthread.h, but that will work with libpthread really doesn't
		# exist, like AIX 4.2.  [Bug: 4359]
		AC_CHECK_LIB(pthread, __pthread_mutex_init,
		    tcl_ok=yes, tcl_ok=no)
	    fi

	    if test "$tcl_ok" = "yes"; then
		# The space is needed
		THREADS_LIBS=" -lpthread"
	    else
		AC_CHECK_LIB(pthreads, pthread_mutex_init,
		    tcl_ok=yes, tcl_ok=no)
		if test "$tcl_ok" = "yes"; then
		    # The space is needed
		    THREADS_LIBS=" -lpthreads"
		else
		    AC_CHECK_LIB(c, pthread_mutex_init,
			tcl_ok=yes, tcl_ok=no)
		    if test "$tcl_ok" = "no"; then
			AC_CHECK_LIB(c_r, pthread_mutex_init,
			    tcl_ok=yes, tcl_ok=no)
			if test "$tcl_ok" = "yes"; then
			    # The space is needed
			    THREADS_LIBS=" -pthread"
			else
			    TCL_THREADS=0
			    AC_MSG_WARN([Do not know how to find pthread lib on your system - thread support disabled])
			fi
		    fi
		fi
	    fi
	fi
    else
	TCL_THREADS=0
    fi
    # Do checking message here to not mess up interleaved configure output
    AC_MSG_CHECKING([for building with threads])
    if test "${TCL_THREADS}" = 1; then
	AC_DEFINE(TCL_THREADS, 1, [Are we building with threads enabled?])
	AC_MSG_RESULT([yes (default)])
    else
	AC_MSG_RESULT([no])
    fi
    # TCL_THREADS sanity checking.  See if our request for building with
    # threads is the same as the way Tcl was built.  If not, warn the user.
    case ${TCL_DEFS} in
	*THREADS=1*)
	    if test "${TCL_THREADS}" = "0"; then
		AC_MSG_WARN([
    Building ${PACKAGE_NAME} without threads enabled, but building against Tcl
    that IS thread-enabled.  It is recommended to use --enable-threads.])
	    fi
	    ;;
	*)
	    if test "${TCL_THREADS}" = "1"; then
		AC_MSG_WARN([
    --enable-threads requested, but building against a Tcl that is NOT
    thread-enabled.  This is an OK configuration that will also run in
    a thread-enabled core.])
	    fi
	    ;;
    esac
    AC_SUBST(TCL_THREADS)
])

#------------------------------------------------------------------------
# TEA_ENABLE_SYMBOLS --
#
#	Specify if debugging symbols should be used.
#	Memory (TCL_MEM_DEBUG) debugging can also be enabled.
#
# Arguments:
#	none
#
#	TEA varies from core Tcl in that C|LDFLAGS_DEFAULT receives
#	the value of C|LDFLAGS_OPTIMIZE|DEBUG already substituted.
#	Requires the following vars to be set in the Makefile:
#		CFLAGS_DEFAULT
#		LDFLAGS_DEFAULT
#
# Results:
#
#	Adds the following arguments to configure:
#		--enable-symbols
#
#	Defines the following vars:
#		CFLAGS_DEFAULT	Sets to $(CFLAGS_DEBUG) if true
#				Sets to $(CFLAGS_OPTIMIZE) if false
#		LDFLAGS_DEFAULT	Sets to $(LDFLAGS_DEBUG) if true
#				Sets to $(LDFLAGS_OPTIMIZE) if false
#		DBGX		Formerly used as debug library extension;
#				always blank now.
#
#------------------------------------------------------------------------

AC_DEFUN([TEA_ENABLE_SYMBOLS], [
    dnl TEA specific: Make sure we are initialized
    AC_REQUIRE([TEA_CONFIG_CFLAGS])
    AC_MSG_CHECKING([for build with symbols])
    AC_ARG_ENABLE(symbols,
	AC_HELP_STRING([--enable-symbols],
	    [build with debugging symbols (default: off)]),
	[tcl_ok=$enableval], [tcl_ok=no])
    DBGX=""
    if test "$tcl_ok" = "no"; then
	CFLAGS_DEFAULT='${CFLAGS_OPTIMIZE}'
	LDFLAGS_DEFAULT='${LDFLAGS_OPTIMIZE}'
	AC_MSG_RESULT([no])
    else
	CFLAGS_DEFAULT='${CFLAGS_DEBUG}'
	LDFLAGS_DEFAULT='${LDFLAGS_DEBUG}'
	if test "$tcl_ok" = "yes"; then
	    AC_MSG_RESULT([yes (standard debugging)])
	fi
    fi
    # TEA specific:
    if test "${TEA_PLATFORM}" != "windows" ; then
	LDFLAGS_DEFAULT="${LDFLAGS}"
    fi
    AC_SUBST(CFLAGS_DEFAULT)
    AC_SUBST(LDFLAGS_DEFAULT)
    AC_SUBST(TCL_DBGX)

    if test "$tcl_ok" = "mem" -o "$tcl_ok" = "all"; then
	AC_DEFINE(TCL_MEM_DEBUG, 1, [Is memory debugging enabled?])
    fi

    if test "$tcl_ok" != "yes" -a "$tcl_ok" != "no"; then
	if test "$tcl_ok" = "all"; then
	    AC_MSG_RESULT([enabled symbols mem debugging])
	else
	    AC_MSG_RESULT([enabled $tcl_ok debugging])
	fi
    fi
])

#------------------------------------------------------------------------
# TEA_ENABLE_LANGINFO --
#
#	Allows use of modern nl_langinfo check for better l10n.
#	This is only relevant for Unix.
#
# Arguments:
#	none
#
# Results:
#
#	Adds the following arguments to configure:
#		--enable-langinfo=yes|no (default is yes)
#
#	Defines the following vars:
#		HAVE_LANGINFO	Triggers use of nl_langinfo if defined.
#
#------------------------------------------------------------------------

AC_DEFUN([TEA_ENABLE_LANGINFO], [
    AC_ARG_ENABLE(langinfo,
	AC_HELP_STRING([--enable-langinfo],
	    [use nl_langinfo if possible to determine encoding at startup, otherwise use old heuristic (default: on)]),
	[langinfo_ok=$enableval], [langinfo_ok=yes])

    HAVE_LANGINFO=0
    if test "$langinfo_ok" = "yes"; then
	AC_CHECK_HEADER(langinfo.h,[langinfo_ok=yes],[langinfo_ok=no])
    fi
    AC_MSG_CHECKING([whether to use nl_langinfo])
    if test "$langinfo_ok" = "yes"; then
	AC_CACHE_VAL(tcl_cv_langinfo_h, [
	    AC_TRY_COMPILE([#include <langinfo.h>], [nl_langinfo(CODESET);],
		    [tcl_cv_langinfo_h=yes],[tcl_cv_langinfo_h=no])])
	AC_MSG_RESULT([$tcl_cv_langinfo_h])
	if test $tcl_cv_langinfo_h = yes; then
	    AC_DEFINE(HAVE_LANGINFO, 1, [Do we have nl_langinfo()?])
	fi
    else
	AC_MSG_RESULT([$langinfo_ok])
    fi
])

#--------------------------------------------------------------------
# TEA_CONFIG_SYSTEM
#
#	Determine what the system is (some things cannot be easily checked
#	on a feature-driven basis, alas). This can usually be done via the
#	"uname" command.
#
# Arguments:
#	none
#
# Results:
#	Defines the following var:
#
#	system -	System/platform/version identification code.
#
#--------------------------------------------------------------------

AC_DEFUN([TEA_CONFIG_SYSTEM], [
    AC_CACHE_CHECK([system version], tcl_cv_sys_version, [
	# TEA specific:
	if test "${TEA_PLATFORM}" = "windows" ; then
	    tcl_cv_sys_version=windows
	else
	    tcl_cv_sys_version=`uname -s`-`uname -r`
	    if test "$?" -ne 0 ; then
		AC_MSG_WARN([can't find uname command])
		tcl_cv_sys_version=unknown
	    else
		if test "`uname -s`" = "AIX" ; then
		    tcl_cv_sys_version=AIX-`uname -v`.`uname -r`
		fi
	    fi
	fi
    ])
    system=$tcl_cv_sys_version
])

#--------------------------------------------------------------------
# TEA_CONFIG_CFLAGS
#
#	Try to determine the proper flags to pass to the compiler
#	for building shared libraries and other such nonsense.
#
# Arguments:
#	none
#
# Results:
#
#	Defines and substitutes the following vars:
#
#	DL_OBJS, DL_LIBS - removed for TEA, only needed by core.
#       LDFLAGS -      Flags to pass to the compiler when linking object
#                       files into an executable application binary such
#                       as tclsh.
#       LD_SEARCH_FLAGS-Flags to pass to ld, such as "-R /usr/local/tcl/lib",
#                       that tell the run-time dynamic linker where to look
#                       for shared libraries such as libtcl.so.  Depends on
#                       the variable LIB_RUNTIME_DIR in the Makefile. Could
#                       be the same as CC_SEARCH_FLAGS if ${CC} is used to link.
#       CC_SEARCH_FLAGS-Flags to pass to ${CC}, such as "-Wl,-rpath,/usr/local/tcl/lib",
#                       that tell the run-time dynamic linker where to look
#                       for shared libraries such as libtcl.so.  Depends on
#                       the variable LIB_RUNTIME_DIR in the Makefile.
#       SHLIB_CFLAGS -  Flags to pass to cc when compiling the components
#                       of a shared library (may request position-independent
#                       code, among other things).
#       SHLIB_LD -      Base command to use for combining object files
#                       into a shared library.
#       SHLIB_LD_LIBS - Dependent libraries for the linker to scan when
#                       creating shared libraries.  This symbol typically
#                       goes at the end of the "ld" commands that build
#                       shared libraries. The value of the symbol defaults to
#                       "${LIBS}" if all of the dependent libraries should
#                       be specified when creating a shared library.  If
#                       dependent libraries should not be specified (as on
#                       SunOS 4.x, where they cause the link to fail, or in
#                       general if Tcl and Tk aren't themselves shared
#                       libraries), then this symbol has an empty string
#                       as its value.
#       SHLIB_SUFFIX -  Suffix to use for the names of dynamically loadable
#                       extensions.  An empty string means we don't know how
#                       to use shared libraries on this platform.
#       LIB_SUFFIX -    Specifies everything that comes after the "libfoo"
#                       in a static or shared library name, using the $VERSION variable
#                       to put the version in the right place.  This is used
#                       by platforms that need non-standard library names.
#                       Examples:  ${VERSION}.so.1.1 on NetBSD, since it needs
#                       to have a version after the .so, and ${VERSION}.a
#                       on AIX, since a shared library needs to have
#                       a .a extension whereas shared objects for loadable
#                       extensions have a .so extension.  Defaults to
#                       ${VERSION}${SHLIB_SUFFIX}.
#	CFLAGS_DEBUG -
#			Flags used when running the compiler in debug mode
#	CFLAGS_OPTIMIZE -
#			Flags used when running the compiler in optimize mode
#	CFLAGS -	Additional CFLAGS added as necessary (usually 64-bit)
#
#--------------------------------------------------------------------

AC_DEFUN([TEA_CONFIG_CFLAGS], [
    dnl TEA specific: Make sure we are initialized
    AC_REQUIRE([TEA_INIT])

    # Step 0.a: Enable 64 bit support?

    AC_MSG_CHECKING([if 64bit support is requested])
    AC_ARG_ENABLE(64bit,
	AC_HELP_STRING([--enable-64bit],
	    [enable 64bit support (default: off)]),
	[do64bit=$enableval], [do64bit=no])
    AC_MSG_RESULT([$do64bit])

    # Step 0.b: Enable Solaris 64 bit VIS support?

    AC_MSG_CHECKING([if 64bit Sparc VIS support is requested])
    AC_ARG_ENABLE(64bit-vis,
	AC_HELP_STRING([--enable-64bit-vis],
	    [enable 64bit Sparc VIS support (default: off)]),
	[do64bitVIS=$enableval], [do64bitVIS=no])
    AC_MSG_RESULT([$do64bitVIS])
    # Force 64bit on with VIS
    AS_IF([test "$do64bitVIS" = "yes"], [do64bit=yes])

    # Step 0.c: Check if visibility support is available. Do this here so
    # that platform specific alternatives can be used below if this fails.

    AC_CACHE_CHECK([if compiler supports visibility "hidden"],
	tcl_cv_cc_visibility_hidden, [
	hold_cflags=$CFLAGS; CFLAGS="$CFLAGS -Werror"
	AC_TRY_LINK([
	    extern __attribute__((__visibility__("hidden"))) void f(void);
	    void f(void) {}], [f();], tcl_cv_cc_visibility_hidden=yes,
	    tcl_cv_cc_visibility_hidden=no)
	CFLAGS=$hold_cflags])
    AS_IF([test $tcl_cv_cc_visibility_hidden = yes], [
	AC_DEFINE(MODULE_SCOPE,
	    [extern __attribute__((__visibility__("hidden")))],
	    [Compiler support for module scope symbols])
    ])

    # Step 0.d: Disable -rpath support?

    AC_MSG_CHECKING([if rpath support is requested])
    AC_ARG_ENABLE(rpath,
	AC_HELP_STRING([--disable-rpath],
	    [disable rpath support (default: on)]),
	[doRpath=$enableval], [doRpath=yes])
    AC_MSG_RESULT([$doRpath])

    # TEA specific: Cross-compiling options for Windows/CE builds?

    AS_IF([test "${TEA_PLATFORM}" = windows], [
	AC_MSG_CHECKING([if Windows/CE build is requested])
	AC_ARG_ENABLE(wince,
	    AC_HELP_STRING([--enable-wince],
		[enable Win/CE support (where applicable)]),
	    [doWince=$enableval], [doWince=no])
	AC_MSG_RESULT([$doWince])
    ])

    # Set the variable "system" to hold the name and version number
    # for the system.

    TEA_CONFIG_SYSTEM

    # Require ranlib early so we can override it in special cases below.

    AC_REQUIRE([AC_PROG_RANLIB])

    # Set configuration options based on system name and version.
    # This is similar to Tcl's unix/tcl.m4 except that we've added a
    # "windows" case and removed some core-only vars.

    do64bit_ok=no
    # default to '{$LIBS}' and set to "" on per-platform necessary basis
    SHLIB_LD_LIBS='${LIBS}'
    # When ld needs options to work in 64-bit mode, put them in
    # LDFLAGS_ARCH so they eventually end up in LDFLAGS even if [load]
    # is disabled by the user. [Bug 1016796]
    LDFLAGS_ARCH=""
    UNSHARED_LIB_SUFFIX=""
    # TEA specific: use PACKAGE_VERSION instead of VERSION
    TCL_TRIM_DOTS='`echo ${PACKAGE_VERSION} | tr -d .`'
    ECHO_VERSION='`echo ${PACKAGE_VERSION}`'
    TCL_LIB_VERSIONS_OK=ok
    CFLAGS_DEBUG=-g
    AS_IF([test "$GCC" = yes], [
	CFLAGS_OPTIMIZE=-O2
	CFLAGS_WARNING="-Wall"
    ], [
	CFLAGS_OPTIMIZE=-O
	CFLAGS_WARNING=""
    ])
    AC_CHECK_TOOL(AR, ar)
    STLIB_LD='${AR} cr'
    LD_LIBRARY_PATH_VAR="LD_LIBRARY_PATH"
    AS_IF([test "x$SHLIB_VERSION" = x],[SHLIB_VERSION="1.0"])
    case $system in
	# TEA specific:
	windows)
	    # This is a 2-stage check to make sure we have the 64-bit SDK
	    # We have to know where the SDK is installed.
	    # This magic is based on MS Platform SDK for Win2003 SP1 - hobbs
	    # MACHINE is IX86 for LINK, but this is used by the manifest,
	    # which requires x86|amd64|ia64.
	    MACHINE="X86"
	    if test "$do64bit" != "no" ; then
		if test "x${MSSDK}x" = "xx" ; then
		    MSSDK="C:/Progra~1/Microsoft Platform SDK"
		fi
		MSSDK=`echo "$MSSDK" | sed -e  's!\\\!/!g'`
		PATH64=""
		case "$do64bit" in
		    amd64|x64|yes)
			MACHINE="AMD64" ; # default to AMD64 64-bit build
			PATH64="${MSSDK}/Bin/Win64/x86/AMD64"
			;;
		    ia64)
			MACHINE="IA64"
			PATH64="${MSSDK}/Bin/Win64"
			;;
		esac
		if test "$GCC" != "yes" -a ! -d "${PATH64}" ; then
		    AC_MSG_WARN([Could not find 64-bit $MACHINE SDK to enable 64bit mode])
		    AC_MSG_WARN([Ensure latest Platform SDK is installed])
		    do64bit="no"
		else
		    AC_MSG_RESULT([   Using 64-bit $MACHINE mode])
		    do64bit_ok="yes"
		fi
	    fi

	    if test "$doWince" != "no" ; then
		if test "$do64bit" != "no" ; then
		    AC_MSG_ERROR([Windows/CE and 64-bit builds incompatible])
		fi
		if test "$GCC" = "yes" ; then
		    AC_MSG_ERROR([Windows/CE and GCC builds incompatible])
		fi
		TEA_PATH_CELIB
		# Set defaults for common evc4/PPC2003 setup
		# Currently Tcl requires 300+, possibly 420+ for sockets
		CEVERSION=420; 		# could be 211 300 301 400 420 ...
		TARGETCPU=ARMV4;	# could be ARMV4 ARM MIPS SH3 X86 ...
		ARCH=ARM;		# could be ARM MIPS X86EM ...
		PLATFORM="Pocket PC 2003"; # or "Pocket PC 2002"
		if test "$doWince" != "yes"; then
		    # If !yes then the user specified something
		    # Reset ARCH to allow user to skip specifying it
		    ARCH=
		    eval `echo $doWince | awk -F, '{ \
	    if (length([$]1)) { printf "CEVERSION=\"%s\"\n", [$]1; \
	    if ([$]1 < 400)   { printf "PLATFORM=\"Pocket PC 2002\"\n" } }; \
	    if (length([$]2)) { printf "TARGETCPU=\"%s\"\n", toupper([$]2) }; \
	    if (length([$]3)) { printf "ARCH=\"%s\"\n", toupper([$]3) }; \
	    if (length([$]4)) { printf "PLATFORM=\"%s\"\n", [$]4 }; \
		    }'`
		    if test "x${ARCH}" = "x" ; then
			ARCH=$TARGETCPU;
		    fi
		fi
		OSVERSION=WCE$CEVERSION;
	    	if test "x${WCEROOT}" = "x" ; then
			WCEROOT="C:/Program Files/Microsoft eMbedded C++ 4.0"
		    if test ! -d "${WCEROOT}" ; then
			WCEROOT="C:/Program Files/Microsoft eMbedded Tools"
		    fi
		fi
		if test "x${SDKROOT}" = "x" ; then
		    SDKROOT="C:/Program Files/Windows CE Tools"
		    if test ! -d "${SDKROOT}" ; then
			SDKROOT="C:/Windows CE Tools"
		    fi
		fi
		WCEROOT=`echo "$WCEROOT" | sed -e 's!\\\!/!g'`
		SDKROOT=`echo "$SDKROOT" | sed -e 's!\\\!/!g'`
		if test ! -d "${SDKROOT}/${OSVERSION}/${PLATFORM}/Lib/${TARGETCPU}" \
		    -o ! -d "${WCEROOT}/EVC/${OSVERSION}/bin"; then
		    AC_MSG_ERROR([could not find PocketPC SDK or target compiler to enable WinCE mode [$CEVERSION,$TARGETCPU,$ARCH,$PLATFORM]])
		    doWince="no"
		else
		    # We could PATH_NOSPACE these, but that's not important,
		    # as long as we quote them when used.
		    CEINCLUDE="${SDKROOT}/${OSVERSION}/${PLATFORM}/include"
		    if test -d "${CEINCLUDE}/${TARGETCPU}" ; then
			CEINCLUDE="${CEINCLUDE}/${TARGETCPU}"
		    fi
		    CELIBPATH="${SDKROOT}/${OSVERSION}/${PLATFORM}/Lib/${TARGETCPU}"
    		fi
	    fi

	    if test "$GCC" != "yes" ; then
	        if test "${SHARED_BUILD}" = "0" ; then
		    runtime=-MT
	        else
		    runtime=-MD
	        fi

                if test "$do64bit" != "no" ; then
		    # All this magic is necessary for the Win64 SDK RC1 - hobbs
		    CC="\"${PATH64}/cl.exe\""
		    CFLAGS="${CFLAGS} -I\"${MSSDK}/Include\" -I\"${MSSDK}/Include/crt\" -I\"${MSSDK}/Include/crt/sys\""
		    RC="\"${MSSDK}/bin/rc.exe\""
		    lflags="-nologo -MACHINE:${MACHINE} -LIBPATH:\"${MSSDK}/Lib/${MACHINE}\""
		    LINKBIN="\"${PATH64}/link.exe\""
		    CFLAGS_DEBUG="-nologo -Zi -Od -W3 ${runtime}d"
		    CFLAGS_OPTIMIZE="-nologo -O2 -W2 ${runtime}"
		    # Avoid 'unresolved external symbol __security_cookie'
		    # errors, c.f. http://support.microsoft.com/?id=894573
		    TEA_ADD_LIBS([bufferoverflowU.lib])
		elif test "$doWince" != "no" ; then
		    CEBINROOT="${WCEROOT}/EVC/${OSVERSION}/bin"
		    if test "${TARGETCPU}" = "X86"; then
			CC="\"${CEBINROOT}/cl.exe\""
		    else
			CC="\"${CEBINROOT}/cl${ARCH}.exe\""
		    fi
		    CFLAGS="$CFLAGS -I\"${CELIB_DIR}/inc\" -I\"${CEINCLUDE}\""
		    RC="\"${WCEROOT}/Common/EVC/bin/rc.exe\""
		    arch=`echo ${ARCH} | awk '{print tolower([$]0)}'`
		    defs="${ARCH} _${ARCH}_ ${arch} PALM_SIZE _MT _WINDOWS"
		    if test "${SHARED_BUILD}" = "1" ; then
			# Static CE builds require static celib as well
		    	defs="${defs} _DLL"
		    fi
		    for i in $defs ; do
			AC_DEFINE_UNQUOTED($i, 1, [WinCE def ]$i)
		    done
		    AC_DEFINE_UNQUOTED(_WIN32_WCE, $CEVERSION, [_WIN32_WCE version])
		    AC_DEFINE_UNQUOTED(UNDER_CE, $CEVERSION, [UNDER_CE version])
		    CFLAGS_DEBUG="-nologo -Zi -Od"
		    CFLAGS_OPTIMIZE="-nologo -Ox"
		    lversion=`echo ${CEVERSION} | sed -e 's/\(.\)\(..\)/\1\.\2/'`
		    lflags="-MACHINE:${ARCH} -LIBPATH:\"${CELIBPATH}\" -subsystem:windowsce,${lversion} -nologo"
		    LINKBIN="\"${CEBINROOT}/link.exe\""
		    AC_SUBST(CELIB_DIR)
		else
		    RC="rc"
		    lflags="-nologo"
    		    LINKBIN="link"
		    CFLAGS_DEBUG="-nologo -Z7 -Od -W3 -WX ${runtime}d"
		    CFLAGS_OPTIMIZE="-nologo -O2 -W2 ${runtime}"
		fi
	    fi

	    if test "$GCC" = "yes"; then
		# mingw gcc mode
		AC_CHECK_TOOL(RC, windres)
		CFLAGS_DEBUG="-g"
		CFLAGS_OPTIMIZE="-O2 -fomit-frame-pointer"
		SHLIB_LD='${CC} -shared'
		UNSHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.a'
		LDFLAGS_CONSOLE="-wl,--subsystem,console ${lflags}"
		LDFLAGS_WINDOW="-wl,--subsystem,windows ${lflags}"

		AC_CACHE_CHECK(for cross-compile version of gcc,
			ac_cv_cross,
			AC_TRY_COMPILE([
			    #ifdef __WIN32__
				#error cross-compiler
			    #endif
			], [],
			ac_cv_cross=yes,
			ac_cv_cross=no)
		      )
		
		      if test "$ac_cv_cross" = "yes"; then
			case "$do64bit" in
			    amd64|x64|yes)
				CC="x86_64-w64-mingw32-gcc"
				LD="x86_64-w64-mingw32-ld"
				AR="x86_64-w64-mingw32-ar"
				RANLIB="x86_64-w64-mingw32-ranlib"
				RC="x86_64-w64-mingw32-windres"
			    ;;
			    *)
				CC="i686-w64-mingw32-gcc"
				LD="i686-w64-mingw32-ld"
				AR="i686-w64-mingw32-ar"
				RANLIB="i686-w64-mingw32-ranlib"
				RC="i686-w64-mingw32-windres"
			    ;;
			esac
		fi

	    else
		SHLIB_LD="${LINKBIN} -dll ${lflags}"
		# link -lib only works when -lib is the first arg
		STLIB_LD="${LINKBIN} -lib ${lflags}"
		UNSHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.lib'
		PATHTYPE=-w
		# For information on what debugtype is most useful, see:
		# http://msdn.microsoft.com/library/en-us/dnvc60/html/gendepdebug.asp
		# and also
		# http://msdn2.microsoft.com/en-us/library/y0zzbyt4%28VS.80%29.aspx
		# This essentially turns it all on.
		LDFLAGS_DEBUG="-debug -debugtype:cv"
		LDFLAGS_OPTIMIZE="-release"
		if test "$doWince" != "no" ; then
		    LDFLAGS_CONSOLE="-link ${lflags}"
		    LDFLAGS_WINDOW=${LDFLAGS_CONSOLE}
		else
		    LDFLAGS_CONSOLE="-link -subsystem:console ${lflags}"
		    LDFLAGS_WINDOW="-link -subsystem:windows ${lflags}"
		fi
	    fi

	    SHLIB_SUFFIX=".dll"
	    SHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.dll'

	    TCL_LIB_VERSIONS_OK=nodots
    	    ;;
	AIX-*)
	    AS_IF([test "${TCL_THREADS}" = "1" -a "$GCC" != "yes"], [
		# AIX requires the _r compiler when gcc isn't being used
		case "${CC}" in
		    *_r|*_r\ *)
			# ok ...
			;;
		    *)
			# Make sure only first arg gets _r
		    	CC=`echo "$CC" | sed -e 's/^\([[^ ]]*\)/\1_r/'`
			;;
		esac
		AC_MSG_RESULT([Using $CC for compiling with threads])
	    ])
	    LIBS="$LIBS -lc"
	    SHLIB_CFLAGS=""
	    SHLIB_SUFFIX=".so"

	    LD_LIBRARY_PATH_VAR="LIBPATH"

	    # Check to enable 64-bit flags for compiler/linker
	    AS_IF([test "$do64bit" = yes], [
		AS_IF([test "$GCC" = yes], [
		    AC_MSG_WARN([64bit mode not supported with GCC on $system])
		], [
		    do64bit_ok=yes
		    CFLAGS="$CFLAGS -q64"
		    LDFLAGS_ARCH="-q64"
		    RANLIB="${RANLIB} -X64"
		    AR="${AR} -X64"
		    SHLIB_LD_FLAGS="-b64"
		])
	    ])

	    AS_IF([test "`uname -m`" = ia64], [
		# AIX-5 uses ELF style dynamic libraries on IA-64, but not PPC
		SHLIB_LD="/usr/ccs/bin/ld -G -z text"
		AS_IF([test "$GCC" = yes], [
		    CC_SEARCH_FLAGS='-Wl,-R,${LIB_RUNTIME_DIR}'
		], [
		    CC_SEARCH_FLAGS='-R${LIB_RUNTIME_DIR}'
		])
		LD_SEARCH_FLAGS='-R ${LIB_RUNTIME_DIR}'
	    ], [
		AS_IF([test "$GCC" = yes], [
		    SHLIB_LD='${CC} -shared -Wl,-bexpall'
		], [
		    SHLIB_LD="/bin/ld -bhalt:4 -bM:SRE -bexpall -H512 -T512 -bnoentry"
		    LDFLAGS="$LDFLAGS -brtl"
		])
		SHLIB_LD="${SHLIB_LD} ${SHLIB_LD_FLAGS}"
		CC_SEARCH_FLAGS='-L${LIB_RUNTIME_DIR}'
		LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
	    ])
	    ;;
	BeOS*)
	    SHLIB_CFLAGS="-fPIC"
	    SHLIB_LD='${CC} -nostart'
	    SHLIB_SUFFIX=".so"

	    #-----------------------------------------------------------
	    # Check for inet_ntoa in -lbind, for BeOS (which also needs
	    # -lsocket, even if the network functions are in -lnet which
	    # is always linked to, for compatibility.
	    #-----------------------------------------------------------
	    AC_CHECK_LIB(bind, inet_ntoa, [LIBS="$LIBS -lbind -lsocket"])
	    ;;
	BSD/OS-4.*)
	    SHLIB_CFLAGS="-export-dynamic -fPIC"
	    SHLIB_LD='${CC} -shared'
	    SHLIB_SUFFIX=".so"
	    LDFLAGS="$LDFLAGS -export-dynamic"
	    CC_SEARCH_FLAGS=""
	    LD_SEARCH_FLAGS=""
	    ;;
	CYGWIN_*)
	    SHLIB_CFLAGS=""
	    SHLIB_LD='${CC} -shared'
	    SHLIB_SUFFIX=".dll"
	    EXEEXT=".exe"
	    CC_SEARCH_FLAGS=""
	    LD_SEARCH_FLAGS=""
	    ;;
	Haiku*)
	    LDFLAGS="$LDFLAGS -Wl,--export-dynamic"
	    SHLIB_CFLAGS="-fPIC"
	    SHLIB_SUFFIX=".so"
	    SHLIB_LD='${CC} -shared ${CFLAGS} ${LDFLAGS}'
	    AC_CHECK_LIB(network, inet_ntoa, [LIBS="$LIBS -lnetwork"])
	    ;;
	HP-UX-*.11.*)
	    # Use updated header definitions where possible
	    AC_DEFINE(_XOPEN_SOURCE_EXTENDED, 1, [Do we want to use the XOPEN network library?])
	    # TEA specific: Needed by Tcl, but not most extensions
	    #AC_DEFINE(_XOPEN_SOURCE, 1, [Do we want to use the XOPEN network library?])
	    #LIBS="$LIBS -lxnet"               # Use the XOPEN network library

	    AS_IF([test "`uname -m`" = ia64], [
		SHLIB_SUFFIX=".so"
		# Use newer C++ library for C++ extensions
		#if test "$GCC" != "yes" ; then
		#   CPPFLAGS="-AA"
		#fi
	    ], [
		SHLIB_SUFFIX=".sl"
	    ])
	    AC_CHECK_LIB(dld, shl_load, tcl_ok=yes, tcl_ok=no)
	    AS_IF([test "$tcl_ok" = yes], [
		LDFLAGS="$LDFLAGS -Wl,-E"
		CC_SEARCH_FLAGS='-Wl,+s,+b,${LIB_RUNTIME_DIR}:.'
		LD_SEARCH_FLAGS='+s +b ${LIB_RUNTIME_DIR}:.'
		LD_LIBRARY_PATH_VAR="SHLIB_PATH"
	    ])
	    AS_IF([test "$GCC" = yes], [
		SHLIB_LD='${CC} -shared'
		LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
	    ], [
		CFLAGS="$CFLAGS -z"
		# Users may want PA-RISC 1.1/2.0 portable code - needs HP cc
		#CFLAGS="$CFLAGS +DAportable"
		SHLIB_CFLAGS="+z"
		SHLIB_LD="ld -b"
	    ])

	    # Check to enable 64-bit flags for compiler/linker
	    AS_IF([test "$do64bit" = "yes"], [
		AS_IF([test "$GCC" = yes], [
		    case `${CC} -dumpmachine` in
			hppa64*)
			    # 64-bit gcc in use.  Fix flags for GNU ld.
			    do64bit_ok=yes
			    SHLIB_LD='${CC} -shared'
			    AS_IF([test $doRpath = yes], [
				CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'])
			    LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
			    ;;
			*)
			    AC_MSG_WARN([64bit mode not supported with GCC on $system])
			    ;;
		    esac
		], [
		    do64bit_ok=yes
		    CFLAGS="$CFLAGS +DD64"
		    LDFLAGS_ARCH="+DD64"
		])
	    ]) ;;
	IRIX-6.*)
	    SHLIB_CFLAGS=""
	    SHLIB_LD="ld -n32 -shared -rdata_shared"
	    SHLIB_SUFFIX=".so"
	    AS_IF([test $doRpath = yes], [
		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'
		LD_SEARCH_FLAGS='-rpath ${LIB_RUNTIME_DIR}'])
	    AS_IF([test "$GCC" = yes], [
		CFLAGS="$CFLAGS -mabi=n32"
		LDFLAGS="$LDFLAGS -mabi=n32"
	    ], [
		case $system in
		    IRIX-6.3)
			# Use to build 6.2 compatible binaries on 6.3.
			CFLAGS="$CFLAGS -n32 -D_OLD_TERMIOS"
			;;
		    *)
			CFLAGS="$CFLAGS -n32"
			;;
		esac
		LDFLAGS="$LDFLAGS -n32"
	    ])
	    ;;
	IRIX64-6.*)
	    SHLIB_CFLAGS=""
	    SHLIB_LD="ld -n32 -shared -rdata_shared"
	    SHLIB_SUFFIX=".so"
	    AS_IF([test $doRpath = yes], [
		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'
		LD_SEARCH_FLAGS='-rpath ${LIB_RUNTIME_DIR}'])

	    # Check to enable 64-bit flags for compiler/linker

	    AS_IF([test "$do64bit" = yes], [
	        AS_IF([test "$GCC" = yes], [
	            AC_MSG_WARN([64bit mode not supported by gcc])
	        ], [
	            do64bit_ok=yes
	            SHLIB_LD="ld -64 -shared -rdata_shared"
	            CFLAGS="$CFLAGS -64"
	            LDFLAGS_ARCH="-64"
	        ])
	    ])
	    ;;
	Linux*)
	    SHLIB_CFLAGS="-fPIC"
	    SHLIB_SUFFIX=".so"

	    # TEA specific:
	    CFLAGS_OPTIMIZE="-O2 -fomit-frame-pointer"

	    # TEA specific: use LDFLAGS_DEFAULT instead of LDFLAGS
	    SHLIB_LD='${CC} -shared ${CFLAGS} ${LDFLAGS_DEFAULT}'
	    LDFLAGS="$LDFLAGS -Wl,--export-dynamic"
	    AS_IF([test $doRpath = yes], [
		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'])
	    LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
	    AS_IF([test "`uname -m`" = "alpha"], [CFLAGS="$CFLAGS -mieee"])
	    AS_IF([test $do64bit = yes], [
		AC_CACHE_CHECK([if compiler accepts -m64 flag], tcl_cv_cc_m64, [
		    hold_cflags=$CFLAGS
		    CFLAGS="$CFLAGS -m64"
		    AC_TRY_LINK(,, tcl_cv_cc_m64=yes, tcl_cv_cc_m64=no)
		    CFLAGS=$hold_cflags])
		AS_IF([test $tcl_cv_cc_m64 = yes], [
		    CFLAGS="$CFLAGS -m64"
		    do64bit_ok=yes
		])
	   ])

	    # The combo of gcc + glibc has a bug related to inlining of
	    # functions like strtod(). The -fno-builtin flag should address
	    # this problem but it does not work. The -fno-inline flag is kind
	    # of overkill but it works. Disable inlining only when one of the
	    # files in compat/*.c is being linked in.

	    AS_IF([test x"${USE_COMPAT}" != x],[CFLAGS="$CFLAGS -fno-inline"])

	    ;;
	GNU*)
	    SHLIB_CFLAGS="-fPIC"
	    SHLIB_SUFFIX=".so"

	    SHLIB_LD='${CC} -shared'
	    LDFLAGS="$LDFLAGS -Wl,--export-dynamic"
	    CC_SEARCH_FLAGS=""
	    LD_SEARCH_FLAGS=""
	    AS_IF([test "`uname -m`" = "alpha"], [CFLAGS="$CFLAGS -mieee"])
	    ;;
	Lynx*)
	    SHLIB_CFLAGS="-fPIC"
	    SHLIB_SUFFIX=".so"
	    CFLAGS_OPTIMIZE=-02
	    SHLIB_LD='${CC} -shared'
	    LD_FLAGS="-Wl,--export-dynamic"
	    AS_IF([test $doRpath = yes], [
		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'
		LD_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'])
	    ;;
	OpenBSD-*)
	    arch=`arch -s`
	    case "$arch" in
	    m88k|vax)
		SHLIB_SUFFIX=""
		SHARED_LIB_SUFFIX=""
		;;
	    *)
		SHLIB_CFLAGS="-fPIC"
		SHLIB_LD='${CC} -shared ${SHLIB_CFLAGS}'
		SHLIB_SUFFIX=".so"
		AS_IF([test $doRpath = yes], [
		    CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'])
		LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
		SHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.so.${SHLIB_VERSION}'
		;;
	    esac
	    case "$arch" in
	    m88k|vax)
		CFLAGS_OPTIMIZE="-O1"
		;;
	    *)
		CFLAGS_OPTIMIZE="-O2"
		;;
	    esac
	    AC_CACHE_CHECK([for ELF], tcl_cv_ld_elf, [
		AC_EGREP_CPP(yes, [
#ifdef __ELF__
	yes
#endif
		], tcl_cv_ld_elf=yes, tcl_cv_ld_elf=no)])
	    AS_IF([test $tcl_cv_ld_elf = yes], [
		LDFLAGS=-Wl,-export-dynamic
	    ], [LDFLAGS=""])
	    AS_IF([test "${TCL_THREADS}" = "1"], [
		# On OpenBSD:	Compile with -pthread
		#		Don't link with -lpthread
		LIBS=`echo $LIBS | sed s/-lpthread//`
		CFLAGS="$CFLAGS -pthread"
	    ])
	    # OpenBSD doesn't do version numbers with dots.
	    UNSHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.a'
	    TCL_LIB_VERSIONS_OK=nodots
	    ;;
	NetBSD-*|FreeBSD-[[3-4]].*)
	    # FreeBSD 3.* and greater have ELF.
	    # NetBSD 2.* has ELF and can use 'cc -shared' to build shared libs
	    SHLIB_CFLAGS="-fPIC"
	    SHLIB_LD='${CC} -shared ${SHLIB_CFLAGS}'
	    SHLIB_SUFFIX=".so"
	    LDFLAGS="$LDFLAGS -export-dynamic"
	    AS_IF([test $doRpath = yes], [
		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'])
	    LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
	    AS_IF([test "${TCL_THREADS}" = "1"], [
		# The -pthread needs to go in the CFLAGS, not LIBS
		LIBS=`echo $LIBS | sed s/-pthread//`
		CFLAGS="$CFLAGS -pthread"
	    	LDFLAGS="$LDFLAGS -pthread"
	    ])
	    case $system in
	    FreeBSD-3.*)
	    	# FreeBSD-3 doesn't handle version numbers with dots.
	    	UNSHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.a'
	    	SHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.so'
	    	TCL_LIB_VERSIONS_OK=nodots
		;;
	    esac
	    ;;
	FreeBSD-*)
	    # This configuration from FreeBSD Ports.
	    SHLIB_CFLAGS="-fPIC"
	    SHLIB_LD="${CC} -shared"
	    TCL_SHLIB_LD_EXTRAS="-soname \$[@]"
	    SHLIB_SUFFIX=".so"
	    LDFLAGS=""
	    AS_IF([test $doRpath = yes], [
		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'
		LD_SEARCH_FLAGS='-rpath ${LIB_RUNTIME_DIR}'])
	    AS_IF([test "${TCL_THREADS}" = "1"], [
		# The -pthread needs to go in the LDFLAGS, not LIBS
		LIBS=`echo $LIBS | sed s/-pthread//`
		CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
		LDFLAGS="$LDFLAGS $PTHREAD_LIBS"])
	    # Version numbers are dot-stripped by system policy.
	    TCL_TRIM_DOTS=`echo ${VERSION} | tr -d .`
	    UNSHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}.a'
	    SHARED_LIB_SUFFIX='${TCL_TRIM_DOTS}\$\{DBGX\}.so.1'
	    TCL_LIB_VERSIONS_OK=nodots
	    ;;
	Darwin-*)
	    CFLAGS_OPTIMIZE="-Os"
	    SHLIB_CFLAGS="-fno-common"
	    # To avoid discrepancies between what headers configure sees during
	    # preprocessing tests and compiling tests, move any -isysroot and
	    # -mmacosx-version-min flags from CFLAGS to CPPFLAGS:
	    CPPFLAGS="${CPPFLAGS} `echo " ${CFLAGS}" | \
		awk 'BEGIN {FS=" +-";ORS=" "}; {for (i=2;i<=NF;i++) \
		if ([$]i~/^(isysroot|mmacosx-version-min)/) print "-"[$]i}'`"
	    CFLAGS="`echo " ${CFLAGS}" | \
		awk 'BEGIN {FS=" +-";ORS=" "}; {for (i=2;i<=NF;i++) \
		if (!([$]i~/^(isysroot|mmacosx-version-min)/)) print "-"[$]i}'`"
	    AS_IF([test $do64bit = yes], [
		case `arch` in
		    ppc)
			AC_CACHE_CHECK([if compiler accepts -arch ppc64 flag],
				tcl_cv_cc_arch_ppc64, [
			    hold_cflags=$CFLAGS
			    CFLAGS="$CFLAGS -arch ppc64 -mpowerpc64 -mcpu=G5"
			    AC_TRY_LINK(,, tcl_cv_cc_arch_ppc64=yes,
				    tcl_cv_cc_arch_ppc64=no)
			    CFLAGS=$hold_cflags])
			AS_IF([test $tcl_cv_cc_arch_ppc64 = yes], [
			    CFLAGS="$CFLAGS -arch ppc64 -mpowerpc64 -mcpu=G5"
			    do64bit_ok=yes
			]);;
		    i386)
			AC_CACHE_CHECK([if compiler accepts -arch x86_64 flag],
				tcl_cv_cc_arch_x86_64, [
			    hold_cflags=$CFLAGS
			    CFLAGS="$CFLAGS -arch x86_64"
			    AC_TRY_LINK(,, tcl_cv_cc_arch_x86_64=yes,
				    tcl_cv_cc_arch_x86_64=no)
			    CFLAGS=$hold_cflags])
			AS_IF([test $tcl_cv_cc_arch_x86_64 = yes], [
			    CFLAGS="$CFLAGS -arch x86_64"
			    do64bit_ok=yes
			]);;
		    *)
			AC_MSG_WARN([Don't know how enable 64-bit on architecture `arch`]);;
		esac
	    ], [
		# Check for combined 32-bit and 64-bit fat build
		AS_IF([echo "$CFLAGS " |grep -E -q -- '-arch (ppc64|x86_64) ' \
		    && echo "$CFLAGS " |grep -E -q -- '-arch (ppc|i386) '], [
		    fat_32_64=yes])
	    ])
	    # TEA specific: use LDFLAGS_DEFAULT instead of LDFLAGS
	    SHLIB_LD='${CC} -dynamiclib ${CFLAGS} ${LDFLAGS_DEFAULT}'
	    AC_CACHE_CHECK([if ld accepts -single_module flag], tcl_cv_ld_single_module, [
		hold_ldflags=$LDFLAGS
		LDFLAGS="$LDFLAGS -dynamiclib -Wl,-single_module"
		AC_TRY_LINK(, [int i;], tcl_cv_ld_single_module=yes, tcl_cv_ld_single_module=no)
		LDFLAGS=$hold_ldflags])
	    AS_IF([test $tcl_cv_ld_single_module = yes], [
		SHLIB_LD="${SHLIB_LD} -Wl,-single_module"
	    ])
	    # TEA specific: link shlib with current and compatiblity version flags
	    vers=`echo ${PACKAGE_VERSION} | sed -e 's/^\([[0-9]]\{1,5\}\)\(\(\.[[0-9]]\{1,3\}\)\{0,2\}\).*$/\1\2/p' -e d`
	    SHLIB_LD="${SHLIB_LD} -current_version ${vers:-0} -compatibility_version ${vers:-0}"
	    SHLIB_SUFFIX=".dylib"
	    # Don't use -prebind when building for Mac OS X 10.4 or later only:
	    AS_IF([test "`echo "${MACOSX_DEPLOYMENT_TARGET}" | awk -F '10\\.' '{print int([$]2)}'`" -lt 4 -a \
		"`echo "${CPPFLAGS}" | awk -F '-mmacosx-version-min=10\\.' '{print int([$]2)}'`" -lt 4], [
		LDFLAGS="$LDFLAGS -prebind"])
	    LDFLAGS="$LDFLAGS -headerpad_max_install_names"
	    AC_CACHE_CHECK([if ld accepts -search_paths_first flag],
		    tcl_cv_ld_search_paths_first, [
		hold_ldflags=$LDFLAGS
		LDFLAGS="$LDFLAGS -Wl,-search_paths_first"
		AC_TRY_LINK(, [int i;], tcl_cv_ld_search_paths_first=yes,
			tcl_cv_ld_search_paths_first=no)
		LDFLAGS=$hold_ldflags])
	    AS_IF([test $tcl_cv_ld_search_paths_first = yes], [
		LDFLAGS="$LDFLAGS -Wl,-search_paths_first"
	    ])
	    AS_IF([test "$tcl_cv_cc_visibility_hidden" != yes], [
		AC_DEFINE(MODULE_SCOPE, [__private_extern__],
		    [Compiler support for module scope symbols])
		tcl_cv_cc_visibility_hidden=yes
	    ])
	    CC_SEARCH_FLAGS=""
	    LD_SEARCH_FLAGS=""
	    LD_LIBRARY_PATH_VAR="DYLD_LIBRARY_PATH"
	    # TEA specific: for combined 32 & 64 bit fat builds of Tk
	    # extensions, verify that 64-bit build is possible.
	    AS_IF([test "$fat_32_64" = yes && test -n "${TK_BIN_DIR}"], [
		AS_IF([test "${TEA_WINDOWINGSYSTEM}" = x11], [
		    AC_CACHE_CHECK([for 64-bit X11], tcl_cv_lib_x11_64, [
			for v in CFLAGS CPPFLAGS LDFLAGS; do
			    eval 'hold_'$v'="$'$v'";'$v'="`echo "$'$v' "|sed -e "s/-arch ppc / /g" -e "s/-arch i386 / /g"`"'
			done
			CPPFLAGS="$CPPFLAGS -I/usr/X11R6/include"
			LDFLAGS="$LDFLAGS -L/usr/X11R6/lib -lX11"
			AC_TRY_LINK([#include <X11/Xlib.h>], [XrmInitialize();],
			    tcl_cv_lib_x11_64=yes, tcl_cv_lib_x11_64=no)
			for v in CFLAGS CPPFLAGS LDFLAGS; do
			    eval $v'="$hold_'$v'"'
			done])
		])
		AS_IF([test "${TEA_WINDOWINGSYSTEM}" = aqua], [
		    AC_CACHE_CHECK([for 64-bit Tk], tcl_cv_lib_tk_64, [
			for v in CFLAGS CPPFLAGS LDFLAGS; do
			    eval 'hold_'$v'="$'$v'";'$v'="`echo "$'$v' "|sed -e "s/-arch ppc / /g" -e "s/-arch i386 / /g"`"'
			done
			CPPFLAGS="$CPPFLAGS -DUSE_TCL_STUBS=1 -DUSE_TK_STUBS=1 ${TCL_INCLUDES} ${TK_INCLUDES}"
			LDFLAGS="$LDFLAGS ${TCL_STUB_LIB_SPEC} ${TK_STUB_LIB_SPEC}"
			AC_TRY_LINK([#include <tk.h>], [Tk_InitStubs(NULL, "", 0);],
			    tcl_cv_lib_tk_64=yes, tcl_cv_lib_tk_64=no)
			for v in CFLAGS CPPFLAGS LDFLAGS; do
			    eval $v'="$hold_'$v'"'
			done])
		])
		# remove 64-bit arch flags from CFLAGS et al. if configuration
		# does not support 64-bit.
		AS_IF([test "$tcl_cv_lib_tk_64" = no -o "$tcl_cv_lib_x11_64" = no], [
		    AC_MSG_NOTICE([Removing 64-bit architectures from compiler & linker flags])
		    for v in CFLAGS CPPFLAGS LDFLAGS; do
			eval $v'="`echo "$'$v' "|sed -e "s/-arch ppc64 / /g" -e "s/-arch x86_64 / /g"`"'
		    done])
	    ])
	    ;;
	OS/390-*)
	    CFLAGS_OPTIMIZE=""		# Optimizer is buggy
	    AC_DEFINE(_OE_SOCKETS, 1,	# needed in sys/socket.h
		[Should OS/390 do the right thing with sockets?])
	    ;;
	OSF1-V*)
	    # Digital OSF/1
	    SHLIB_CFLAGS=""
	    AS_IF([test "$SHARED_BUILD" = 1], [
	        SHLIB_LD='ld -shared -expect_unresolved "*"'
	    ], [
	        SHLIB_LD='ld -non_shared -expect_unresolved "*"'
	    ])
	    SHLIB_SUFFIX=".so"
	    AS_IF([test $doRpath = yes], [
		CC_SEARCH_FLAGS='-Wl,-rpath,${LIB_RUNTIME_DIR}'
		LD_SEARCH_FLAGS='-rpath ${LIB_RUNTIME_DIR}'])
	    AS_IF([test "$GCC" = yes], [CFLAGS="$CFLAGS -mieee"], [
		CFLAGS="$CFLAGS -DHAVE_TZSET -std1 -ieee"])
	    # see pthread_intro(3) for pthread support on osf1, k.furukawa
	    AS_IF([test "${TCL_THREADS}" = 1], [
		CFLAGS="$CFLAGS -DHAVE_PTHREAD_ATTR_SETSTACKSIZE"
		CFLAGS="$CFLAGS -DTCL_THREAD_STACK_MIN=PTHREAD_STACK_MIN*64"
		LIBS=`echo $LIBS | sed s/-lpthreads//`
		AS_IF([test "$GCC" = yes], [
		    LIBS="$LIBS -lpthread -lmach -lexc"
		], [
		    CFLAGS="$CFLAGS -pthread"
		    LDFLAGS="$LDFLAGS -pthread"
		])
	    ])
	    ;;
	QNX-6*)
	    # QNX RTP
	    # This may work for all QNX, but it was only reported for v6.
	    SHLIB_CFLAGS="-fPIC"
	    SHLIB_LD="ld -Bshareable -x"
	    SHLIB_LD_LIBS=""
	    SHLIB_SUFFIX=".so"
	    CC_SEARCH_FLAGS=""
	    LD_SEARCH_FLAGS=""
	    ;;
	SCO_SV-3.2*)
	    AS_IF([test "$GCC" = yes], [
		SHLIB_CFLAGS="-fPIC -melf"
		LDFLAGS="$LDFLAGS -melf -Wl,-Bexport"
	    ], [
	       SHLIB_CFLAGS="-Kpic -belf"
	       LDFLAGS="$LDFLAGS -belf -Wl,-Bexport"
	    ])
	    SHLIB_LD="ld -G"
	    SHLIB_LD_LIBS=""
	    SHLIB_SUFFIX=".so"
	    CC_SEARCH_FLAGS=""
	    LD_SEARCH_FLAGS=""
	    ;;
	SunOS-5.[[0-6]])
	    # Careful to not let 5.10+ fall into this case

	    # Note: If _REENTRANT isn't defined, then Solaris
	    # won't define thread-safe library routines.

	    AC_DEFINE(_REENTRANT, 1, [Do we want the reentrant OS API?])
	    AC_DEFINE(_POSIX_PTHREAD_SEMANTICS, 1,
		[Do we really want to follow the standard? Yes we do!])

	    SHLIB_CFLAGS="-KPIC"
	    SHLIB_SUFFIX=".so"
	    AS_IF([test "$GCC" = yes], [
		SHLIB_LD='${CC} -shared'
		CC_SEARCH_FLAGS='-Wl,-R,${LIB_RUNTIME_DIR}'
		LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
	    ], [
		SHLIB_LD="/usr/ccs/bin/ld -G -z text"
		CC_SEARCH_FLAGS='-R ${LIB_RUNTIME_DIR}'
		LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
	    ])
	    ;;
	SunOS-5*)
	    # Note: If _REENTRANT isn't defined, then Solaris
	    # won't define thread-safe library routines.

	    AC_DEFINE(_REENTRANT, 1, [Do we want the reentrant OS API?])
	    AC_DEFINE(_POSIX_PTHREAD_SEMANTICS, 1,
		[Do we really want to follow the standard? Yes we do!])

	    SHLIB_CFLAGS="-KPIC"

	    # Check to enable 64-bit flags for compiler/linker
	    AS_IF([test "$do64bit" = yes], [
		arch=`isainfo`
		AS_IF([test "$arch" = "sparcv9 sparc"], [
		    AS_IF([test "$GCC" = yes], [
			AS_IF([test "`${CC} -dumpversion | awk -F. '{print [$]1}'`" -lt 3], [
			    AC_MSG_WARN([64bit mode not supported with GCC < 3.2 on $system])
			], [
			    do64bit_ok=yes
			    CFLAGS="$CFLAGS -m64 -mcpu=v9"
			    LDFLAGS="$LDFLAGS -m64 -mcpu=v9"
			    SHLIB_CFLAGS="-fPIC"
			])
		    ], [
			do64bit_ok=yes
			AS_IF([test "$do64bitVIS" = yes], [
			    CFLAGS="$CFLAGS -xarch=v9a"
			    LDFLAGS_ARCH="-xarch=v9a"
			], [
			    CFLAGS="$CFLAGS -xarch=v9"
			    LDFLAGS_ARCH="-xarch=v9"
			])
			# Solaris 64 uses this as well
			#LD_LIBRARY_PATH_VAR="LD_LIBRARY_PATH_64"
		    ])
		], [AS_IF([test "$arch" = "amd64 i386"], [
		    AS_IF([test "$GCC" = yes], [
			case $system in
			    SunOS-5.1[[1-9]]*|SunOS-5.[[2-9]][[0-9]]*)
				do64bit_ok=yes
				CFLAGS="$CFLAGS -m64"
				LDFLAGS="$LDFLAGS -m64";;
			    *)
				AC_MSG_WARN([64bit mode not supported with GCC on $system]);;
			esac
		    ], [
			do64bit_ok=yes
			case $system in
			    SunOS-5.1[[1-9]]*|SunOS-5.[[2-9]][[0-9]]*)
				CFLAGS="$CFLAGS -m64"
				LDFLAGS="$LDFLAGS -m64";;
			    *)
				CFLAGS="$CFLAGS -xarch=amd64"
				LDFLAGS="$LDFLAGS -xarch=amd64";;
			esac
		    ])
		], [AC_MSG_WARN([64bit mode not supported for $arch])])])
	    ])

	    SHLIB_SUFFIX=".so"
	    AS_IF([test "$GCC" = yes], [
		SHLIB_LD='${CC} -shared'
		CC_SEARCH_FLAGS='-Wl,-R,${LIB_RUNTIME_DIR}'
		LD_SEARCH_FLAGS=${CC_SEARCH_FLAGS}
		AS_IF([test "$do64bit_ok" = yes], [
		    AS_IF([test "$arch" = "sparcv9 sparc"], [
			# We need to specify -static-libgcc or we need to
			# add the path to the sparv9 libgcc.
			# JH: static-libgcc is necessary for core Tcl, but may
			# not be necessary for extensions.
			SHLIB_LD="$SHLIB_LD -m64 -mcpu=v9 -static-libgcc"
			# for finding sparcv9 libgcc, get the regular libgcc
			# path, remove so name and append 'sparcv9'
			#v9gcclibdir="`gcc -print-file-name=libgcc_s.so` | ..."
			#CC_SEARCH_FLAGS="${CC_SEARCH_FLAGS},-R,$v9gcclibdir"
		    ], [AS_IF([test "$arch" = "amd64 i386"], [
			# JH: static-libgcc is necessary for core Tcl, but may
			# not be necessary for extensions.
			SHLIB_LD="$SHLIB_LD -m64 -static-libgcc"
		    ])])
		])
	    ], [
		case $system in
		    SunOS-5.[[1-9]][[0-9]]*)
			# TEA specific: use LDFLAGS_DEFAULT instead of LDFLAGS
			SHLIB_LD='${CC} -G -z text ${LDFLAGS_DEFAULT}';;
		    *)
			SHLIB_LD='/usr/ccs/bin/ld -G -z text';;
		esac
		CC_SEARCH_FLAGS='-Wl,-R,${LIB_RUNTIME_DIR}'
		LD_SEARCH_FLAGS='-R ${LIB_RUNTIME_DIR}'
	    ])
	    ;;
    esac

    AS_IF([test "$do64bit" = yes -a "$do64bit_ok" = no], [
	AC_MSG_WARN([64bit support being disabled -- don't know magic for this platform])
    ])

dnl # Add any CPPFLAGS set in the environment to our CFLAGS, but delay doing so
dnl # until the end of configure, as configure's compile and link tests use
dnl # both CPPFLAGS and CFLAGS (unlike our compile and link) but configure's
dnl # preprocessing tests use only CPPFLAGS.
    AC_CONFIG_COMMANDS_PRE([CFLAGS="${CFLAGS} ${CPPFLAGS}"; CPPFLAGS=""])

    # Add in the arch flags late to ensure it wasn't removed.
    # Not necessary in TEA, but this is aligned with core
    LDFLAGS="$LDFLAGS $LDFLAGS_ARCH"

    # If we're running gcc, then change the C flags for compiling shared
    # libraries to the right flags for gcc, instead of those for the
    # standard manufacturer compiler.

    AS_IF([test "$GCC" = yes], [
	case $system in
	    AIX-*) ;;
	    BSD/OS*) ;;
	    CYGWIN_*) ;;
	    IRIX*) ;;
	    NetBSD-*|FreeBSD-*|OpenBSD-*) ;;
	    Darwin-*) ;;
	    SCO_SV-3.2*) ;;
	    windows) ;;
	    *) SHLIB_CFLAGS="-fPIC" ;;
	esac])

    AS_IF([test "$tcl_cv_cc_visibility_hidden" != yes], [
	AC_DEFINE(MODULE_SCOPE, [extern],
	    [No Compiler support for module scope symbols])
	AC_DEFINE(NO_VIZ, [], [No visibility hidden passed to zlib?])
    ])

    AS_IF([test "$SHARED_LIB_SUFFIX" = ""], [
	# TEA specific: use PACKAGE_VERSION instead of VERSION
	SHARED_LIB_SUFFIX='${PACKAGE_VERSION}${SHLIB_SUFFIX}'])
    AS_IF([test "$UNSHARED_LIB_SUFFIX" = ""], [
	# TEA specific: use PACKAGE_VERSION instead of VERSION
	UNSHARED_LIB_SUFFIX='${PACKAGE_VERSION}.a'])

	AC_CACHE_CHECK(for SEH support in compiler,
	    tcl_cv_seh,
	AC_TRY_RUN([
	    #define WIN32_LEAN_AND_MEAN
	    #include <windows.h>
	    #undef WIN32_LEAN_AND_MEAN

	    int main(int argc, char** argv) {
		int a, b = 0;
		__try {
		    a = 666 / b;
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
		    return 0;
		}
		return 1;
	    }
	],
	    tcl_cv_seh=yes,
	    tcl_cv_seh=no,
	    tcl_cv_seh=no)
	)
	if test "$tcl_cv_seh" = "no" ; then
	    AC_DEFINE(HAVE_NO_SEH, 1,
		    [Defined when mingw does not support SEH])
	fi

	#
	# Check to see if the excpt.h include file provided contains the
	# definition for EXCEPTION_DISPOSITION; if not, which is the case
	# with Cygwin's version as of 2002-04-10, define it to be int,
	# sufficient for getting the current code to work.
	#
	AC_CACHE_CHECK(for EXCEPTION_DISPOSITION support in include files,
	    tcl_cv_eh_disposition,
	    AC_TRY_COMPILE([
#	    define WIN32_LEAN_AND_MEAN
#	    include <windows.h>
#	    undef WIN32_LEAN_AND_MEAN
	    ],[
		EXCEPTION_DISPOSITION x;
	    ],
		tcl_cv_eh_disposition=yes,
		tcl_cv_eh_disposition=no)
	)
	if test "$tcl_cv_eh_disposition" = "no" ; then
	AC_DEFINE(EXCEPTION_DISPOSITION, int,
		[Defined when cygwin/mingw does not support EXCEPTION DISPOSITION])
	fi

	# Check to see if winnt.h defines CHAR, SHORT, and LONG
	# even if VOID has already been #defined. The win32api
	# used by mingw and cygwin is known to do this.

	AC_CACHE_CHECK(for winnt.h that ignores VOID define,
	    tcl_cv_winnt_ignore_void,
	    AC_TRY_COMPILE([
		#define VOID void
		#define WIN32_LEAN_AND_MEAN
		#include <windows.h>
		#undef WIN32_LEAN_AND_MEAN
	    ], [
		CHAR c;
		SHORT s;
		LONG l;
	    ],
        tcl_cv_winnt_ignore_void=yes,
        tcl_cv_winnt_ignore_void=no)
	)
	if test "$tcl_cv_winnt_ignore_void" = "yes" ; then
	    AC_DEFINE(HAVE_WINNT_IGNORE_VOID, 1,
		    [Defined when cygwin/mingw ignores VOID define in winnt.h])
	fi

	# See if the compiler supports casting to a union type.
	# This is used to stop gcc from printing a compiler
	# warning when initializing a union member.

	AC_CACHE_CHECK(for cast to union support,
	    tcl_cv_cast_to_union,
	    AC_TRY_COMPILE([],
	    [
		  union foo { int i; double d; };
		  union foo f = (union foo) (int) 0;
	    ],
	    tcl_cv_cast_to_union=yes,
	    tcl_cv_cast_to_union=no)
	)
	if test "$tcl_cv_cast_to_union" = "yes"; then
	    AC_DEFINE(HAVE_CAST_TO_UNION, 1,
		    [Defined when compiler supports casting to union type.])
	fi

    AC_SUBST(CFLAGS_DEBUG)
    AC_SUBST(CFLAGS_OPTIMIZE)
    AC_SUBST(CFLAGS_WARNING)

    AC_SUBST(STLIB_LD)
    AC_SUBST(SHLIB_LD)

    AC_SUBST(SHLIB_LD_LIBS)
    AC_SUBST(SHLIB_CFLAGS)

    AC_SUBST(LD_LIBRARY_PATH_VAR)

    # These must be called after we do the basic CFLAGS checks and
    # verify any possible 64-bit or similar switches are necessary
    TEA_TCL_EARLY_FLAGS
    TEA_TCL_64BIT_FLAGS
])

#--------------------------------------------------------------------
# TEA_SERIAL_PORT
#
#	Determine which interface to use to talk to the serial port.
#	Note that #include lines must begin in leftmost column for
#	some compilers to recognize them as preprocessor directives,
#	and some build environments have stdin not pointing at a
#	pseudo-terminal (usually /dev/null instead.)
#
# Arguments:
#	none
#
# Results:
#
#	Defines only one of the following vars:
#		HAVE_SYS_MODEM_H
#		USE_TERMIOS
#		USE_TERMIO
#		USE_SGTTY
#
#--------------------------------------------------------------------

AC_DEFUN([TEA_SERIAL_PORT], [
    AC_CHECK_HEADERS(sys/modem.h)
    AC_CACHE_CHECK([termios vs. termio vs. sgtty], tcl_cv_api_serial, [
    AC_TRY_RUN([
#include <termios.h>

int main() {
    struct termios t;
    if (tcgetattr(0, &t) == 0) {
	cfsetospeed(&t, 0);
	t.c_cflag |= PARENB | PARODD | CSIZE | CSTOPB;
	return 0;
    }
    return 1;
}], tcl_cv_api_serial=termios, tcl_cv_api_serial=no, tcl_cv_api_serial=no)
    if test $tcl_cv_api_serial = no ; then
	AC_TRY_RUN([
#include <termio.h>

int main() {
    struct termio t;
    if (ioctl(0, TCGETA, &t) == 0) {
	t.c_cflag |= CBAUD | PARENB | PARODD | CSIZE | CSTOPB;
	return 0;
    }
    return 1;
}], tcl_cv_api_serial=termio, tcl_cv_api_serial=no, tcl_cv_api_serial=no)
    fi
    if test $tcl_cv_api_serial = no ; then
	AC_TRY_RUN([
#include <sgtty.h>

int main() {
    struct sgttyb t;
    if (ioctl(0, TIOCGETP, &t) == 0) {
	t.sg_ospeed = 0;
	t.sg_flags |= ODDP | EVENP | RAW;
	return 0;
    }
    return 1;
}], tcl_cv_api_serial=sgtty, tcl_cv_api_serial=no, tcl_cv_api_serial=no)
    fi
    if test $tcl_cv_api_serial = no ; then
	AC_TRY_RUN([
#include <termios.h>
#include <errno.h>

int main() {
    struct termios t;
    if (tcgetattr(0, &t) == 0
	|| errno == ENOTTY || errno == ENXIO || errno == EINVAL) {
	cfsetospeed(&t, 0);
	t.c_cflag |= PARENB | PARODD | CSIZE | CSTOPB;
	return 0;
    }
    return 1;
}], tcl_cv_api_serial=termios, tcl_cv_api_serial=no, tcl_cv_api_serial=no)
    fi
    if test $tcl_cv_api_serial = no; then
	AC_TRY_RUN([
#include <termio.h>
#include <errno.h>

int main() {
    struct termio t;
    if (ioctl(0, TCGETA, &t) == 0
	|| errno == ENOTTY || errno == ENXIO || errno == EINVAL) {
	t.c_cflag |= CBAUD | PARENB | PARODD | CSIZE | CSTOPB;
	return 0;
    }
    return 1;
    }], tcl_cv_api_serial=termio, tcl_cv_api_serial=no, tcl_cv_api_serial=no)
    fi
    if test $tcl_cv_api_serial = no; then
	AC_TRY_RUN([
#include <sgtty.h>
#include <errno.h>

int main() {
    struct sgttyb t;
    if (ioctl(0, TIOCGETP, &t) == 0
	|| errno == ENOTTY || errno == ENXIO || errno == EINVAL) {
	t.sg_ospeed = 0;
	t.sg_flags |= ODDP | EVENP | RAW;
	return 0;
    }
    return 1;
}], tcl_cv_api_serial=sgtty, tcl_cv_api_serial=none, tcl_cv_api_serial=none)
    fi])
    case $tcl_cv_api_serial in
	termios) AC_DEFINE(USE_TERMIOS, 1, [Use the termios API for serial lines]);;
	termio)  AC_DEFINE(USE_TERMIO, 1, [Use the termio API for serial lines]);;
	sgtty)   AC_DEFINE(USE_SGTTY, 1, [Use the sgtty API for serial lines]);;
    esac
])

#--------------------------------------------------------------------
# TEA_MISSING_POSIX_HEADERS
#
#	Supply substitutes for missing POSIX header files.  Special
#	notes:
#	    - stdlib.h doesn't define strtol, strtoul, or
#	      strtod in some versions of SunOS
#	    - some versions of string.h don't declare procedures such
#	      as strstr
#
# Arguments:
#	none
#
# Results:
#
#	Defines some of the following vars:
#		NO_DIRENT_H
#		NO_ERRNO_H
#		NO_VALUES_H
#		HAVE_LIMITS_H or NO_LIMITS_H
#		NO_STDLIB_H
#		NO_STRING_H
#		NO_SYS_WAIT_H
#		NO_DLFCN_H
#		HAVE_SYS_PARAM_H
#
#		HAVE_STRING_H ?
#
# tkUnixPort.h checks for HAVE_LIMITS_H, so do both HAVE and
# CHECK on limits.h
#--------------------------------------------------------------------

AC_DEFUN([TEA_MISSING_POSIX_HEADERS], [
    AC_CACHE_CHECK([dirent.h], tcl_cv_dirent_h, [
    AC_TRY_LINK([#include <sys/types.h>
#include <dirent.h>], [
#ifndef _POSIX_SOURCE
#   ifdef __Lynx__
	/*
	 * Generate compilation error to make the test fail:  Lynx headers
	 * are only valid if really in the POSIX environment.
	 */

	missing_procedure();
#   endif
#endif
DIR *d;
struct dirent *entryPtr;
char *p;
d = opendir("foobar");
entryPtr = readdir(d);
p = entryPtr->d_name;
closedir(d);
], tcl_cv_dirent_h=yes, tcl_cv_dirent_h=no)])

    if test $tcl_cv_dirent_h = no; then
	AC_DEFINE(NO_DIRENT_H, 1, [Do we have <dirent.h>?])
    fi

    # TEA specific:
    AC_CHECK_HEADER(errno.h, , [AC_DEFINE(NO_ERRNO_H, 1, [Do we have <errno.h>?])])
    AC_CHECK_HEADER(float.h, , [AC_DEFINE(NO_FLOAT_H, 1, [Do we have <float.h>?])])
    AC_CHECK_HEADER(values.h, , [AC_DEFINE(NO_VALUES_H, 1, [Do we have <values.h>?])])
    AC_CHECK_HEADER(limits.h,
	[AC_DEFINE(HAVE_LIMITS_H, 1, [Do we have <limits.h>?])],
	[AC_DEFINE(NO_LIMITS_H, 1, [Do we have <limits.h>?])])
    AC_CHECK_HEADER(stdlib.h, tcl_ok=1, tcl_ok=0)
    AC_EGREP_HEADER(strtol, stdlib.h, , tcl_ok=0)
    AC_EGREP_HEADER(strtoul, stdlib.h, , tcl_ok=0)
    AC_EGREP_HEADER(strtod, stdlib.h, , tcl_ok=0)
    if test $tcl_ok = 0; then
	AC_DEFINE(NO_STDLIB_H, 1, [Do we have <stdlib.h>?])
    fi
    AC_CHECK_HEADER(string.h, tcl_ok=1, tcl_ok=0)
    AC_EGREP_HEADER(strstr, string.h, , tcl_ok=0)
    AC_EGREP_HEADER(strerror, string.h, , tcl_ok=0)

    # See also memmove check below for a place where NO_STRING_H can be
    # set and why.

    if test $tcl_ok = 0; then
	AC_DEFINE(NO_STRING_H, 1, [Do we have <string.h>?])
    fi

    AC_CHECK_HEADER(sys/wait.h, , [AC_DEFINE(NO_SYS_WAIT_H, 1, [Do we have <sys/wait.h>?])])
    AC_CHECK_HEADER(dlfcn.h, , [AC_DEFINE(NO_DLFCN_H, 1, [Do we have <dlfcn.h>?])])

    # OS/390 lacks sys/param.h (and doesn't need it, by chance).
    AC_HAVE_HEADERS(sys/param.h)
])

#--------------------------------------------------------------------
# TEA_PATH_X
#
#	Locate the X11 header files and the X11 library archive.  Try
#	the ac_path_x macro first, but if it doesn't find the X stuff
#	(e.g. because there's no xmkmf program) then check through
#	a list of possible directories.  Under some conditions the
#	autoconf macro will return an include directory that contains
#	no include files, so double-check its result just to be safe.
#
#	This should be called after TEA_CONFIG_CFLAGS as setting the
#	LIBS line can confuse some configure macro magic.
#
# Arguments:
#	none
#
# Results:
#
#	Sets the following vars:
#		XINCLUDES
#		XLIBSW
#		PKG_LIBS (appends to)
#
#--------------------------------------------------------------------

AC_DEFUN([TEA_PATH_X], [
    if test "${TEA_WINDOWINGSYSTEM}" = "x11" ; then
	TEA_PATH_UNIX_X
    fi
])

AC_DEFUN([TEA_PATH_UNIX_X], [
    AC_PATH_X
    not_really_there=""
    if test "$no_x" = ""; then
	if test "$x_includes" = ""; then
	    AC_TRY_CPP([#include <X11/XIntrinsic.h>], , not_really_there="yes")
	else
	    if test ! -r $x_includes/X11/Intrinsic.h; then
		not_really_there="yes"
	    fi
	fi
    fi
    if test "$no_x" = "yes" -o "$not_really_there" = "yes"; then
	AC_MSG_CHECKING([for X11 header files])
	found_xincludes="no"
	AC_TRY_CPP([#include <X11/Intrinsic.h>], found_xincludes="yes", found_xincludes="no")
	if test "$found_xincludes" = "no"; then
	    dirs="/usr/unsupported/include /usr/local/include /usr/X386/include /usr/X11R6/include /usr/X11R5/include /usr/include/X11R5 /usr/include/X11R4 /usr/openwin/include /usr/X11/include /usr/sww/include"
	    for i in $dirs ; do
		if test -r $i/X11/Intrinsic.h; then
		    AC_MSG_RESULT([$i])
		    XINCLUDES=" -I$i"
		    found_xincludes="yes"
		    break
		fi
	    done
	fi
    else
	if test "$x_includes" != ""; then
	    XINCLUDES="-I$x_includes"
	    found_xincludes="yes"
	fi
    fi
    if test "$found_xincludes" = "no"; then
	AC_MSG_RESULT([couldn't find any!])
    fi

    if test "$no_x" = yes; then
	AC_MSG_CHECKING([for X11 libraries])
	XLIBSW=nope
	dirs="/usr/unsupported/lib /usr/local/lib /usr/X386/lib /usr/X11R6/lib /usr/X11R5/lib /usr/lib/X11R5 /usr/lib/X11R4 /usr/openwin/lib /usr/X11/lib /usr/sww/X11/lib"
	for i in $dirs ; do
	    if test -r $i/libX11.a -o -r $i/libX11.so -o -r $i/libX11.sl -o -r $i/libX11.dylib; then
		AC_MSG_RESULT([$i])
		XLIBSW="-L$i -lX11"
		x_libraries="$i"
		break
	    fi
	done
    else
	if test "$x_libraries" = ""; then
	    XLIBSW=-lX11
	else
	    XLIBSW="-L$x_libraries -lX11"
	fi
    fi
    if test "$XLIBSW" = nope ; then
	AC_CHECK_LIB(Xwindow, XCreateWindow, XLIBSW=-lXwindow)
    fi
    if test "$XLIBSW" = nope ; then
	AC_MSG_RESULT([could not find any!  Using -lX11.])
	XLIBSW=-lX11
    fi
    # TEA specific:
    if test x"${XLIBSW}" != x ; then
	PKG_LIBS="${PKG_LIBS} ${XLIBSW}"
    fi
])

#--------------------------------------------------------------------
# TEA_BLOCKING_STYLE
#
#	The statements below check for systems where POSIX-style
#	non-blocking I/O (O_NONBLOCK) doesn't work or is unimplemented.
#	On these systems (mostly older ones), use the old BSD-style
#	FIONBIO approach instead.
#
# Arguments:
#	none
#
# Results:
#
#	Defines some of the following vars:
#		HAVE_SYS_IOCTL_H
#		HAVE_SYS_FILIO_H
#		USE_FIONBIO
#		O_NONBLOCK
#
#--------------------------------------------------------------------

AC_DEFUN([TEA_BLOCKING_STYLE], [
    AC_CHECK_HEADERS(sys/ioctl.h)
    AC_CHECK_HEADERS(sys/filio.h)
    TEA_CONFIG_SYSTEM
    AC_MSG_CHECKING([FIONBIO vs. O_NONBLOCK for nonblocking I/O])
    case $system in
	OSF*)
	    AC_DEFINE(USE_FIONBIO, 1, [Should we use FIONBIO?])
	    AC_MSG_RESULT([FIONBIO])
	    ;;
	*)
	    AC_MSG_RESULT([O_NONBLOCK])
	    ;;
    esac
])

#--------------------------------------------------------------------
# TEA_TIME_HANDLER
#
#	Checks how the system deals with time.h, what time structures
#	are used on the system, and what fields the structures have.
#
# Arguments:
#	none
#
# Results:
#
#	Defines some of the following vars:
#		USE_DELTA_FOR_TZ
#		HAVE_TM_GMTOFF
#		HAVE_TM_TZADJ
#		HAVE_TIMEZONE_VAR
#
#--------------------------------------------------------------------

AC_DEFUN([TEA_TIME_HANDLER], [
    AC_CHECK_HEADERS(sys/time.h)
    AC_HEADER_TIME
    AC_STRUCT_TIMEZONE

    AC_CHECK_FUNCS(gmtime_r localtime_r)

    AC_CACHE_CHECK([tm_tzadj in struct tm], tcl_cv_member_tm_tzadj, [
	AC_TRY_COMPILE([#include <time.h>], [struct tm tm; tm.tm_tzadj;],
	    tcl_cv_member_tm_tzadj=yes, tcl_cv_member_tm_tzadj=no)])
    if test $tcl_cv_member_tm_tzadj = yes ; then
	AC_DEFINE(HAVE_TM_TZADJ, 1, [Should we use the tm_tzadj field of struct tm?])
    fi

    AC_CACHE_CHECK([tm_gmtoff in struct tm], tcl_cv_member_tm_gmtoff, [
	AC_TRY_COMPILE([#include <time.h>], [struct tm tm; tm.tm_gmtoff;],
	    tcl_cv_member_tm_gmtoff=yes, tcl_cv_member_tm_gmtoff=no)])
    if test $tcl_cv_member_tm_gmtoff = yes ; then
	AC_DEFINE(HAVE_TM_GMTOFF, 1, [Should we use the tm_gmtoff field of struct tm?])
    fi

    #
    # Its important to include time.h in this check, as some systems
    # (like convex) have timezone functions, etc.
    #
    AC_CACHE_CHECK([long timezone variable], tcl_cv_timezone_long, [
	AC_TRY_COMPILE([#include <time.h>],
	    [extern long timezone;
	    timezone += 1;
	    exit (0);],
	    tcl_cv_timezone_long=yes, tcl_cv_timezone_long=no)])
    if test $tcl_cv_timezone_long = yes ; then
	AC_DEFINE(HAVE_TIMEZONE_VAR, 1, [Should we use the global timezone variable?])
    else
	#
	# On some systems (eg IRIX 6.2), timezone is a time_t and not a long.
	#
	AC_CACHE_CHECK([time_t timezone variable], tcl_cv_timezone_time, [
	    AC_TRY_COMPILE([#include <time.h>],
		[extern time_t timezone;
		timezone += 1;
		exit (0);],
		tcl_cv_timezone_time=yes, tcl_cv_timezone_time=no)])
	if test $tcl_cv_timezone_time = yes ; then
	    AC_DEFINE(HAVE_TIMEZONE_VAR, 1, [Should we use the global timezone variable?])
	fi
    fi
])

#--------------------------------------------------------------------
# TEA_BUGGY_STRTOD
#
#	Under Solaris 2.4, strtod returns the wrong value for the
#	terminating character under some conditions.  Check for this
#	and if the problem exists use a substitute procedure
#	"fixstrtod" (provided by Tcl) that corrects the error.
#	Also, on Compaq's Tru64 Unix 5.0,
#	strtod(" ") returns 0.0 instead of a failure to convert.
#
# Arguments:
#	none
#
# Results:
#
#	Might defines some of the following vars:
#		strtod (=fixstrtod)
#
#--------------------------------------------------------------------

AC_DEFUN([TEA_BUGGY_STRTOD], [
    AC_CHECK_FUNC(strtod, tcl_strtod=1, tcl_strtod=0)
    if test "$tcl_strtod" = 1; then
	AC_CACHE_CHECK([for Solaris2.4/Tru64 strtod bugs], tcl_cv_strtod_buggy,[
	    AC_TRY_RUN([
		extern double strtod();
		int main() {
		    char *infString="Inf", *nanString="NaN", *spaceString=" ";
		    char *term;
		    double value;
		    value = strtod(infString, &term);
		    if ((term != infString) && (term[-1] == 0)) {
			exit(1);
		    }
		    value = strtod(nanString, &term);
		    if ((term != nanString) && (term[-1] == 0)) {
			exit(1);
		    }
		    value = strtod(spaceString, &term);
		    if (term == (spaceString+1)) {
			exit(1);
		    }
		    exit(0);
		}], tcl_cv_strtod_buggy=ok, tcl_cv_strtod_buggy=buggy,
		    tcl_cv_strtod_buggy=buggy)])
	if test "$tcl_cv_strtod_buggy" = buggy; then
	    AC_LIBOBJ([fixstrtod])
	    USE_COMPAT=1
	    AC_DEFINE(strtod, fixstrtod, [Do we want to use the strtod() in compat?])
	fi
    fi
])

#--------------------------------------------------------------------
# TEA_TCL_LINK_LIBS
#
#	Search for the libraries needed to link the Tcl shell.
#	Things like the math library (-lm) and socket stuff (-lsocket vs.
#	-lnsl) are dealt with here.
#
# Arguments:
#	Requires the following vars to be set in the Makefile:
#		DL_LIBS (not in TEA, only needed in core)
#		LIBS
#		MATH_LIBS
#
# Results:
#
#	Subst's the following var:
#		TCL_LIBS
#		MATH_LIBS
#
#	Might append to the following vars:
#		LIBS
#
#	Might define the following vars:
#		HAVE_NET_ERRNO_H
#
#--------------------------------------------------------------------

AC_DEFUN([TEA_TCL_LINK_LIBS], [
    #--------------------------------------------------------------------
    # On a few very rare systems, all of the libm.a stuff is
    # already in libc.a.  Set compiler flags accordingly.
    # Also, Linux requires the "ieee" library for math to work
    # right (and it must appear before "-lm").
    #--------------------------------------------------------------------

    AC_CHECK_FUNC(sin, MATH_LIBS="", MATH_LIBS="-lm")
    AC_CHECK_LIB(ieee, main, [MATH_LIBS="-lieee $MATH_LIBS"])

    #--------------------------------------------------------------------
    # Interactive UNIX requires -linet instead of -lsocket, plus it
    # needs net/errno.h to define the socket-related error codes.
    #--------------------------------------------------------------------

    AC_CHECK_LIB(inet, main, [LIBS="$LIBS -linet"])
    AC_CHECK_HEADER(net/errno.h, [
	AC_DEFINE(HAVE_NET_ERRNO_H, 1, [Do we have <net/errno.h>?])])

    #--------------------------------------------------------------------
    #	Check for the existence of the -lsocket and -lnsl libraries.
    #	The order here is important, so that they end up in the right
    #	order in the command line generated by make.  Here are some
    #	special considerations:
    #	1. Use "connect" and "accept" to check for -lsocket, and
    #	   "gethostbyname" to check for -lnsl.
    #	2. Use each function name only once:  can't redo a check because
    #	   autoconf caches the results of the last check and won't redo it.
    #	3. Use -lnsl and -lsocket only if they supply procedures that
    #	   aren't already present in the normal libraries.  This is because
    #	   IRIX 5.2 has libraries, but they aren't needed and they're
    #	   bogus:  they goof up name resolution if used.
    #	4. On some SVR4 systems, can't use -lsocket without -lnsl too.
    #	   To get around this problem, check for both libraries together
    #	   if -lsocket doesn't work by itself.
    #--------------------------------------------------------------------

    tcl_checkBoth=0
    AC_CHECK_FUNC(connect, tcl_checkSocket=0, tcl_checkSocket=1)
    if test "$tcl_checkSocket" = 1; then
	AC_CHECK_FUNC(setsockopt, , [AC_CHECK_LIB(socket, setsockopt,
	    LIBS="$LIBS -lsocket", tcl_checkBoth=1)])
    fi
    if test "$tcl_checkBoth" = 1; then
	tk_oldLibs=$LIBS
	LIBS="$LIBS -lsocket -lnsl"
	AC_CHECK_FUNC(accept, tcl_checkNsl=0, [LIBS=$tk_oldLibs])
    fi
    AC_CHECK_FUNC(gethostbyname, , [AC_CHECK_LIB(nsl, gethostbyname,
	    [LIBS="$LIBS -lnsl"])])

    # TEA specific: Don't perform the eval of the libraries here because
    # DL_LIBS won't be set until we call TEA_CONFIG_CFLAGS

    TCL_LIBS='${DL_LIBS} ${LIBS} ${MATH_LIBS}'
    AC_SUBST(TCL_LIBS)
    AC_SUBST(MATH_LIBS)
])

#--------------------------------------------------------------------
# TEA_TCL_EARLY_FLAGS
#
#	Check for what flags are needed to be passed so the correct OS
#	features are available.
#
# Arguments:
#	None
#
# Results:
#
#	Might define the following vars:
#		_ISOC99_SOURCE
#		_LARGEFILE64_SOURCE
#		_LARGEFILE_SOURCE64
#
#--------------------------------------------------------------------

AC_DEFUN([TEA_TCL_EARLY_FLAG],[
    AC_CACHE_VAL([tcl_cv_flag_]translit($1,[A-Z],[a-z]),
	AC_TRY_COMPILE([$2], $3, [tcl_cv_flag_]translit($1,[A-Z],[a-z])=no,
	    AC_TRY_COMPILE([[#define ]$1[ 1
]$2], $3,
		[tcl_cv_flag_]translit($1,[A-Z],[a-z])=yes,
		[tcl_cv_flag_]translit($1,[A-Z],[a-z])=no)))
    if test ["x${tcl_cv_flag_]translit($1,[A-Z],[a-z])[}" = "xyes"] ; then
	AC_DEFINE($1, 1, [Add the ]$1[ flag when building])
	tcl_flags="$tcl_flags $1"
    fi
])

AC_DEFUN([TEA_TCL_EARLY_FLAGS],[
    AC_MSG_CHECKING([for required early compiler flags])
    tcl_flags=""
    TEA_TCL_EARLY_FLAG(_ISOC99_SOURCE,[#include <stdlib.h>],
	[char *p = (char *)strtoll; char *q = (char *)strtoull;])
    TEA_TCL_EARLY_FLAG(_LARGEFILE64_SOURCE,[#include <sys/stat.h>],
	[struct stat64 buf; int i = stat64("/", &buf);])
    TEA_TCL_EARLY_FLAG(_LARGEFILE_SOURCE64,[#include <sys/stat.h>],
	[char *p = (char *)open64;])
    if test "x${tcl_flags}" = "x" ; then
	AC_MSG_RESULT([none])
    else
	AC_MSG_RESULT([${tcl_flags}])
    fi
])

#--------------------------------------------------------------------
# TEA_TCL_64BIT_FLAGS
#
#	Check for what is defined in the way of 64-bit features.
#
# Arguments:
#	None
#
# Results:
#
#	Might define the following vars:
#		TCL_WIDE_INT_IS_LONG
#		TCL_WIDE_INT_TYPE
#		HAVE_STRUCT_DIRENT64
#		HAVE_STRUCT_STAT64
#		HAVE_TYPE_OFF64_T
#
#--------------------------------------------------------------------

AC_DEFUN([TEA_TCL_64BIT_FLAGS], [
    AC_MSG_CHECKING([for 64-bit integer type])
    AC_CACHE_VAL(tcl_cv_type_64bit,[
	tcl_cv_type_64bit=none
	# See if the compiler knows natively about __int64
	AC_TRY_COMPILE(,[__int64 value = (__int64) 0;],
	    tcl_type_64bit=__int64, tcl_type_64bit="long long")
	# See if we should use long anyway  Note that we substitute in the
	# type that is our current guess for a 64-bit type inside this check
	# program, so it should be modified only carefully...
        AC_TRY_COMPILE(,[switch (0) {
            case 1: case (sizeof(]${tcl_type_64bit}[)==sizeof(long)): ;
        }],tcl_cv_type_64bit=${tcl_type_64bit})])
    if test "${tcl_cv_type_64bit}" = none ; then
	AC_DEFINE(TCL_WIDE_INT_IS_LONG, 1, [Are wide integers to be implemented with C 'long's?])
	AC_MSG_RESULT([using long])
    elif test "${tcl_cv_type_64bit}" = "__int64" \
		-a "${TEA_PLATFORM}" = "windows" ; then
	# TEA specific: We actually want to use the default tcl.h checks in
	# this case to handle both TCL_WIDE_INT_TYPE and TCL_LL_MODIFIER*
	AC_MSG_RESULT([using Tcl header defaults])
    else
	AC_DEFINE_UNQUOTED(TCL_WIDE_INT_TYPE,${tcl_cv_type_64bit},
	    [What type should be used to define wide integers?])
	AC_MSG_RESULT([${tcl_cv_type_64bit}])

	# Now check for auxiliary declarations
	AC_CACHE_CHECK([for struct dirent64], tcl_cv_struct_dirent64,[
	    AC_TRY_COMPILE([#include <sys/types.h>
#include <sys/dirent.h>],[struct dirent64 p;],
		tcl_cv_struct_dirent64=yes,tcl_cv_struct_dirent64=no)])
	if test "x${tcl_cv_struct_dirent64}" = "xyes" ; then
	    AC_DEFINE(HAVE_STRUCT_DIRENT64, 1, [Is 'struct dirent64' in <sys/types.h>?])
	fi

	AC_CACHE_CHECK([for struct stat64], tcl_cv_struct_stat64,[
	    AC_TRY_COMPILE([#include <sys/stat.h>],[struct stat64 p;
],
		tcl_cv_struct_stat64=yes,tcl_cv_struct_stat64=no)])
	if test "x${tcl_cv_struct_stat64}" = "xyes" ; then
	    AC_DEFINE(HAVE_STRUCT_STAT64, 1, [Is 'struct stat64' in <sys/stat.h>?])
	fi

	AC_CHECK_FUNCS(open64 lseek64)
	AC_MSG_CHECKING([for off64_t])
	AC_CACHE_VAL(tcl_cv_type_off64_t,[
	    AC_TRY_COMPILE([#include <sys/types.h>],[off64_t offset;
],
		tcl_cv_type_off64_t=yes,tcl_cv_type_off64_t=no)])
	dnl Define HAVE_TYPE_OFF64_T only when the off64_t type and the
	dnl functions lseek64 and open64 are defined.
	if test "x${tcl_cv_type_off64_t}" = "xyes" && \
	        test "x${ac_cv_func_lseek64}" = "xyes" && \
	        test "x${ac_cv_func_open64}" = "xyes" ; then
	    AC_DEFINE(HAVE_TYPE_OFF64_T, 1, [Is off64_t in <sys/types.h>?])
	    AC_MSG_RESULT([yes])
	else
	    AC_MSG_RESULT([no])
	fi
    fi
])

##
## Here ends the standard Tcl configuration bits and starts the
## TEA specific functions
##

#------------------------------------------------------------------------
# TEA_INIT --
#
#	Init various Tcl Extension Architecture (TEA) variables.
#	This should be the first called TEA_* macro.
#
# Arguments:
#	none
#
# Results:
#
#	Defines and substs the following vars:
#		CYGPATH
#		EXEEXT
#	Defines only:
#		TEA_VERSION
#		TEA_INITED
#		TEA_PLATFORM (windows or unix)
#
# "cygpath" is used on windows to generate native path names for include
# files. These variables should only be used with the compiler and linker
# since they generate native path names.
#
# EXEEXT
#	Select the executable extension based on the host type.  This
#	is a lightweight replacement for AC_EXEEXT that doesn't require
#	a compiler.
#------------------------------------------------------------------------

AC_DEFUN([TEA_INIT], [
    # TEA extensions pass this us the version of TEA they think they
    # are compatible with.
    TEA_VERSION="3.9"

    AC_MSG_CHECKING([for correct TEA configuration])
    if test x"${PACKAGE_NAME}" = x ; then
	AC_MSG_ERROR([
The PACKAGE_NAME variable must be defined by your TEA configure.in])
    fi
    if test x"$1" = x ; then
	AC_MSG_ERROR([
TEA version not specified.])
    elif test "$1" != "${TEA_VERSION}" ; then
	AC_MSG_RESULT([warning: requested TEA version "$1", have "${TEA_VERSION}"])
    else
	AC_MSG_RESULT([ok (TEA ${TEA_VERSION})])
    fi
    case "`uname -s`" in
	*win32*|*WIN32*|*MINGW32_*)
	    AC_CHECK_PROG(CYGPATH, cygpath, cygpath -w, echo)
	    EXEEXT=".exe"
	    TEA_PLATFORM="windows"
	    ;;
	*CYGWIN_*)
	    CYGPATH=echo
	    EXEEXT=".exe"
	    # TEA_PLATFORM is determined later in LOAD_TCLCONFIG
	    ;;
	*)
	    CYGPATH=echo
	    # Maybe we are cross-compiling....
	    case ${host_alias} in
		*mingw32*)
		EXEEXT=".exe"
		TEA_PLATFORM="windows"
		;;
	    *)
		EXEEXT=""
		TEA_PLATFORM="unix"
		;;
	    esac
	    ;;
    esac

    # Check if exec_prefix is set. If not use fall back to prefix.
    # Note when adjusted, so that TEA_PREFIX can correct for this.
    # This is needed for recursive configures, since autoconf propagates
    # $prefix, but not $exec_prefix (doh!).
    if test x$exec_prefix = xNONE ; then
	exec_prefix_default=yes
	exec_prefix=$prefix
    fi

    AC_MSG_NOTICE([configuring ${PACKAGE_NAME} ${PACKAGE_VERSION}])

    AC_SUBST(EXEEXT)
    AC_SUBST(CYGPATH)

    # This package name must be replaced statically for AC_SUBST to work
    AC_SUBST(PKG_LIB_FILE)
    # Substitute STUB_LIB_FILE in case package creates a stub library too.
    AC_SUBST(PKG_STUB_LIB_FILE)

    # We AC_SUBST these here to ensure they are subst'ed,
    # in case the user doesn't call TEA_ADD_...
    AC_SUBST(PKG_STUB_SOURCES)
    AC_SUBST(PKG_STUB_OBJECTS)
    AC_SUBST(PKG_TCL_SOURCES)
    AC_SUBST(PKG_HEADERS)
    AC_SUBST(PKG_INCLUDES)
    AC_SUBST(PKG_LIBS)
    AC_SUBST(PKG_CFLAGS)
])

#------------------------------------------------------------------------
# TEA_ADD_SOURCES --
#
#	Specify one or more source files.  Users should check for
#	the right platform before adding to their list.
#	It is not important to specify the directory, as long as it is
#	in the generic, win or unix subdirectory of $(srcdir).
#
# Arguments:
#	one or more file names
#
# Results:
#
#	Defines and substs the following vars:
#		PKG_SOURCES
#		PKG_OBJECTS
#------------------------------------------------------------------------
AC_DEFUN([TEA_ADD_SOURCES], [
    vars="$@"
    for i in $vars; do
	case $i in
	    [\$]*)
		# allow $-var names
		PKG_SOURCES="$PKG_SOURCES $i"
		PKG_OBJECTS="$PKG_OBJECTS $i"
		;;
	    *)
		# check for existence - allows for generic/win/unix VPATH
		# To add more dirs here (like 'src'), you have to update VPATH
		# in Makefile.in as well
		if test ! -f "${srcdir}/$i" -a ! -f "${srcdir}/generic/$i" \
		    -a ! -f "${srcdir}/win/$i" -a ! -f "${srcdir}/unix/$i" \
		    -a ! -f "${srcdir}/macosx/$i" \
		    ; then
		    AC_MSG_ERROR([could not find source file '$i'])
		fi
		PKG_SOURCES="$PKG_SOURCES $i"
		# this assumes it is in a VPATH dir
		i=`basename $i`
		# handle user calling this before or after TEA_SETUP_COMPILER
		if test x"${OBJEXT}" != x ; then
		    j="`echo $i | sed -e 's/\.[[^.]]*$//'`.${OBJEXT}"
		else
		    j="`echo $i | sed -e 's/\.[[^.]]*$//'`.\${OBJEXT}"
		fi
		PKG_OBJECTS="$PKG_OBJECTS $j"
		;;
	esac
    done
    AC_SUBST(PKG_SOURCES)
    AC_SUBST(PKG_OBJECTS)
])

#------------------------------------------------------------------------
# TEA_ADD_STUB_SOURCES --
#
#	Specify one or more source files.  Users should check for
#	the right platform before adding to their list.
#	It is not important to specify the directory, as long as it is
#	in the generic, win or unix subdirectory of $(srcdir).
#
# Arguments:
#	one or more file names
#
# Results:
#
#	Defines and substs the following vars:
#		PKG_STUB_SOURCES
#		PKG_STUB_OBJECTS
#------------------------------------------------------------------------
AC_DEFUN([TEA_ADD_STUB_SOURCES], [
    vars="$@"
    for i in $vars; do
	# check for existence - allows for generic/win/unix VPATH
	if test ! -f "${srcdir}/$i" -a ! -f "${srcdir}/generic/$i" \
	    -a ! -f "${srcdir}/win/$i" -a ! -f "${srcdir}/unix/$i" \
	    -a ! -f "${srcdir}/macosx/$i" \
	    ; then
	    AC_MSG_ERROR([could not find stub source file '$i'])
	fi
	PKG_STUB_SOURCES="$PKG_STUB_SOURCES $i"
	# this assumes it is in a VPATH dir
	i=`basename $i`
	# handle user calling this before or after TEA_SETUP_COMPILER
	if test x"${OBJEXT}" != x ; then
	    j="`echo $i | sed -e 's/\.[[^.]]*$//'`.${OBJEXT}"
	else
	    j="`echo $i | sed -e 's/\.[[^.]]*$//'`.\${OBJEXT}"
	fi
	PKG_STUB_OBJECTS="$PKG_STUB_OBJECTS $j"
    done
    AC_SUBST(PKG_STUB_SOURCES)
    AC_SUBST(PKG_STUB_OBJECTS)
])

#------------------------------------------------------------------------
# TEA_ADD_TCL_SOURCES --
#
#	Specify one or more Tcl source files.  These should be platform
#	independent runtime files.
#
# Arguments:
#	one or more file names
#
# Results:
#
#	Defines and substs the following vars:
#		PKG_TCL_SOURCES
#------------------------------------------------------------------------
AC_DEFUN([TEA_ADD_TCL_SOURCES], [
    vars="$@"
    for i in $vars; do
	# check for existence, be strict because it is installed
	if test ! -f "${srcdir}/$i" ; then
	    AC_MSG_ERROR([could not find tcl source file '${srcdir}/$i'])
	fi
	PKG_TCL_SOURCES="$PKG_TCL_SOURCES $i"
    done
    AC_SUBST(PKG_TCL_SOURCES)
])

#------------------------------------------------------------------------
# TEA_ADD_HEADERS --
#
#	Specify one or more source headers.  Users should check for
#	the right platform before adding to their list.
#
# Arguments:
#	one or more file names
#
# Results:
#
#	Defines and substs the following vars:
#		PKG_HEADERS
#------------------------------------------------------------------------
AC_DEFUN([TEA_ADD_HEADERS], [
    vars="$@"
    for i in $vars; do
	# check for existence, be strict because it is installed
	if test ! -f "${srcdir}/$i" ; then
	    AC_MSG_ERROR([could not find header file '${srcdir}/$i'])
	fi
	PKG_HEADERS="$PKG_HEADERS $i"
    done
    AC_SUBST(PKG_HEADERS)
])

#------------------------------------------------------------------------
# TEA_ADD_INCLUDES --
#
#	Specify one or more include dirs.  Users should check for
#	the right platform before adding to their list.
#
# Arguments:
#	one or more file names
#
# Results:
#
#	Defines and substs the following vars:
#		PKG_INCLUDES
#------------------------------------------------------------------------
AC_DEFUN([TEA_ADD_INCLUDES], [
    vars="$@"
    for i in $vars; do
	PKG_INCLUDES="$PKG_INCLUDES $i"
    done
    AC_SUBST(PKG_INCLUDES)
])

#------------------------------------------------------------------------
# TEA_ADD_LIBS --
#
#	Specify one or more libraries.  Users should check for
#	the right platform before adding to their list.  For Windows,
#	libraries provided in "foo.lib" format will be converted to
#	"-lfoo" when using GCC (mingw).
#
# Arguments:
#	one or more file names
#
# Results:
#
#	Defines and substs the following vars:
#		PKG_LIBS
#------------------------------------------------------------------------
AC_DEFUN([TEA_ADD_LIBS], [
    vars="$@"
    for i in $vars; do
	if test "${TEA_PLATFORM}" = "windows" -a "$GCC" = "yes" ; then
	    # Convert foo.lib to -lfoo for GCC.  No-op if not *.lib
	    i=`echo "$i" | sed -e 's/^\([[^-]].*\)\.lib[$]/-l\1/i'`
	fi
	PKG_LIBS="$PKG_LIBS $i"
    done
    AC_SUBST(PKG_LIBS)
])

#------------------------------------------------------------------------
# TEA_ADD_CFLAGS --
#
#	Specify one or more CFLAGS.  Users should check for
#	the right platform before adding to their list.
#
# Arguments:
#	one or more file names
#
# Results:
#
#	Defines and substs the following vars:
#		PKG_CFLAGS
#------------------------------------------------------------------------
AC_DEFUN([TEA_ADD_CFLAGS], [
    PKG_CFLAGS="$PKG_CFLAGS $@"
    AC_SUBST(PKG_CFLAGS)
])

#------------------------------------------------------------------------
# TEA_ADD_CLEANFILES --
#
#	Specify one or more CLEANFILES.
#
# Arguments:
#	one or more file names to clean target
#
# Results:
#
#	Appends to CLEANFILES, already defined for subst in LOAD_TCLCONFIG
#------------------------------------------------------------------------
AC_DEFUN([TEA_ADD_CLEANFILES], [
    CLEANFILES="$CLEANFILES $@"
])

#------------------------------------------------------------------------
# TEA_PREFIX --
#
#	Handle the --prefix=... option by defaulting to what Tcl gave
#
# Arguments:
#	none
#
# Results:
#
#	If --prefix or --exec-prefix was not specified, $prefix and
#	$exec_prefix will be set to the values given to Tcl when it was
#	configured.
#------------------------------------------------------------------------
AC_DEFUN([TEA_PREFIX], [
    if test "${prefix}" = "NONE"; then
	prefix_default=yes
	if test x"${TCL_PREFIX}" != x; then
	    AC_MSG_NOTICE([--prefix defaulting to TCL_PREFIX ${TCL_PREFIX}])
	    prefix=${TCL_PREFIX}
	else
	    AC_MSG_NOTICE([--prefix defaulting to /usr/local])
	    prefix=/usr/local
	fi
    fi
    if test "${exec_prefix}" = "NONE" -a x"${prefix_default}" = x"yes" \
	-o x"${exec_prefix_default}" = x"yes" ; then
	if test x"${TCL_EXEC_PREFIX}" != x; then
	    AC_MSG_NOTICE([--exec-prefix defaulting to TCL_EXEC_PREFIX ${TCL_EXEC_PREFIX}])
	    exec_prefix=${TCL_EXEC_PREFIX}
	else
	    AC_MSG_NOTICE([--exec-prefix defaulting to ${prefix}])
	    exec_prefix=$prefix
	fi
    fi
])

#------------------------------------------------------------------------
# TEA_SETUP_COMPILER_CC --
#
#	Do compiler checks the way we want.  This is just a replacement
#	for AC_PROG_CC in TEA configure.in files to make them cleaner.
#
# Arguments:
#	none
#
# Results:
#
#	Sets up CC var and other standard bits we need to make executables.
#------------------------------------------------------------------------
AC_DEFUN([TEA_SETUP_COMPILER_CC], [
    # Don't put any macros that use the compiler (e.g. AC_TRY_COMPILE)
    # in this macro, they need to go into TEA_SETUP_COMPILER instead.

    # If the user did not set CFLAGS, set it now to keep
    # the AC_PROG_CC macro from adding "-g -O2".
    if test "${CFLAGS+set}" != "set" ; then
	CFLAGS=""
    fi

    AC_PROG_CC
    AC_PROG_CPP

    #--------------------------------------------------------------------
    # Checks to see if the make program sets the $MAKE variable.
    #--------------------------------------------------------------------

    AC_PROG_MAKE_SET

    #--------------------------------------------------------------------
    # Find ranlib
    #--------------------------------------------------------------------

    AC_CHECK_TOOL(RANLIB, ranlib)

    #--------------------------------------------------------------------
    # Determines the correct binary file extension (.o, .obj, .exe etc.)
    #--------------------------------------------------------------------

    AC_OBJEXT
    AC_EXEEXT
])

#------------------------------------------------------------------------
# TEA_SETUP_COMPILER --
#
#	Do compiler checks that use the compiler.  This must go after
#	TEA_SETUP_COMPILER_CC, which does the actual compiler check.
#
# Arguments:
#	none
#
# Results:
#
#	Sets up CC var and other standard bits we need to make executables.
#------------------------------------------------------------------------
AC_DEFUN([TEA_SETUP_COMPILER], [
    # Any macros that use the compiler (e.g. AC_TRY_COMPILE) have to go here.
    AC_REQUIRE([TEA_SETUP_COMPILER_CC])

    #------------------------------------------------------------------------
    # If we're using GCC, see if the compiler understands -pipe. If so, use it.
    # It makes compiling go faster.  (This is only a performance feature.)
    #------------------------------------------------------------------------

    if test -z "$no_pipe" -a -n "$GCC"; then
	AC_CACHE_CHECK([if the compiler understands -pipe],
	    tcl_cv_cc_pipe, [
	    hold_cflags=$CFLAGS; CFLAGS="$CFLAGS -pipe"
	    AC_TRY_COMPILE(,, tcl_cv_cc_pipe=yes, tcl_cv_cc_pipe=no)
	    CFLAGS=$hold_cflags])
	if test $tcl_cv_cc_pipe = yes; then
	    CFLAGS="$CFLAGS -pipe"
	fi
    fi

    #--------------------------------------------------------------------
    # Common compiler flag setup
    #--------------------------------------------------------------------

    AC_C_BIGENDIAN
    if test "${TEA_PLATFORM}" = "unix" ; then
	TEA_TCL_LINK_LIBS
	TEA_MISSING_POSIX_HEADERS
	# Let the user call this, because if it triggers, they will
	# need a compat/strtod.c that is correct.  Users can also
	# use Tcl_GetDouble(FromObj) instead.
	#TEA_BUGGY_STRTOD
    fi
])

#------------------------------------------------------------------------
# TEA_MAKE_LIB --
#
#	Generate a line that can be used to build a shared/unshared library
#	in a platform independent manner.
#
# Arguments:
#	none
#
#	Requires:
#
# Results:
#
#	Defines the following vars:
#	CFLAGS -	Done late here to note disturb other AC macros
#       MAKE_LIB -      Command to execute to build the Tcl library;
#                       differs depending on whether or not Tcl is being
#                       compiled as a shared library.
#	MAKE_SHARED_LIB	Makefile rule for building a shared library
#	MAKE_STATIC_LIB	Makefile rule for building a static library
#	MAKE_STUB_LIB	Makefile rule for building a stub library
#	VC_MANIFEST_EMBED_DLL Makefile rule for embedded VC manifest in DLL
#	VC_MANIFEST_EMBED_EXE Makefile rule for embedded VC manifest in EXE
#------------------------------------------------------------------------

AC_DEFUN([TEA_MAKE_LIB], [
    if test "${TEA_PLATFORM}" = "windows" -a "$GCC" != "yes"; then
	MAKE_STATIC_LIB="\${STLIB_LD} -out:\[$]@ \$(PKG_OBJECTS)"
	MAKE_SHARED_LIB="\${SHLIB_LD} \${SHLIB_LD_LIBS} \${LDFLAGS_DEFAULT} -out:\[$]@ \$(PKG_OBJECTS)"
	AC_EGREP_CPP([manifest needed], [
#if defined(_MSC_VER) && _MSC_VER >= 1400
print("manifest needed")
#endif
	], [
	# Could do a CHECK_PROG for mt, but should always be with MSVC8+
	VC_MANIFEST_EMBED_DLL="if test -f \[$]@.manifest ; then mt.exe -nologo -manifest \[$]@.manifest -outputresource:\[$]@\;2 ; fi"
	VC_MANIFEST_EMBED_EXE="if test -f \[$]@.manifest ; then mt.exe -nologo -manifest \[$]@.manifest -outputresource:\[$]@\;1 ; fi"
	MAKE_SHARED_LIB="${MAKE_SHARED_LIB} ; ${VC_MANIFEST_EMBED_DLL}"
	TEA_ADD_CLEANFILES([*.manifest])
	])
	MAKE_STUB_LIB="\${STLIB_LD} -out:\[$]@ \$(PKG_STUB_OBJECTS)"
    else
	MAKE_STATIC_LIB="\${STLIB_LD} \[$]@ \$(PKG_OBJECTS)"
	MAKE_SHARED_LIB="\${SHLIB_LD} -o \[$]@ \$(PKG_OBJECTS) \${SHLIB_LD_LIBS}"
	MAKE_STUB_LIB="\${STLIB_LD} \[$]@ \$(PKG_STUB_OBJECTS)"
    fi

    if test "${SHARED_BUILD}" = "1" ; then
	MAKE_LIB="${MAKE_SHARED_LIB} "
    else
	MAKE_LIB="${MAKE_STATIC_LIB} "
    fi

    #--------------------------------------------------------------------
    # Shared libraries and static libraries have different names.
    # Use the double eval to make sure any variables in the suffix is
    # substituted. (@@@ Might not be necessary anymore)
    #--------------------------------------------------------------------

    if test "${TEA_PLATFORM}" = "windows" ; then
	if test "${SHARED_BUILD}" = "1" ; then
	    # We force the unresolved linking of symbols that are really in
	    # the private libraries of Tcl and Tk.
	    SHLIB_LD_LIBS="${SHLIB_LD_LIBS} \"`${CYGPATH} ${TCL_BIN_DIR}/${TCL_STUB_LIB_FILE}`\""
	    if test x"${TK_BIN_DIR}" != x ; then
		SHLIB_LD_LIBS="${SHLIB_LD_LIBS} \"`${CYGPATH} ${TK_BIN_DIR}/${TK_STUB_LIB_FILE}`\""
	    fi
	    eval eval "PKG_LIB_FILE=${PACKAGE_NAME}${SHARED_LIB_SUFFIX}"
	else
	    eval eval "PKG_LIB_FILE=${PACKAGE_NAME}${UNSHARED_LIB_SUFFIX}"
	fi
	# Some packages build their own stubs libraries
	eval eval "PKG_STUB_LIB_FILE=${PACKAGE_NAME}stub${UNSHARED_LIB_SUFFIX}"
	if test "$GCC" = "yes"; then
	    PKG_STUB_LIB_FILE=lib${PKG_STUB_LIB_FILE}
	fi
	# These aren't needed on Windows (either MSVC or gcc)
	RANLIB=:
	RANLIB_STUB=:
    else
	RANLIB_STUB="${RANLIB}"
	if test "${SHARED_BUILD}" = "1" ; then
	    SHLIB_LD_LIBS="${SHLIB_LD_LIBS} ${TCL_STUB_LIB_SPEC}"
	    if test x"${TK_BIN_DIR}" != x ; then
		SHLIB_LD_LIBS="${SHLIB_LD_LIBS} ${TK_STUB_LIB_SPEC}"
	    fi
	    eval eval "PKG_LIB_FILE=lib${PACKAGE_NAME}${SHARED_LIB_SUFFIX}"
	    RANLIB=:
	else
	    eval eval "PKG_LIB_FILE=lib${PACKAGE_NAME}${UNSHARED_LIB_SUFFIX}"
	fi
	# Some packages build their own stubs libraries
	eval eval "PKG_STUB_LIB_FILE=lib${PACKAGE_NAME}stub${UNSHARED_LIB_SUFFIX}"
    fi

    # These are escaped so that only CFLAGS is picked up at configure time.
    # The other values will be substituted at make time.
    CFLAGS="${CFLAGS} \${CFLAGS_DEFAULT} \${CFLAGS_WARNING}"
    if test "${SHARED_BUILD}" = "1" ; then
	CFLAGS="${CFLAGS} \${SHLIB_CFLAGS}"
    fi

    AC_SUBST(MAKE_LIB)
    AC_SUBST(MAKE_SHARED_LIB)
    AC_SUBST(MAKE_STATIC_LIB)
    AC_SUBST(MAKE_STUB_LIB)
    AC_SUBST(RANLIB_STUB)
    AC_SUBST(VC_MANIFEST_EMBED_DLL)
    AC_SUBST(VC_MANIFEST_EMBED_EXE)
])

#------------------------------------------------------------------------
# TEA_LIB_SPEC --
#
#	Compute the name of an existing object library located in libdir
#	from the given base name and produce the appropriate linker flags.
#
# Arguments:
#	basename	The base name of the library without version
#			numbers, extensions, or "lib" prefixes.
#	extra_dir	Extra directory in which to search for the
#			library.  This location is used first, then
#			$prefix/$exec-prefix, then some defaults.
#
# Requires:
#	TEA_INIT and TEA_PREFIX must be called first.
#
# Results:
#
#	Defines the following vars:
#		${basename}_LIB_NAME	The computed library name.
#		${basename}_LIB_SPEC	The computed linker flags.
#------------------------------------------------------------------------

AC_DEFUN([TEA_LIB_SPEC], [
    AC_MSG_CHECKING([for $1 library])

    # Look in exec-prefix for the library (defined by TEA_PREFIX).

    tea_lib_name_dir="${exec_prefix}/lib"

    # Or in a user-specified location.

    if test x"$2" != x ; then
	tea_extra_lib_dir=$2
    else
	tea_extra_lib_dir=NONE
    fi

    for i in \
	    `ls -dr ${tea_extra_lib_dir}/$1[[0-9]]*.lib 2>/dev/null ` \
	    `ls -dr ${tea_extra_lib_dir}/lib$1[[0-9]]* 2>/dev/null ` \
	    `ls -dr ${tea_lib_name_dir}/$1[[0-9]]*.lib 2>/dev/null ` \
	    `ls -dr ${tea_lib_name_dir}/lib$1[[0-9]]* 2>/dev/null ` \
	    `ls -dr /usr/lib/$1[[0-9]]*.lib 2>/dev/null ` \
	    `ls -dr /usr/lib/lib$1[[0-9]]* 2>/dev/null ` \
	    `ls -dr /usr/lib64/$1[[0-9]]*.lib 2>/dev/null ` \
	    `ls -dr /usr/lib64/lib$1[[0-9]]* 2>/dev/null ` \
	    `ls -dr /usr/local/lib/$1[[0-9]]*.lib 2>/dev/null ` \
	    `ls -dr /usr/local/lib/lib$1[[0-9]]* 2>/dev/null ` ; do
	if test -f "$i" ; then
	    tea_lib_name_dir=`dirname $i`
	    $1_LIB_NAME=`basename $i`
	    $1_LIB_PATH_NAME=$i
	    break
	fi
    done

    if test "${TEA_PLATFORM}" = "windows"; then
	$1_LIB_SPEC=\"`${CYGPATH} ${$1_LIB_PATH_NAME} 2>/dev/null`\"
    else
	# Strip off the leading "lib" and trailing ".a" or ".so"

	tea_lib_name_lib=`echo ${$1_LIB_NAME}|sed -e 's/^lib//' -e 's/\.[[^.]]*$//' -e 's/\.so.*//'`
	$1_LIB_SPEC="-L${tea_lib_name_dir} -l${tea_lib_name_lib}"
    fi

    if test "x${$1_LIB_NAME}" = x ; then
	AC_MSG_ERROR([not found])
    else
	AC_MSG_RESULT([${$1_LIB_SPEC}])
    fi
])

#------------------------------------------------------------------------
# TEA_PRIVATE_TCL_HEADERS --
#
#	Locate the private Tcl include files
#
# Arguments:
#
#	Requires:
#		TCL_SRC_DIR	Assumes that TEA_LOAD_TCLCONFIG has
#				already been called.
#
# Results:
#
#	Substs the following vars:
#		TCL_TOP_DIR_NATIVE
#		TCL_INCLUDES
#------------------------------------------------------------------------

AC_DEFUN([TEA_PRIVATE_TCL_HEADERS], [
    # Allow for --with-tclinclude to take effect and define ${ac_cv_c_tclh}
    AC_REQUIRE([TEA_PUBLIC_TCL_HEADERS])
    AC_MSG_CHECKING([for Tcl private include files])

    TCL_SRC_DIR_NATIVE=`${CYGPATH} ${TCL_SRC_DIR}`
    TCL_TOP_DIR_NATIVE=\"${TCL_SRC_DIR_NATIVE}\"

    # Check to see if tcl<Plat>Port.h isn't already with the public headers
    # Don't look for tclInt.h because that resides with tcl.h in the core
    # sources, but the <plat>Port headers are in a different directory
    if test "${TEA_PLATFORM}" = "windows" -a \
	-f "${ac_cv_c_tclh}/tclWinPort.h"; then
	result="private headers found with public headers"
    elif test "${TEA_PLATFORM}" = "unix" -a \
	-f "${ac_cv_c_tclh}/tclUnixPort.h"; then
	result="private headers found with public headers"
    else
	TCL_GENERIC_DIR_NATIVE=\"${TCL_SRC_DIR_NATIVE}/generic\"
	if test "${TEA_PLATFORM}" = "windows"; then
	    TCL_PLATFORM_DIR_NATIVE=\"${TCL_SRC_DIR_NATIVE}/win\"
	else
	    TCL_PLATFORM_DIR_NATIVE=\"${TCL_SRC_DIR_NATIVE}/unix\"
	fi
	# Overwrite the previous TCL_INCLUDES as this should capture both
	# public and private headers in the same set.
	# We want to ensure these are substituted so as not to require
	# any *_NATIVE vars be defined in the Makefile
	TCL_INCLUDES="-I${TCL_GENERIC_DIR_NATIVE} -I${TCL_PLATFORM_DIR_NATIVE}"
	if test "`uname -s`" = "Darwin"; then
            # If Tcl was built as a framework, attempt to use
            # the framework's Headers and PrivateHeaders directories
            case ${TCL_DEFS} in
	    	*TCL_FRAMEWORK*)
		    if test -d "${TCL_BIN_DIR}/Headers" -a \
			    -d "${TCL_BIN_DIR}/PrivateHeaders"; then
			TCL_INCLUDES="-I\"${TCL_BIN_DIR}/Headers\" -I\"${TCL_BIN_DIR}/PrivateHeaders\" ${TCL_INCLUDES}"
		    else
			TCL_INCLUDES="${TCL_INCLUDES} ${TCL_INCLUDE_SPEC} `echo "${TCL_INCLUDE_SPEC}" | sed -e 's/Headers/PrivateHeaders/'`"
		    fi
	            ;;
	    esac
	    result="Using ${TCL_INCLUDES}"
	else
	    if test ! -f "${TCL_SRC_DIR}/generic/tclInt.h" ; then
		AC_MSG_ERROR([Cannot find private header tclInt.h in ${TCL_SRC_DIR}])
	    fi
	    result="Using srcdir found in tclConfig.sh: ${TCL_SRC_DIR}"
	fi
    fi

    AC_SUBST(TCL_TOP_DIR_NATIVE)

    AC_SUBST(TCL_INCLUDES)
    AC_MSG_RESULT([${result}])
])

#------------------------------------------------------------------------
# TEA_PUBLIC_TCL_HEADERS --
#
#	Locate the installed public Tcl header files
#
# Arguments:
#	None.
#
# Requires:
#	CYGPATH must be set
#
# Results:
#
#	Adds a --with-tclinclude switch to configure.
#	Result is cached.
#
#	Substs the following vars:
#		TCL_INCLUDES
#------------------------------------------------------------------------

AC_DEFUN([TEA_PUBLIC_TCL_HEADERS], [
    AC_MSG_CHECKING([for Tcl public headers])

    AC_ARG_WITH(tclinclude, [  --with-tclinclude       directory containing the public Tcl header files], with_tclinclude=${withval})

    AC_CACHE_VAL(ac_cv_c_tclh, [
	# Use the value from --with-tclinclude, if it was given

	if test x"${with_tclinclude}" != x ; then
	    if test -f "${with_tclinclude}/tcl.h" ; then
		ac_cv_c_tclh=${with_tclinclude}
	    else
		AC_MSG_ERROR([${with_tclinclude} directory does not contain tcl.h])
	    fi
	else
	    list=""
	    if test "`uname -s`" = "Darwin"; then
		# If Tcl was built as a framework, attempt to use
		# the framework's Headers directory
		case ${TCL_DEFS} in
		    *TCL_FRAMEWORK*)
			list="`ls -d ${TCL_BIN_DIR}/Headers 2>/dev/null`"
			;;
		esac
	    fi

	    # Look in the source dir only if Tcl is not installed,
	    # and in that situation, look there before installed locations.
	    if test -f "${TCL_BIN_DIR}/Makefile" ; then
		list="$list `ls -d ${TCL_SRC_DIR}/generic 2>/dev/null`"
	    fi

	    # Check order: pkg --prefix location, Tcl's --prefix location,
	    # relative to directory of tclConfig.sh.

	    eval "temp_includedir=${includedir}"
	    list="$list \
		`ls -d ${temp_includedir}        2>/dev/null` \
		`ls -d ${TCL_PREFIX}/include     2>/dev/null` \
		`ls -d ${TCL_BIN_DIR}/../include 2>/dev/null`"
	    if test "${TEA_PLATFORM}" != "windows" -o "$GCC" = "yes"; then
		list="$list /usr/local/include /usr/include"
		if test x"${TCL_INCLUDE_SPEC}" != x ; then
		    d=`echo "${TCL_INCLUDE_SPEC}" | sed -e 's/^-I//'`
		    list="$list `ls -d ${d} 2>/dev/null`"
		fi
	    fi
	    for i in $list ; do
		if test -f "$i/tcl.h" ; then
		    ac_cv_c_tclh=$i
		    break
		fi
	    done
	fi
    ])

    # Print a message based on how we determined the include path

    if test x"${ac_cv_c_tclh}" = x ; then
	AC_MSG_ERROR([tcl.h not found.  Please specify its location with --with-tclinclude])
    else
	AC_MSG_RESULT([${ac_cv_c_tclh}])
    fi

    # Convert to a native path and substitute into the output files.

    INCLUDE_DIR_NATIVE=`${CYGPATH} ${ac_cv_c_tclh}`

    TCL_INCLUDES=-I\"${INCLUDE_DIR_NATIVE}\"

    AC_SUBST(TCL_INCLUDES)
])

#------------------------------------------------------------------------
# TEA_PRIVATE_TK_HEADERS --
#
#	Locate the private Tk include files
#
# Arguments:
#
#	Requires:
#		TK_SRC_DIR	Assumes that TEA_LOAD_TKCONFIG has
#				 already been called.
#
# Results:
#
#	Substs the following vars:
#		TK_INCLUDES
#------------------------------------------------------------------------

AC_DEFUN([TEA_PRIVATE_TK_HEADERS], [
    # Allow for --with-tkinclude to take effect and define ${ac_cv_c_tkh}
    AC_REQUIRE([TEA_PUBLIC_TK_HEADERS])
    AC_MSG_CHECKING([for Tk private include files])

    TK_SRC_DIR_NATIVE=`${CYGPATH} ${TK_SRC_DIR}`
    TK_TOP_DIR_NATIVE=\"${TK_SRC_DIR_NATIVE}\"

    # Check to see if tk<Plat>Port.h isn't already with the public headers
    # Don't look for tkInt.h because that resides with tk.h in the core
    # sources, but the <plat>Port headers are in a different directory
    if test "${TEA_PLATFORM}" = "windows" -a \
	-f "${ac_cv_c_tkh}/tkWinPort.h"; then
	result="private headers found with public headers"
    elif test "${TEA_PLATFORM}" = "unix" -a \
	-f "${ac_cv_c_tkh}/tkUnixPort.h"; then
	result="private headers found with public headers"
    else
	TK_GENERIC_DIR_NATIVE=\"${TK_SRC_DIR_NATIVE}/generic\"
	TK_XLIB_DIR_NATIVE=\"${TK_SRC_DIR_NATIVE}/xlib\"
	if test "${TEA_PLATFORM}" = "windows"; then
	    TK_PLATFORM_DIR_NATIVE=\"${TK_SRC_DIR_NATIVE}/win\"
	else
	    TK_PLATFORM_DIR_NATIVE=\"${TK_SRC_DIR_NATIVE}/unix\"
	fi
	# Overwrite the previous TK_INCLUDES as this should capture both
	# public and private headers in the same set.
	# We want to ensure these are substituted so as not to require
	# any *_NATIVE vars be defined in the Makefile
	TK_INCLUDES="-I${TK_GENERIC_DIR_NATIVE} -I${TK_PLATFORM_DIR_NATIVE}"
	# Detect and add ttk subdir
	if test -d "${TK_SRC_DIR}/generic/ttk"; then
	   TK_INCLUDES="${TK_INCLUDES} -I\"${TK_SRC_DIR_NATIVE}/generic/ttk\""
	fi
	if test "${TEA_WINDOWINGSYSTEM}" != "x11"; then
	   TK_INCLUDES="${TK_INCLUDES} -I\"${TK_XLIB_DIR_NATIVE}\""
	fi
	if test "${TEA_WINDOWINGSYSTEM}" = "aqua"; then
	   TK_INCLUDES="${TK_INCLUDES} -I\"${TK_SRC_DIR_NATIVE}/macosx\""
	fi
	if test "`uname -s`" = "Darwin"; then
	    # If Tk was built as a framework, attempt to use
	    # the framework's Headers and PrivateHeaders directories
	    case ${TK_DEFS} in
		*TK_FRAMEWORK*)
			if test -d "${TK_BIN_DIR}/Headers" -a \
				-d "${TK_BIN_DIR}/PrivateHeaders"; then
			    TK_INCLUDES="-I\"${TK_BIN_DIR}/Headers\" -I\"${TK_BIN_DIR}/PrivateHeaders\" ${TK_INCLUDES}"
			else
			    TK_INCLUDES="${TK_INCLUDES} ${TK_INCLUDE_SPEC} `echo "${TK_INCLUDE_SPEC}" | sed -e 's/Headers/PrivateHeaders/'`"
			fi
			;;
	    esac
	    result="Using ${TK_INCLUDES}"
	else
	    if test ! -f "${TK_SRC_DIR}/generic/tkInt.h" ; then
	       AC_MSG_ERROR([Cannot find private header tkInt.h in ${TK_SRC_DIR}])
	    fi
	    result="Using srcdir found in tkConfig.sh: ${TK_SRC_DIR}"
	fi
    fi

    AC_SUBST(TK_TOP_DIR_NATIVE)
    AC_SUBST(TK_XLIB_DIR_NATIVE)

    AC_SUBST(TK_INCLUDES)
    AC_MSG_RESULT([${result}])
])

#------------------------------------------------------------------------
# TEA_PUBLIC_TK_HEADERS --
#
#	Locate the installed public Tk header files
#
# Arguments:
#	None.
#
# Requires:
#	CYGPATH must be set
#
# Results:
#
#	Adds a --with-tkinclude switch to configure.
#	Result is cached.
#
#	Substs the following vars:
#		TK_INCLUDES
#------------------------------------------------------------------------

AC_DEFUN([TEA_PUBLIC_TK_HEADERS], [
    AC_MSG_CHECKING([for Tk public headers])

    AC_ARG_WITH(tkinclude, [  --with-tkinclude        directory containing the public Tk header files], with_tkinclude=${withval})

    AC_CACHE_VAL(ac_cv_c_tkh, [
	# Use the value from --with-tkinclude, if it was given

	if test x"${with_tkinclude}" != x ; then
	    if test -f "${with_tkinclude}/tk.h" ; then
		ac_cv_c_tkh=${with_tkinclude}
	    else
		AC_MSG_ERROR([${with_tkinclude} directory does not contain tk.h])
	    fi
	else
	    list=""
	    if test "`uname -s`" = "Darwin"; then
		# If Tk was built as a framework, attempt to use
		# the framework's Headers directory.
		case ${TK_DEFS} in
		    *TK_FRAMEWORK*)
			list="`ls -d ${TK_BIN_DIR}/Headers 2>/dev/null`"
			;;
		esac
	    fi

	    # Look in the source dir only if Tk is not installed,
	    # and in that situation, look there before installed locations.
	    if test -f "${TK_BIN_DIR}/Makefile" ; then
		list="$list `ls -d ${TK_SRC_DIR}/generic 2>/dev/null`"
	    fi

	    # Check order: pkg --prefix location, Tk's --prefix location,
	    # relative to directory of tkConfig.sh, Tcl's --prefix location,
	    # relative to directory of tclConfig.sh.

	    eval "temp_includedir=${includedir}"
	    list="$list \
		`ls -d ${temp_includedir}        2>/dev/null` \
		`ls -d ${TK_PREFIX}/include      2>/dev/null` \
		`ls -d ${TK_BIN_DIR}/../include  2>/dev/null` \
		`ls -d ${TCL_PREFIX}/include     2>/dev/null` \
		`ls -d ${TCL_BIN_DIR}/../include 2>/dev/null`"
	    if test "${TEA_PLATFORM}" != "windows" -o "$GCC" = "yes"; then
		list="$list /usr/local/include /usr/include"
		if test x"${TK_INCLUDE_SPEC}" != x ; then
		    d=`echo "${TK_INCLUDE_SPEC}" | sed -e 's/^-I//'`
		    list="$list `ls -d ${d} 2>/dev/null`"
		fi
	    fi
	    for i in $list ; do
		if test -f "$i/tk.h" ; then
		    ac_cv_c_tkh=$i
		    break
		fi
	    done
	fi
    ])

    # Print a message based on how we determined the include path

    if test x"${ac_cv_c_tkh}" = x ; then
	AC_MSG_ERROR([tk.h not found.  Please specify its location with --with-tkinclude])
    else
	AC_MSG_RESULT([${ac_cv_c_tkh}])
    fi

    # Convert to a native path and substitute into the output files.

    INCLUDE_DIR_NATIVE=`${CYGPATH} ${ac_cv_c_tkh}`

    TK_INCLUDES=-I\"${INCLUDE_DIR_NATIVE}\"

    AC_SUBST(TK_INCLUDES)

    if test "${TEA_WINDOWINGSYSTEM}" != "x11"; then
	# On Windows and Aqua, we need the X compat headers
	AC_MSG_CHECKING([for X11 header files])
	if test ! -r "${INCLUDE_DIR_NATIVE}/X11/Xlib.h"; then
	    INCLUDE_DIR_NATIVE="`${CYGPATH} ${TK_SRC_DIR}/xlib`"
	    TK_XINCLUDES=-I\"${INCLUDE_DIR_NATIVE}\"
	    AC_SUBST(TK_XINCLUDES)
	fi
	AC_MSG_RESULT([${INCLUDE_DIR_NATIVE}])
    fi
])

#------------------------------------------------------------------------
# TEA_PATH_CONFIG --
#
#	Locate the ${1}Config.sh file and perform a sanity check on
#	the ${1} compile flags.  These are used by packages like
#	[incr Tk] that load *Config.sh files from more than Tcl and Tk.
#
# Arguments:
#	none
#
# Results:
#
#	Adds the following arguments to configure:
#		--with-$1=...
#
#	Defines the following vars:
#		$1_BIN_DIR	Full path to the directory containing
#				the $1Config.sh file
#------------------------------------------------------------------------

AC_DEFUN([TEA_PATH_CONFIG], [
    #
    # Ok, lets find the $1 configuration
    # First, look for one uninstalled.
    # the alternative search directory is invoked by --with-$1
    #

    if test x"${no_$1}" = x ; then
	# we reset no_$1 in case something fails here
	no_$1=true
	AC_ARG_WITH($1, [  --with-$1              directory containing $1 configuration ($1Config.sh)], with_$1config=${withval})
	AC_MSG_CHECKING([for $1 configuration])
	AC_CACHE_VAL(ac_cv_c_$1config,[

	    # First check to see if --with-$1 was specified.
	    if test x"${with_$1config}" != x ; then
		case ${with_$1config} in
		    */$1Config.sh )
			if test -f ${with_$1config}; then
			    AC_MSG_WARN([--with-$1 argument should refer to directory containing $1Config.sh, not to $1Config.sh itself])
			    with_$1config=`echo ${with_$1config} | sed 's!/$1Config\.sh$!!'`
			fi;;
		esac
		if test -f "${with_$1config}/$1Config.sh" ; then
		    ac_cv_c_$1config=`(cd ${with_$1config}; pwd)`
		else
		    AC_MSG_ERROR([${with_$1config} directory doesn't contain $1Config.sh])
		fi
	    fi

	    # then check for a private $1 installation
	    if test x"${ac_cv_c_$1config}" = x ; then
		for i in \
			../$1 \
			`ls -dr ../$1*[[0-9]].[[0-9]]*.[[0-9]]* 2>/dev/null` \
			`ls -dr ../$1*[[0-9]].[[0-9]][[0-9]] 2>/dev/null` \
			`ls -dr ../$1*[[0-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ../$1*[[0-9]].[[0-9]]* 2>/dev/null` \
			../../$1 \
			`ls -dr ../../$1*[[0-9]].[[0-9]]*.[[0-9]]* 2>/dev/null` \
			`ls -dr ../../$1*[[0-9]].[[0-9]][[0-9]] 2>/dev/null` \
			`ls -dr ../../$1*[[0-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ../../$1*[[0-9]].[[0-9]]* 2>/dev/null` \
			../../../$1 \
			`ls -dr ../../../$1*[[0-9]].[[0-9]]*.[[0-9]]* 2>/dev/null` \
			`ls -dr ../../../$1*[[0-9]].[[0-9]][[0-9]] 2>/dev/null` \
			`ls -dr ../../../$1*[[0-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ../../../$1*[[0-9]].[[0-9]]* 2>/dev/null` \
			${srcdir}/../$1 \
			`ls -dr ${srcdir}/../$1*[[0-9]].[[0-9]]*.[[0-9]]* 2>/dev/null` \
			`ls -dr ${srcdir}/../$1*[[0-9]].[[0-9]][[0-9]] 2>/dev/null` \
			`ls -dr ${srcdir}/../$1*[[0-9]].[[0-9]] 2>/dev/null` \
			`ls -dr ${srcdir}/../$1*[[0-9]].[[0-9]]* 2>/dev/null` \
			; do
		    if test -f "$i/$1Config.sh" ; then
			ac_cv_c_$1config=`(cd $i; pwd)`
			break
		    fi
		    if test -f "$i/unix/$1Config.sh" ; then
			ac_cv_c_$1config=`(cd $i/unix; pwd)`
			break
		    fi
		done
	    fi

	    # check in a few common install locations
	    if test x"${ac_cv_c_$1config}" = x ; then
		for i in `ls -d ${libdir} 2>/dev/null` \
			`ls -d ${exec_prefix}/lib 2>/dev/null` \
			`ls -d ${prefix}/lib 2>/dev/null` \
			`ls -d /usr/local/lib 2>/dev/null` \
			`ls -d /usr/contrib/lib 2>/dev/null` \
			`ls -d /usr/lib 2>/dev/null` \
			`ls -d /usr/lib64 2>/dev/null` \
			; do
		    if test -f "$i/$1Config.sh" ; then
			ac_cv_c_$1config=`(cd $i; pwd)`
			break
		    fi
		done
	    fi
	])

	if test x"${ac_cv_c_$1config}" = x ; then
	    $1_BIN_DIR="# no $1 configs found"
	    AC_MSG_WARN([Cannot find $1 configuration definitions])
	    exit 0
	else
	    no_$1=
	    $1_BIN_DIR=${ac_cv_c_$1config}
	    AC_MSG_RESULT([found $$1_BIN_DIR/$1Config.sh])
	fi
    fi
])

#------------------------------------------------------------------------
# TEA_LOAD_CONFIG --
#
#	Load the $1Config.sh file
#
# Arguments:
#
#	Requires the following vars to be set:
#		$1_BIN_DIR
#
# Results:
#
#	Subst the following vars:
#		$1_SRC_DIR
#		$1_LIB_FILE
#		$1_LIB_SPEC
#
#------------------------------------------------------------------------

AC_DEFUN([TEA_LOAD_CONFIG], [
    AC_MSG_CHECKING([for existence of ${$1_BIN_DIR}/$1Config.sh])

    if test -f "${$1_BIN_DIR}/$1Config.sh" ; then
        AC_MSG_RESULT([loading])
	. "${$1_BIN_DIR}/$1Config.sh"
    else
        AC_MSG_RESULT([file not found])
    fi

    #
    # If the $1_BIN_DIR is the build directory (not the install directory),
    # then set the common variable name to the value of the build variables.
    # For example, the variable $1_LIB_SPEC will be set to the value
    # of $1_BUILD_LIB_SPEC. An extension should make use of $1_LIB_SPEC
    # instead of $1_BUILD_LIB_SPEC since it will work with both an
    # installed and uninstalled version of Tcl.
    #

    if test -f "${$1_BIN_DIR}/Makefile" ; then
	AC_MSG_WARN([Found Makefile - using build library specs for $1])
        $1_LIB_SPEC=${$1_BUILD_LIB_SPEC}
        $1_STUB_LIB_SPEC=${$1_BUILD_STUB_LIB_SPEC}
        $1_STUB_LIB_PATH=${$1_BUILD_STUB_LIB_PATH}
        $1_INCLUDE_SPEC=${$1_BUILD_INCLUDE_SPEC}
        $1_LIBRARY_PATH=${$1_LIBRARY_PATH}
    fi

    AC_SUBST($1_VERSION)
    AC_SUBST($1_BIN_DIR)
    AC_SUBST($1_SRC_DIR)

    AC_SUBST($1_LIB_FILE)
    AC_SUBST($1_LIB_SPEC)

    AC_SUBST($1_STUB_LIB_FILE)
    AC_SUBST($1_STUB_LIB_SPEC)
    AC_SUBST($1_STUB_LIB_PATH)

    # Allow the caller to prevent this auto-check by specifying any 2nd arg
    AS_IF([test "x$2" = x], [
	# Check both upper and lower-case variants
	# If a dev wanted non-stubs libs, this function could take an option
	# to not use _STUB in the paths below
	AS_IF([test "x${$1_STUB_LIB_SPEC}" = x],
	    [TEA_LOAD_CONFIG_LIB(translit($1,[a-z],[A-Z])_STUB)],
	    [TEA_LOAD_CONFIG_LIB($1_STUB)])
    ])
])

#------------------------------------------------------------------------
# TEA_LOAD_CONFIG_LIB --
#
#	Helper function to load correct library from another extension's
#	${PACKAGE}Config.sh.
#
# Results:
#	Adds to LIBS the appropriate extension library
#
#------------------------------------------------------------------------
AC_DEFUN([TEA_LOAD_CONFIG_LIB], [
    AC_MSG_CHECKING([For $1 library for LIBS])
    # This simplifies the use of stub libraries by automatically adding
    # the stub lib to your path.  Normally this would add to SHLIB_LD_LIBS,
    # but this is called before CONFIG_CFLAGS.  More importantly, this adds
    # to PKG_LIBS, which becomes LIBS, and that is only used by SHLIB_LD.
    if test "x${$1_LIB_SPEC}" != "x" ; then
	if test "${TEA_PLATFORM}" = "windows" -a "$GCC" != "yes" ; then
	    TEA_ADD_LIBS([\"`${CYGPATH} ${$1_LIB_PATH}`\"])
	    AC_MSG_RESULT([using $1_LIB_PATH ${$1_LIB_PATH}])
	else
	    TEA_ADD_LIBS([${$1_LIB_SPEC}])
	    AC_MSG_RESULT([using $1_LIB_SPEC ${$1_LIB_SPEC}])
	fi
    else
	AC_MSG_RESULT([file not found])
    fi
])

#------------------------------------------------------------------------
# TEA_EXPORT_CONFIG --
#
#	Define the data to insert into the ${PACKAGE}Config.sh file
#
# Arguments:
#
#	Requires the following vars to be set:
#		$1
#
# Results:
#	Subst the following vars:
#
#------------------------------------------------------------------------

AC_DEFUN([TEA_EXPORT_CONFIG], [
    #--------------------------------------------------------------------
    # These are for $1Config.sh
    #--------------------------------------------------------------------

    # pkglibdir must be a fully qualified path and (not ${exec_prefix}/lib)
    eval pkglibdir="[$]{libdir}/$1${PACKAGE_VERSION}"
    if test "${TCL_LIB_VERSIONS_OK}" = "ok"; then
	eval $1_LIB_FLAG="-l$1${PACKAGE_VERSION}${DBGX}"
	eval $1_STUB_LIB_FLAG="-l$1stub${PACKAGE_VERSION}${DBGX}"
    else
	eval $1_LIB_FLAG="-l$1`echo ${PACKAGE_VERSION} | tr -d .`${DBGX}"
	eval $1_STUB_LIB_FLAG="-l$1stub`echo ${PACKAGE_VERSION} | tr -d .`${DBGX}"
    fi
    $1_BUILD_LIB_SPEC="-L`pwd` ${$1_LIB_FLAG}"
    $1_LIB_SPEC="-L${pkglibdir} ${$1_LIB_FLAG}"
    $1_BUILD_STUB_LIB_SPEC="-L`pwd` [$]{$1_STUB_LIB_FLAG}"
    $1_STUB_LIB_SPEC="-L${pkglibdir} [$]{$1_STUB_LIB_FLAG}"
    $1_BUILD_STUB_LIB_PATH="`pwd`/[$]{PKG_STUB_LIB_FILE}"
    $1_STUB_LIB_PATH="${pkglibdir}/[$]{PKG_STUB_LIB_FILE}"

    AC_SUBST($1_BUILD_LIB_SPEC)
    AC_SUBST($1_LIB_SPEC)
    AC_SUBST($1_BUILD_STUB_LIB_SPEC)
    AC_SUBST($1_STUB_LIB_SPEC)
    AC_SUBST($1_BUILD_STUB_LIB_PATH)
    AC_SUBST($1_STUB_LIB_PATH)

    AC_SUBST(MAJOR_VERSION)
    AC_SUBST(MINOR_VERSION)
    AC_SUBST(PATCHLEVEL)
])


#------------------------------------------------------------------------
# TEA_PATH_CELIB --
#
#	Locate Keuchel's celib emulation layer for targeting Win/CE
#
# Arguments:
#	none
#
# Results:
#
#	Adds the following arguments to configure:
#		--with-celib=...
#
#	Defines the following vars:
#		CELIB_DIR	Full path to the directory containing
#				the include and platform lib files
#------------------------------------------------------------------------

AC_DEFUN([TEA_PATH_CELIB], [
    # First, look for one uninstalled.
    # the alternative search directory is invoked by --with-celib

    if test x"${no_celib}" = x ; then
	# we reset no_celib in case something fails here
	no_celib=true
	AC_ARG_WITH(celib,[  --with-celib=DIR        use Windows/CE support library from DIR], with_celibconfig=${withval})
	AC_MSG_CHECKING([for Windows/CE celib directory])
	AC_CACHE_VAL(ac_cv_c_celibconfig,[
	    # First check to see if --with-celibconfig was specified.
	    if test x"${with_celibconfig}" != x ; then
		if test -d "${with_celibconfig}/inc" ; then
		    ac_cv_c_celibconfig=`(cd ${with_celibconfig}; pwd)`
		else
		    AC_MSG_ERROR([${with_celibconfig} directory doesn't contain inc directory])
		fi
	    fi

	    # then check for a celib library
	    if test x"${ac_cv_c_celibconfig}" = x ; then
		for i in \
			../celib-palm-3.0 \
			../celib \
			../../celib-palm-3.0 \
			../../celib \
			`ls -dr ../celib-*3.[[0-9]]* 2>/dev/null` \
			${srcdir}/../celib-palm-3.0 \
			${srcdir}/../celib \
			`ls -dr ${srcdir}/../celib-*3.[[0-9]]* 2>/dev/null` \
			; do
		    if test -d "$i/inc" ; then
			ac_cv_c_celibconfig=`(cd $i; pwd)`
			break
		    fi
		done
	    fi
	])
	if test x"${ac_cv_c_celibconfig}" = x ; then
	    AC_MSG_ERROR([Cannot find celib support library directory])
	else
	    no_celib=
	    CELIB_DIR=${ac_cv_c_celibconfig}
	    CELIB_DIR=`echo "$CELIB_DIR" | sed -e 's!\\\!/!g'`
	    AC_MSG_RESULT([found $CELIB_DIR])
	fi
    fi
])


# Local Variables:
# mode: autoconf
# End:
blob
data 11176
#include "tcl.h"
#include "tk.h"
#include <X11/Xlib.h>
#include <X11/X.h>

/*
 * Define DND Cursors...
 */

/* No Drop Cursor... */
#define noDropCursorWidth  20
#define noDropCursorHeight 20
#define noDropCursorX      10
#define noDropCursorY      10
static unsigned char noDropCurBits[] = {
 0x00,0x00,0x00,0x80,0x1f,0x00,0xe0,0x7f,0x00,0xf0,0xf0,0x00,0x38,0xc0,0x01,
 0x7c,0x80,0x03,0xec,0x00,0x03,0xce,0x01,0x07,0x86,0x03,0x06,0x06,0x07,0x06,
 0x06,0x0e,0x06,0x06,0x1c,0x06,0x0e,0x38,0x07,0x0c,0x70,0x03,0x1c,0xe0,0x03,
 0x38,0xc0,0x01,0xf0,0xe0,0x00,0xe0,0x7f,0x00,0x80,0x1f,0x00,0x00,0x00,0x00};

static unsigned char noDropCurMask[] = {
 0x80,0x1f,0x00,0xe0,0x7f,0x00,0xf0,0xff,0x00,0xf8,0xff,0x01,0xfc,0xf0,0x03,
 0xfe,0xc0,0x07,0xfe,0x81,0x07,0xff,0x83,0x0f,0xcf,0x07,0x0f,0x8f,0x0f,0x0f,
 0x0f,0x1f,0x0f,0x0f,0x3e,0x0f,0x1f,0xfc,0x0f,0x1e,0xf8,0x07,0x3e,0xf0,0x07,
 0xfc,0xe0,0x03,0xf8,0xff,0x01,0xf0,0xff,0x00,0xe0,0x7f,0x00,0x80,0x1f,0x00};
 
/* Copy Cursor... */
#define CopyCursorWidth  29
#define CopyCursorHeight 25
#define CopyCursorX      10
#define CopyCursorY      10
static unsigned char CopyCurBits[] =
{
  0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x02, 0x00, 0x08, 0x01,
  0x02, 0x00, 0x08, 0x01, 0x02, 0x00, 0x08, 0x01, 0x02, 0x00, 0xe8, 0x0f,
  0x02, 0x00, 0x08, 0x01, 0x02, 0x00, 0x08, 0x01, 0x02, 0x00, 0x08, 0x01,
  0x02, 0x00, 0x08, 0x00, 0x02, 0x04, 0x08, 0x00, 0x02, 0x0c, 0x08, 0x00,
  0x02, 0x1c, 0x08, 0x00, 0x02, 0x3c, 0x08, 0x00, 0x02, 0x7c, 0x08, 0x00,
  0x02, 0xfc, 0x08, 0x00, 0x02, 0xfc, 0x09, 0x00, 0x02, 0xfc, 0x0b, 0x00,
  0x02, 0x7c, 0x08, 0x00, 0xfe, 0x6d, 0x0f, 0x00, 0x00, 0xc4, 0x00, 0x00,
  0x00, 0xc0, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00};

static unsigned char CopyCurMask[] =
{
  0xff, 0xff, 0x1f, 0x00, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0x1f,
  0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f,
  0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f,
  0x07, 0x06, 0xfc, 0x1f, 0x07, 0x0e, 0xfc, 0x1f, 0x07, 0x1e, 0x1c, 0x00,
  0x07, 0x3e, 0x1c, 0x00, 0x07, 0x7e, 0x1c, 0x00, 0x07, 0xfe, 0x1c, 0x00,
  0x07, 0xfe, 0x1d, 0x00, 0x07, 0xfe, 0x1f, 0x00, 0x07, 0xfe, 0x1f, 0x00,
  0xff, 0xff, 0x1f, 0x00, 0xff, 0xff, 0x1e, 0x00, 0xff, 0xef, 0x1f, 0x00,
  0x00, 0xe6, 0x01, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0xc0, 0x03, 0x00,
  0x00, 0x80, 0x01, 0x00};

/* Move Cursor... */
#define MoveCursorWidth  21
#define MoveCursorHeight 25
#define MoveCursorX      10
#define MoveCursorY      10
static unsigned char MoveCurBits[] =
{
  0x00, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x02, 0x00, 0x08, 0x02, 0x00, 0x08,
  0x02, 0x00, 0x08, 0x02, 0x00, 0x08, 0x02, 0x00, 0x08, 0x02, 0x00, 0x08,
  0x02, 0x00, 0x08, 0x02, 0x00, 0x08, 0x02, 0x04, 0x08, 0x02, 0x0c, 0x08,
  0x02, 0x1c, 0x08, 0x02, 0x3c, 0x08, 0x02, 0x7c, 0x08, 0x02, 0xfc, 0x08,
  0x02, 0xfc, 0x09, 0x02, 0xfc, 0x0b, 0x02, 0x7c, 0x08, 0xfe, 0x6d, 0x0f,
  0x00, 0xc4, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x80, 0x01, 0x00, 0x80, 0x01,
  0x00, 0x00, 0x00};

static unsigned char MoveCurMask[] =
{
  0xff, 0xff, 0x1f, 0xff, 0xff, 0x1f, 0xff, 0xff, 0x1f, 0x07, 0x00, 0x1c,
  0x07, 0x00, 0x1c, 0x07, 0x00, 0x1c, 0x07, 0x00, 0x1c, 0x07, 0x00, 0x1c,
  0x07, 0x00, 0x1c, 0x07, 0x06, 0x1c, 0x07, 0x0e, 0x1c, 0x07, 0x1e, 0x1c,
  0x07, 0x3e, 0x1c, 0x07, 0x7e, 0x1c, 0x07, 0xfe, 0x1c, 0x07, 0xfe, 0x1d,
  0x07, 0xfe, 0x1f, 0x07, 0xfe, 0x1f, 0xff, 0xff, 0x1f, 0xff, 0xff, 0x1e,
  0xff, 0xef, 0x1f, 0x00, 0xe6, 0x01, 0x00, 0xc0, 0x03, 0x00, 0xc0, 0x03,
  0x00, 0x80, 0x01};

/* Link Cursor... */
#define LinkCursorWidth  29
#define LinkCursorHeight 25
#define LinkCursorX      10
#define LinkCursorY      10
static unsigned char LinkCurBits[] =
{
  0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x02, 0x00, 0x08, 0x01,
  0x02, 0x00, 0x88, 0x00, 0x02, 0x00, 0x48, 0x00, 0x02, 0x00, 0xe8, 0x0f,
  0x02, 0x00, 0x48, 0x00, 0x02, 0x00, 0x88, 0x00, 0x02, 0x00, 0x08, 0x01,
  0x02, 0x00, 0x08, 0x00, 0x02, 0x04, 0x08, 0x00, 0x02, 0x0c, 0x08, 0x00,
  0x02, 0x1c, 0x08, 0x00, 0x02, 0x3c, 0x08, 0x00, 0x02, 0x7c, 0x08, 0x00,
  0x02, 0xfc, 0x08, 0x00, 0x02, 0xfc, 0x09, 0x00, 0x02, 0xfc, 0x0b, 0x00,
  0x02, 0x7c, 0x08, 0x00, 0xfe, 0x6d, 0x0f, 0x00, 0x00, 0xc4, 0x00, 0x00,
  0x00, 0xc0, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00};

static unsigned char LinkCurMask[] =
{
  0xff, 0xff, 0x1f, 0x00, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0x1f,
  0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f,
  0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f,
  0x07, 0x06, 0xfc, 0x1f, 0x07, 0x0e, 0xfc, 0x1f, 0x07, 0x1e, 0x1c, 0x00,
  0x07, 0x3e, 0x1c, 0x00, 0x07, 0x7e, 0x1c, 0x00, 0x07, 0xfe, 0x1c, 0x00,
  0x07, 0xfe, 0x1d, 0x00, 0x07, 0xfe, 0x1f, 0x00, 0x07, 0xfe, 0x1f, 0x00,
  0xff, 0xff, 0x1f, 0x00, 0xff, 0xff, 0x1e, 0x00, 0xff, 0xef, 0x1f, 0x00,
  0x00, 0xe6, 0x01, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0xc0, 0x03, 0x00,
  0x00, 0x80, 0x01, 0x00};

/* Ask Cursor... */
#define AskCursorWidth  29
#define AskCursorHeight 25
#define AskCursorX      10
#define AskCursorY      10
static unsigned char AskCurBits[] =
{
  0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0x0f, 0x00, 0x02, 0x00, 0x88, 0x03,
  0x02, 0x00, 0x48, 0x04, 0x02, 0x00, 0x08, 0x04, 0x02, 0x00, 0x08, 0x02,
  0x02, 0x00, 0x08, 0x01, 0x02, 0x00, 0x08, 0x01, 0x02, 0x00, 0x08, 0x00,
  0x02, 0x00, 0x08, 0x01, 0x02, 0x04, 0x08, 0x00, 0x02, 0x0c, 0x08, 0x00,
  0x02, 0x1c, 0x08, 0x00, 0x02, 0x3c, 0x08, 0x00, 0x02, 0x7c, 0x08, 0x00,
  0x02, 0xfc, 0x08, 0x00, 0x02, 0xfc, 0x09, 0x00, 0x02, 0xfc, 0x0b, 0x00,
  0x02, 0x7c, 0x08, 0x00, 0xfe, 0x6d, 0x0f, 0x00, 0x00, 0xc4, 0x00, 0x00,
  0x00, 0xc0, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00};

static unsigned char AskCurMask[] =
{
  0xff, 0xff, 0x1f, 0x00, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0x1f,
  0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f,
  0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f, 0x07, 0x00, 0xfc, 0x1f,
  0x07, 0x06, 0xfc, 0x1f, 0x07, 0x0e, 0xfc, 0x1f, 0x07, 0x1e, 0x1c, 0x00,
  0x07, 0x3e, 0x1c, 0x00, 0x07, 0x7e, 0x1c, 0x00, 0x07, 0xfe, 0x1c, 0x00,
  0x07, 0xfe, 0x1d, 0x00, 0x07, 0xfe, 0x1f, 0x00, 0x07, 0xfe, 0x1f, 0x00,
  0xff, 0xff, 0x1f, 0x00, 0xff, 0xff, 0x1e, 0x00, 0xff, 0xef, 0x1f, 0x00,
  0x00, 0xe6, 0x01, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0xc0, 0x03, 0x00,
  0x00, 0x80, 0x01, 0x00};

static Cursor noDropCursor = 0,
              moveCursor   = 0,
              copyCursor   = 0,
              linkCursor   = 0,
              askCursor    = 0;


void TkDND_InitialiseCursors(Tcl_Interp *interp) {
  XColor black, white;
  Pixmap image_pixmap, mask_pixmap;
  Tk_Window main_window;
  Display *display;
  Window RootWindow;

  if (!interp) return;
  main_window   = Tk_MainWindow(interp);
  Tk_MakeWindowExist(main_window);
  display       = Tk_Display(main_window);
  RootWindow    = DefaultRootWindow(display);
  
  black.pixel = BlackPixel(display, DefaultScreen(display));
  white.pixel = WhitePixel(display, DefaultScreen(display));
  XQueryColor(display, DefaultColormap(display, 
          DefaultScreen(display)), &black);
  XQueryColor(display, DefaultColormap(display,
          DefaultScreen(display)), &white);
  /* No Drop Cursor */
  if (!noDropCursor) {
    image_pixmap = XCreateBitmapFromData(display, RootWindow,
            (char *) noDropCurBits, noDropCursorWidth, noDropCursorHeight);
    mask_pixmap  = XCreateBitmapFromData(display, RootWindow,
            (char *) noDropCurMask, noDropCursorWidth, noDropCursorHeight);
    noDropCursor = XCreatePixmapCursor (display, image_pixmap,
            mask_pixmap, &black, &white, noDropCursorX, noDropCursorY);
    XFreePixmap (display, image_pixmap);
    XFreePixmap (display, mask_pixmap);
  }
  /* Copy Cursor */
  if (!copyCursor) {
    image_pixmap = XCreateBitmapFromData(display, RootWindow,
            (char *) CopyCurBits, CopyCursorWidth, CopyCursorHeight);
    mask_pixmap  = XCreateBitmapFromData(display, RootWindow,
            (char *) CopyCurMask, CopyCursorWidth, CopyCursorHeight);
    copyCursor   = XCreatePixmapCursor (display, image_pixmap,
            mask_pixmap, &black, &white, CopyCursorX, CopyCursorY);
    XFreePixmap (display, image_pixmap);
    XFreePixmap (display, mask_pixmap);
  }
  /* Move Cursor */
  if (!moveCursor) {
    image_pixmap = XCreateBitmapFromData(display, RootWindow,
            (char *) MoveCurBits, MoveCursorWidth, MoveCursorHeight);
    mask_pixmap  = XCreateBitmapFromData(display, RootWindow,
            (char *) MoveCurMask, MoveCursorWidth, MoveCursorHeight);
    moveCursor   = XCreatePixmapCursor (display, image_pixmap,
            mask_pixmap, &black, &white, MoveCursorX, MoveCursorY);
    XFreePixmap (display, image_pixmap);
    XFreePixmap (display, mask_pixmap);
  }
  /* Link Cursor */
  if (!linkCursor) {
    image_pixmap = XCreateBitmapFromData(display, RootWindow,
            (char *) LinkCurBits, LinkCursorWidth, LinkCursorHeight);
    mask_pixmap  = XCreateBitmapFromData(display, RootWindow,
            (char *) LinkCurMask, LinkCursorWidth, LinkCursorHeight);
    linkCursor   = XCreatePixmapCursor (display, image_pixmap,
            mask_pixmap, &black, &white, LinkCursorX, LinkCursorY);
    XFreePixmap (display, image_pixmap);
    XFreePixmap (display, mask_pixmap);
  }
  /* Ask Cursor */
  if (!askCursor) {
    image_pixmap = XCreateBitmapFromData(display, RootWindow,
            (char *) AskCurBits, AskCursorWidth, AskCursorHeight);
    mask_pixmap  = XCreateBitmapFromData(display, RootWindow,
            (char *) AskCurMask, AskCursorWidth, AskCursorHeight);
    askCursor    = XCreatePixmapCursor (display, image_pixmap,
            mask_pixmap, &black, &white, AskCursorX, AskCursorY);
    XFreePixmap (display, image_pixmap);
    XFreePixmap (display, mask_pixmap);
  }
  /* Register Cursors... */
}; /* TkDND_InitialiseCursors */

Tk_Cursor TkDND_GetCursor(Tcl_Interp *interp, Tcl_Obj *name) {
  static char *DropActions[] = {
    "copy", "move", "link", "ask",  "private", "refuse_drop", "default",
    (char *) NULL
  };
  enum dropactions {
    ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate,
    refuse_drop, ActionDefault
  };
  int status, index;
  Tk_Cursor cursor;

  status = Tcl_GetIndexFromObj(interp, name, (const char **) DropActions,
                              "dropactions", 0, &index);
  if (status == TCL_OK) {
    switch ((enum dropactions) index) {
      case ActionDefault:
      case ActionCopy:    return (Tk_Cursor) copyCursor;
      case ActionMove:    return (Tk_Cursor) moveCursor;
      case ActionLink:    return (Tk_Cursor) linkCursor;
      case ActionAsk:     return (Tk_Cursor) askCursor;
      case ActionPrivate: return (Tk_Cursor) askCursor;
      case refuse_drop:   return (Tk_Cursor) noDropCursor;
    }
  }
  /* The name is not an action. Try Tk cursors... */
  cursor = Tk_AllocCursorFromObj(interp, Tk_MainWindow(interp), name);
  if (cursor == None) {
    Tcl_SetResult(interp, "invalid cursor name", TCL_STATIC);
    return (Tk_Cursor) None;
  }
  return cursor;
}; /* TkDND_GetCursor */
blob
data 60601
/*
 * TkDND_XDND.h -- Tk XDND Drag'n'Drop Protocol Implementation
 * 
 *    This file implements the unix portion of the drag&drop mechanism
 *    for the tk toolkit. The protocol in use under unix is the
 *    XDND protocol.
 *
 * This software is copyrighted by:
 * Georgios Petasis, Athens, Greece.
 * e-mail: petasisg@yahoo.gr, petasis@iit.demokritos.gr
 *
 * The following terms apply to all files associated
 * with the software unless explicitly disclaimed in individual files.
 *
 * The authors hereby grant permission to use, copy, modify, distribute,
 * and license this software and its documentation for any purpose, provided
 * that existing copyright notices are retained in all copies and that this
 * notice is included verbatim in any distributions. No written agreement,
 * license, or royalty fee is required for any of the authorized uses.
 * Modifications to this software may be copyrighted by their authors
 * and need not follow the licensing terms described here, provided that
 * the new terms are clearly indicated on the first page of each file where
 * they apply.
 * 
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 * ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
 * DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
 * IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
 * NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 */
#include "tcl.h"
#include "tk.h"
#include <string.h>
#include <stdlib.h>
#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xatom.h>
#include <X11/keysym.h>

#ifdef HAVE_LIMITS_H
#include "limits.h"
#else
#define LONG_MAX 0x7FFFFFFFL
#endif

/*
#define TKDND_SET_XDND_PROPERTY_ON_TARGET
#define TKDND_SET_XDND_PROPERTY_ON_WRAPPER
#define DEBUG_CLIENTMESSAGE_HANDLER
 */
#define TKDND_SET_XDND_PROPERTY_ON_TOPLEVEL

#define TkDND_TkWindowChildren(tkwin) \
    ((Tk_Window) (((Tk_FakeWin *) (tkwin))->dummy2))

#define TkDND_TkWindowLastChild(tkwin) \
    ((Tk_Window) (((Tk_FakeWin *) (tkwin))->dummy3))

#define TkDND_TkWin(x) \
  (Tk_NameToWindow(interp, Tcl_GetString(x), Tk_MainWindow(interp)))

#define TkDND_Eval(objc) \
  for (i=0; i<objc; ++i) Tcl_IncrRefCount(objv[i]);\
  if (Tcl_EvalObjv(interp, objc, objv, TCL_EVAL_GLOBAL) != TCL_OK) \
      Tk_BackgroundError(interp); \
  for (i=0; i<objc; ++i) Tcl_DecrRefCount(objv[i]);

#define TkDND_Status_Eval(objc) \
  for (i=0; i<objc; ++i) Tcl_IncrRefCount(objv[i]);\
  status = Tcl_EvalObjv(interp, objc, objv, TCL_EVAL_GLOBAL);\
  if (status != TCL_OK) Tk_BackgroundError(interp); \
  for (i=0; i<objc; ++i) Tcl_DecrRefCount(objv[i]);

#define TkDND_Dict_Put(dict, k, v) \
  key   = Tcl_NewStringObj(k, -1); Tcl_IncrRefCount(key); \
  value = Tcl_NewStringObj(v, -1); Tcl_IncrRefCount(value); \
  Tcl_DictObjPut(interp, dict, key, value); \
  Tcl_DecrRefCount(key); Tcl_DecrRefCount(value);

#define TkDND_Dict_PutInt(dict, k, v) \
  key   = Tcl_NewStringObj(k, -1); Tcl_IncrRefCount(key); \
  value = Tcl_NewIntObj(v); Tcl_IncrRefCount(value); \
  Tcl_DictObjPut(interp, dict, key, value); \
  Tcl_DecrRefCount(key); Tcl_DecrRefCount(value);

#define TkDND_Dict_PutLong(dict, k, v) \
  key   = Tcl_NewStringObj(k, -1); Tcl_IncrRefCount(key); \
  value = Tcl_NewLongObj(v); Tcl_IncrRefCount(value); \
  Tcl_DictObjPut(interp, dict, key, value); \
  Tcl_DecrRefCount(key); Tcl_DecrRefCount(value);

#define TkDND_Dict_PutObj(dict, k, value) \
  key   = Tcl_NewStringObj(k, -1); Tcl_IncrRefCount(key); \
  Tcl_IncrRefCount(value); \
  Tcl_DictObjPut(interp, dict, key, value); \
  Tcl_DecrRefCount(key); Tcl_DecrRefCount(value);

#ifndef Tk_Interp
/*
 * Tk 8.5 has a new function to return the interpreter that is associated with a
 * window. Under 8.4 and earlier versions, simulate this function.
 */
#include "tkInt.h"
Tcl_Interp * TkDND_Interp(Tk_Window tkwin) {
  if (tkwin != NULL && ((TkWindow *)tkwin)->mainPtr != NULL) {
    return ((TkWindow *)tkwin)->mainPtr->interp;
  }
  return NULL;
} /* Tk_Interp */
#define Tk_Interp TkDND_Interp
#endif /* Tk_Interp */

/*
 * XDND Section
 */
#define XDND_VERSION 5

/* XdndEnter */
#define XDND_THREE 3
#define XDND_ENTER_SOURCE_WIN(e)        ((e)->xclient.data.l[0])
#define XDND_ENTER_THREE_TYPES(e)       (((e)->xclient.data.l[1] & 0x1UL) == 0)
#define XDND_ENTER_THREE_TYPES_SET(e,b) (e)->xclient.data.l[1] = ((e)->xclient.data.l[1] & ~0x1UL) | (((b) == 0) ? 0 : 0x1UL)
#define XDND_ENTER_VERSION(e)           ((e)->xclient.data.l[1] >> 24)
#define XDND_ENTER_VERSION_SET(e,v)     (e)->xclient.data.l[1] = ((e)->xclient.data.l[1] & ~(0xFF << 24)) | ((v) << 24)
#define XDND_ENTER_TYPE(e,i)            ((e)->xclient.data.l[2 + i])    /* i => (0, 1, 2) */

/* XdndPosition */
#define XDND_POSITION_SOURCE_WIN(e)     ((e)->xclient.data.l[0])
#define XDND_POSITION_ROOT_X(e)         (((e)->xclient.data.l[2] & 0xffff0000) >> 16)
#define XDND_POSITION_ROOT_Y(e)         ((e)->xclient.data.l[2] & 0x0000ffff)
#define XDND_POSITION_ROOT_SET(e,x,y)   (e)->xclient.data.l[2]  = ((x) << 16) | ((y) & 0xFFFFUL)
#define XDND_POSITION_TIME(e)           ((e)->xclient.data.l[3])
#define XDND_POSITION_ACTION(e)         ((e)->xclient.data.l[4])

/* XdndStatus */
#define XDND_STATUS_TARGET_WIN(e)       ((e)->xclient.data.l[0])
#define XDND_STATUS_WILL_ACCEPT(e)      ((e)->xclient.data.l[1] & 0x1L)
#define XDND_STATUS_WILL_ACCEPT_SET(e,b) (e)->xclient.data.l[1] = ((e)->xclient.data.l[1] & ~0x1UL) | (((b) == 0) ? 0 : 0x1UL)
#define XDND_STATUS_WANT_POSITION(e)    ((e)->xclient.data.l[1] & 0x2UL)
#define XDND_STATUS_WANT_POSITION_SET(e,b) (e)->xclient.data.l[1] = ((e)->xclient.data.l[1] & ~0x2UL) | (((b) == 0) ? 0 : 0x2UL)
#define XDND_STATUS_RECT_X(e)           ((e)->xclient.data.l[2] >> 16)
#define XDND_STATUS_RECT_Y(e)           ((e)->xclient.data.l[2] & 0xFFFFL)
#define XDND_STATUS_RECT_WIDTH(e)       ((e)->xclient.data.l[3] >> 16)
#define XDND_STATUS_RECT_HEIGHT(e)      ((e)->xclient.data.l[3] & 0xFFFFL)
#define XDND_STATUS_RECT_SET(e,x,y,w,h) {(e)->xclient.data.l[2] = ((x) << 16) | ((y) & 0xFFFFUL); (e)->xclient.data.l[3] = ((w) << 16) | ((h) & 0xFFFFUL); }
#define XDND_STATUS_ACTION(e)           ((e)->xclient.data.l[4])

/* XdndLeave */
#define XDND_LEAVE_SOURCE_WIN(e)        ((e)->xclient.data.l[0])

/* XdndDrop */
#define XDND_DROP_SOURCE_WIN(e)         ((e)->xclient.data.l[0])
#define XDND_DROP_TIME(e)               ((e)->xclient.data.l[2])

/* XdndFinished */
#define XDND_FINISHED_TARGET_WIN(e)     ((e)->xclient.data.l[0])
/*
#define XDND_FINISHED_ACCEPTED(e)       ((e)->xclient.data.l[1] & 0x1L)
#define XDND_FINISHED_ACCEPTED_SET(e,b)  (e)->xclient.data.l[1] = ((e)->xclient.data.l[1] & ~0x1UL) | (((b) == 0) ? 0 : 0x1UL)
*/
#define XDND_FINISHED_ACCEPTED(e)       ((e)->xclient.data.l[1] &   (1 << 1))
#define XDND_FINISHED_ACCEPTED_NO(e)    ((e)->xclient.data.l[1] &= ~(1 << 1))
#define XDND_FINISHED_ACCEPTED_YES(e)   ((e)->xclient.data.l[1] |=  (1 << 1))
#define XDND_FINISHED_ACTION(e)         ((e)->xclient.data.l[2])

#ifndef CONST86
#define CONST86
#endif

extern int TkDND_GetSelection(Tcl_Interp *interp, Tk_Window tkwin,
                              Atom selection,
                              Atom target, Time time,
                              Tk_GetSelProc *proc, ClientData clientData);
extern void TkDND_InitialiseCursors(Tcl_Interp *interp);
extern Tk_Cursor TkDND_GetCursor(Tcl_Interp *interp, Tcl_Obj *name);

/*
 * Support for getting the wrapper window for our top-level...
 */

int TkDND_RegisterTypesObjCmd(ClientData clientData, Tcl_Interp *interp,
                              int objc, Tcl_Obj *CONST objv[]) {

  Atom version       = XDND_VERSION;
  Tk_Window path     = NULL;
  Tk_Window toplevel = NULL;

  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 1, objv, "path toplevel types-list");
    return TCL_ERROR;
  }

  path     = TkDND_TkWin(objv[1]);
  if (!path) return TCL_ERROR;
  Tk_MakeWindowExist(path);

#if defined(TKDND_SET_XDND_PROPERTY_ON_WRAPPER) || \
    defined(TKDND_SET_XDND_PROPERTY_ON_TOPLEVEL)
  toplevel = TkDND_TkWin(objv[2]);
  if (!Tk_IsTopLevel(toplevel)) {
    Tcl_ResetResult(interp);
    Tcl_AppendResult(interp, "path \"", Tcl_GetString(objv[2]),
                             "\" is not a toplevel window!", (char *) NULL);
    return TCL_ERROR;
  }
  Tk_MakeWindowExist(toplevel);
  Tk_MapWindow(toplevel);
#endif

  /*
   * We must make the toplevel that holds this widget XDND aware. This means
   * that we have to set the XdndAware property on our toplevel.
   */
#ifdef TKDND_SET_XDND_PROPERTY_ON_TARGET
  XChangeProperty(Tk_Display(path), Tk_WindowId(path),
                  Tk_InternAtom(path, "XdndAware"),
                  XA_ATOM, 32, PropModeReplace,
                  (unsigned char *) &version, 1);
#endif /* TKDND_SET_XDND_PROPERTY_ON_TARGET */

#ifdef TKDND_SET_XDND_PROPERTY_ON_WRAPPER
  if (Tk_HasWrapper(toplevel)) {
  }
#endif /* TKDND_SET_XDND_PROPERTY_ON_WRAPPER */

#ifdef TKDND_SET_XDND_PROPERTY_ON_TOPLEVEL
  Window root_return, parent, *children_return = 0;
  unsigned int nchildren_return;
  XQueryTree(Tk_Display(toplevel), Tk_WindowId(toplevel),
             &root_return, &parent,
             &children_return, &nchildren_return);
  if (children_return) XFree(children_return);
  XChangeProperty(Tk_Display(toplevel), parent,
                  Tk_InternAtom(toplevel, "XdndAware"),
                  XA_ATOM, 32, PropModeReplace,
                  (unsigned char *) &version, 1);
#endif /* TKDND_SET_XDND_PROPERTY_ON_TOPLEVEL */
  return TCL_OK;
} /* TkDND_RegisterTypesObjCmd */

Tk_Window TkDND_GetToplevelFromWrapper(Tk_Window tkwin) {
  Window root_return, parent, *children_return = 0;
  unsigned int nchildren_return;
  Tk_Window toplevel = NULL;
  if (tkwin == NULL || Tk_IsTopLevel(tkwin)) return tkwin;
  XQueryTree(Tk_Display(tkwin), Tk_WindowId(tkwin),
           &root_return, &parent,
           &children_return, &nchildren_return);
  if (nchildren_return == 1) {
    toplevel = Tk_IdToWindow(Tk_Display(tkwin), children_return[0]);
  }
  if (children_return) XFree(children_return);
  return toplevel;
}; /* TkDND_GetToplevelFromWrapper */

Window TkDND_GetVirtualRootWindowOfScreen(Tk_Window tkwin) {
  static Screen *screen, *save_screen = (Screen *)0;
  static Window root = (Window)0;
  
  screen = Tk_Screen(tkwin);
  if (screen != save_screen) {
    Display *dpy = DisplayOfScreen(screen);
    int i;
    Window rootReturn, parentReturn, *children;
    unsigned int numChildren;
    Atom __SWM_VROOT = Tk_InternAtom(tkwin, "__SWM_VROOT"),
         __SWM_ROOT  = Tk_InternAtom(tkwin, "__SWM_ROOT"),
         __WM_ROOT   = Tk_InternAtom(tkwin, "__WM_ROOT");
    
    root = RootWindowOfScreen(screen);
    
    /* go look for a virtual root */
    if (XQueryTree(dpy, root, &rootReturn, &parentReturn,
                   &children, &numChildren)) {
      for (i = 0; i < numChildren; i++) {
        Atom actual_type;
        int actual_format;
        unsigned long nitems, bytesafter;
        Window *newRoot = (Window *)0;
    
        if (
             (XGetWindowProperty(dpy, children[i],
                __WM_ROOT, 0, (long) 1, False, XA_WINDOW,
                &actual_type, &actual_format, &nitems, &bytesafter,
                (unsigned char **) &newRoot) == Success
                && newRoot && (actual_type == XA_WINDOW)) ||
             (XGetWindowProperty(dpy, children[i],
                __SWM_ROOT, 0, (long) 1, False, XA_WINDOW,
                &actual_type, &actual_format, &nitems, &bytesafter,
                (unsigned char **) &newRoot) == Success
                && newRoot && (actual_type == XA_WINDOW)) ||
             (XGetWindowProperty(dpy, children[i],
                __SWM_VROOT, 0, (long) 1, False, XA_WINDOW,
                &actual_type, &actual_format, &nitems, &bytesafter,
                (unsigned char **) &newRoot) == Success
                && newRoot && (actual_type == XA_WINDOW))
           ) {
          root = *newRoot;
          break;
        }
      }
      if (children) XFree((char *)children);
    }
    save_screen = screen;
  }
  return root;
}; /* TkDND_GetVirtualRootWindowOfScreen */

int TkDND_HandleXdndEnter(Tk_Window tkwin, XEvent *xevent) {
  Tcl_Interp *interp = Tk_Interp(tkwin);
  Tk_Window toplevel;
  Atom *typelist = NULL;
  int i, version = (int) XDND_ENTER_VERSION(xevent);
  Window drag_source;
  // Window drop_toplevel, drop_window;
  Tcl_Obj* objv[4], *element;

  if (interp == NULL) return False;
  if (version > XDND_VERSION) return False;
#if XDND_VERSION >= 3
  if (version < 3) return False;
#endif

//#if XDND_VERSION >= 3
//  /* XdndEnter is delivered to the toplevel window, which is the wrapper
//   *  window for the Tk toplevel. We don't yet know the sub-window the mouse
//   *  is in... */
//  drop_toplevel = xevent->xany.window;
//  drop_window   = 0;
//#else
//  drop_toplevel = 0
//  drop_window   = xevent->xany.window;
//#endif
  drag_source = XDND_ENTER_SOURCE_WIN(xevent);
  toplevel    = TkDND_GetToplevelFromWrapper(tkwin);
  if (toplevel == NULL) toplevel = tkwin;

  if (XDND_ENTER_THREE_TYPES(xevent)) {
    typelist = (Atom *) Tcl_Alloc(sizeof(Atom)*4);
    if (typelist == NULL) return False;
    typelist[0] = xevent->xclient.data.l[2];
    typelist[1] = xevent->xclient.data.l[3];
    typelist[2] = xevent->xclient.data.l[4];
    typelist[3] = None;
  } else {
    /* Get the types from XdndTypeList property. */
    Atom actualType = None;
    int actualFormat;
    unsigned long itemCount, remainingBytes;
    Atom *data;
    XGetWindowProperty(xevent->xclient.display, drag_source,
                       Tk_InternAtom(tkwin, "XdndTypeList"), 0,
                       LONG_MAX, False, XA_ATOM, &actualType, &actualFormat,
                       &itemCount, &remainingBytes, (unsigned char **) &data);
    typelist = (Atom *) Tcl_Alloc(sizeof(Atom)*(itemCount+1));
    if (typelist == NULL) return False;
    for (i=0; i<itemCount; i++) { typelist[i] = data[i]; }
    typelist[itemCount] = None;
    if (data) XFree((unsigned char*)data);
  }
  /* We have all the information we need. Its time to pass it at the Tcl
   * level.*/
  objv[0] = Tcl_NewStringObj("tkdnd::xdnd::_HandleXdndEnter", -1);
  objv[1] = Tcl_NewStringObj(Tk_PathName(toplevel), -1);
  objv[2] = Tcl_NewLongObj(drag_source);
  objv[3] = Tcl_NewListObj(0, NULL);
  for (i=0; typelist[i] != None; ++i) {
    element = Tcl_NewStringObj(Tk_GetAtomName(tkwin, typelist[i]), -1);
    Tcl_ListObjAppendElement(NULL, objv[3], element);
  }
  TkDND_Eval(4);
  Tcl_Free((char *) typelist);
  return True;
} /* TkDND_HandleXdndEnter */

int TkDND_HandleXdndPosition(Tk_Window tkwin, XEvent *xevent) {
  Tcl_Interp *interp = Tk_Interp(tkwin);
  Tk_Window mouse_tkwin = NULL, toplevel;
  Window drag_source, virtual_root, dummyChild;
  Tcl_Obj* result;
  Tcl_Obj* objv[5];
  int rootX, rootY, dx, dy, i, index, status, w, h;
  XEvent response;
  int width = 1, height = 1;
  static char *DropActions[] = {
    "copy", "move", "link", "ask",  "private", "refuse_drop", "default",
    (char *) NULL
  };
  enum dropactions {
    ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate,
    refuse_drop, ActionDefault
  };
/*Time time;
  Atom action;*/

  if (interp == NULL || tkwin == NULL) return False;

  drag_source = XDND_POSITION_SOURCE_WIN(xevent);
  /* Get the coordinates from the event... */
  rootX  = XDND_POSITION_ROOT_X(xevent);
  rootY  = XDND_POSITION_ROOT_Y(xevent);
  /* Get the time from the event... */
  /* time   = XDND_POSITION_TIME(xevent); */
  /* Get the user action from the event... */
  /* action = XDND_POSITION_ACTION(xevent); */

  /* The event may have been delivered to the toplevel wrapper.
   * Try to find the toplevel window... */
  toplevel = TkDND_GetToplevelFromWrapper(tkwin);
  if (toplevel == NULL) toplevel = tkwin;
  /* Get the virtual root window... */
  virtual_root = TkDND_GetVirtualRootWindowOfScreen(tkwin);
  if (virtual_root != None) {
    //XTranslateCoordinates(Tk_Display(tkwin), DefaultRootWindow(Tk_Display(tkwin)),
    //                      virtual_root, rootX, rootY, &dx, &dy, &dummyChild);
    XTranslateCoordinates(Tk_Display(tkwin), virtual_root,
                          Tk_WindowId(toplevel), rootX, rootY, &dx, &dy, &dummyChild);
    mouse_tkwin = Tk_IdToWindow(Tk_Display(tkwin), dummyChild);
  }
  if (!mouse_tkwin) {
    Tk_GetVRootGeometry(toplevel, &dx, &dy, &w, &h);
    mouse_tkwin = Tk_CoordsToWindow(rootX, rootY, toplevel);
  }
  if (!mouse_tkwin) mouse_tkwin = Tk_CoordsToWindow(rootX + dx, rootY + dy, tkwin);
#if 0
  printf("mouse_win: %p (%s) (%d, %d %p %s) i=%p\n", mouse_tkwin,
          mouse_tkwin?Tk_PathName(mouse_tkwin):"",
          rootX, rootY, tkwin, Tk_PathName(tkwin), interp);
#endif
  /* Ask the Tk widget whether it will accept the drop... */
  index = refuse_drop;
  if (mouse_tkwin != NULL) {
    objv[0] = Tcl_NewStringObj("tkdnd::xdnd::_HandleXdndPosition", -1);
    objv[1] = Tcl_NewStringObj(Tk_PathName(mouse_tkwin), -1);
    objv[2] = Tcl_NewIntObj(rootX);
    objv[3] = Tcl_NewIntObj(rootY);
    objv[4] = Tcl_NewLongObj(drag_source);
    TkDND_Status_Eval(5);
    if (status == TCL_OK) {
      /* Get the returned action... */
      result = Tcl_GetObjResult(interp); Tcl_IncrRefCount(result);
      status = Tcl_GetIndexFromObj(interp, result, (const char **) DropActions,
                              "dropactions", 0, &index);
      Tcl_DecrRefCount(result);
      if (status != TCL_OK) index = refuse_drop;
    }
  }
  /* Sent a XdndStatus event, to notify the drag source */
  memset (&response, 0, sizeof(xevent));
  response.xany.type            = ClientMessage;
  response.xany.display         = xevent->xclient.display;
  response.xclient.window       = drag_source;
  response.xclient.message_type = Tk_InternAtom(tkwin, "XdndStatus");
  response.xclient.format       = 32;
  XDND_STATUS_WILL_ACCEPT_SET(&response, 1);
  XDND_STATUS_WANT_POSITION_SET(&response, 1);
  XDND_STATUS_RECT_SET(&response, rootX, rootY, width, height);
#if XDND_VERSION >= 3
  XDND_STATUS_TARGET_WIN(&response) = Tk_WindowId(tkwin);
#else
  XDND_STATUS_TARGET_WIN(&response) = xevent->xany.window;
#endif
  switch ((enum dropactions) index) {
    case ActionDefault:
    case ActionCopy:
      XDND_STATUS_ACTION(&response) = Tk_InternAtom(tkwin, "XdndActionCopy");
      break;
    case ActionMove:
      XDND_STATUS_ACTION(&response) = Tk_InternAtom(tkwin, "XdndActionMove");
      break;
    case ActionLink:
      XDND_STATUS_ACTION(&response) = Tk_InternAtom(tkwin, "XdndActionLink");
      break;
    case ActionAsk:
      XDND_STATUS_ACTION(&response) = Tk_InternAtom(tkwin, "XdndActionAsk");
      break;
    case ActionPrivate: 
      XDND_STATUS_ACTION(&response) = Tk_InternAtom(tkwin, "XdndActionPrivate");
      break;
    case refuse_drop: {
      XDND_STATUS_WILL_ACCEPT_SET(&response, 0); /* Refuse drop. */
    }
  }
  XSendEvent(response.xany.display, response.xclient.window,
             False, NoEventMask, (XEvent*)&response);
  return True;
} /* TkDND_HandleXdndPosition */

int TkDND_HandleXdndLeave(Tk_Window tkwin, XEvent *xevent) {
  Tcl_Interp *interp = Tk_Interp(tkwin);
  Tcl_Obj* objv[1];
  int i;
  if (interp == NULL) return False; 
  objv[0] = Tcl_NewStringObj("tkdnd::xdnd::_HandleXdndLeave", -1);
  TkDND_Eval(1);
  return True;
} /* TkDND_HandleXdndLeave */

int TkDND_HandleXdndDrop(Tk_Window tkwin, XEvent *xevent) {
  XEvent finished;
  Tcl_Interp *interp = Tk_Interp(tkwin);
  Tcl_Obj* objv[2], *result;
  int status, i, index;
  Time time = CurrentTime;
  static char *DropActions[] = {
    "copy", "move", "link", "ask",  "private", "refuse_drop", "default",
    (char *) NULL
  };
  enum dropactions {
    ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate,
    refuse_drop, ActionDefault
  };
    
  if (interp == NULL) return False;
  if (XDND_DROP_TIME(xevent) != 0) {
    time = ((sizeof(Time) == 8 && XDND_DROP_TIME(xevent) < 0)
             ? (unsigned int) (XDND_DROP_TIME(xevent))
             :  XDND_DROP_TIME(xevent));
  }

  memset(&finished, 0, sizeof(XEvent));
  finished.xclient.type         = ClientMessage;
  finished.xclient.window       = XDND_DROP_SOURCE_WIN(xevent);
  finished.xclient.message_type = Tk_InternAtom(tkwin, "XdndFinished");
  finished.xclient.format       = 32;
#if XDND_VERSION >= 3
  XDND_FINISHED_TARGET_WIN(&finished) = Tk_WindowId(tkwin);
#else
  XDND_FINISHED_TARGET_WIN(&finished) = xevent->xany.window;
#endif
  XDND_FINISHED_ACCEPTED_YES(&finished);
  //XFlush(Tk_Display(tkwin));

  /* Call out Tcl callback. */
  objv[0] = Tcl_NewStringObj("tkdnd::xdnd::_HandleXdndDrop", -1);
  objv[1] = Tcl_NewLongObj(time);
  TkDND_Status_Eval(2);
  if (status == TCL_OK) {
    /* Get the returned action... */
    result = Tcl_GetObjResult(interp); Tcl_IncrRefCount(result);
    status = Tcl_GetIndexFromObj(interp, result, (const char **) DropActions,
                            "dropactions", 0, &index);
    Tcl_DecrRefCount(result);
    if (status != TCL_OK) index = refuse_drop;
    switch ((enum dropactions) index) {
      case ActionDefault:
      case ActionCopy:
        XDND_FINISHED_ACTION(&finished) =
            Tk_InternAtom(tkwin, "XdndActionCopy");    break;
      case ActionMove:
        XDND_FINISHED_ACTION(&finished) =
            Tk_InternAtom(tkwin, "XdndActionMove");    break;
      case ActionLink:
        XDND_FINISHED_ACTION(&finished) =
            Tk_InternAtom(tkwin, "XdndActionLink");    break;
      case ActionAsk:
        XDND_FINISHED_ACTION(&finished) =
            Tk_InternAtom(tkwin, "XdndActionAsk");     break;
      case ActionPrivate: 
        XDND_FINISHED_ACTION(&finished) =
            Tk_InternAtom(tkwin, "XdndActionPrivate"); break;
      case refuse_drop: {
        XDND_FINISHED_ACCEPTED_NO(&finished); /* Drop canceled. */
        XDND_FINISHED_ACTION(&finished) = None;
      }
    }
  } else {
    XDND_FINISHED_ACCEPTED_NO(&finished);
    XDND_FINISHED_ACTION(&finished) = None;
  }
  /* Send XdndFinished. */
  XSendEvent(Tk_Display(tkwin), finished.xclient.window,
             False, NoEventMask, (XEvent*)&finished);
  return True;
} /* TkDND_HandleXdndDrop */

int TkDND_HandleXdndStatus(Tk_Window tkwin, XEvent *xevent) {
  Tcl_Interp *interp = Tk_Interp(tkwin);
  Tcl_Obj *objv[2], *key, *value;
  int i;
  Atom action;
  if (interp == NULL) return False; 
  objv[0] = Tcl_NewStringObj("tkdnd::xdnd::_HandleXdndStatus", -1);
  objv[1] = Tcl_NewDictObj();
  /* data.l[0] contains the XID of the target window */
  TkDND_Dict_PutLong(objv[1], "target", xevent->xclient.data.l[0]);
  /* data.l[1] bit 0 is set if the current target will accept the drop */
  TkDND_Dict_PutInt(objv[1], "accept", XDND_STATUS_WILL_ACCEPT(xevent) ? 1:0);
  /* data.l[1] bit 1 is set if the target wants XdndPosition messages while
   * the mouse moves inside the rectangle in data.l[2,3] */
  TkDND_Dict_PutInt(objv[1], "want_position",
    XDND_STATUS_WANT_POSITION(xevent) ? 1 : 0);
  /* data.l[4] contains the action accepted by the target */
  action = XDND_STATUS_ACTION(xevent);
  if (action == Tk_InternAtom(tkwin, "XdndActionCopy")) {
    TkDND_Dict_Put(objv[1], "action", "copy");
  } else if (action == Tk_InternAtom(tkwin, "XdndActionMove")) {
    TkDND_Dict_Put(objv[1], "action", "move");
  } else if (action == Tk_InternAtom(tkwin, "XdndActionLink")) {
    TkDND_Dict_Put(objv[1], "action", "link");
  } else if (action == Tk_InternAtom(tkwin, "XdndActionAsk")) {
    TkDND_Dict_Put(objv[1], "action", "ask");
  } else if (action == Tk_InternAtom(tkwin, "XdndActionPrivate")) {
    TkDND_Dict_Put(objv[1], "action", "private");
  } else {
    TkDND_Dict_Put(objv[1], "action", "refuse_drop");
  }
  TkDND_Dict_PutInt(objv[1], "x", XDND_STATUS_RECT_X(xevent));
  TkDND_Dict_PutInt(objv[1], "y", XDND_STATUS_RECT_Y(xevent));
  TkDND_Dict_PutInt(objv[1], "w", XDND_STATUS_RECT_WIDTH(xevent));
  TkDND_Dict_PutInt(objv[1], "h", XDND_STATUS_RECT_HEIGHT(xevent));
  
  TkDND_Eval(2);
  return True;
} /* TkDND_HandleXdndStatus */

int TkDND_HandleXdndFinished(Tk_Window tkwin, XEvent *xevent) {
   Tcl_Interp *interp = Tk_Interp(tkwin);
  Tcl_Obj *objv[2], *key, *value;
  int i;
  Atom action;
  if (interp == NULL) return False; 
  objv[0] = Tcl_NewStringObj("tkdnd::xdnd::_HandleXdndFinished", -1);
  objv[1] = Tcl_NewDictObj();
  /* data.l[0] contains the XID of the target window */
  TkDND_Dict_PutLong(objv[1], "target", xevent->xclient.data.l[0]);
  /* data.l[1] bit 0 is set if the current target accepted the drop and
   *  successfully performed the accepted drop action */
  TkDND_Dict_PutInt(objv[1], "accept", (xevent->xclient.data.l[1] & 0x1L)?1:0);
  /* data.l[2] contains the action performed by the target */
  action = xevent->xclient.data.l[2];
  if (action == Tk_InternAtom(tkwin, "XdndActionCopy")) {
    TkDND_Dict_Put(objv[1], "action", "copy");
  } else if (action == Tk_InternAtom(tkwin, "XdndActionMove")) {
    TkDND_Dict_Put(objv[1], "action", "move");
  } else if (action == Tk_InternAtom(tkwin, "XdndActionLink")) {
    TkDND_Dict_Put(objv[1], "action", "link");
  } else if (action == Tk_InternAtom(tkwin, "XdndActionAsk")) {
    TkDND_Dict_Put(objv[1], "action", "ask");
  } else if (action == Tk_InternAtom(tkwin, "XdndActionPrivate")) {
    TkDND_Dict_Put(objv[1], "action", "private");
  } else {
    TkDND_Dict_Put(objv[1], "action", "refuse_drop");
  }
  TkDND_Eval(2);
  return True;
} /* TkDND_HandleXdndFinished */

static int TkDND_XDNDHandler(Tk_Window tkwin, XEvent *xevent) {
  if (xevent->type != ClientMessage) return False;

  if (xevent->xclient.message_type == Tk_InternAtom(tkwin, "XdndPosition")) {
#ifdef DEBUG_CLIENTMESSAGE_HANDLER
    printf("XDND_HandleClientMessage: Received XdndPosition\n");
#endif /* DEBUG_CLIENTMESSAGE_HANDLER */
    return TkDND_HandleXdndPosition(tkwin, xevent);
  } else if (xevent->xclient.message_type== Tk_InternAtom(tkwin, "XdndEnter")) {
#ifdef DEBUG_CLIENTMESSAGE_HANDLER
    printf("XDND_HandleClientMessage: Received XdndEnter\n");
#endif /* DEBUG_CLIENTMESSAGE_HANDLER */
    return TkDND_HandleXdndEnter(tkwin, xevent);
  } else if (xevent->xclient.message_type==Tk_InternAtom(tkwin, "XdndStatus")) {
#ifdef DEBUG_CLIENTMESSAGE_HANDLER
    printf("XDND_HandleClientMessage: Received XdndStatus\n");
#endif /* DEBUG_CLIENTMESSAGE_HANDLER */
    return TkDND_HandleXdndStatus(tkwin, xevent);
  } else if (xevent->xclient.message_type== Tk_InternAtom(tkwin, "XdndLeave")) {
#ifdef DEBUG_CLIENTMESSAGE_HANDLER
    printf("XDND_HandleClientMessage: Received XdndLeave\n");
#endif /* DEBUG_CLIENTMESSAGE_HANDLER */
    return TkDND_HandleXdndLeave(tkwin, xevent);
  } else if (xevent->xclient.message_type == Tk_InternAtom(tkwin, "XdndDrop")) {
#ifdef DEBUG_CLIENTMESSAGE_HANDLER
    printf("XDND_HandleClientMessage: Received XdndDrop\n");
#endif /* DEBUG_CLIENTMESSAGE_HANDLER */
    return TkDND_HandleXdndDrop(tkwin, xevent);
  } else if (xevent->xclient.message_type == 
                                         Tk_InternAtom(tkwin, "XdndFinished")) {
#ifdef DEBUG_CLIENTMESSAGE_HANDLER
    printf("XDND_HandleClientMessage: Received XdndFinished\n");
#endif /* DEBUG_CLIENTMESSAGE_HANDLER */
    return TkDND_HandleXdndFinished(tkwin, xevent);
  } else {
#ifdef TKDND_ENABLE_MOTIF_DROPS
    if (MotifDND_HandleClientMessage(dnd, xevent)) return True;
#endif /* TKDND_ENABLE_MOTIF_DROPS */
  }
  return False;
} /* TkDND_XDNDHandler */

/*
 * The following two functions were copied from tkSelect.c
 * If TIP 370 gets implemented, they will not be required.
 */
static int TkDND_SelGetProc(ClientData clientData,
                            Tcl_Interp *interp, CONST86 char *portion) {
  Tcl_DStringAppend(clientData, portion, -1);
  return TCL_OK;
}; /* TkDND_SelGetProc */

int TkDND_GetSelectionObjCmd(ClientData clientData, Tcl_Interp *interp,
                             int objc, Tcl_Obj *CONST objv[]) {
  Tk_Window tkwin = Tk_MainWindow(interp);
  Atom target;
  Atom selection;
  Time time = CurrentTime;
  const char *targetName = NULL;
  Tcl_DString selBytes;
  int result;
  static const char *const getOptionStrings[] = {
      "-displayof", "-selection", "-time", "-type", NULL
  };
  enum getOptions { GET_DISPLAYOF, GET_SELECTION, GET_TIME, GET_TYPE };
  int getIndex;
  int count;
  Tcl_Obj **objs;
  const char *string;
  const char *path = NULL;
  const char *selName = NULL;

  for (count = objc-1, objs = ((Tcl_Obj **)objv)+1; count>0;
                count-=2, objs+=2) {
    string = Tcl_GetString(objs[0]);
    if (string[0] != '-') {
        break;
    }
    if (count < 2) {
        Tcl_AppendResult(interp, "value for \"", string,
                                 "\" missing", NULL);
        return TCL_ERROR;
    }
    
    if (Tcl_GetIndexFromObj(interp, objs[0], (const char **) getOptionStrings,
            "option", 0, &getIndex) != TCL_OK) {
        return TCL_ERROR;
    }
    
    switch ((enum getOptions) getIndex) {
    case GET_DISPLAYOF:
        path = Tcl_GetString(objs[1]);
        break;
    case GET_SELECTION:
        selName = Tcl_GetString(objs[1]);
        break;
    case GET_TYPE:
        targetName = Tcl_GetString(objs[1]);
        break;
    case GET_TIME:
        if (Tcl_GetLongFromObj(interp, objs[1], (long *) &time) != TCL_OK) {
          return TCL_ERROR;
        }
        break;
    }
  }
  if (path != NULL) {
      tkwin = Tk_NameToWindow(interp, path, tkwin);
  }
  if (tkwin == NULL) {
      return TCL_ERROR;
  }
  if (selName != NULL) {
      selection = Tk_InternAtom(tkwin, selName);
  } else {
      selection = XA_PRIMARY;
  }
  if (count > 1) {
      Tcl_WrongNumArgs(interp, 1, objv, "?-option value ...?");
      return TCL_ERROR;
  } else if (count == 1) {
      target = Tk_InternAtom(tkwin, Tcl_GetString(objs[0]));
  } else if (targetName != NULL) {
      target = Tk_InternAtom(tkwin, targetName);
  } else {
      target = XA_STRING;
  }
  Tcl_DStringInit(&selBytes);
  result = TkDND_GetSelection(interp, tkwin, selection, target, time,
                              TkDND_SelGetProc, &selBytes);
  if (result == TCL_OK) {
      Tcl_DStringResult(interp, &selBytes);
  }
  Tcl_DStringFree(&selBytes);
  return result;
} /* TkDND_GetSelectionObjCmd */

int TkDND_AnnounceTypeListObjCmd(ClientData clientData, Tcl_Interp *interp,
                            int objc, Tcl_Obj *CONST objv[]) {
  Tk_Window path;
  Tcl_Obj **type;
  int status, i, types;
  Atom *typelist;

  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, "path types-list");
    return TCL_ERROR;
  }
  path     = TkDND_TkWin(objv[1]);
  if (!path) return TCL_ERROR;
  status = Tcl_ListObjGetElements(interp, objv[2], &types, &type);
  if (status != TCL_OK) return status;
  typelist = (Atom *) Tcl_Alloc(types * sizeof(Atom));
  if (typelist == NULL) return TCL_ERROR;
  for (i = 0; i < types; ++i) {
    typelist[i] = Tk_InternAtom(path, Tcl_GetString(type[i]));
  }
  XChangeProperty(Tk_Display(path), Tk_WindowId(path),
                  Tk_InternAtom(path, "XdndTypeList"),
                  XA_ATOM, 32, PropModeReplace,
                  (unsigned char*) typelist, types);
  Tcl_Free((char *) typelist);
  return TCL_OK;
}; /* TkDND_AnnounceTypeListObjCmd */

int TkDND_AnnounceActionListObjCmd(ClientData clientData, Tcl_Interp *interp,
                            int objc, Tcl_Obj *CONST objv[]) {
  Tk_Window path;
  Tcl_Obj **action, **description;
  int status, i, actions, descriptions;
  Atom actionlist[10], descriptionlist[10];

  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 1, objv, "path actions-list descriptions-list");
    return TCL_ERROR;
  }
  path     = TkDND_TkWin(objv[1]);
  if (!path) return TCL_ERROR;
  status = Tcl_ListObjGetElements(interp, objv[2], &actions, &action);
  if (status != TCL_OK) return status;
  status = Tcl_ListObjGetElements(interp, objv[3], &descriptions, &description);
  if (status != TCL_OK) return status;

  if (actions != descriptions) {
    Tcl_SetResult(interp, "number of actions != number of descriptions",
                                                              TCL_STATIC);
    return TCL_ERROR;
  }
  if (actions > 10) {
    Tcl_SetResult(interp, "too many actions/descriptions", TCL_STATIC);
    return TCL_ERROR;
  }

  for (i = 0; i < actions; ++i) {
    actionlist[i]      = Tk_InternAtom(path, Tcl_GetString(action[i]));
    descriptionlist[i] = Tk_InternAtom(path, Tcl_GetString(description[i]));
  }
  XChangeProperty(Tk_Display(path), Tk_WindowId(path),
                  Tk_InternAtom(path, "XdndActionList"),
                  XA_ATOM, 32, PropModeReplace,
                  (unsigned char*) actionlist, actions);
  XChangeProperty(Tk_Display(path), Tk_WindowId(path),
                  Tk_InternAtom(path, "XdndActionDescription"),
                  XA_ATOM, 32, PropModeReplace,
                  (unsigned char*) descriptionlist, descriptions);
  return TCL_OK;
}; /* TkDND_AnnounceActionListObjCmd */

int TkDND_GrabPointerObjCmd(ClientData clientData, Tcl_Interp *interp,
                            int objc, Tcl_Obj *CONST objv[]) {
  Tk_Window path;
  Tk_Cursor cursor;

  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, "path cursor");
    return TCL_ERROR;
  }

  path     = TkDND_TkWin(objv[1]);
  if (!path) return TCL_ERROR;
  Tk_MakeWindowExist(path);

  cursor = TkDND_GetCursor(interp, objv[2]);
  if (cursor == None) {
    Tcl_SetResult(interp, "invalid cursor name: ", TCL_STATIC);
    Tcl_AppendResult(interp, Tcl_GetString(objv[2]));
    return TCL_ERROR;
  }

  if (XGrabPointer(Tk_Display(path), Tk_WindowId(path), False,
       ButtonPressMask   | ButtonReleaseMask |
       PointerMotionMask | EnterWindowMask   | LeaveWindowMask,
       GrabModeAsync, GrabModeAsync,
       None, (Cursor) cursor, CurrentTime) != GrabSuccess) {
    Tcl_SetResult(interp, "unable to grab mouse pointer", TCL_STATIC);
    return TCL_ERROR;
  }
  return TCL_OK;
}; /* TkDND_GrabPointerObjCmd */

int TkDND_UnrabPointerObjCmd(ClientData clientData, Tcl_Interp *interp,
                            int objc, Tcl_Obj *CONST objv[]) {
  Tk_Window path;
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, "path");
    return TCL_ERROR;
  }
  path     = TkDND_TkWin(objv[1]);
  if (!path) return TCL_ERROR;
  XUngrabPointer(Tk_Display(path), CurrentTime);
  return TCL_OK;
}; /* TkDND_GrabPointerObjCmd */

int TkDND_SetPointerCursorObjCmd(ClientData clientData, Tcl_Interp *interp,
                            int objc, Tcl_Obj *CONST objv[]) {
  Tk_Window path;
  Tk_Cursor cursor;

  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, "path cursor");
    return TCL_ERROR;
  }

  path     = TkDND_TkWin(objv[1]);
  if (!path) return TCL_ERROR;
  Tk_MakeWindowExist(path);

  cursor = TkDND_GetCursor(interp, objv[2]);
  if (cursor == None) {
    Tcl_SetResult(interp, "invalid cursor name: ", TCL_STATIC);
    Tcl_AppendResult(interp, Tcl_GetString(objv[2]));
    return TCL_ERROR;
  }

  if (XChangeActivePointerGrab(Tk_Display(path),
       ButtonPressMask   | ButtonReleaseMask |
       PointerMotionMask | EnterWindowMask   | LeaveWindowMask,
       (Cursor) cursor, CurrentTime) != GrabSuccess) {
    /* Tcl_SetResult(interp, "unable to update mouse pointer", TCL_STATIC);
       return TCL_ERROR; */
  }
  return TCL_OK;
}; /* TkDND_SetPointerCursorObjCmd */

void TkDND_AddStateInformation(Tcl_Interp *interp, Tcl_Obj *dict,
                               unsigned int state) {
  Tcl_Obj *key, *value;
  TkDND_Dict_PutInt(dict, "state",   state);
  /* Masks... */
  TkDND_Dict_PutInt(dict, "1",       state & Button1Mask ? 1 : 0);
  TkDND_Dict_PutInt(dict, "2",       state & Button2Mask ? 1 : 0);
  TkDND_Dict_PutInt(dict, "3",       state & Button3Mask ? 1 : 0);
  TkDND_Dict_PutInt(dict, "4",       state & Button4Mask ? 1 : 0);
  TkDND_Dict_PutInt(dict, "5",       state & Button5Mask ? 1 : 0);
  TkDND_Dict_PutInt(dict, "Mod1",    state & Mod1Mask    ? 1 : 0);
  TkDND_Dict_PutInt(dict, "Mod2",    state & Mod2Mask    ? 1 : 0);
  TkDND_Dict_PutInt(dict, "Mod3",    state & Mod3Mask    ? 1 : 0);
  TkDND_Dict_PutInt(dict, "Mod4",    state & Mod4Mask    ? 1 : 0);
  TkDND_Dict_PutInt(dict, "Mod5",    state & Mod5Mask    ? 1 : 0);
  TkDND_Dict_PutInt(dict, "Alt",     state & Mod1Mask    ? 1 : 0);
  TkDND_Dict_PutInt(dict, "Shift",   state & ShiftMask   ? 1 : 0);
  TkDND_Dict_PutInt(dict, "Lock",    state & LockMask    ? 1 : 0);
  TkDND_Dict_PutInt(dict, "Control", state & ControlMask ? 1 : 0);
}; /* TkDND_AddStateInformation */

int TkDND_HandleGenericEvent(ClientData clientData, XEvent *eventPtr) {
  Tcl_Interp *interp = (Tcl_Interp *) clientData;
  Tcl_Obj *dict, *key, *value;
  Tcl_Obj *objv[2], *result;
  int status, i;
  KeySym sym;
  Tk_Window main_window;

  if (interp == NULL) return 0;
  dict = Tcl_NewDictObj();

  switch (eventPtr->type) {
    case MotionNotify:
      TkDND_Dict_Put(dict,     "type",   "MotionNotify");
      TkDND_Dict_PutInt(dict,  "x",       eventPtr->xmotion.x);
      TkDND_Dict_PutInt(dict,  "y",       eventPtr->xmotion.y);
      TkDND_Dict_PutInt(dict,  "x_root",  eventPtr->xmotion.x_root);
      TkDND_Dict_PutInt(dict,  "y_root",  eventPtr->xmotion.y_root);
      TkDND_Dict_PutLong(dict, "time",    eventPtr->xmotion.time);
      TkDND_AddStateInformation(interp,   dict,     eventPtr->xmotion.state);
      break;
    case ButtonPress:
      TkDND_Dict_Put(dict,     "type",   "ButtonPress");
      TkDND_Dict_PutInt(dict,  "x",       eventPtr->xbutton.x);
      TkDND_Dict_PutInt(dict,  "y",       eventPtr->xbutton.y);
      TkDND_Dict_PutInt(dict,  "x_root",  eventPtr->xbutton.x_root);
      TkDND_Dict_PutInt(dict,  "y_root",  eventPtr->xbutton.y_root);
      TkDND_Dict_PutLong(dict, "time",    eventPtr->xbutton.time);
      TkDND_AddStateInformation(interp,   dict,     eventPtr->xbutton.state);
      TkDND_Dict_PutInt(dict,  "button",  eventPtr->xbutton.button);
      break;
    case ButtonRelease:
      TkDND_Dict_Put(dict,     "type",   "ButtonRelease");
      TkDND_Dict_PutInt(dict,  "x",       eventPtr->xbutton.x);
      TkDND_Dict_PutInt(dict,  "y",       eventPtr->xbutton.y);
      TkDND_Dict_PutInt(dict,  "x_root",  eventPtr->xbutton.x_root);
      TkDND_Dict_PutInt(dict,  "y_root",  eventPtr->xbutton.y_root);
      TkDND_Dict_PutLong(dict, "time",    eventPtr->xbutton.time);
      TkDND_AddStateInformation(interp,   dict,     eventPtr->xbutton.state);
      TkDND_Dict_PutInt(dict,  "button",  eventPtr->xbutton.button);
      break;
    case KeyPress:
      TkDND_Dict_Put(dict,     "type",   "KeyPress");
      TkDND_Dict_PutInt(dict,  "x",       eventPtr->xkey.x);
      TkDND_Dict_PutInt(dict,  "y",       eventPtr->xkey.y);
      TkDND_Dict_PutInt(dict,  "x_root",  eventPtr->xkey.x_root);
      TkDND_Dict_PutInt(dict,  "y_root",  eventPtr->xkey.y_root);
      TkDND_Dict_PutLong(dict, "time",    eventPtr->xkey.time);
      TkDND_AddStateInformation(interp,   dict,     eventPtr->xkey.state);
      TkDND_Dict_PutInt(dict,  "keycode", eventPtr->xkey.keycode);
      main_window = Tk_MainWindow(interp);
      sym = XKeycodeToKeysym(Tk_Display(main_window),
                             eventPtr->xkey.keycode, 0);
      TkDND_Dict_Put(dict,     "keysym",   XKeysymToString(sym));
      break;
    case KeyRelease:
      TkDND_Dict_Put(dict,     "type",   "KeyRelease");
      TkDND_Dict_PutInt(dict,  "x",       eventPtr->xkey.x);
      TkDND_Dict_PutInt(dict,  "y",       eventPtr->xkey.y);
      TkDND_Dict_PutInt(dict,  "x_root",  eventPtr->xkey.x_root);
      TkDND_Dict_PutInt(dict,  "y_root",  eventPtr->xkey.y_root);
      TkDND_Dict_PutLong(dict, "time",    eventPtr->xkey.time);
      TkDND_AddStateInformation(interp,   dict,     eventPtr->xkey.state);
      TkDND_Dict_PutInt(dict,  "keycode", eventPtr->xkey.keycode);
      main_window = Tk_MainWindow(interp);
      sym = XKeycodeToKeysym(Tk_Display(main_window),
                             eventPtr->xkey.keycode, 0);
      TkDND_Dict_Put(dict,     "keysym",   XKeysymToString(sym));
      break;
    case EnterNotify:
      return 0;
      TkDND_Dict_Put(dict, "type", "EnterNotify");
      TkDND_Dict_PutLong(dict, "time",    eventPtr->xcrossing.time);
      break;
    case LeaveNotify:
      return 0;
      TkDND_Dict_Put(dict, "type", "LeaveNotify");
      TkDND_Dict_PutLong(dict, "time",    eventPtr->xcrossing.time);
      break;
    case SelectionRequest:
      main_window = Tk_MainWindow(interp);
      TkDND_Dict_Put(dict, "type", "SelectionRequest");
      TkDND_Dict_PutLong(dict, "time",     eventPtr->xselectionrequest.time);
      TkDND_Dict_PutLong(dict, "owner",    eventPtr->xselectionrequest.owner);
      TkDND_Dict_PutLong(dict, "requestor",
                                eventPtr->xselectionrequest.requestor);
      TkDND_Dict_Put(dict,     "selection",
            Tk_GetAtomName(main_window, eventPtr->xselectionrequest.selection));
      TkDND_Dict_Put(dict,     "target",
            Tk_GetAtomName(main_window, eventPtr->xselectionrequest.target));
      TkDND_Dict_Put(dict,     "property",
            Tk_GetAtomName(main_window, eventPtr->xselectionrequest.property));
      break;
    default:
      Tcl_DecrRefCount(dict);
      return 0;
  }
  /* Call out Tcl callback. */
  objv[0] = Tcl_NewStringObj("tkdnd::xdnd::_process_drag_events", -1);
  objv[1] = dict;
  TkDND_Status_Eval(2);
  if (status == TCL_OK) {
    result = Tcl_GetObjResult(interp); Tcl_IncrRefCount(result);
    status = Tcl_GetIntFromObj(interp, result, &i);
    Tcl_DecrRefCount(result);
    if (status == TCL_OK) return i;
  } else {
    /* An error occured, stop the drag action... */
    Tcl_SetVar(interp, "::tkdnd::xdnd::_dragging", "0", TCL_GLOBAL_ONLY);
  }
  return 0;
}; /* TkDND_HandleGenericEvent */

int TkDND_RegisterGenericEventHandlerObjCmd(ClientData clientData,
                         Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (objc != 1) {
    Tcl_WrongNumArgs(interp, 1, objv, "");
    return TCL_ERROR;
  }
  Tk_CreateGenericHandler(TkDND_HandleGenericEvent, interp);
  return TCL_OK;
}; /* TkDND_RegisterGenericEventHandlerObjCmd */

int TkDND_UnregisterGenericEventHandlerObjCmd(ClientData clientData,
                         Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (objc != 1) {
    Tcl_WrongNumArgs(interp, 1, objv, "");
    return TCL_ERROR;
  }
  Tk_DeleteGenericHandler(TkDND_HandleGenericEvent, interp);
  return TCL_OK;
}; /* TkDND_UnegisterGenericEventHandlerObjCmd */

int TkDND_FindDropTargetWindowObjCmd(ClientData clientData,
                         Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int rootx, rooty;
  Tk_Window path;
  Window root, src, t;
  Window target = 0;
  int lx = 0, ly = 0, lx2, ly2;
  Display *display;
  Atom XdndAware;
  Atom type = 0;
  int f;
  unsigned long n, a;
  unsigned char *data = 0;

  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 1, objv, "path rootx rooty");
    return TCL_ERROR;
  }
  path = TkDND_TkWin(objv[1]);
  if (!path) return TCL_ERROR;
  if (Tcl_GetIntFromObj(interp, objv[2], &rootx) != TCL_OK) return TCL_ERROR;
  if (Tcl_GetIntFromObj(interp, objv[3], &rooty) != TCL_OK) return TCL_ERROR;
  root = RootWindowOfScreen(Tk_Screen(path));
  display = Tk_Display(path);

  if (!XTranslateCoordinates(display, root, root, rootx, rooty,
                             &lx, &ly, &target)) return TCL_ERROR;
  if (target == root) return TCL_ERROR;
  src = root;
  XdndAware = Tk_InternAtom(path, "XdndAware");
  while (target != 0) {
    if (!XTranslateCoordinates(display, src, target, lx, ly, &lx2, &ly2, &t)) {
      target = 0; break; /* Error... */
    }
    lx = lx2; ly = ly2; src = target; type = 0; data = NULL;
    /* Check if we can find the XdndAware property... */
    XGetWindowProperty(display, target, XdndAware, 0, 0, False,
                       AnyPropertyType, &type, &f,&n,&a,&data);
    if (data) XFree(data);
    if (type) break; /* We have found a target! */
    /* Find child at the coordinates... */
    if (!XTranslateCoordinates(display, src, src, lx, ly, &lx2, &ly2, &target)){
      target = 0; break; /* Error */
    }
  }
  if (target) {
    Tcl_SetObjResult(interp, Tcl_NewLongObj(target));
  } else {
    Tcl_ResetResult(interp);
  }

  return TCL_OK;
}; /* TkDND_FindDropTargetWindowObjCmd */

int TkDND_FindDropTargetProxyObjCmd(ClientData clientData,
                         Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Window target, proxy, *proxy_ptr;
  Atom type = None;
  int f;
  unsigned long n, a;
  unsigned char *retval = NULL;
  Display *display;
  Tk_Window path;

  if (objc != 3) {
    Tcl_WrongNumArgs(interp, 1, objv, "source target");
    return TCL_ERROR;
  }

  path = TkDND_TkWin(objv[1]);
  if (!path) return TCL_ERROR;
  if (Tcl_GetLongFromObj(interp, objv[2], (long *) &target) != TCL_OK) {
    return TCL_ERROR;
  }
  display = Tk_Display(path);
  proxy = target;
  XGetWindowProperty(display, target, Tk_InternAtom(path, "XdndProxy"), 0, 1,
                     False, XA_WINDOW, &type, &f,&n,&a,&retval);
  proxy_ptr = (Window *) retval;
  if (type == XA_WINDOW && proxy_ptr) {
    proxy = *proxy_ptr;
    XFree(proxy_ptr);
    proxy_ptr = NULL;
    /* Is the XdndProxy property pointing to the same window? */
    XGetWindowProperty(display, proxy, Tk_InternAtom(path, "XdndProxy"), 0, 1,
                       False, XA_WINDOW, &type, &f,&n,&a,&retval);
    proxy_ptr = (Window *) retval;
    if (type != XA_WINDOW || !proxy_ptr || *proxy_ptr != proxy) {
      proxy = target;
    }
  }
  if (proxy_ptr) XFree(proxy_ptr);
  Tcl_SetObjResult(interp, Tcl_NewLongObj(proxy));

  return TCL_OK;
}; /* TkDND_FindDropTargetProxyObjCmd */

int TkDND_SendXdndEnterObjCmd(ClientData clientData,
                         Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XEvent event;
  Tk_Window source;
  Window target, proxy;
  Display *display;
  int types, r, f, *tv, target_version = XDND_VERSION, flags, status, i;
  Atom t = None;
  unsigned long n, a;
  unsigned char *retval;
  Tcl_Obj **type;

  if (objc != 5) {
    Tcl_WrongNumArgs(interp, 1, objv, "source target proxy types_len");
    return TCL_ERROR;
  }
  
  source = TkDND_TkWin(objv[1]);
  if (!source) return TCL_ERROR;
  if (Tcl_GetLongFromObj(interp, objv[2], (long *) &target) != TCL_OK) {
    return TCL_ERROR;
  }
  if (Tcl_GetLongFromObj(interp, objv[3], (long *) &proxy) != TCL_OK) {
    return TCL_ERROR;
  }
  status = Tcl_ListObjGetElements(interp, objv[4], &types, &type);
  if (status != TCL_OK) return status;
  display = Tk_Display(source);

  /* Get the XDND version supported by the target... */
  r = XGetWindowProperty(display, proxy, Tk_InternAtom(source, "XdndAware"), 0, 1,
                         False, AnyPropertyType, &t, &f,&n,&a,&retval);
  if (r != Success) {
    Tcl_SetResult(interp, "cannot retrieve XDND version from target",
                  TCL_STATIC);
    return TCL_ERROR;
  }
  tv = (int *)retval;
  if (tv) {
    if (*tv < target_version) target_version = *tv;
    XFree(tv);
  } 

  memset (&event, 0, sizeof(event));
  event.type                    = ClientMessage;
  event.xclient.window          = target;
  event.xclient.format          = 32;
  event.xclient.message_type    = Tk_InternAtom(source, "XdndEnter");
  XDND_ENTER_SOURCE_WIN(&event) = Tk_WindowId(source);
  flags = target_version << 24;
  if (types > 3) flags |= 0x0001;
  event.xclient.data.l[1] = flags;
  for (i = 0; i < types && i < 3; ++i) {
    event.xclient.data.l[2+i] = Tk_InternAtom(source, Tcl_GetString(type[i]));
  }
  XSendEvent(display, proxy, False, NoEventMask, &event);

  return TCL_OK;
}; /* TkDND_SendXdndEnterObjCmd */

int TkDND_SendXdndPositionObjCmd(ClientData clientData,
                         Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  static char *DropActions[] = {
    "copy", "move", "link", "ask",  "private", "default",
    (char *) NULL
  };
  enum dropactions {
    ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate, ActionDefault
  };

  XEvent event;
  Tk_Window source;
  Window target, proxy;
  Display *display;
  int rootx, rooty, status, index;

  if (objc != 7) {
    Tcl_WrongNumArgs(interp, 1, objv, "source target proxy rootx rooty action");
    return TCL_ERROR;
  }
  
  source = TkDND_TkWin(objv[1]);
  if (!source) return TCL_ERROR;
  if (Tcl_GetLongFromObj(interp, objv[2], (long *) &target) != TCL_OK) {
    return TCL_ERROR;
  }
  if (Tcl_GetLongFromObj(interp, objv[3], (long *) &proxy) != TCL_OK) {
    return TCL_ERROR;
  }
  if (Tcl_GetIntFromObj(interp, objv[4], &rootx) != TCL_OK) return TCL_ERROR;
  if (Tcl_GetIntFromObj(interp, objv[5], &rooty) != TCL_OK) return TCL_ERROR;
  status = Tcl_GetIndexFromObj(interp, objv[6], (const char **) DropActions,
                            "dropactions", 0, &index);
  if (status != TCL_OK) return status;
  display = Tk_Display(source);

  memset (&event, 0, sizeof(event));
  event.type                       = ClientMessage;
  event.xclient.window             = target;
  event.xclient.format             = 32;
  event.xclient.message_type       = Tk_InternAtom(source, "XdndPosition");
  event.xclient.data.l[0]          = Tk_WindowId(source);
  event.xclient.data.l[1]          = 0; // flags
  event.xclient.data.l[2]          = (rootx << 16) + rooty;
  event.xclient.data.l[3]          = CurrentTime;
  switch ((enum dropactions) index) {
    case ActionDefault:
    case ActionCopy:
      XDND_POSITION_ACTION(&event) =
          Tk_InternAtom(source, "XdndActionCopy");    break;
    case ActionMove:
      XDND_POSITION_ACTION(&event) =
          Tk_InternAtom(source, "XdndActionMove");    break;
    case ActionLink:
      XDND_POSITION_ACTION(&event) =
          Tk_InternAtom(source, "XdndActionLink");    break;
    case ActionAsk:
      XDND_POSITION_ACTION(&event) =
          Tk_InternAtom(source, "XdndActionAsk");     break;
    case ActionPrivate: 
      XDND_POSITION_ACTION(&event) =
          Tk_InternAtom(source, "XdndActionPrivate"); break;
  }

  XSendEvent(display, proxy, False, NoEventMask, &event);

  return TCL_OK;
}; /* TkDND_SendXdndPositionObjCmd */

int TkDND_SendXdndLeaveObjCmd(ClientData clientData,
                         Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XEvent event;
  Tk_Window source;
  Window target, proxy;

  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 1, objv, "source target proxy");
    return TCL_ERROR;
  }

  source = TkDND_TkWin(objv[1]);
  if (!source) return TCL_ERROR;
  if (Tcl_GetLongFromObj(interp, objv[2], (long *) &target) != TCL_OK) {
    return TCL_ERROR;
  }
  if (Tcl_GetLongFromObj(interp, objv[3], (long *) &proxy) != TCL_OK) {
    return TCL_ERROR;
  }

  memset (&event, 0, sizeof(event));
  event.type                       = ClientMessage;
  event.xclient.window             = target;
  event.xclient.format             = 32;
  event.xclient.message_type       = Tk_InternAtom(source, "XdndLeave");
  event.xclient.data.l[0]          = Tk_WindowId(source);
  XSendEvent(Tk_Display(source), proxy, False, NoEventMask, &event);
  return TCL_OK;
}; /* TkDND_SendXdndLeaveObjCmd */

int TkDND_SendXdndDropObjCmd(ClientData clientData,
                         Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XEvent event;
  Tk_Window source;
  Window target, proxy;

  if (objc != 4) {
    Tcl_WrongNumArgs(interp, 1, objv, "source target proxy");
    return TCL_ERROR;
  }

  source = TkDND_TkWin(objv[1]);
  if (!source) return TCL_ERROR;
  if (Tcl_GetLongFromObj(interp, objv[2], (long *) &target) != TCL_OK) {
    return TCL_ERROR;
  }
  if (Tcl_GetLongFromObj(interp, objv[3], (long *) &proxy) != TCL_OK) {
    return TCL_ERROR;
  }

  memset (&event, 0, sizeof(event));
  event.type                       = ClientMessage;
  event.xclient.window             = target;
  event.xclient.format             = 32;
  event.xclient.message_type       = Tk_InternAtom(source, "XdndDrop");
  event.xclient.data.l[0]          = Tk_WindowId(source);
  event.xclient.data.l[2]          = CurrentTime;
  XSendEvent(Tk_Display(source), proxy, False, NoEventMask, &event);
  Tcl_SetObjResult(interp, Tcl_NewLongObj(event.xclient.data.l[2]));
  return TCL_OK;
}; /* TkDND_SendXdndDropObjCmd */

int TkDND_XChangePropertyObjCmd(ClientData clientData,
                         Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  XEvent event;
  Window target;
  Atom property = None, type = None;
  int format, numItems, numFields, i;
  Display *display;
  Tk_Window source;
  Time time;
  unsigned char *data = NULL;
  Tcl_Obj **field;

  if (objc != 9) {
    Tcl_WrongNumArgs(interp, 1, objv,
        "source requestor property type format time data data_items");
    return TCL_ERROR;
  }

  source = TkDND_TkWin(objv[1]);
  if (!source) return TCL_ERROR;
  if (Tcl_GetLongFromObj(interp, objv[2], (long *) &target) != TCL_OK) {
    return TCL_ERROR;
  }
  display  = Tk_Display(source);
  property = Tk_InternAtom(source, Tcl_GetString(objv[3]));
  type     = Tk_InternAtom(source, Tcl_GetString(objv[4]));
  if (Tcl_GetIntFromObj(interp, objv[5], &format) != TCL_OK) {
    return TCL_ERROR;
  }
  if (format != 8 && format != 16 && format != 32) {
    Tcl_SetResult(interp, "unsupported format: not 8, 16 or 32", TCL_STATIC);
    return TCL_ERROR;
  }
  if (Tcl_GetIntFromObj(interp, objv[5], &format) != TCL_OK) {
    return TCL_ERROR;
  }
  if (Tcl_GetLongFromObj(interp, objv[6], (long *) &time) != TCL_OK) {
    return TCL_ERROR;
  }
  if (Tcl_GetIntFromObj(interp, objv[8], &numItems) != TCL_OK) {
    return TCL_ERROR;
  }
  if (!time) time = CurrentTime;
  switch (format) {
    case 8:
      data = (unsigned char *) Tcl_GetString(objv[7]);
      break;
    case 16: {
      short *propPtr = (short *) Tcl_Alloc(sizeof(short)*numItems);
      data = (unsigned char *) propPtr;
      if (Tcl_ListObjGetElements(interp, objv[7], &numFields, &field)
                                                                   != TCL_OK) {
        return TCL_ERROR;
      }
      for (i = 0; i < numItems; i++) {
	char *dummy;
	propPtr[i] = (short) strtol(Tcl_GetString(field[i]), &dummy, 0);
      }
      break;
    }
    case 32: {
      long *propPtr  = (long *) Tcl_Alloc(sizeof(long)*numItems);
      data = (unsigned char *) propPtr;
      if (Tcl_ListObjGetElements(interp, objv[7], &numFields, &field)
                                                                   != TCL_OK) {
        return TCL_ERROR;
      }
      for (i = 0; i < numItems; i++) {
	char *dummy;
	propPtr[i] = (short) strtol(Tcl_GetString(field[i]), &dummy, 0);
      }
      break;
    }
  }
  XChangeProperty(display, target, property, type, format, PropModeReplace,
         (unsigned char *) data, numItems);
  if (format > 8 && data) Tcl_Free((char *) data);
  /* Send selection notify to requestor... */
  event.xselection.type      = SelectionNotify;
  event.xselection.display   = display;
  event.xselection.requestor = target;
  event.xselection.selection = Tk_InternAtom(source, "XdndSelection");
  event.xselection.target    = type;
  event.xselection.property  = property;
  event.xselection.time      = time;
  XSendEvent(display, target, False, NoEventMask, &event);
  return TCL_OK;
}; /* TkDND_XChangePropertyObjCmd */

/*
 * For C++ compilers, use extern "C"
 */
#ifdef __cplusplus
extern "C" {
#endif
DLLEXPORT int Tkdnd_Init(Tcl_Interp *interp);
DLLEXPORT int Tkdnd_SafeInit(Tcl_Interp *interp);
#ifdef __cplusplus
}
#endif

int DLLEXPORT Tkdnd_Init(Tcl_Interp *interp) {
  int major, minor, patchlevel;
  Tcl_CmdInfo info;

  if (
#ifdef USE_TCL_STUBS 
      Tcl_InitStubs(interp, "8.3", 0)
#else
      Tcl_PkgRequire(interp, "Tcl", "8.3", 0)
#endif /* USE_TCL_STUBS */
            == NULL) {
            return TCL_ERROR;
  }
  if (
#ifdef USE_TK_STUBS
       Tk_InitStubs(interp, "8.3", 0)
#else
       Tcl_PkgRequire(interp, "Tk", "8.3", 0)
#endif /* USE_TK_STUBS */
            == NULL) {
            return TCL_ERROR;
  }

  /*
   * Get the version, because we really need 8.3.3+.
   */
  Tcl_GetVersion(&major, &minor, &patchlevel, NULL);
  if ((major == 8) && (minor == 3) && (patchlevel < 3)) {
    Tcl_SetResult(interp, "tkdnd requires Tk 8.3.3 or greater", TCL_STATIC);
    return TCL_ERROR;
  }

  if (Tcl_GetCommandInfo(interp, "selection", &info) == 0) {
    Tcl_SetResult(interp, "selection Tk command not found", TCL_STATIC);
    return TCL_ERROR;
  }

  /* Register the various commands */
  if (Tcl_CreateObjCommand(interp, "_register_types",
           (Tcl_ObjCmdProc*) TkDND_RegisterTypesObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_selection_get",
           (Tcl_ObjCmdProc*) TkDND_GetSelectionObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_grab_pointer",
           (Tcl_ObjCmdProc*) TkDND_GrabPointerObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_ungrab_pointer",
           (Tcl_ObjCmdProc*) TkDND_UnrabPointerObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_set_pointer_cursor",
           (Tcl_ObjCmdProc*) TkDND_SetPointerCursorObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_register_generic_event_handler",
           (Tcl_ObjCmdProc*) TkDND_RegisterGenericEventHandlerObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_unregister_generic_event_handler",
           (Tcl_ObjCmdProc*) TkDND_UnregisterGenericEventHandlerObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }
  
  if (Tcl_CreateObjCommand(interp, "_announce_type_list",
           (Tcl_ObjCmdProc*) TkDND_AnnounceTypeListObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_announce_action_list",
           (Tcl_ObjCmdProc*) TkDND_AnnounceActionListObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_find_drop_target_window",
           (Tcl_ObjCmdProc*) TkDND_FindDropTargetWindowObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_find_drop_target_proxy",
           (Tcl_ObjCmdProc*) TkDND_FindDropTargetProxyObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_send_XdndEnter",
           (Tcl_ObjCmdProc*) TkDND_SendXdndEnterObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_send_XdndPosition",
           (Tcl_ObjCmdProc*) TkDND_SendXdndPositionObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_send_XdndLeave",
           (Tcl_ObjCmdProc*) TkDND_SendXdndLeaveObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_send_XdndDrop",
           (Tcl_ObjCmdProc*) TkDND_SendXdndDropObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "XChangeProperty",
           (Tcl_ObjCmdProc*) TkDND_XChangePropertyObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
    return TCL_ERROR;
  }

  /* Create the cursors... */
  TkDND_InitialiseCursors(interp);

  /* Finally, register the XDND Handler... */
  Tk_CreateClientMessageHandler(&TkDND_XDNDHandler);

  Tcl_PkgProvide(interp, PACKAGE_NAME, PACKAGE_VERSION);
  return TCL_OK;
} /* Tkdnd_Init */

int DLLEXPORT Tkdnd_SafeInit(Tcl_Interp *interp) {
  return Tkdnd_Init(interp);
} /* Tkdnd_SafeInit */
blob
data 13837
/*
 * tkUnixSelect.c --
 *
 *	This file contains X specific routines for manipulating selections.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution of
 * this file, and for a DISCLAIMER OF ALL WARRANTIES.
 */

#include "tk.h"
#include "X11/Xutil.h"

/*
 * Forward declarations for functions defined in this file:
 */
typedef struct {
  Tcl_Interp     *interp;
  Tk_GetSelProc  *proc;
  ClientData      clientData;
  Tcl_TimerToken  timeout;
  Tk_Window       tkwin;
  Atom            property;
  int             result;
  int             idleTime;
} TkDND_ProcDetail;

void TkDND_SelectionNotifyEventProc(ClientData clientData, XEvent *eventPtr);
void TkDND_PropertyNotifyEventProc(ClientData clientData, XEvent *eventPtr);
static void TkDND_SelTimeoutProc(ClientData clientData);

static inline int maxSelectionIncr(Display *dpy) {
  return XMaxRequestSize(dpy) > 65536 ? 65536*4 :
                               XMaxRequestSize(dpy)*4 - 100;
}; /* maxSelectionIncr */

int TkDND_ClipboardReadProperty(Tk_Window tkwin,
                                Atom property, int deleteProperty,
                                TkDND_ProcDetail *detail,
                                int *size, Atom *type, int *format) {
    Display *display = Tk_Display(tkwin);
    Window   win     = Tk_WindowId(tkwin);
    int      maxsize = maxSelectionIncr(display);
    unsigned long    bytes_left; // bytes_after
    unsigned long    length;     // nitems
    unsigned char   *data;
    Atom     dummy_type;
    int      dummy_format;
    int      r;
    Tcl_DString *buffer = (Tcl_DString *) detail->clientData;

    if (!type)                                // allow null args
        type = &dummy_type;
    if (!format)
        format = &dummy_format;

    // Don't read anything, just get the size of the property data
    r = XGetWindowProperty(display, win, property, 0, 0, False,
                            AnyPropertyType, type, format,
                            &length, &bytes_left, &data);
    if (r != Success || (type && *type == None)) {
        return 0;
    }
    XFree((char*)data);

    int offset = 0, format_inc = 1, proplen = bytes_left;

    switch (*format) {
    case 8:
    default:
        format_inc = sizeof(char) / 1;
        break;

    case 16:
        format_inc = sizeof(short) / 2;
        proplen   *= sizeof(short) / 2;
        break;

    case 32:
        format_inc = sizeof(long) / 4;
        proplen   *= sizeof(long) / 4;
        break;
    }

    while (bytes_left) {
      r = XGetWindowProperty(display, win, property, offset, maxsize/4,
                             False, AnyPropertyType, type, format,
                             &length, &bytes_left, &data);
      if (r != Success || (type && *type == None))
          break;
      switch (*format) {
        case 8:
        default:
          offset += length / (32 / *format);
          length *= format_inc * (*format) / 8;
          Tcl_DStringAppend(buffer, (char *) data, length);
          break;
        case 16: {
          register unsigned short *propPtr = (unsigned short *) data;
          for (; length > 0; propPtr++, length--) {
            char buf[12];

	    sprintf(buf, "0x%04x", (unsigned short) *propPtr);
	    Tcl_DStringAppendElement(buffer, buf);
          }
          Tcl_DStringAppend(buffer, " ", 1);
          break;
        }
        case 32: {
          register unsigned long *propPtr = (unsigned long *) data;
          for (; length > 0; propPtr++, length--) {
            char buf[12];

	    sprintf(buf, "0x%x", (unsigned int) *propPtr);
	    Tcl_DStringAppendElement(buffer, buf);
          }
          Tcl_DStringAppend(buffer, " ", 1);
          break;
        }
      }

      XFree((char*)data);
    }
#if 0
    printf("Selection details:\n");
    printf("  type: %s\n", XGetAtomName(display, *type));
    printf("  format: %d %s\n", *format, XGetAtomName(display, *format));
    printf("  length: %d\n", Tcl_DStringLength(buffer));
    printf("  data: \"%s\"\n", Tcl_DStringValue(buffer));
#endif

    if (*format == 8 && *type == Tk_InternAtom(tkwin, "COMPOUND_TEXT")) {
      // convert COMPOUND_TEXT to a multibyte string
      XTextProperty textprop;
      textprop.encoding = *type;
      textprop.format = *format;
      textprop.nitems = Tcl_DStringLength(buffer);
      textprop.value = (unsigned char *) Tcl_DStringValue(buffer);

      char **list_ret = 0;
      int count;
      if (XmbTextPropertyToTextList(display, &textprop, &list_ret,
                   &count) == Success && count && list_ret) {
        Tcl_DStringFree(buffer);
        Tcl_DStringInit(buffer);
        Tcl_DStringAppend(buffer, list_ret[0], -1);
      }
      if (list_ret) XFreeStringList(list_ret);
    }

    // correct size, not 0-term.
    if (size) *size = Tcl_DStringLength(buffer);
    if (deleteProperty) XDeleteProperty(display, win, property);
    //XFlush(display);
    return 1;
}; /* TkDND_ClipboardReadProperty */

int TkDND_ClipboardReadIncrementalProperty(Tk_Window tkwin,
                                           Atom property,
                                           TkDND_ProcDetail *detail) {
  TkDND_ProcDetail detail2;
  Tcl_DString     *buffer  = (Tcl_DString *) detail->clientData;
  detail2.interp           = detail->interp;
  detail2.tkwin            = detail->tkwin;
  detail2.property         = detail->property;
  detail2.proc             = NULL;
  detail2.clientData       = buffer;
  detail2.result           = -1;
  detail2.idleTime         = 0;
  Tcl_DStringFree(buffer);
  Tcl_DStringInit(buffer);

  //XFlush(display);
  /* Install a handler for PropertyNotify events... */
  Tk_CreateEventHandler(tkwin, PropertyNotify,
                        TkDND_PropertyNotifyEventProc, &detail2);
  /*
   * Enter a loop processing X events until the selection has been retrieved
   * and processed. If no response is received within a few seconds, then
   * timeout.
   */
  detail2.timeout = Tcl_CreateTimerHandler(1000, TkDND_SelTimeoutProc,
                                           &detail2);
  while (detail2.result == -1) {
    //XFlush(display);
    Tcl_DoOneEvent(0);
  }
  Tk_DeleteEventHandler(tkwin, PropertyNotify,
                        TkDND_PropertyNotifyEventProc, &detail2);
  if (detail2.timeout) Tcl_DeleteTimerHandler(detail2.timeout);
  return detail2.result;
}; /* TkDND_ClipboardReadIncrementalProperty */

void TkDND_SelectionNotifyEventProc(ClientData clientData, XEvent *eventPtr) {
  TkDND_ProcDetail *detail = (TkDND_ProcDetail *) clientData;
  int status, size, format;
  Atom type;

  status = TkDND_ClipboardReadProperty(detail->tkwin, detail->property, 1,
                                       detail, &size, &type, &format);
  if (status) {
#ifdef TKDND_DebugSelectionRequests
    if (eventPtr != NULL) {
    printf("SelectionNotify: selection: %s, target: %s, property: %s,\
            type: %s, format: %d\n",
            Tk_GetAtomName(detail->tkwin, eventPtr->xselection.selection),
            Tk_GetAtomName(detail->tkwin, eventPtr->xselection.target),
            Tk_GetAtomName(detail->tkwin, eventPtr->xselection.property),
            Tk_GetAtomName(detail->tkwin, type), format);
    }
#endif /* TKDND_DebugSelectionRequests */
    if (type == Tk_InternAtom(detail->tkwin, "INCR")) {
      status = TkDND_ClipboardReadIncrementalProperty(detail->tkwin,
                                       detail->property, detail);
    }
  }
  if (status) detail->result = TCL_OK;
  else {
    /* Do not report the error if this has not be called by a
     *  SelectionNotify event... */
    if (eventPtr != NULL) detail->result = TCL_ERROR;
  }
}; /* TkDND_SelectionNotifyEventProc */

void TkDND_PropertyNotifyEventProc(ClientData clientData, XEvent *eventPtr) {
  TkDND_ProcDetail *detail = (TkDND_ProcDetail *) clientData;
  Tcl_DString      *buffer = (Tcl_DString *) detail->clientData;
  Tcl_DString       ds;
  int status, size, format;
  Atom type;
  if (eventPtr->xproperty.atom != detail->property ||
      eventPtr->xproperty.state != PropertyNewValue) return;
  /* We will call TkDND_ClipboardReadProperty to read the property. Ensure that
   * a temporary DString will be used... */ 
  Tcl_DStringInit(&ds);
  detail->clientData = &ds;
  status = TkDND_ClipboardReadProperty(detail->tkwin, detail->property, 1,
                                       detail, &size, &type, &format);
  detail->clientData = buffer;
  if (status) {
    if (size == 0) {
      /* We are done! */
      detail->result = status;
    } else {
      Tcl_DStringAppend(buffer, Tcl_DStringValue(&ds), Tcl_DStringLength(&ds));
    }
  } else {
    /* An error occured... */
    detail->result = status;
  }
  Tcl_DStringFree(&ds);
}; /* TkDND_PropertyNotifyEventProc */

/*
 *----------------------------------------------------------------------
 *
 * TkDNDSelGetSelection --
 *
 *	Retrieve the specified selection from another process.
 *
 * Results:
 *	The return value is a standard Tcl return value. If an error occurs
 *	(such as no selection exists) then an error message is left in the
 *	interp's result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TkDNDSelGetSelection(
    Tcl_Interp *interp,		/* Interpreter to use for reporting errors. */
    Tk_Window tkwin,		/* Window on whose behalf to retrieve the
				 * selection (determines display from which to
				 * retrieve). */
    Atom selection,		/* Selection to retrieve. */
    Atom target,		/* Desired form in which selection is to be
				 * returned. */
    Time time,
    Tk_GetSelProc *proc,	/* Function to call to process the selection,
				 * once it has been retrieved. */
    ClientData clientData)	/* Arbitrary value to pass to proc. */
{
    TkDND_ProcDetail detail;
    Tk_Window sel_tkwin = Tk_MainWindow(interp);
    Display *display    = Tk_Display(tkwin);
    detail.interp       = interp;
    detail.tkwin        = sel_tkwin;
    detail.property     = selection;
    detail.proc         = proc;
    detail.clientData   = clientData;
    detail.result       = -1;
    detail.idleTime     = 0;

    XFlush(display);
    if (XGetSelectionOwner(display, selection) == None) {
      Tcl_SetResult(interp, "no owner for selection", TCL_STATIC);
      return TCL_ERROR;
    }
    /*
     * Initiate the request for the selection. Note: can't use TkCurrentTime
     * for the time. If we do, and this application hasn't received any X
     * events in a long time, the current time will be way in the past and
     * could even predate the time when the selection was made; if this
     * happens, the request will be rejected.
     */
    Tcl_ThreadAlert(Tcl_GetCurrentThread());
    /* Register an event handler for tkwin... */
    Tk_CreateEventHandler(sel_tkwin, SelectionNotify,
                          TkDND_SelectionNotifyEventProc, &detail);
    XConvertSelection(display, selection, target,
	              selection, Tk_WindowId(sel_tkwin), time);
    XFlush(display);
    /*
     * Enter a loop processing X events until the selection has been retrieved
     * and processed. If no response is received within a few seconds, then
     * timeout.
     */
    detail.timeout = Tcl_CreateTimerHandler(70, TkDND_SelTimeoutProc,
	                                    &detail);
    while (detail.result == -1) {
      TkDND_SelectionNotifyEventProc(&detail, NULL);
      Tcl_DoOneEvent(0);
    }
    Tk_DeleteEventHandler(sel_tkwin, SelectionNotify,
                          TkDND_SelectionNotifyEventProc, &detail);
    if (detail.timeout) Tcl_DeleteTimerHandler(detail.timeout);

    return detail.result;
}

/*
 *----------------------------------------------------------------------
 *
 * TkDND_SelTimeoutProc --
 *
 *	This function is invoked once every second while waiting for the
 *	selection to be returned. After a while it gives up and aborts the
 *	selection retrieval.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	A new timer callback is created to call us again in another second,
 *	unless time has expired, in which case an error is recorded for the
 *	retrieval.
 *
 *----------------------------------------------------------------------
 */

static void
TkDND_SelTimeoutProc(
    ClientData clientData)	/* Information about retrieval in progress. */
{
    register TkDND_ProcDetail *retrPtr = (TkDND_ProcDetail *) clientData;

    /*
     * Make sure that the retrieval is still in progress. Then see how long
     * it's been since any sort of response was received from the other side.
     */

    TkDND_SelectionNotifyEventProc(retrPtr, NULL);
    if (retrPtr->result != -1) {
	return;
    }
    XFlush(Tk_Display(retrPtr->tkwin));
    if (retrPtr->idleTime > 3){
      Tcl_ThreadAlert(Tcl_GetCurrentThread());
      XFlush(Tk_Display(retrPtr->tkwin));
    }
    retrPtr->idleTime++;
    if (retrPtr->idleTime >= 6) {
	/*
	 * Use a careful function to store the error message, because the
	 * result could already be partially filled in with a partial
	 * selection return.
	 */

	Tcl_SetResult(retrPtr->interp, "selection owner didn't respond",
		TCL_STATIC);
	retrPtr->result = TCL_ERROR;
        retrPtr->timeout = NULL;

    } else {
	retrPtr->timeout = Tcl_CreateTimerHandler(1000, TkDND_SelTimeoutProc,
		(ClientData) retrPtr);
    }
}

int TkDND_GetSelection(Tcl_Interp *interp, Tk_Window tkwin, Atom selection,
                       Atom target, Time time,
                       Tk_GetSelProc *proc, ClientData clientData) {
  /*
   * The selection is owned by some other process.
   */
  return TkDNDSelGetSelection(interp, tkwin, selection, target, time,
                              proc, clientData);
}

/*
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
blob
data 47940
/*
 * OleDND.h --
 * 
 *    This file implements the windows portion of the drag&drop mechanism
 *    for the Tk toolkit. The protocol in use under windows is the
 *    OLE protocol. Based on code wrote by Gordon Chafee.
 *
 * This software is copyrighted by:
 * George Petasis, National Centre for Scientific Research "Demokritos",
 * Aghia Paraskevi, Athens, Greece.
 * e-mail: petasis@iit.demokritos.gr
 * Laurent Riesterer, Rennes, France.
 * e-mail: laurent.riesterer@free.fr
 *
 * The following terms apply to all files associated
 * with the software unless explicitly disclaimed in individual files.
 *
 * The authors hereby grant permission to use, copy, modify, distribute,
 * and license this software and its documentation for any purpose, provided
 * that existing copyright notices are retained in all copies and that this
 * notice is included verbatim in any distributions. No written agreement,
 * license, or royalty fee is required for any of the authorized uses.
 * Modifications to this software may be copyrighted by their authors
 * and need not follow the licensing terms described here, provided that
 * the new terms are clearly indicated on the first page of each file where
 * they apply.
 * 
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 * ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
 * DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
 * IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
 * NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 */

#ifndef _OLE_DND_H
#define _OLE_DND_H

#if defined(__MINGW32__) || defined(__MINGW64__)
#ifndef WINVER
#define WINVER 0x0500 /* version 5.0 */
#endif /* !WINVER */
#endif /* __MINGW32__ */

#include <windows.h>
#include <ole2.h>
#include <shlobj.h>
#include <io.h>
#include <fcntl.h>
#include <share.h>
#include <sys/stat.h>
#include <tchar.h>
#include <wchar.h>

#ifdef DND_ENABLE_DROP_TARGET_HELPER
#include <atlbase.h>
#include <shlobj.h>     /* for IDropTargetHelper */
#include <shlguid.h>
/* We need this declaration for CComPtr, which uses __uuidof() */
struct __declspec(uuid("{4657278B-411B-11d2-839A-00C04FD918D0}"))
  IDropTargetHelper;
#endif /* DND_ENABLE_DROP_TARGET_HELPER */
 
#include <tcl.h>
#include <tk.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <tkPlatDecls.h>
#ifdef __cplusplus
}
#endif

#define TkDND_TkWin(x) \
  (Tk_NameToWindow(interp, Tcl_GetString(x), Tk_MainWindow(interp)))

#define TkDND_Eval(objc) {\
  for (i=0; i<objc; ++i) Tcl_IncrRefCount(objv[i]);\
  if (Tcl_EvalObjv(interp, objc, objv, TCL_EVAL_GLOBAL) != TCL_OK) \
      Tk_BackgroundError(interp); \
  for (i=0; i<objc; ++i) Tcl_DecrRefCount(objv[i]);}

#define TkDND_Status_Eval(objc) {\
  for (i=0; i<objc; ++i) Tcl_IncrRefCount(objv[i]);\
  status = Tcl_EvalObjv(interp, objc, objv, TCL_EVAL_GLOBAL);\
  if (status != TCL_OK) Tk_BackgroundError(interp); \
  for (i=0; i<objc; ++i) Tcl_DecrRefCount(objv[i]);}

#if defined(UNICODE) || defined(_MBCS)
#  ifdef _MBCS
#    define TCL_GETSTRING(x)    ((LPCSTR) Tcl_GetUnicode(x))
#    define TCL_NEWSTRING(x, y) Tcl_NewStringObj(x, y)
#  else
#    define TCL_GETSTRING(x)    ((LPCWSTR) Tcl_GetUnicode(x))
#    define TCL_NEWSTRING(x, y) Tcl_NewUnicodeObj((Tcl_UniChar *) x, y)
#  endif
#else
#  define TCL_GETSTRING(x)    Tcl_GetString(x)
#  define TCL_NEWSTRING(x, y) Tcl_NewStringObj(x, y)
#endif


/*****************************************************************************
 * Windows Clipboard formats.
 ****************************************************************************/
#define STRING_(s) {s,TEXT(#s)}
typedef struct {
  UINT   cfFormat;
  const TCHAR *name;
} CLIP_FORMAT_STRING_TABLE;

static CLIP_FORMAT_STRING_TABLE ClipboardFormatBook[] = {
  STRING_(CF_TEXT),
  STRING_(CF_BITMAP),
  STRING_(CF_METAFILEPICT),
  STRING_(CF_SYLK),
  STRING_(CF_DIF),
  STRING_(CF_TIFF),
  STRING_(CF_OEMTEXT),
  STRING_(CF_DIB),
  STRING_(CF_PALETTE),
  STRING_(CF_PENDATA),
  STRING_(CF_RIFF),
  STRING_(CF_WAVE),
  STRING_(CF_UNICODETEXT),
  STRING_(CF_ENHMETAFILE),
#ifdef    CF_HDROP
  STRING_(CF_HDROP),
#endif /* CF_HDROP */
#ifdef    CF_LOCALE
  STRING_(CF_LOCALE),
#endif /* CF_LOCALE */
#ifdef    CF_DIBV5
  STRING_(CF_DIBV5),
#endif /* CF_DIBV5 */
  STRING_(CF_OWNERDISPLAY),
  STRING_(CF_DSPTEXT),
  STRING_(CF_DSPBITMAP),
  STRING_(CF_DSPMETAFILEPICT),
  STRING_(CF_DSPENHMETAFILE),
  STRING_(CF_GDIOBJFIRST),
  STRING_(CF_PRIVATEFIRST),
  {0, 0}
}; /* ClipboardFormatBook */

/*****************************************************************************
 * Data Object Class.
 ****************************************************************************/

// Helper function to perform a "deep" copy of a FORMATETC
static void DeepCopyFormatEtc(FORMATETC *dest, FORMATETC *source) {
  // copy the source FORMATETC into dest
  *dest = *source;
  if(source->ptd) {
    // allocate memory for the DVTARGETDEVICE if necessary
    dest->ptd = (DVTARGETDEVICE*)CoTaskMemAlloc(sizeof(DVTARGETDEVICE));
    // copy the contents of the source DVTARGETDEVICE into dest->ptd
    *(dest->ptd) = *(source->ptd);
  }
}; /* DeepCopyFormatEtc */

HRESULT CreateEnumFormatEtc(UINT nNumFormats, FORMATETC *pFormatEtc,
                            IEnumFORMATETC **ppEnumFormatEtc);

class TkDND_FormatEtc : public IEnumFORMATETC {
public:

    // IUnknown members
    HRESULT __stdcall QueryInterface(REFIID iid, void ** ppvObject) {
      // check to see what interface has been requested
      if (iid == IID_IEnumFORMATETC || iid == IID_IUnknown) {
        AddRef();
        *ppvObject = this;
        return S_OK;
      } else {
        *ppvObject = 0;
        return E_NOINTERFACE;
      }
    }; /* QueryInterface */
    
    ULONG __stdcall AddRef(void) {
      // increment object reference count
      return InterlockedIncrement(&m_lRefCount);
    }; /* AddRef */
    
    ULONG __stdcall Release (void) {
      // decrement object reference count
      LONG count = InterlockedDecrement(&m_lRefCount);
      if (count == 0) {
        delete this;
        return 0;
      } else {
        return count;
      }
    }; /* Release */
    
    // IEnumFormatEtc members
    HRESULT __stdcall Next(ULONG celt, FORMATETC *pFormatEtc,
                           ULONG *pceltFetched) {
      ULONG copied  = 0;
      // validate arguments
      if(celt == 0 || pFormatEtc == 0) return E_INVALIDARG;
      // copy FORMATETC structures into caller's buffer
      while (m_nIndex < m_nNumFormats && copied < celt) {
        DeepCopyFormatEtc(&pFormatEtc[copied], &m_pFormatEtc[m_nIndex]);
        copied++; m_nIndex++;
      }
      // store result
      if (pceltFetched != 0) *pceltFetched = copied;
      // did we copy all that was requested?
      return (copied == celt) ? S_OK : S_FALSE;
    }; /* Next */
    
    HRESULT __stdcall Skip(ULONG celt) {
      m_nIndex += celt;
      return (m_nIndex <= m_nNumFormats) ? S_OK : S_FALSE;
    }; /* Skip */
    
    HRESULT __stdcall Reset(void) {
      m_nIndex = 0;
      return S_OK;
    }; /* Reset */

    HRESULT __stdcall Clone(IEnumFORMATETC ** ppEnumFormatEtc) {
      HRESULT hResult;
      // make a duplicate enumerator
      hResult = CreateEnumFormatEtc(m_nNumFormats, m_pFormatEtc,
                                    ppEnumFormatEtc);
      if (hResult == S_OK) {
        // manually set the index state
        ((TkDND_FormatEtc *) *ppEnumFormatEtc)->m_nIndex = m_nIndex;
      }
      return hResult;
    }; /* Clone */
    
    // Construction / Destruction
    TkDND_FormatEtc(FORMATETC *pFormatEtc, int nNumFormats) {
      m_lRefCount   = 1;
      m_nIndex      = 0;
      m_nNumFormats = nNumFormats;
      m_pFormatEtc  = new FORMATETC[nNumFormats];
      
      // copy the FORMATETC structures
      for (int i = 0; i < nNumFormats; i++) {        
        DeepCopyFormatEtc(&m_pFormatEtc[i], &pFormatEtc[i]);
      }
    }; /* TkDND_FormatEtc */

    ~TkDND_FormatEtc() {
       if (m_pFormatEtc) {
         for(ULONG i = 0; i < m_nNumFormats; i++) {
           if(m_pFormatEtc[i].ptd) CoTaskMemFree(m_pFormatEtc[i].ptd);
         }
         delete[] m_pFormatEtc;
       }
    }; /* ~TkDND_FormatEtc */

private:
    LONG  m_lRefCount;        // Reference count for this COM interface
    ULONG m_nIndex;           // current enumerator index
    ULONG m_nNumFormats;      // number of FORMATETC members
    FORMATETC * m_pFormatEtc; // array of FORMATETC objects
}; /* TkDND_FormatEtc */

// "Drop-in" replacement for SHCreateStdEnumFmtEtc.
HRESULT CreateEnumFormatEtc(UINT nNumFormats, FORMATETC *pFormatEtc,
                            IEnumFORMATETC **ppEnumFormatEtc) {
  if(nNumFormats==0 || pFormatEtc==0 || ppEnumFormatEtc==0) return E_INVALIDARG;
  *ppEnumFormatEtc = new TkDND_FormatEtc(pFormatEtc, nNumFormats);
  return (*ppEnumFormatEtc) ? S_OK : E_OUTOFMEMORY;
}; /* CreateEnumFormatEtc */


class TkDND_DataObject : public IDataObject {
public:

    // IUnknown members
    HRESULT __stdcall QueryInterface(REFIID iid, void ** ppvObject) {
      // check to see what interface has been requested
      if (iid == IID_IDataObject || iid == IID_IUnknown) {
        AddRef();
        *ppvObject = this;
        return S_OK;
      } else {
        *ppvObject = 0;
        return E_NOINTERFACE;
      }
    }; /* QueryInterface */
    
    ULONG __stdcall AddRef(void) {
      // increment object reference count
      return InterlockedIncrement(&m_lRefCount);
    }; /* AddRef */
    
    ULONG __stdcall Release(void) {
      // decrement object reference count
      LONG count = InterlockedDecrement(&m_lRefCount);
      if (count == 0) {
        delete this; return 0;
      } else {
         return count;
      }
    }; /* Release */
        
    // IDataObject members
    HRESULT __stdcall GetData(FORMATETC *pFormatEtc,  STGMEDIUM *pMedium) {
      int idx;
      // try to match the specified FORMATETC with one of our supported formats
      if ((idx = LookupFormatEtc(pFormatEtc)) == -1) return DV_E_FORMATETC;

      // found a match - transfer data into supplied storage medium
      pMedium->tymed           = m_pFormatEtc[idx].tymed;
      pMedium->pUnkForRelease  = 0;
          
      // copy the data into the caller's storage medium
      switch(m_pFormatEtc[idx].tymed) {
        case TYMED_HGLOBAL:
          pMedium->hGlobal = DupGlobalMem(m_pStgMedium[idx].hGlobal);
          break;
        default:
          return DV_E_FORMATETC;
      }
      return S_OK;
    }; /* GetData */
    
    HRESULT __stdcall GetDataHere(FORMATETC *pFormatEtc,  STGMEDIUM *pmedium) {
      return DATA_E_FORMATETC;
    }; /* GetDataHere */
            
    
    HRESULT __stdcall QueryGetData(FORMATETC *pFormatEtc) {
      return (LookupFormatEtc(pFormatEtc) == -1) ? DV_E_FORMATETC : S_OK;
    };
    
    HRESULT __stdcall GetCanonicalFormatEtc(FORMATETC *pFormatEct,
                      FORMATETC *pFormatEtcOut) {
      // Apparently we have to set this field to NULL even though we don't do
      // anything else.
      pFormatEtcOut->ptd = NULL;
      return E_NOTIMPL;
    }; /* GetCanonicalFormatEtc */
    
    HRESULT __stdcall SetData(FORMATETC *pFormatEtc, STGMEDIUM *pMedium,
                              BOOL fRelease) {
      return E_NOTIMPL;
    }; /* SetData */
    
    HRESULT __stdcall EnumFormatEtc(DWORD dwDirection,
                                    IEnumFORMATETC **ppEnumFormatEtc) {
      // only the get direction is supported for OLE
      if(dwDirection == DATADIR_GET) {
        // for Win2k+ you can use the SHCreateStdEnumFmtEtc API call, however
        // to support all Windows platforms we need to implement
        // IEnumFormatEtc ourselves.
        return CreateEnumFormatEtc(m_nNumFormats,m_pFormatEtc,ppEnumFormatEtc);
      } else {
        // the direction specified is not supported for drag+drop
        return E_NOTIMPL;
      }
    }; /* EnumFormatEtc */
    
    HRESULT __stdcall DAdvise(FORMATETC *pFormatEtc,  DWORD advf,
                              IAdviseSink *, DWORD *) {
      return OLE_E_ADVISENOTSUPPORTED;
    }; /* DAdvise */
    
    HRESULT __stdcall DUnadvise(DWORD dwConnection) {
      return OLE_E_ADVISENOTSUPPORTED;
    }; /* DUnadvise */
    
    HRESULT __stdcall EnumDAdvise(IEnumSTATDATA **ppEnumAdvise) {
      return OLE_E_ADVISENOTSUPPORTED;
    }; /* EnumDAdvise */;
        
    // Constructor / Destructor
    TkDND_DataObject(FORMATETC *fmtetc, STGMEDIUM *stgmed, int count) {
      // reference count must ALWAYS start at 1
      m_lRefCount    = 1;
      m_nNumFormats  = count;

      m_pFormatEtc   = new FORMATETC[count];
      m_pStgMedium   = new STGMEDIUM[count];

      for(int i = 0; i < count; i++)
      {
          m_pFormatEtc[i] = fmtetc[i];
          m_pStgMedium[i] = stgmed[i];
      }
      currentFormat = 0;
    }; /* TkDND_DataObject */
    
    ~TkDND_DataObject() {
      // cleanup
      if(m_pFormatEtc) delete[] m_pFormatEtc;
      if(m_pStgMedium) delete[] m_pStgMedium;
    }; /* ~TkDND_DataObject */

    // Custom functions.
    UINT GetCurrentFormat(void) {
      return currentFormat;
    }; /* GetCurrentFormat */

    const TCHAR *GetCurrentFormatName(void) {
      for (int i = 0; ClipboardFormatBook[i].name != 0; i++) {
        if (ClipboardFormatBook[i].cfFormat == currentFormat)
                     return ClipboardFormatBook[i].name;
      }
      GetClipboardFormatName((CLIPFORMAT) currentFormat, szTempStr, 78);
      return szTempStr;
    }; /* GetCurrentFormatName */

private:

    // any private members and functions
    LONG       m_lRefCount;
    FORMATETC *m_pFormatEtc;
    STGMEDIUM *m_pStgMedium;
    LONG       m_nNumFormats;
    UINT       currentFormat;

    TCHAR szTempStr[80];

    int LookupFormatEtc(FORMATETC *pFormatEtc) {
      // check each of our formats in turn to see if one matches
      for(int i = 0; i < m_nNumFormats; i++) {
        // The AND operator is used here because the FORMATETC::tymed member
        // is actually a bit-flag which can contain more than one value.
        // For example, the caller of QueryGetData could quite legitimetly
        // specify a FORMATETC::tymed value of (TYMED_HGLOBAL | TYMED_ISTREAM)
        // , which basically means "Do you support HGLOBAL or IStream?".
        if ((m_pFormatEtc[i].tymed    &  pFormatEtc->tymed)   &&
             m_pFormatEtc[i].cfFormat == pFormatEtc->cfFormat &&
             m_pFormatEtc[i].dwAspect == pFormatEtc->dwAspect) {
             currentFormat = m_pFormatEtc[i].cfFormat;
             // return index of stored format
             return i;
        }
      }
      // error, format not found
      return -1;
    }; /* LookupFormatEtc */

    HGLOBAL DupGlobalMem(HGLOBAL hMem) {
      DWORD   len    = GlobalSize(hMem);
      PVOID   source = GlobalLock(hMem);
      PVOID   dest   = GlobalAlloc(GMEM_FIXED, len);
      memcpy(dest, source, len);
      GlobalUnlock(hMem);
      return dest;
    }; /* DupGlobalMem */
    
}; /* TkDND_DataObject */


/*****************************************************************************
 * Drop Target Related Class.
 ****************************************************************************/
class TkDND_DropTarget;
typedef class TkDND_DropTarget *PTDropTarget;
class TkDND_DropTarget: public IDropTarget {
  private:
    LONG                 m_lRefCount; /* Reference count */
    Tcl_Interp          *interp;
    Tk_Window            tkwin;
    TCHAR                szTempStr[MAX_PATH+2];
    
    const TCHAR * FormatName(UINT cfFormat) {
      for (int i = 0; ClipboardFormatBook[i].name != 0; i++) {
        if (ClipboardFormatBook[i].cfFormat == cfFormat)
                     return ClipboardFormatBook[i].name;
      }
      GetClipboardFormatName((CLIPFORMAT) cfFormat, szTempStr, MAX_PATH);
      return szTempStr;
    }; /* FormatName */

  public:
    TkDND_DropTarget(Tcl_Interp *_interp, Tk_Window _tkwin) :
      interp(_interp), tkwin(_tkwin), m_lRefCount(1) {
    }; /* TkDND_DropTarget */
   
    ~TkDND_DropTarget(void) {
   }; /* ~TkDND_DropTarget */
   
    /* IUnknown interface members */
    HRESULT __stdcall QueryInterface(REFIID iid, void ** ppvObject) {
      // check to see what interface has been requested
      if (iid == IID_IEnumFORMATETC || iid == IID_IUnknown) {
        AddRef();
        *ppvObject = this;
        return S_OK;
      } else {
        *ppvObject = 0;
        return E_NOINTERFACE;
      }
    }; /* QueryInterface */
    
    ULONG __stdcall AddRef(void) {
      // increment object reference count
      return InterlockedIncrement(&m_lRefCount);
    }; /* AddRef */
    
    ULONG __stdcall Release(void) {
      // decrement object reference count
      LONG count = InterlockedDecrement(&m_lRefCount);
      if (count == 0) {
        delete this; return 0;
      } else {
        return count;
      }
    }; /* Release */

    /* IDropTarget interface members */

    STDMETHODIMP DragEnter(IDataObject *pDataObject, DWORD grfKeyState, 
                           POINTL pt, DWORD *pdwEffect) {
      // We want to get:
      //   a) The types supported by the drag source.
      //   b) The actions supported by the drag source.
      //   c) The state of the keyboard modifier keys.
      // And we must return:
      //   a) The prefered action.

      IEnumFORMATETC *pEF;
      FORMATETC fetc;
      char tmp[64];
      Tcl_Obj *typelist    = Tcl_NewListObj(0, NULL), *element,
              *actionlist  = Tcl_NewListObj(0, NULL), *objv[8],
              *pressedkeys = Tcl_NewListObj(0, NULL), *result,
              *codelist    = Tcl_NewListObj(0, NULL);
      int i, status, index;
      static const char *DropActions[] = {
        "copy", "move", "link", "ask",  "private", "refuse_drop",
        "default", 
        (char *) NULL
      };
      enum dropactions {
        ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate,
        refuse_drop, ActionDefault
      };

      // Get the types supported by the drag source.
      if (pDataObject->EnumFormatEtc(DATADIR_GET, &pEF) == S_OK) {
        while (pEF->Next(1, &fetc, NULL) == S_OK) {
          if (pDataObject->QueryGetData(&fetc) == S_OK) {
            /* Get the format name from windows */
            element = TCL_NEWSTRING(FormatName(fetc.cfFormat), -1);
            Tcl_ListObjAppendElement(NULL, typelist, element);
            /* Store the numeric code of the format */
            sprintf(tmp, "0x%08x", fetc.cfFormat);
            element = Tcl_NewStringObj(tmp, -1);
            Tcl_ListObjAppendElement(NULL, codelist, element);
          }; // if (pIDataSource->QueryGetData(&fetc) == S_OK)
        }; // while (pEF->Next(1, &fetc, NULL) == S_OK)
      }; // if (pIDataSource->EnumFormatEtc(DATADIR_GET, &pEF) == S_OK)

      // Get the state of the keyboard modifier keys.
      // MK_CONTROL, MK_SHIFT, MK_ALT, MK_RBUTTON, MK_LBUTTON
      if (grfKeyState & MK_CONTROL)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("ctrl", -1));
      if (grfKeyState & MK_SHIFT)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("shift",-1));
      if (grfKeyState & MK_ALT)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("alt", -1));
      if (grfKeyState & MK_RBUTTON)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("3", -1));
      if (grfKeyState & MK_MBUTTON)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("2", -1));
      if (grfKeyState & MK_LBUTTON)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("1", -1));
      
      // Get the actions supported by the drag source.
      // DROPEFFECT_COPY, DROPEFFECT_MOVE, DROPEFFECT_LINK
      if (*pdwEffect & DROPEFFECT_COPY)
        Tcl_ListObjAppendElement(NULL,actionlist,Tcl_NewStringObj("copy", -1));
      if (*pdwEffect & DROPEFFECT_MOVE)
        Tcl_ListObjAppendElement(NULL,actionlist,Tcl_NewStringObj("move", -1));
      if (*pdwEffect & DROPEFFECT_LINK)
        Tcl_ListObjAppendElement(NULL,actionlist,Tcl_NewStringObj("link", -1));

      // We are ready to pass the info to the Tcl level, and get the desired
      // action.
      objv[0] = Tcl_NewStringObj("tkdnd::olednd::_HandleDragEnter", -1);
      objv[1] = Tcl_NewStringObj(Tk_PathName(tkwin), -1);
      objv[2] = typelist;
      objv[3] = actionlist;
      objv[4] = pressedkeys;
      objv[5] = Tcl_NewLongObj(pt.x);
      objv[6] = Tcl_NewLongObj(pt.y);
      objv[7] = codelist;
      TkDND_Status_Eval(8);
      *pdwEffect = DROPEFFECT_NONE;
      if (status == TCL_OK) {
        /* Get the returned action... */
        result = Tcl_GetObjResult(interp); Tcl_IncrRefCount(result);
        status = Tcl_GetIndexFromObj(interp, result, (const char **)DropActions,
                                     "dropactions", 0, &index);
        Tcl_DecrRefCount(result);
        if (status != TCL_OK) index = ActionDefault;
      }
      switch ((enum dropactions) index) {
        case ActionCopy:    *pdwEffect = DROPEFFECT_COPY; break;
        case ActionMove:    *pdwEffect = DROPEFFECT_MOVE; break;
        case ActionLink:    *pdwEffect = DROPEFFECT_LINK; break;
        case ActionAsk:     *pdwEffect = DROPEFFECT_NONE; break;
        case ActionPrivate: *pdwEffect = DROPEFFECT_NONE; break;
        case ActionDefault: *pdwEffect = DROPEFFECT_COPY; break;
        case refuse_drop:   *pdwEffect = DROPEFFECT_NONE; /* Refuse drop. */
      }
      return S_OK;
    }; /* DragEnter */
    
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect) {
      Tcl_Obj *objv[5], *pressedkeys = Tcl_NewListObj(0, NULL), *result;
      int i, status, index;
      static const char *DropActions[] = {
        "copy", "move", "link", "ask",  "private", "refuse_drop",
        "default",
        (char *) NULL
      };
      enum dropactions {
        ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate,
        refuse_drop, ActionDefault
      };

      // Get the state of the keyboard modifier keys.
      // MK_CONTROL, MK_SHIFT, MK_ALT, MK_RBUTTON, MK_LBUTTON
      if (grfKeyState & MK_CONTROL)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("ctrl", -1));
      if (grfKeyState & MK_SHIFT)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("shift",-1));
      if (grfKeyState & MK_ALT)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("alt", -1));
      if (grfKeyState & MK_RBUTTON)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("3", -1));
      if (grfKeyState & MK_MBUTTON)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("2", -1));
      if (grfKeyState & MK_LBUTTON)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("1", -1));

      // We are ready to pass the info to the Tcl level, and get the desired
      // action.
      objv[0] = Tcl_NewStringObj("tkdnd::olednd::_HandleDragOver", -1);
      objv[1] = Tcl_NewStringObj(Tk_PathName(tkwin), -1);
      objv[2] = pressedkeys;
      objv[3] = Tcl_NewLongObj(pt.x);
      objv[4] = Tcl_NewLongObj(pt.y);
      TkDND_Status_Eval(5);
      *pdwEffect = DROPEFFECT_NONE;
      if (status == TCL_OK) {
        /* Get the returned action... */
        result = Tcl_GetObjResult(interp); Tcl_IncrRefCount(result);
        status = Tcl_GetIndexFromObj(interp, result, (const char **)DropActions,
                                     "dropactions", 0, &index);
        Tcl_DecrRefCount(result);
        if (status != TCL_OK) index = ActionDefault;
      }
      switch ((enum dropactions) index) {
        case ActionCopy:    *pdwEffect = DROPEFFECT_COPY; break;
        case ActionMove:    *pdwEffect = DROPEFFECT_MOVE; break;
        case ActionLink:    *pdwEffect = DROPEFFECT_LINK; break;
        case ActionAsk:     *pdwEffect = DROPEFFECT_NONE; break;
        case ActionPrivate: *pdwEffect = DROPEFFECT_NONE; break;
        case ActionDefault: *pdwEffect = DROPEFFECT_COPY; break;
        case refuse_drop:   *pdwEffect = DROPEFFECT_NONE; /* Refuse drop. */
      }
      return S_OK;
    }; /* DragOver */
    
    STDMETHODIMP DragLeave(void) {
      Tcl_Obj *objv[2];
      int i;
      objv[0] = Tcl_NewStringObj("tkdnd::olednd::_HandleDragLeave", -1);
      objv[1] = Tcl_NewStringObj(Tk_PathName(tkwin), -1);
      TkDND_Eval(2);
      return S_OK;
    }; /* DragLeave */
    
    STDMETHODIMP Drop(IDataObject *pDataObject, DWORD grfKeyState, 
                      POINTL pt, DWORD *pdwEffect) {
      Tcl_Obj *objv[7], *result, **typeObj, *data = NULL, *type,
              *pressedkeys = NULL;
      int i, type_index, status, index, typeObjc;
      static const char *DropTypes[] = {
        "CF_UNICODETEXT", "CF_TEXT", "CF_HDROP",
        "FileGroupDescriptorW", "FileGroupDescriptor",
        (char *) NULL
      };
      enum droptypes {
        TYPE_CF_UNICODETEXT, TYPE_CF_TEXT, TYPE_CF_HDROP,
        TYPE_FILEGROUPDESCRIPTORW, TYPE_FILEGROUPDESCRIPTOR
      };
      static const char *DropActions[] = {
        "copy", "move", "link", "ask",  "private", "refuse_drop",
        "default",
        (char *) NULL
      };
      enum dropactions {
        ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate,
        refuse_drop, ActionDefault
      };
      *pdwEffect = DROPEFFECT_NONE;
      // Get the drop format list.
      objv[0] = Tcl_NewStringObj("tkdnd::olednd::_GetDropTypes", -1);
      objv[1] = Tcl_NewStringObj(Tk_PathName(tkwin), -1);
      TkDND_Status_Eval(2); if (status != TCL_OK) return S_OK;
      result = Tcl_GetObjResult(interp); Tcl_IncrRefCount(result);
      status = Tcl_ListObjGetElements(interp, result, &typeObjc, &typeObj);
      if (status != TCL_OK) {Tcl_DecrRefCount(result); return S_OK;}
      // Try to get the data.
      for (type_index = 0; type_index < typeObjc; ++type_index) {
        status = Tcl_GetIndexFromObj(interp, typeObj[type_index],
                             (const char **)DropTypes, "droptypes", 0, &index);
        if (status == TCL_OK) {
          switch ((enum droptypes) index) {
            case TYPE_CF_UNICODETEXT:
              data = GetData_CF_UNICODETEXT(pDataObject); break;
            case TYPE_CF_TEXT:
              data = GetData_CF_TEXT(pDataObject); break;
            case TYPE_CF_HDROP:
              data = GetData_CF_HDROP(pDataObject); break;
            case TYPE_FILEGROUPDESCRIPTORW:
              // Get a directory where we can store files...
              objv[0]=Tcl_NewStringObj("tkdnd::GetDropFileTempDirectory", -1);
              TkDND_Status_Eval(1);
              if (status == TCL_OK) {
                strcpy((char *) szTempStr, Tcl_GetStringResult(interp));
                data = GetData_FileGroupDescriptorW(pDataObject);
              }
              break;
            case TYPE_FILEGROUPDESCRIPTOR:
              // Get a directory where we can store files...
              objv[0] = Tcl_NewStringObj("tkdnd::GetDropFileTempDirectory", -1);
              TkDND_Status_Eval(1);
              if (status == TCL_OK) {
                strcpy((char *) szTempStr, Tcl_GetStringResult(interp));
                data = GetData_FileGroupDescriptor(pDataObject);
              }
              break;
          }
        }
        if (data != NULL) {
          type = typeObj[type_index]; Tcl_IncrRefCount(type);
          break; // We have got the data!
        }
      }

      if (data == NULL) {
        // We failed to get the data.
        type = typeObj[0]; Tcl_IncrRefCount(type);
        data = GetData_Bytearray(pDataObject, type);
      }
      Tcl_DecrRefCount(result);
      
      // Get the state of the keyboard modifier keys.
      // MK_CONTROL, MK_SHIFT, MK_ALT, MK_RBUTTON, MK_LBUTTON
      pressedkeys = Tcl_NewListObj(0, NULL);
      if (grfKeyState & MK_CONTROL)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("ctrl", -1));
      if (grfKeyState & MK_SHIFT)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("shift",-1));
      if (grfKeyState & MK_ALT)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("alt", -1));
      if (grfKeyState & MK_RBUTTON)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("3", -1));
      if (grfKeyState & MK_MBUTTON)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("2", -1));
      if (grfKeyState & MK_LBUTTON)
        Tcl_ListObjAppendElement(NULL,pressedkeys,Tcl_NewStringObj("1", -1));

      // We are ready to pass the info to the Tcl level, and get the desired
      // action.
      objv[0] = Tcl_NewStringObj("tkdnd::olednd::_HandleDrop", -1);
      objv[1] = Tcl_NewStringObj(Tk_PathName(tkwin), -1);
      objv[2] = pressedkeys;
      objv[3] = Tcl_NewLongObj(pt.x);
      objv[4] = Tcl_NewLongObj(pt.y);
      objv[5] = type;
      objv[6] = data;
      TkDND_Status_Eval(7);
      Tcl_DecrRefCount(type);
      *pdwEffect = DROPEFFECT_NONE;
      if (status == TCL_OK) {
        /* Get the returned action... */
        result = Tcl_GetObjResult(interp); Tcl_IncrRefCount(result);
        status = Tcl_GetIndexFromObj(interp, result, (const char **)DropActions,
                                     "dropactions", 0, &index);
        Tcl_DecrRefCount(result);
        if (status != TCL_OK) index = ActionDefault;
      }
      switch ((enum dropactions) index) {
        case ActionCopy:    *pdwEffect = DROPEFFECT_COPY; break;
        case ActionMove:    *pdwEffect = DROPEFFECT_MOVE; break;
        case ActionLink:    *pdwEffect = DROPEFFECT_LINK; break;
        case ActionAsk:     *pdwEffect = DROPEFFECT_NONE; break;
        case ActionPrivate: *pdwEffect = DROPEFFECT_NONE; break;
        case ActionDefault: *pdwEffect = DROPEFFECT_COPY; break;
        case refuse_drop:   *pdwEffect = DROPEFFECT_NONE; /* Refuse drop. */
      }
      
      return S_OK;
    }; /* Drop */

    /* TkDND additional interface methods */
private:

    Tcl_Obj *GetData_Bytearray(IDataObject *pDataObject, Tcl_Obj *formatObj) {
      STGMEDIUM StgMed;
      FORMATETC fmte = { 0, (DVTARGETDEVICE FAR *)NULL,
                         DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
      Tcl_Obj *result;
      unsigned char *bytes;
      fmte.cfFormat = RegisterClipboardFormat(TCL_GETSTRING(formatObj));
      if (pDataObject->QueryGetData(&fmte) != S_OK ||
          pDataObject->GetData(&fmte, &StgMed) != S_OK ) {
        Tcl_NewStringObj("unsupported type", -1);
      }
      bytes = (unsigned char *) GlobalLock(StgMed.hGlobal);
      result = Tcl_NewByteArrayObj(bytes, GlobalSize(StgMed.hGlobal));
      GlobalUnlock(StgMed.hGlobal);
      ReleaseStgMedium(&StgMed);
      return result;
    }; /* GetData_Bytearray */

    Tcl_Obj *GetData_CF_UNICODETEXT(IDataObject *pDataObject) {
      STGMEDIUM StgMed;
      FORMATETC fmte = { CF_UNICODETEXT, (DVTARGETDEVICE FAR *)NULL,
                         DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
      
      if (pDataObject->QueryGetData(&fmte) == S_OK) {
        if (pDataObject->GetData(&fmte, &StgMed) == S_OK) {
          Tcl_DString ds;
          char *data, *destPtr;
          data = (char *) GlobalLock(StgMed.hGlobal);
          Tcl_DStringInit(&ds);
          Tcl_UniCharToUtfDString((Tcl_UniChar *) data,
              Tcl_UniCharLen((Tcl_UniChar *) data), &ds);
          GlobalUnlock(StgMed.hGlobal);
          ReleaseStgMedium(&StgMed);
          /*  Translate CR/LF to LF.  */
          data = destPtr = Tcl_DStringValue(&ds);
          while (*data) {
              if (data[0] == '\r' && data[1] == '\n') {
                  data++;
              } else {
                  *destPtr++ = *data++;
              }
          }
          *destPtr = '\0';
          Tcl_Obj *result = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
          Tcl_DStringFree(&ds);
          return result;
        }
      }
      return NULL;
    }; /* GetData_CF_UNICODETEXT */

    Tcl_Obj *GetData_CF_TEXT(IDataObject *pDataObject) {
      STGMEDIUM StgMed;
      FORMATETC fmte = { CF_TEXT, (DVTARGETDEVICE FAR *)NULL,
                         DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
      FORMATETC fmte_locale = { CF_LOCALE, (DVTARGETDEVICE FAR *)NULL,
                         DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
      
      if (pDataObject->QueryGetData(&fmte) == S_OK) {
        // Determine the encoding to use to convert this text.
        Tcl_Encoding encoding = NULL;
        char *data, *destPtr;
        if (pDataObject->QueryGetData(&fmte_locale) == S_OK) {
          if (pDataObject->GetData(&fmte_locale, &StgMed) == S_OK) {
            Tcl_DString ds;
            int locale;
            Tcl_DStringInit(&ds);
            Tcl_DStringAppend(&ds, "cp######", -1);
            data = (char *) GlobalLock(StgMed.hGlobal);
            /*
             * Even though the documentation claims that GetLocaleInfo expects
             * an LCID, on Windows 9x it really seems to expect a LanguageID.
             */
            locale = LANGIDFROMLCID(*((int*) data));
            GetLocaleInfoA(locale, LOCALE_IDEFAULTANSICODEPAGE,
                     Tcl_DStringValue(&ds)+2, Tcl_DStringLength(&ds)-2);
            GlobalUnlock(StgMed.hGlobal);
            encoding = Tcl_GetEncoding(NULL, Tcl_DStringValue(&ds));
            Tcl_DStringFree(&ds);
          } 
        }
        if (pDataObject->GetData(&fmte, &StgMed) == S_OK) {
          Tcl_DString ds;
          
          data = (char *) GlobalLock(StgMed.hGlobal);
          Tcl_DStringInit(&ds);
          Tcl_ExternalToUtfDString(encoding, data, -1, &ds);
          GlobalUnlock(StgMed.hGlobal);
          ReleaseStgMedium(&StgMed);
          if (encoding) Tcl_FreeEncoding(encoding);
          
          /*  Translate CR/LF to LF.  */
          data = destPtr = Tcl_DStringValue(&ds);
          while (*data) {
              if (data[0] == '\r' && data[1] == '\n') {
                  data++;
              } else {
                  *destPtr++ = *data++;
              }
          }
          *destPtr = '\0';
          Tcl_Obj *result = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
          Tcl_DStringFree(&ds);
          return result;
        }
      }
      return NULL;
    }; /* GetData_CF_TEXT */
    
    Tcl_Obj *GetData_CF_HDROP(IDataObject *pDataObject) {
#if defined(UNICODE)
      Tcl_DString ds;
      // char utf8[MAX_PATH*4+2];
#endif /* UNICODE */
      STGMEDIUM StgMed;
      memset(&StgMed, 0, sizeof(StgMed));
      StgMed.tymed = TYMED_HGLOBAL;
      FORMATETC fmte = { CF_HDROP, (DVTARGETDEVICE FAR *)NULL,
                         DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
      if (pDataObject->QueryGetData(&fmte) == S_OK) {
        if (pDataObject->GetData(&fmte, &StgMed) == S_OK) {
          HDROP hdrop;
          UINT cFiles;
          TCHAR szFile[MAX_PATH+2];
          Tcl_Obj *result, *item;
          char *utf_8_data = NULL, *p;

          hdrop = (HDROP) GlobalLock(StgMed.hGlobal);
          if ( NULL == hdrop ) {
            GlobalUnlock(hdrop);
            ReleaseStgMedium(&StgMed);
            return NULL;
          }
          cFiles = ::DragQueryFile(hdrop, (UINT)-1, NULL, 0);
          result = Tcl_NewListObj(0, NULL);

          for (UINT count = 0; count < cFiles; count++) {
            ::DragQueryFile(hdrop, count, szFile, sizeof(szFile));
#if defined(UNICODE)
            /* Convert UTF-16 to UTF-8... */
            // memset(utf8, sizeof(utf8), 0);
            // WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR) szFile, -1,
            //                                 utf8, sizeof(utf8), 0, 0);
            Tcl_DStringInit(&ds);
            Tcl_UniCharToUtfDString((Tcl_UniChar *) szFile,
                Tcl_UniCharLen((Tcl_UniChar *) szFile), &ds);
            utf_8_data = Tcl_DStringValue(&ds);
            // utf_8_data = utf8;
#else  /* UNICODE */
            utf_8_data = (char *) &szFile[0];
#endif /* UNICODE */
            /* Convert to forward slashes for easier access in scripts... */
            for (p=utf_8_data; *p!='\0'; p=(char *) CharNextA(p)) {
              if (*p == '\\') *p = '/';
            }
            item = Tcl_NewStringObj(utf_8_data, -1);
            Tcl_ListObjAppendElement(NULL, result, item);
#if defined(UNICODE)
            Tcl_DStringFree(&ds);
#endif /* UNICODE */
          }
          GlobalUnlock(StgMed.hGlobal);
          ReleaseStgMedium(&StgMed);
          //if (StgMed.pUnkForRelease) { StgMed.pUnkForRelease->Release(); }
          //else { ::GlobalFree(StgMed.hGlobal); }
          return result;
        }
      }
      return NULL;
    }; /* GetData_CF_HDROP */

#define BLOCK_SIZE 1024
    HRESULT StreamToFile(IStream *stream, char *file_name) {
      byte buffer[BLOCK_SIZE];
      unsigned long bytes_read = 0;
      int bytes_written = 0;
      int new_file;
      HRESULT hr = S_OK;
    
      new_file = _sopen(file_name, O_RDWR | O_BINARY | O_CREAT,
                                  SH_DENYNO, S_IREAD | S_IWRITE);
      if (new_file != -1) {
        do {
          hr = stream->Read(buffer, BLOCK_SIZE, &bytes_read);
          if (bytes_read) bytes_written = _write(new_file, buffer, bytes_read);
        } while (S_OK == hr && bytes_read == BLOCK_SIZE);
        _close(new_file);
        if (bytes_written == 0) _unlink(file_name);
      } else {
        unsigned long error;
        if ((error = GetLastError()) == 0L) error = _doserrno;
        hr = HRESULT_FROM_WIN32(errno);
      }
      return hr;
    }; /* StreamToFile */

    Tcl_Obj *GetData_FileGroupDescriptor(IDataObject *pDataObject) {
      STGMEDIUM StgMed;
      FORMATETC fmte_locale    = { CF_LOCALE, (DVTARGETDEVICE FAR *) NULL,
                                   DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
      FORMATETC descriptor_fmt = { 0, (DVTARGETDEVICE FAR *) NULL,
                                   DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
      FORMATETC contents_fmt   = { 0, (DVTARGETDEVICE FAR *) NULL,
                                   DVASPECT_CONTENT, -1, TYMED_ISTREAM };
      HRESULT hr = S_OK;
      FILEGROUPDESCRIPTOR *file_group_descriptor;
      FILEDESCRIPTOR file_descriptor;
      Tcl_Encoding encoding = NULL;

      descriptor_fmt.cfFormat = RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR);
      contents_fmt.cfFormat   = RegisterClipboardFormat(CFSTR_FILECONTENTS);
      if (pDataObject->QueryGetData(&descriptor_fmt) != S_OK) return NULL;
      if (pDataObject->QueryGetData(&contents_fmt) != S_OK) return NULL;
      // Get the descriptor information
      STGMEDIUM storage = {0,0,0};
      hr = pDataObject->GetData(&descriptor_fmt, &storage);
      if (hr != S_OK) return NULL;
      file_group_descriptor = (FILEGROUPDESCRIPTOR *)
                              GlobalLock(storage.hGlobal);
      // Determine the encoding to use to convert this text.
      if (pDataObject->QueryGetData(&fmte_locale) == S_OK) {
        if (pDataObject->GetData(&fmte_locale, &StgMed) == S_OK) {
          Tcl_DString ds;
          int locale;
          Tcl_DStringInit(&ds);
          Tcl_DStringAppend(&ds, "cp######", -1);
          char *data = (char *) GlobalLock(StgMed.hGlobal);
          /*
           * Even though the documentation claims that GetLocaleInfo expects
           * an LCID, on Windows 9x it really seems to expect a LanguageID.
           */
          locale = LANGIDFROMLCID(*((int*) data));
          GetLocaleInfoA(locale, LOCALE_IDEFAULTANSICODEPAGE,
                  Tcl_DStringValue(&ds)+2, Tcl_DStringLength(&ds)-2);
          GlobalUnlock(StgMed.hGlobal);
          encoding = Tcl_GetEncoding(NULL, Tcl_DStringValue(&ds));
          Tcl_DStringFree(&ds);
        } 
      }
      Tcl_Obj *result = Tcl_NewListObj(0, NULL);
      // For each file, get the name and copy the stream to a file
      for (unsigned int file_index = 0;
           file_index < file_group_descriptor->cItems; file_index++) {
        STGMEDIUM content_storage = {TYMED_ISTREAM,0,0};
        file_descriptor = file_group_descriptor->fgd[file_index];
        contents_fmt.lindex = file_index;
        if (pDataObject->GetData(&contents_fmt, &content_storage) == S_OK) {
          // Dump stream into a file.
          char file_name[MAX_PATH+1];
          GlobalLock(content_storage.pstm);
          strcpy(file_name, (char *) szTempStr);
          strcat(file_name, "\\");
          strcat(file_name, (char *) file_descriptor.cFileName);
          if (StreamToFile(content_storage.pstm, file_name) == S_OK) {
            Tcl_DString ds;
            Tcl_DStringInit(&ds);
            Tcl_ExternalToUtfDString(encoding, file_name, -1, &ds);
            Tcl_ListObjAppendElement(NULL, result,
                       Tcl_NewStringObj(Tcl_DStringValue(&ds), -1));
            Tcl_DStringFree(&ds);
          }
          GlobalUnlock(content_storage.pstm);
        }
        ReleaseStgMedium(&content_storage);
      }
      GlobalUnlock(storage.hGlobal);
      ReleaseStgMedium(&storage);
      if (encoding) Tcl_FreeEncoding(encoding);
      return result;
    }; /* GetData_FileGroupDescriptor */

    HRESULT StreamToFileW(IStream *stream, const Tcl_UniChar *file_name) {
      byte buffer[BLOCK_SIZE];
      unsigned long bytes_read = 0;
      int bytes_written = 0;
      int new_file;
      HRESULT hr = S_OK;
    
      new_file = _wsopen((wchar_t *) file_name, O_RDWR | O_BINARY | O_CREAT,
                                               SH_DENYNO, S_IREAD | S_IWRITE);
      if (new_file != -1) {
        do {
          hr = stream->Read(buffer, BLOCK_SIZE, &bytes_read);
          if (bytes_read) bytes_written = _write(new_file, buffer, bytes_read);
        } while (S_OK == hr && bytes_read == BLOCK_SIZE);
        _close(new_file);
        if (bytes_written == 0) _wunlink((wchar_t *) file_name);
        return S_OK;
      } else {
        unsigned long error;
        if ((error = GetLastError()) == 0L) error = _doserrno;
        hr = HRESULT_FROM_WIN32(errno);
      }
      return hr;
    }; /* StreamToFileW */

    Tcl_Obj *GetData_FileGroupDescriptorW(IDataObject *pDataObject) {
      FORMATETC descriptor_fmt = { 0, (DVTARGETDEVICE FAR *) NULL,
                                   DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
      FORMATETC contents_fmt   = { 0, (DVTARGETDEVICE FAR *) NULL,
                                   DVASPECT_CONTENT, -1, TYMED_ISTREAM };
      HRESULT hr = S_OK;
      FILEGROUPDESCRIPTORW *file_group_descriptor;
      FILEDESCRIPTORW file_descriptor;
      Tcl_Obj *item;

      descriptor_fmt.cfFormat = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
      contents_fmt.cfFormat   = RegisterClipboardFormat(CFSTR_FILECONTENTS);
      if (pDataObject->QueryGetData(&descriptor_fmt) != S_OK) return NULL;
      if (pDataObject->QueryGetData(&contents_fmt) != S_OK) return NULL;
      // Get the descriptor information
      STGMEDIUM storage = {0,0,0};
      hr = pDataObject->GetData(&descriptor_fmt, &storage);
      if (hr != S_OK) return NULL;
      file_group_descriptor = (FILEGROUPDESCRIPTORW *)
                              GlobalLock(storage.hGlobal);

      Tcl_Obj *result = Tcl_NewListObj(0, NULL);
      // For each file, get the name and copy the stream to a file
      for (unsigned int file_index = 0;
           file_index < file_group_descriptor->cItems; file_index++) {
        STGMEDIUM content_storage = {TYMED_ISTREAM,0,0};
        file_descriptor = file_group_descriptor->fgd[file_index];
        contents_fmt.lindex = file_index;
        if (pDataObject->GetData(&contents_fmt, &content_storage) == S_OK) {
          // Dump stream into a file.
          item = Tcl_NewUnicodeObj((Tcl_UniChar *) szTempStr, -1);
          Tcl_AppendToObj(item, "\\", 1);
          Tcl_GetUnicode(item);
          Tcl_AppendUnicodeToObj(item, (Tcl_UniChar *)
                                       file_descriptor.cFileName, -1);
          GlobalLock(content_storage.pstm);
          if (StreamToFileW(content_storage.pstm, Tcl_GetUnicode(item))==S_OK) {
            Tcl_ListObjAppendElement(NULL, result, item);
#if 0
          } else {
            LPVOID lpMsgBuf;
            if (!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL, GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR) &lpMsgBuf, 0, NULL )) {
               // Handle the error.
            }
            // Display the string.
            MessageBox( NULL, (LPCTSTR)lpMsgBuf, "Error",
                        MB_OK | MB_ICONINFORMATION );
            // Free the buffer.
            LocalFree( lpMsgBuf );
#endif
          }
          GlobalUnlock(content_storage.pstm);
        }
        ReleaseStgMedium(&content_storage);
      }
      GlobalUnlock(storage.hGlobal);
      ReleaseStgMedium(&storage);
      return result;
    }; /* GetData_FileGroupDescriptorW */

}; /* TkDND_DropTarget */

/*****************************************************************************
 * Drop Source Related Class.
 ****************************************************************************/
class TkDND_DropSource : public IDropSource {
public:
    int button;

    // IUnknown members
    HRESULT __stdcall QueryInterface(REFIID iid, void ** ppvObject) {
      // check to see what interface has been requested
      if (iid == IID_IDropSource || iid == IID_IUnknown) {
          AddRef();
          *ppvObject = this;
          return S_OK;
      } else {
          *ppvObject = 0;
          return E_NOINTERFACE;
      }
    }; /* QueryInterface */
    
    ULONG   __stdcall AddRef(void) {
      // increment object reference count
      return InterlockedIncrement(&m_lRefCount);
    }; /* AddRef */
    
    ULONG   __stdcall Release(void) {
      // decrement object reference count
      LONG count = InterlockedDecrement(&m_lRefCount);
      if (count == 0) { delete this; return 0; }
      else { return count; };
    }; /* Release */
                
    // IDropSource members

    //  Called by OLE whenever Escape/Control/Shift/Mouse buttons have changed
    HRESULT __stdcall QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState){
      // if the <Escape> key has been pressed since the last call,
      // cancel the drop
      if(fEscapePressed == TRUE) return DRAGDROP_S_CANCEL;        

      switch (button) {
        case 1: {
          // if the <LeftMouse> button has been released, then do the drop!
          if((grfKeyState & MK_LBUTTON) == 0) return DRAGDROP_S_DROP;
          break;
        }
        case 2: {
          // if the <MiddleMouse> button has been released, then do the drop!
          if((grfKeyState & MK_MBUTTON) == 0) return DRAGDROP_S_DROP;
          break;
        }
        case 3: {
          // if the <RightMouse> button has been released, then do the drop!
          if((grfKeyState & MK_RBUTTON) == 0) return DRAGDROP_S_DROP;
          break;
        }
      }

      // continue with the drag-drop
      return S_OK;
    }; /* QueryContinueDrag */

    // Return either S_OK, or DRAGDROP_S_USEDEFAULTCURSORS to instruct
    // OLE to use the default mouse cursor images...
    HRESULT __stdcall GiveFeedback(DWORD dwEffect) {
      return DRAGDROP_S_USEDEFAULTCURSORS;
    }; /* GiveFeedback */
        
    // Constructor / Destructor
    TkDND_DropSource() {
      m_lRefCount = 1;
      button = 1;
    }; /* TkDND_DropSource */

    TkDND_DropSource(int b) {
      m_lRefCount = 1;
      button = b;
    }; /* TkDND_DropSource */
    
    ~TkDND_DropSource() {};
        
private:
    LONG   m_lRefCount;
}; /* TkDND_DropSource */

#endif /* _OLE_DND_H */
blob
data 15608
/*
 * TkDND_OleDND.h -- Tk OleDND Drag'n'Drop Protocol Implementation
 * 
 *    This file implements the unix portion of the drag&drop mechanism
 *    for the Tk toolkit. The protocol in use under windows is the
 *    OleDND protocol.
 *
 * This software is copyrighted by:
 * Georgios Petasis, Athens, Greece.
 * e-mail: petasisg@yahoo.gr, petasis@iit.demokritos.gr
 * Laurent Riesterer, Rennes, France.
 * e-mail: laurent.riesterer@free.fr
 *
 * The following terms apply to all files associated
 * with the software unless explicitly disclaimed in individual files.
 *
 * The authors hereby grant permission to use, copy, modify, distribute,
 * and license this software and its documentation for any purpose, provided
 * that existing copyright notices are retained in all copies and that this
 * notice is included verbatim in any distributions. No written agreement,
 * license, or royalty fee is required for any of the authorized uses.
 * Modifications to this software may be copyrighted by their authors
 * and need not follow the licensing terms described here, provided that
 * the new terms are clearly indicated on the first page of each file where
 * they apply.
 * 
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY
 * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 * ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY
 * DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE
 * IS PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE
 * NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 */

#include "OleDND.h"
#if defined(HAVE_STRSAFE_H) || !defined(NO_STRSAFE_H)
#include "Strsafe.h"
#endif

int TkDND_RegisterDragDropObjCmd(ClientData clientData, Tcl_Interp *interp,
                                 int objc, Tcl_Obj *CONST objv[]) {
  TkDND_DropTarget *pDropTarget;
  Tk_Window tkwin;
  HRESULT hret;
  
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, "path");
    return TCL_ERROR;
  }
  Tcl_ResetResult(interp);

  tkwin = TkDND_TkWin(objv[1]);
  if (tkwin == NULL) {
    Tcl_AppendResult(interp, "invalid Tk widget path: \"",
                             Tcl_GetString(objv[1]), (char *) NULL);
    return TCL_ERROR;
  }
  Tk_MakeWindowExist(tkwin);

  pDropTarget = new TkDND_DropTarget(interp, tkwin);
  if (pDropTarget == NULL) {
    Tcl_SetResult(interp, "out of memory", TCL_STATIC);
    return TCL_ERROR;
  }
  hret = RegisterDragDrop(Tk_GetHWND(Tk_WindowId(tkwin)), pDropTarget);
  switch (hret) {
    case E_OUTOFMEMORY: {
      delete pDropTarget;
      Tcl_AppendResult(interp, "unable to register \"", Tcl_GetString(objv[1]),
                "\" as a drop target: out of memory", (char *) NULL);
      break;
    }
    case DRAGDROP_E_INVALIDHWND: {
      delete pDropTarget;
      Tcl_AppendResult(interp, "unable to register \"", Tcl_GetString(objv[1]),
                "\" as a drop target: invalid window handle", (char *) NULL);
      break;
    }
    case DRAGDROP_E_ALREADYREGISTERED: {
      /* Silently ignore this. The window has been registered before. */
    }
    case S_OK: return TCL_OK;
  }
  return TCL_ERROR;
}; /* TkDND_RegisterDragDropObjCmd */

int TkDND_RevokeDragDropObjCmd(ClientData clientData, Tcl_Interp *interp,
                                 int objc, Tcl_Obj *CONST objv[]) {
  Tk_Window tkwin;
  HRESULT hret;
  
  if (objc != 2) {
    Tcl_WrongNumArgs(interp, 1, objv, "path");
    return TCL_ERROR;
  }
  Tcl_ResetResult(interp);

  tkwin = TkDND_TkWin(objv[1]);
  if (tkwin == NULL) {
    Tcl_AppendResult(interp, "invalid Tk widget path: \"",
                             Tcl_GetString(objv[1]), (char *) NULL);
    return TCL_ERROR;
  }

  hret = RevokeDragDrop(Tk_GetHWND(Tk_WindowId(tkwin)));
  if (hret != S_OK) {
    Tcl_AppendResult(interp, "Tk widget \"", Tcl_GetString(objv[1]),
              "\" has never been registered as a drop target", (char *) NULL);
    return TCL_ERROR;
  }
              
  return TCL_OK;
}; /* TkDND_RevokeDragDropObjCmd */

int TkDND_DoDragDropObjCmd(ClientData clientData, Tcl_Interp *interp,
                           int objc, Tcl_Obj *CONST objv[]) {
  TkDND_DataObject *pDataObject = NULL;
  TkDND_DropSource *pDropSource = NULL;
  Tcl_Obj         **elem;
  DWORD             actions = 0;
  DWORD             dwEffect;
  DWORD             dwResult;
  int               status, elem_nu, i, index, nDataLength, button = 1;
  char             *ptr;
  Tcl_UniChar      *unicode, *ptr_u;
  FORMATETC        *m_pfmtetc;
  STGMEDIUM        *m_pstgmed;
  static const char *DropTypes[] = {
    "CF_UNICODETEXT", "CF_TEXT", "CF_HDROP",
    (char *) NULL
  };
  enum droptypes {
    TYPE_CF_UNICODETEXT, TYPE_CF_TEXT, TYPE_CF_HDROP
  };
  static const char *DropActions[] = {
    "copy", "move", "link", "ask",  "private", "refuse_drop",
    "default",
    (char *) NULL
  };
  enum dropactions {
    ActionCopy, ActionMove, ActionLink, ActionAsk, ActionPrivate,
    refuse_drop, ActionDefault
  };
  size_t buffer_size;

  if (objc != 5 && objc != 6) {
    Tcl_WrongNumArgs(interp, 1, objv, "path actions types data ?mouse-button?");
    return TCL_ERROR;
  }
  Tcl_ResetResult(interp);

  /* Get the mouse button. It must be one of 1, 2, or 3. */
  if (objc > 5) {
    status = Tcl_GetIntFromObj(interp, objv[5], &button);
    if (status != TCL_OK) return status;
    if (button < 1 || button > 3) {
      Tcl_SetResult(interp, "button must be either 1, 2, or 3", TCL_STATIC);
      return TCL_ERROR;
    }
  }

  /* Process drag actions. */
  status = Tcl_ListObjGetElements(interp, objv[2], &elem_nu, &elem);
  if (status != TCL_OK) return status;
  for (i = 0; i < elem_nu; i++) {
    status = Tcl_GetIndexFromObj(interp, elem[i], (const char **)DropActions,
                                 "dropactions", 0, &index);
    if (status != TCL_OK) return status;
    switch ((enum dropactions) index) {
      case ActionCopy:    actions |= DROPEFFECT_COPY; break;
      case ActionMove:    actions |= DROPEFFECT_MOVE; break;
      case ActionLink:    actions |= DROPEFFECT_LINK; break;
      case ActionAsk:     /* not supported */;        break;
      case ActionPrivate: actions |= DROPEFFECT_NONE; break;
      case ActionDefault: /* not supported */;        break;
      case refuse_drop:   /* not supported */;        break;
    }
  }

  /* Process drag types. */
  status = Tcl_ListObjGetElements(interp, objv[3], &elem_nu, &elem);
  if (status != TCL_OK) return status;
  m_pfmtetc  = new FORMATETC[elem_nu];
  if (m_pfmtetc == NULL) return TCL_ERROR;
  m_pstgmed  = new STGMEDIUM[elem_nu];
  if (m_pstgmed == NULL) {
    delete[] m_pfmtetc; return TCL_ERROR;
  }
  for (i = 0; i < elem_nu; i++) {
    m_pfmtetc[i].ptd            = 0;
    m_pfmtetc[i].dwAspect       = DVASPECT_CONTENT;
    m_pfmtetc[i].lindex         = -1;
    m_pfmtetc[i].tymed          = TYMED_HGLOBAL;
    m_pstgmed[i].tymed          = TYMED_HGLOBAL;
    m_pstgmed[i].pUnkForRelease = 0;
    status = Tcl_GetIndexFromObj(interp, elem[i], (const char **) DropTypes,
                                 "dropactions", 0, &index);
    if (status == TCL_OK) {
      switch ((enum droptypes) index) {
        case TYPE_CF_UNICODETEXT: {
          m_pfmtetc[i].cfFormat = CF_UNICODETEXT;
          unicode = Tcl_GetUnicodeFromObj(objv[4], &nDataLength);
          buffer_size = (nDataLength+1) * sizeof(Tcl_UniChar);
          m_pstgmed[i].hGlobal = GlobalAlloc(GHND, buffer_size);
          if (m_pstgmed[i].hGlobal) {
            ptr_u = (Tcl_UniChar *) GlobalLock(m_pstgmed[i].hGlobal);
#ifdef HAVE_STRSAFE_H
            StringCchCopyW((LPWSTR) ptr_u, buffer_size, (LPWSTR) unicode);
#else
            lstrcpyW((LPWSTR) ptr_u, (LPWSTR) unicode);
#endif
            GlobalUnlock(m_pstgmed[i].hGlobal);
          }
          break;
        }
        case TYPE_CF_TEXT: {
          m_pfmtetc[i].cfFormat = CF_TEXT;
          nDataLength = Tcl_GetCharLength(objv[4]);
          m_pstgmed[i].hGlobal = GlobalAlloc(GHND, nDataLength+1);
          if (m_pstgmed[i].hGlobal) {
            ptr = (char *) GlobalLock(m_pstgmed[i].hGlobal);
            memcpy(ptr, Tcl_GetString(objv[4]), nDataLength);
            ptr[nDataLength] = '\0';
            GlobalUnlock(m_pstgmed[i].hGlobal);
          }
          break;
        }
        case TYPE_CF_HDROP: {
          LPDROPFILES pDropFiles;
          Tcl_DString ds;
          Tcl_Obj **File, *native_files_obj = NULL, *obj;
          int file_nu, j, size, len;
          char *native_name;

          status = Tcl_ListObjGetElements(interp, objv[4], &file_nu, &File);
          if (status != TCL_OK) {elem_nu = i; goto error;}
          /* What we expect is a list of filenames. Convert the filenames into
           * the native format, and store the translated filenames into a new
           * list... */
          native_files_obj = Tcl_NewListObj(0, NULL);
          if (native_files_obj == NULL) {elem_nu = i; goto error;}
          size = 0;
          for (j = 0; j < file_nu; ++j) {
            Tcl_DStringInit(&ds);
            native_name = Tcl_TranslateFileName(NULL, 
                                                Tcl_GetString(File[j]), &ds);
            if (native_name == NULL) {
              Tcl_DStringFree(&ds);
              continue;
            }
            obj = Tcl_NewStringObj(native_name, -1);
            Tcl_ListObjAppendElement(NULL, native_files_obj, obj);
            /* Get the length in unicode... */
            Tcl_GetUnicodeFromObj(obj, &len);
            size += len + 1; // NULL character...
            Tcl_DStringFree(&ds);
          }

          buffer_size = sizeof(wchar_t) * (size+1);
          m_pfmtetc[i].cfFormat = CF_HDROP;
          m_pstgmed[i].hGlobal = GlobalAlloc(GHND, 
                   (DWORD) (sizeof(DROPFILES) + buffer_size));
          if (m_pstgmed[i].hGlobal) {
            TCHAR *CurPosition;
            pDropFiles = (LPDROPFILES) GlobalLock(m_pstgmed[i].hGlobal);
            // Set the offset where the starting point of the file start.
            pDropFiles->pFiles = sizeof(DROPFILES);
            // File contains wide characters?
            pDropFiles->fWide = TRUE;
            CurPosition = (TCHAR *) (LPBYTE(pDropFiles) + sizeof(DROPFILES)); 
            Tcl_ListObjGetElements(NULL, native_files_obj, &file_nu, &File);
            for (j = 0; j < file_nu; j++) {
              TCHAR *pszFileName = (TCHAR *)
                                   Tcl_GetUnicodeFromObj(File[j], &len);
              // Copy the file name into global memory.
#ifdef HAVE_STRSAFE_H
              StringCchCopyW(CurPosition, buffer_size, pszFileName);
#else
              lstrcpyW(CurPosition, pszFileName);
#endif
              /*
               * Move the current position beyond the file name copied, and
               * don't forget the NULL terminator (+1)
               */
              CurPosition += 1 + _tcschr(pszFileName, '\0') - pszFileName;
            }
            /*
             * Finally, add an additional null terminator, as per CF_HDROP
             * Format specs.
             */
            *CurPosition = '\0';
            GlobalUnlock(m_pstgmed[i].hGlobal);
          }
          if (native_files_obj) Tcl_DecrRefCount(native_files_obj);
          break;
        }
      }
    } else {
      unsigned char *bytes;
      /* A user defined type? */
      m_pfmtetc[i].cfFormat = RegisterClipboardFormat(TCL_GETSTRING(elem[i]));
      bytes = Tcl_GetByteArrayFromObj(objv[4], &nDataLength);
      m_pstgmed[i].hGlobal = GlobalAlloc(GHND, nDataLength);
      if (m_pstgmed[i].hGlobal) {
        ptr = (char *) GlobalLock(m_pstgmed[i].hGlobal);
        memcpy(ptr, bytes, nDataLength);
        GlobalUnlock(m_pstgmed[i].hGlobal);
      }
      break;
    }
  }; /* for (i = 0; i < elem_nu; i++) */
  
  pDataObject = new TkDND_DataObject(m_pfmtetc, m_pstgmed, elem_nu);
  if (pDataObject == NULL) {
    Tcl_SetResult(interp, "unable to create OLE Data object", TCL_STATIC);
    return TCL_ERROR;
  }
  
  pDropSource = new TkDND_DropSource(button);
  if (pDropSource == NULL) {
    pDataObject->Release();
    Tcl_SetResult(interp, "unable to create OLE Drop Source object",TCL_STATIC);
    return TCL_ERROR;
  }

  dwResult = DoDragDrop(pDataObject, pDropSource, actions, &dwEffect);
  // release the COM interfaces
  pDropSource->Release();
  pDataObject->Release();
  for (i = 0; i < elem_nu; i++) {
    ReleaseStgMedium(&m_pstgmed[i]);
  }
  delete[] m_pfmtetc;
  delete[] m_pstgmed;
  if (dwResult == DRAGDROP_S_DROP) {
    switch (dwEffect) {
      case DROPEFFECT_COPY: Tcl_SetResult(interp, "copy", TCL_STATIC); break;
      case DROPEFFECT_MOVE: Tcl_SetResult(interp, "move", TCL_STATIC); break;
      case DROPEFFECT_LINK: Tcl_SetResult(interp, "link", TCL_STATIC); break;
    }
  } else {
    Tcl_SetResult(interp, "refuse_drop", TCL_STATIC);
  }
  return TCL_OK;
error:
  // release the COM interfaces
  if (pDropSource) pDropSource->Release();
  if (pDataObject) pDataObject->Release();
  for (i = 0; i < elem_nu; i++) {
    ReleaseStgMedium(&m_pstgmed[i]);
  }
  delete[] m_pfmtetc;
  delete[] m_pstgmed;
  return TCL_ERROR;
}; /* TkDND_DoDragDropObjCmd */

/*
 * For C++ compilers, use extern "C"
 */
#ifdef __cplusplus
extern "C" {
#endif
DLLEXPORT int Tkdnd_Init(Tcl_Interp *interp);
DLLEXPORT int Tkdnd_SafeInit(Tcl_Interp *interp);
#ifdef __cplusplus
}
#endif

int DLLEXPORT Tkdnd_Init(Tcl_Interp *interp) {
  int major, minor, patchlevel;
  HRESULT hret;

  if (
#ifdef USE_TCL_STUBS 
      Tcl_InitStubs(interp, "8.3", 0)
#else
      Tcl_PkgRequire(interp, "Tcl", "8.3", 0)
#endif /* USE_TCL_STUBS */
            == NULL) {
            return TCL_ERROR;
  }
  if (
#ifdef USE_TK_STUBS
       Tk_InitStubs(interp, "8.3", 0)
#else
       Tcl_PkgRequire(interp, "Tk", "8.3", 0)
#endif /* USE_TK_STUBS */
            == NULL) {
            return TCL_ERROR;
  }

  /*
   * Get the version, because we really need 8.3.3+.
   */
  Tcl_GetVersion(&major, &minor, &patchlevel, NULL);
  if ((major == 8) && (minor == 3) && (patchlevel < 3)) {
    Tcl_SetResult(interp, "tkdnd requires Tk 8.3.3 or greater", TCL_STATIC);
    return TCL_ERROR;
  }

  /*
   * Initialise OLE.
   */
  hret = OleInitialize(NULL);
  
  /*
   * If OleInitialize returns S_FALSE, OLE has already been initialized
   */
  if (hret != S_OK && hret != S_FALSE) {
    Tcl_AppendResult(interp, "unable to initialize OLE2",
      (char *) NULL);
    return TCL_ERROR;
  }

  /* Register the various commands */
  if (Tcl_CreateObjCommand(interp, "_RegisterDragDrop",
           (Tcl_ObjCmdProc*) TkDND_RegisterDragDropObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
      return TCL_ERROR;
  }
  if (Tcl_CreateObjCommand(interp, "_RevokeDragDrop",
           (Tcl_ObjCmdProc*) TkDND_RevokeDragDropObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
      return TCL_ERROR;
  }

  if (Tcl_CreateObjCommand(interp, "_DoDragDrop",
           (Tcl_ObjCmdProc*) TkDND_DoDragDropObjCmd,
           (ClientData) NULL, (Tcl_CmdDeleteProc *) NULL) == NULL) {
      return TCL_ERROR;
  }

  Tcl_PkgProvide(interp, PACKAGE_NAME, PACKAGE_VERSION);
  return TCL_OK;
} /* Tkdnd_Init */

int DLLEXPORT Tkdnd_SafeInit(Tcl_Interp *interp) {
  return Tkdnd_Init(interp);
} /* Tkdnd_SafeInit */
blob
data 377
SET(tkdnd_ignore_files
Changelog
cmake
configure.in
demos
doc
license.terms
unix/tkUnixSelect.c
unix/TkDND_XDND.c
unix/Cursors.c
library/tkdnd.tcl
library/tkdnd_compat.tcl
library/tkdnd_macosx.tcl
library/tkdnd_unix.tcl
library/tkdnd_windows.tcl
macosx/macdnd.m
tclconfig/ChangeLog
tclconfig/README.txt
tclconfig/install-sh
tclconfig/tcl.m4
win/OleDND.h
win/TkDND_OleDND.cpp
)
blob
data 349
SET(tktreectrl_ignore_files
ChangeLog
CMake
aclocal.m4
configure
configure.ac
demos
doc
generic/qebind.h
generic/tkTreeCtrl.h
generic/tkTreeElem.h
library/filelist-bindings.tcl
library/treectrl.tcl
license.terms
macosx/tkMacOSXTree.c
pkg.m4
shellicon
tclconfig
tests
treectrl.dll.manifest.in
treectrl.rc
unix/tkUnixTree.c
win/tkWinTree.c
winrc.m4
)
