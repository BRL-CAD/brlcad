blob
data 7687
# build shared libs by default
IF(NOT DEFINED BUILD_SHARED_LIBS)
  set(BUILD_SHARED_LIBS ON)
ENDIF(NOT DEFINED BUILD_SHARED_LIBS)

# build static libs by default
IF(NOT DEFINED BUILD_STATIC_LIBS)
  set(BUILD_STATIC_LIBS ON)
ENDIF(NOT DEFINED BUILD_STATIC_LIBS)

# these are files no longer in opennurbs but retained for reference
set(OPENNURBS_REF
opennurbs_basic.cpp
opennurbs_brep_changesrf.cpp
opennurbs_brep_kinky.cpp
opennurbs_x.cpp
)

# these are files we turn off because we don't use them and they incur
# some cost to enable (e.g., they require OpenGL)
set(OPENNURBS_OFF
opennurbs_gl.cpp
opennurbs_gl.h
opennurbs_precompiledheader.cpp
opennurbs_zlib_memory.cpp
opennurbs_x.h
)

set(OPENNURBS_SOURCES
${OPENNURBS_REF}
opennurbs_3dm_attributes.cpp
opennurbs_3dm_properties.cpp
opennurbs_3dm_settings.cpp
opennurbs_annotation.cpp
opennurbs_annotation2.cpp
opennurbs_arc.cpp
opennurbs_arccurve.cpp
opennurbs_archive.cpp
opennurbs_array.cpp
opennurbs_base32.cpp
opennurbs_base64.cpp
opennurbs_beam.cpp
opennurbs_bezier.cpp
opennurbs_beziervolume.cpp
opennurbs_bitmap.cpp
opennurbs_bounding_box.cpp
opennurbs_box.cpp
opennurbs_brep.cpp
opennurbs_brep_extrude.cpp
opennurbs_brep_io.cpp
opennurbs_brep_isvalid.cpp
opennurbs_brep_region.cpp
opennurbs_brep_tools.cpp
opennurbs_brep_v2valid.cpp
opennurbs_circle.cpp
opennurbs_color.cpp
opennurbs_compress.cpp
opennurbs_cone.cpp
opennurbs_crc.cpp
opennurbs_curve.cpp
opennurbs_curveonsurface.cpp
opennurbs_curveproxy.cpp
opennurbs_cylinder.cpp
opennurbs_defines.cpp
opennurbs_detail.cpp
opennurbs_dimstyle.cpp
opennurbs_dll.cpp
opennurbs_ellipse.cpp
opennurbs_embedded_file.cpp
opennurbs_error.cpp
opennurbs_error_message.cpp
opennurbs_evaluate_nurbs.cpp
opennurbs_extensions.cpp
opennurbs_font.cpp
opennurbs_fsp.cpp
opennurbs_geometry.cpp
opennurbs_group.cpp
opennurbs_hatch.cpp
opennurbs_instance.cpp
opennurbs_intersect.cpp
opennurbs_knot.cpp
opennurbs_layer.cpp
opennurbs_light.cpp
opennurbs_line.cpp
opennurbs_linecurve.cpp
opennurbs_linetype.cpp
opennurbs_lookup.cpp
opennurbs_material.cpp
opennurbs_math.cpp
opennurbs_massprop.cpp
opennurbs_matrix.cpp
opennurbs_memory.c
opennurbs_memory_util.c
opennurbs_mesh.cpp
opennurbs_mesh_ngon.cpp
opennurbs_mesh_tools.cpp
opennurbs_morph.cpp
opennurbs_nurbscurve.cpp
opennurbs_nurbssurface.cpp
opennurbs_nurbsvolume.cpp
opennurbs_object.cpp
opennurbs_object_history.cpp
opennurbs_objref.cpp
opennurbs_offsetsurface.cpp
opennurbs_optimize.cpp
opennurbs_plane.cpp
opennurbs_planesurface.cpp
opennurbs_pluginlist.cpp
opennurbs_point.cpp
opennurbs_pointcloud.cpp
opennurbs_pointgeometry.cpp
opennurbs_pointgrid.cpp
opennurbs_polycurve.cpp
opennurbs_polyedgecurve.cpp
opennurbs_polyline.cpp
opennurbs_polylinecurve.cpp
opennurbs_rand.cpp
opennurbs_revsurface.cpp
opennurbs_rtree.cpp
opennurbs_sort.cpp
opennurbs_sphere.cpp
opennurbs_string.cpp
opennurbs_sum.cpp
opennurbs_sumsurface.cpp
opennurbs_surface.cpp
opennurbs_surfaceproxy.cpp
opennurbs_textlog.cpp
opennurbs_torus.cpp
opennurbs_unicode.cpp
opennurbs_userdata.cpp
opennurbs_uuid.cpp
opennurbs_viewport.cpp
opennurbs_workspace.cpp
opennurbs_wstring.cpp
opennurbs_xform.cpp
opennurbs_zlib.cpp
  )

SET(OPENNURBS_HEADERS
opennurbs.h
opennurbs_3dm.h
opennurbs_3dm_attributes.h
opennurbs_3dm_properties.h
opennurbs_3dm_settings.h
opennurbs_annotation.h
opennurbs_annotation2.h
opennurbs_arc.h
opennurbs_arccurve.h
opennurbs_archive.h
opennurbs_array.h
opennurbs_array_defs.h
opennurbs_base32.h
opennurbs_base64.h
opennurbs_beam.h
opennurbs_bezier.h
opennurbs_bitmap.h
opennurbs_bounding_box.h
opennurbs_box.h
opennurbs_brep.h
opennurbs_circle.h
opennurbs_color.h
opennurbs_compress.h
opennurbs_cone.h
opennurbs_crc.h
opennurbs_curve.h
opennurbs_curveonsurface.h
opennurbs_curveproxy.h
opennurbs_cylinder.h
opennurbs_defines.h
opennurbs_detail.h
opennurbs_dimstyle.h
opennurbs_dll_resource.h
opennurbs_ellipse.h
opennurbs_error.h
opennurbs_evaluate_nurbs.h
opennurbs_extensions.h
opennurbs_font.h
opennurbs_fpoint.h
opennurbs_fsp.h
opennurbs_fsp_defs.h
opennurbs_geometry.h
opennurbs_group.h
opennurbs_hatch.h
opennurbs_hsort_template.h
opennurbs_instance.h
opennurbs_intersect.h
opennurbs_knot.h
opennurbs_layer.h
opennurbs_light.h
opennurbs_line.h
opennurbs_linecurve.h
opennurbs_linestyle.h
opennurbs_linetype.h
opennurbs_lookup.h
opennurbs_mapchan.h
opennurbs_massprop.h
opennurbs_material.h
opennurbs_math.h
opennurbs_matrix.h
opennurbs_memory.h
opennurbs_mesh.h
opennurbs_nurbscurve.h
opennurbs_nurbssurface.h
opennurbs_object.h
opennurbs_object_history.h
opennurbs_objref.h
opennurbs_offsetsurface.h
opennurbs_optimize.h
opennurbs_plane.h
opennurbs_planesurface.h
opennurbs_pluginlist.h
opennurbs_point.h
opennurbs_pointcloud.h
opennurbs_pointgeometry.h
opennurbs_pointgrid.h
opennurbs_polycurve.h
opennurbs_polyedgecurve.h
opennurbs_polyline.h
opennurbs_polylinecurve.h
opennurbs_qsort_template.h
opennurbs_rand.h
opennurbs_rendering.h
opennurbs_revsurface.h
opennurbs_rtree.h
opennurbs_sphere.h
opennurbs_string.h
opennurbs_sumsurface.h
opennurbs_surface.h
opennurbs_surfaceproxy.h
opennurbs_system.h
opennurbs_textlog.h
opennurbs_texture.h
opennurbs_texture_mapping.h
opennurbs_torus.h
opennurbs_unicode.h
opennurbs_userdata.h
opennurbs_uuid.h
opennurbs_version.h
opennurbs_viewport.h
opennurbs_workspace.h
opennurbs_x.h
opennurbs_xform.h
opennurbs_zlib.h
  )


INCLUDE(CheckIncludeFiles)
CHECK_INCLUDE_FILE(emmintrin.h HAVE_EMMINTRIN_H)
CHECK_INCLUDE_FILE(ieeefp.h HAVE_IEEEFP_H)
CHECK_INCLUDE_FILE(sys/stat.h HAVE_SYS_STAT_H)
if(HAVE_EMMINTRIN_H)
  add_definitions(-DHAVE_EMMINTRIN_H)
endif(HAVE_EMMINTRIN_H)
if(HAVE_IEEEFP_H)
  add_definitions(-DHAVE_IEEEFP_H)
endif(HAVE_IEEEFP_H)
if(HAVE_SYS_STAT_H)
  add_definitions(-DHAVE_SYS_STAT_H)
endif(HAVE_SYS_STAT_H)

IF(BUILD_STATIC_LIBS AND BRLCAD_ENABLE_BRLCAD_LIBRARY AND ${CMAKE_PROJECT_NAME}_ZLIB_BUILD AND NOT ${CMAKE_PROJECT_NAME}-ENABLE_SYSTEM_LIBS_ONLY)
  set(OPENNURBS_LINKLIBRARIES
    zlib-static
    )
ELSE(BUILD_STATIC_LIBS AND BRLCAD_ENABLE_BRLCAD_LIBRARY AND ${CMAKE_PROJECT_NAME}_ZLIB_BUILD AND NOT ${CMAKE_PROJECT_NAME}-ENABLE_SYSTEM_LIBS_ONLY)
  set(OPENNURBS_LINKLIBRARIES
    ${ZLIB_LIBRARY}
    )
ENDIF(BUILD_STATIC_LIBS AND BRLCAD_ENABLE_BRLCAD_LIBRARY AND ${CMAKE_PROJECT_NAME}_ZLIB_BUILD AND NOT ${CMAKE_PROJECT_NAME}-ENABLE_SYSTEM_LIBS_ONLY)

# Ideally, we should only need ZLIB here
include_directories(
  ${${CMAKE_PROJECT_NAME}_SOURCE_DIR}/include
  ${ZLIB_INCLUDE_DIR}
  )

if (MSVC)
  add_definitions(
    -DON_COMPILING_OPENNURBS
    -DON_DLL_EXPORTS
    )
else (MSVC)
  add_definitions(
    -DON_COMPILING_OPENNURBS
    )
endif(MSVC)


if(MSVC)
  add_definitions(
    -DUNICODE
    )

  set(OPENNURBS_LINKLIBRARIES
    ${OPENNURBS_LINKLIBRARIES}
    Rpcrt4
    )
endif(MSVC)

IF(BUILD_SHARED_LIBS)
  add_library(openNURBS SHARED ${OPENNURBS_SOURCES})
  target_link_libraries(openNURBS ${OPENNURBS_LINKLIBRARIES})
  set_property(TARGET openNURBS PROPERTY LINK_INTERFACE_LIBRARIES "")
  SET_TARGET_PROPERTIES(openNURBS PROPERTIES VERSION "2010.04.95")
  install(TARGETS openNURBS
	  RUNTIME DESTINATION ${BIN_DIR}
	  LIBRARY DESTINATION ${LIB_DIR}
	  ARCHIVE DESTINATION ${LIB_DIR})
ENDIF(BUILD_SHARED_LIBS)
IF(NOT MSVC)
  IF(BUILD_STATIC_LIBS)
    add_library(openNURBS-static STATIC ${OPENNURBS_SOURCES})
    target_link_libraries(openNURBS-static ${OPENNURBS_LINKLIBRARIES})
    IF(NOT WIN32)
      SET_TARGET_PROPERTIES(openNURBS-static PROPERTIES OUTPUT_NAME "openNURBS")
    ENDIF(NOT WIN32)
    install(TARGETS openNURBS-static
	    RUNTIME DESTINATION ${BIN_DIR}
	    LIBRARY DESTINATION ${LIB_DIR}
	    ARCHIVE DESTINATION ${LIB_DIR})
  ENDIF(BUILD_STATIC_LIBS)
ENDIF(NOT MSVC)

install(FILES ${OPENNURBS_HEADERS} DESTINATION include/openNURBS)
blob
data 6212

lib_LTLIBRARIES = libopenNURBS.la
noinst_LTLIBRARIES = libopenNURBS_nil.la

ON_INC = \
	opennurbs.h \
	opennurbs_3dm.h \
	opennurbs_3dm_attributes.h \
	opennurbs_3dm_properties.h \
	opennurbs_3dm_settings.h \
	opennurbs_annotation.h \
	opennurbs_annotation2.h \
	opennurbs_arc.h \
	opennurbs_arccurve.h \
	opennurbs_archive.h \
	opennurbs_array.h \
	opennurbs_array_defs.h \
	opennurbs_base32.h \
	opennurbs_base64.h \
	opennurbs_beam.h \
	opennurbs_bezier.h \
	opennurbs_bitmap.h \
	opennurbs_bounding_box.h \
	opennurbs_box.h \
	opennurbs_brep.h \
	opennurbs_circle.h \
	opennurbs_color.h \
	opennurbs_compress.h \
	opennurbs_cone.h \
	opennurbs_crc.h \
	opennurbs_curve.h \
	opennurbs_curveonsurface.h \
	opennurbs_curveproxy.h \
	opennurbs_cylinder.h \
	opennurbs_defines.h \
	opennurbs_detail.h \
	opennurbs_dimstyle.h \
	opennurbs_ellipse.h \
	opennurbs_error.h \
	opennurbs_evaluate_nurbs.h \
	opennurbs_extensions.h \
	opennurbs_font.h \
	opennurbs_fpoint.h \
	opennurbs_fsp.h \
	opennurbs_fsp_defs.h \
	opennurbs_geometry.h \
	opennurbs_group.h \
	opennurbs_hatch.h \
	opennurbs_hsort_template.h \
	opennurbs_instance.h \
	opennurbs_intersect.h \
	opennurbs_knot.h \
	opennurbs_layer.h \
	opennurbs_light.h \
	opennurbs_line.h \
	opennurbs_linecurve.h \
	opennurbs_linestyle.h \
	opennurbs_linetype.h \
	opennurbs_lookup.h \
	opennurbs_mapchan.h \
	opennurbs_massprop.h \
	opennurbs_material.h \
	opennurbs_math.h \
	opennurbs_matrix.h \
	opennurbs_mesh.h \
	opennurbs_nurbscurve.h \
	opennurbs_nurbssurface.h \
	opennurbs_object.h \
	opennurbs_object_history.h \
	opennurbs_objref.h \
	opennurbs_offsetsurface.h \
	opennurbs_optimize.h \
	opennurbs_plane.h \
	opennurbs_planesurface.h \
	opennurbs_pluginlist.h \
	opennurbs_point.h \
	opennurbs_pointcloud.h \
	opennurbs_pointgeometry.h \
	opennurbs_pointgrid.h \
	opennurbs_polycurve.h \
	opennurbs_polyedgecurve.h \
	opennurbs_polyline.h \
	opennurbs_polylinecurve.h \
	opennurbs_qsort_template.h \
	opennurbs_rand.h \
	opennurbs_rendering.h \
	opennurbs_revsurface.h \
	opennurbs_rtree.h \
	opennurbs_sphere.h \
	opennurbs_string.h \
	opennurbs_sumsurface.h \
	opennurbs_surface.h \
	opennurbs_surfaceproxy.h \
	opennurbs_system.h \
	opennurbs_textlog.h \
	opennurbs_texture.h \
	opennurbs_texture_mapping.h \
	opennurbs_torus.h \
	opennurbs_unicode.h \
	opennurbs_userdata.h \
	opennurbs_uuid.h \
	opennurbs_version.h \
	opennurbs_viewport.h \
	opennurbs_workspace.h \
	opennurbs_x.h \
	opennurbs_xform.h \
	opennurbs_zlib.h

ON_SRC = \
	opennurbs_3dm_attributes.cpp \
	opennurbs_3dm_properties.cpp \
	opennurbs_3dm_settings.cpp \
	opennurbs_annotation.cpp \
	opennurbs_annotation2.cpp \
	opennurbs_arc.cpp \
	opennurbs_arccurve.cpp \
	opennurbs_archive.cpp \
	opennurbs_array.cpp \
	opennurbs_base32.cpp \
	opennurbs_base64.cpp \
	opennurbs_basic.cpp \
	opennurbs_beam.cpp \
	opennurbs_bezier.cpp \
	opennurbs_beziervolume.cpp \
	opennurbs_bitmap.cpp \
	opennurbs_bounding_box.cpp \
	opennurbs_box.cpp \
	opennurbs_brep.cpp \
	opennurbs_brep_extrude.cpp \
	opennurbs_brep_io.cpp \
	opennurbs_brep_isvalid.cpp \
	opennurbs_brep_region.cpp \
	opennurbs_brep_tools.cpp \
	opennurbs_brep_v2valid.cpp \
	opennurbs_circle.cpp \
	opennurbs_color.cpp \
	opennurbs_compress.cpp \
	opennurbs_cone.cpp \
	opennurbs_crc.cpp \
	opennurbs_curve.cpp \
	opennurbs_curveonsurface.cpp \
	opennurbs_curveproxy.cpp \
	opennurbs_cylinder.cpp \
	opennurbs_defines.cpp \
	opennurbs_detail.cpp \
	opennurbs_dimstyle.cpp \
	opennurbs_dll.cpp \
	opennurbs_ellipse.cpp \
	opennurbs_embedded_file.cpp \
	opennurbs_error.cpp \
	opennurbs_error_message.cpp \
	opennurbs_evaluate_nurbs.cpp \
	opennurbs_extensions.cpp \
	opennurbs_font.cpp \
	opennurbs_fsp.cpp \
	opennurbs_geometry.cpp \
	opennurbs_group.cpp \
	opennurbs_hatch.cpp \
	opennurbs_instance.cpp \
	opennurbs_intersect.cpp \
	opennurbs_knot.cpp \
	opennurbs_layer.cpp \
	opennurbs_light.cpp \
	opennurbs_line.cpp \
	opennurbs_linecurve.cpp \
	opennurbs_linetype.cpp \
	opennurbs_lookup.cpp \
	opennurbs_massprop.cpp \
	opennurbs_material.cpp \
	opennurbs_math.cpp \
	opennurbs_matrix.cpp \
	opennurbs_memory.c \
	opennurbs_memory_util.c \
	opennurbs_mesh.cpp \
	opennurbs_mesh_ngon.cpp \
	opennurbs_mesh_tools.cpp \
	opennurbs_morph.cpp \
	opennurbs_nurbscurve.cpp \
	opennurbs_nurbssurface.cpp \
	opennurbs_nurbsvolume.cpp \
	opennurbs_object.cpp \
	opennurbs_object_history.cpp \
	opennurbs_objref.cpp \
	opennurbs_offsetsurface.cpp \
	opennurbs_optimize.cpp \
	opennurbs_plane.cpp \
	opennurbs_planesurface.cpp \
	opennurbs_pluginlist.cpp \
	opennurbs_point.cpp \
	opennurbs_pointcloud.cpp \
	opennurbs_pointgeometry.cpp \
	opennurbs_pointgrid.cpp \
	opennurbs_polycurve.cpp \
	opennurbs_polyedgecurve.cpp \
	opennurbs_polyline.cpp \
	opennurbs_polylinecurve.cpp \
	opennurbs_rand.cpp \
	opennurbs_revsurface.cpp \
	opennurbs_rtree.cpp \
	opennurbs_sort.cpp \
	opennurbs_sphere.cpp \
	opennurbs_string.cpp \
	opennurbs_sum.cpp \
	opennurbs_sumsurface.cpp \
	opennurbs_surface.cpp \
	opennurbs_surfaceproxy.cpp \
	opennurbs_textlog.cpp \
	opennurbs_torus.cpp \
	opennurbs_unicode.cpp \
	opennurbs_userdata.cpp \
	opennurbs_uuid.cpp \
	opennurbs_viewport.cpp \
	opennurbs_workspace.cpp \
	opennurbs_wstring.cpp \
	opennurbs_x.cpp \
	opennurbs_xform.cpp \
	opennurbs_zlib.cpp

nurbincludedir = $(includedir)/openNURBS
nurbinclude_HEADERS = $(ON_INC)

libopenNURBS_nil_la_SOURCES = $(ON_SRC)
libopenNURBS_nil_la_CFLAGS = ${LIBZ_CPPFLAGS} ${NOWARN}
libopenNURBS_nil_la_CXXFLAGS = ${LIBZ_CPPFLAGS} ${NOWARN}
libopenNURBS_nil_la_LIBADD = ${LIBZ}

libopenNURBS_la_SOURCES =
libopenNURBS_la_LIBADD = libopenNURBS_nil.la

ON_EXTRA = \
	opennurbs.rc \
	opennurbs_basic.cpp \
	opennurbs_brep_changesrf.cpp \
	opennurbs_brep_kinky.cpp \
	opennurbs_gl.cpp \
	opennurbs_precompiledheader.cpp \
	opennurbs_zlib_memory.cpp

EXTRA_DIST = \
	${ON_EXTRA} \
	example_brep \
	example_gl \
	example_read \
	example_roundtrip \
	example_userdata \
	example_write \
	examples_linking_pragmas.h \
	BRL-CAD_changes.txt \
	faq.txt \
	license.txt \
	opennurbs_dll_resource.h \
	opennurbs_gl.h \
	readme.txt \
        CMakeLists.txt

if BUILD_ZLIB
DEPADD = src/other/libz
endif
DEPENDS = ${DEPADD}

include $(top_srcdir)/misc/Makefile.defs

blob
data 22980
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2011 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

// uncomment the "ON_DLL_IMPORTS" define to use opennurbs as a Windows DLL
//#define ON_DLL_IMPORTS
#include "../opennurbs.h"
#include "../examples_linking_pragmas.h"

// This example demonstrates two things:
//
// 1) How to dig through a ON_Brep face  and get at the surface
//    and trimming information.  See TraverseBrepFace() for
//    details.
//
// 2) How to write an OpenNURBS B-rep.  See MakeTwistedCube() for details.

void TraverseBrepFace( 
       const ON_Brep& brep,
       int fi,                  // brep face index
       ON_TextLog& error_log
       )
{
  if ( fi < 0 || fi >= brep.m_F.Count() ) 
  {
    error_log.Print("Invalid face index\n");
    return;
  }

  const ON_BrepFace& face = brep.m_F[fi];

  // pSrf = underlying untrimmed surface
  const ON_Surface* pSrf = NULL;
  if ( face.m_si < 0 || face.m_si >= brep.m_S.Count() )
    error_log.Print("ERROR: invalid brep.m_F[%d].m_si\n", fi );
  else {
    pSrf = brep.m_S[face.m_si];
    if ( !pSrf )
      error_log.Print("ERROR: invalid brep.m_S[%d] is NULL\n", face.m_si );
  }

  // The face is trimmed with one or more trimming loops.
  //
  // All the 2d trimming curves are oriented so that the
  // active region of the trimmed surface lies to the left
  // of the 2d trimming curve.  
  //
  // If face.m_bRev is true, the orientations of the face in
  // the b-rep is opposited the natural parameteric orientation
  // of the surface.

  // loop_count = number of trimming loops on this face (>=1)
  const int loop_count = face.m_li.Count(); 

  int fli; // face's loop index
  for ( fli = 0; fli < loop_count; fli++ ) {
    const int li = face.m_li[fli]; // li = brep loop index
    const ON_BrepLoop& loop = brep.m_L[li];

    // loop_edge_count = number of trimming edges in this loop
    const int loop_trim_count = loop.m_ti.Count();

    int lti; // loop's trim index
    for ( lti = 0; lti < loop_trim_count; lti++ ) {
      const int ti = loop.m_ti[lti]; // ti = brep trim index
      const ON_BrepTrim& trim = brep.m_T[ti];

      //////////////////////////////////////////////////////
      // 2d trimming information
      //
      // Each trim has a 2d parameter space curve.
      const ON_Curve* p2dCurve = NULL;
      const int c2i = trim.m_c2i; // c2i = brep 2d curve index
      if ( c2i < 0 || c2i >= brep.m_C2.Count() ) {
        error_log.Print("ERROR: invalid brep.m_T[%d].m_c2i\n", ti );
      }
      else {
        p2dCurve = brep.m_C2[c2i];
        if ( !p2dCurve )
          error_log.Print("ERROR: invalid brep.m_C2[%d] is NULL\n", c2i );
      }


      //////////////////////////////////////////////////////
      // topology and 3d geometry information
      //

      // Trim starts at v0 and ends at v1.  When the trim
      // is a loop or on a singular surface side, v0i and v1i
      // will be equal.
      //const int v0i = trim.m_vi[0]; // v0i = brep vertex index
      //const int v1i = trim.m_vi[1]; // v1i = brep vertex index
      //const ON_BrepVertex& v0 = brep.m_V[v0i];
      //const ON_BrepVertex& v1 = brep.m_V[v1i];
      // The vX.m_ei[] array contains the brep.m_E[] indices of
      // the edges that begin or end at vX.
      
      const int ei = trim.m_ei;
      if ( ei == -1 ) {
        // This trim lies on a portion of a singular surface side.
        // The vertex indices are still valid and will be equal.
      }
      else {
        // If trim.m_bRev3d is false, the orientations of the 3d edge
        // and the 3d curve obtained by composing the surface and 2d
        // curve agree.
        //
        // If trim.m_bRev3d is true, the orientations of the 3d edge
        // and the 3d curve obtained by composing the surface and 2d
        // curve are opposite.
        const ON_BrepEdge& edge = brep.m_E[ei];
        const int c3i = edge.m_c3i;
        const ON_Curve* p3dCurve = NULL;

        if ( c3i < 0 || c3i >= brep.m_C3.Count() ) {
          error_log.Print("ERROR: invalid brep.m_E[%d].m_c3i\n", ei );
        }
        else {
          p3dCurve = brep.m_C3[c3i];
          if ( !p3dCurve )
            error_log.Print("ERROR: invalid brep.m_C3[%d] is NULL\n", c3i );
        }

        // The edge.m_ti[] array contains the brep.m_T[] indices
        // for the other trims that are joined to this edge.
      }
    }
  }
}

// symbolic vertex index constants to make code more readable
static const int 
  A = 0,
  B = 1,
  C = 2,
  D = 3,
  E = 4,
  F = 5,
  G = 6,
  H = 7;

// symbolic edge index constants to make code more readable
static const int
  AB =  0,
  BC =  1,
  CD =  2,
  AD =  3,
  EF =  4,
  FG =  5,
  GH =  6,
  EH =  7,
  AE =  8,
  BF =  9,
  CG = 10,
  DH = 11;

// symbolic face index constants to make code more readable
static const int
  ABCD =  0,
  BCGF =  1,
  CDHG =  2,
  ADHE =  3,
  ABFE =  4,
  EFGH =  5;

static ON_Curve* TwistedCubeTrimmingCurve(
              const ON_Surface& s,
              int side // 0 = SW to SE
                       // 1 = SE to NE
                       // 2 = NE to NW
                       // 3 = NW to SW
              )
{
  // A trimming curve is a 2d curve whose image lies in the surface's domain.
  // The "active" portion of the surface is to the left of the trimming curve.
  // An outer trimming loop consists of a simple closed curve running 
  // counter-clockwise around the region it trims.

  ON_2dPoint from, to;
  double u0, u1, v0, v1;

  s.GetDomain( 0, &u0, &u1 );
  s.GetDomain( 1, &v0, &v1 );

  switch ( side ) {
  case 0:  // SW to SE
    from.x = u0; from.y = v0;
    to.x   = u1; to.y   = v0;
    break;
  case 1: // SE to NE
    from.x = u1; from.y = v0;
    to.x   = u1; to.y   = v1;
    break;
  case 2: // NE to NW
    from.x = u1; from.y = v1;
    to.x   = u0; to.y   = v1;
    break;
  case 3: // NW to SW
    from.x = u0; from.y = v1;
    to.x   = u0; to.y   = v0;
    break;
  default:
    return 0;
  }

  ON_Curve* c2d = new ON_LineCurve( from, to );
  c2d->SetDomain(0.0,1.0);

  return c2d;
}


static ON_Curve* TwistedCubeEdgeCurve( const ON_3dPoint& from, const ON_3dPoint& to )
{
  // creates a 3d line segment to be used as a 3d curve in a ON_Brep
  ON_Curve* c3d = new ON_LineCurve( from, to );
  c3d->SetDomain( 0.0, 1.0 );
  return c3d;
}

static ON_Surface* TwistedCubeSideSurface( 
                             const ON_3dPoint& SW, const ON_3dPoint& SE,
                             const ON_3dPoint& NE, const ON_3dPoint& NW
                             )
{
  ON_NurbsSurface* pNurbsSurface = new ON_NurbsSurface(
                                        3,     // dimension
                                        false, // not rational
                                        2,     // "u" order
                                        2,     // "v" order
                                        2,     // number of control vertices in "u" dir
                                        2      // number of control vertices in "v" dir
                                        );
  // corner CVs in counter clockwise order starting in the south west
  pNurbsSurface->SetCV( 0,0, SW );
  pNurbsSurface->SetCV( 1,0, SE );
  pNurbsSurface->SetCV( 1,1, NE );
  pNurbsSurface->SetCV( 0,1, NW );
  // "u" knots
  pNurbsSurface->SetKnot( 0,0, 0.0 );
  pNurbsSurface->SetKnot( 0,1, 1.0 );
  // "v" knots
  pNurbsSurface->SetKnot( 1,0, 0.0 );
  pNurbsSurface->SetKnot( 1,1, 1.0 );

  return pNurbsSurface;
}

static void MakeTwistedCubeEdge( ON_Brep& brep,
                                 int vi0, // index of start vertex
                                 int vi1, // index of end vertex
                                 int c3i  // index of 3d curve
                                 )
{
  ON_BrepVertex& v0 = brep.m_V[vi0];
  ON_BrepVertex& v1 = brep.m_V[vi1];
  ON_BrepEdge& edge = brep.NewEdge(v0,v1,c3i);
  edge.m_tolerance = 0.0;  // this simple example is exact - for models with
                           // non-exact data, set tolerance as explained in
                           // definition of ON_BrepEdge.
}

static void MakeTwistedCubeEdges( ON_Brep& brep )
{

  // In this simple example, the edge indices exactly match the 3d
  // curve indices.  In general,the correspondence between edge and
  // curve indices can be arbitrary.  It is permitted for multiple
  // edges to use different portions of the same 3d curve.  The 
  // orientation of the edge always agrees with the natural 
  // parametric orientation of the curve.
  
  // edge that runs from A to B
  MakeTwistedCubeEdge( brep, A, B, AB );
  
  // edge that runs from B to C
  MakeTwistedCubeEdge( brep, B, C, BC );

  // edge that runs from C to D
  MakeTwistedCubeEdge( brep, C, D, CD );

  // edge that runs from A to D
  MakeTwistedCubeEdge( brep, A, D, AD );

  // edge that runs from E to F
  MakeTwistedCubeEdge( brep, E, F, EF );

  // edge that runs from F to G
  MakeTwistedCubeEdge( brep, F, G, FG );

  // edge that runs from G to H
  MakeTwistedCubeEdge( brep, G, H, GH );

  // edge that runs from E to H
  MakeTwistedCubeEdge( brep, E, H, EH );

  // edge that runs from A to E
  MakeTwistedCubeEdge( brep, A, E, AE );

  // edge that runs from B to F
  MakeTwistedCubeEdge( brep, B, F, BF );

  // edge that runs from C to G
  MakeTwistedCubeEdge( brep, C, G, CG );

  // edge that runs from D to H
  MakeTwistedCubeEdge( brep, D, H, DH );
}

static int MakeTwistedCubeTrimmingLoop(  ON_Brep& brep, // returns index of loop
     ON_BrepFace& face,  // face loop is on
     //int vSWi, int vSEi, int vNEi, int vNWi, // Indices of corner vertices listed in SW,SE,NW,NE order
     int eSi,     // index of edge on south side of surface
     int eS_dir,  // orientation of edge with respect to surface trim
     int eEi,     // index of edge on south side of surface
     int eE_dir,  // orientation of edge with respect to surface trim
     int eNi,     // index of edge on south side of surface
     int eN_dir,  // orientation of edge with respect to surface trim
     int eWi,     // index of edge on south side of surface
     int eW_dir   // orientation of edge with respect to surface trim
                                )
{
  const ON_Surface& srf = *brep.m_S[face.m_si];

  ON_BrepLoop& loop = brep.NewLoop( ON_BrepLoop::outer, face );

  // Create trimming curves running counter clockwise around the surface's domain.
  // Start at the south side
  ON_Curve* c2;
  int c2i, ei=0, bRev3d=0;
  ON_2dPoint q;
  ON_Surface::ISO iso = ON_Surface::not_iso;

  for ( int side = 0; side < 4; side++ ) {
    // side: 0=south, 1=east, 2=north, 3=west
    
    c2 = TwistedCubeTrimmingCurve( srf, side );
    c2i = brep.m_C2.Count();
    brep.m_C2.Append(c2);

    switch ( side ) {
    case 0: // south
      ei = eSi;
      bRev3d = (eS_dir == -1);
      iso = ON_Surface::S_iso;
      break;
    case 1: // east
      ei = eEi;
      bRev3d = (eE_dir == -1);
      iso = ON_Surface::E_iso;
      break;
    case 2: // north
      ei = eNi;
      bRev3d = (eN_dir == -1);
      iso = ON_Surface::N_iso;
      break;
    case 3: // west
      ei = eWi;
      bRev3d = (eW_dir == -1);
      iso = ON_Surface::W_iso;
      break;
    }

    ON_BrepTrim& trim = brep.NewTrim( brep.m_E[ei], bRev3d, loop, c2i );
    q = c2->PointAtStart();
    //trim.m_P[0] = srf.PointAt( q.x, q.y );
    q = c2->PointAtEnd();
    //trim.m_P[1] = srf.PointAt( q.x, q.y );
    trim.m_iso = iso;
    trim.m_type = ON_BrepTrim::mated; // This b-rep is closed, so all trims
                                         // have mates.
    trim.m_tolerance[0] = 0.0; // This simple example is exact - for models with
    trim.m_tolerance[1] = 0.0; // non-exact data, set tolerance as explained in
                               // definition of ON_BrepTrim.
  }

  return loop.m_loop_index;
}

static void MakeTwistedCubeFace( ON_Brep& brep,
     int si,      // index of 3d surface
     int s_dir,   // orientation of surface with respect to brep
     //int vSWi, int vSEi, int vNEi, int vNWi, // Indices of corner vertices listed in SW,SE,NW,NE order
     int eSi,     // index of edge on south side of surface
     int eS_dir,  // orientation of edge with respect to surface trim
     int eEi,     // index of edge on south side of surface
     int eE_dir,  // orientation of edge with respect to surface trim
     int eNi,     // index of edge on south side of surface
     int eN_dir,  // orientation of edge with respect to surface trim
     int eWi,     // index of edge on south side of surface
     int eW_dir   // orientation of edge with respect to surface trim
                                )
{
  ON_BrepFace& face = brep.NewFace(si);

  MakeTwistedCubeTrimmingLoop( brep, face,
                //vSWi, vSEi, vNEi, vNWi, 
                eSi, eS_dir, 
                eEi, eE_dir, 
                eNi, eN_dir, 
                eWi, eW_dir 
                );

  face.m_bRev = (s_dir == -1);
}

static void MakeTwistedCubeFaces( ON_Brep& brep )
{

  MakeTwistedCubeFace( brep,
    ABCD,       // Index of surface ABCD
    +1,         // orientation of surface with respect to brep
    //A, B, C, D, // Indices of vertices listed in SW,SE,NW,NE order
    AB,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (AB)
    BC,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (BC)
    CD,+1,      // South side edge and its orientation with respect to
                // to the trimming curve   (CD)
    AD,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (AD)
    );

  MakeTwistedCubeFace( brep,
    BCGF,       // Index of surface BCGF
    -1,         // orientation of surface with respect to brep
    //B, C, G, F, // Indices of vertices listed in SW,SE,NW,NE order
    BC,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (BC)
    CG,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (CG)
    FG,-1,      // South side edge and its orientation with respect to
                // to the trimming curve   (FG)
    BF,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (BF)
    );

  MakeTwistedCubeFace( brep,
    CDHG,       // Index of surface CDHG
    -1,         // orientation of surface with respect to brep
    //C, D, H, G, // Indices of vertices listed in SW,SE,NW,NE order
    CD,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (CD)
    DH,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (DH)
    GH,-1,      // South side edge and its orientation with respect to
                // to the trimming curve   (GH)
    CG,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (CG)
    );

  MakeTwistedCubeFace( brep,
    ADHE,       // Index of surface ADHE
    +1,         // orientation of surface with respect to brep
    //A, D, H, E, // Indices of vertices listed in SW,SE,NW,NE order
    AD,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (AD)
    DH,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (DH)
    EH,-1,      // South side edge and its orientation with respect to
                // to the trimming curve   (EH)
    AE,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (AE)
    );

  MakeTwistedCubeFace( brep,
    ABFE,       // Index of surface ABFE
    -1,         // orientation of surface with respect to brep
    //A, B, F, E, // Indices of vertices listed in SW,SE,NW,NE order
    AB,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (AB)
    BF,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (BF)
    EF,-1,      // South side edge and its orientation with respect to
                // to the trimming curve   (EF)
    AE,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (AE)
    );

  MakeTwistedCubeFace( brep,
    EFGH,       // Index of surface EFGH
    -1,         // orientation of surface with respect to brep
    //E, F, G, H, // Indices of vertices listed in SW,SE,NW,NE order
    EF,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (EF)
    FG,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (FG)
    GH,+1,      // South side edge and its orientation with respect to
                // to the trimming curve   (GH)
    EH,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (EH)
    );
}


static ON_Brep* MakeTwistedCube( ON_TextLog& error_log )
{
  // This example demonstrates how to construct a ON_Brep
  // with the topology shown below.
  //
  //
  //             H-------e6-------G
  //            /                /|
  //           / |              / |
  //          /  e7            /  e5
  //         /   |            /   |
  //        /                e10  |
  //       /     |          /     |
  //      e11    E- - e4- -/- - - F
  //     /                /      /
  //    /      /         /      /
  //   D---------e2-----C      e9
  //   |     /          |     /
  //   |    e8          |    /
  //   e3  /            e1  /
  //   |                |  /
  //   | /              | /
  //   |                |/
  //   A-------e0-------B
  //
  //

  ON_3dPoint point[8] = {
    ON_3dPoint(  0.0,  0.0,  0.0 ),  // point A = geometry for vertex 0
    ON_3dPoint( 10.0,  0.0,  0.0 ),  // point B = geometry for vertex 1
    ON_3dPoint( 10.0,  8.0, -1.0 ),  // point C = geometry for vertex 2
    ON_3dPoint(  0.0,  6.0,  0.0 ),  // point D = geometry for vertex 3
    ON_3dPoint(  1.0,  2.0, 11.0 ),  // point E = geometry for vertex 4
    ON_3dPoint( 10.0,  0.0, 12.0 ),  // point F = geometry for vertex 5
    ON_3dPoint( 10.0,  7.0, 13.0 ),  // point G = geometry for vertex 6
    ON_3dPoint(  0.0,  6.0, 12.0 )   // point H = geometry for vertex 7
  };

  ON_Brep* brep = new ON_Brep();

  // create eight vertices located at the eight points
  int vi;
  for ( vi = 0; vi < 8; vi++ ) {
    ON_BrepVertex& v = brep->NewVertex(point[vi]);
    v.m_tolerance = 0.0; // this simple example is exact - for models with
                         // non-exact data, set tolerance as explained in
                         // definition of ON_BrepVertex.
  }

  // Create 3d curve geometry - the orientations are arbitrarily chosen
  // so that the end vertices are in alphabetical order.
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[A], point[B] ) ); // line AB
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[B], point[C] ) ); // line BC
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[C], point[D] ) ); // line CD
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[A], point[D] ) ); // line AD
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[E], point[F] ) ); // line EF
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[F], point[G] ) ); // line FG
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[G], point[H] ) ); // line GH
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[E], point[H] ) ); // line EH
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[A], point[E] ) ); // line AE
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[B], point[F] ) ); // line BF
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[C], point[G] ) ); // line CG
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[D], point[H] ) ); // line DH

  // Create the 12 edges that connect the corners of the cube.
  MakeTwistedCubeEdges( *brep );

  // Create 3d surface geometry - the orientations are arbitrarily chosen so
  // that some normals point into the cube and others point out of the cube.
  brep->m_S.Append( TwistedCubeSideSurface( point[A], point[B], point[C], point[D] ) ); // ABCD
  brep->m_S.Append( TwistedCubeSideSurface( point[B], point[C], point[G], point[F] ) ); // BCGF
  brep->m_S.Append( TwistedCubeSideSurface( point[C], point[D], point[H], point[G] ) ); // CDHG
  brep->m_S.Append( TwistedCubeSideSurface( point[A], point[D], point[H], point[E] ) ); // ADHE
  brep->m_S.Append( TwistedCubeSideSurface( point[A], point[B], point[F], point[E] ) ); // ABFE
  brep->m_S.Append( TwistedCubeSideSurface( point[E], point[F], point[G], point[H] ) ); // EFGH


  // Create the CRhinoBrepFaces
  MakeTwistedCubeFaces( *brep );

  if ( !brep->IsValid() ) 
  {
    error_log.Print("Twisted cube b-rep is not valid.\n");
    delete brep;
    brep = NULL;
  }

  //ON_BOOL32 bIsManifold;
  //ON_BOOL32 bHasBoundary;
  //ON_BOOL32 b = brep->IsManifold( &bIsManifold,&bHasBoundary );

  return brep;
}

//int main( int argc, const char *argv[] )
int main()
{
  ON::Begin();

  ON_TextLog error_log;

  // Before working through this example, you should understand
  // the example_write.cpp example.

  ON_Brep* brep = MakeTwistedCube(error_log);
  if ( !brep )
    return 1;

  ONX_Model model;

  ONX_Model_Object& mo = model.m_object_table.AppendNew();
  mo.m_object = brep;
  mo.m_bDeleteObject = true; // ~ONX_Model will delete brep
  brep = 0;
  mo.m_attributes.m_name = "Twisted b-rep";

  // OPTIONAL - change values from defaults
  model.m_properties.m_Notes.m_notes = "File created by OpenNURBS example_brep.cpp";
  model.m_properties.m_Notes.m_bVisible = true;

  model.m_properties.m_Application.m_application_name 
    = "OpenNURBS example_brep.cpp";
  model.m_properties.m_Application.m_application_URL 
    = "http://www.opennurbs.org";
  model.m_properties.m_Application.m_application_details 
    = "OpenNURBS example showing how to create and write a simple b-rep";


  int version = 0; // version will be ON_BinaryArchive::CurrentArchiveVersion()
  model.Polish();
  const char* filename = "my_brep.3dm";
  bool rc = model.Write( filename, 
               version,
               __FILE__ " example_brep.cpp " __DATE__,
               &error_log
               );

  if (rc)
    printf("Wrote %s.\n",filename);
  else
    printf("Errors writing %s.\n",filename);

  ON::End();

  return 0;
}

blob
data 28721
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2011 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

// uncomment the "ON_DLL_IMPORTS" define to use opennurbs as a Windows DLL
//#define ON_DLL_IMPORTS
#include "../opennurbs.h"
#include "../examples_linking_pragmas.h"

#include "../opennurbs_gl.h"

#if defined(ON_COMPILER_MSC)

#if ( _MSC_VER != 1400 )
// Tested compilers:
//   Microsoft Visual Studio 2005
//   Support for other compilers is not available.
#error The OpenGL example is not supported on this compiler.
// NOTE:
//   Visual Studio 2005 / 8.0 was the last version of Visual
//   studio to install the libraries and header files for
//   Open GL auxillary functions.
#endif

#include <GL/GLaux.h>   // Open GL auxillary functions

#define ON_EXAMPLE_GL_USE_GLAUX

#elif defined(ON_COMPILER_XCODE)

// Tested compilers:
//   Apple Xcode 2.4.1
//   Support for other Apple compilers is not available.
#include <GLUT/glut.h>   // Open GL auxillary functions
#define ON_EXAMPLE_GL_USE_GLUT

#else

// Unsupported compiler:
//   Support for other compilers is not available
#error Choose between OpenGL AUX or OpenGL GLUT.

//#include <GLaux.h>   // Open GL auxillary functions
//#define ON_EXAMPLE_GL_USE_GLAUX

//#include <glut.h>   // Open GL auxillary functions
//#define ON_EXAMPLE_GL_USE_GLUT

#endif


#if defined(_WINDOWS) || defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)
#define MY_GL_CALLBACK CALLBACK
#define MY_USE_WINDOWS_STUFF
#else
#define MY_GL_CALLBACK
#endif

// Before working on this file, be sure to study the OpenNURBS toolkit 
// file example_read.cpp and to read chapters 1 through 11 of the 
// _Open_GL_Programming_Guide_.
//
// This file contains simple example in modeled after those found in
// the _Open_GL_Programming_Guide_.  The nuts and bolts functions that
// demonstrate how to use Open GL to display OpenNURBS geometry are in
// opennurbs_gl.cpp.

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


class CModel : public ONX_Model
{
public:
  void GetObjectMaterial( int object_index, ON_Material& material ) const;
  ON_3dmView m_view;
  ON_BoundingBox m_bbox;
};

void CModel::GetObjectMaterial( 
          int object_index,
          ON_Material& material 
          ) const
{
  material.Default();
  //const ON_Geometry* geo = 0;

  if ( object_index >= 0 && object_index <= m_object_table.Count() )
  {
    const ONX_Model_Object& mo = m_object_table[object_index];
    if ( 0 != mo.m_object )
    {
      switch( mo.m_object->ObjectType() )
      {
      case ON::surface_object:
      case ON::brep_object:
      case ON::mesh_object:
      case ON::instance_reference:
        GetRenderMaterial( mo.m_attributes, material );
        break;
      default:
        {
          // use emmissive object color for curve objects
          ON_Color c = WireframeColor( mo.m_attributes );
          ON_Color black(0,0,0);
          material.Default();
          material.SetAmbient(black);
          material.SetDiffuse(black);
          material.SetSpecular(black);
          material.SetEmission(c);
        }
        break;
      }
    }
  }
}


void GetDefaultView( const ON_BoundingBox& bbox, ON_3dmView& view )
{
  // simple parallel projection of bounding box;
  double window_height = 1.0;
  double window_width = 1.0;
  double dx, dy, dz;
  double frus_near, frus_far;
  ON_3dPoint camLoc;
  ON_3dVector camDir, camUp;
  view.m_target = 0.5*(bbox.m_min + bbox.m_max);
  dx = 1.1*(bbox.m_max[0] - bbox.m_min[0]);
  dy = 1.1*(bbox.m_max[1] - bbox.m_min[1]);
  dz = 1.1*(bbox.m_max[2] - bbox.m_min[2]);
  if ( dx <= 1.0e-6 && dy <= 1.0e-6 )
    dx = dy = 2.0;
  if ( window_height*dx < window_width*dy ) {
    dx = dy*window_width/window_height;
  }
  else {
    dy = dx*window_height/window_width;
  }
  if ( dz <= 0.1*(dx+dy) )
    dz = 0.1*(dx+dy);
  dx *= 0.5;
  dy *= 0.5;
  dz *= 0.5;


  frus_near = 1.0;
  frus_far = frus_near + 2.0*dz;
  camLoc = view.m_target + (dz + frus_near)*ON_zaxis;
  camDir = -ON_zaxis;
  camUp = ON_yaxis;

  view.m_vp.SetProjection( ON::parallel_view );
  view.m_vp.SetCameraLocation( camLoc );
  view.m_vp.SetCameraDirection( camDir );
  view.m_vp.SetCameraUp( camUp );
  view.m_vp.SetFrustum( -dx, dx, -dy, dy, frus_near, frus_far );
}

///////////////////////////////////////////////////////////////////////
//
// Globals for myDisplay() function passed to auxMainLoop()
//
//////////////////////////////////////////////////////////////////////

// GL display list "name"
static GLuint glb_display_list_number = 1;

// global pointer to active model
CModel* glb_model = 0;

///////////////////////////////////////////////////////////////////////
//
// Functions used in main()
//
//////////////////////////////////////////////////////////////////////

ON_BOOL32 myInitGL( const ON_Viewport&, GLUnurbsObj*& );

void myBuildDisplayList( 
      GLuint,                  // display_list_number,
      GLUnurbsObj*,            // pointer to GL nurbs render
      const CModel&            // geometry to render
      );

extern "C" {
void MY_GL_CALLBACK myNurbsErrorCallback( GLenum ); // for gluNurbsCallback()

void MY_GL_CALLBACK myDisplay( void );              // for auxMainLoop()


void MY_GL_CALLBACK myKeyLeftArrowEvent( void );    // for auxKeyFunc();
void MY_GL_CALLBACK myKeyRightArrowEvent( void );   // for auxKeyFunc();
void MY_GL_CALLBACK myKeyUpArrowEvent( void );      // for auxKeyFunc();
void MY_GL_CALLBACK myKeyDownArrowEvent( void );    // for auxKeyFunc();
void MY_GL_CALLBACK myKeyViewExtents( void );       // for auxKeyFunc();

#if defined(ON_EXAMPLE_GL_USE_GLAUX)
void MY_GL_CALLBACK myGLAUX_Reshape( GLsizei, GLsizei );  // for auxReshapeFunc()

void MY_GL_CALLBACK myGLAUX_MouseLeftEvent( AUX_EVENTREC* );   // for auxMouseFunc();
void MY_GL_CALLBACK myGLAUX_MouseMiddleEvent( AUX_EVENTREC* ); // for auxMouseFunc();
void MY_GL_CALLBACK myGLAUX_MouseRightEvent( AUX_EVENTREC* );  // for auxMouseFunc();

typedef void (CALLBACK* RHINO_GL_NURBS_ERROR)();
#endif

#if defined(ON_EXAMPLE_GL_USE_GLUT)
void MY_GL_CALLBACK myGLUT_Reshape( int, int );  // for glutReshapeFunc()

void MY_GL_CALLBACK myGLUT_MouseEvent( int button, int state, int x, int y );
void MY_GL_CALLBACK myGLUT_KeyboardEvent( unsigned char ch, int x, int y );
void MY_GL_CALLBACK myGLUT_SpecialKeyEvent( int ch, int x, int y );    // for auxKeyFunc();

// If you are using Apple's Xcode and you get a compile error
// on the typedef below, then try using the commented out typedef.
//
// Apple's Xcode 2.4 likes this typedef witht the (...)
typedef void (CALLBACK* RHINO_GL_NURBS_ERROR)(...);
//
// Apple's Xcode 3.2 likes this typedef witht the (...)
//typedef void (CALLBACK* RHINO_GL_NURBS_ERROR)();
#endif

}

///////////////////////////////////////////////////////////////////////
//
// used to set projections
//
void SetGLModelViewMatrix( const ON_Viewport& );
void SetGLProjectionMatrix( ON_Viewport& );
///////////////////////////////////////////////////////////////////////

int main( int argc, const char *argv[] )
{
  // reads model into global glb_model;
  ON::Begin();

  ON_TextLog error_log;

  ON_BOOL32 bOK;
  int window_width  = 500;
  int window_height = 500;
  //double port_aspect = ((double)window_width)/((double)window_height);

  // read the file into model
  if ( argc != 2 ) {
    printf("Syntax: %s filename.3dm\n",argv[0] );
    return 0;
  }
  const char* sFileName = argv[1];
  printf("\nFile:  %s\n", sFileName );

  // read the file
  CModel model;
  if ( !model.Read( sFileName, &error_log ) )
  {
    // read failed
    error_log.Print("Unable to read file %s\n",sFileName);
    return 1;
  }

  glb_model = &model;

  // set bbox = world bounding box of all the objects
  model.m_bbox = model.BoundingBox();
  if ( !model.m_bbox.IsValid() )
  {
    // nothing to look at in this model
    return 2;
  }

  // set model.m_view
  if ( model.m_settings.m_views.Count() > 0 )
  {
    // use first viewport projection in file
    double angle;
    model.m_view.m_vp = model.m_settings.m_views[0].m_vp;
    model.m_view.m_target = model.m_settings.m_views[0].m_target;
    model.m_view.m_vp.GetCameraAngle( &angle );
    model.m_view.m_vp.Extents( angle, model.m_bbox );
  }
  else 
  {
    GetDefaultView( model.m_bbox, model.m_view );
  }

  // If needed, enlarge frustum so its aspect matches the window's aspect.
  // Since the Rhino file does not store the far frustum distance in the
  // file, viewports read from a Rhil file need to have the frustum's far
  // value set by inspecting the bounding box of the geometry to be
  // displayed.

  
  ///////////////////////////////////////////////////////////////////
  //
  // GL stuff starts here
  //
  for(;;) {  
    
#if defined(ON_EXAMPLE_GL_USE_GLAUX)
    wchar_t sWindowTitleString[256];
#endif
#if defined(ON_EXAMPLE_GL_USE_GLUT)
    char sWindowTitleString[256];
#endif
    sWindowTitleString[255] = 0;
    if ( argv[0] && argv[0][0] )
    {
      int i;
      for ( i = 0; i < 254 && argv[0][i]; i++ )
        sWindowTitleString[i] = argv[0][i];
      sWindowTitleString[i] = 0;
    }

#if defined(ON_EXAMPLE_GL_USE_GLAUX)
    auxInitPosition( 0, 0, window_width, window_height );
    auxInitDisplayMode( AUX_SINGLE | AUX_RGB | AUX_DEPTH );
    auxInitWindow( sWindowTitleString );

    // register event handler functions
    auxIdleFunc( 0 );
    auxReshapeFunc( myGLAUX_Reshape );
    auxMouseFunc( AUX_LEFTBUTTON,   AUX_MOUSEDOWN, myGLAUX_MouseLeftEvent );
    auxMouseFunc( AUX_LEFTBUTTON,   AUX_MOUSEUP,   myGLAUX_MouseLeftEvent );
    auxMouseFunc( AUX_MIDDLEBUTTON, AUX_MOUSEDOWN, myGLAUX_MouseMiddleEvent );
    auxMouseFunc( AUX_MIDDLEBUTTON, AUX_MOUSEUP,   myGLAUX_MouseMiddleEvent );
    auxMouseFunc( AUX_RIGHTBUTTON,  AUX_MOUSEDOWN, myGLAUX_MouseRightEvent );
    auxMouseFunc( AUX_RIGHTBUTTON,  AUX_MOUSEUP,   myGLAUX_MouseRightEvent );
    auxKeyFunc( AUX_LEFT,  myKeyLeftArrowEvent );
    auxKeyFunc( AUX_RIGHT, myKeyRightArrowEvent );
    auxKeyFunc( AUX_UP,    myKeyUpArrowEvent );
    auxKeyFunc( AUX_DOWN,  myKeyDownArrowEvent );
    auxKeyFunc( AUX_E,  myKeyViewExtents );
    auxKeyFunc( AUX_e,  myKeyViewExtents );
    auxKeyFunc( AUX_Z,  myKeyViewExtents );
    auxKeyFunc( AUX_z,  myKeyViewExtents );
#endif

#if defined(ON_EXAMPLE_GL_USE_GLUT)
    glutInit(&argc,(char**)argv);
    glutInitWindowPosition( 0, 0);
    glutInitWindowSize( window_width, window_height );
    glutInitDisplayMode( GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH );
    glutCreateWindow( sWindowTitleString );

    // register event handler functions
    glutIdleFunc( 0 );
    glutReshapeFunc( myGLUT_Reshape );
    glutMouseFunc( myGLUT_MouseEvent );
    glutKeyboardFunc( myGLUT_KeyboardEvent );
    glutSpecialFunc( myGLUT_SpecialKeyEvent );
    glutDisplayFunc( myDisplay );
#endif

    // setup model view matrix, GL defaults, and the GL NURBS renderer
    GLUnurbsObj* pTheGLNURBSRender = NULL; // OpenGL NURBS rendering context
    bOK = myInitGL( model.m_view.m_vp, pTheGLNURBSRender );

    if ( bOK ) {
      // build display list
      myBuildDisplayList( glb_display_list_number,
                          pTheGLNURBSRender,
                          model );

      // look at it
#if defined(ON_EXAMPLE_GL_USE_GLAUX)
      auxMainLoop( myDisplay );
#endif

#if defined(ON_EXAMPLE_GL_USE_GLUT)
      glutMainLoop(  );
#endif

    }

    gluDeleteNurbsRenderer( pTheGLNURBSRender );

    break;
  }

  //
  // GL stuff ends here
  //
  ///////////////////////////////////////////////////////////////////

  ON::End();

  return 0;
}

///////////////////////////////////////////////////////////////////////
void SetGLModelViewMatrix( const ON_Viewport& viewport )
{
  ON_GL( viewport ); // updates GL model view matrix
}

void SetGLProjectionMatrix( ON_Viewport& viewport )
{
  int pl, pr, pb, pt;
  viewport.GetScreenPort( &pl, &pr, &pb, &pt, NULL, NULL );
  ON_GL( viewport, pl, pr, pb, pt ); // updates GL projection matrix
}

ON_BOOL32 myInitGL( const ON_Viewport& viewport, GLUnurbsObj*& nobj )
{
  // set the model view transform
  SetGLModelViewMatrix( viewport );

  // this stuff works with MSVC 4.2's Open GL. Changes may be needed for other
  // GLs.
  //ON_Color background_color(0,128,128);
  ON_Color background_color(0,63,127);
  //background_color = glb_model->m_settings.m_RenderSettings.m_background_color;
  glClearColor( (float)background_color.FractionRed(), 
                (float)background_color.FractionGreen(), 
                (float)background_color.FractionBlue(), 
                1.0f
                );

  glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE );
  glDisable( GL_CULL_FACE );
  
  // Rhino viewports have camera "Z" pointing at the camera in a right
  // handed coordinate system.
  glClearDepth( 0.0f );
  glEnable( GL_DEPTH_TEST );
  glDepthFunc( GL_GEQUAL );

  glEnable( GL_LIGHTING );
  glEnable( GL_DITHER );
  //glEnable( GL_AUTO_NORMAL );
  //glEnable( GL_NORMALIZE );

  // default material
  ON_GL( (ON_Material*)NULL );


  // GL rendering of NURBS objects requires a GLUnurbsObj.
  nobj = gluNewNurbsRenderer();
  if ( !nobj )
    return false;
  
  gluNurbsProperty( nobj, GLU_SAMPLING_TOLERANCE,   20.0f );
  gluNurbsProperty( nobj, GLU_PARAMETRIC_TOLERANCE, 0.5f );
  gluNurbsProperty( nobj, GLU_DISPLAY_MODE,         (GLfloat)GLU_FILL );
  //gluNurbsProperty( nobj, GLU_DISPLAY_MODE,         GLU_OUTLINE_POLYGON );
  //gluNurbsProperty( nobj, GLU_DISPLAY_MODE,         GLU_OUTLINE_PATCH );
  gluNurbsProperty( nobj, GLU_SAMPLING_METHOD,      (GLfloat)GLU_PATH_LENGTH );
  //gluNurbsProperty( nobj, GLU_SAMPLING_METHOD,      GLU_PARAMETRIC_ERROR );
  //gluNurbsProperty( nobj, GLU_SAMPLING_METHOD,      GLU_DOMAIN_DISTANCE );
  gluNurbsProperty( nobj, GLU_CULLING,              (GLfloat)GL_FALSE );

  // register GL NURBS error callback
  {
    // hack to get around C vs C++ type checking trauma
    RHINO_GL_NURBS_ERROR fn;
    fn = (RHINO_GL_NURBS_ERROR)myNurbsErrorCallback;
    gluNurbsCallback( nobj, GLU_ERROR, fn );
  }

  return true;
}

///////////////////////////////////////////////////////////////////////

#if defined(ON_EXAMPLE_GL_USE_GLAUX)
void MY_GL_CALLBACK myGLAUX_Reshape( GLsizei w, GLsizei h )
{
  static GLsizei w0 = 0;
  static GLsizei h0 = 0;
  if ( w != w0 || h != h0 ) {
    h0 = h;
    w0 = w;
    ON_GL( glb_model->m_view.m_vp, 0, w-1, h-1, 0 ); // set projection transform
  }
  glViewport( 0, 0, w, h );
}
#endif

#if defined(ON_EXAMPLE_GL_USE_GLUT)
void MY_GL_CALLBACK myGLUT_Reshape( int w, int h )
{
  static int w0 = 0;
  static int h0 = 0;
  if ( w != w0 || h != h0 ) {
    h0 = h;
    w0 = w;
    ON_GL( glb_model->m_view.m_vp, 0, w-1, h-1, 0 ); // set projection transform
  }
  glViewport( 0, 0, w, h );
}
#endif


///////////////////////////////////////////////////////////////////////
static void myRotateView( ON_Viewport& viewport,
                          const ON_3dVector& axis,
                          const ON_3dPoint& center,
                          double angle )
{
  ON_Xform rot;
  ON_3dPoint camLoc;
  ON_3dVector camY, camZ;

  rot.Rotation( angle, axis, center );

  if ( !viewport.GetCameraFrame( camLoc, NULL, camY, camZ ) )
    return;

  camLoc = rot*camLoc;
  camY   = rot*camY;
  camZ   = -(rot*camZ);

  viewport.SetCameraLocation( camLoc );
  viewport.SetCameraDirection( camZ );
  viewport.SetCameraUp( camY );

  ON_GL( viewport ); // update model view
}

static void myRotateLeftRight( ON_Viewport& viewport, double angle )
{
  // ON_3dVector axis = ON_zaxis; // rotate camera about world z axis (z up feel)
  ON_3dVector axis = ON_zaxis; // rotate camera about world y axis (u up feel)
  
  ON_3dPoint center;
  if ( glb_model )
    center = glb_model->m_view.m_target;
  else
    viewport.GetFrustumCenter( center );
  myRotateView( viewport, axis, center, angle );
}

static void myRotateUpDown( ON_Viewport& viewport, double angle )
{
  // rotates camera around the screen x axis
  ON_3dVector camX;
  ON_3dPoint center;
  if ( glb_model )
    center = glb_model->m_view.m_target;
  else
    viewport.GetFrustumCenter( center );
  viewport.GetCameraFrame( NULL, camX, NULL, NULL );
  myRotateView( viewport, camX, center, angle );
}

///////////////////////////////////////////////////////////////////////


void MY_GL_CALLBACK myKeyLeftArrowEvent( void )
{
  myRotateLeftRight( glb_model->m_view.m_vp, ON_PI/12.0 );
}

void MY_GL_CALLBACK myKeyRightArrowEvent( void )
{
  myRotateLeftRight( glb_model->m_view.m_vp, -ON_PI/12.0 );
}

void MY_GL_CALLBACK myKeyUpArrowEvent( void )
{
  myRotateUpDown( glb_model->m_view.m_vp, ON_PI/12.0 );
}

void MY_GL_CALLBACK myKeyDownArrowEvent( void )
{
  myRotateUpDown( glb_model->m_view.m_vp, -ON_PI/12.0 );
}

void MY_GL_CALLBACK myKeyViewExtents( void )
{
  double half_angle = 7.5*ON_PI/180.0;
  glb_model->m_view.m_vp.Extents( half_angle, glb_model->m_bbox );
  SetGLModelViewMatrix( glb_model->m_view.m_vp );
  SetGLProjectionMatrix( glb_model->m_view.m_vp );
}

#if defined(ON_EXAMPLE_GL_USE_GLAUX)

///////////////////////////////////////////////////////////////////////
//
// Mouse event handling
//

static void myGLAUX_MouseEvent( GLint button, const AUX_EVENTREC* event )
{
  static ON_BOOL32 bMouseActive = false;
  static int mx0, my0;
  int mx, my;

  if ( !event ) {
    bMouseActive = false;
    return;
  }

  if ( event->event == AUX_MOUSEDOWN ) {
    if ( bMouseActive ) {
      bMouseActive = false;
      return;
    }
    bMouseActive = true;
    mx0 = event->data[AUX_MOUSEX];
    my0 = event->data[AUX_MOUSEY];
    return;
  }

  if ( !bMouseActive || event->event != AUX_MOUSEUP )
    return;

  mx = event->data[AUX_MOUSEX];
  my = event->data[AUX_MOUSEY];

  switch (button) {
  case AUX_LEFTBUTTON:
    // zoom
    glb_model->m_view.m_vp.ZoomToScreenRect( mx0, my0, mx, my );
    break;
  case AUX_MIDDLEBUTTON:
    break;
  case AUX_RIGHTBUTTON:
    // dolly
    {
      ON_3dVector dolly_vector;
      double d;
      ON_3dPoint camLoc;
      ON_3dVector camZ;
      glb_model->m_view.m_vp.GetCameraFrame( camLoc, NULL, NULL, camZ );
      d = (camLoc-glb_model->m_view.m_target)*camZ;
      if ( glb_model->m_view.m_vp.GetDollyCameraVector(mx0,my0,mx,my,d,dolly_vector) ) {
        glb_model->m_view.m_vp.DollyCamera( dolly_vector );
      }
    }
    break;
  }

  // update GL model view and projection matrices to match viewport changes
  SetGLModelViewMatrix( glb_model->m_view.m_vp );
  SetGLProjectionMatrix( glb_model->m_view.m_vp );

  bMouseActive = false;
}

void MY_GL_CALLBACK myGLAUX_MouseLeftEvent( AUX_EVENTREC* event )
{
  myGLAUX_MouseEvent( AUX_LEFTBUTTON, event );
}

void MY_GL_CALLBACK myGLAUX_MouseMiddleEvent( AUX_EVENTREC* event )
{
  myGLAUX_MouseEvent( AUX_MIDDLEBUTTON, event );
}

void MY_GL_CALLBACK myGLAUX_MouseRightEvent( AUX_EVENTREC* event )
{
  myGLAUX_MouseEvent( AUX_RIGHTBUTTON, event );
}
#endif

#if defined(ON_EXAMPLE_GL_USE_GLUT)

void MY_GL_CALLBACK myGLUT_KeyboardEvent( unsigned char ch, int x, int y )
{
	int m = glutGetModifiers();
	if (m != GLUT_ACTIVE_ALT)
		return;
	if (ch == 'e' || ch == 'z') {
		myKeyViewExtents();
		glutPostRedisplay();
	}
}


void MY_GL_CALLBACK myGLUT_SpecialKeyEvent( int ch, int x, int y )
{
	if (ch == GLUT_KEY_LEFT)
		myKeyLeftArrowEvent();
	if (ch == GLUT_KEY_UP)
		myKeyUpArrowEvent();
	if (ch == GLUT_KEY_RIGHT)
		myKeyRightArrowEvent();
	if (ch == GLUT_KEY_DOWN)
		myKeyDownArrowEvent();
	glutPostRedisplay();
}

void myGLUT_MouseEvent( int button, int state, int x, int y )
{
	static int mx0, my0;
	static int mButton;

	if ( state == GLUT_DOWN ) {
		switch (button) {
		case GLUT_LEFT_BUTTON:
		case GLUT_MIDDLE_BUTTON:
		case GLUT_RIGHT_BUTTON:
			mButton = button;
			mx0 = x;
			my0 = y;
			break;
		}
	}

	if ( state == GLUT_UP && button == mButton ) {
		switch (mButton) {
		case GLUT_LEFT_BUTTON:
			// zoom
			glb_model->m_view.m_vp.ZoomToScreenRect( mx0, my0, x, y );
			break;
		case GLUT_MIDDLE_BUTTON:
			break;
		case GLUT_RIGHT_BUTTON:
			// dolly
			{
				ON_3dVector dolly_vector;
				double d;
				ON_3dPoint camLoc;
				ON_3dVector camZ;
				glb_model->m_view.m_vp.GetCameraFrame( camLoc, NULL, NULL, camZ );
				d = (camLoc-glb_model->m_view.m_target)*camZ;
				if ( glb_model->m_view.m_vp.GetDollyCameraVector(mx0,my0,x,y,d,dolly_vector) ) {
					glb_model->m_view.m_vp.DollyCamera( dolly_vector );
				}
			}
			break;
		}

		// update GL model view and projection matrices to match viewport changes
		SetGLModelViewMatrix( glb_model->m_view.m_vp );
		SetGLProjectionMatrix( glb_model->m_view.m_vp );
		glutPostRedisplay();
	}
}

#endif


///////////////////////////////////////////////////////////////////////

void myDisplayObject( const ON_Object& geometry, const ON_Material& material, GLUnurbsObj* nobj )
{
  // Called from myDisplay() to show geometry.
  // Uses ON_GL() functions found in rhinoio_gl.cpp.
  const ON_Point* point=0;
  const ON_PointCloud* cloud=0;
  const ON_Brep* brep=0;
  const ON_Mesh* mesh=0;
  const ON_Curve* curve=0;
  const ON_Surface* surface=0;

  // specify rendering material
  ON_GL( material );

  brep = ON_Brep::Cast(&geometry);
  if ( brep ) 
  {
    ON_GL(*brep, nobj);
    return;
  }

  mesh = ON_Mesh::Cast(&geometry);
  if ( mesh ) 
  {
    ON_GL(*mesh);
    return;
  }

  curve = ON_Curve::Cast(&geometry);
  if ( curve ) 
  {
    ON_GL( *curve, nobj );
    return;
  }

  surface = ON_Surface::Cast(&geometry);
  if ( surface ) 
  {
    gluBeginSurface( nobj );
    ON_GL( *surface, nobj );
    gluEndSurface( nobj );
    return;
  }

  point = ON_Point::Cast(&geometry);
  if ( point ) 
  {
    ON_GL(*point);
    return;
  }

  cloud = ON_PointCloud::Cast(&geometry);
  if ( cloud ) 
  {
    ON_GL(*cloud);
    return;
  }

}

///////////////////////////////////////////////////////////////////////

void MY_GL_CALLBACK myDisplayLighting( const ON_Viewport&, // viewport, // unreferenced
                                       const CModel& model
                                     )
{
  int light_count = model.m_light_table.Count();
  if ( light_count > 0 ) {
    int maxlighti = light_count;
    if ( maxlighti > GL_MAX_LIGHTS )
      maxlighti = GL_MAX_LIGHTS;
    int lighti;
    for ( lighti = 0; lighti < maxlighti; lighti++ ) {
      ON_GL( model.m_light_table[lighti].m_light, lighti+GL_LIGHT0 );
    }
  }
  else {
    // use default headlight
    // use basic bright white head light with a bit of ambient
    ON_Light head_light;
    head_light.Default();
    ON_GL( head_light, GL_LIGHT0 );
  }
}

///////////////////////////////////////////////////////////////////////

#if defined(MY_USE_WINDOWS_STUFF)
static void myDrawAxesSprite( const ON_Viewport& viewport, HDC hdc )
{
  // Use simple Windows calls to draw world axes sprite in lower left corner.
  // Note that Windows has screen (0,0) in the upper left corner; i.e,
  // screen "y" increases downwards.
  if ( !hdc )
    return;
  const int axes_size = 30;

  int port_left, port_right, port_top, port_bottom;
  if ( !viewport.GetScreenPort( &port_left, &port_right, &port_bottom, &port_top, NULL, NULL ) )
    return;
  const int scr_width  = port_right - port_left; // no "+1" here
  const int scr_height = port_bottom - port_top; // no "+1" here

  if (4*axes_size >= scr_width )
    return;
  if (4*axes_size >= scr_height )
    return;

  int x0 = 3*axes_size/2;
  int y0 = port_bottom - 3*axes_size/2;
  int indx[3] = {0,1,2};
  double scr_coord[3][2];
  viewport.GetCoordinateSprite( axes_size, x0, y0, indx, scr_coord );

#define LXSIZE 3
#define LYSIZE 3
#define LOFF 3

  // draw 3 axes from back to front
  HPEN axis_pen[3];
  axis_pen[0] = CreatePen( PS_SOLID, 2, RGB(255,0,0) );
  axis_pen[1] = CreatePen( PS_SOLID, 2, RGB(0,255,0) );
  axis_pen[2] = CreatePen( PS_SOLID, 2, RGB(0,0,255) );
  HGDIOBJ saved_pen = SelectObject( hdc, axis_pen[0] );

  int i, k, x, y, lx, ly;
  for (i=0;i<3;i++) {
    k = indx[i];
    x = (int)scr_coord[k][0];
    y = (int)scr_coord[k][1];
    // use direction of screen vector to determine letter placement
    lx = x-x0; ly = y-y0;
    if (abs(lx) > abs(ly)) {
      // center letter to right/left of axis end
      lx = (x >= x0) ? x + LXSIZE+LOFF : x - LXSIZE-LOFF;
      ly = y;
    }
    else if (abs(ly) > abs(lx)) {
      // center letter above/below axis end
      lx = x;
      ly = (y >= y0) ? y + LYSIZE+LOFF : y - LYSIZE-LOFF;
    }
    else if (lx) {
      // diagonal axis - center letter on axis
      lx = (x >= x0) ? x + LXSIZE+LOFF : x - LXSIZE-LOFF;
      ly = (y >= y0) ? y + LYSIZE+LOFF : y - LYSIZE-LOFF;
    }
    else {
      // axis is perp to screen - center letter at axis end
      lx = x;
      ly = y;
    }
    SelectObject( hdc, axis_pen[k] );

    // draw axis
    MoveToEx( hdc, x0, y0, NULL );
    LineTo( hdc, x, y );

    // draw axis label
    switch (k) {
    case 0: // X
      MoveToEx( hdc, lx-LXSIZE, ly-LYSIZE, NULL );
      LineTo(   hdc, lx+LXSIZE, ly+LYSIZE );
      MoveToEx( hdc, lx-LXSIZE, ly+LYSIZE, NULL );
      LineTo(   hdc, lx+LXSIZE, ly-LYSIZE );
      break;
    case 1: // Y
      MoveToEx( hdc, lx-LXSIZE, ly-LYSIZE, NULL );
      LineTo(   hdc, lx,    ly    );
      LineTo(   hdc, lx+LXSIZE, ly-LYSIZE );
      MoveToEx( hdc, lx,    ly, NULL    );
      LineTo(   hdc, lx,    ly+LYSIZE );
      break;
    case 2: // Z
      MoveToEx( hdc, lx-LXSIZE, ly-LYSIZE, NULL );
      LineTo(   hdc, lx+LXSIZE, ly-LYSIZE );
      LineTo(   hdc, lx-LXSIZE, ly+LYSIZE );
      LineTo(   hdc, lx+LXSIZE, ly+LYSIZE );
      break;
    }

  }
  SelectObject( hdc, saved_pen );
  DeleteObject( axis_pen[0] );
  DeleteObject( axis_pen[1] );
  DeleteObject( axis_pen[2] );

#undef LXSIZE
#undef LYSIZE
#undef LOFF

}
#endif

///////////////////////////////////////////////////////////////////////

void myBuildDisplayList( GLuint display_list_number,
                         GLUnurbsObj* pTheGLNurbsRender,
                         const CModel& model
                         )
{
  ON_Material material;
  glNewList( display_list_number, GL_COMPILE );

  // display Rhino geometry using ON_GL() functions found in rhinoio_gl.cpp
  int i;
  const int object_count = model.m_object_table.Count();
  for ( i = 0; i < object_count; i++ ) 
  {
    const ONX_Model_Object& mo = model.m_object_table[i];
    if ( 0 != mo.m_object )
    {
      model.GetObjectMaterial( i, material );
      myDisplayObject( *mo.m_object, material, pTheGLNurbsRender );
    }
  }

  glEndList();
}

///////////////////////////////////////////////////////////////////////

void MY_GL_CALLBACK myDisplay( void )
{
  // Uses globals glb_* because the GL aux tools don't provide an
  // easy way to pass information into this callback.
  int bUseRhinoSpotlights = false; // I like to use a simple headlight
                                   // for a basic preview.

  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

  // lights
  if ( bUseRhinoSpotlights && glb_model ) {
    // Rhino spotlights (currently rotate along with geometry)
    myDisplayLighting( glb_model->m_view.m_vp, *glb_model );
  }
  else {
    // simple bright white headlight
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();
    GLfloat pos[4]  = { (GLfloat)0.0, (GLfloat)0.0, (GLfloat)1.0, (GLfloat)0.0 };
    glLightfv( GL_LIGHT0, GL_POSITION,  pos );
    GLfloat black[4] = { (GLfloat)0.0, (GLfloat)0.0, (GLfloat)0.0, (GLfloat)1.0 };
    GLfloat white[4] = { (GLfloat)1.0, (GLfloat)1.0, (GLfloat)1.0, (GLfloat)1.0 };
    glLightfv( GL_LIGHT0, GL_AMBIENT,  black );
    glLightfv( GL_LIGHT0, GL_DIFFUSE,  white );
    glLightfv( GL_LIGHT0, GL_SPECULAR, white );
    glEnable( GL_LIGHT0 );
    glPopMatrix();
  }

  // display list built with myBuildDisplayList()
  glCallList( glb_display_list_number ); 

  glFlush();

#if defined(MY_USE_WINDOWS_STUFF)
  // Windows decorations
  myDrawAxesSprite( glb_model->m_view.m_vp, wglGetCurrentDC() );
#endif
}

///////////////////////////////////////////////////////////////////////

void MY_GL_CALLBACK myNurbsErrorCallback( GLenum errCode )
{
  const GLubyte* s = gluErrorString( errCode );
  printf("GL NURBS ERROR: (%d) %s\n",errCode, s );
}

///////////////////////////////////////////////////////////////////////
blob
data 10563
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2011 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/		

////////////////////////////////////////////////////////////////
//
//  example_read.cpp  
// 
//  Example program using the Rhino file IO toolkit.  The program reads in  
//  a Rhino 3dm model file and describes its contents.  The program is a 
//  console application that takes a filename as a command line argument.
//
////////////////////////////////////////////////////////////////////////

// uncomment the "ON_DLL_IMPORTS" define to use opennurbs as a Windows DLL
//#define ON_DLL_IMPORTS
#include "../opennurbs.h"
#include "../examples_linking_pragmas.h"

static bool Dump3dmFileHelper( 
        const wchar_t* sFileName, // full name of file
        ON_TextLog& dump
        )
{
  dump.Print("====== FILENAME: %ls\n",sFileName);
  ON_Workspace ws;
  FILE* fp = ws.OpenFile( sFileName, L"rb" ); // file automatically closed by ~ON_Workspace()
  if ( !fp ) {
    dump.Print("**ERROR** Unable to open file.\n");
    return false;
  }

  ON_BinaryFile file( ON::read3dm, fp );

  int version = 0;
  ON_String comment_block;
  ON_BOOL32 rc = file.Read3dmStartSection( &version, comment_block );
  if (!rc) {
    dump.Print("**ERROR** Read3dmStartSection() failed\n");
    return false;
  }
  dump.Print("====== VERSION: %d\n",version );
  dump.Print("====== COMMENT BLOCK:\n",version );
  dump.PushIndent();
  dump.Print(comment_block);
  dump.PopIndent();
  dump.Print("====== CHUNKS:\n",version );
  unsigned int typecode;
  while ( !file.AtEnd() ) {
    typecode = file.Dump3dmChunk( dump, 0 );
    if ( !typecode )
      break;
    if ( typecode == TCODE_ENDOFFILE )
      break;
  }
  dump.Print("====== FINISHED: %ls\n",sFileName);

  return true;
}

/*
Returns:
  True if .3dm file was successfully read into an ONX_Model class.
*/
static bool ReadFileHelper( 
  const wchar_t* sFileName,
  bool bVerboseTextDump,
  bool bChunkDump,
  ON_TextLog& dump
  )
{
  if ( bChunkDump )
  {
    return Dump3dmFileHelper(sFileName,dump);
  }

  ONX_Model model;

  dump.Print("\nOpenNURBS Archive File:  %ls\n", sFileName );

  // open file containing opennurbs archive
  FILE* archive_fp = ON::OpenFile( sFileName, L"rb");
  if ( !archive_fp ) 
  {
    dump.Print("  Unable to open file.\n" );
    return false;
  }

  dump.PushIndent();

  // create achive object from file pointer
  ON_BinaryFile archive( ON::read3dm, archive_fp );

  // read the contents of the file into "model"
  bool rc = model.Read( archive, &dump );

  // close the file
  ON::CloseFile( archive_fp );

  // print diagnostic
  if ( rc )
    dump.Print("Successfully read.\n");
  else
    dump.Print("Errors during reading.\n");

  // see if everything is in good shape
  if ( model.IsValid(&dump) )
  {
    dump.Print("Model is valid.\n");
  }
  else
  {
    dump.Print("Model is not valid.\n");
  }

  // create a text dump of the model
  if ( bVerboseTextDump )
  {
    dump.PushIndent();
    model.Dump(dump);
    dump.PopIndent();
  }

  // destroy this model
  model.Destroy();

  dump.PopIndent();

  return rc;
}

/*
Returns:
  Number of files read.
*/
static int ReadDirectoryHelper( 
  int directory_depth,
  int maximum_directory_depth,
  const wchar_t* directory_name,
  const wchar_t* file_name_filter,
  bool bVerboseTextDump,
  bool bChunkDump,
  ON_TextLog& dump
  )
{
  int file_count = 0;
  if ( directory_depth <= maximum_directory_depth )
  {
    if ( 0 == file_name_filter || 0 == file_name_filter[0] )
      file_name_filter = L"*.3dm";

    // read files in this directory
    ON_FileIterator file_it;
    for ( const wchar_t* file_name = file_it.FirstFile( directory_name, file_name_filter );
          0 != file_name;
          file_name = file_it.NextFile()
        )
    {
      if ( file_it.CurrentFileIsDirectory() )
        continue;      
      
      if ( file_it.CurrentFileIsHidden() )
        continue;

      ON_wString full_path;
      if ( !file_it.GetCurrentFullPathFileName(full_path) )
        continue;
      
      if ( !ON::IsOpenNURBSFile(full_path) )
        continue;

      if ( ReadFileHelper(full_path,bVerboseTextDump,bChunkDump,dump) )
        file_count++;
    }

    // read files in subdirectories
    if ( directory_depth < maximum_directory_depth )
    {
      ON_FileIterator dir_it;
      for ( const wchar_t* subdirectory_name = dir_it.FirstFile( directory_name, 0 );
            0 != subdirectory_name;
            subdirectory_name = dir_it.NextFile()
          )
      {
        if ( false == dir_it.CurrentFileIsDirectory() )
          continue;

        if ( dir_it.CurrentFileIsHidden() )
          continue;

        ON_wString full_path;
        if ( !dir_it.GetCurrentFullPathFileName(full_path) )
          continue;
      
        file_count += ReadDirectoryHelper(
                            directory_depth + 1,
                            maximum_directory_depth,
                            full_path,
                            file_name_filter,
                            bVerboseTextDump,
                            bChunkDump,
                            dump
                            );
      }
    }
  }

  return file_count;
}


static void print_help(const char* example_read_exe_name)
{
  if ( 0 == example_read_exe_name || 0 == example_read_exe_name[0])
    example_read_exe_name = "example_read";

  printf("\n");
  printf("SYNOPSIS:\n");
  printf("  %s [-out:outputfilename.txt] [-c] [-r] <file or directory names>\n",example_read_exe_name );
  printf("\n");
  printf("DESCRIPTION:\n");
  printf("  If a file is listed, it is read as an opennurbs model file.\n");
  printf("  If a directory is listed, all .3dm files in that directory\n");
  printf("  are read as opennurbs model files.\n");
  printf("\n");
  printf("  Available options:\n");
  printf("    -out:outputfilename.txt\n");
  printf("      The output is written to the named file.\n");
  printf("    -chunkdump\n");
  printf("      Does a chunk dump instead of reading the file's contents.\n");
  printf("    -recursive\n");
  printf("      Recursivly reads files in subdirectories.\n");
  printf("\n");
  printf("EXAMPLE:\n");
  printf("  %s -out:list.txt -resursive .../example_files\n",example_read_exe_name);
  printf("  with read all the opennurbs .3dm files in the\n"); 
  printf("  example_files/ directory and subdirectories.\n");
}

int main( int argc, const char *argv[] )
{
  // If you are using OpenNURBS as a Windows DLL, then you MUST use
  // ON::OpenFile() to open the file.  If you are not using OpenNURBS
  // as a Windows DLL, then you may use either ON::OpenFile() or fopen()
  // to open the file.

  const char* example_read_exe_name = 0;
  if ( argc >= 1 && 0 != argv && 0 != argv[0] && 0 != argv[0][0] )
  {
    on_splitpath(argv[0],0,0,&example_read_exe_name,0);
  }
  if ( 0 == example_read_exe_name || 0 == example_read_exe_name[0] )
  {
#if defined(ON_OS_WINDOWS)
    example_read_exe_name = "example_read.exe";
#else
    example_read_exe_name = "example_read";
#endif
  }

  int argi;
  if ( argc < 2 ) 
  {
    print_help(example_read_exe_name);
    return 0;
  }

  // Call once in your application to initialze opennurbs library
  ON::Begin();

  // default dump is to stdout
  ON_TextLog dump_to_stdout;
  dump_to_stdout.SetIndentSize(2);
  ON_TextLog* dump = &dump_to_stdout;
  FILE* dump_fp = 0;

  bool bVerboseTextDump = true;

  bool bChunkDump = false;


  int maximum_directory_depth = 0;

  int file_count = 0;

  for ( argi = 1; argi < argc; argi++ ) 
  {
    const char* arg = argv[argi];

    // check for -out or /out option
    if ( (    0 == strncmp(arg,"-out:",5) || 0 == strncmp(arg,"-out:",5)
#if defined(ON_OS_WINDOWS)
           || 0 == strncmp(arg,"/out:",5) 
#endif
         ) 
         && arg[5] )
    {
      // change destination of dump file
      if ( dump != &dump_to_stdout )
      {
        delete dump;
        dump = 0;
      }
        if ( dump_fp )
        {
          ON::CloseFile(dump_fp);
        }

      const char* sDumpFilename = arg+5;
      FILE* text_fp = ON::OpenFile(sDumpFilename,"w");
      if ( text_fp )
      {
        dump_fp = text_fp;
        dump = new ON_TextLog(dump_fp);
        dump->SetIndentSize(2);
    }

      if ( 0 == dump )
        dump = &dump_to_stdout;

      continue;
    }

    // check for -chunkdump or /chunkdump option
    if (    0 == strcmp(arg,"-C") 
         || 0 == strcmp(arg,"-c") 
         || 0 == strcmp(arg,"-chunk") 
         || 0 == strcmp(arg,"-chunkdump") 
#if defined(ON_OS_WINDOWS)
         || 0 == strcmp(arg,"/C") 
         || 0 == strcmp(arg,"/c") 
         || 0 == strcmp(arg,"/chunk") 
         || 0 == strcmp(arg,"/chunkdump") 
#endif
         )
    {
      bChunkDump = true;
      continue;
    }

    // check for -recursive or /recursive option
    if (    0 == strcmp(arg,"-R") 
         || 0 == strcmp(arg,"-r") 
         || 0 == strcmp(arg,"-recurse") 
         || 0 == strcmp(arg,"-recursive") 
#if defined(ON_OS_WINDOWS)
         || 0 == strcmp(arg,"/R") 
         || 0 == strcmp(arg,"/r") 
         || 0 == strcmp(arg,"/recurse") 
         || 0 == strcmp(arg,"/recursive") 
#endif
         )
    {
      maximum_directory_depth = 32;
      continue;
    }

    ON_wString ws_arg = arg;
    const wchar_t* wchar_arg = ws_arg;

    if ( ON::IsDirectory(wchar_arg) )
    {
      file_count += ReadDirectoryHelper( 0, maximum_directory_depth, wchar_arg, 0, bVerboseTextDump, bChunkDump, *dump );
    }
    else
    {
      if ( ReadFileHelper( wchar_arg, bVerboseTextDump, bChunkDump, *dump ) )
        file_count++;
    }

  }

  dump->Print("%s read %d opennurbs model files.\n",example_read_exe_name,file_count);
  if ( dump != &dump_to_stdout )
  {
    delete dump;
    dump = 0;
  }

  if ( dump_fp )
  {
    // close the text dump file
    ON::CloseFile( dump_fp );
    dump_fp = 0;
  }
  
  // OPTIONAL: Call just before your application exits to clean
  //           up opennurbs class definition information.
  //           Opennurbs will not work correctly after ON::End()
  //           is called.
  ON::End();

  return 0;
}

blob
data 4258
// uncomment the "ON_DLL_IMPORTS" define to use opennurbs as a Windows DLL
//#define ON_DLL_IMPORTS
#include "../opennurbs.h"
#include "../examples_linking_pragmas.h"

int main( int argc, const char *argv[] )
{
  // If you are using OpenNURBS as a Windows DLL, then you MUST use
  // ON::OpenFile() to open the file.  If you are not using OpenNURBS
  // as a Windows DLL, then you may use either ON::OpenFile() or fopen()
  // to open the file.

  int argi;
  if ( argc < 2 ) 
  {
    printf("Syntax: %s [-out:outputfilename.txt] file1.3dm file2.3dm ...\n",argv[0] );
    return 0;
  }

  // Call once in your application to initialze opennurbs library
  ON::Begin();

  // default dump is to stdout
  ON_TextLog dump_to_stdout;
  ON_TextLog* dump = &dump_to_stdout;
  FILE* dump_fp = 0;

  ONX_Model model;

  for ( argi = 1; argi < argc; argi++ ) 
  {
    const char* arg = argv[argi];

    // check for -out or /out option
    if ( ( 0 == strncmp(arg,"-out:",5) || 0 == strncmp(arg,"/out:",5) ) 
         && arg[5] )
    {
      // change destination of dump file
      const char* sDumpFilename = arg+5;
      FILE* text_fp = ON::OpenFile(sDumpFilename,"w");
      if ( text_fp )
      {
        if ( dump_fp )
        {
          delete dump;
          ON::CloseFile(dump_fp);
        }
        dump_fp = text_fp;
        dump = new ON_TextLog(dump_fp);
      }
      continue;
    }

    const char* sFileName = arg;

    dump->Print("\nOpenNURBS Archive File:  %s\n", sFileName );

    // open file containing opennurbs archive
    FILE* archive_fp = ON::OpenFile( sFileName, "rb");
    if ( !archive_fp ) 
    {
      dump->Print("  Unable to open file.\n" );
      continue;
    }

    dump->PushIndent();

    // create achive object from file pointer
    ON_BinaryFile archive( ON::read3dm, archive_fp );

    // read the contents of the file into "model"
    bool rc = model.Read( archive, dump );

    // close the file
    ON::CloseFile( archive_fp );

    // print diagnostic
    if ( rc )
      dump->Print("Successfully read.\n");
    else
      dump->Print("Errors during reading.\n");

    // see if everything is in good shape
    if ( model.IsValid(dump) )
      dump->Print("Model is valid.\n");
    else
    {
      model.Polish();
      if ( model.IsValid() )
      {
        dump->Print("Model is valid after calling Polish().\n");
      }
      else
      {
        dump->Print("Model is not valid.\n");
      }
    }

    /*
    int oi = 14;
    if ( oi >=0 && oi < model.m_object_table.Count() )
    {
      dump->Print("m_object_table[%d].m_object:\n",oi);
      dump->PushIndent();
      model.m_object_table[oi].m_object->Dump(*dump);
      dump->PopIndent();
    }
    */

    int version = 0; // write current Rhino file

    ON_String outfile = sFileName;
    int len = outfile.Length() - 4;
    outfile.SetLength(len);
    outfile += "_roundtrip.3dm";
    bool outrc = model.Write( outfile, version, "roundtrip", dump );
    if ( outrc )
    {
      dump->Print("model.Write(%s) succeeded.\n",outfile.Array());
      ONX_Model model2;
      if ( model2.Read( outfile, dump ) )
      {
        dump->Print("model2.Read(%s) succeeded.\n",outfile.Array());
        if ( model2.IsValid(dump) )
        {
          dump->Print("Model2 is valid.\n");
        }
        else
        {
          dump->Print("Model2 is not valid.\n");
        }
        /*
        if ( oi >=0 && oi < model2.m_object_table.Count() )
        {
          dump->Print("m_object_table[%d].m_object:\n",oi);
          dump->PushIndent();
          model2.m_object_table[oi].m_object->Dump(*dump);
          dump->PopIndent();
        }
        */
      }
      else
      {
        dump->Print("model2.Read(%s) failed.\n",outfile.Array());
      }
    }
    else
      dump->Print("model.Write(%s) failed.\n",outfile.Array());

    // destroy this model
    model.Destroy();

    dump->PopIndent();
  }

  if ( dump_fp )
  {
    // close the text dump file
    delete dump;
    ON::CloseFile( dump_fp );
  }
  
  // OPTIONAL: Call just before your application exits to clean
  //           up opennurbs class definition information.
  //           Opennurbs will not work correctly after ON::End()
  //           is called.
  ON::End();

  return 0;
}

blob
data 2107
// uncomment the "ON_DLL_IMPORTS" define to use opennurbs as a Windows DLL
//#define ON_DLL_IMPORTS
#include "../opennurbs.h"
#include "example_ud.h"

CExampleWriteUserData::CExampleWriteUserData()
{
  m_sn = ++m__sn;
  m_userdata_uuid = Id();
  m_userdata_copycount = 1;
}

// {2532FB4A-DED9-4600-B6A4-1568504B66A5}
static const ON_UUID ExampleWriteUserData_Id = 
{ 0x2532fb4a, 0xded9, 0x4600, { 0xb6, 0xa4, 0x15, 0x68, 0x50, 0x4b, 0x66, 0xa5 } };

CExampleWriteUserData::CExampleWriteUserData( const char* s)
{
  m_sn = ++m__sn;
  m_userdata_uuid = Id();
  m_application_uuid = ExampleWriteUserData_Id;
  m_userdata_copycount = 1;
  m_str = s;
}

CExampleWriteUserData::CExampleWriteUserData(const CExampleWriteUserData& src) : ON_UserData(src), m_str(src.m_str)
{
  m_sn = ++m__sn;
}

CExampleWriteUserData& CExampleWriteUserData::operator=(const CExampleWriteUserData& src)
{
  if ( this != &src )
  {
    ON_UserData::operator=(src);
    m_str = src.m_str;
  }
  return *this;
}

CExampleWriteUserData::~CExampleWriteUserData()
{
  m_sn = -abs(m_sn);
}

void CExampleWriteUserData::Dump( ON_TextLog& text_log ) const
{
  ON_UserData::Dump(text_log);
  text_log.PushIndent();
  const wchar_t* s = m_str;
  if ( 0 == s ) 
    s = L"";
  text_log.Print("m_str: %ls\n",s);
  text_log.Print("m_sn: %d\n",m_sn);
  text_log.PopIndent();
}

ON_BOOL32 CExampleWriteUserData::GetDescription( ON_wString& description )
{
  description = L"example_write.exe user data";
  return true;
}


ON_BOOL32 CExampleWriteUserData::Archive() const
{
  return true;
}

ON_BOOL32 CExampleWriteUserData::Write(ON_BinaryArchive& file) const
{
  return file.WriteString(m_str);
}

ON_BOOL32 CExampleWriteUserData::Read(ON_BinaryArchive& file)
{
  return file.ReadString(m_str);
}

int CExampleWriteUserData::m__sn = 0;

ON_OBJECT_IMPLEMENT(CExampleWriteUserData,ON_UserData,"DADD17C5-706D-44ea-9B13-7D9D2C56D085");

ON_UUID CExampleWriteUserData::Id()
{
  // {6FC7CDF1-751E-4fa0-9D86-73E84D416DD7}
  static const ON_UUID id = 
  { 0x6fc7cdf1, 0x751e, 0x4fa0, { 0x9d, 0x86, 0x73, 0xe8, 0x4d, 0x41, 0x6d, 0xd7 } };
  return id;
}

blob
data 8566
// uncomment the "ON_DLL_IMPORTS" define to use opennurbs as a Windows DLL
//#define ON_DLL_IMPORTS
#include "../opennurbs.h"
#include "../examples_linking_pragmas.h"

// This example demonstrates how to attach customized "user data"
// to any class derived from ON_Object.  In particular, you can
// attach custom information to any piece of geometry in a 3DM
// file and have it persist in files, transform, and copy.

class MyUserData : public ON_UserData
{
  ON_OBJECT_DECLARE(MyUserData);

public:
  // Note well:
  // 1) All constructors must initialize ON_UserData::m_userdata_uuid to
  //    the UUID that identifies this kind of user data.  
  // 2) All constructors must initialize ON_UserData::m_copy_count to
  //    1 if the user data should be copied when the parent object is
  //    copied.
  // For more details, see comments in the constructor code below.
  MyUserData();
  MyUserData(const MyUserData&);

  MyUserData& operator=(const MyUserData&);
  ~MyUserData();

  // In order to get your user data to persist in files, you must
  // override ON_UserData::Archive(), ON_Object::Write() and 
  // ON_Object::Read()

  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  // Archive() must return true in order for user data to get saved
  // in a file.
  ON_BOOL32 Archive() const;
  
  // You must override ON_UserData::GetDescription().
  ON_BOOL32 GetDescription( ON_wString& );

  // If your user data is attached to some type of ON_Geometry and you
  // want the user data to be transformed when the parent ON_Geometry
  // is transformed, then you must override ON_UserData::Transform().
  //
  // If you don't override ON_UserData::Transform(), then the net
  // result of any transforms is stored in ON_UserData::m_userdata_xform.
  // At appropriate times, you can inspect ON_UserData::m_userdata_xform
  // and reset it to the identity after you've taken whatever actions
  // you deem to be appropriate.
  ON_BOOL32 Transform( const ON_Xform& );

  // possible information you might want to attach.
  int       m_my_int;
  ON_Line   m_my_line;
  ON_String m_my_string;
};

ON_OBJECT_IMPLEMENT( MyUserData, ON_UserData, "53114529-1CD7-4872-818E-311CB19101FA" );

// {D11E26D2-9A77-4a2f-AEC8-4498F2EABBA1}
static const ON_UUID my_application_id = 
{ 0xd11e26d2, 0x9a77, 0x4a2f, { 0xae, 0xc8, 0x44, 0x98, 0xf2, 0xea, 0xbb, 0xa1 } };

MyUserData::MyUserData()
{
  // Each kind of user data needs a uuid and your constructors MUST
  // initialize ON_UserData::m_userdata_uuid with the value of this
  // uuid.  The value of ON_UserData::m_userdata_uuid uuid is used to
  // identify the user data and is passed to ON_Object::GetUserData()
  // when an application wants to access user data that has been
  // attached to an object.
  //
  // In simple cases, the class UUID can be used as is shown below.
  m_userdata_uuid = MyUserData::m_MyUserData_class_id.Uuid();

  // In order for user data to be saved in 3dm files, it must have
  // a non-nil application id.
  m_application_uuid = my_application_id;

  // If you want your user data to be copied when its parent ON_Object
  // is copied, then your constructor must initialize 
  // ON_UserData::m_userdata_copycount to 1.
  // By default, ON_UserData::m_userdata_copycount is zero and the
  // user data is not copied.  See the comments in the ON_UserData
  // class definition for more details.
  m_userdata_copycount = 1;

  m_my_int = 0;
}

MyUserData::MyUserData(const MyUserData& src) 
          : ON_UserData(src) // critical - be sure to call base class copy constructor
{
  // The base class copy constructor copies
  // m_userdata_uuid, m_application_id, m_userdata_copycount, 
  // and m_userdata_xform.  Then if m_userdata_copycount is
  // not zero, it is incremented.

  m_my_int = src.m_my_int;
  m_my_line = src.m_my_line;
  m_my_string = src.m_my_string;
}

MyUserData& MyUserData::operator=(const MyUserData& src)
{
  if ( this != &src ) {
    // critical - be sure to call base class operator=()
    ON_UserData::operator=(src);
    
    m_my_int = src.m_my_int;
    m_my_line = src.m_my_line;
    m_my_string = src.m_my_string;
  }
  return *this;
}

MyUserData::~MyUserData()
{
}

ON_BOOL32 MyUserData::Archive() const
{
  return true;
}


ON_BOOL32 MyUserData::Read( ON_BinaryArchive& file )
{
  ON_BOOL32 rc = true;
  if ( rc ) 
    rc = file.ReadInt(&m_my_int);
  if ( rc ) 
    rc = file.ReadLine(m_my_line);
  if ( rc ) 
    rc = file.ReadString(m_my_string);
  return rc;
}

ON_BOOL32 MyUserData::Write( ON_BinaryArchive& file ) const
{
  ON_BOOL32 rc = true;
  if ( rc ) 
    rc = file.WriteInt(m_my_int);
  if ( rc ) 
    rc = file.WriteLine(m_my_line);
  if ( rc ) 
    rc = file.WriteString(m_my_string);
  return rc;
}

ON_BOOL32 MyUserData::GetDescription( ON_wString& s )
{
  s = L"my user data with point, line, and string";
  return true;
}

ON_BOOL32 MyUserData::Transform( const ON_Xform& xform )
{
  // Optional: call the ON_UserData::Transform() if you want the
  // ON_UserData::m_userdata_xform value to be updated.
  ON_UserData::Transform(xform);


  // Transform any geometry you have in your class.
  ON_BOOL32 rc = m_my_line.Transform(xform);
  return rc;
}

static void write_file( const char* filename, const ON_Point& point )
{
  ONX_Model model;

  ONX_Model_Object& mo = model.m_object_table.AppendNew();
  mo.m_object = &point;
  mo.m_bDeleteObject = false;

  int version = 0; // version will be ON_BinaryArchive::CurrentArchiveVersion()

  model.Polish();
  model.Write( filename, version, "example_userdata.cpp file" );
}

static void read_file( const char* filename, ON_Object*& pObject )
{
  // see example_read.cpp for information about read 3dm files
  // This code will only read the file created by write_file().
  // This code should not be used as a model for reading general 3dm files.


  ONX_Model model;
  model.Read( filename );

  if ( model.m_object_table.Count() > 0 )
  {
    pObject = const_cast<ON_Object*>(model.m_object_table[0].m_object);
    model.m_object_table[0].m_object = 0; // so ~ONX_Model will not delete object
  }

}


int main()
{
  ON::Begin();

  // uuid used to get user data via ON_Object::GetUserData()
  const ON_UUID my_user_data_uuid = MyUserData::m_MyUserData_class_id.Uuid();

  // We'll attach a MyUserData user data to a point.  In general,
  // you can attach user data to any class derived from ON_Object.
  ON_Point point(0.0,0.0,0.0);

  // User data must be created by a call to new
  MyUserData* ud = new MyUserData();
  ud->m_my_int = 1;
  ud->m_my_line.from.Set(0.0,0.0,0.0);
  ud->m_my_line.to.Set(1.0,1.0,1.0);
  ud->m_my_string = "my user data";

  // This attaches the user data to point.  When the point is destroied,
  // the user data will be destroyed.  
  //
  point.AttachUserData(ud);

  // Use ON_Object::GetUserData() to get user data.
  MyUserData* original_ud = MyUserData::Cast( point.GetUserData( my_user_data_uuid ) );

  printf("original_ud->m_userdata_copycount = %d\n",original_ud->m_userdata_copycount);

  // When the point is copied, the user data will be copied if 
  // ud->m_userdata_copycount > 0.
  //
  ON_Point copy_of_point = point;

  // Use ON_Object::GetUserData() to get user data.
  MyUserData* copy_of_ud = MyUserData::Cast( copy_of_point.GetUserData( my_user_data_uuid ) );

  if ( 0 == copy_of_ud )
    printf("ON_UserData::m_copy_count must be > 0 for user data to be copied.\n");
  else
    printf("copy_of_ud->m_userdata_copycount = %d\n",copy_of_ud->m_userdata_copycount);

  // When the point is transformed, the virtual ON_UserData::Transform()
  // is called to transform the point.


  // When the point is saved to a file, the virtual ON_Object::Write() is
  // called to write the attached user data.
  const char* filename = "my_point_with_user_data.3dm";
  write_file( filename, point );

  // When the point is read from a file, the virtual ON_Object::Read() is
  // called to read the user data.
  ON_Object* object_from_file = 0;
  read_file( filename, object_from_file );

  if ( 0 != object_from_file )
  {
    // Use ON_Object::GetUserData() to get user data.
    MyUserData* ud_from_file = MyUserData::Cast( object_from_file->GetUserData( my_user_data_uuid ) );

    printf("ud_from_file->m_userdata_copycount = %d\n",ud_from_file->m_userdata_copycount);

    // Clean up
    delete object_from_file;
    object_from_file = 0;
  }

  ON::End();

  return 0;
}
blob
data 44196
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2011 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/


// uncomment the "ON_DLL_IMPORTS" define to use opennurbs as a Windows DLL
//#define ON_DLL_IMPORTS
#include "../opennurbs.h"
#include "../examples_linking_pragmas.h"

#include "../example_userdata/example_ud.h"

static bool write_simple_file_example(
            FILE* fp,
            int version,
            ON_TextLog& error_log,
            const char* sNotes,
            const ON_3dmSettings* settings,
            int material_count, const ON_Material* material,  // optional rendering material
            int layer_count,    const ON_Layer* layer,        // optional layer definitions
            int light_count,
            const ON_3dmObjectAttributes* light_attributes, // optional light attributes
            ON_Light*                     light,            // lights
            int object_count,
            const ON_3dmObjectAttributes* object_attributes, // optional object attributes
            ON_Object**                   object      // objects
            )
{
  ONX_Model model;
  int i;
  ON_3dmObjectAttributes attribs;


  // some notes
  model.m_properties.m_Notes.m_notes = sNotes;
  model.m_properties.m_Notes.m_bVisible = (model.m_properties.m_Notes.m_notes.Length() > 0);

  // set revision history information
  model.m_properties.m_RevisionHistory.NewRevision();
  
  // set application information
  model.m_properties.m_Application.m_application_name = "OpenNURBS write_simple_file_example() function";
  model.m_properties.m_Application.m_application_URL = "http://www.opennurbs.org";
  model.m_properties.m_Application.m_application_details = "Example program in OpenNURBS toolkit.";


  if ( 0 != settings )
    model.m_settings = *settings;

  if ( 0 != material && material_count > 0 )
  {
    model.m_material_table.Reserve(material_count);
    for ( i = 0; i < material_count; i++ )
      model.m_material_table.Append(material[i]);
  }

  // layer table
  {
    // Each object in the object table (written below)
    // should to be on a defined layer.  There should be
    // at least one layer with layer index 0 in every file.

    // layer table indices begin at 0
    ON_Layer default_layer;
    default_layer.SetLayerIndex(0);
    default_layer.SetLayerName("Default");
    if ( 0 == layer || layer_count <= 0 || layer[0].LayerIndex() != 0 ) {
      layer = &default_layer;
      layer_count = 1;
    }

    model.m_layer_table.Reserve(layer_count);
    for ( i = 0; i < layer_count; i++ ) 
    {
      // check that layer index is correct
      if ( layer[i].LayerIndex() != i ) 
      {
        error_log.Print("error: layer[%d].LayerIndex() == %d\n",i,layer[i].LayerIndex());
        layer_count = i;
        break;
      }
      // check that layer's material index is correct
      if (    layer[i].RenderMaterialIndex() < -1 
           || layer[i].RenderMaterialIndex() >= material_count ) 
      {
        error_log.Print("error: layer[%d].RenderMaterialIndex() == %d\n",i,layer[i].RenderMaterialIndex());
        layer_count = i;
        break;
      }
      model.m_layer_table.Append(layer[i]);
    }
  }

  if ( 0 != light && light_count > 0 )
  {
    for ( i = 0; i < light_count; i++ ) 
    {
      ONX_Model_RenderLight& mrl = model.m_light_table.AppendNew();
      mrl.m_light = light[i];
      if ( light_attributes )
        mrl.m_attributes = light_attributes[i];
    }
  }

  if ( 0 != object && object_count > 0 )
  {
    for ( i = 0; i < object_count; i++ ) 
    {
      // get object attributes and make sure layer and material indices are legit
      if ( object[i] ) 
      {
        ONX_Model_Object& mo = model.m_object_table.AppendNew();
        mo.m_object = object[i];
        mo.m_bDeleteObject = false;
        if ( object_attributes )
          mo.m_attributes = object_attributes[i];
      }
    }
  }

  // archive to write to
  ON_BinaryFile archive( ON::write3dm, fp );

  // Set uuid's, indices, etc.
  model.Polish();
  // writes model to archive
  bool ok = model.Write( archive,
                         version, 
                         __FILE__ " write_simple_file_example() " __DATE__, 
                         &error_log );

  return ok;
}

static bool write_points_example( FILE* fp, int version, ON_TextLog& error_log  )
{
  // example demonstrates how to write a singe points and point clouds
  ONX_Model model;


  // file properties (notes, preview image, revision history, ...)
  {
    // set revision history information
    model.m_properties.m_RevisionHistory.NewRevision();
    
    // set application information
    model.m_properties.m_Application.m_application_name = "OpenNURBS write_points_example() function";
    model.m_properties.m_Application.m_application_URL = "http://www.opennurbs.org";
    model.m_properties.m_Application.m_application_details = "Example program in OpenNURBS toolkit.";

    {
      // OPTIONAL - add some notes
      model.m_properties.m_Notes.m_notes = "This file was made with the OpenNURBS write_points_example() function.";
      model.m_properties.m_Notes.m_bVisible = true;
    }
  }

  // file settings (units, tolerances, views, ...)
  {
    // OPTIONAL - change values from defaults
    model.m_settings.m_ModelUnitsAndTolerances.m_unit_system = ON::meters;
    model.m_settings.m_ModelUnitsAndTolerances.m_absolute_tolerance = 0.01;
    model.m_settings.m_ModelUnitsAndTolerances.m_angle_tolerance = ON_PI/180.0; // radians
    model.m_settings.m_ModelUnitsAndTolerances.m_relative_tolerance = 0.01; // 1%
  }

  // layer table
  {
    // define some layers
    ON_Layer layer[3];

    layer[0].SetLayerName("Default");
    layer[0].SetVisible(true);
    layer[0].SetLocked(false);
    layer[0].SetLayerIndex(0);
    layer[0].SetColor( ON_Color(0,0,0) );

    layer[1].SetLayerName("red points");
    layer[1].SetVisible(true);
    layer[1].SetLocked(false);
    layer[1].SetLayerIndex(1);
    layer[1].SetColor( ON_Color(255,0,0) );

    layer[2].SetLayerName("one blue point");
    layer[2].SetVisible(true);
    layer[2].SetLocked(false);
    layer[2].SetLayerIndex(2);
    layer[2].SetColor( ON_Color(0,0,255) );

    model.m_layer_table.Append(layer[0]);
    model.m_layer_table.Append(layer[1]);
    model.m_layer_table.Append(layer[2]);
  }

  // group table
  {
    // we'll put 2 red and one blue point in a group
    ON_Group group;
    group.SetGroupName("group of points");
    group.SetGroupIndex(0);
    model.m_group_table.Append(group);
  }

  // object table

  // single point at (1,4,5) on default layer
  ON_Point point1(ON_3dPoint( 1.0, 4.0, 5.0 ));
  point1.AttachUserData( new CExampleWriteUserData("write_points_example()-point1") );
  {
    ONX_Model_Object& mo = model.m_object_table.AppendNew();
    mo.m_object = &point1;
    mo.m_bDeleteObject = false; // point1 is on the stack
    mo.m_attributes.m_layer_index = 0;
    mo.m_attributes.m_name = "first point";
  }

  // point "cloud" with 3 points on red point cloud layer
  ON_PointCloud* pointcloud = new ON_PointCloud();
  pointcloud->AppendPoint(ON_3dPoint( 1.0, 6.0, 5.0 ));
  pointcloud->AppendPoint(ON_3dPoint( 1.5, 4.5, 6.0 ));
  pointcloud->AppendPoint(ON_3dPoint( 2.0, 5.0, 7.0 ));

  pointcloud->AttachUserData( new CExampleWriteUserData("write_points_example()-pointcloud") );
  {
    ONX_Model_Object& mo = model.m_object_table.AppendNew();
    mo.m_object = pointcloud;
    mo.m_bDeleteObject = true; // ~ONX_Model will delete pointcloud.
    mo.m_attributes.m_layer_index = 1;
    mo.m_attributes.AddToGroup(0); // put these points in the group
    mo.m_attributes.m_name = "3 points";
  }

  // single point at (3,2,4) on red point layer
  ON_Point point2(ON_3dPoint( 3.0, 2.0, 4.0  ));
  point2.AttachUserData( new CExampleWriteUserData("write_points_example()-point2") );
  {
    ONX_Model_Object& mo = model.m_object_table.AppendNew();
    mo.m_object = &point2;
    mo.m_bDeleteObject = false;
    mo.m_attributes.m_layer_index = 2;
    mo.m_attributes.AddToGroup(0); // put this points in the group
    mo.m_attributes.m_name = "last point";
  }

  ON_BinaryFile archive( ON::write3dm, fp ); // fp = pointer from fopoen(...,"wb")

  // start section comment
  const char* sStartSectionComment = __FILE__ "write_points_example()" __DATE__;

  // Set uuid's, indices, etc.
  model.Polish();
  // writes model to archive
  bool ok = model.Write( archive, version, sStartSectionComment, &error_log );

  return ok;
}



static bool write_curves_example( FILE* fp, int version, ON_TextLog& error_log )
{
  // example demonstrates how to write a NURBS curve, line, and circle
  ONX_Model model;

  // file properties (notes, preview image, revision history, ...)

  // set revision history information
  model.m_properties.m_RevisionHistory.NewRevision();

  // set application information
  model.m_properties.m_Application.m_application_name = "OpenNURBS write_curves_example() function";
  model.m_properties.m_Application.m_application_URL = "http://www.opennurbs.org";
  model.m_properties.m_Application.m_application_details = "Example program in OpenNURBS toolkit.";

  // some notes
  model.m_properties.m_Notes.m_notes = "This file was made with the OpenNURBS write_curves_example() function.";
  model.m_properties.m_Notes.m_bVisible = true;


  // file settings (units, tolerances, views, ...)
  model.m_settings.m_ModelUnitsAndTolerances.m_unit_system = ON::inches;
  model.m_settings.m_ModelUnitsAndTolerances.m_absolute_tolerance = 0.001;
  model.m_settings.m_ModelUnitsAndTolerances.m_angle_tolerance = ON_PI/180.0; // radians
  model.m_settings.m_ModelUnitsAndTolerances.m_relative_tolerance = 0.01; // 1%


  // layer table
  {
    // OPTIONAL - define some layers
    ON_Layer layer[3];

    layer[0].SetLayerName("Default");
    layer[0].SetVisible(true);
    layer[0].SetLocked(false);
    layer[0].SetColor( ON_Color(0,0,0) );

    layer[1].SetLayerName("green NURBS wiggle");
    layer[1].SetVisible(true);
    layer[1].SetLocked(false);
    layer[1].SetLayerIndex(1);
    layer[1].SetColor( ON_Color(0,255,0) );

    layer[2].SetLayerName("blue circles");
    layer[2].SetVisible(true);
    layer[2].SetLocked(false);
    layer[2].SetLayerIndex(2);
    layer[2].SetColor( ON_Color(0,0,255) );

    model.m_layer_table.Append(layer[0]);
    model.m_layer_table.Append(layer[1]);
    model.m_layer_table.Append(layer[2]);
  }


  // object table
  {

    {
      // write a line on the default layer
      ONX_Model_Object& mo = model.m_object_table.AppendNew();
      mo.m_object = new ON_LineCurve( ON_Line( ON_3dPoint(1.0,2.0,-1.5), ON_3dPoint(5.0,3.0,2.0) ) );
      mo.m_bDeleteObject = true;
      mo.m_attributes.m_layer_index = 0;
      mo.m_attributes.m_name = "straight line curve";

    }

    {
      // write a wiggly cubic curve on the "green NURBS wiggle" layer
      ON_NurbsCurve* wiggle = new ON_NurbsCurve(
        3, // dimension
        false, // true if rational
        4,     // order = degree+1
        6      // number of control vertices
        );
      int i;
      for ( i = 0; i < wiggle->CVCount(); i++ ) {
        ON_3dPoint pt( 2*i, -i, (i-3)*(i-3) ); // pt = some 3d point
        wiggle->SetCV( i, pt );
      }

      // ON_NurbsCurve's have order+cv_count-2 knots.
      wiggle->SetKnot(0, 0.0);
      wiggle->SetKnot(1, 0.0);
      wiggle->SetKnot(2, 0.0);
      wiggle->SetKnot(3, 1.5);
      wiggle->SetKnot(4, 2.3);
      wiggle->SetKnot(5, 4.0);
      wiggle->SetKnot(6, 4.0);
      wiggle->SetKnot(7, 4.0);

      
      if ( wiggle->IsValid() ) 
      {
        ONX_Model_Object& mo = model.m_object_table.AppendNew();
        mo.m_object = wiggle;
        mo.m_bDeleteObject = true;
        mo.m_attributes.m_layer_index = 1;
        mo.m_attributes.m_name = "wiggly cubic curve";
      }
      else
        delete wiggle;
    }

    {
      // write two circles on the "blue circles"
      ONX_Model_Object& circle1 = model.m_object_table.AppendNew();
      circle1.m_object = new ON_ArcCurve( ON_Circle( ON_3dPoint(1.0,2.0,-1.5), 3.0 ) );
      circle1.m_bDeleteObject = true;
      circle1.m_attributes.m_layer_index = 2;
      circle1.m_attributes.m_name = "radius 3 circle";

      ONX_Model_Object& circle2 = model.m_object_table.AppendNew();
      circle2.m_object = new ON_ArcCurve( ON_Circle( ON_3dPoint(1.0,2.0,-1.5), 5.0 ) );
      circle2.m_bDeleteObject = true;
      circle2.m_attributes.m_layer_index = 2;
      circle2.m_attributes.m_name = "radius 5 circle";
    }

  }

  // start section comments
  const char* sStartSectionComment = __FILE__ "write_curves_example()" __DATE__;

  ON_BinaryFile archive( ON::write3dm, fp ); // fp = pointer from fopoen(...,"wb")

  // Set uuid's, indices, etc.
  model.Polish();
  // writes model to archive
  bool ok = model.Write(archive, version, sStartSectionComment, &error_log );

  return ok;
}


static bool write_surfaces_example( FILE* fp, int version )
{
  // example demonstrates how to write a NURBS surface

  //////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////

  // The code between the comment bands has nothing to do with I/O.
  // It is simply an easy way to get a NURBS surface to write.
  const int bIsRational = false;
  const int dim = 3;
  const int u_degree = 2;
  const int v_degree = 3;
  const int u_cv_count = 3;
  const int v_cv_count = 5;

  // The knot vectors do NOT have the 2 superfluous knots
  // at the start and end of the knot vector.  If you are
  // coming from a system that has the 2 superfluous knots,
  // just ignore them when writing a 3dm file.
  double u_knot[ u_cv_count + u_degree - 1 ];
  double v_knot[ v_cv_count + v_degree - 1 ];

  // make up a quadratic knot vector with no interior knots
  u_knot[0] = u_knot[1] = 0.0;
  u_knot[2] = u_knot[3] = 1.0;

  // make up a cubic knot vector with one simple interior knot
  v_knot[0] = v_knot[1] = v_knot[2] = 0.0;
  v_knot[3] = 1.5;
  v_knot[4] = v_knot[5] = v_knot[6] = 2.0;

  // Rational control points can be in either homogeneous
  // or euclidean form. Non-rational control points do not
  // need to specify a weight.  
  ON_3dPoint CV[u_cv_count][v_cv_count];

  int i, j;
  for ( i = 0; i < u_cv_count; i++ ) {
    for ( j = 0; j < v_cv_count; j++ ) {
      CV[i][j].x = i;
      CV[i][j].y = j;
      CV[i][j].z = i-j;
    }
  }

  // write a line on the default layer
  ON_NurbsSurface nurbs_surface( dim, bIsRational, 
                        u_degree+1, v_degree+1,
                        u_cv_count, v_cv_count );

  for ( i = 0; i < nurbs_surface.KnotCount(0); i++ )
    nurbs_surface.SetKnot( 0, i, u_knot[i] );

  for ( j = 0; j < nurbs_surface.KnotCount(1); j++ )
    nurbs_surface.SetKnot( 1, j, v_knot[j] );

  for ( i = 0; i < nurbs_surface.CVCount(0); i++ ) {
    for ( j = 0; j < nurbs_surface.CVCount(1); j++ ) {
      nurbs_surface.SetCV( i, j, CV[i][j] );
    }
  }

  bool ok = false;
  if ( nurbs_surface.IsValid() ) 
  {
    ON_BinaryFile archive( ON::write3dm, fp );
    ok = ON_WriteOneObjectArchive( archive, version, nurbs_surface );
  }

  return ok;
}


static bool write_mesh_example( FILE* fp, int version )
{
  // example demonstrates how to create and write a mesh

  // create a mesh to write
  // The mesh is a pyramid with 4 triangular sides and a quadranglar 
  // base.  The mesh has 5 vertices and 5 faces.  
  // The side faces share normals at their common vertices.  The
  // quadrangular base has normals different from the side normal.
  // Coincident vertices that have distinct normals must be
  // duplicated in the vertex list.
  //
  // The apex will be at (1,1.5,4) with normal (0,0,1).
  // The base corners will be at (0,0,0), (0,2,0), (2,3,0), (0,3,0).


  bool bHasVertexNormals = true; // we will specify vertex normals
  bool bHasTexCoords = false;    // we will not specify texture coordinates
  const int vertex_count = 5+4;  // 4 duplicates for different base normals
  const int face_count = 5; // 4 triangle sides and a quad base
  ON_Mesh mesh( face_count, vertex_count, bHasVertexNormals, bHasTexCoords);

  // The SetVertex(), SetNormal(), SetTCoord() and SetFace() functions
  // return true if successful and false if input is illegal.  It is
  // a good idea to inspect this returned value.

  // vertex #0: apex location and normal
  mesh.SetVertex( 0, ON_3dPoint(1.0,  1.5,  5.0) );
  mesh.SetVertexNormal( 0, ON_3dVector(0.0,  0.0,  1.0) );

  // vertex #1: SW corner vertex for sides
  mesh.SetVertex( 1, ON_3dPoint(0.0,  0.0,  0.0) );
  mesh.SetVertexNormal( 1, ON_3dVector(-1.0, -1.0,  0.0) ); // set normal will unitize if needed

  // vertex #2: SE corner vertex for sides
  mesh.SetVertex( 2, ON_3dPoint(2.0,  0.0,  0.0) );
  mesh.SetVertexNormal( 2, ON_3dVector(+1.0, -1.0,  0.0) );

  // vertex #3: NE corner vertex for sides
  mesh.SetVertex( 3, ON_3dPoint(2.0,  3.0,  0.0) );
  mesh.SetVertexNormal( 3, ON_3dVector(+1.0, +1.0,  0.0) );

  // vertex #4: NW corner vertex for sides
  mesh.SetVertex( 4, ON_3dPoint(0.0,  3.0,  0.0) );
  mesh.SetVertexNormal( 4, ON_3dVector(-1.0, +1.0,  0.0) );

  // vertex #5: SW corner vertex for base
  mesh.SetVertex( 5, ON_3dPoint(0.0,  0.0,  0.0) ); // == location of v1
  mesh.SetVertexNormal( 5, ON_3dVector(0.0,  0.0, -1.0) );

  // vertex #6: SE corner vertex for base
  mesh.SetVertex( 6, ON_3dPoint(2.0,  0.0,  0.0) ); // == location of v2
  mesh.SetVertexNormal( 6, ON_3dVector(0.0,  0.0, -1.0) );

  // vertex #7: SW corner vertex for base
  mesh.SetVertex( 7, ON_3dPoint(2.0,  3.0,  0.0) ); // == location of v3
  mesh.SetVertexNormal( 7, ON_3dVector(0.0,  0.0, -1.0) );

  // vertex #8: SW corner vertex for base
  mesh.SetVertex( 8, ON_3dPoint(0.0,  3.0,  0.0) ); // == location of v4
  mesh.SetVertexNormal( 8, ON_3dVector(0.0,  0.0, -1.0) );

  // faces have vertices ordered counter-clockwise

  // South side triangle
  mesh.SetTriangle( 0,   1, 2, 0 );

  // East side triangle
  mesh.SetTriangle( 1,   2, 3, 0 );

  // North side triangle
  mesh.SetTriangle( 2,   3, 4, 0 );

  // West side triangle
  mesh.SetTriangle( 3,   4, 1, 0 );

  // last face is quadrangular base
  mesh.SetQuad( 4,   5, 8, 7, 6 );

  //////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////

  bool ok = false;
  if ( mesh.IsValid() ) 
  {
    // Most applications expect vertex normals.
    // If they are not present, ComputeVertexNormals sets
    // them by averaging face normals.
    if ( !mesh.HasVertexNormals() )
      mesh.ComputeVertexNormals();
    ON_BinaryFile archive( ON::write3dm, fp );
    ok = ON_WriteOneObjectArchive( archive, version, mesh );
  }

  return ok;
}

static bool write_mesh_with_material_example( FILE* fp, int version, ON_TextLog& error_log )
{
  // example demonstrates how to create and write a mesh that uses
  // a rendering material.  You may want to study write_mesh_example() 
  // before examining this function.
  //
  // The key to attaching a texture is to create a mesh
  // with texture coordinates, create a material using the
  // texture as a bitmap, and to attach the material to the
  // mesh before writing the mesh.


  bool bHasVertexNormals = false; // we will NOT specify vertex normals
  bool bHasTexCoords = true;      // we will specify texture coordinates
  const int vertex_count = 40;
  const int face_count = 28;
  ON_Mesh mesh( face_count, vertex_count, bHasVertexNormals, bHasTexCoords);

  // The SetVertex(), SetNormal(), SetTextureCoord() and SetQuad() functions
  // return true if successful and false if input is illegal.  It is
  // a good idea to inspect this returned value.

  // cook up a 5 x 8 grid of vertices
  int vertex_index = 0;
  int i, j;
  for ( i = 0; i <= 4; i++ ) {
    for ( j = 0; j <= 7; j++ ) {
      ON_3fPoint v( (float)i, (float)j, (float)(sin( 2.0*3.14159*j/7.0 ) + cos( 3.14159*i/4.0 )) );
      mesh.SetVertex( vertex_index, v ); // 3d location

      // normalized texture coordinate
      double tcoord_u = i/4.0;
      double tcoord_v = j/7.0;
      mesh.SetTextureCoord( vertex_index, tcoord_u, tcoord_v ); // 2d texture coordinate

      vertex_index++;
    }
  }

  // faces have vertices ordered counter-clockwise

  // cook up a 4 x 7 grid of quadrangular faces
  int face_index = 0;
  for ( i = 0; i < 4; i++ ) {
    for ( j = 0; j < 7; j++ ) {
      int vi[4]; // indices of corner vertices
      vi[0] = i*8 + j;  // vertex at "lower left" corner
      vi[1] = vi[0]+8;  // vertex at "lower right" corner
      vi[2] = vi[1]+1;  // vertex at "upper left" corner
      vi[3] = vi[0]+1;  // vertex at "upper right" corner
      mesh.SetQuad( face_index, vi[0], vi[1], vi[2], vi[3] );
      face_index++;
    }
  }


  // rendering material with a texture map.
  ON_Material material;
  material.SetMaterialIndex(0);
  material.SetAmbient(  ON_Color(  40,  40,  40 ) );
  material.SetDiffuse(  ON_Color( 220, 220, 220 ) );
  material.SetEmission( ON_Color(   0,   0,   0 ) );
  material.SetSpecular( ON_Color( 180, 180, 180 ) );

  material.SetShine( 0.35*ON_Material::MaxShine() ); // 0 = flat
                                                        // MaxShine() = shiney

  material.SetTransparency( 0.2 );  // 0 = opaque, 1 = transparent

  // Texture and bump bitmaps can be Windows bitmap (.BMP), Targa (.TGA),
  // JPEG (.JPG), PCX or PNG files.  Version 1 of Rhino will not support
  // filenames using unicode or multibyte character sets.  As soon as
  // Rhino supports these character sets, the const char* filename will
  // changed to const _TCHAR*.

  // For Rhino to find the texture bitmap, the .3dm file and the
  // .bmp file need to be in the same directory.
  ON_Texture texture;
  texture.m_filename = L"example_texture.bmp";
  material.AddTexture( texture );

  // The render material name is a string used to identify rendering
  // materials in RIB, POV, OBJ, ..., files.  In Rhino, the render
  // material name is set with the SetObjectMaterial command and can
  // be viewed in the Info tab of the dialog displayed by the
  // Properties command.
  material.SetMaterialName( L"my render material" );

  bool ok = false;
  if ( mesh.IsValid() ) 
  {
    // Most applications expect vertex normals.
    // If they are not present, ComputeVertexNormals sets
    // them by averaging face normals.
    if ( !mesh.HasVertexNormals() )
      mesh.ComputeVertexNormals();

    ON_Object* object[1];
    object[0] = &mesh;
    ON_3dmObjectAttributes attributes;
    attributes.m_name = "my mesh with material";
    attributes.m_material_index = 0;
    attributes.SetMaterialSource( ON::material_from_object );
    ok = write_simple_file_example( fp, version, error_log,
         "OpenNURBS write_mesh_with_material_example()", // notes
         NULL,               // default settings
         1, &material,       // render material table
         0, NULL,            // layer table
         0,                  // light count
         NULL,               // light attributes
         NULL,               // lights
         1,                  // object count
         &attributes,        // array of object_count attributes
         object              // array of object_count objects
         );
  }

  return ok;
}

static bool write_spot_light_example( FILE* fp, int version, ON_TextLog& error_log )
{
  // create a blue spotlight shining on a white plane

  // white material for surface
  ON_Material material;
  ON_Color white(255,255,255);
  ON_Color black(0,0,0);
  material.SetMaterialIndex(0);
  material.SetAmbient(  white );
  material.SetDiffuse(  white );
  material.SetEmission( black );
  material.SetSpecular( white );
  material.SetShine( 0.35*ON_Material::MaxShine() ); // 0 = flat
                                                        // MaxShine() = shiney
  material.SetTransparency( 0.0 );  // 0 = opaque, 1 = transparent
  material.SetMaterialName( L"white material" );


  // 2 layers
  ON_Layer layer[2];
  layer[0].SetLayerName(L"surfaces");
  layer[0].SetVisible(true);
  layer[0].SetLocked(false);
  layer[0].SetLayerIndex(0);
  layer[0].SetColor( ON_Color(0, 0, 0) );

  layer[1].SetLayerName(L"lights");
  layer[1].SetVisible(true);
  layer[1].SetLocked(false);
  layer[1].SetLayerIndex(1);
  layer[1].SetColor( ON_Color(0, 0, 0) );


  // spotlight
  ON_Light light;
  light.SetLightIndex(0);
  light.SetLocation( ON_3dPoint(2.0, 3.0, 10.0) );
  light.SetDirection( ON_3dVector(-1.0, -1.0, -10.0) );
  light.SetDiffuse( ON_Color( 0, 0, 255 ) );
  light.SetAmbient( ON_Color( 0, 0, 0 ) );
  light.SetSpecular( ON_Color( 0, 0, 255 ) );
  light.SetSpotExponent( 60 );    // 0 = hard, 128 = soft
  light.SetSpotAngleDegrees( 30.0 );
  light.SetStyle(ON::world_spot_light);

  light.SetLightName( "Blue spot light" );

  ON_3dmObjectAttributes light_attributes;
  light_attributes.Default();
  light_attributes.m_layer_index = 1;     // spotlights layer we defined above
  light_attributes.m_name = "Blue spot light";


  // quick and dirty plane
  ON_PlaneSurface plane (ON_xy_plane);
  plane.SetDomain( 0, -10.0, +10.0 );
  plane.SetDomain( 1, -10.0, +10.0 );

  ON_3dmObjectAttributes object_attributes;
  object_attributes.Default();
  object_attributes.m_layer_index = 0; // surfaces layer we defined above
  object_attributes.m_material_index = 0; // white material we defined above
  object_attributes.SetMaterialSource(ON::material_from_object);
  object_attributes.m_name = "20x20 plane";

  ON_Object* object[1];
  object[0] = &plane;
  bool ok = write_simple_file_example( fp, version, error_log,
       "OpenNURBS write_spot_light_example()", // notes
       NULL,               // default settings
       0, NULL,            // render material table
       0, NULL,            // layer table
       1,                  // light_count
       &light_attributes,  // array of light_count attributes
       &light,             // array of light_count lights
       1,                  // object_count
       &object_attributes, // array of object_count attributes
       object              // array of object_count objects
       );

  return ok;
}


static bool write_viewport_example( FILE* fp, int version, ON_TextLog& error_log,
      const ON_Sphere& sphere // sphere containing region to be viewed
       )
{
  // Writes a 7 viewport layout - 3 along the right side,
  // 3 along the left side, and 1 big on in the middle
  // that displays the space inside the sphere.

  // Viewports have a "target" point inside of the view frustum.
  // This target is the center of view rotations.

  // Viewports have a "construction plane".  This plane is
  // (optionally) displayed as a grid.
  //

  ON_3dmSettings settings;
  {
    // OPTIONAL - change values from defaults
    settings.m_ModelUnitsAndTolerances.m_unit_system = ON::millimeters;
    settings.m_ModelUnitsAndTolerances.m_absolute_tolerance = 0.01;
    settings.m_ModelUnitsAndTolerances.m_angle_tolerance = ON_PI/180.0; // radians
    settings.m_ModelUnitsAndTolerances.m_relative_tolerance = 0.01; // 1%
  }

  // reserve room for 7 views
  settings.m_views.Reserve(7);

  // some values needed to fill in view information
  const double pos_x[4]  = {0.0,0.25,0.75,1.0};       // x: 0 = left, 1 = right
  const double pos_y[4]  = {0.0,1.0/3.0,2.0/3.0,1.0}; // y: 0 = top, 1 = bottom
  ON_3dVector camDir;
  double fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far;
  double target_distance;

  fr_left   = -sphere.radius;
  fr_right  =  sphere.radius;
  fr_bottom = -sphere.radius;
  fr_top    =  sphere.radius;
  fr_near         = 2.0*sphere.radius; // Rhino's default
  target_distance = 3.0*sphere.radius;
  fr_far          = 4.0*sphere.radius;

  // view number 1
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = -ON_zaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_yaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "+X+Y parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[0];
    view.m_position.m_wnd_right = pos_x[1];
    view.m_position.m_wnd_top = pos_y[2];
    view.m_position.m_wnd_bottom = pos_y[3];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane = ON_xy_plane;
  }

  // view number 2
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = ON_yaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_zaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "+X+Z parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[0];
    view.m_position.m_wnd_right = pos_x[1];
    view.m_position.m_wnd_top = pos_y[1];
    view.m_position.m_wnd_bottom = pos_y[2];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane = ON_zx_plane;
  }

  // view number 3
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = -ON_xaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_zaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "+Y+Z parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[0];
    view.m_position.m_wnd_right = pos_x[1];
    view.m_position.m_wnd_top = pos_y[0];
    view.m_position.m_wnd_bottom = pos_y[1];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane = ON_yz_plane;
  }

  // view number 4
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = ON_zaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_yaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "-X+Y parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[2];
    view.m_position.m_wnd_right = pos_x[3];
    view.m_position.m_wnd_top = pos_y[2];
    view.m_position.m_wnd_bottom = pos_y[3];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane.CreateFromFrame( ON_origin, -ON_xaxis, ON_yaxis );
  }

  // view number 5
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = -ON_yaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_zaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "-X+Z parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[2];
    view.m_position.m_wnd_right = pos_x[3];
    view.m_position.m_wnd_top = pos_y[1];
    view.m_position.m_wnd_bottom = pos_y[2];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane.CreateFromFrame( ON_origin, -ON_xaxis, ON_zaxis );
  }

  // view number 6
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = ON_xaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_zaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "-Y+Z parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[2];
    view.m_position.m_wnd_right = pos_x[3];
    view.m_position.m_wnd_top = pos_y[0];
    view.m_position.m_wnd_bottom = pos_y[1];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane.CreateFromFrame( ON_origin, -ON_yaxis, ON_zaxis );
  }

  // view number 7
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    target_distance = 10.0*sphere.radius;
    const double tan_half_angle = sphere.radius / target_distance;

    view.m_vp.SetProjection( ON::perspective_view );
    camDir = ON_3dVector(-40.0,75.0,-50.0);
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_zaxis );
    fr_near   = (target_distance - sphere.radius)/10.0;
    fr_far    = target_distance + 1.5*sphere.radius;
    double d  = fr_near*tan_half_angle;
    fr_left   = -d;
    fr_right  =  d;
    fr_bottom = -d;
    fr_top    =  d;
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "skew perspective";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[1];
    view.m_position.m_wnd_right = pos_x[2];
    view.m_position.m_wnd_top = pos_y[0];
    view.m_position.m_wnd_bottom = pos_y[3];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane = ON_xy_plane;
  }


  bool ok = write_simple_file_example( fp, version, error_log,
         "OpenNURBS write_viewport_example()", // notes
         &settings,          // default settings
         0, NULL,            // render material table
         0, NULL,            // layer table
         0,                  // light count
         NULL,               // light attributes
         NULL,               // lights
         0,                  // object count
         NULL,               // array of object_count attributes
         NULL                // array of object_count objects
         );

  return ok;
}

static void make_trimming_curves( ON_Brep& brep, 
                                  const ON_2dPoint& A2, // start point in parameter space
                                  const ON_2dPoint& B2, // end point in parameter space
                                  const ON_3dPoint& A3, // start point in parameter space
                                  const ON_3dPoint& B3  // end point in parameter space
                                  )
{
  ON_LineCurve* p2dCurve = new ON_LineCurve( A2, B2 );
  ON_LineCurve* p3dCurve = new ON_LineCurve( A3, B3 );

  // it is not necessary for the domains of the 2d and 3d curves
  // to match, but it makes it easier to understand the brep
  ON_Interval domain = p3dCurve->Domain();
  p2dCurve->SetDomain( domain.Min(), domain.Max() );

  brep.m_C2.Append(p2dCurve);

  brep.m_C3.Append(p3dCurve);
}


static bool write_trimmed_surface_example( FILE* fp, int version, ON_TextLog& error_log )
{
  // trimmed surfaces are written as a CRhinoBrep that has
  // a single surface and a single CRhinoBrepFace.
  //
  // Trimming loops are simple closed curves and are oriented
  // so that the active portion of the trimmed surface's
  // domain lies to the left of the trimming curves.

  ON_Brep brep;
  ON_2dPoint q;

  // Create a 10x10 plane surface at z=3 with domain [0,1]x[0,1]
  ON_PlaneSurface* pSurface = new ON_PlaneSurface( ON_Plane( ON_3dPoint( 0, 0,3), 
                                                             ON_3dPoint(10,10,3), 
                                                             ON_3dPoint(10, 0,3) ) );
  pSurface->SetDomain(0,0.0,10.0);
  pSurface->SetDomain(1,0.0,10.0);

  // ~ON_Brep() will delete this surface
  const int si = brep.m_S.Count(); // index of surface
  brep.m_S.Append(pSurface);

  // create simple trimming triangle
  ON_2dPoint A2(1.0, 2.0); // parameter space locations of 2d trim corners
  ON_2dPoint B2(9.0, 1.5);
  ON_2dPoint C2(7.0, 8.0);

  ON_3dPoint A3 = pSurface->PointAt(A2.x,A2.y);
  ON_3dPoint B3 = pSurface->PointAt(B2.x,B2.y);
  ON_3dPoint C3 = pSurface->PointAt(C2.x,C2.y);

  make_trimming_curves( brep, A2, B2, A3, B3 ); // creates 2d and 3d curve
  make_trimming_curves( brep, B2, C2, B3, C3 );
  make_trimming_curves( brep, C2, A2, C3, A3 );

  // there are vertices at the 3 corners
  brep.NewVertex( pSurface->PointAt( A2.x, A2.y ) );
  brep.NewVertex( pSurface->PointAt( B2.x, B2.y ) );
  brep.NewVertex( pSurface->PointAt( C2.x, C2.y ) );

  // the vertices are exact since we have lines on a plane
  brep.m_V[0].m_tolerance = 0.0;
  brep.m_V[1].m_tolerance = 0.0;
  brep.m_V[2].m_tolerance = 0.0;

  // there are 3 edges along the sides of the triangle
  brep.NewEdge( brep.m_V[0], brep.m_V[1], 0 ); // start vertex, end vertex, 3d curve index
  brep.NewEdge( brep.m_V[1], brep.m_V[2], 1 ); // start vertex, end vertex, 3d curve index
  brep.NewEdge( brep.m_V[2], brep.m_V[0], 2 ); // start vertex, end vertex, 3d curve index

  // the edges are exact since we have lines on a plane
  brep.m_E[0].m_tolerance = 0.0;
  brep.m_E[1].m_tolerance = 0.0;
  brep.m_E[2].m_tolerance = 0.0;

  // there is 1 face
  ON_BrepFace& face = brep.NewFace( si );

  // outer boundary trimming loops
  ON_BrepLoop& loop = brep.NewLoop( ON_BrepLoop::outer, face );

  // geometrically, loops are made from a contiguous list of 2d parameter space
  // curves that form a simple closed curve.
  brep.NewTrim( brep.m_E[0], false, loop, 0 ); // A to B
  brep.NewTrim( brep.m_E[1], false, loop, 1 ); // B to C
  brep.NewTrim( brep.m_E[2], false, loop, 2 ); // C to A

  // the trims are exact since we have lines on a plane
  q = brep.m_C2[0]->PointAtStart();
  //brep.m_T[0].m_P[0] = pSurface->PointAt(q.x,q.y);
  q = brep.m_C2[0]->PointAtEnd();
  //brep.m_T[0].m_P[1] = pSurface->PointAt(q.x,q.y);
  brep.m_T[0].m_type = ON_BrepTrim::boundary;
  brep.m_T[0].m_tolerance[0] = 0.0;
  brep.m_T[0].m_tolerance[1] = 0.0;

  q = brep.m_C2[0]->PointAtStart();
  //brep.m_T[1].m_P[0] = pSurface->PointAt(q.x,q.y);
  q = brep.m_C2[0]->PointAtEnd();
  //brep.m_T[1].m_P[1] = pSurface->PointAt(q.x,q.y);
  brep.m_T[1].m_type = ON_BrepTrim::boundary;
  brep.m_T[1].m_tolerance[0] = 0.0;
  brep.m_T[1].m_tolerance[1] = 0.0;

  q = brep.m_C2[0]->PointAtStart();
  //brep.m_T[2].m_P[0] = pSurface->PointAt(q.x,q.y);
  q = brep.m_C2[0]->PointAtEnd();
  //brep.m_T[2].m_P[1] = pSurface->PointAt(q.x,q.y);
  brep.m_T[2].m_type = ON_BrepTrim::boundary;
  brep.m_T[2].m_tolerance[0] = 0.0;
  brep.m_T[2].m_tolerance[1] = 0.0;

    // when debugging your code, IsValid(), IsSolid(), IsManifold() are useful
  // to check.

  bool ok = false;
  if ( brep.IsValid( &error_log ) )
  {
    ON_BinaryFile archive(ON::write3dm,fp);
    ok = ON_WriteOneObjectArchive( archive, version, brep );
  }
  
  int bIsManifold, bIsOriented, bHasBoundary, bIsSolid;
  bIsManifold = brep.IsManifold( &bIsOriented, &bHasBoundary );
  bIsSolid = brep.IsSolid();

  return ok;
}

//int main ( int argc, const char* argv[] )
int main ()
{
  bool rc;
  const char* filename;

  ON::Begin();
  // If you want to learn to write b-rep models, first work through
  // this example paying close attention to write_trimmed_surface_example(),
  // then examime example_brep.cpp.

  // The OpenNURBS toolkit will write version 2 and 3 and read
  // version 1, 2 and 3 of the 3DM file format.
  //
  // version 1 is the legacy Rhino I/O tookit format and was used by Rhino 1.x.
  // version 2 is the OpenNURBS format (released 1 July 2000) and is used by Rhino 2.x
  // version 3 is the OpenNURBS format (released 1 November 2002) and is used by Rhino 3.x
  // version 4 is the OpenNURBS format (released September 2006) and is used by Rhino 4.x
  // version 5 is the OpenNURBS format (released September 2009) and is used by Rhino 5.x

  // version to write
  int version = 0; // version will be ON_BinaryArchive::CurrentArchiveVersion()

  // errors printed to stdout
  ON_TextLog error_log;

  // messages printed to stdout
  ON_TextLog message_log;

  // errors logged in text file
  //FILE* error_log_fp = ON::OpenFile("error_log.txt","w");
  //ON_TextLog error_log(error_log_fp);

  filename = "my_points.3dm";
  FILE* fp = ON::OpenFile( filename, "wb" );
  rc = write_points_example( fp, version, error_log );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_curves.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_curves_example( fp, version, error_log );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_surfaces.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_surfaces_example( fp, version );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_mesh.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_mesh_example( fp, version );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_mesh_with_material.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_mesh_with_material_example( fp, version, error_log );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_spot_light.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_spot_light_example( fp, version, error_log );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_viewports.3dm";
  fp = ON::OpenFile( filename, "wb" );
  // views will display space inside the sphere
  ON_Sphere sphere ( ON_origin, 10.0 );
  rc = write_viewport_example( fp, version, error_log, sphere );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_trimmed_surface.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_trimmed_surface_example( fp, version, error_log );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  ON::End();

  return 0;
}
blob
data 328951
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

#include "opennurbs.h"


////////////////////////////////////////////////////////////////
//   Class ON_BrepVertex
////////////////////////////////////////////////////////////////

ON_OBJECT_IMPLEMENT(ON_BrepVertex,ON_Point,"60B5DBC0-E660-11d3-BFE4-0010830122F0");

static bool ON_BrepIsNotValid()
{
  return ON_IsNotValid(); // <-- good place for a breakpoint
}


ON_BrepVertex::ON_BrepVertex()
              : m_vertex_index(-1),
                m_tolerance(ON_UNSET_VALUE)
{
  memset(&m_vertex_user,0,sizeof(m_vertex_user));
}

ON_BrepVertex::ON_BrepVertex( int vertex_index ) 
              : m_vertex_index(vertex_index),
                m_tolerance(ON_UNSET_VALUE)
{
  memset(&m_vertex_user,0,sizeof(m_vertex_user));
}

unsigned int ON_BrepVertex::SizeOf() const
{
  unsigned int sz = ON_Geometry::SizeOf();
  sz += (sizeof(*this) - sizeof(ON_Geometry));
  sz += m_ei.SizeOfArray();
  return sz;
}

ON_BrepVertex& ON_BrepVertex::operator=(const ON_BrepVertex& src)
{
  if ( &src != this ) {
    ON_Point::operator=(src);
    m_vertex_user   = src.m_vertex_user;
    m_vertex_index  = src.m_vertex_index;
    m_ei            = src.m_ei;
    m_tolerance     = src.m_tolerance;
  }
  return *this;
}

ON_BOOL32 
ON_BrepVertex::IsValid( ON_TextLog* text_log ) const
{
  if (m_vertex_index < 0)
  {
    if ( text_log )
      text_log->Print("ON_BrepVertex m_vertex_index = %d.  Should be >= 0\n",m_vertex_index);
    return ON_BrepIsNotValid();
  }
  const int ve_count = EdgeCount();
  int vei, ei;
  for ( vei = 0; vei < ve_count; vei++ ) {
    ei = m_ei[vei];
    if ( ei < 0 )
    {
      if ( text_log )
        text_log->Print("ON_BrepVertex m_ei[%d] = %d.  m_ei[] values should be >= 0\n",vei,ei);
      return ON_BrepIsNotValid();
    }
  }
  return ON_Point::IsValid(text_log);
}

void 
ON_BrepVertex::Dump( ON_TextLog& dump ) const
{
  dump.Print("ON_BrepVertex[%d]: ",m_vertex_index);
  dump.Print( point );
  dump.Print("\n");
}


bool
ON_BrepVertex::SetPoint( const ON_3dPoint& p )
{
  point = p;
  m_tolerance = ON_UNSET_VALUE;
  return true;
}

ON_3dPoint
ON_BrepVertex::Point() const
{
  return point;
}

double
ON_BrepVertex::Tolerance() const
{
  return m_tolerance;
}

int
ON_BrepVertex::EdgeCount() const
{
  return m_ei.Count();
}

////////////////////////////////////////////////////////////////
//   Class ON_BrepEdge
////////////////////////////////////////////////////////////////

ON_OBJECT_IMPLEMENT(ON_BrepEdge,ON_CurveProxy,"60B5DBC1-E660-11d3-BFE4-0010830122F0");

ON_BrepEdge::ON_BrepEdge() : ON_CurveProxy(0),
                         m_edge_index(-1),
                         m_c3i(-1),
                         m_tolerance(ON_UNSET_VALUE),
                         m_brep(0)
{
  memset(&m_edge_user,0,sizeof(m_edge_user));
  m_vi[0] = m_vi[1] = -1;
}

ON_BrepEdge::ON_BrepEdge(int edge_index ) : ON_CurveProxy(0),
                         m_edge_index(edge_index),
                         m_c3i(-1),
                         m_tolerance(ON_UNSET_VALUE),
                         m_brep(0)
{
  memset(&m_edge_user,0,sizeof(m_edge_user));
  m_vi[0] = m_vi[1] = -1;
}

ON::object_type ON_BrepEdge::ObjectType() const
{
  // This MUST return ON::curve_object.
  // NEVER change this to ON::edge_object.
  return ON::curve_object;
}

unsigned int ON_BrepEdge::SizeOf() const
{
  unsigned int sz = ON_CurveProxy::SizeOf();
  sz = (sizeof(*this) - sizeof(ON_CurveProxy));
  sz += m_ti.SizeOfArray();
  return sz;
}

ON_BrepEdge& ON_BrepEdge::operator=(const ON_BrepEdge& src)
{
  if ( &src != this ) 
  {
    // do not copy m_brep pointer
    ON_CurveProxy::operator=(src);
    m_edge_user   = src.m_edge_user;
    m_edge_index  = src.m_edge_index;
    m_c3i         = src.m_c3i;
    m_vi[0]       = src.m_vi[0];
    m_vi[1]       = src.m_vi[1];
    m_ti          = src.m_ti;
    m_tolerance   = src.m_tolerance;
  }
  return *this;
}

ON_BOOL32 ON_BrepEdge::IsValid( ON_TextLog* text_log ) const
{
  bool rc = ON_CurveProxy::IsValid(text_log) ? true : false;

  if ( !rc )
  {
    if ( text_log )
    {
      text_log->Print("ON_BrepEdge is not a valid curve proxy\n");
    }
  }
  else if (m_edge_index < 0)
  {
    if ( text_log )
    {
      text_log->Print("ON_BrepEdge.m_edge_index = %d (should be >= 0 )\n",m_edge_index);
    }
    rc = false;
  }
  else if ( m_c3i < 0 )
  {
    if ( text_log )
    {
      text_log->Print("ON_BrepEdge.m_c3i = %d (should be >= 0 )\n",m_c3i);
    }
    rc = false;
  }
  else if ( m_vi[0] < 0 )
  {
    if ( text_log )
    {
      text_log->Print("ON_BrepEdge.m_vi[0] = %d (should be >= 0 )\n",m_vi[0]);
    }
    rc = false;
  }
  else if ( m_vi[1] < 0 )
  {
    if ( text_log )
    {
      text_log->Print("ON_BrepEdge.m_vi[1] = %d (should be >= 0 )\n",m_vi[1]);
    }
    rc = false;
  }
  else if ( !m_brep )
  {
    if ( text_log )
    {
      text_log->Print("ON_BrepEdge.m_brep = NULL (should point to parent ON_Brep)\n");
    }
    rc = false;
  }

  return rc;

}

ON_BOOL32 ON_BrepEdge::IsClosed() const
{
  // This function must return true if ON_CurveProxy::IsClosed() is true.
  ON_BOOL32 rc = ON_CurveProxy::IsClosed();
  if ( 0 == rc 
       && m_vi[0] >= 0 
       && m_vi[0] == m_vi[1]
       && 0 != ProxyCurve()
       && ProxyCurveDomain() == ProxyCurve()->Domain()
       && 0 != m_brep
       && m_vi[0] < m_brep->m_V.Count()
       )
  {
    // When ON_CurveProxy::IsClosed() is false and the topology
    // indicates the edge is closed, we need to verify that its
    // geometry is within tolerance of being closed.
    const ON_BrepVertex& v = m_brep->m_V[m_vi[0]];
    ON_3dPoint P = PointAtStart();
    ON_3dPoint Q = PointAtEnd();
    ON_3dPoint V = v.point;
    double vtx_tol = v.m_tolerance;
    if ( P.DistanceTo(Q) <= m_tolerance 
         && V.DistanceTo(P) <= vtx_tol
         && V.DistanceTo(Q) <= vtx_tol )
      rc = true;
  }
  return rc;
}

ON_Brep* ON_BrepEdge::Brep() const
{
  return m_brep;
}

ON_BrepTrim* ON_BrepEdge::Trim( int eti ) const
{
  return (m_brep && eti >= 0 && eti < m_ti.Count()) ? m_brep->Trim(m_ti[eti]) : 0;
}

int ON_BrepEdge::TrimCount() const
{
  return m_ti.Count();
}

void ON_BrepEdge::Dump( ON_TextLog& dump ) const
{
  dump.Print("ON_BrepEdge[%d]: ",m_edge_index);
}


// virtual ON_Curve::Reverse override
ON_BOOL32 ON_BrepEdge::Reverse()
{
  ON_BOOL32 rc = false;
  if ( m_brep )
  {
    ON_Interval edge_domain = Domain();
    if ( m_brep->StandardizeEdgeCurve( m_edge_index, false ) )
    {
      ON_Curve* c3 = const_cast<ON_Curve*>(EdgeCurveOf());
      if ( c3 )
      {
        rc = c3->Reverse();
        edge_domain.Reverse();
        c3->SetDomain(edge_domain);
        SetProxyCurve(c3);
      }
    }
  }

  if ( !rc )
    rc = ON_CurveProxy::Reverse();

  if (rc)
  {
    int i = m_vi[0];
    m_vi[0] = m_vi[1];
    m_vi[1] = i;
    if ( m_brep )
    {
      const int tcount = m_brep->m_T.Count();
      int ti, eti;
      for ( eti = m_ti.Count()-1; eti >= 0; eti-- ) {
        ti = m_ti[eti];
        if ( ti >= 0 && ti < tcount ) 
        {
          ON_BrepTrim& trim = m_brep->m_T[ti];
          trim.m_bRev3d = trim.m_bRev3d ? false : true;
          trim.UnsetPlineEdgeParameters();
        }
      }
    }
  }

  return rc;
}

////////////////////////////////////////////////////////////////
//   Class ON_BrepTrim
////////////////////////////////////////////////////////////////

ON_OBJECT_IMPLEMENT(ON_BrepTrim,ON_CurveProxy,"60B5DBC2-E660-11d3-BFE4-0010830122F0");

ON_BrepTrim::ON_BrepTrim()
              : m_trim_index(-1), 
                m_c2i(-1), 
                m_ei(-1), 
                m_bRev3d(false), 
                m_type(ON_BrepTrim::unknown), 
                m_iso(ON_Surface::not_iso),
                m_li(-1),
                m__legacy_2d_tol(ON_UNSET_VALUE), 
                m__legacy_3d_tol(ON_UNSET_VALUE),
                m__legacy_flags(0),
                m_brep(0)
{
  memset(&m_trim_user,0,sizeof(m_trim_user));
  m_vi[0] = m_vi[1] = -1; 
  m_tolerance[0] = m_tolerance[1] = ON_UNSET_VALUE;
  m_pline.Reserve(4); // This is a stopgap fix to insures the memory 
                      // pool used for pline segments is the same as
                      // the memory pool used for the rest of this brep.
  //m_P[0] = ON_UNSET_POINT;
  //m_P[1] = ON_UNSET_POINT;
}

ON_BrepTrim::ON_BrepTrim(int trim_index) 
              : m_trim_index(trim_index), 
                m_c2i(-1), 
                m_ei(-1), 
                m_bRev3d(false), 
                m_type(ON_BrepTrim::unknown), 
                m_iso(ON_Surface::not_iso),
                m_li(-1),
                m__legacy_2d_tol(ON_UNSET_VALUE), 
                m__legacy_3d_tol(ON_UNSET_VALUE),
                m__legacy_flags(0),
                m_brep(0)
{
  memset(&m_trim_user,0,sizeof(m_trim_user));
  m_vi[0] = m_vi[1] = -1; 
  m_tolerance[0] = m_tolerance[1] = ON_UNSET_VALUE;
  m_pline.Reserve(4); // This is a stopgap fix to insures the memory 
                      // pool used for pline segments is the same as
                      // the memory pool used for the rest of this brep.
  //m_P[0] = ON_UNSET_POINT;
  //m_P[1] = ON_UNSET_POINT;
}


unsigned int ON_BrepTrim::SizeOf() const
{
  unsigned int sz = ON_CurveProxy::SizeOf();
  sz = (sizeof(*this) - sizeof(ON_CurveProxy));
  // runtime m_pline is not counted
  return sz;
}


ON_BrepTrim& ON_BrepTrim::operator=(const ON_BrepTrim& src)
{
  if ( &src != this ) 
  {
    // do not copy m_brep pointer
    ON_CurveProxy::operator=(src);
    m_trim_user   = src.m_trim_user;
    m_trim_index  = src.m_trim_index;
    m_c2i    = src.m_c2i;
    //m_t      = src.m_t;
    m_ei     = src.m_ei;
    m_vi[0]  = src.m_vi[0];
    m_vi[1]  = src.m_vi[1];
    m_bRev3d = src.m_bRev3d;
    m_type   = src.m_type;
    m_iso    = src.m_iso;
    m_li     = src.m_li;
    m_tolerance[0] = src.m_tolerance[0];
    m_tolerance[1] = src.m_tolerance[1];
    //m_P[0] = src.m_P[0];
    //m_P[1] = src.m_P[1];
    m__legacy_2d_tol = src.m__legacy_2d_tol;
    m__legacy_3d_tol = src.m__legacy_3d_tol;
    m__legacy_flags = src.m__legacy_flags;
    m_pline = src.m_pline;
    m_pbox = src.m_pbox;
  }
  return *this;
}

ON_Brep* ON_BrepTrim::Brep() const
{
  return m_brep;
}

ON_BrepLoop* ON_BrepTrim::Loop() const
{
  ON_BrepLoop* loop = 0;
  if ( m_brep && m_li >= 0 && m_li < m_brep->m_L.Count() )
    loop = &m_brep->m_L[m_li];
  return loop;  
}

ON_BrepFace* ON_BrepTrim::Face() const
{
  ON_BrepFace* face = 0;
  if ( m_brep && m_li >= 0 && m_li < m_brep->m_L.Count() )
  {
    int fi = m_brep->m_L[m_li].m_fi;
    if ( fi >= 0 && fi < m_brep->m_F.Count() )
      face = &m_brep->m_F[fi];
  }
  return face;
}

ON_BrepEdge* ON_BrepTrim::Edge() const
{
  ON_BrepEdge* edge = 0;
  if ( m_brep && m_ei >= 0 && m_ei < m_brep->m_E.Count() )
    edge = &m_brep->m_E[m_ei];
  return edge;  
}

ON_BrepVertex* ON_BrepTrim::Vertex(int tvi) const
{
  ON_BrepVertex* vertex = 0;
  if ( 0 != m_brep && 0 <= tvi && tvi <= 1 )
  {
    int vi = m_vi[tvi];
    if ( 0 <= vi && vi < m_brep->m_V.Count() )
    {
      vertex = &m_brep->m_V[vi];
    }
  }
  return vertex;  
}

ON_BrepVertex* ON_BrepEdge::Vertex(int evi) const
{
  ON_BrepVertex* vertex = 0;
  if ( 0 != m_brep && 0 <= evi && evi <= 1 )
  {
    int vi = m_vi[evi];
    if ( 0 <= vi && vi < m_brep->m_V.Count() )
    {
      vertex = &m_brep->m_V[vi];
    }
  }
  return vertex;  
}


ON_BOOL32 ON_BrepTrim::IsValid( ON_TextLog* text_log ) const
{
  if ( m_trim_index < 0 )
  {
    if ( text_log )
    {
      text_log->Print("trim.m_trim_index < 0.\n");
    }
    return ON_BrepIsNotValid();
  }

  if ( m_c2i < 0 )
  {
    if ( text_log )
    {
      text_log->Print("trim.m_c2i = %d is not valid\n",m_c2i);
    }
    return ON_BrepIsNotValid();
  }

  if ( !ON_CurveProxy::IsValid(text_log) )
  {
    if ( text_log )
    {
      text_log->Print("trim curve proxy settings are not valid.\n");
    }
    return ON_BrepIsNotValid();
  }

  if ( m_ei < 0 ) 
  {
    if ( m_type != singular )
    {
      if ( text_log )
      {
        text_log->Print("trim.m_ei = %d but trim.mtype != singular\n",m_ei);
      }
      return ON_BrepIsNotValid();
    }
  }

  if ( m_vi[0] < 0 )
  {
    if ( text_log )
    {
      text_log->Print("trim.m_v[0] = %d is not valid\n",m_vi[0]);
    }
    return ON_BrepIsNotValid();
  }

  if ( m_vi[1] < 0 )
  {
    if ( text_log )
    {
      text_log->Print("trim.m_v[1] = %d is not valid\n",m_vi[1]);
    }
    return ON_BrepIsNotValid();
  }

  unsigned int i = m_type;
  if ( i >= trim_type_count )
  {
    if ( text_log )
    {
      text_log->Print("trim.m_type = %d is not valid\n",i);
    }
    return ON_BrepIsNotValid();
  }

  if ( i == ON_BrepTrim::slit )
  {
    if ( text_log )
    {
      text_log->Print("trim.m_type = ON_BrepTrim::slit is not valid. REserved for future use.\n",i);
    }
    return ON_BrepIsNotValid();
  }

  i = m_iso;
  if ( i >= ON_Surface::iso_count )
  {
    if ( text_log )
    {
      text_log->Print("trim.m_iso = %d is not valid\n",i);
    }
    return ON_BrepIsNotValid();
  }

  if ( m_li < 0 )
  {
    if ( text_log )
    {
      text_log->Print("trim.m_li = %d is not valid\n",m_li);
    }
    return ON_BrepIsNotValid();
  }

  if ( !m_brep )
  {
    if ( text_log )
    {
      text_log->Print("trim.m_brep is null.\n");
    }
    return ON_BrepIsNotValid();
  }

  return true;
}

void ON_BrepTrim::Dump( ON_TextLog& dump ) const
{
  dump.Print("ON_BrepTrim[%d]:\n",m_trim_index);
}

ON_BOOL32 ON_BrepTrim::Reverse()
{
  m_pline.Destroy();
  DestroyCurveTree();

  ON_BOOL32 rc = false;
  if ( m_brep )
  {
    ON_Interval trim_domain = Domain();
    if ( m_brep->StandardizeTrimCurve( m_trim_index ) )
    {
      ON_Curve* c2 = const_cast<ON_Curve*>(TrimCurveOf());
      if ( c2 )
      {
        rc = c2->Reverse();
        trim_domain.Reverse();
        c2->SetDomain(trim_domain);
        SetProxyCurve(c2);
      }
    }
  }

  if ( !rc )
    rc = ON_CurveProxy::Reverse();

  if (rc)
  {
    int i = m_vi[0];
    m_vi[0] = m_vi[1];
    m_vi[1] = i;
    if ( m_ei >= 0 )
      m_bRev3d = m_bRev3d ? false : true;
  }
  return rc;
}


////////////////////////////////////////////////////////////////
//   Class ON_BrepLoop
////////////////////////////////////////////////////////////////

ON_OBJECT_IMPLEMENT(ON_BrepLoop,ON_Geometry,"60B5DBC3-E660-11d3-BFE4-0010830122F0");

ON_BrepLoop::ON_BrepLoop()
              : m_loop_index(-1), 
                m_type(ON_BrepLoop::unknown), 
                m_fi(-1),
                m_brep(0)
{
  memset(&m_loop_user,0,sizeof(m_loop_user));
}

ON_BrepLoop::ON_BrepLoop(int loop_index) 
              : m_loop_index(loop_index), 
                m_type(ON_BrepLoop::unknown), 
                m_fi(-1),
                m_brep(0)
{
  memset(&m_loop_user,0,sizeof(m_loop_user));
}

ON_Brep* ON_BrepLoop::Brep() const
{
  return m_brep;
}

ON_BrepFace* ON_BrepLoop::Face() const
{
  return m_brep ? m_brep->Face(m_fi) : 0;
}


unsigned int ON_BrepLoop::SizeOf() const
{
  unsigned int sz = ON_Object::SizeOf();
  sz += (sizeof(ON_BrepLoop) - sizeof(ON_Object));
  sz += m_ti.SizeOfArray();
  return sz;
}

ON_BrepTrim* ON_BrepLoop::Trim( int lti ) const
{
  ON_BrepTrim* trim = ( m_brep && lti >= 0 && lti < m_ti.Count() )
                    ? m_brep->Trim(m_ti[lti])
                    : 0;
  return trim;
}

int ON_BrepLoop::TrimCount() const
{
  return m_ti.Count();
}

ON_BrepLoop& ON_BrepLoop::operator=(const ON_BrepLoop& src)
{
  if ( &src != this ) 
  {
    // do not copy m_brep pointer
    ON_Object::operator=(src);
    m_loop_user   = src.m_loop_user;
    m_loop_index  = src.m_loop_index;
    m_ti    = src.m_ti;
    m_type  = src.m_type;
    m_fi    = src.m_fi;
    m_pbox  = src.m_pbox;
  }
  return *this;
}

static void BadLoopMessage( int loop_index, ON_TextLog* text_log )
{
  if ( text_log )
  {
    text_log->Print("brep.m_L[%d] loop is not valid.\n",loop_index);
  }
}

ON_BOOL32 ON_BrepLoop::IsValid( ON_TextLog* text_log ) const
{
  if ( m_loop_index < 0 )
  {
    BadLoopMessage(m_loop_index,text_log);
    if ( text_log )
      text_log->Print("loop.m_loop_index < 0.\n");
    return ON_BrepIsNotValid();
  }

  if ( m_ti.Count() < 1 )
  {
    BadLoopMessage(m_loop_index,text_log);
    if ( text_log )
      text_log->Print("loop.m_ti[] is empty.\n");
    return ON_BrepIsNotValid();
  }
  int i = m_type;
  if ( i < 0 || i > type_count )
  {
    BadLoopMessage(m_loop_index,text_log);
    if ( text_log )
      text_log->Print("loop.m_type = %d is not a valid value.\n",i);
    return ON_BrepIsNotValid();
  }
  if ( m_fi < 0 )
  {
    BadLoopMessage(m_loop_index,text_log);
    if ( text_log )
      text_log->Print("loop.m_fi = %d (should be >= 0 ).\n",m_fi);
    return ON_BrepIsNotValid();
  }
  if ( !m_brep )
  {
    BadLoopMessage(m_loop_index,text_log);
    if ( text_log )
      text_log->Print("loop.m_brep is NULL.\n");
    return ON_BrepIsNotValid();
  }
  return true;
}

void ON_BrepLoop::Dump( ON_TextLog& dump ) const
{
  dump.Print("ON_BrepLoop[%d]: m_fi = %d, m_type = %d m_ti.Count() = %d\n",
             m_loop_index,m_fi,m_type,m_ti.Count()
             );
}

int ON_BrepLoop::IndexOfTrim( const ON_BrepTrim& trim ) const
{
  const int count = m_ti.Count();
  int lti;
  for ( lti = 0; lti < count; lti++ )
  {
    if ( m_ti[lti] == trim.m_trim_index )
      return lti;
  }
  return -1;
}

////////////////////////////////////////////////////////////////
//   Class ON_BrepFace
////////////////////////////////////////////////////////////////

ON_OBJECT_IMPLEMENT(ON_BrepFace,ON_SurfaceProxy,"60B5DBC4-E660-11d3-BFE4-0010830122F0");

ON_BrepFace::ON_BrepFace() : ON_SurfaceProxy(0),
                m_face_index(-1), 
                m_si(-1), 
                m_bRev(false),
                m_face_material_channel(0),
                m_render_mesh(0),
                m_analysis_mesh(0),
                m_preview_mesh(0),
                m_brep(0)
{
  m_face_uuid = ON_nil_uuid;
  memset(&m_face_user,0,sizeof(m_face_user));
}

ON_BrepFace::ON_BrepFace(int face_index) : ON_SurfaceProxy(0),
                m_face_index(face_index),
                m_si(-1), 
                m_bRev(false),
                m_face_material_channel(0),
                m_render_mesh(0),
                m_analysis_mesh(0),
                m_preview_mesh(0),
                m_brep(0)
{
  m_face_uuid = ON_nil_uuid;
  memset(&m_face_user,0,sizeof(m_face_user));
}


unsigned int ON_BrepFace::SizeOf() const
{
  unsigned int sz = ON_SurfaceProxy::SizeOf();
  sz += (sizeof(*this) - sizeof(ON_SurfaceProxy));
  sz += m_li.SizeOfArray();
  if ( m_render_mesh )
    sz += m_render_mesh->SizeOf();
  if ( m_analysis_mesh )
    sz += m_analysis_mesh->SizeOf();
  if ( m_preview_mesh )
    sz += m_preview_mesh->SizeOf();
  return sz;
}


ON_BrepFace& ON_BrepFace::operator=(const ON_BrepFace& src)
{
  if ( &src != this ) 
  {
    // do not copy m_brep pointer
    ON_SurfaceProxy::operator=(src);
    m_face_user   = src.m_face_user;
    m_face_index  = src.m_face_index;
    m_li    = src.m_li;
    m_si    = src.m_si;
    m_bRev  = src.m_bRev;
    m_face_material_channel = src.m_face_material_channel;
    m_face_uuid = src.m_face_uuid;
    if ( m_render_mesh ) {
      delete m_render_mesh;
      m_render_mesh = 0;
    }
    if ( src.m_render_mesh ) {
      m_render_mesh = new ON_Mesh(*src.m_render_mesh);
    }    
    if ( m_analysis_mesh ) {
      delete m_analysis_mesh;
      m_analysis_mesh = 0;
    }
    if ( src.m_analysis_mesh ) {
      m_analysis_mesh = new ON_Mesh(*src.m_analysis_mesh);
    }    
    if ( m_preview_mesh ) {
      delete m_preview_mesh;
      m_preview_mesh = 0;
    }
    if ( src.m_preview_mesh ) {
      m_preview_mesh = new ON_Mesh(*src.m_preview_mesh);
    }    
    //m_material_index = src.m_material_index;
  }
  return *this;
}

ON_BrepFace::~ON_BrepFace()
{
  DestroyMesh(ON::any_mesh);
  m_li.Destroy();
}

ON_Brep* ON_BrepFace::Brep() const
{
  return m_brep;
}

ON_BrepLoop* ON_BrepFace::Loop( int lti ) const
{
  return (m_brep && lti >= 0 && lti < m_li.Count()) ? m_brep->Loop( m_li[lti]) : 0;
}

int ON_BrepFace::LoopCount() const
{
  return m_li.Count();
}

ON_BrepLoop* ON_BrepFace::OuterLoop() const
{
  int li, lti;
  for ( lti = 0; lti < m_li.Count(); lti++ )
  {
    li = m_li[lti];
    if ( li >= 0 && li < m_brep->m_L.Count() )
    {
      if ( ON_BrepLoop::outer == m_brep->m_L[li].m_type  )
      {
        return &m_brep->m_L[li];
      }
    }
  }
  return 0;
}


ON_BOOL32 ON_BrepFace::IsValid( ON_TextLog* text_log ) const
{
  if ( m_face_index < 0 )
  {
    if ( 0 != text_log )
      text_log->Print("ON_BrepFace m_face_index = %d.  Should be >= 0.\n",m_face_index);
    return false;
  }

  if ( m_li.Count() < 1 )
  {
    if ( 0 != text_log )
      text_log->Print("ON_BrepFace m_li.Count() = 0  Should be > 0.\n");
    return false;
  }

  if ( m_si < 0 )
  {
    if ( 0 != text_log )
      text_log->Print("ON_BrepFace m_si = %d.  Should be >= 0.\n",m_si);
    return false;
  }

  if ( 0 == m_brep )
  {
    if ( 0 != text_log )
      text_log->Print("ON_BrepFace m_brep = 0.  Should point to parent brep.\n");
    return false;

  }

  return true;
}

void ON_BrepFace::Dump( ON_TextLog& dump ) const
{
  dump.Print("ON_BrepFace[%d]:",m_face_index);
  if ( ON_UuidCompare(m_face_uuid,ON_nil_uuid) )
  {
    dump.Print(" (");
    dump.Print(m_face_uuid);
    dump.Print(" )");
  }
  dump.Print("\n");
}


/*
int ON_BrepFace::MaterialIndex() const
{
  return m_material_index;
}

void ON_BrepFace::SetMaterialIndex(int mi)
{
  m_material_index = (mi>0) ? mi : -1;
}
*/

const ON_Mesh* ON_BrepFace::Mesh( ON::mesh_type mt ) const
{
  ON_Mesh* m = 0;
  switch(mt) {
  case ON::render_mesh:
    m = m_render_mesh;
    break;
  case ON::analysis_mesh:
    m = m_analysis_mesh;
    break;
  case ON::preview_mesh:
    m = m_preview_mesh;
    break;
  default:
    m = m_render_mesh ? m_render_mesh : m_analysis_mesh;
    if ( !m )
      m = m_preview_mesh;
    break;
  }
  if ( m ) {
    m->m_parent = this;
    //m->m_material_index = m_material_index;
  }
  return m;
}

void ON_BrepFace::DestroyMesh( ON::mesh_type mt, bool bDeleteMesh )
{
  switch(mt) {
  case ON::render_mesh:
    if ( m_render_mesh ) 
    {
      if ( bDeleteMesh )
        delete m_render_mesh;
      m_render_mesh = 0;
    }
    break;
  case ON::analysis_mesh:
    if (m_analysis_mesh) 
    {
      if ( bDeleteMesh )
        delete m_analysis_mesh;
      m_analysis_mesh = 0;
    }
    break;
  case ON::preview_mesh:
    if (m_preview_mesh) 
    {
      if ( bDeleteMesh )
        delete m_preview_mesh;
      m_preview_mesh = 0;
    }
    break;
  default:
    DestroyMesh( ON::render_mesh );
    DestroyMesh( ON::analysis_mesh );
    DestroyMesh( ON::preview_mesh );
    break;
  }
}


unsigned int ON_BrepVertexArray::SizeOf() const
{
  unsigned int sz = 0;
  int i, count = Count();
  for ( i = 0; i < count; i++ )
  {
    sz += m_a[i].SizeOf();
  }
  sz += (m_capacity - m_count)*sizeof(m_a[0]);
  return sz;
}

unsigned int ON_BrepEdgeArray::SizeOf() const
{
  unsigned int sz = 0;
  int i, count = Count();
  for ( i = 0; i < count; i++ )
  {
    sz += m_a[i].SizeOf();
  }
  sz += (m_capacity - m_count)*sizeof(m_a[0]);
  return sz;
}

unsigned int ON_BrepTrimArray::SizeOf() const
{
  unsigned int sz = 0;
  int i, count = Count();
  for ( i = 0; i < count; i++ )
  {
    sz += m_a[i].SizeOf();
  }
  sz += (m_capacity - m_count)*sizeof(m_a[0]);
  return sz;
}

unsigned int ON_BrepLoopArray::SizeOf() const
{
  unsigned int sz = 0;
  int i, count = Count();
  for ( i = 0; i < count; i++ )
  {
    sz += m_a[i].SizeOf();
  }
  sz += (m_capacity - m_count)*sizeof(m_a[0]);
  return sz;
}

unsigned int ON_BrepFaceArray::SizeOf() const
{
  unsigned int sz = 0;
  int i, count = Count();
  for ( i = 0; i < count; i++ )
  {
    sz += m_a[i].SizeOf();
  }
  sz += (m_capacity - m_count)*sizeof(m_a[0]);
  return sz;
}

////////////////////////////////////////////////////////////////
//   Class ON_Brep
////////////////////////////////////////////////////////////////

ON_BrepVertexArray::ON_BrepVertexArray()
{}

ON_BrepVertexArray::~ON_BrepVertexArray()
{}


ON_BrepEdgeArray::ON_BrepEdgeArray()
{}

ON_BrepEdgeArray::~ON_BrepEdgeArray()
{}


ON_BrepTrimArray::ON_BrepTrimArray()
{}

ON_BrepTrimArray::~ON_BrepTrimArray()
{}


ON_BrepLoopArray::ON_BrepLoopArray()
{}

ON_BrepLoopArray::~ON_BrepLoopArray()
{}

ON_BrepFaceArray::ON_BrepFaceArray()
{}

ON_BrepFaceArray::~ON_BrepFaceArray()
{}


ON_OBJECT_IMPLEMENT(ON_Brep,ON_Geometry,"60B5DBC5-E660-11d3-BFE4-0010830122F0");

void ON_Brep::Initialize()
{
  memset(&m_brep_user,0,sizeof(m_brep_user));
  m_is_solid = 0;
  m_bbox.Destroy();
}

ON_Brep* ON_Brep::New() 
{
  // use instead of new ON_Brep()
  // (When openNURBS is used as a Windows DLL, 
  // this forces the call to new to happen in the openNURBS DLL.)
  return new ON_Brep();
}

ON_Brep* ON_Brep::New(const ON_Brep& src) 
{
  // use instead of new ON_Brep(const ON_Brep&)
  // (When openNURBS is used as a Windows DLL, 
  // this forces the call to new to happen in the openNURBS DLL.)
  return new ON_Brep(src);
}

ON_Brep::ON_Brep()
{ 
  ON__SET__THIS__PTR(m_s_ON_Brep_ptr);
  Initialize();
}

ON_Brep::ON_Brep(const ON_Brep& src) : ON_Geometry(src)
{
  ON__SET__THIS__PTR(m_s_ON_Brep_ptr);
  Initialize();
  *this = src;
}

ON_Brep::~ON_Brep()
{ 
  DestroyMesh(ON::any_mesh,true);
  // everything is in array classes that destroy themselves.
}

unsigned int ON_Brep::SizeOf() const
{
  int i, count;

  unsigned int sz = ON_Geometry::SizeOf();
  sz += (sizeof(*this) - sizeof(ON_Geometry));
  sz += m_C2.SizeOfArray();
  sz += m_C3.SizeOfArray();
  sz += m_S.SizeOfArray();

  count = m_C2.Count();
  for ( i = 0; i < count; i++ )
  {
    const ON_Curve* c2 = m_C2[i];
    if ( c2 )
      sz += c2->SizeOf();
  }

  count = m_C3.Count();
  for ( i = 0; i < count; i++ )
  {
    const ON_Curve* c3 = m_C3[i];
    if ( c3 )
      sz += c3->SizeOf();
  }

  count = m_S.Count();
  for ( i = 0; i < count; i++ )
  {
    const ON_Surface* s = m_S[i];
    if ( s )
      sz += s->SizeOf();
  }

  sz += m_V.SizeOf();
  sz += m_E.SizeOf();
  sz += m_T.SizeOf();
  sz += m_L.SizeOf();
  sz += m_F.SizeOf();

  return sz;
}

ON__UINT32 ON_BrepVertex::DataCRC(ON__UINT32 current_remainder) const
{
  current_remainder = ON_CRC32(current_remainder,sizeof(m_vertex_index),&m_vertex_index);
  current_remainder = ON_CRC32(current_remainder,sizeof(m_tolerance),&m_tolerance);
  current_remainder = m_ei.DataCRC(current_remainder);
  return current_remainder;
}

ON__UINT32 ON_BrepEdge::DataCRC(ON__UINT32 current_remainder) const
{
  current_remainder = ON_CurveProxy::DataCRC(current_remainder);
  current_remainder = ON_CRC32(current_remainder,sizeof(m_edge_index),&m_edge_index);
  current_remainder = ON_CRC32(current_remainder,sizeof(m_c3i),&m_c3i);
  current_remainder = ON_CRC32(current_remainder,2*sizeof(m_vi[0]),&m_vi[0]);
  current_remainder = m_ti.DataCRC(current_remainder);
  current_remainder = ON_CRC32(current_remainder,sizeof(m_tolerance),&m_tolerance);

  return current_remainder;
}

ON__UINT32 ON_BrepFace::DataCRC(ON__UINT32 current_remainder) const
{
  current_remainder = ON_SurfaceProxy::DataCRC(current_remainder);
  current_remainder = ON_CRC32(current_remainder,sizeof(m_face_index),&m_face_index);
  current_remainder = ON_CRC32(current_remainder,sizeof(m_bRev),&m_bRev);
  current_remainder = m_li.DataCRC(current_remainder);

  return current_remainder;
}

ON__UINT32 ON_Brep::DataCRC(ON__UINT32 current_remainder) const
{
  current_remainder = m_V.DataCRC(current_remainder);
  current_remainder = m_E.DataCRC(current_remainder);
  current_remainder = m_F.DataCRC(current_remainder);
  return current_remainder;
}

void ON_Brep::DestroyMesh( ON::mesh_type mt, bool bDeleteMesh )
{
  const int fcnt = m_F.Count();
  int fi;
  for ( fi = 0; fi < fcnt; fi++ ) {
    m_F[fi].DestroyMesh(mt,bDeleteMesh);
  }
}

int ON_Brep::GetMesh( ON::mesh_type mt, ON_SimpleArray<const ON_Mesh*>& meshes ) const
{
  int fcnt = m_F.Count();
  int fi;
  int null_count = 0;
  meshes.Reserve( meshes.Count() + fcnt );
  for ( fi = 0; fi < fcnt; fi++ )
  {
    const ON_Mesh* mesh = m_F[fi].Mesh(mt);
    meshes.Append( mesh );
    if ( !mesh )
    {
      // If some meshes are missing, we have to put
      // a null in the return array so the face-to-mesh
      // correspondence is preserved.
      null_count++;
    }
  }
  if ( null_count == fcnt )
  {
    // If ALL the meshes are missing, return 0.
    meshes.SetCount(meshes.Count()-fcnt);
    fcnt = 0;
  }
  return fcnt;
}


int ON_Brep::Dimension() const
{
  return (m_V.Count() > 0) ? 3 : 0;
}

static void ON_BrepTransformSwapSrfHelper( ON_Brep& brep, ON_NurbsSurface* nurbs_srf, int si )
{
  // Replace plane surface which could not be properly transformed
  // with nurbs_surface.
  ON_Surface* old_srf = brep.m_S[si];
  ON_UserDataHolder udholder;
  udholder.MoveUserDataFrom(*old_srf);
  udholder.MoveUserDataTo(*nurbs_srf,false);
  brep.m_S[si] = nurbs_srf;
  
  // Update faces to use new surface.
  const int fcount = brep.m_F.Count();
  ON_BrepFace* f = brep.m_F.Array();
  for ( int fi = 0; fi < fcount; fi++ )
  {
    if (f[fi].m_si == si || f[fi].ProxySurface() == old_srf )
    {
      const bool bIsTransposed = f[fi].ProxySurfaceIsTransposed();
      f[fi].SetProxySurface(nurbs_srf);
      if (bIsTransposed)
        f[fi].ON_SurfaceProxy::Transpose();
    }
  }

  delete old_srf;
}

ON_BOOL32 ON_Brep::Transform( const ON_Xform& xform )
{
  int i, count;
  ON_BOOL32 rc = true;
  
  DestroyRuntimeCache();

  int is_similarity = xform.IsSimilarity();
  double det = xform.Determinant();

  if ( 1 != is_similarity )
  {
    // this will cause the solid flag to be
    // recaclulated the next time it is needed.
    m_is_solid = 0;
  }


  // 13 Feb 2003 Dale Lear:
  // Transforming the bbox makes it grow too large under repeated
  // rotations.  So, we will destroy it here and reset it below.
  //m_bbox.Transform(xform);
  m_bbox.Destroy();

  count = m_C3.Count();
  for ( i = 0; i < count; i++ ) 
  {
    if ( m_C3[i] ) 
    {
      if ( !m_C3[i]->Transform(xform) )
        rc = false;
    }
  }

  count = m_S.Count();
  for ( i = 0; i < count; i++ ) {
    if ( m_S[i] ) 
    
    {
      ON_NurbsSurface* nurbs_srf = 0;
      if ( !is_similarity )
      {
        if (    1 == m_S[i]->Degree(0) // degree tests reduce calls to
             && 1 == m_S[i]->Degree(1) // slow ON_PlaneSurface::Cast()
             && 0 != ON_PlaneSurface::Cast(m_S[i]) )
        {
          nurbs_srf = ON_NurbsSurface::New();
          if ( !m_S[i]->GetNurbForm(*nurbs_srf) )
          {
            delete nurbs_srf;
            nurbs_srf = 0;
          }
          else if ( !nurbs_srf->Transform(xform) )
          {
            delete nurbs_srf;
            nurbs_srf = 0;
          }
        }
      }

      if ( !m_S[i]->Transform(xform) )
      {
        if ( nurbs_srf )
        {
          ON_BrepTransformSwapSrfHelper(*this,nurbs_srf,i);
          nurbs_srf = 0;
        }
        else
        {
          rc = false;
        }
      }
      else if ( nurbs_srf )
      {
        // make sure transformation was good
        ON_Interval u = nurbs_srf->Domain(0);
        ON_Interval v = nurbs_srf->Domain(1);
        for ( int ui = 0; ui < 2 && nurbs_srf; ui++ ) for (int vi = 0; vi < 2 && nurbs_srf; vi++)
        {
          ON_3dPoint P = nurbs_srf->PointAt(u[ui],v[vi]);
          ON_3dPoint Q = m_S[i]->PointAt(u[ui],v[vi]);
          if ( P.DistanceTo(Q) > ON_ZERO_TOLERANCE )
          {
            ON_BrepTransformSwapSrfHelper(*this,nurbs_srf,i);
            nurbs_srf = 0;
            break;
          }
        }
        if ( nurbs_srf )
        {
          delete nurbs_srf;
          nurbs_srf = 0;
        }
      }
    }
  }

  count = m_V.Count();
  for ( i = 0; i < count; i++ ) {
    if ( !m_V[i].Transform(xform) )
      rc = false;
  }

  count = m_E.Count();
  for ( i = 0; i < count; i++ ) {
    m_E[i].TransformUserData(xform);
  }

  count = m_F.Count();
  for ( i = 0; i < count; i++ ) 
  {
    ON_BrepFace& face = m_F[i];
    face.TransformUserData(xform);

    // 13 Feb 2003 Dale Lear:
    // Transforming the bbox makes it grow too large under repeated
    // rotations.  So, we need to reset it.
    face.m_bbox.Destroy();
    const ON_Surface* srf = face.SurfaceOf();
    if ( 0 != srf )
    {
      face.m_bbox = srf->BoundingBox();
      if ( face.m_face_index != -1 )
        m_bbox.Union( face.m_bbox );
    }

    // 12 May 2003 Dale Lear - RR 10528
    //     Use surface evaluation to update rendermesh when 
    //     calling ON_Mesh::Transform() will map mesh normals
    //     to some thing different that the "true" surface
    //     normal.
    bool bEvMesh = ( fabs(det) <= ON_SQRT_EPSILON
                     || xform[3][0] != 0.0
                     || xform[3][1] != 0.0
                     || xform[3][2] != 0.0
                     || xform[3][3] != 1.0
                     );
    if ( 0 == srf )
      bEvMesh = false;

    if ( 0 != face.m_render_mesh )
    {
      if ( bEvMesh && face.m_render_mesh->EvaluateMeshGeometry(*srf) )
      {
        if ( face.m_bRev )
        {
          // 29 September 2003 Dale Lear
          //     Normals on render meshes (and face orientations)
          //     take face.m_bRev into account so that two sided
          //     materials work as expected.  EvaluateMeshGeometry()
          //     does not take face.m_bRev into account, so we need
          //     to reverse the face normals here.
          int ni, ncnt = face.m_render_mesh->m_N.Count();
          for ( ni = 0; ni < ncnt; ni++ )
          {
            face.m_render_mesh->m_N[ni].Reverse();
          }
        }
      }
      else
        face.m_render_mesh->Transform(xform);
    }

    if ( 0 != face.m_analysis_mesh )
    {
      // Dale Lear 30 March 2009 - bug 46766
      //   Evaluate analysis meshes when the transform involves scaling
      //   so curvature values are properly updated.
      bool bEvAnalysisMesh = bEvMesh;
      if ( !bEvAnalysisMesh )
      {
        ON_Xform tmp(xform);
        tmp.m_xform[0][3] = 0.0;
        tmp.m_xform[1][3] = 0.0;
        tmp.m_xform[2][3] = 0.0;
        if ( 1 != tmp.IsSimilarity() )
          bEvAnalysisMesh = true;
      }
      if ( bEvAnalysisMesh && face.m_analysis_mesh->EvaluateMeshGeometry(*srf) )
      {
        // 28 Sept 2012, Mikko:
        // Apply the "29 September 2003 Dale Lear" fix above also to analysis meshes.
        if ( face.m_bRev )
        {
          int ni, ncnt = face.m_analysis_mesh->m_N.Count();
          for ( ni = 0; ni < ncnt; ni++ )
          {
            face.m_analysis_mesh->m_N[ni].Reverse();
          }
        }
      }
      else
        face.m_analysis_mesh->Transform(xform);
    }

    if ( 0 != face.m_preview_mesh )
    {
      if ( bEvMesh && face.m_preview_mesh->EvaluateMeshGeometry(*srf) )
      {
        if ( face.m_bRev )
        {
          int ni, ncnt = face.m_analysis_mesh->m_N.Count();
          for ( ni = 0; ni < ncnt; ni++ )
          {
            face.m_analysis_mesh->m_N[ni].Reverse();
          }
        }
      }
      else
        face.m_preview_mesh->Transform(xform);

    }
  }

  // The call to transform user data needs to be last
  // so that the rest of the brep is in position.
  // In particular, ON_BrepRegionTopologyUserData::Transform
  // assumes the face bounding boxes are up to date.
  TransformUserData(xform);

  return rc;
}

/////////////////////////////////////////////////////////////////
// ON_Brep Creation Interface

int 
ON_Brep::AddTrimCurve( ON_Curve* pC )
{
  int c2i = -1;

  if ( 0 != pC )
  {
    // 7 April 2003 Dale Lear:
    //    There are too many cases where bugs are caused by
    //    people attempting to use 3d curves for trims.  In
    //    all the cases encountered so far, the intent was
    //    to pass in a 2d curve, so...

    int dim = pC->Dimension();

    if ( dim != 2 )
    {
      ON_ERROR("ON_Brep::AddTrimCurve() go a non-2d curve - changing dim to 2.");
      pC->ChangeDimension(2);
      dim = pC->Dimension();
    }

    if ( 2 == dim )
    {
      c2i = m_C2.Count();
      m_C2.Append(pC);
    }
  }
  return c2i;
}

int 
ON_Brep::AddEdgeCurve( ON_Curve* pC )
{
  int c3i = -1;
  if ( 0 != pC )
  {

    int dim = pC->Dimension();

    if ( dim != 3 )
    {
      // 7 April 2003 Dale Lear: (See comment in ON_Brep::AddTrimCurve().)
      ON_ERROR("ON_Brep::AddEdgeCurve() got a non-3d curve - changing dim to 3.");
      pC->ChangeDimension(3);
      dim = pC->Dimension();
    }
    
    if ( 3 == dim )
    {
      c3i = m_C3.Count();
      m_C3.Append(pC);
    }
  }
  return c3i;
}

int 
ON_Brep::AddSurface( ON_Surface* pS )
{
  int si = -1;
  if ( pS && pS->Dimension() == 3 ) 
  {
    si = m_S.Count();
    m_S.Append(pS);
  }
  m_bbox.Destroy();
  m_is_solid = 0;
  return si;
}

ON_BrepVertex& 
ON_Brep::NewVertex()
{
  int vi = m_V.Count();
  m_V.Reserve(vi+1);
  m_V.SetCount(vi+1);
  ON_BrepVertex& vertex = m_V.Array()[vi];
  vertex.m_vertex_index = vi;
  vertex.point = ON_UNSET_POINT;
  vertex.m_tolerance = ON_UNSET_VALUE;
  return vertex;
}

ON_BrepVertex& 
ON_Brep::NewVertex( ON_3dPoint vertex_point, double vertex_tolerance )
{
  ON_BrepVertex& vertex = NewVertex();
  vertex.point = vertex_point;
  vertex.m_tolerance = vertex_tolerance;
  return vertex;
}

ON_BrepEdge& 
ON_Brep::NewEdge( int c3i )
{
  int ei = m_E.Count();
  ON_BrepEdge& edge = m_E.AppendNew();
  edge.m_tolerance = ON_UNSET_VALUE;
  edge.m_edge_index = ei;
  edge.m_c3i = c3i;
  if ( edge.m_c3i >= 0 && edge.m_c3i < m_C3.Count() ) 
  {
    edge.SetProxyCurve(m_C3[edge.m_c3i]);
  }
  edge.m_brep = this;
  return edge;
}

ON_BrepEdge& 
ON_Brep::NewEdge( ON_BrepVertex& v0, ON_BrepVertex& v1, 
                  int c3i, const ON_Interval* edomain,
                  double edge_tolerance )
{
  ON_BrepEdge& edge = NewEdge(c3i);
  edge.m_vi[0] = v0.m_vertex_index;
  edge.m_vi[1] = v1.m_vertex_index;
  v0.m_ei.Append(edge.m_edge_index);
  v1.m_ei.Append(edge.m_edge_index);
  if ( edomain && edomain->IsIncreasing() ) {
    ON_Interval edom;
    edom.Intersection( edge.ProxyCurveDomain(), *edomain );
    if ( edom.IsIncreasing() )
      edge.SetProxyCurveDomain(edom);
  }
  edge.m_tolerance = edge_tolerance;
  return edge;
}

bool ON_Brep::SetEdgeCurve( 
  ON_BrepEdge& edge,
  int c3_index,
  const ON_Interval* sub_domain
  )
{
  bool rc = false;
  if ( c3_index == - 1 && !sub_domain )
  {
    edge.m_c3i = -1;
    edge.SetProxyCurve(0);
    rc = true;
  }
  else if ( c3_index >= 0 && c3_index <= m_C3.Count() && m_C3[c3_index] )
  {
    ON_Interval curve_domain = m_C3[c3_index]->Domain();
    if ( !sub_domain || (sub_domain->IsIncreasing() && curve_domain.Includes(*sub_domain)) )
    {
      edge.m_c3i = c3_index;
      edge.SetProxyCurve( m_C3[c3_index], 
                          (sub_domain) ? *sub_domain : curve_domain
                          );
      rc = true;
    }
  }
  return rc;
}

bool ON_Brep::SetTrimCurve( 
  ON_BrepTrim& trim,
  int c2_index,
  const ON_Interval* sub_domain
  )
{
  bool rc = false;
  if ( c2_index == - 1 && !sub_domain )
  {
    trim.m_c2i = -1;
    trim.SetProxyCurve(0);
    rc = true;
  }
  else if ( c2_index >= 0 && c2_index <= m_C2.Count() && m_C2[c2_index] )
  {
    ON_Interval curve_domain = m_C2[c2_index]->Domain();
    if ( !sub_domain || (sub_domain->IsIncreasing() && curve_domain.Includes(*sub_domain)) )
    {
      trim.m_c2i = c2_index;
      trim.SetProxyCurve( m_C2[trim.m_c2i], (sub_domain) ? *sub_domain : curve_domain );
      trim.m_pbox = m_C2[trim.m_c2i]->BoundingBox();
      trim.m_pbox.m_min.z = 0.0;
      trim.m_pbox.m_max.z = 0.0;
      rc = true;
    }
  }
  return rc;
}

ON_BrepTrim& 
ON_Brep::NewTrim( int c2i )
{
  m_is_solid = 0;
  int ti = m_T.Count();
  ON_BrepTrim& trim = m_T.AppendNew();
  trim.m_brep = this;
  trim.m_trim_index = ti;
  trim.m_ei = -1;
  trim.m_type = ON_BrepTrim::unknown;
  trim.m_bRev3d = false;
  trim.m_c2i = c2i;
  trim.m_iso = ON_Surface::not_iso;
  trim.m_li = -1;
  trim.m_tolerance[0] = ON_UNSET_VALUE;
  trim.m_tolerance[1] = ON_UNSET_VALUE;
  trim.m__legacy_2d_tol = ON_UNSET_VALUE;
  trim.m__legacy_3d_tol = ON_UNSET_VALUE;
  trim.m__legacy_flags = 0;
  const ON_Curve* c2 = (c2i >= 0 && c2i < m_C2.Count()) 
                     ? m_C2[c2i] 
                     : 0;
  if ( c2 ) 
  {
    trim.SetProxyCurve( c2 );
    trim.m_pbox = c2->BoundingBox();
    trim.m_pbox.m_min.z = 0.0;
    trim.m_pbox.m_max.z = 0.0;
  }

  return trim;
}

ON_BrepTrim& 
ON_Brep::NewTrim( ON_BrepEdge& edge, ON_BOOL32 bRev3d, int c2i )
{
  m_is_solid = 0;
  ON_BrepTrim& trim = NewTrim( c2i );
  trim.m_ei = edge.m_edge_index;
  edge.m_ti.Append(trim.m_trim_index);
  trim.m_vi[0] = edge.m_vi[bRev3d?1:0];
  trim.m_vi[1] = edge.m_vi[bRev3d?0:1];
  trim.m_bRev3d = bRev3d?true:false;
  return trim;
}


ON_BrepTrim& 
ON_Brep::NewTrim( ON_BrepEdge& edge, ON_BOOL32 bRev3d, ON_BrepLoop& loop, int c2i )
{
  m_is_solid = 0;
  const int edge_trim_count0 = edge.m_ti.Count();
  ON_BrepTrim& trim = NewTrim( edge, bRev3d, c2i );
  trim.m_li = loop.m_loop_index;
  loop.m_ti.Append(trim.m_trim_index);
  if ( c2i >= 0 && c2i < m_C2.Count() )
  {
    ON_Curve* c2 = m_C2[c2i];
    if ( c2 )
    {
      ON_BoundingBox c2_bbox;
      if ( c2->GetBoundingBox(c2_bbox) )
      {
        c2_bbox.m_min.z = 0.0;
        c2_bbox.m_max.z = 0.0;
        if ( loop.m_ti.Count() == 1 )
          loop.m_pbox = c2_bbox;
        else
          loop.m_pbox.Union(c2_bbox);
      }
    }
  }

  if ( edge_trim_count0 == 0 )
  {
    // This is the only trim using this edge.
    //
    // At the moment it's a boundary trim.  The type
    // will be changed to seam or mated when
    // another trim is added that uses this edge.
    trim.m_type = ON_BrepTrim::boundary;
  }
  else if ( edge_trim_count0 == 1 )
  {
    // there are now two trims using this edge
    ON_BrepTrim::TYPE trim_type = ON_BrepTrim::mated;
    ON_BrepTrim& other_trim = m_T[edge.m_ti[0]];
    if ( other_trim.m_li == loop.m_loop_index )
      trim_type = ON_BrepTrim::seam;
    else 
      trim_type = ON_BrepTrim::mated;
    trim.m_type = trim_type;
    other_trim.m_type = trim_type;
  }
  else
  {
    // non-manifold edge - need to check for mated or seam
    ON_BrepTrim::TYPE trim_type = ON_BrepTrim::mated;
    for ( int eti = 0; eti < edge_trim_count0; eti++ )
    {
      ON_BrepTrim& other_trim = m_T[edge.m_ti[eti]];
      if ( other_trim.m_li == loop.m_loop_index )
      {
        other_trim.m_type = ON_BrepTrim::seam;
        trim_type = ON_BrepTrim::seam;
        break;
      }
    }
    trim.m_type = trim_type;
  }
  return trim;
}


ON_BrepTrim& 
ON_Brep::NewTrim( ON_BOOL32 bRev3d, ON_BrepLoop& loop, int c2i )
{
  m_is_solid = 0;
  ON_BrepTrim& trim = NewTrim( c2i );
  trim.m_bRev3d = bRev3d ? true : false;
  trim.m_li = loop.m_loop_index;
  loop.m_ti.Append(trim.m_trim_index);
  if ( c2i >= 0 && c2i < m_C2.Count() )
  {
    const ON_Curve* c2 = m_C2[c2i];
    if ( c2 )
    {
      ON_BoundingBox c2_bbox;
      if ( c2->GetBoundingBox(c2_bbox) )
      {
        c2_bbox.m_min.z = 0.0;
        c2_bbox.m_max.z = 0.0;
        if ( loop.m_ti.Count() == 1 )
          loop.m_pbox = c2_bbox;
        else
          loop.m_pbox.Union( c2_bbox );
      }
    }
  }
  return trim;
}

ON_BrepTrim&
ON_Brep::NewSingularTrim(const ON_BrepVertex& vertex,ON_BrepLoop& loop, ON_Surface::ISO iso, int c2i)
{
  ON_BrepTrim& trim = NewTrim(false,loop,c2i);
  trim.m_vi[0] = vertex.m_vertex_index;
  trim.m_vi[1] = trim.m_vi[0];
  trim.m_type = ON_BrepTrim::singular;
  trim.m_iso = iso;
  trim.m_tolerance[0] = 0.0;
  trim.m_tolerance[1] = 0.0;
  trim.m__legacy_2d_tol = 0.0;
  trim.m__legacy_3d_tol = 0.0;
  trim.m__legacy_flags_Set(-1,1);
  return trim;
}

void ON_Brep::Append( const ON_Brep& b )
{
  int i, j, jcnt;

  const int vcount0  = m_V.Count();
  const int ecount0  = m_E.Count();
  const int fcount0  = m_F.Count();
  const int tcount0  = m_T.Count();
  const int lcount0  = m_L.Count();
  const int c2count0 = m_C2.Count();
  const int c3count0 = m_C3.Count();
  const int scount0  = m_S.Count();

  const int vcount1  = b.m_V.Count();
  const int ecount1  = b.m_E.Count();
  const int fcount1  = b.m_F.Count();
  const int tcount1  = b.m_T.Count();
  const int lcount1  = b.m_L.Count();
  const int c2count1 = b.m_C2.Count();
  const int c3count1 = b.m_C3.Count();
  const int scount1  = b.m_S.Count();

  // need to duplicate geometry
  ON_Object* obj;
  ON_Curve* c;
  ON_Surface* s;
  for ( i = 0; i < scount1; i++ ) {
    s = b.m_S[i];
    if ( s ) {
      obj = s->Duplicate();
      s = ON_Surface::Cast(obj);
      if ( !s )
        delete obj;
    }
    m_S.Append(s);
  }
  for ( i = 0; i < c2count1; i++ ) {
    c = b.m_C2[i];
    if ( c ) {
      obj = c->Duplicate();
      c = ON_Curve::Cast(obj);
      if ( !c )
        delete obj;
    }
    m_C2.Append(c);
  }
  for ( i = 0; i < c3count1; i++ ) {
    c = b.m_C3[i];
    if ( c ) {
      obj = c->Duplicate();
      c = ON_Curve::Cast(obj);
      if ( !c )
        delete obj;
    }
    m_C3.Append(c);
  }

  // copy topology info
  m_V.Append( b.m_V.Count(), b.m_V.Array() );
  m_E.Append( b.m_E.Count(), b.m_E.Array() );
  m_F.Append( b.m_F.Count(), b.m_F.Array() );
  m_T.Append( b.m_T.Count(), b.m_T.Array() );
  m_L.Append( b.m_L.Count(), b.m_L.Array() );

  // update indices
  for ( i = 0; i < vcount1; i++ ) {
    ON_BrepVertex& vertex = m_V[vcount0+i];
    if ( vertex.m_vertex_index >= 0 )
      vertex.m_vertex_index += vcount0;
    else
      vertex.m_vertex_index = -1;
    jcnt = vertex.m_ei.Count();
    for ( j = 0; j < jcnt; j++ ) {
      if ( vertex.m_ei[j] >=0 )
        vertex.m_ei[j] += ecount0;
    }
  }

  for ( i = 0; i < ecount1; i++ ) 
  {
    ON_BrepEdge& edge = m_E[ecount0+i];
    if ( edge.m_edge_index >= 0 )
      edge.m_edge_index += ecount0;
    else
      edge.m_edge_index = -1;
    if ( edge.m_c3i >= 0 ) 
      edge.m_c3i += c3count0;
    if ( edge.m_vi[0] >= 0 )
      edge.m_vi[0] += vcount0;
    if ( edge.m_vi[1] >= 0 )
      edge.m_vi[1] += vcount0;
    jcnt = edge.m_ti.Count();
    for ( j = 0; j < jcnt; j++ ) {
      if ( edge.m_ti[j] >= 0 )
        edge.m_ti[j] += tcount0;
    }
    edge.m_brep = this;
    if (edge.m_c3i >= 0)
      edge.SetProxyCurve( m_C3[edge.m_c3i], b.m_E[i].ProxyCurveDomain() );
    else 
      edge.SetProxyCurve( 0, b.m_E[i].ProxyCurveDomain() );
    if ( b.m_E[i].ProxyCurveIsReversed() != edge.ProxyCurveIsReversed() )
      edge.ON_CurveProxy::Reverse();
    edge.SetDomain( b.m_E[i].Domain() );
  }

  for ( i = 0; i < tcount1; i++ ) {
    ON_BrepTrim& trim = m_T[tcount0+i];
    trim.m_brep = this;
    if ( trim.m_trim_index == i )
      trim.m_trim_index = tcount0+i;
    else
      trim.m_trim_index = -1;
    if ( trim.m_c2i >= 0 )
      trim.m_c2i += c2count0;
    if ( trim.m_ei >= 0 )
      trim.m_ei += ecount0;
    if ( trim.m_vi[0] >= 0 )
      trim.m_vi[0] += vcount0;
    if ( trim.m_vi[1] >= 0 )
      trim.m_vi[1] += vcount0;
    if ( trim.m_li >= 0 )
      trim.m_li += lcount0;
    if (trim.m_c2i >= 0)
      trim.SetProxyCurve( m_C2[trim.m_c2i], b.m_T[i].ProxyCurveDomain() );
    else 
      trim.SetProxyCurve( 0, b.m_T[i].ProxyCurveDomain() );
    if ( b.m_T[i].ProxyCurveIsReversed() != trim.ProxyCurveIsReversed() )
      trim.ON_CurveProxy::Reverse();
    trim.SetDomain( b.m_T[i].Domain() );
  }

  for ( i = 0; i < lcount1; i++ ) 
  {
    ON_BrepLoop& loop = m_L[lcount0+i];
    if ( loop.m_loop_index >= 0 )
      loop.m_loop_index += lcount0;
    else
      loop.m_loop_index = -1;
    jcnt = loop.m_ti.Count();
    for ( j = 0; j < jcnt; j++ ) {
      if ( loop.m_ti[j] >= 0)
        loop.m_ti[j] += tcount0;
    }
    if ( loop.m_fi >= 0 )
      loop.m_fi += fcount0;
    loop.m_brep = this;
  }

  for ( i = 0; i < fcount1; i++ ) {
    ON_BrepFace& face = m_F[fcount0+i];
    if ( face.m_face_index >= 0 )
      face.m_face_index += fcount0;
    else
      face.m_face_index = -1;
    jcnt = face.m_li.Count();
    for ( j = 0; j < jcnt; j++ ) {
      if ( face.m_li[j] >= 0 )
        face.m_li[j] += lcount0;
    }
    if ( face.m_si >= 0 )
    {
      face.m_si += scount0;
      face.SetProxySurface(m_S[face.m_si]);
    }
    else
    {
      face.SetProxySurface( 0 );
    }
    face.m_brep = this;
  }

  //grow bounding box if possible.  otherwise invalidate it.
  if (m_bbox.IsValid() && b.BoundingBox().IsValid())
    m_bbox.Union(b.BoundingBox());
  else m_bbox.Destroy();

  m_is_solid = 0;

  DestroyMesh(ON::any_mesh);

  return;
}

ON_BrepLoop& 
ON_Brep::NewLoop( ON_BrepLoop::TYPE looptype )
{
  m_is_solid = 0;
  int li = m_L.Count();
  m_L.Reserve(li+1);
  m_L.SetCount(li+1);
  ON_BrepLoop& loop =  m_L.Array()[li];
  loop.m_loop_index = li;
  loop.m_type = looptype;
  loop.m_brep = this;
  return loop;
}

ON_BrepLoop& 
ON_Brep::NewLoop( ON_BrepLoop::TYPE looptype, ON_BrepFace& face )
{
  m_is_solid = 0;
  ON_BrepLoop& loop = NewLoop( looptype );
  loop.m_fi = face.m_face_index;
  if ( ON_BrepLoop::outer == looptype )
  {
    // the index of the outer loop is always 
    // in face.m_li[0]
    face.m_li.Insert(0,loop.m_loop_index);
  }
  else
  {
    face.m_li.Append(loop.m_loop_index);
  }
  loop.m_brep = this;
  return loop;
}

ON_BrepLoop* ON_Brep::NewOuterLoop( int face_index )
{
  m_is_solid = 0;
  int vid[4] = {-1,-1,-1,-1};
  int eid[4] = {-1,-1,-1,-1};
  ON_BOOL32 bRev3d[4] = {0,0,0,0};
  return NewOuterLoop( face_index,vid,eid,bRev3d);
}

ON_BrepFace& ON_Brep::NewFace( int si )
{
  m_bbox.Destroy();
  m_is_solid = 0;
  int fi = m_F.Count();
  m_F.Reserve(fi+1);
  m_F.SetCount(fi+1);
  ON_BrepFace& face = m_F.Array()[fi];
  face.m_face_index = fi;
  face.m_si = si;
  face.m_brep = this;
  if ( si >= 0 && si < m_S.Count() )
  {
    face.SetProxySurface(m_S[si]);
    if ( face.ProxySurface() )
      face.m_bbox = face.ProxySurface()->BoundingBox();
  }
  return face;
}

ON_BrepFace* ON_Brep::NewFace( const ON_Surface& surface )
{
  m_bbox.Destroy();
  m_is_solid = 0;
  ON_BrepFace* face = NULL;
  ON_Surface* pSurface = surface.DuplicateSurface();
  if ( pSurface )
  {
    int vid[4] = {-1,-1,-1,-1};
    int eid[4] = {-1,-1,-1,-1};
    ON_BOOL32 bRev3d[4] = {0,0,0,0};
    face = NewFace(pSurface,vid,eid,bRev3d);
  }
  return face;
}



bool
ON_Brep::SetTrimIsoFlags()
{
  bool rc = true;
  int fi;
  const int fcnt = m_F.Count();
  for ( fi = 0; fi < fcnt; fi++ ) {
    if ( !SetTrimIsoFlags( m_F[fi] ) )
      rc = false;
  }
  return rc;
}

bool
ON_Brep::SetTrimIsoFlags( ON_BrepFace& face )
{
  bool rc = true;
  int fli;
  const int face_loop_count = face.m_li.Count();
  for ( fli = 0; fli < face_loop_count; fli++ ) {
    if ( !SetTrimIsoFlags( m_L[face.m_li[fli]] ) )
      rc = false;
  }
  return rc;
}

bool
ON_Brep::SetTrimIsoFlags( ON_BrepLoop& loop )
{
  bool rc = true;
  int lti;
  const int loop_trim_count = loop.m_ti.Count();
  for ( lti = 0; lti < loop_trim_count; lti++ ) {
    if ( !SetTrimIsoFlags( m_T[loop.m_ti[lti]] ) )
      rc = false;
  }
  return rc;
}

bool
ON_Brep::SetTrimIsoFlags( ON_BrepTrim& trim )
{
  bool rc = false;
  if ( trim.m_li >= 0 && trim.m_li < m_L.Count() )
  {
    const int fi = m_L[trim.m_li].m_fi;
    if ( fi >= 0 && fi < m_F.Count() )
    {
      const ON_Surface* pS = m_F[fi].SurfaceOf();
      if ( pS )
      {
        const ON_Curve* pC = (trim.m_c2i >= 0 && trim.m_c2i < m_C2.Count()) 
                           ? m_C2[trim.m_c2i]
                           : 0;
        if ( pC ) 
        {
          ON_Interval PD = trim.ProxyCurveDomain(); 
          trim.m_iso = pS->IsIsoparametric( *pC, &PD);
          rc = true;
        }
      }
    }
  }
  return rc;
}

bool
ON_Brep::SetTrimTypeFlags( ON_BOOL32 bLazy )
{
  bool rc = true;
  int fi;
  const int fcnt = m_F.Count();
  for ( fi = 0; fi < fcnt; fi++ ) {
    if ( !SetTrimTypeFlags( m_F[fi], bLazy ) )
      rc = false;
  }
  return rc;
}

bool
ON_Brep::SetTrimTypeFlags( ON_BrepFace& face, ON_BOOL32 bLazy )
{
  bool rc = true;
  int fli;
  const int face_loop_count = face.m_li.Count();
  for ( fli = 0; fli < face_loop_count; fli++ ) {
    if ( !SetTrimTypeFlags( m_L[face.m_li[fli]], bLazy ) )
      rc = false;
  }
  return rc;
}

bool
ON_Brep::SetTrimTypeFlags( ON_BrepLoop& loop, ON_BOOL32 bLazy )
{
  bool rc = true;
  int lti;
  const int loop_trim_count = loop.m_ti.Count();
  for ( lti = 0; lti < loop_trim_count; lti++ ) {
    if ( !SetTrimTypeFlags( m_T[loop.m_ti[lti]], bLazy ) )
      rc = false;
  }
  return rc;
}

ON_BrepTrim::TYPE ON_Brep::TrimType( const ON_BrepTrim& trim, ON_BOOL32 bLazy ) const
{
  ON_BrepTrim::TYPE trim_type = bLazy ? trim.m_type : ON_BrepTrim::unknown;
  int eti, other_ti;

  if ( trim_type == ON_BrepTrim::unknown && trim.m_li >= 0 && trim.m_li < m_L.Count() ) 
  {
    const ON_BrepLoop& loop = m_L[trim.m_li];
    if ( loop.m_type == ON_BrepLoop::ptonsrf )
      trim_type = ON_BrepTrim::ptonsrf;
    else if (loop.m_type == ON_BrepLoop::crvonsrf )
      trim_type = ON_BrepTrim::crvonsrf;
    else if ( trim.m_ei == -1 ) 
    {
      trim_type = ON_BrepTrim::singular;
    }
    else if ( trim.m_ei >= 0 && trim.m_ei < m_E.Count() ) 
    {
      const ON_BrepEdge& edge = m_E[trim.m_ei];
      if ( edge.m_ti.Count() == 1 && edge.m_ti[0] == trim.m_trim_index ) 
      {
        trim_type = ON_BrepTrim::boundary;
      }
      else if ( edge.m_ti.Count() > 1 ) 
      {
        trim_type = ON_BrepTrim::mated;
        // check for seam
        for ( eti = 0; eti < edge.m_ti.Count(); eti++ ) 
        {
          other_ti = edge.m_ti[eti];
          if ( other_ti != trim.m_trim_index && other_ti >= 0 && other_ti < m_T.Count() ) 
          {
            if ( m_T[other_ti].m_li == trim.m_li ) 
            {
              trim_type = ON_BrepTrim::seam;
              break;
            }
          }
        }
      }
    }
  }
  return trim_type;
}

bool
ON_Brep::SetTrimTypeFlags( ON_BrepTrim& trim, ON_BOOL32 bLazy )
{
  if ( !bLazy || trim.m_type == ON_BrepTrim::unknown)
    trim.m_type = TrimType(trim,false);
  return ((trim.m_type != ON_BrepTrim::unknown)?true:false);
}

bool
ON_Brep::GetTrim2dStart(int trim_index,
                        ON_2dPoint& P
                        ) const

{
  if (trim_index < 0 || trim_index >= m_T.Count())
    return false;
  const ON_BrepTrim& trim = m_T[trim_index];
  ON_3dPoint pp;
  if (!trim.EvPoint(trim.Domain()[0], pp)) 
    return false;
  P = pp;
  return true;
}

bool
ON_Brep::GetTrim2dEnd(int trim_index,
                        ON_2dPoint& P
                        ) const

{
  if (trim_index < 0 || trim_index >= m_T.Count())
    return false;
  const ON_BrepTrim& trim = m_T[trim_index];
  ON_3dPoint pp;
  if (!trim.EvPoint(trim.Domain()[1], pp))
    return false;
  P = pp;
  return true;
}

bool
ON_Brep::GetTrim3dStart(int trim_index,
                        ON_3dPoint& P
                        ) const
{
  const ON_Surface* srf = 0;
  ON_3dPoint uv;
  if ( trim_index >= 0 && trim_index < m_T.Count() )
  {
    const ON_BrepTrim& trim = m_T[trim_index];
    if ( trim.m_li >= 0 && trim.m_li < m_L.Count() )
    {
      const int fi = m_L[trim.m_li].m_fi;
      if ( fi >= 0 && fi < m_F.Count() )
      {
        if ( trim.Evaluate(trim.Domain()[0],0,3,&uv.x) )
        {
          srf = m_F[fi].SurfaceOf();
        }
      }
    }
  }
  return (srf && srf->EvPoint(uv.x, uv.y, P) ? true : false);
}

bool
ON_Brep::GetTrim3dEnd(int trim_index,
                        ON_3dPoint& P
                        ) const

{
  const ON_Surface* srf = 0;
  ON_3dPoint uv;
  if ( trim_index >= 0 && trim_index < m_T.Count() )
  {
    const ON_BrepTrim& trim = m_T[trim_index];
    if ( trim.m_li >= 0 && trim.m_li < m_L.Count() )
    {
      const int fi = m_L[trim.m_li].m_fi;
      if ( fi >= 0 && fi < m_F.Count() )
      {
        if ( trim.Evaluate(trim.Domain()[1],0,3,&uv.x) )
        {
          srf = m_F[fi].SurfaceOf();
        }
      }
    }
  }
  return (srf && srf->EvPoint(uv.x, uv.y, P) ? true : false);
}


ON_BrepLoop::TYPE 
ON_Brep::ComputeLoopType( const ON_BrepLoop& loop ) const
{
  // This function must always compute the type from the
  // 2d trim geometry.  NEVER modify this function to
  // return the input value of loop.m_type.

  ON_BrepLoop::TYPE loop_type = ON_BrepLoop::unknown;

  int loop_dir =  LoopDirection( loop );
  if ( 1 == loop_dir )
    loop_type = ON_BrepLoop::outer;
  else if ( -1 == loop_dir )
    loop_type = ON_BrepLoop::inner;

  // TODO check for gaps, slits, etc.

  /*
  int ugap_count = 0;
  int vgap_count = 0;
  double d, utol0, vtol0, loop_start_utol, loop_start_vtol;
  ON_3dPoint p0, p1, loop_start;
  ON_Interval srf_domain[2];
  if ( loop.m_fi >= 0 && loop.m_fi < m_F.Count() ) {
    const ON_BrepFace& face = m_F[loop.m_fi];
    if ( face.m_si >= 0 && face.m_si < m_S.Count() ) {
      ON_Surface* srf = m_S[face.m_si];
      srf_domain[0] = srf->Domain(0);
      srf_domain[1] = srf->Domain(1);
    }
  }
  const ON_2dPoint basePt( srf_domain[0].ParameterAt(0.5), srf_domain[1].ParameterAt(0.5) );

  const int trim_count = loop.m_ti.Count();
  for ( lti = 0; lti < trim_count; lti++ ) 
  {
    ti = loop.m_ti[lti];
    const ON_BrepTrim& trim = m_T[ti];
    p0 = trim.PointAtStart();
    u_tol0 = trim.m_tolerance[0];
    v_tol0 = trim.m_tolerance[1];
    if ( !lti ) 
    {
      loop_start = p0;
      loop_start_utol = trim.m_tolerance[0];
      loop_start_vtol = trim.m_tolerance[1];
    }
    else 
    {
      d = fabs(p0.x-p1.x);
      if ( d > utol0 + trim.m_tolerance[0] )
        ugap_count++;
      d = fabs(p0.y-p1.y);
      if ( d > vtol0 + trim.m_tolerance[1] )
        vgap_count++;
    }
    p1 = c2->PointAtEnd();
  }
  */

  return loop_type;
}


bool
ON_Brep::IsValidTrim( int trim_index, ON_TextLog* text_log ) const
{
  if ( trim_index < 0 || trim_index >= m_T.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep trim_index = %d (should be >=0 and <%d=brep.m_T.Count()).\n",
                      trim_index, m_T.Count());
    }
    return ON_BrepIsNotValid();
  }
  const ON_BrepTrim& trim = m_T[trim_index];
  if ( trim.m_trim_index != trim_index )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.m_trim_index = %d (should be %d).\n",
                       trim.m_trim_index, trim_index );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  if ( !trim.IsValid(text_log) )
  {
    if ( text_log )
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
    return ON_BrepIsNotValid();
  }
  if ( trim.m_c2i < 0 || trim.m_c2i >= m_C2.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print( "trim.m_c2i = %d (should be >=0 and <%d).\n", trim.m_c2i, 0, m_C2.Count() );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  const ON_Curve* pC = m_C2[trim.m_c2i];
  if ( !pC )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.m_c2i = %d and ON_Brep.m_C2[%d] is NULL\n", trim.m_c2i, trim.m_c2i );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  int c2_dim = pC->Dimension();
  if ( c2_dim != 2 )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.m_c2i = %d and ON_Brep.m_C2[%d]->Dimension() = %d (should be 2).\n", trim.m_c2i, trim.m_c2i, c2_dim );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  if ( pC != trim.ProxyCurve() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.ProxyCurve() != m_C2[trim.m_c2i].\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  //if ( trim.ProxyCurveIsReversed() )
  //{
  //  if ( text_log )
  //  {
  //    text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
  //    text_log->PushIndent();
  //    text_log->Print("trim.ProxyCurveIsReversed() is true\n");
  //    text_log->PopIndent();
  //  }
  //  return ON_BrepIsNotValid();
  //}

  ON_Interval trim_domain = trim.Domain();
  ON_Interval c2_domain = pC->Domain();
  if ( !trim_domain.IsIncreasing() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.Domain() = (%g,%g) (should be an increasing interval).\n", trim_domain[0], trim_domain[1] );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  if ( !c2_domain.Includes(trim_domain) )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.Domain() = (%g,%g) is not included in brep.m_C2[trim.m_c2i=%d]->Domain() = (%g,%g)\n",
                      trim_domain[0], trim_domain[1], trim.m_c2i, c2_domain[0], c2_domain[1] );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  int vi0 = trim.m_vi[0];
  int vi1 = trim.m_vi[1];
  if ( vi0 < 0 || vi0 >= m_V.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.m_vi[0] = %d (should be >= 0 and < %d=brep.m_V.Count()).\n",
                       trim_index, vi0, m_V.Count() );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  if ( vi1 < 0 || vi1 >= m_V.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.m_vi[1] = %d (should be >= 0 and < %d=brep.m_V.Count()).\n",
                       trim_index, vi1, m_V.Count() );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  const int ei = trim.m_ei;
  int trim_eti = -1;
  if ( trim.m_type == ON_BrepTrim::singular ) 
  {
    // singular trim - no edge and 3d v0 = 3d v1
    if ( ei != -1 )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim.m_type = singular but trim.m_ei = %d (should be -1)\n",ei);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    if ( vi0 != vi1 )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim.m_type = singular but trim.m_vi[] = [%d,%d] (the m_vi[] values should be equal).\n",
                        vi0,vi1);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    if ( pC->IsClosed() )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim.m_type = singular but brep.m_C2[trim.m_c2i=%d]->IsClosed() is true.\n",
                        trim.m_c2i,trim.m_c2i);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
  }
  else if ( trim.m_type != ON_BrepTrim::ptonsrf )
  {
    // non-singular non-ptonsrf trim must have valid edge
    if ( ei < 0 || ei >= m_E.Count() )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim.m_type != singular and trim.m_ei = %d (m_ei should be >=0 and <brep.m_E.Count()=%d\n",
                        trim.m_ei,m_E.Count());
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    const ON_BrepEdge& edge = m_E[ei];
    if ( edge.m_vi[trim.m_bRev3d?1:0] != vi0 )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim.m_vi[0] != brep.m_E[trim.m_ei=%d].m_vi[trim.m_bRev3d?1:0]\n",ei);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    if ( edge.m_vi[trim.m_bRev3d?0:1] != vi1 )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim.m_vi[1] != brep.m_E[trim.m_ei=%d].m_vi[trim.m_bRev3d?0:1]\n",ei);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    if ( trim_domain == c2_domain && pC->IsClosed() ) 
    {
      // (open 2d trims can still have vi0 = vi1 on closed surfaces)
      if ( vi0 != vi1 )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
          text_log->PushIndent();
          text_log->Print("trim.m_vi[] = [%d,%d] but brep.m_C2[trim.m_c2i=%d]->IsClosed()=true\n",
                          vi0, vi1, trim.m_c2i );
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
    }
    else if ( vi0 == vi1 )
    {
      // TODO: check that trim start/end is a closed surface seam point.
    }
    else
    {
      // vi0 != vi1
      // TODO: check that trim start/end is not a closed surface seam point.
    }
    int i;
    for ( i = 0; i < edge.m_ti.Count(); i++ ) 
    {
      if ( edge.m_ti[i] == trim_index )
      {
        trim_eti = i;
        break;
      }
    }

    if ( trim_eti < 0 )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim index %d is not in brep.m_E[trim.m_ei=%d].m_ti[]\n",
                        trim_index, trim.m_ei );
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }

    if ( edge.m_ti.Count() == 2 )
    {
      int other_ti = edge.m_ti[ (edge.m_ti[0]==trim_index)?1:0 ];
      if ( other_ti >= 0 && other_ti < m_T.Count() && other_ti != trim_index )
      {
        const ON_BrepTrim& other_trim = m_T[other_ti];
        if ( other_trim.m_li == trim.m_li )
        {
          if ( trim.m_type != ON_BrepTrim::seam )
          {
            if ( text_log )
            {
              text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
              text_log->PushIndent();
              text_log->Print("trim.m_type!=seam but brep.m_E[trim.m_ei=%d] references two trims in loop trim.m_li=%d.\n",
                              trim.m_ei,trim.m_li);
              text_log->PopIndent();
            }
            return ON_BrepIsNotValid();
          }
        }
      }
    }
  }
  if ( trim.m_li < 0 || trim.m_li >= m_L.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.m_li = %d (should be >= 0 and <brep.m_L.Count()=%d\n", trim.m_li,m_L.Count() );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  if ( trim.m_ei >= 0 && trim_eti < 0 )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("brep.m_E[trim.m_ei=%d].m_ti[] does not reference the trim.\n",trim.m_ei);
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }


  switch ( trim.m_type )
  {
  case ON_BrepTrim::unknown:
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim.m_type = unknown (should be set to the correct ON_BrepTrim::TYPE value)\n");
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    break;
  case ON_BrepTrim::boundary:
    {
      const ON_BrepLoop& loop = m_L[trim.m_li];
      const ON_BrepEdge& edge = m_E[trim.m_ei];
      if ( edge.m_ti.Count() > 1 )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
          text_log->PushIndent();
          text_log->Print("trim.m_type = boundary but brep.m_E[trim.m_ei=%d] has 2 or more trims.\n",trim.m_ei);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
      if ( loop.m_type != ON_BrepLoop::outer && loop.m_type != ON_BrepLoop::inner )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
          text_log->PushIndent();
          text_log->Print("trim.m_type = boundary but brep.m_L[trim.m_li=%d].m_type is not inner or outer.\n",trim.m_li);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
    }
    break;
  case ON_BrepTrim::mated:
    {
      const ON_BrepLoop& loop = m_L[trim.m_li];
      const ON_BrepEdge& edge = m_E[trim.m_ei];
      if ( edge.m_ti.Count() < 2 )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
          text_log->PushIndent();
          text_log->Print("trim.m_type = mated but brep.m_E[trim.m_ei=%d] only references this trim.\n",trim.m_ei);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
      if ( loop.m_type != ON_BrepLoop::outer && loop.m_type != ON_BrepLoop::inner )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
          text_log->PushIndent();
          text_log->Print("trim.m_type = mated but brep.m_L[trim.m_li=%d].m_type is not inner or outer.\n",trim.m_li);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
    }
    break;
  case ON_BrepTrim::seam:
    {
      const ON_BrepLoop& loop = m_L[trim.m_li];
      const ON_BrepEdge& edge = m_E[trim.m_ei];
      if ( edge.m_ti.Count() < 2 )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
          text_log->PushIndent();
          text_log->Print("trim.m_type = seam but brep.m_E[trim.m_ei=%d] < 2.\n",trim.m_ei);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
      int other_ti = -1;
      for ( int eti = 0; eti < edge.m_ti.Count(); eti++ ) 
      {
        if ( trim_eti == eti )
          continue;
        int i = edge.m_ti[eti];
        if ( i == trim_index )
        {
          if ( text_log )
          {
            text_log->Print("brep.m_E[%d] trim is not valid.\n",trim.m_ei);
            text_log->PushIndent();
            text_log->Print("edge.m_ti[%d] = m_ti[%d] = %d.\n",trim_eti,eti,trim_index);
            text_log->PopIndent();
          }
          return ON_BrepIsNotValid();
        }

        if ( i < 0 || i >= m_T.Count() )
        {
          if ( text_log )
          {
            text_log->Print("brep.m_E[%d] trim is not valid.\n",trim.m_ei);
            text_log->PushIndent();
            text_log->Print("edge.m_ti[%d]=%d is not a valid m_T[] index.\n",eti,i);
            text_log->PopIndent();
          }
          return ON_BrepIsNotValid();
        }

        const ON_BrepTrim& other_trim = m_T[i];
        if ( other_trim.m_type == ON_BrepTrim::seam && other_trim.m_li == trim.m_li )
        {
          if ( other_ti < 0 )
            other_ti = i;
          else
          {
            if ( text_log )
            {
              text_log->Print("brep.m_T[%d,%d, or %d] trim is not valid.\n",trim_index,other_ti,i);
              text_log->PushIndent();
              text_log->Print("All three trims have m_type = seam m_ei=%d and m_li = %d.\n",trim.m_ei,trim.m_li);
              text_log->PopIndent();
            }
            return ON_BrepIsNotValid();
          }
        }
      }

      if ( other_ti < 0 )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
          text_log->PushIndent();
          text_log->Print("trim.m_type = seam but its other trim is not in the loop.\n");
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }

      if ( loop.m_type != ON_BrepLoop::outer && edge.m_ti.Count() <= 2 )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
          text_log->PushIndent();
          text_log->Print("trim.m_type = seam, the edge is manifold, but brep.m_L[trim.m_li=%d].m_type is not outer.\n",trim.m_li);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
      // 31 Jan 2002 - The definition of a seam trim is a trim that is connected to
      //               an edge, is part of loop, and exactly one other trim in the
      //               same loop is connected to the same edge.  This can happen
      //               on the interior of a surface (like an annulus in a plane)
      //               and on non-manifold edges.
      //if ( trim.m_iso != ON_Surface::W_iso && trim.m_iso != ON_Surface::N_iso &&
      //     trim.m_iso != ON_Surface::E_iso && trim.m_iso != ON_Surface::S_iso )
      //{
      //  if ( text_log )
      //  {
      //    text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      //    text_log->PushIndent();
      //    text_log->Print("trim.m_type = seam but trim.m_iso != N/S/E/W_iso\n");
      //    text_log->PopIndent();
      //  }
      //  return ON_BrepIsNotValid();
      //}
    }
    break;
  case ON_BrepTrim::singular:
    // most requirements are checked above
    if ( trim.m_iso != ON_Surface::W_iso && trim.m_iso != ON_Surface::N_iso &&
         trim.m_iso != ON_Surface::E_iso && trim.m_iso != ON_Surface::S_iso )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim.m_type = singular but trim.m_iso != N/S/E/W_iso\n");
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    break;
  case ON_BrepTrim::crvonsrf:
    {
      const ON_BrepLoop& loop = m_L[trim.m_li];
      if ( loop.m_type != ON_BrepLoop::crvonsrf )
      {
        return ON_BrepIsNotValid();
      }
      if ( trim.m_c2i < 0 || trim.m_c2i >= m_C2.Count() )
      {
        return ON_BrepIsNotValid();
      }
      if ( trim.m_ei < 0 || trim.m_ei >= m_E.Count() )
      {
        return ON_BrepIsNotValid();
      }
    }
    break;
  case ON_BrepTrim::ptonsrf:
    {
      const ON_BrepLoop& loop = m_L[trim.m_li];
      if ( loop.m_type != ON_BrepLoop::ptonsrf )
      {
        return ON_BrepIsNotValid();
      }
      if ( trim.m_ei != -1 )
      {
        return ON_BrepIsNotValid();
      }
      if ( trim.m_c2i != -1 )
      {
        return ON_BrepIsNotValid();
      }
      if ( trim.m_pbox.m_min.x != trim.m_pbox.m_max.x || trim.m_pbox.m_min.y != trim.m_pbox.m_max.y || trim.m_pbox.m_min.z != trim.m_pbox.m_max.z ) 
      {
        // m_pbox must be a single point that defines surface parameters of the point.
        return ON_BrepIsNotValid();
      }
      if ( trim.m_pbox.m_min.x == ON_UNSET_VALUE || trim.m_pbox.m_min.y == ON_UNSET_VALUE || trim.m_pbox.m_min.z != 0.0 ) 
      {
        // m_pbox must be a single point that defines surface parameters of the point.
        return ON_BrepIsNotValid();
      }
    }
    break;

  case ON_BrepTrim::slit:
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim.m_type = ON_BrepTrim::slit (should be set to the correct ON_BrepTrim::TYPE value)\n");
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    break;

  case ON_BrepTrim::trim_type_count:
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim.m_type = type_count (should be set to the correct ON_BrepTrim::TYPE value)\n");
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    break;

  default:
    {
      if ( text_log )
      {
        text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
        text_log->PushIndent();
        text_log->Print("trim.m_type = garbage (should be set to the correct ON_BrepTrim::TYPE value)\n");
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    break;
  }

  if ( trim.m_tolerance[0] < 0.0 )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.m_tolerance[0] = %g (should be >= 0.0)\n",trim.m_tolerance[0]);
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  if ( trim.m_tolerance[1] < 0.0 )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.m_tolerance[1] = %g (should be >= 0.0)\n",trim.m_tolerance[1]);
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  if ( !trim.m_pbox.IsValid() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.m_pbox is not valid.\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  if ( trim.m_brep != this )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_T[%d] trim is not valid.\n",trim_index);
      text_log->PushIndent();
      text_log->Print("trim.m_brep does not point to parent brep.\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  return true;
}

bool
ON_Brep::IsValidLoop( int loop_index, ON_TextLog* text_log  ) const
{
  if ( loop_index < 0 || loop_index >= m_L.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep loop_index = %d (should be >=0 and <%d=brep.m_L.Count()).\n",
                      loop_index, m_L.Count());
    }
    return ON_BrepIsNotValid();
  }
  const ON_BrepLoop& loop = m_L[loop_index];
  if ( loop.m_loop_index != loop_index )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_L[%d] loop is not valid.\n",loop_index);
      text_log->PushIndent();
      text_log->Print("loop.m_loop_index = %d (should be %d).\n",
                       loop.m_loop_index, loop_index );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  if ( loop.m_fi < 0 || loop.m_fi >= m_F.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_L[%d] loop is not valid.\n",loop_index);
      text_log->PushIndent();
      text_log->Print("loop.m_fi = %d (should be >= 0 and <brep.m_F.Count()=%d\n", loop.m_fi, m_F.Count() );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  const int loop_trim_count = loop.m_ti.Count();
  if ( loop_trim_count <= 0 )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_L[%d] loop is not valid.\n",loop_index);
      text_log->PushIndent();
      text_log->Print("loop.m_ti.Count() is <= 0  (should be > 0)\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  if (    loop.m_type != ON_BrepLoop::outer 
       && loop.m_type != ON_BrepLoop::inner 
       && loop.m_type != ON_BrepLoop::slit 
       )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_L[%d] loop is not valid.\n",loop_index);
      text_log->PushIndent();
      text_log->Print("loop.m_type = %d (must be %d=outer, %d=inner, or %d=slit)\n",
                      loop.m_type,ON_BrepLoop::outer,ON_BrepLoop::inner,ON_BrepLoop::slit);
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }


  if ( loop.m_brep != this )
  {
    if ( text_log )
    {
      text_log->Print("loop.m_L[%d] loop is not valid.\n",loop_index);
      text_log->PushIndent();
      text_log->Print("loop.m_brep does not point to parent brep.\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  // make sure trims are valid
  int i, lti, ti;
  for ( lti = 0; lti < loop_trim_count; lti++ ) {
    ti = loop.m_ti[lti];
    for ( i = 0; i < lti; i++ ) {
      if ( loop.m_ti[i] == ti )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_L[%d] loop is not valid.\n",loop_index);
          text_log->PushIndent();
          text_log->Print("loop.m_ti[%d] = loop.m_ti[%d] = %d (trim index can only appear once)\n",
                          lti, i, ti);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
    }
    if ( !IsValidTrim( ti, text_log ) )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_L[%d] loop is not valid.\n",loop_index);
        text_log->PushIndent();
        text_log->Print("brep.m_T[loop.m_ti[%d]=%d] is not valid.\n",
                        lti, ti);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    if ( m_T[ti].m_li != loop_index )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_L[%d] loop is not valid.\n",loop_index);
        text_log->PushIndent();
        text_log->Print("brep.m_T[loop.m_ti[%d]=%d].m_li=%d (m_li should be %d).\n",
                        lti, ti, m_T[ti].m_li, loop_index );
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
  }


  if ( ON_BrepLoop::slit == loop.m_type )
  {
    if ( loop.m_ti.Count() < 2 || 0 != (loop.m_ti.Count() % 2) )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_L[%d] loop is not valid.\n",loop_index);
        text_log->PushIndent();
        text_log->Print("loop.m_type = slit but loop has %d trims\n",loop.m_ti.Count());
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }

    for ( int lti = 0; lti < loop.m_ti.Count(); lti++ )
    {
      int ti = loop.m_ti[lti];
      const ON_BrepTrim& trim = m_T[ti];
      if ( trim.m_type != ON_BrepTrim::seam )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_L[%d] slit loop is not valid.\n",loop_index);
          text_log->PushIndent();
          text_log->Print("brep.m_T[loop.m_ti[%d]=%d].m_type = %d (should be %d = seam)\n",
                          lti,ti,trim.m_type,ON_BrepTrim::seam);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
      switch( trim.m_iso )
      {
      case ON_Surface::W_iso:
      case ON_Surface::E_iso:
      case ON_Surface::S_iso:
      case ON_Surface::N_iso:
        {
          if ( text_log )
          {
            text_log->Print("brep.m_L[%d] slit loop is not valid.\n",loop_index);
            text_log->PushIndent();
            text_log->Print("brep.m_T[loop.m_ti[%d]=%d].m_iso = E/W/N/S_iso (should be interior)\n",
                            lti,ti);
            text_log->PopIndent();
          }
          return ON_BrepIsNotValid();
        }
        break;

      case ON_Surface::not_iso:
      case ON_Surface::x_iso:
      case ON_Surface::y_iso:
      case ON_Surface::iso_count:
        break;
      }
    }   
  }

  const ON_Surface *surf = loop.Face()->SurfaceOf();
  double urange = surf->Domain(0)[1] - surf->Domain(0)[0];
  double vrange = surf->Domain(1)[1] - surf->Domain(1)[0];

  // make sure ends of trims jibe
  int ci0, ci1, next_lti;
  ON_3dPoint P0, P1;
  const ON_Curve *pC0, *pC1;
  for ( lti = 0; lti < loop_trim_count; lti++ ) 
  {
    //double x_tol = ON_ZERO_TOLERANCE;
    //double y_tol = ON_ZERO_TOLERANCE;
    const ON_BrepTrim& trim0 = m_T[loop.m_ti[lti]];
    next_lti = (lti+1)%loop_trim_count;
    const ON_BrepTrim& trim1 = m_T[loop.m_ti[next_lti]];
    ON_Interval trim0_domain = trim0.Domain();
    ON_Interval trim1_domain = trim1.Domain();
    ci0 = trim0.m_c2i;
    ci1 = trim1.m_c2i;
    pC0 = m_C2[ci0];
    pC1 = m_C2[ci1];
    P0 = pC0->PointAt( trim0_domain[1] ); // end of this 2d trim
    P1 = pC1->PointAt( trim1_domain[0] ); // start of next 2d trim
    if ( !(P0-P1).IsTiny() )
    {
       // **** Let Trims Cross a Seam ****
       // First lets see if this is a closed surface, if so check to see if trim endpoints
       // lie on seam, if so check the closeness of the endpoints in 3D.
       if (surf->IsClosed(0) || surf->IsClosed(1)) {
           if (surf->IsAtSeam(P0.x,P0.y) && surf->IsAtSeam(P1.x,P1.y)) {
               ON_3dPoint p0 = surf->PointAt(P0.x,P0.y);
               ON_3dPoint p1 = surf->PointAt(P1.x,P1.y);
               if ((p0-p1).IsTiny()) {
#if 0
                   if ( text_log )
                   {
                     text_log->Print("Face[%d]-Loop[%d] Crosses Seam:\n",loop.m_fi,loop.m_loop_index);
                     text_log->PushIndent();
                     text_log->Print("Trim[%d] ends at at 2d[%f %f], 3D[%f %f %f]\n",loop.m_ti[lti],P0.x,P0.y,p0.x,p0.y,p0.z);
                     text_log->Print("Trim[%d] starts at at 2d[%f %f], 3D[%f %f %f]\n",loop.m_ti[lti],P1.x,P1.y,p1.x,p1.y,p1.z);
                     text_log->PopIndent();
                   }
#endif
                   break;
               }
           }
       }

      // 16 September 2003 Dale Lear - RR 11319
      //    Added relative tol check so cases with huge
      //    coordinate values that agreed to 10 places
      //    didn't get flagged as bad.
      //double xtol = (fabs(P0.x) + fabs(P1.x))*1.0e-10;
      //double ytol = (fabs(P0.y) + fabs(P1.y))*1.0e-10;
      //
      // Oct 12 2009 Rather than using the above check, BRL-CAD uses
      // relative uv size
      double xtol = (urange) * trim0.m_tolerance[0];
      double ytol = (vrange) * trim0.m_tolerance[1];
      if ( xtol < ON_ZERO_TOLERANCE )
        xtol = ON_ZERO_TOLERANCE;
      if ( ytol < ON_ZERO_TOLERANCE )
        ytol = ON_ZERO_TOLERANCE;
      double dx = fabs(P0.x-P1.x);
      double dy = fabs(P0.y-P1.y);
      if ( dx > xtol || dy > ytol )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_L[%d] loop is not valid.\n",loop_index);
          text_log->PushIndent();
          text_log->Print("end of brep.m_T[loop.m_ti[%d]=%d]=(%g,%g) and start \n", lti, loop.m_ti[lti],P0.x,P0.y);
          text_log->Print("of brep.m_T[loop.m_ti[%d]=%d]=(%g,%g) do not match.\n",next_lti, loop.m_ti[next_lti],P1.x,P1.y);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
    }
  }

  if ( !loop.m_pbox.IsValid() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_L[%d] loop is not valid.\n",loop_index);
      text_log->PushIndent();
      text_log->Print("loop.m_pbox is not valid\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  return true; 
}


bool
ON_Brep::IsValidFace( int face_index, ON_TextLog* text_log  ) const
{
  if ( face_index < 0 || face_index >= m_F.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep face_index = %d (should be >=0 and <%d=brep.m_F.Count()).\n",
                      face_index, m_F.Count());
    }
    return ON_BrepIsNotValid();
  }
  const ON_BrepFace& face = m_F[face_index];
  if ( face.m_face_index != face_index )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
      text_log->PushIndent();
      text_log->Print("face.m_face_index = %d (should be %d).\n",
                       face.m_face_index, face_index );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  if ( face.m_brep != this )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
      text_log->PushIndent();
      text_log->Print("face.m_brep does not point to parent brep.\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  const int face_loop_count = face.m_li.Count();
  if ( face_loop_count <= 0 )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
      text_log->PushIndent();
      text_log->Print("face.m_li.Count() <= 0 (should be >= 1)\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  int i, fli, li;
  for ( fli = 0; fli < face_loop_count; fli++ ) 
  {
    li = face.m_li[fli];
    for ( i = 0; i < fli; i++ ) 
    {
      if ( face.m_li[i] == li )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
          text_log->PushIndent();
          text_log->Print("face.m_li[%d]=face.m_li[%d]=%d (a loop index should appear once in face.m_li[])\n",
                          fli,i,li);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
    }
    if ( !IsValidLoop( li, text_log ) )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
        text_log->PushIndent();
        text_log->Print("brep.m_L[face.m_li[%d]=%d] is not valid.\n",fli,li);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    const ON_BrepLoop& loop = m_L[li];
    if ( loop.m_loop_index != li )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
        text_log->PushIndent();
        text_log->Print("face.m_li[%d]=%d is a deleted loop\n",
                        fli,li);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    if ( loop.m_fi != face_index )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
        text_log->PushIndent();
        text_log->Print("face.m_li[%d]=%d but brep.m_L[%d].m_fi=%d (m_fi should be %d)\n",
                        fli,li,li,loop.m_fi,face_index);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    if ( fli == 0 ) 
    {
      if ( loop.m_type != ON_BrepLoop::outer )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
          text_log->PushIndent();
          text_log->Print("brep.m_L[face.m_li[0]=%d].m_type is not outer.\n",li);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
    }
    else
    {
      if (   loop.m_type != ON_BrepLoop::slit 
           && loop.m_type != ON_BrepLoop::inner 
         )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
          text_log->PushIndent();
          text_log->Print("brep.m_L[face.m_li[%d]=%d].m_type is not inner or slit.\n",fli,li);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
    }
  }

  const int si = face.m_si;
  if ( si < 0 || si >= m_S.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
      text_log->PushIndent();
      text_log->Print("face.m_si=%d (should be >=0 and <%d=m_S.Count())\n",
                      face.m_si,m_S.Count());                      
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  if ( !m_S[si] )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
      text_log->PushIndent();
      text_log->Print("brep.m_S[face.m_si=%d] is NULL\n",face.m_si);
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  if ( m_S[si] != face.ProxySurface() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
      text_log->PushIndent();
      text_log->Print("brep.m_S[face.m_si=%d] != face.ProxySurface().\n",si);
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  if ( face.ProxySurfaceIsTransposed() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_F[%d] face is not valid.\n",face_index);
      text_log->PushIndent();
      text_log->Print("face.ProxySurfaceIsTransposed() is true.\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  return true; 
}

bool
ON_Brep::IsValidEdge( int edge_index, ON_TextLog* text_log ) const
{
  if ( edge_index < 0 || edge_index >= m_E.Count() )
  {
    if ( text_log )
      text_log->Print("brep edge_index = %d (should be >=0 and <%d=brep.m_E.Count() ).\n",
                      edge_index, m_E.Count());
    return ON_BrepIsNotValid();
  }
  const ON_BrepEdge& edge = m_E[edge_index];
  if ( edge.m_brep != this )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
      text_log->PushIndent();
      text_log->Print("edge.m_brep does not point to parent brep\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  if ( edge.m_edge_index != edge_index )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
      text_log->PushIndent();
      text_log->Print("edge.m_edge_index = %d (should be %d).\n",
                       edge.m_edge_index, edge_index );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  if ( !edge.IsValid(text_log) )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
      text_log->PushIndent();
      text_log->Print("edge is not a valid.\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  const int ci = edge.m_c3i;
  if ( ci < 0 || ci >= m_C3.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
      text_log->PushIndent();
      text_log->Print("edge.m_c3i = %d (should be >=0 and <%d=m_C3.Count()\n",
                      edge.m_c3i,m_C3.Count() );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  
  if ( m_C3[ci] != edge.ProxyCurve() || 0 == m_C3[ci] )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
      text_log->PushIndent();
      text_log->Print("edge.m_curve != brep.m_C3[edge.m_c3i=%d]\n", edge.m_c3i );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  
  //if ( edge.ProxyCurveIsReversed() )
  //{
  //  if ( text_log )
  //  {
  //    text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
  //    text_log->PushIndent();
  //    text_log->Print("edge.ProxyCurveIsReversed() is true.\n" );
  //    text_log->PopIndent();
  //  }
  //  return ON_BrepIsNotValid();
  //}

  double t0, t1;
  if ( !edge.GetDomain( &t0, &t1 ) )
  {
    if ( text_log )
    {
      ON_Interval edom = edge.ProxyCurveDomain();
      text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
      text_log->PushIndent();
      text_log->Print( "edge.m_domain=(%g,%g) is not valid\n", edom[0], edom[1]);
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  const int vi0 = edge.m_vi[0];
  const int vi1 = edge.m_vi[1];
  if ( vi0 < 0 || vi0 >= m_V.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
      text_log->PushIndent();
      text_log->Print("edge.m_vi[0]=%d (should be >=0 and <%d=m_V.Count()\n",
                       vi0, m_V.Count() );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  if ( vi1 < 0 || vi1 >= m_V.Count() )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
      text_log->PushIndent();
      text_log->Print("edge.m_vi[1]=%d (should be >=0 and <%d=m_V.Count()\n",
                       vi1, m_V.Count() );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  int evi;
  for ( evi = 0; evi < 2; evi++ ) 
  {
    const ON_BrepVertex& vertex = m_V[edge.m_vi[evi]];

    if ( edge.m_vi[evi] != vertex.m_vertex_index )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
        text_log->PushIndent();
        text_log->Print("edge.m_vi[%d]=%d is a deleted vertex\n",
                         evi,edge.m_vi[evi] );
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }


    const int vertex_edge_count = vertex.m_ei.Count();
    ON_BOOL32 bFoundIt = false;
    int vei;
    for ( vei = 0; vei < vertex_edge_count && !bFoundIt; vei++ ) {
      bFoundIt = (vertex.m_ei[vei] == edge_index);
    }
    if ( !bFoundIt )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
        text_log->PushIndent();
        text_log->Print("edge.m_vi[%d]=%d but edge is not referenced in m_V[%d].m_ei[]\n",
                         evi,edge.m_vi[evi],edge.m_vi[evi] );
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
  }

  if ( edge.IsClosed() ) {
    if ( vi0 != vi1 )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
        text_log->PushIndent();
        text_log->Print("edge.m_vi[]=(%d,%d) but edge.IsClosed() is true\n",
                         vi0,vi1);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
  }
  else {
    if ( vi0 == vi1 )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
        text_log->PushIndent();
        text_log->Print("edge.m_vi[0]=edge.m_vi[1]=%d but edge.IsClosed() is false.\n",
                         vi0);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
  }

  const int edge_trim_count = edge.m_ti.Count();
  if ( edge_trim_count < 0 )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
      text_log->PushIndent();
      text_log->Print("edge.m_ti.Count() < 0\n");
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  int i, eti, ti;
  for (eti = 0; eti < edge_trim_count; eti++ )
  {
    ti = edge.m_ti[eti];
    if ( ti < 0 || ti >= m_T.Count() )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
        text_log->PushIndent();
        text_log->Print("edge.m_ti[%d]=%d (should be >=0 and <%d=m_T.Count())\n",eti,ti);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    if ( m_T[ti].m_trim_index != ti )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
        text_log->PushIndent();
        text_log->Print("edge.m_ti[%d]=%d is a deleted trim\n",eti,ti);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    for ( i = 0; i < eti; i++ ) 
    {
      if ( edge.m_ti[i] == ti )
      {
        if ( text_log )
        {
          text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
          text_log->PushIndent();
          text_log->Print("edge.m_ti[%d]=edge.m_ti[%d]=%d (a trim should be referenced once).\n",i,eti,ti);
          text_log->PopIndent();
        }
        return ON_BrepIsNotValid();
      }
    }
    const ON_BrepTrim& trim = m_T[ti];
    if ( trim.m_ei != edge_index )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
        text_log->PushIndent();
        text_log->Print("edge.m_ti[%d]=%d but brep.m_T[%d].m_ei=%d\n",eti,ti,ti,trim.m_ei);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
  }

  if ( edge.m_tolerance < 0.0 )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_E[%d] edge is not valid.\n",edge_index);
      text_log->PushIndent();
      text_log->Print("edge.m_tolerance=%g (should be >= 0.0)\n",edge.m_tolerance);
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  return true;
}

bool
ON_Brep::IsValidVertex( int vertex_index, ON_TextLog* text_log ) const
{
  if ( vertex_index < 0 || vertex_index >= m_V.Count() )
  {
    if ( text_log )
      text_log->Print("brep vertex_index = %d (should be >=0 and <%d=brep.m_V.Count() ).\n",
                      vertex_index, m_V.Count());
    return ON_BrepIsNotValid();
  }
  const ON_BrepVertex& vertex = m_V[vertex_index];
  if ( vertex.m_vertex_index != vertex_index )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_V[%d] vertex is not valid.\n",vertex_index);
      text_log->PushIndent();
      text_log->Print("vertex.m_vertex_index = %d (should be %d).\n",
                       vertex.m_vertex_index, vertex_index );
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }

  const int vertex_edge_count = vertex.m_ei.Count();
  int i, j, vei, ei;
  for ( vei = 0; vei < vertex_edge_count; vei++ ) {
    ei = vertex.m_ei[vei];
    if ( ei < 0 || ei >= m_E.Count() )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_V[%d] vertex is not valid.\n",vertex_index);
        text_log->PushIndent();
        text_log->Print("vertex.m_ei[%d] = %d (should be >=0 and <%d).\n", vei, ei, m_E.Count());
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    const ON_BrepEdge& edge = m_E[ei];
    if ( ei != edge.m_edge_index )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_V[%d] vertex is not valid.\n",vertex_index);
        text_log->PushIndent();
        text_log->Print("vertex.m_ei[%d] = %d is a deleted edge.\n", vei, ei);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
    for ( i = 0; i < vei; i++ ) 
    {
      if ( vertex.m_ei[i] == ei ) 
      {
        // edge should be closed
        if ( edge.m_vi[0] != vertex_index || edge.m_vi[1] != vertex_index )
        {
          if ( text_log )
          {
            text_log->Print("brep.m_V[%d] vertex is not valid.\n",vertex_index);
            text_log->PushIndent();
            text_log->Print("vertex.m_ei[%d] and vertex.m_ei[%d] = %d but brep.m_E[%d].m_vi[0] = %d",
                             i,vei,ei,ei,edge.m_vi[0]);
            text_log->Print("and ON_Brep.m_E[%d].m_vi[1] = %d (both m_vi[] values should be %d).\n",
                            ei,edge.m_vi[1],vertex_index);
            text_log->PopIndent();
          }
          return ON_BrepIsNotValid();
        }
        for (j = i+1; j < vei; j++ ) 
        {
          if ( vertex.m_ei[j] == ei )
          {
            if ( text_log )
            {
              text_log->Print("brep.m_V[%d] vertex is not valid.\n",vertex_index);
              text_log->PushIndent();
              text_log->Print("vertex.m_ei[%d,%d,%d] = %d. An open edge index should appear once\n",i,vei,j,ei);
              text_log->Print("in vertex.m_ei[] and a closed edge index should appear twice.\n");
              text_log->PopIndent();
            }
            return ON_BrepIsNotValid();
          }
        }
        break;
      }
    }
    if ( edge.m_vi[0] != vertex_index && edge.m_vi[1] != vertex_index )
    {
      if ( text_log )
      {
        text_log->Print("brep.m_V[%d] vertex is not valid.\n",vertex_index);
        text_log->PushIndent();
        text_log->Print("vertex.m_ei[%d] = %d but ON_Brep.m_E[%d].m_vi[] = [%d,%d]. "
                        "At least one edge m_vi[] value should be %d.\n",
                        vei,ei,ei,edge.m_vi[0],edge.m_vi[1],vertex_index);
        text_log->PopIndent();
      }
      return ON_BrepIsNotValid();
    }
  }

  if ( vertex.m_tolerance < 0.0 )
  {
    if ( text_log )
    {
      text_log->Print("brep.m_V[%d] vertex is not valid.\n",vertex_index);
      text_log->PushIndent();
      text_log->Print("vertex.m_tolerace = %g (should be >= 0.0)\n",vertex.m_tolerance);
      text_log->PopIndent();
    }
    return ON_BrepIsNotValid();
  }
  return true;
}



static
bool TestTrimPBox( const ON_BrepTrim& trim, ON_TextLog* text_log )
{
  ON_3dPoint pt;
  double d;
  ON_BoundingBox pbox = trim.m_pbox;

  
  d = ON_SQRT_EPSILON*(fabs(pbox.m_min.x)+fabs(pbox.m_max.x));
  if ( d < ON_ZERO_TOLERANCE )
    d = ON_ZERO_TOLERANCE;
  pbox.m_min.x -= d;
  pbox.m_max.x += d;

  d = ON_SQRT_EPSILON*(fabs(pbox.m_min.y)+fabs(pbox.m_max.y));
  if ( d < ON_ZERO_TOLERANCE )
    d = ON_ZERO_TOLERANCE;
  pbox.m_min.y -= d;
  pbox.m_max.y += d;

  pt = trim.PointAtStart();
  if ( !pbox.IsPointIn(pt) )
  {
    if ( text_log )
       text_log->Print("ON_Brep.m_T[%d].m_pbox does not contain start of trim.\n",trim.m_trim_index);
    return false;
  }

  pt = trim.PointAtEnd();

  if ( !pbox.IsPointIn(pt) )
  {
    if ( text_log )
       text_log->Print("ON_Brep.m_T[%d].m_pbox does not contain end of trim.\n",trim.m_trim_index);
    return false;
  }

  pt = trim.PointAt(trim.Domain().ParameterAt(0.5));
  if ( !pbox.IsPointIn(pt) )
  {
    if ( text_log )
       text_log->Print("ON_Brep.m_T[%d].m_pbox does not contain middle of trim.\n",trim.m_trim_index);
    return false;
  }

  return true;
}

static
bool CheckTrimOnSrfHelper( const ON_Interval& srf_domain0,
                           const ON_Interval& srf_domain1,
                           const ON_BrepTrim& trim,
                           ON_TextLog* text_log
                           )
{
  // this check only works if the pline exists.
  const ON_BrepTrimPoint* tp = trim.m_pline.Array();
  int i, count = trim.m_pline.Count();

  /*
  June 08 2012 - Chuck - Changing a and b to -ON_ZERO_TOLERANCE and 1+ON_ZERO_TOLERANCE. Done so RR 106304 is considered a bad object.  Split, Trim, etc expect uv curves to
  be on the surface.  If you get a Check error here and feel the need to change this, 
  discuss first with Chuck or Dale L and document with RR item numbers. 
  const double a = -0.01;
  const double b =  1.01;

  26 June 2012 Chuck and Dale Lear
    Concerning bugs 
      http://dev.mcneel.com/bugtrack/?q=106304
      http://dev.mcneel.com/bugtrack/?q=107842

    We are moving the relative fuzz back to 1%
    because making it smaller is generating
    more tech support than it is worth at this 
    point.

    We did learn that 2d trim curves leak off the
    surface domain a bit fairly often and that
    forcing the 2d pline to be in the surface domain
    but leaving the 2d trim curve as is does not
    fix the bugs cited above.
  */
  const double a = -0.01;
  const double b =  1.01;
  double s,t;
  for ( i = 0; i < count; i++ )
  {
    s = srf_domain0.NormalizedParameterAt(tp[i].p.x);
    t = srf_domain1.NormalizedParameterAt(tp[i].p.y);
    if ( s < a || s > b || t < a || t > b )
    {
      if ( text_log )
      {
        text_log->Print("ON_Brep.m_T[%d] 2d curve is not inside surface domain.\n",trim.m_trim_index);
      }
      return false;
    }
  }
  return true;
}

static
bool CheckLoopOnSrfHelper( const ON_Brep& brep, 
                           const ON_Interval& srf_domain0,
                           const ON_Interval& srf_domain1,
                           const ON_BrepLoop& loop,
                           ON_TextLog* text_log
                           )
{
  for ( int lti = 0; lti < loop.m_ti.Count(); lti++ )
  {
    int ti = loop.m_ti[lti];
    if ( ti < 0 || ti >= brep.m_T.Count() )
      continue;
    if ( ! CheckTrimOnSrfHelper( srf_domain0, srf_domain1, brep.m_T[ti], text_log ) )
      return false;
  }
  return true;
}

ON_BOOL32
ON_Brep::IsValid( ON_TextLog* text_log ) const
{
  const int curve2d_count = m_C2.Count();
  const int curve3d_count = m_C3.Count();
  const int surface_count = m_S.Count();
  const int vertex_count  = m_V.Count();
  const int edge_count    = m_E.Count();
  const int trim_count    = m_T.Count();
  const int loop_count    = m_L.Count();
  const int face_count    = m_F.Count();

  int c2i, c3i, si, vi, ei, fi, ti, li;

  if ( 0 == face_count && 0 == edge_count && 0 == vertex_count )
  {
    if ( text_log )
      text_log->Print( "ON_Brep has no faces, edges, or vertices\n");
    return ON_BrepIsNotValid();
  }

  if ( 0 != face_count )
  {
    if ( 0 == edge_count )
    {
      if ( text_log )
        text_log->Print( "ON_Brep has no edges.\n");
      return ON_BrepIsNotValid();
    }
    if ( 0 == loop_count )
    {
      if ( text_log )
        text_log->Print( "ON_Brep has no loops.\n");
      return ON_BrepIsNotValid();
    }
    if ( 0 == surface_count )
    {
      if ( text_log )
        text_log->Print( "ON_Brep has no surfaces.\n");
      return ON_BrepIsNotValid();
    }
    if ( 0 == trim_count )
    {
      if ( text_log )
        text_log->Print( "ON_Brep has no trims.\n");
      return ON_BrepIsNotValid();
    }
    if ( 0 == curve2d_count )
    {
      if ( text_log )
        text_log->Print( "ON_Brep has no 2d curves.\n");
      return ON_BrepIsNotValid();
    }
  }

  if ( 0 != edge_count )
  {
    if ( 0 == curve3d_count )
    {
      if ( text_log )
        text_log->Print( "ON_Brep has no 3d curves.\n");
      return ON_BrepIsNotValid();
    }
    if ( 0 == vertex_count )
    {
      if ( text_log )
        text_log->Print( "ON_Brep has no vertices.\n");
      return ON_BrepIsNotValid();
    }
  }

  // check element indices match array positions
  for ( vi = 0; vi < vertex_count; vi++ ) 
  {
    if ( m_V[vi].m_vertex_index == -1 )
    {
      const ON_BrepVertex& vertex = m_V[vi];
      if ( vertex.m_ei.Count() > 0 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_V[%d] is deleted (m_vertex_index = -1) but vertex.m_ei.Count() = %d.\n",
                           vi, vertex.m_ei.Count() );
        return ON_BrepIsNotValid();
      }
    }
    else if ( m_V[vi].m_vertex_index != vi )
    {
      if ( text_log )
        text_log->Print( "ON_Brep.m_V[%d].m_vertex_index = %d (should be %d)\n",
                         vi, m_V[vi].m_vertex_index, vi );
      return ON_BrepIsNotValid();
    }
  }

  for ( ei = 0; ei < edge_count; ei++ ) 
  {
    if ( m_E[ei].m_edge_index == -1 )
    {
      const ON_BrepEdge& edge = m_E[ei];
      if ( edge.m_ti.Count() > 0 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_E[%d] is deleted (m_edge_index = -1) but edge.m_ti.Count() = %d.\n",
                           ei, edge.m_ti.Count() );
        return ON_BrepIsNotValid();
      }
      if ( edge.m_c3i != -1 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_E[%d] is deleted (m_edge_index = -1) but edge.m_c3i=%d (should be -1).\n",
                           ei, edge.m_c3i );
        return ON_BrepIsNotValid();
      }
      if ( edge.ProxyCurve() )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_E[%d] is deleted (m_edge_index = -1) but edge.m_curve is not NULL.\n",
                           ei );
        return ON_BrepIsNotValid();
      }
      if ( edge.m_vi[0] != -1 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_E[%d] is deleted (m_edge_index = -1) but edge.m_vi[0]=%d (should be -1).\n",
                           ei, edge.m_vi[0] );
        return ON_BrepIsNotValid();
      }
      if ( edge.m_vi[1] != -1 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_E[%d] is deleted (m_edge_index = -1) but edge.m_vi[1]=%d (should be -1).\n",
                           ei, edge.m_vi[1] );
        return ON_BrepIsNotValid();
      }
    }
    else if ( m_E[ei].m_edge_index != ei )
    {
      if ( text_log )
        text_log->Print( "ON_Brep.m_E[%d].m_edge_index = %d (should be %d)\n",
                         ei, m_E[ei].m_edge_index, ei );
      return ON_BrepIsNotValid();
    }
  }

  for ( ti = 0; ti < trim_count; ti++ ) 
  {
    if ( m_T[ti].m_trim_index == -1 )
    {
      const ON_BrepTrim& trim = m_T[ti];
      if ( trim.m_ei != -1 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_T[%d] is deleted (m_trim_index = -1) but trim.m_ei=%d (should be -1).\n",
                           ti, trim.m_ei );
        return ON_BrepIsNotValid();
      }
      if ( trim.m_li != -1 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_T[%d] is deleted (m_trim_index = -1) but trim.m_li=%d (should be -1).\n",
                           ti, trim.m_li );
        return ON_BrepIsNotValid();
      }
      if ( trim.m_c2i != -1 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_T[%d] is deleted (m_trim_index = -1) but trim.m_c2i=%d (should be -1).\n",
                           ti, trim.m_c2i );
        return ON_BrepIsNotValid();
      }
      if ( trim.m_vi[0] != -1 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_T[%d] is deleted (m_trim_index = -1) but trim.m_vi[0]=%d (should be -1).\n",
                           ti, trim.m_vi[0] );
        return ON_BrepIsNotValid();
      }
      if ( trim.m_vi[1] != -1 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_T[%d] is deleted (m_trim_index = -1) but trim.m_vi[1]=%d (should be -1).\n",
                           ti, trim.m_vi[1] );
        return ON_BrepIsNotValid();
      }
    }
    else if ( m_T[ti].m_trim_index != ti  )
    {
      if ( text_log )
        text_log->Print( "ON_Brep.m_T[%d].m_trim_index = %d (should be %d)\n",
                         ti, m_T[ti].m_trim_index, ti );
      return ON_BrepIsNotValid();
    }
    else if ( !m_T[ti].IsValid( text_log ) )
    {
      if ( text_log )
        text_log->Print( "ON_Brep.m_T[%d] is not valid\n",ti );
      return ON_BrepIsNotValid();
    }
  }

  for ( li = 0; li < loop_count; li++ ) 
  {
    if ( m_L[li].m_loop_index == -1 )
    {
      const ON_BrepLoop& loop = m_L[li];
      if ( loop.m_fi != -1 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_L[%d] is deleted (m_loop_index = -1) but loop.m_fi=%d (should be -1).\n",
                           li, loop.m_fi );
        return ON_BrepIsNotValid();
      }
      if ( loop.m_ti.Count() > 0 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_L[%d] is deleted (m_loop_index = -1) but loop.m_ti.Count()=%d.\n",
                           li, loop.m_ti.Count() );
        return ON_BrepIsNotValid();
      }
    }
    else if ( m_L[li].m_loop_index != li )
    {
      if ( text_log )
        text_log->Print( "ON_Brep.m_L[%d].m_loop_index = %d (should be %d)\n",
                         li, m_L[li].m_loop_index, li );
      return ON_BrepIsNotValid();
    }
  }

  for ( fi = 0; fi < face_count; fi++ ) 
  {
    if ( m_F[fi].m_face_index == -1 )
    {
      const ON_BrepFace& face = m_F[fi];
      if ( face.m_si != -1 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_F[%d] is deleted (m_face_index = -1) but face.m_si=%d (should be -1).\n",
                           fi, face.m_si );
        return ON_BrepIsNotValid();
      }
      if ( face.ProxySurface() )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_F[%d] is deleted (m_face_index = -1) but face.ProxySurface() is not NULL.\n",
                           fi );
        return ON_BrepIsNotValid();
      }
      if ( face.m_li.Count() > 0 )
      {
        if ( text_log )
          text_log->Print( "ON_Brep.m_F[%d] is deleted (m_face_index = -1) but face.m_li.Count()=%d.\n",
                           fi, face.m_li.Count() );
        return ON_BrepIsNotValid();
      }
    }
    else if ( m_F[fi].m_face_index != fi )
    {
      if ( text_log )
        text_log->Print( "ON_Brep.m_F[%d].m_face_index = %d (should be %d)\n",
                         fi, m_F[fi].m_face_index, fi );
      return ON_BrepIsNotValid();
    }
  }

  // check 2d curve geometry
  for ( c2i = 0; c2i < curve2d_count; c2i++ ) {
    if ( !m_C2[c2i] )
    {
      continue;
      // NULL 2d curves are ok if they are not referenced
      //if ( text_log )
      //  text_log->Print("ON_Brep.m_C2[%d] is NULL.\n",c2i);
      //return ON_BrepIsNotValid();
    }
    if ( !m_C2[c2i]->IsValid(text_log) )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_C2[%d] is invalid.\n",c2i);
      return ON_BrepIsNotValid();
    }
    int c2_dim = m_C2[c2i]->Dimension();
    if ( c2_dim != 2 )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_C2[%d]->Dimension() = %d (should be 2).\n", c2i, c2_dim );
      return ON_BrepIsNotValid();
    }
    const ON_PolyCurve* polycurve = ON_PolyCurve::Cast(m_C2[c2i]);
    if ( polycurve && polycurve->IsNested() )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_C2[%d] is a nested polycurve.\n", c2i );
      return ON_BrepIsNotValid();
    }
  }

  // check 3d curve geometry
  for ( c3i = 0; c3i < curve3d_count; c3i++ ) {
    if ( !m_C3[c3i] )
    {
      continue;
      // NULL 3d curves are ok if they are not referenced
      //if ( text_log )
      //  text_log->Print("ON_Brep.m_C3[%d] is NULL.\n",c3i);
      //return ON_BrepIsNotValid();
    }
    if ( !m_C3[c3i]->IsValid(text_log) )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_C3[%d] is invalid.\n",c3i);
      return ON_BrepIsNotValid();
    }
    int c3_dim = m_C3[c3i]->Dimension();
    if ( c3_dim != 3 )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_C3[%d]->Dimension() = %d (should be 3).\n", c3i, c3_dim );
      return ON_BrepIsNotValid();
    }
    const ON_PolyCurve* polycurve = ON_PolyCurve::Cast(m_C3[c3i]);
    if ( polycurve && polycurve->IsNested() )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_C3[%d] is a nested polycurve.\n", c3i );
      return ON_BrepIsNotValid();
    }
  }

  // check 3d surface geometry
  for ( si = 0; si < surface_count; si++ ) {
    if ( !m_S[si] )
    {
      continue;
      // NULL 3d surfaces are ok if they are not referenced
      //if ( text_log )
      //  text_log->Print("ON_Brep.m_S[%d] is NULL.\n",si);
      //return ON_BrepIsNotValid();
    }
    if ( !m_S[si]->IsValid(text_log) )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_S[%d] is invalid.\n",si);
      return ON_BrepIsNotValid();
    }
    int dim = m_S[si]->Dimension();
    if ( dim != 3 )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_S[%d]->Dimension() = %d (should be 3).\n", si, dim );
      return ON_BrepIsNotValid();
    }
  }

  // check vertices
  for ( vi = 0; vi < vertex_count; vi++ ) {
    if ( m_V[vi].m_vertex_index == -1 )
      continue;
    if ( !IsValidVertex( vi, text_log ) ) {
      if ( text_log )
        text_log->Print("ON_Brep.m_V[%d] is invalid.\n",vi);
      return ON_BrepIsNotValid();
    }
  }

  // check edges
  for ( ei = 0; ei < edge_count; ei++ ) 
  {
    if ( m_E[ei].m_edge_index == -1 )
      continue;
    if ( !IsValidEdge( ei, text_log ) ) {
      if ( text_log )
        text_log->Print("ON_Brep.m_E[%d] is invalid.\n",ei);
      return ON_BrepIsNotValid();
    }
  }

  // check faces
  for ( fi = 0; fi < face_count; fi++ ) 
  {
    if ( m_F[fi].m_face_index == -1 )
      continue;
    if ( !IsValidFace( fi, text_log ) ) {
      if ( text_log )
        text_log->Print("ON_Brep.m_F[%d] is invalid.\n",fi);
      return ON_BrepIsNotValid();
    }
  }

  // Check loops - this check is necessary at the brep level
  // to make sure there are no orphaned loops.
  // ON_Brep::IsValidLoop(), which is called by ON_Brep::IsValidFace(),
  // performs loop-trim bookkeeping checks on all loops that are referenced
  // by a face.
  for ( li = 0; li < loop_count; li++ )
  {
    const ON_BrepLoop& loop = m_L[li];
    if ( m_L[li].m_loop_index == -1 )
      continue;
    if ( loop.m_fi < 0 || loop.m_fi >= m_F.Count() )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_L[%d].m_fi = %d is not invalid.\n",li,loop.m_fi);
      return ON_BrepIsNotValid();
    }
    if ( m_F[loop.m_fi].m_face_index != loop.m_fi )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_L[%d].m_fi = %d is a deleted face.\n",li,loop.m_fi);
      return ON_BrepIsNotValid();
    }

    // This for() loop check is performed in IsValidLoop() which is 
    // called by IsValidFace() in the "check faces" loop above.  
    // I think it can be removed.  If anybody every sees this code
    // find a flaw, please tell Dale Lear.
    for ( int lti = 0; lti < loop.m_ti.Count(); lti++ )
    {
      ti = loop.m_ti[lti];
      if ( ti < 0 || ti >= m_T.Count() )
      {
        if ( text_log )
          text_log->Print("ON_Brep.m_L[%d].m_ti[%d] = %d is not invalid.\n",li,lti,ti);
        return ON_BrepIsNotValid();
      }
      if ( m_T[ti].m_trim_index != ti )
      {
        if ( text_log )
          text_log->Print("ON_Brep.m_L[%d].m_ti[%d] = %d is a deleted trim.\n",li,lti,ti);
        return ON_BrepIsNotValid();
      }
    }
  }

  // check trims - this check is necessary at the brep 
  // level to make sure there are no orphan trims and 
  // to test tolerances.  Most of these tests are duplicates 
  // of ones in ON_Brep::IsValidTrim, which is called by 
  // ON_Brep::IsValidLoop, which is called by ON_Brep::IsValidFace.
  int seam_trim_count = 0;
  for ( ti = 0; ti < trim_count; ti++ )
  {
    const ON_BrepTrim& trim = m_T[ti];
    if ( trim.m_trim_index == -1 )
      continue;

    if ( trim.m_vi[0] < 0 || trim.m_vi[0] >= m_V.Count() )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_vi[0] = %d is not invalid.\n",ti,trim.m_vi[0]);
      return ON_BrepIsNotValid();
    }
    if ( trim.m_vi[1] < 0 || trim.m_vi[1] >= m_V.Count() )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_vi[1] = %d is not invalid.\n",ti,trim.m_vi[1]);
      return ON_BrepIsNotValid();
    }

    if ( m_V[trim.m_vi[0]].m_vertex_index != trim.m_vi[0] )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_vi[0] is deleted.\n",ti);
      return ON_BrepIsNotValid();
    }
    if ( m_V[trim.m_vi[1]].m_vertex_index != trim.m_vi[1] )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_vi[1] is deleted.\n",ti);
      return ON_BrepIsNotValid();
    }

    if ( trim.m_c2i < 0 || trim.m_c2i >= m_C2.Count() )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_c2i = %d is not valid.\n",ti,trim.m_c2i);
      return ON_BrepIsNotValid();
    }

    if ( 0 == m_C2[trim.m_c2i] )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_c2i = %d, but m_C2[%d] is NULL.\n",ti,trim.m_c2i,trim.m_c2i);
      return ON_BrepIsNotValid();
    }

    if ( trim.m_li < 0 || trim.m_li >= m_L.Count() )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_li = %d is not valid.\n",ti,trim.m_li);
      return ON_BrepIsNotValid();
    }

    if ( m_L[trim.m_li].m_loop_index != trim.m_li )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_li = %d is a deleted loop.\n",ti,trim.m_li);
      return ON_BrepIsNotValid();
    }

    {
      const ON_Curve* c2 = m_C2[trim.m_c2i];
      const ON_Surface* srf = m_S[m_F[m_L[trim.m_li].m_fi].m_si];
      if ( srf )
      {
        ON_Interval PD = trim.ProxyCurveDomain();
        ON_Surface::ISO iso = srf->IsIsoparametric(*c2, &PD);
        if ( trim.m_iso != iso )
        {
          if ( text_log )
            text_log->Print("ON_Brep.m_T[%d].m_iso = %d and it should be %d\n",ti,trim.m_iso,iso);
          return ON_BrepIsNotValid();
        }
      }
    }

    if ( trim.m_type == ON_BrepTrim::singular )
    {
      if ( trim.m_ei != -1 )
      {
        if ( text_log )
          text_log->Print("ON_Brep.m_T[%d].m_type = singular, but m_ei = %d (should be -1).\n",ti,trim.m_ei);
        return ON_BrepIsNotValid();
      }
      continue;
    }

    if ( trim.m_ei < 0 || trim.m_ei >= m_E.Count() )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_ei = %d is not invalid.\n",ti,trim.m_ei);
      return ON_BrepIsNotValid();
    }
    
    const ON_BrepEdge& edge = m_E[trim.m_ei];
    if ( edge.m_edge_index != trim.m_ei )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_ei is deleted.\n",ti);
      return ON_BrepIsNotValid();
    }

    const int evi0 = trim.m_bRev3d ? 1 : 0;
    const int evi1 = trim.m_bRev3d ? 0 : 1;
    if ( trim.m_vi[0] != edge.m_vi[evi0] )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_bRev3d = %d, but m_vi[0] != m_E[m_ei].m_vi[%d].\n",ti,trim.m_bRev3d,evi0);
      return ON_BrepIsNotValid();
    }
    if ( trim.m_vi[1] != edge.m_vi[evi1] )
    {
      if ( text_log )
        text_log->Print("ON_Brep.m_T[%d].m_bRev3d = %d, but m_vi[0] != m_E[m_ei].m_vi[%d].\n",ti,trim.m_bRev3d,evi1);
      return ON_BrepIsNotValid();
    }

    // check tolerances and closed curve directions
    {
      ON_3dPoint trim_pt0, trim_pt1, srf_pt0, srf_pt1;
      ON_3dVector trim_der0, trim_der1, srf_du0, srf_dv0, srf_du1, srf_dv1;
      ON_Interval trim_domain = trim.Domain();
      // trim_pt0 should be closed to trim_pt1 except when
      // trim starts and ends on opposite sides of a surface 
      // seam.  Even when the trim curve is closed, the 
      // derivatives can be different when there is
      // a kink at the start/end of a trim.
      trim.Ev1Der( trim_domain[0], trim_pt0, trim_der0 );
      trim.Ev1Der( trim_domain[1], trim_pt1, trim_der1 );

      const ON_Surface* trim_srf = m_F[ m_L[trim.m_li].m_fi ].SurfaceOf();
      trim_srf->Ev1Der( trim_pt0.x, trim_pt0.y, srf_pt0, srf_du0, srf_dv0 );
      trim_srf->Ev1Der( trim_pt1.x, trim_pt1.y, srf_pt1, srf_du1, srf_dv1 );

      // estimate 3d tolerances from 2d trim tolerances
      double t0_tol = srf_du0.Length()*trim.m_tolerance[0] + srf_dv0.Length()*trim.m_tolerance[1];
      double t1_tol = srf_du1.Length()*trim.m_tolerance[0] + srf_dv1.Length()*trim.m_tolerance[1];
      ON_3dVector trim_tangent0 = trim_der0.x*srf_du0 + trim_der0.y*srf_dv0;
      trim_tangent0.Unitize();
      ON_3dVector trim_tangent1 = trim_der1.x*srf_du1 + trim_der1.y*srf_dv1;
      trim_tangent1.Unitize();
      ON_3dVector edge_tangent0 = edge.TangentAt( edge.Domain()[trim.m_bRev3d ? 1 : 0] );
      ON_3dVector edge_tangent1 = edge.TangentAt( edge.Domain()[trim.m_bRev3d ? 0 : 1] );
      double d0 = trim_tangent0*edge_tangent0;
      double d1 = trim_tangent1*edge_tangent1;
      if ( trim.m_bRev3d )
      {
        d0 = -d0;
        d1 = -d1;
      }
      if (    trim.m_vi[0] == trim.m_vi[1] 
           && edge.m_vi[0] == edge.m_vi[1] 
           && trim.m_vi[0] == edge.m_vi[0] 
           )
      {
        // For high quality models, d0 and d1 should be close to +1.
        // If both are close to -1, the trim.m_bRev3d flag is most
        // likely set opposite of what it should be.

        // check start tangent to see if m_bRev3d is set correctly
        if ( d0 < 0.0 || d1 < 0.0)
        {
          if ( text_log )
          {
            if ( trim.m_bRev3d )
              text_log->Print("ON_Brep.m_T[%d].m_bRev3d = true, but closed curve directions are the same.\n",ti);
            else
              text_log->Print("ON_Brep.m_T[%d].m_bRev3d = false, but closed curve directions are opposite.\n",ti);
          }
          return ON_BrepIsNotValid();
        }
      }

      // Make sure edge and tolerances are realistic
      ON_3dPoint EdgeEnd[2];
      EdgeEnd[trim.m_bRev3d?1:0] = edge.PointAtStart();
      EdgeEnd[trim.m_bRev3d?0:1] = edge.PointAtEnd();
      d0 = EdgeEnd[0].DistanceTo(srf_pt0);
      d1 = EdgeEnd[1].DistanceTo(srf_pt1);
      double etol = edge.m_tolerance;
      double dtol = 10.0*(etol + t0_tol + t1_tol);
      if ( dtol < 0.01 )
        dtol = 0.01;
      if ( d0 > dtol  )
      {
        if ( text_log )
        {
          text_log->Print("Distance from start of ON_Brep.m_T[%d] to 3d edge is %g.  (edge tol = %g, trim tol ~ %g).\n",
                          ti, d0, etol,t0_tol);
        }
        return ON_BrepIsNotValid();
      }
      if ( d1 > dtol )
      {
        if ( text_log )
        {
          text_log->Print("Distance from end of ON_Brep.m_T[%d] to 3d edge is %g.  (edge tol = %g, trim tol ~ %g).\n",
                          ti, d1, etol,t1_tol);
        }
        return ON_BrepIsNotValid();
      }
    }

    // check trim's m_pbox
    {
      if ( trim.m_pbox.m_min.z != 0.0 )
      {
        if ( text_log )
           text_log->Print("ON_Brep.m_T[%d].m_pbox.m_min.z = %g (should be zero).\n",ti,trim.m_pbox.m_min.z);
        return ON_BrepIsNotValid();
      }
      if ( trim.m_pbox.m_max.z != 0.0 )
      {
        if ( text_log )
           text_log->Print("ON_Brep.m_T[%d].m_pbox.m_max.z = %g (should be zero).\n",ti,trim.m_pbox.m_max.z);
        return ON_BrepIsNotValid();
      }
      
      if ( !TestTrimPBox( trim, text_log ) )
        return ON_BrepIsNotValid();

    }

    if ( ON_BrepTrim::seam == trim.m_type )
    {
      // trim must be on a surface edge
      switch ( trim.m_iso )
      {
      case ON_Surface::S_iso:
        break;
      case ON_Surface::E_iso:
        break;
      case ON_Surface::N_iso:
        break;
      case ON_Surface::W_iso:
        break;
      default:
        if ( text_log )
          text_log->Print("ON_Brep.m_T[%d].m_type = ON_BrepTrim::seam but m_iso is not N/E/W/S_iso.\n",ti);
        return ON_BrepIsNotValid();
      }
      seam_trim_count++;
    }
  }

  // check loop m_pboxes
  for ( li = 0; li < loop_count; li++ )
  {
    const ON_BrepLoop& loop = m_L[li];
    if ( loop.m_loop_index != li )
      continue;
    if ( loop.m_pbox.m_min.z != 0.0 )
    {
      if ( text_log )
         text_log->Print("ON_Brep.m_L[%d].m_pbox.m_min.z = %g (should be zero).\n",li,loop.m_pbox.m_min.z);
      return ON_BrepIsNotValid();
    }
    if ( loop.m_pbox.m_max.z != 0.0 )
    {
      if ( text_log )
         text_log->Print("ON_Brep.m_L[%d].m_pbox.m_max.z = %g (should be zero).\n",li,loop.m_pbox.m_max.z);
      return ON_BrepIsNotValid();
    }
    int first_trim_ti = -4;
    int first_trim_vi0 = -3;
    int prev_trim_vi1 = -2;
    int prev_trim_ti=-9;
    int lti;
    for ( lti = 0; lti < loop.m_ti.Count(); lti++ )
    {
      const ON_BrepTrim& trim = m_T[loop.m_ti[lti]];
      if ( !loop.m_pbox.IsPointIn(trim.m_pbox.m_min) || !loop.m_pbox.IsPointIn(trim.m_pbox.m_max) )
      {
        if ( text_log )
           text_log->Print("ON_Brep.m_L[%d].m_pbox does not contain m_T[loop.m_ti[%d]].m_pbox.\n",li,lti);
        return ON_BrepIsNotValid();
      }
      if ( 0 == lti )
      {
        first_trim_ti = loop.m_ti[lti];
        first_trim_vi0 = trim.m_vi[0];
      }
      else if ( prev_trim_vi1 != trim.m_vi[0] )
      {
        // 23 May 2003 Dale Lear
        //     Added this test to make sure adjacent trims
        //     in a loop shared vertices.
        if ( text_log )
           text_log->Print("ON_Brep.m_L[%d] loop has trim vertex mismatch:\n  m_T[loop.m_ti[%d]=%d].m_vi[1] = %d != m_T[loop.m_ti[%d]=%d].m_vi[0]=%d.\n",li,lti-1,prev_trim_ti,prev_trim_vi1,lti,loop.m_ti[lti],trim.m_vi[0]);
        return ON_BrepIsNotValid();
      }
      prev_trim_ti = loop.m_ti[lti];
      prev_trim_vi1 = trim.m_vi[1];
    }

    if ( first_trim_ti >= 0 && first_trim_vi0 != prev_trim_vi1 )
    {
      // 23 May 2003 Dale Lear
      //     Added this test to make sure adjacent trims
      //     in a loop shared vertices.
      if ( text_log )
         text_log->Print("ON_Brep.m_L[%d] loop has trim vertex mismatch:\n  m_T[loop.m_ti[%d]=%d].m_vi[1] = %d != m_T[loop.m_ti[%d]=%d].m_vi[0]=%d.\n",
                         li,lti-1,prev_trim_ti,prev_trim_vi1,0,first_trim_ti,first_trim_vi0);
      return ON_BrepIsNotValid();
    }
  }

  // 21 October 2003 Dale Lear - fix RR 11980 - check for split seams
  // This block of code assumes the preceding checks have all passed.
  // It looks for boundary trims on seams that should be joined as a seam trim.
  ON_Interval srf_domain[2];
  for ( fi = 0; fi < face_count; fi++ )
  {
    const ON_BrepFace& face = m_F[fi];
    if ( face.m_face_index < 0 )
      continue;
    const ON_Surface* srf = m_S[face.m_si];
    if ( 0 == srf )
      continue;

    srf_domain[0] = srf->Domain(0);
    srf_domain[1] = srf->Domain(1);
    for ( int fli = 0; fli < face.m_li.Count(); fli++ )
    {
      int li = face.m_li[fli];
      if ( li < 0 || li >= m_L.Count() )
        continue;
      if ( !CheckLoopOnSrfHelper(*this,srf_domain[0],srf_domain[1],m_L[li],text_log) )
        return ON_BrepIsNotValid();
    }

    const ON_BrepLoop* outer_loop = face.OuterLoop();
    if ( 0 == outer_loop )
      continue;

    ON_BOOL32 bClosed[2];
    bClosed[0] = srf->IsClosed(0);
    bClosed[1] = srf->IsClosed(1);
    if ( !bClosed[0] && !bClosed[1] )
      continue;

    const int outer_trim_count = outer_loop->m_ti.Count();
    int lti, lti1;
    int endpt_index = 0;
    ON_Surface::ISO iso_type;
    ON_Interval side_interval;
    double s0, s1;
    const double side_tol = 1.0e-4;

    for ( lti = 0; lti < outer_trim_count; lti++ )
    {
      const ON_BrepTrim& trim = m_T[outer_loop->m_ti[lti]];
      if ( ON_BrepTrim::boundary !=  trim.m_type )
        continue;
      if ( ON_Surface::E_iso == trim.m_iso && bClosed[0] )
      {
        iso_type = ON_Surface::W_iso;
        endpt_index = 1;
      }
      else if ( ON_Surface::W_iso == trim.m_iso && bClosed[0] )
      {
        iso_type = ON_Surface::E_iso;
        endpt_index = 1;
      }
      else if( ON_Surface::S_iso == trim.m_iso && bClosed[1] )
      {
        iso_type = ON_Surface::N_iso;
        endpt_index = 0;
      }
      else if( ON_Surface::N_iso == trim.m_iso && bClosed[1] )
      {
        iso_type = ON_Surface::S_iso;
        endpt_index = 0;
      }
      else
        continue;

      side_interval.Set(trim.PointAtStart()[endpt_index],trim.PointAtEnd()[endpt_index]);
      if ( ON_Surface::N_iso == iso_type || ON_Surface::W_iso == iso_type )
      {
        if ( !side_interval.IsIncreasing() )
          continue;
      }
      else
      {
        if ( !side_interval.IsDecreasing() )
          continue;
      }

      // search for seam
      for ( lti1 = 0; lti1 < outer_trim_count; lti1++ )
      {
        if ( lti1 == lti )
          continue;
        const ON_BrepTrim& trim1 = m_T[outer_loop->m_ti[lti1]];
        if ( iso_type != trim1.m_iso )
          continue;
        if ( ON_BrepTrim::boundary != trim1.m_type )
          continue;
        
        s1 = side_interval.NormalizedParameterAt(trim1.PointAtStart()[endpt_index]);
        if ( fabs(s1-1.0) > side_tol )
          continue;
        s0 = side_interval.NormalizedParameterAt(trim1.PointAtEnd()[endpt_index]);
        if ( fabs(s0) > side_tol )
          continue;

        if ( text_log )
        {
         text_log->Print("ON_Brep.m_F[%d] is on a closed surface. Outer loop m_L[%d] contains boundary trims %d and %d.  They should be seam trims connected to the same edge.\n",
                         face.m_face_index,outer_loop->m_loop_index,
                         trim.m_trim_index,trim1.m_trim_index
                         );
        }
        return ON_BrepIsNotValid();                
      }
    }
  }

  // make sure seam trims are properly matched.
  for ( ti = 0; seam_trim_count > 0 && ti < trim_count; ti++ )
  {
    const ON_BrepTrim& trim = m_T[ti];
    if ( trim.m_trim_index == -1 )
      continue;
    if ( ON_BrepTrim::seam != trim.m_type )
      continue;
    seam_trim_count--;
    if ( trim.m_ei < 0 || trim.m_ei >= edge_count )
    {
      if ( text_log )
      {
        text_log->Print("ON_Brep.m_T[%d] is a seam trim with an invalid m_ei.\n",ti);
        return ON_BrepIsNotValid();
      }
    }

    const ON_BrepEdge& edge = m_E[trim.m_ei];
    int trim1_index = -1;
    for ( int eti = 0; eti < edge.m_ti.Count(); eti++ )
    {
      const int ti1 = edge.m_ti[eti];
      if ( ti1 == ti 
           || ti < 0
           || ti >= trim_count 
         )
      {
        continue;
      }
      const ON_BrepTrim& trim1 = m_T[ti1];
      if ( trim1.m_trim_index == -1 )
        continue;
      if ( ON_BrepTrim::seam != trim1.m_type )
        continue;
      if ( trim1.m_li != trim.m_li )
        continue;
      if ( -1 == trim1_index )
      {
        trim1_index = ti1;
        continue;
      }
      text_log->Print("ON_Brep.m_T[%d,%d,%d] are three seam trims with the same edge in the same loop.\n",ti,trim1_index,ti1);
      return ON_BrepIsNotValid();
    }

    if ( trim1_index < 0 || trim1_index >= trim_count )
    {
      text_log->Print("ON_Brep.m_T[%d] is a seam trim with no matching seam trim in the same loop.\n",ti);
      return ON_BrepIsNotValid();
    }

    // previous validation step insures trim.m_iso = N/S/E/W_iso
    switch(trim.m_iso)
    {
    case ON_Surface::S_iso:
      if ( ON_Surface::N_iso != m_T[trim1_index].m_iso )
      {
        if (text_log )
          text_log->Print("Seam trim ON_Brep.m_T[%d].m_iso = S_iso but matching seam ON_Brep.m_T[%d].m_iso != N_iso.\n",ti,trim1_index);
        return ON_BrepIsNotValid();
      }
      break;

    case ON_Surface::E_iso:
      if ( ON_Surface::W_iso != m_T[trim1_index].m_iso )
      {
        if (text_log )
          text_log->Print("Seam trim ON_Brep.m_T[%d].m_iso = E_iso but matching seam ON_Brep.m_T[%d].m_iso != W_iso.\n",ti,trim1_index);
        return ON_BrepIsNotValid();
      }
      break;

    case ON_Surface::N_iso:
      if ( ON_Surface::S_iso != m_T[trim1_index].m_iso )
      {
        if (text_log )
          text_log->Print("Seam trim ON_Brep.m_T[%d].m_iso = N_iso but matching seam ON_Brep.m_T[%d].m_iso != S_iso.\n",ti,trim1_index);
        return ON_BrepIsNotValid();
      }
      break;

    case ON_Surface::W_iso:
      if ( ON_Surface::E_iso != m_T[trim1_index].m_iso )
      {
        if (text_log )
          text_log->Print("Seam trim ON_Brep.m_T[%d].m_iso = W_iso but matching seam ON_Brep.m_T[%d].m_iso != E_iso.\n",ti,trim1_index);
        return ON_BrepIsNotValid();
      }
      break;

    case ON_Surface::not_iso:
    case ON_Surface::x_iso:
    case ON_Surface::y_iso:
    case ON_Surface::iso_count:
      break; // keep gcc quiet
    }

  }

#if 0
  // validate ON_BrepTrim.m_pline
  for ( ti = 0; ti < trim_count; ti++ )
  {
    const ON_BrepTrim& trim = m_T[ti];
    if ( trim.m_trim_index == -1 )
      continue;
    const int pline_count = trim.m_pline.Count();
    if ( 0 == pline_count )
      continue;
    if ( pline_count <= 1 )
    {
      if (text_log )
        text_log->Print("ON_Brep.m_T[%d].m_pline.Count() = 1. It should be 0 or >= 2\n",ti);
      return ON_BrepIsNotValid();
    }

    const ON_Interval trim_domain = trim.Domain();
    if ( !(trim.m_pline[0].t == trim_domain[0]) )
    {
      if (text_log )
        text_log->Print("ON_Brep.m_T[%d].m_pline[0].t != start of trim domain.\n",ti);
      return ON_BrepIsNotValid();
    }
    if ( !(trim.m_pline[pline_count-1].t == trim_domain[1]) )
    {
      if (text_log )
        text_log->Print("ON_Brep.m_T[%d].m_pline[%d].t != end of trim domain.\n",ti,pline_count-1);
      return ON_BrepIsNotValid();
    }
    for ( int i = 1; i < pline_count; i++ )
    {
      // pline trim "t" values must be valid
      if ( !ON_IsValid(trim.m_pline[i].t) )
      {
        if (text_log )
          text_log->Print("ON_Brep.m_T[%d].m_pline[%d].t is not a valid double.\n",ti,i);
        return ON_BrepIsNotValid();
      }
      if ( !(trim.m_pline[i-1].t < trim.m_pline[i].t) )
      {
        if (text_log )
          text_log->Print("ON_Brep.m_T[%d].m_pline[%d].t must be < m_pline[%d].t.\n",ti,i-1,i);
        return ON_BrepIsNotValid();
      }
    }

    if (    ON_UNSET_VALUE == trim.m_pline[0].e 
         && ON_UNSET_VALUE == trim.m_pline[pline_count-1].e 
       )
    {
      // the "e" values are not set.
      // This is permitted. The are set when extensive
      // trim-edge parameter correspondence is needed.
      // Meshing is an example of a calculation that sets
      // the "e" paramters.
      continue;
    }

    if ( trim.m_ei < 0 || trim.m_ei >= m_E.Count() )
    {
      if (text_log )
        text_log->Print("ON_Brep.m_T[%d].m_pline has e parameters but trim.m_ei is not valid.\n",ti);
      return ON_BrepIsNotValid();
    }
    const ON_BrepEdge& edge = m_E[trim.m_ei];
    const ON_Interval edge_domain = edge.Domain();
    const int i0 = trim.m_bRev3d ? pline_count-1 : 0;
    const int i1 = trim.m_bRev3d ? 0 : pline_count-1;
    const int di = trim.m_bRev3d ? -1 : 1;
    if ( !(trim.m_pline[i0].e == edge_domain[0]) )
    {
      if (text_log )
        text_log->Print("ON_Brep.m_T[%d].m_pline[%d].e != start of edge domain.\n",ti,i0);
      return ON_BrepIsNotValid();
    }
    if ( !(trim.m_pline[i1].e == edge_domain[1]) )
    {
      if (text_log )
        text_log->Print("ON_Brep.m_T[%d].m_pline[%d].e != end of edge domain.\n",ti,i1);
      return ON_BrepIsNotValid();
    }
    int prev_valid_i = i0;
    for ( int i = i0+di; i >= 0 && i < pline_count && i-di >= 0 && i-di < pline_count; i += di )
    {
      if ( !ON_IsValid(trim.m_pline[i].e) )
      {
        // internal "e" may be invalid when the setter
        // had troubles.  This is a symptom of a 
        // bad trim or edge curve, but is not conclusive
        // proof.
        continue;
      }
      if ( !(trim.m_pline[prev_valid_i].e < trim.m_pline[i].e) )
      {
        if (text_log )
          text_log->Print("ON_Brep.m_T[%d].m_pline[%d].t must be < m_pline[%d].t.\n",ti,prev_valid_i,i);
        return ON_BrepIsNotValid();
      }
      prev_valid_i = i;
    }
  }
#endif

  return true;
}



bool ON_Brep::SetEdgeVertex( const int ei, const int evi, const int vi )
{
  if ( ei < 0 || vi < 0 || evi < 0 || evi > 1 )
    return false;
  ON_BrepEdge& edge = m_E[ei];
  if ( edge.m_vi[evi] != vi ) {
    edge.m_vi[evi] = vi;
    ON_BrepVertex& vertex = m_V[vi];
    vertex.m_ei.Append(ei);
  }
  const int trim_count = edge.m_ti.Count();
  int eti, ti, tvi;
  for ( eti = 0; eti < trim_count; eti++ ) {
    ti = edge.m_ti[eti];
    if ( ti < 0 )
      continue;
    ON_BrepTrim& trim = m_T[ti];
    tvi = trim.m_bRev3d ? 1-evi : evi;
    trim.m_vi[tvi] = vi;
  }
  return true;
}

bool ON_Brep::HopAcrossEdge( int& ti, int& tvi ) const
{
  // Tf ti is a trim associated with an interior manifold edge,
  // then ti is set to twin.
  int ei, evi, new_ti, new_tvi;
  if ( ti < 0 )
    return false;
  ei = m_T[ti].m_ei;
  if ( ei < 0 )
    return false;
  const ON_BrepEdge& edge = m_E[ei];
  if ( edge.m_ti.Count() < 2 )
    return false;
  evi = (m_T[ti].m_bRev3d) ? 1-tvi : tvi;
  new_ti = edge.m_ti[(edge.m_ti[0] == ti)?1:0];
  if ( new_ti < 0 )
    return false;
  new_tvi = (m_T[new_ti].m_bRev3d) ? 1-evi : evi;
  ti = new_ti;
  tvi = new_tvi;
  return true;
}

bool ON_Brep::SetTrimStartVertex( const int ti0, const int vi )
{
  // Do not use NextEdge(), PrevEdge() because they require
  // the information we are in the act of creating.
  if ( ti0 < 0 || vi < 0 )
    return false;
  int next_ti, ti, ei, evi, tvi, counter;

  // Step counter clockwise around vertex until we hit a boundary
  // or we get back to where we started.
  for ( ti = ti0, tvi = 0, counter = 0; ti >= 0 && counter < 512; counter++ ) {
    if ( counter > 0 ) {
      if ( ti == ti0 && tvi == 0 )
        return true; // vertex was interior
    }
    ON_BrepTrim& trim = m_T[ti];
    if ( trim.m_type == ON_BrepTrim::singular ) {
      trim.m_vi[0] = trim.m_vi[1] = vi;
      tvi = 1-tvi;
      next_ti = (tvi) ? NextTrim(ti) : PrevTrim(ti);
      ti = next_ti;
      tvi = 1-tvi;
      if ( ti == ti0 && tvi == 0 )
        return true; // vertex was interior
      if ( m_T[ti].m_type != ON_BrepTrim::singular )
        HopAcrossEdge( ti, tvi ); // OK if hop fails because ti is a boundary
      continue;
    }

    ei = trim.m_ei;
    evi = (trim.m_bRev3d) ? 1-tvi : tvi;
    if ( !SetEdgeVertex( ei, evi, vi ) )
      return false;
    next_ti = (tvi) ? NextTrim(ti) : PrevTrim(ti);
    ti = next_ti;
    tvi = 1-tvi;
    if ( ti < 0 )
      return false; // should not happen

    if ( m_T[ti].m_type == ON_BrepTrim::singular )
      continue;
    ei = m_T[ti].m_ei;
    if ( ei < 0 )
      return false; // should not happen
    evi = (m_T[ti].m_bRev3d) ? 1-tvi : tvi;
    const int edge_trim_count = m_E[ei].m_ti.Count();
    if ( edge_trim_count < 1 )
      break; // should not happen
    if ( edge_trim_count == 1 ) {
      SetEdgeVertex( ei, evi, vi );
      break; // ran into boundary
    }
    if ( !HopAcrossEdge( ti, tvi ) )
      return false;
  }


  // Get ready to step counter clockwise around vertex until
  // we hit a boundary.
  ti = ti0;
  tvi = 0;
  if ( m_T[ti].m_type == ON_BrepTrim::singular ) {
    // back up until we get to a non-singular trim
    while ( m_T[ti].m_type == ON_BrepTrim::singular ) {
      if ( ti != ti0 ) {
        m_T[ti].m_vi[0] = vi;
        m_T[ti].m_vi[1] = vi;
      }
      ti = PrevTrim(ti);
      tvi = 1;
      if ( ti == ti0 )
        break;
    }
    ei = m_T[ti].m_ei;
    if ( ei >= 0 ) {
      evi = (m_T[ti].m_bRev3d) ? 1-tvi : tvi;
      SetEdgeVertex( ei, evi, vi );
    }
  }
  else {
    ei = m_T[ti].m_ei;
  }
  if ( ei < 0 ) {
    // did the best we could - return true so setter keeps going
    // but the fact we are here means the brep is bogus.
    return true;
  }
  if ( m_E[ei].m_ti.Count() < 2 )
    return true; // ti0 is a boundary - we're done.
  if ( !HopAcrossEdge( ti, tvi ) )
    return false;
  next_ti = (tvi) ? NextTrim(ti) : PrevTrim(ti);
  if ( next_ti < 0 )
    return false;
  ti = next_ti;
  tvi = 1-tvi;
  if ( m_T[ti].m_type != ON_BrepTrim::singular ) {
    ei = m_T[ti].m_ei;
    if ( ei < 0 )
      return false;
    if ( m_E[ei].m_ti.Count() == 1 ) {
      evi = (m_T[ti].m_bRev3d)? 1-tvi : tvi;
      SetEdgeVertex( ei, evi, vi );
      return true;
    }
    if ( !HopAcrossEdge( ti, tvi ) )
      return false;
  }

  const int ti1 = ti;
  const int tvi1 = tvi;
  
  for ( ti = ti1, tvi = tvi1, counter = 0; ti >= 0 && counter < 512; counter++ ) {
    if ( counter > 0 ) {
      if ( ti == ti1 && tvi == tvi1 )
        return false; // vertex is not interior - so this should not happen
    }
    ON_BrepTrim& trim = m_T[ti];
    if ( trim.m_type == ON_BrepTrim::singular ) {
      trim.m_vi[0] = trim.m_vi[1] = vi;
      tvi = 1-tvi;
      next_ti = (tvi) ? NextTrim(ti) : PrevTrim(ti);
      ti = next_ti;
      tvi = 1-tvi;
      if ( ti == ti1 && tvi == tvi1 )
        return false; // vertex is not interior - so this should not happen
      if ( m_T[ti].m_type != ON_BrepTrim::singular )
        HopAcrossEdge( ti, tvi );  // OK if hop fails because ti is a boundary
      continue;
    }

    ei = trim.m_ei;
    evi = (trim.m_bRev3d) ? 1-tvi : tvi;
    if ( !SetEdgeVertex( ei, evi, vi ) )
      return false;
    next_ti = (tvi) ? NextTrim(ti) : PrevTrim(ti);
    ti = next_ti;
    tvi = 1-tvi;
    if ( ti < 0 )
      return false; // should not happen
    
    if ( m_T[ti].m_type == ON_BrepTrim::singular )
      continue;
    ei = m_T[ti].m_ei;
    if ( ei < 0 )
      return false; // should not happen
    evi = (m_T[ti].m_bRev3d) ? 1-tvi : tvi;
    const int edge_trim_count = m_E[ei].m_ti.Count();
    if ( edge_trim_count < 1 )
      break; // should not happen
    if ( edge_trim_count == 1 ) {
      SetEdgeVertex( ei, evi, vi );
      return true; // ran into boundary - expected
    }
    if ( !HopAcrossEdge( ti, tvi ) )
      return false;
  }

  return false; // should have exited by hitting "expected" boundary ~10 lines above
}

void ON_Brep::SetLoopVertices( const int li )
{
  ON_BrepLoop& loop = m_L[li];
  const int loop_trim_count = loop.m_ti.Count();
  int lti;
  for ( lti = 0; lti < loop_trim_count; lti++ ) {
    const int ti = loop.m_ti[lti];
    ON_BrepTrim& trim = m_T[ti];
    int vi = trim.m_vi[0];
    if ( vi >= 0 )
      continue;
    ON_BrepVertex& v = NewVertex();
    SetTrimStartVertex( ti, v.m_vertex_index );
  }
}

void ON_Brep::ClearTrimVertices()
{
  int ti;
  const int tcnt = m_T.Count();
  for ( ti = 0; ti < tcnt; ti++ ) {
    ON_BrepTrim& trim = m_T[ti];
    trim.m_vi[0] = -1;
    trim.m_vi[1] = -1;
  }
}

void ON_Brep::ClearEdgeVertices()
{
  int ei;
  const int ecnt = m_E.Count();
  for ( ei = 0; ei < ecnt; ei++ ) {
    ON_BrepEdge& edge = m_E[ei];
    edge.m_vi[0] = -1;
    edge.m_vi[1] = -1;
  }
}

int ON_Brep::NextTrim(int ti) const
{
  const ON_BrepTrim& trim = m_T[ti];
  const int li = trim.m_li;
  const ON_BrepLoop& loop = m_L[li];
  const int trim_count = loop.m_ti.Count();
  int lti;
  for ( lti = 0;  lti < trim_count && loop.m_ti[lti] != ti; lti++)
    ;/* empty for*/
  if ( lti < 0 || lti >= trim_count )
    return -1;
  return loop.m_ti[(lti+1)%trim_count];
}

int ON_Brep::PrevTrim(int ti) const
{
  const ON_BrepTrim& trim = m_T[ti];
  const int li = trim.m_li;
  const ON_BrepLoop& loop = m_L[li];
  const int trim_count = loop.m_ti.Count();
  int lti;
  for ( lti = 0; loop.m_ti[lti] != ti && lti < trim_count; lti++)
    ;/* empty for*/
  if ( lti < 0 || lti >= trim_count )
    return -1;
  return loop.m_ti[(lti+trim_count-1)%trim_count];
}

int ON_Brep::NextEdge(int ei, int endi, int* next_endi ) const
{
  const ON_BrepEdge& edge = m_E[ei];
  const int vi = edge.m_vi[endi];
  const ON_BrepVertex& vertex = m_V[vi];
  const int edge_count = vertex.m_ei.Count();
  int vei;
  if ( edge_count < 2 )
    return -1;
  if ( next_endi )
    *next_endi = 0;
  for ( vei = 0; vertex.m_ei[vei] != ei && vei < edge_count; vei++)
    ;/* empty for*/
  if ( edge.m_vi[0] == edge.m_vi[1]  && endi ) {
    // get next occurance of edge index
    //
    // On closed edges, edge.m_vi[0] = edge.m_vi[1] and edge.edge_index 
    // appears TWICE in vertex.m_ei[].  The first occurance of edge.edge_index
    // in vertex.m_ei[] corresponds to edge.m_vi[0].  The second occurance
    // of edge.edge_index in vertex.m_ei[] corresponds to edge.m_vi[1].
    vei++;
    while ( vei < edge_count && vertex.m_ei[vei] != ei )
      vei++;
  }
  if ( vei < 0 || vei >= edge_count )
    return -1;
  vei = (vei+1)%edge_count;
  const int next_ei = vertex.m_ei[vei];
  if ( next_endi ) {
    if ( m_E[next_ei].m_vi[0] == m_E[next_ei].m_vi[1] ) {
      *next_endi = 1;
      for ( vei++; vei < edge_count; vei++ ) {
        if ( vertex.m_ei[vei] == next_ei ) {
          *next_endi = 0;
          break;
        }
      }
    }
    else if ( m_E[next_ei].m_vi[1] == vi )
      *next_endi = 1;
  }
  return next_ei;
}

int ON_Brep::PrevEdge(int ei, int endi, int* prev_endi ) const
{
  const ON_BrepEdge& edge = m_E[ei];
  const int vi = edge.m_vi[endi];
  const ON_BrepVertex& vertex = m_V[vi];
  const int edge_count = vertex.m_ei.Count();
  if ( edge_count < 2 )
    return -1;
  int vei;
  if ( prev_endi )
    *prev_endi = 0;
  for ( vei = 0; vertex.m_ei[vei] != ei && vei < edge_count; vei++)
    ;/* empty for*/
  if ( edge.m_vi[0] == edge.m_vi[1] && endi ) {
    // get next occurance of edge index
    //
    // On closed edges, edge.m_vi[0] = edge.m_vi[1] and edge.edge_index 
    // appears TWICE in vertex.m_ei[].  The first occurance of edge.edge_index
    // in vertex.m_ei[] corresponds to edge.m_vi[0].  The second occurance
    // of edge.edge_index in vertex.m_ei[] corresponds to edge.m_vi[1].
    vei++;
    while ( vei < edge_count && vertex.m_ei[vei] != ei )
      vei++;
  }
  if ( vei < 0 || vei >= edge_count )
    return -1;
  vei = (vei+edge_count-1)%edge_count;
  const int prev_ei = vertex.m_ei[(vei+edge_count-1)%edge_count];
  if ( prev_endi ) {
    if ( m_E[prev_ei].m_vi[0] == m_E[prev_ei].m_vi[1] ) {
      *prev_endi = 1;
      for ( vei++; vei < edge_count; vei++ ) {
        if ( vertex.m_ei[vei] == prev_ei ) {
          *prev_endi = 0;
          break;
        }
      }
    }
    else if ( m_E[prev_ei].m_vi[1] == vi ) {
      *prev_endi = 1;
    }
  }
  return prev_ei;
}

// HELPER CLASS - DO NOT PUT DEFINITION IN A HEADER FILE
class ON__EDGE_ENDS
{
public:
  // used to sort vertices of closed edges that need
  // to be combined.
  int vi0; // smallest edge vertex index
  int vi1; // largest edge vertex index
  int ei;  // index of closed edge
  bool operator<(const ON__EDGE_ENDS& other) const
  {
    int i = other.vi0 - vi0;
    if ( i < 0 ) return true;
    if ( i > 0 ) return false;
    i = other.vi1 - vi1;
    if ( i < 0 ) return true;
    if ( i > 0 ) return false;
    i = other.ei - ei;
    if ( i < 0 ) return true;
    return false;
  }
};

void ON_Brep::SetVertices(void)
{
  const int face_count = m_F.Count();
  int fi;
  
  ClearEdgeVertices();
  ClearTrimVertices();
  m_V.Empty();
  m_V.Shrink();
  fi = m_E.Count() - m_F.Count() + 8;
  if ( fi < 32 )
    fi = 32;
  m_V.Reserve( fi );
  for ( fi = 0; fi < face_count; fi++ ) {
    ON_BrepFace& face = m_F[fi];
    const int loop_count = face.m_li.Count();
    int fli;
    for ( fli = 0; fli < loop_count; fli++ ) {
      SetLoopVertices( face.m_li[fli] );
    }
  }

  // average edges' end location to get vertex location
  const int vertex_count = m_V.Count();
  int vi;
  ON_3dPoint VP, EP;
  for ( vi = 0; vi < vertex_count; vi++ ) 
  {
    VP.Zero();
    double d = 0.0;
    ON_BrepVertex& vertex = m_V[vi];
    const int edge_count = vertex.m_ei.Count();
    int vei;
    for ( vei = 0; vei < edge_count; vei++ ) 
    {
      const int ei = vertex.m_ei[vei];
      if ( ei < 0 ) 
        continue;
      const ON_BrepEdge& edge = m_E[ei];
      if ( edge.m_c3i < 0 )
        continue;
      const ON_Curve* pC = edge.EdgeCurveOf();
      if ( !pC )
        continue;
      if ( edge.m_vi[0] == vi )
        EP = edge.PointAtStart();
      else if ( edge.m_vi[1] == vi )
        EP = edge.PointAtEnd();
      else
        continue;
      VP.x += EP.x;
      VP.y += EP.y;
      VP.z += EP.z;
      d += 1.0;
    }
    if ( d > 0.0 ) 
    {
      d = 1.0/d;
      vertex.point = d*VP;
    }
  }

  const int edge_count = m_E.Count();
  int ei;
  ON_SimpleArray<ON__EDGE_ENDS> edge_ends(edge_count/4 + 2);
  for ( ei = 0; ei < edge_count; ei++ )
  {
    // see if we have any 3d edges that are closed as 3d curves
    // but have distinct end vertices
    const ON_BrepEdge& edge = m_E[ei];
    if (    edge.m_vi[0] >= 0 
         && edge.m_vi[1] >= 0
         && edge.m_vi[0] != edge.m_vi[1]
         && 0 != edge.EdgeCurveOf()
         && edge.IsClosed() )
    {
      ON__EDGE_ENDS& ee = edge_ends.AppendNew();
      if ( edge.m_vi[0] < edge.m_vi[1] )
      {
        ee.vi0 = edge.m_vi[0];
        ee.vi1 = edge.m_vi[1];
      }
      else
      {
        ee.vi0 = edge.m_vi[1];
        ee.vi1 = edge.m_vi[0];
      }
      ee.ei = ei;
    }
  }

  if ( edge_ends.Count() > 0 )
  {
    // we need to combine some vertices and the ends of closed edges
    edge_ends.QuickSort( ON_CompareIncreasing<ON__EDGE_ENDS> );
    int edge_ends_count = edge_ends.Count();
    int i0, i1, vi0, vi1, i;

    // adjust indices of chained closed edges
    for ( i = 1; i < edge_ends_count; i++ )
    {
      bool bSortAgain = false;
      for ( i0 = 0; i0 < edge_ends_count; i0++ )
      {
        vi0 = edge_ends[i0].vi0;
        vi1 = edge_ends[i0].vi1;
        for ( i1 = i0+1; i1 < edge_ends_count; i1++ )
        {
          ON__EDGE_ENDS& ee = edge_ends[i1];
          if ( ee.vi0 == vi1 )
          {
            ee.vi0 = vi0;
            bSortAgain = true;
          }
          if ( ee.vi1 == vi1 )
          {
            ee.vi1 = ee.vi0;
            ee.vi0 = vi0;
            bSortAgain = true;
          }
        }
      }
      if ( bSortAgain )
      {
        edge_ends.QuickSort( ON_CompareIncreasing<ON__EDGE_ENDS> );
      }
      else
        break;
    }

    // combine vertices at ends of closed edges into a single vertex
    bool bCullUnusedVertices = false;
    for ( i0 = 0, i1 = 1; i0 < edge_ends.Count(); i0 = i1 )
    {
      vi0 = edge_ends[i0].vi0;
      for ( i1 = i0+1; i1 < edge_ends.Count() && vi0 == edge_ends[i1].vi0; i1++ )
      {
        // empty body
      }
      vi1 = vi0;
      for ( i = i0; i < i1; i++ )
      {
        if ( edge_ends[i].vi1 > vi1 )
        {
          vi1 = edge_ends[i].vi1;
          if ( 0 <= vi0 && vi0 < vi1 && vi1 < m_V.Count())
          {
            CombineCoincidentVertices(m_V[vi0],m_V[vi1] );
            bCullUnusedVertices = true;
          }
        }
      }
    }
    if ( bCullUnusedVertices )
      CullUnusedVertices();
  }
}

void ON_BrepTrim::m__legacy_flags_Set(int gcon, int mono)
{
  m__legacy_flags = 0;
  switch(gcon)
  {
  case -1:
    m__legacy_flags |= 1;
    break;
  case 0:
    m__legacy_flags |= 2;
    break;
  case 1:
    m__legacy_flags |= 3;
    break;
  case 2:
    m__legacy_flags |= 4;
    break;
  }
  if (mono)
    m__legacy_flags |= 8;
  else
    m__legacy_flags |= 16;
}

bool ON_BrepTrim::m__legacy_flags_Get(int* gcon, int* mono) const
{
  if ( gcon ) {
    switch ( m__legacy_flags & 7 )
    {
    case 1:
      *gcon = -1;
      break;
    case 2:
      *gcon = 0;
      break;
    case 3:
      *gcon = 1;
      break;
    case 4:
      *gcon = 2;
      break;
    default:
      *gcon = -1;
    }
  }
  if ( mono ) {
    if ( 0 != (m__legacy_flags&8) )
      *mono = 1;
    else
      *mono = 0;
  }
  return m__legacy_flags ? true : false;
}
void ON_Brep::SetTolsFromLegacyValues()
{
  // use m_2d_tol and m_3d_tol read from file to set public tolerances
  const int vcnt = m_V.Count();
  const int tcnt = m_T.Count();
  ON_3dPoint endP;
  double d;
  int vi, ti, vei, evi, vecnt;
  
  // set trim and edge tolerances from values in file
  for ( ti = 0; ti < tcnt; ti++ ) {
    ON_BrepTrim& trim = m_T[ti];
    trim.m_tolerance[0] = trim.m__legacy_2d_tol; // "pe_tol"
    trim.m_tolerance[1] = trim.m__legacy_2d_tol; // "pe_tol"
    if ( trim.m_ei >= 0 ) {
      ON_BrepEdge& edge = m_E[trim.m_ei];
      if ( edge.m_tolerance < trim.m__legacy_3d_tol )
        edge.m_tolerance = trim.m__legacy_3d_tol; // "e_tol"
    }
  }

  // set vertex tolerances from edge tols and end evaluations
  for ( vi = 0; vi < vcnt; vi++ ) {
    ON_BrepVertex& vertex = m_V[vi];
    vecnt = vertex.m_ei.Count();
    for ( vei = 0; vei < vecnt; vei++ ) {
      const ON_BrepEdge& edge = m_E[vertex.m_ei[vei]];
      if ( vertex.m_tolerance < edge.m_tolerance )
        vertex.m_tolerance = edge.m_tolerance;
      const ON_Curve* c = m_C3[edge.m_c3i];
      evi = 0;
      if ( edge.m_vi[0] != vi )
        evi = 1;
      if ( edge.m_vi[evi] == vi ) {
        endP = c->PointAt( c->Domain()[evi] );
        d = vertex.point.DistanceTo( endP );
        if ( d > vertex.m_tolerance ) {
          vertex.m_tolerance = d;      
        }
      }
    }
  }
}

ON::object_type ON_Brep::ObjectType() const
{
  // This must ALWAYS return ON::brep_object.
  // NEVER modify this function to return any
  // other value.
  return ON::brep_object;
}

void ON_Brep::ClearBoundingBox()
{
  m_bbox.Destroy();
}

void ON_BrepFace::ClearBoundingBox()
{
  m_bbox.Destroy();
}

ON_BOOL32
ON_BrepFace::GetBBox(
          double* box_min, // [3],
          double* box_max, // [3],
          ON_BOOL32 bGrowBox     // = false
          ) const
{
  if ( !m_bbox.IsValid() 
       && 0 != m_brep 
       && m_face_index >= 0 
       && m_face_index < m_brep->m_F.Count()
       && &m_brep->m_F[m_face_index] == this 
       )
  {
    const ON_Surface* srf = ProxySurface();
    if ( srf && srf != this )
    {
      srf->GetBoundingBox( const_cast<ON_BrepFace*>(this)->m_bbox, false );
    }
  }

  ON_BOOL32 rc = m_bbox.IsValid();
  if (rc)
  {
    ON_BoundingBox bbox = m_bbox;
    if ( bGrowBox && box_min && box_max && box_min[0] <= box_max[0] )
    {
      bbox.Union( ON_BoundingBox( ON_3dPoint(box_min), ON_3dPoint(box_max) ) );
    }
    if ( box_min )
    {
      box_min[0] = bbox.m_min.x;
      box_min[1] = bbox.m_min.y;
      box_min[2] = bbox.m_min.z;
    }
    if ( box_max )
    {
      box_max[0] = bbox.m_max.x;
      box_max[1] = bbox.m_max.y;
      box_max[2] = bbox.m_max.z;
    }
  }
  return rc;
}


ON_BOOL32
ON_Brep::GetBBox(
          double* box_min, // [3],
          double* box_max, // [3],
          ON_BOOL32 bGrowBox     // = false
          ) const
{
  ON_BoundingBox bbox;
  if ( !m_bbox.IsValid() )
  {
    const int face_count = m_F.Count();
    int fi;
    for ( fi = 0; fi < face_count; fi++ ) 
    {
      if ( m_F[fi].m_face_index == -1 )
        continue;
      const ON_Surface* srf = m_F[fi].ProxySurface();
      if ( !srf )
        continue;
      srf->GetBoundingBox( bbox, bbox.IsValid() );
    }
    ON_Brep* ptr = const_cast<ON_Brep*>(this);
    ptr->m_bbox = bbox;
  }

  ON_BOOL32 rc = m_bbox.IsValid();
  if (rc)
  {
    bbox = m_bbox;
    if ( bGrowBox && box_min && box_max && box_min[0] <= box_max[0] )
    {
      bbox.Union( ON_BoundingBox( ON_3dPoint(box_min), ON_3dPoint(box_max) ) );
    }
    if ( box_min )
    {
      box_min[0] = bbox.m_min.x;
      box_min[1] = bbox.m_min.y;
      box_min[2] = bbox.m_min.z;
    }
    if ( box_max )
    {
      box_max[0] = bbox.m_max.x;
      box_max[1] = bbox.m_max.y;
      box_max[2] = bbox.m_max.z;
    }
  }
  return rc;
}

ON_BOOL32
ON_Brep::SwapCoordinates( int i, int j )
{
  ON_BOOL32 rc = false;
  // swap surface coordinates
  const int srf_count = m_S.Count();
  int si;
  for ( si = 0; si < srf_count; si++ ) {
    if ( !m_S[si] ) 
      continue;
    rc = m_S[si]->SwapCoordinates(i,j);
    if ( !rc ) {
      while ( --si >= 0 ) {
        // undo any changes;
        if ( m_S[si] )
          m_S[si]->SwapCoordinates(i,j);
      }
      return false;
    }
  }
  // swap 3d curve coordinates
  const int crv_count = m_S.Count();
  int ci;
  for ( ci = 0; ci < crv_count; ci++ ) {
    if ( !m_C3[ci] ) 
      continue;
    rc = m_C3[ci]->SwapCoordinates(i,j);
    if ( !rc ) {
      // undo any changes;
      while ( --ci >= 0 ) {
        if ( m_C3[ci] )
          m_C3[ci]->SwapCoordinates(i,j);
        for ( si = 0; si < srf_count; si++ ) {
          if ( m_S[si] )
            m_S[si]->SwapCoordinates(i,j);
        }
      }
      return false;
    }
  }
  return rc;
}

bool
ON_Brep::SwapTrimParameters(
        int trim_index
        )
{
  // helper for SwapLoopParameters
  if ( trim_index < 0 || trim_index >= m_T.Count() )
    return false;
  ON_BrepTrim& trim = m_T[trim_index];

  StandardizeTrimCurve(trim_index);

  const int ci = trim.m_c2i;
  if ( ci < 0 || ci >= m_C2.Count() )
    return false;
  ON_Curve* pC = m_C2[ci];
  if ( !pC )
    return false;

  ON_Interval pdom = trim.ProxyCurveDomain();
  ON_Interval trimdom = trim.Domain();

  // have to call SwapCoordinates on pC because
  // ON_CurveProxy does not permit modification
  // of "real" curve.
  ON_BOOL32 rc = pC->SwapCoordinates(0,1); // "u" <-> "v"
  if ( !rc )
    return false;

  // reverse 2d curve
  rc = pC->Reverse();
  if (rc)
  {
    // take care of proxy house keeping, m_vi[] swapping, and toggle m_bRev3d.
    trim.SetProxyCurve(pC);
    int i = trim.m_vi[0];
    trim.m_vi[0] = trim.m_vi[1];
    trim.m_vi[1] = i;
    if ( trim.m_ei >= 0 )
      trim.m_bRev3d = trim.m_bRev3d ? false : true;
  }
  else
  {
    // undo changes
    rc = pC->SwapCoordinates(0,1); // "u" <-> "v"
    return false;
  }

  // reflect iso type
  switch ( trim.m_iso ) 
  {
  case ON_Surface::not_iso:
    trim.m_iso = ON_Surface::not_iso;
    break;
  case ON_Surface::x_iso:
    trim.m_iso = ON_Surface::y_iso;
    break;
  case ON_Surface::y_iso:
    trim.m_iso = ON_Surface::x_iso;
    break;
  case ON_Surface::W_iso:
    trim.m_iso = ON_Surface::S_iso;
    break;
  case ON_Surface::S_iso:
    trim.m_iso = ON_Surface::W_iso;
    break;
  case ON_Surface::E_iso:
    trim.m_iso = ON_Surface::N_iso;
    break;
  case ON_Surface::N_iso:
    trim.m_iso = ON_Surface::E_iso;
    break;
  default:
    trim.m_iso = ON_Surface::not_iso;
    break;
  }

  return true;
}

bool
ON_Brep::SwapLoopParameters(
        int loop_index
        )
{
  bool rc = false;
  if ( loop_index < 0 || loop_index >= m_L.Count() )
    return false;
  ON_BrepLoop& L = m_L[loop_index];
  const int loop_trim_count = L.m_ti.Count();
  if ( loop_trim_count < 1 )
    return false;
  int lti, ti;
  for ( lti = 0; lti < loop_trim_count; lti++ ) {
    ti = L.m_ti[lti];
    rc = SwapTrimParameters( ti );
    if ( !rc ) {
      while ( --lti >= 0 ) {
        // undo any changes
        ti = L.m_ti[lti];
        SwapTrimParameters( ti );
      }
      return false;
    }
  }

  // reverse order of trimming curves
  if ( rc )
    L.m_ti.Reverse();
  return rc;
}

bool
ON_Brep::IsSolid() const
{
  ON_BOOL32 bIsOriented = false;
  ON_BOOL32 bHasBoundary = true;
  bool bIsManifold = IsManifold( &bIsOriented, &bHasBoundary );
  return (bIsManifold && bIsOriented && !bHasBoundary) ? true : false;
}

int ON_Brep::SolidOrientation() const
{
  // m_is_solid values:
  //   0 = unset
  //   1 = solid with normals pointing out
  //   2 = solid with normals pointing in
  //   3 = not solid
  int rc = 0;
  switch( m_is_solid )
  {
  case 1: // solid with normals pointing out
    rc = 1;
    break;
  case 2: // solid with normals pointing in
    rc = -1;
    break;
  case 3: // not a solid
    rc = 0;
    break;
  
  default:
    if ( IsSolid() )
    {
      // this virtual function is overridden in Rhino SDK
      // and sets m_is_solid to appropriate values.  This
      // stand-alone version cannot tell the difference
      // between solids with inward pointing normals and
      // solids with outwards pointing normals.
      //ON_Brep* p = const_cast<ON_Brep*>(this);
      //p->m_is_solid = 1;
      rc = 2;
    }
    else
    {
      ON_Brep* p = const_cast<ON_Brep*>(this);
      p->m_is_solid = 3;
      rc = 0;
    }
  }
  return rc;
}

bool
ON_Brep::IsManifold( ON_BOOL32* pbIsOriented, ON_BOOL32* pbHasBoundary ) const
{
  const int fcnt = m_F.Count();
  bool bIsManifold = (fcnt > 0) ? true : false;
  bool bIsOriented = bIsManifold;
  bool bHasBoundary = false;
  int fi, other_ti, lcnt, tcnt, fli, lti;
  if ( pbIsOriented )
    *pbIsOriented = bIsOriented;
  if ( pbHasBoundary )
    *pbHasBoundary = bHasBoundary;
  const int brep_loop_count = m_L.Count();
  const int brep_trim_count = m_T.Count();
  const int brep_edge_count = m_E.Count();
  for ( fi = 0; fi < fcnt && bIsManifold; fi++ ) 
  {
    const ON_BrepFace& face = m_F[fi];
    if ( -1 == face.m_face_index )
    {
      // 28 October 2010 - Dale Lear and Chuck
      //    Do not test deleted faces. The join
      //    command calls is manifold with some
      //    deleted faces to avoid calling Compact
      //    lots of times during a join.
      continue;
    }

    lcnt = face.m_li.Count();
    if ( lcnt < 1 ) {
      bIsManifold = false;
    }

    for ( fli = 0; fli < lcnt && bIsManifold; fli++ ) 
    {
      const int li = face.m_li[fli];
      if ( li < 0 || li >= brep_loop_count )
      {
        ON_ERROR("Bogus loop index in face.m_li[]");
        continue;
      }
      const ON_BrepLoop& loop = m_L[li];
      tcnt = loop.m_ti.Count();
      if (tcnt < 1 ) {
        bIsManifold = false;
      }
      for ( lti = 0; lti < tcnt && bIsManifold; lti++ ) 
      {
        const int ti = loop.m_ti[lti];
        if ( ti < 0 || ti >= brep_trim_count )
        {
          ON_ERROR("Bogus loop index in loop.m_ti[]");
          continue;
        }
        const ON_BrepTrim& trim = m_T[ti];
        switch ( trim.m_type ) 
        {
        case ON_BrepTrim::boundary:
          bHasBoundary = true;
          break;
        case ON_BrepTrim::mated:
        case ON_BrepTrim::seam:
          // make sure we have a manifold join
          if ( trim.m_ei >= 0 && trim.m_ei < brep_edge_count )
          {
            const ON_BrepEdge& edge = m_E[trim.m_ei];
            if ( edge.m_ti.Count() != 2 ) {
              bIsManifold = false;
            }
            else 
            {
              other_ti = edge.m_ti[0];
              if ( other_ti == ti )
                other_ti = edge.m_ti[1];
              if ( other_ti == ti )
              {
                bIsManifold = false;
              }
              else 
              {
                const ON_BrepTrim& other_trim = m_T[other_ti];

                // Nov 9, 2011 Tim - Fix for crash bug RR 93743
                // Better index checking.

                ON_BOOL32 bFlipTrim = trim.m_bRev3d;
                if (0 <= trim.m_li && brep_loop_count > trim.m_li)
                {
                  if ( m_F[m_L[trim.m_li].m_fi].m_bRev )
                    bFlipTrim = !bFlipTrim;
                }
                else
                {
                  ON_ERROR("Bogus loop index in trim.m_li");
                  continue;
                }

                ON_BOOL32 bFlipOther = other_trim.m_bRev3d;
                if (0 <= other_trim.m_li && brep_loop_count > other_trim.m_li)
                {
                  if ( m_F[m_L[other_trim.m_li].m_fi].m_bRev )
                    bFlipOther = !bFlipOther;
                }
                else
                {
                  ON_ERROR("Bogus loop index in other_trim.m_li");
                  continue;
                }

                if ( bFlipTrim && bFlipOther )
                {
                  bIsOriented = false;
                }
                else if ( !bFlipTrim && !bFlipOther )
                {
                  bIsOriented = false;
                }
              }
            }
          }
          else
          {
            ON_ERROR("Bogus trim.m_ei or trim.m_type value");
          }
          break;
        case ON_BrepTrim::singular:
          // nothing to check here
          break;
        default:
          bIsManifold = false;
          break;
        }
      }
    }
  }
  if ( !bIsManifold ) {
    bIsOriented = false;
    bHasBoundary = false;
  }
  if ( pbIsOriented )
    *pbIsOriented = bIsOriented;
  if ( pbHasBoundary )
    *pbHasBoundary = bHasBoundary;
  if ( !bIsManifold || bHasBoundary )
  {
    if ( m_is_solid != 3 )
    {
      // lazy evaluation used on m_is_solid
      const_cast<ON_Brep*>(this)->m_is_solid = 3;
    }
  }

  return bIsManifold;
}


bool
ON_Brep::IsSurface() const
{
  // returns true if the b-rep has a single face
  // and that face is geometrically the same
  // as the underlying surface.  I.e., the face
  // has trivial trimming.  In this case, the
  // surface is m_S[0].
  return (m_F.Count() == 1 && FaceIsSurface(0));
}

bool 
ON_Brep::FaceIsSurface( int face_index ) const
{
  // returns true if the face has a single
  // outer boundary and that boundary runs
  // along the edges of the underlying surface.
  // In this case the geometry of the surface
  // is the same as the geometry of the face.

  bool bTrivialFace = false;
  if ( face_index >= 0 && face_index < m_F.Count() ) {
    const ON_BrepFace& face = m_F[face_index];
    if ( face.m_li.Count() == 1 ) {
      bTrivialFace = LoopIsSurfaceBoundary( face.m_li[0] );
    }
  }
  return bTrivialFace;
}

bool 
ON_Brep::LoopIsSurfaceBoundary( int loop_index ) const
{
  // returns true if the loop's trims run along the underlying surface boundary
  bool bTrivialLoop = false;
  if ( loop_index >= 0 && loop_index < m_L.Count() ) {
    const ON_BrepLoop& loop = m_L[loop_index];
    const int trim_count = loop.m_ti.Count();
    if ( trim_count > 0 ) {
      bTrivialLoop = true;
      for ( int lti = 0; lti < trim_count && bTrivialLoop; lti++ ) 
      {
        int ti = loop.m_ti[lti];
        if ( ti < 0 || ti >= m_T.Count() )
        {
          ON_ERROR("Bogus trim index in loop.m_ti[]");
          return false;
        }
        const ON_BrepTrim& trim = m_T[ti];
        if ( trim.m_iso == ON_Surface::W_iso )
          continue;
        if ( trim.m_iso == ON_Surface::S_iso )
          continue;
        if ( trim.m_iso == ON_Surface::N_iso )
          continue;
        if ( trim.m_iso == ON_Surface::E_iso )
          continue;
        bTrivialLoop = false;
      }
    }
  }
  return bTrivialLoop;
}

bool
ON_Brep::FlipReversedSurfaces()
{
  // Clears all ON_BrepFace.m_bRev flags
  // by calling SwapFaceParameters() on each
  // face with a true m_bRev.
  //
  // Returns true if successful.

  // 11 April 2008 Dale Lear and Tim:
  //   face.Transpose() is clearing the m_is_solid
  //   flag but we are not changing the orientation
  //   of the brep.  This prevents having to perform
  //   the expensive step of calculating this flag
  //   again.
  int saved_is_solid = m_is_solid;

  const int face_count = m_F.Count();

  bool rc = true;
  int fi;
  for ( fi = 0; fi < face_count; fi++ ) 
  {
    ON_BrepFace& face = m_F[fi];
    if ( face.m_bRev )
    {
      if ( !face.Transpose() )
        rc = false;
    }
  }

  m_is_solid = saved_is_solid;

  return rc;
}

////////
// Change the domain of a trim
bool ON_Brep::SetTrimDomain(
       int trim_index, // index of trim in m_T[] array
       const ON_Interval& domain
       )
{
  bool rc = false;
  if ( trim_index >= 0 && trim_index < m_T.Count() && domain.IsIncreasing() ) 
  {
    ON_BrepTrim& trim = m_T[trim_index];
    rc = trim.SetDomain(domain);
  }
  return rc;
}

////////
// Change the domain of an edge
bool ON_Brep::SetEdgeDomain(
       int edge_index, // index of edge in m_E[] array
       const ON_Interval& domain
       )
{
  bool rc = false;
  if ( edge_index >= 0 && edge_index < m_E.Count() && domain.IsIncreasing() ) 
  {
    ON_BrepEdge& edge = m_E[edge_index];
    rc = edge.SetDomain(domain);
  }
  return rc;
}

ON_BOOL32 ON_BrepFace::Reverse(int dir)
{
  if ( dir < 0 || dir > 1 || 0 == m_brep )
    return false;
  ON_Surface* srf = const_cast<ON_Surface*>(SurfaceOf());
  if ( !srf )
    return false;
  ON_Interval dom0 = srf->Domain(dir);
  if ( !dom0.IsIncreasing() )
    return false;

// 2/18/03 GBA.  Destroy surface cache on face.
	DestroyRuntimeCache(true);

  if ( m_brep->SurfaceUseCount( m_si, 2 ) > 1 )
  {
    srf = srf->DuplicateSurface();
    m_si = m_brep->AddSurface( srf );
    SetProxySurface(srf);
  }

  if ( !srf->Reverse(dir) )
    return false;

  ON_Interval dom1 = dom0;
  dom1.Reverse();
  if ( dom1 != srf->Domain(dir) )
  {
    srf->SetDomain( dir, dom1 );
    dom1 = srf->Domain(dir);
  }

  // adjust location of 2d trim curves
  ON_Xform xform(1);
  xform.IntervalChange(dir,dom0,ON_Interval(dom1[1],dom1[0]));
  TransformTrim(xform);

  // reverse loop orientations.
  int fli;
  for ( fli = 0; fli < m_li.Count(); fli++ )
  {
    ON_BrepLoop* loop = m_brep->Loop(m_li[fli]);
    if ( loop )
      m_brep->FlipLoop( *loop );
  }
  
  m_bRev = m_bRev ? false : true;

  if (m_brep->m_is_solid == 1 || m_brep->m_is_solid == 2) m_brep->m_is_solid = 0;

	// Greg Arden 10 April 2003.  Fix TRR#9624.  
	// Update analysis and render meshes.
	if(m_render_mesh)
  {
    m_render_mesh->ReverseSurfaceParameters(dir);
    m_render_mesh->ReverseTextureCoordinates(dir);
  }
	if(m_analysis_mesh)
  {
    m_analysis_mesh->ReverseSurfaceParameters(dir);
		m_analysis_mesh->ReverseTextureCoordinates(dir);
  }

  return true;
}

ON_BOOL32 ON_BrepFace::Transpose()
{
  if ( 0 == m_brep )
    return false;

  ON_Surface* srf = const_cast<ON_Surface*>(SurfaceOf());
  if ( 0 == srf )
    return false;

  // 2/18/03 GBA.  Destroy cache on the face.
	DestroyRuntimeCache(true);

  // make sure only one face uses this surface
  if ( m_brep->SurfaceUseCount( m_si, 2 ) > 1 )
  {
    srf = srf->DuplicateSurface();
    m_si = m_brep->AddSurface(srf);
    SetProxySurface(srf);
  }

  ON_Interval u0 = srf->Domain(0);
  ON_Interval v0 = srf->Domain(1);

  // swap surface "u" and "v"
  ON_BOOL32 rc = srf->Transpose();
  if ( !rc )
    return false;

  ON_Interval u1 = srf->Domain(0);
  ON_Interval v1 = srf->Domain(1);

  ON_Xform xform(1);
  xform[0][0] = 0.0;
  xform[0][1] = 1.0;
  xform[1][0] = 1.0;
  xform[1][1] = 0.0;

  TransformTrim(xform);

  // reverse loop orientations.
  int fli;
  for ( fli = 0; fli < m_li.Count(); fli++ )
  {
    ON_BrepLoop* loop = m_brep->Loop(m_li[fli]);
    if ( loop )
      m_brep->FlipLoop( *loop );
  }
  
  m_bRev = m_bRev ? false : true;

  
  // 11 April 2008 Dale Lear:
  //    Transposing the surface and then toggling the m_bRev
  //    does not alter the brep's orientation.  Setting this flag
  //    to zero means we will have to do an unnecessary and
  //    expensive calculation in the future.
  //if (m_brep->m_is_solid == 1 || m_brep->m_is_solid == 2) m_brep->m_is_solid = 0;

	// Update analysis mesh and render mesh.
  // (Greg Arden 10 April 2003.  Fix TRR#9624.)
	if(m_render_mesh)
  {
		m_render_mesh->TransposeSurfaceParameters();
		m_render_mesh->TransposeTextureCoordinates();
  }
	if(m_analysis_mesh)
  {
		m_analysis_mesh->TransposeSurfaceParameters();
		m_analysis_mesh->TransposeTextureCoordinates();
  }

  return true;
}

bool ON_BrepFace::SetDomain(
       ON_Interval u_dom,
       ON_Interval v_dom
       )
{
  if ( 0 == m_brep )
    return false;
  if ( !u_dom.IsIncreasing() )
    return false;
  if ( !v_dom.IsIncreasing() )
    return false;
  
  ON_Surface* srf = const_cast<ON_Surface*>(SurfaceOf());
  if ( 0 == srf )
    return false;

  ON_Interval u0_dom = srf->Domain(0);
  ON_Interval v0_dom = srf->Domain(1);
  if ( u0_dom == u_dom && v0_dom == v_dom )
    return true;

  ON_Xform xform(1);
  {
    ON_Xform ux(1), vx(1);
    if ( u0_dom != u_dom )
    {
      if ( !ux.IntervalChange(0,u0_dom,u_dom) )
        return false;
    }
    if ( v0_dom != v_dom )
    {
      if ( !vx.IntervalChange(1,v0_dom,v_dom) )
        return false;
    }
    xform = ux*vx;
  }

// 2/18/03 GBA.  Destroy cache on the face.
	DestroyRuntimeCache(true);

  if ( m_brep->SurfaceUseCount( m_si, 2 ) > 1 )
  {
    srf = srf->DuplicateSurface();
    m_si = m_brep->AddSurface(srf);
    SetProxySurface(srf);
  }

  if ( u_dom != u0_dom )
  {
    if ( !srf->SetDomain( 0, u_dom ) )
      return false;
  }

  if ( v_dom != v0_dom )
  {
    if ( !srf->SetDomain( 1, v_dom ) )
    {
      srf->SetDomain(0,u0_dom );
      return false;
    }
  }

  // just to be sure 2d curves are in synch with actual surface
  // domain in case srf->SetDomain() does something weird.
  u_dom = srf->Domain(0);
  v_dom = srf->Domain(1);
  {
    ON_Xform ux(1), vx(1);
    if ( u0_dom != u_dom )
    {
      if ( !ux.IntervalChange(0,u0_dom,u_dom) )
        return false;
    }
    if ( v0_dom != v_dom )
    {
      if ( !vx.IntervalChange(1,v0_dom,v_dom) )
        return false;
    }
    xform = ux*vx;
  }

  if ( !TransformTrim(xform) )
    return false;

  ON_Mesh* mesh[3] = {m_analysis_mesh,m_render_mesh,m_preview_mesh};
  for ( int i = 0; i < 3; i++ )
  {
    if ( 0 == mesh[i] )
      continue;
    for ( int dir = 0; dir < 2; dir++ )
    {
      ON_Interval& mdom = mesh[i]->m_srf_domain[dir];
      ON_Interval dom0 = dir ? v0_dom : u0_dom;
      ON_Interval dom1 = dir ? v_dom : u_dom;
      if ( mdom.IsIncreasing() && dom0 != dom1 )
      {
        if ( mdom == dom0 )
          mdom = dom1;
        else
        {
          double t0 = dom1.ParameterAt(dom0.NormalizedParameterAt(mdom[0]));
          double t1 = dom1.ParameterAt(dom0.NormalizedParameterAt(mdom[1]));
          mdom.Set(t0,t1);
        }        
      }
    }
  }

  return true;
}

ON_BOOL32 ON_BrepFace::SetDomain( 
    int dir, // 0 sets first parameter's domain, 1 gets second parameter's domain
    double t0, 
    double t1
    )
{
  if (    dir < 0 
       || dir > 1 
       || t0 == ON_UNSET_VALUE 
       || t1 == ON_UNSET_VALUE 
       || t0 >= t1
       || 0 == m_brep )
    return false;

  ON_Surface* srf = const_cast<ON_Surface*>(SurfaceOf());
  if ( 0 == srf )
    return false;
  ON_Interval udom = srf->Domain(0);
  ON_Interval vdom = srf->Domain(1);
  if ( dir )
    vdom.Set(t0,t1);
  else
    udom.Set(t0,t1);

  return SetDomain( udom, vdom );
}



//bool ON_Brep::ReverseFaceParameter(
//      int face_index, // index of face
//      int dir // dir = 0 reverse "u", 1 reverse "v"
//      )
//{
//  // OBSOLETE - use ON_BrepFace::Reverse(dir)
//  bool rc = false;
//  ON_BrepFace* face = Face(face_index);
//  if ( face )
//    rc = face->Reverse(dir)?true:false;
//  return rc;
//}

int ON_Brep::TrimCurveUseCount( int c2_index, int max_count ) const
{
  int ti, use_count = 0;
  if ( max_count < 1 )
    max_count = m_T.Count();
  for ( ti = 0; ti < m_T.Count() && use_count < max_count; ti++ )
  {
    if ( m_T[ti].m_c2i == c2_index )
      use_count++;
  }
  return use_count;
}

int ON_Brep::EdgeCurveUseCount( int c3_index, int max_count ) const
{
  int ei, use_count = 0;
  if ( max_count < 1 )
    max_count = m_T.Count();
  for ( ei = 0; ei < m_E.Count() && use_count < max_count; ei++ )
  {
    if ( m_E[ei].m_c3i == c3_index )
      use_count++;
  }
  return use_count;
}

int ON_Brep::SurfaceUseCount( int surface_index, int max_count ) const
{
  int fi, use_count = 0;
  if ( max_count < 1 )
    max_count = m_F.Count();
  for ( fi = 0; fi < m_F.Count() && use_count < max_count; fi++ )
  {
    if ( m_F[fi].m_si == surface_index )
      use_count++;
  }
  return use_count;
}

////////
// Change the domain of a face
// This also transforms the "u" and "v" coordinates of all the 
// face's parameter space trimming curves.
//bool ON_Brep::SetFaceDomain(
//       int face_index, // index of face in m_F[] array
//       const ON_Interval& u_dom,
//       const ON_Interval& v_dom
//       )
//{
//  // OBSOLETE
//  bool rc = false;
//  ON_BrepFace* face = Face(face_index);
//  if ( face )
//    rc = face->SetDomain(u_dom,v_dom);
//  return rc;
//}

//bool
//ON_Brep::SwapFaceParameters( int face_index )
//{
//  // OBSOLETE
//  bool rc = false;
//  ON_BrepFace* face = Face(face_index);
//  if ( face )
//    rc = face->Transpose()?true:false;
//  return rc;
//}

void
ON_Brep::Flip()
{
  const int fcnt = m_F.Count();
  int fi;
  int missolid = m_is_solid;
  for ( fi = 0; fi < fcnt; fi++ ) {
    FlipFace(m_F[fi]);
  }
  if (missolid==1) m_is_solid = 2;
  else if (missolid==2) m_is_solid = 1;
}

//void
//ON_Brep::FlipEdge( ON_BrepEdge& edge )
//{
//  edge.Reverse();
//}

void
ON_Brep::FlipFace( ON_BrepFace& face )
{
  face.m_bRev = (face.m_bRev) ? false : true;
  if ( face.m_analysis_mesh )
    face.m_analysis_mesh->Flip();
  if ( face.m_render_mesh )
    face.m_render_mesh->Flip();
  if ( face.m_preview_mesh )
    face.m_preview_mesh->Flip();
  //Jun 16 2011 - Chuck - m_is_solid==3 for a brep with inconsistent normals. 
  //Flipping a face could make the normals consistent.
  //if (m_is_solid == 1 || m_is_solid == 2)
  if (0 != m_is_solid)
    m_is_solid = 0;
}

//void 
//ON_Brep::FlipTrim(ON_BrepTrim& trim)
//{
//  trim.Reverse();
//}

void 
ON_Brep::FlipLoop(ON_BrepLoop& loop)
{
  int ti, lti;
  const int brep_trim_count = m_T.Count();
  const int loop_trim_count = loop.m_ti.Count();

  // reverse order of trimming curves
  loop.m_ti.Reverse();
  // reverse direction of individual trimming curves
  for ( lti = 0; lti < loop_trim_count; lti++ ) 
  {
    ti = loop.m_ti[lti];
    if ( ti >= 0 && ti < brep_trim_count ) 
    {
      m_T[ti].Reverse();
    }
  }
}

static int curve_area( ON_3dPoint& start_point, const ON_Curve* curve, const ON_Interval& curve_domain, const ON_Xform* xform, double *area )
{
  // ges a CRUDE approximation of curve area to use for
  // determining if a simple closed curve 2d has 
  // clockwise or couterclockwise orientation.
  ON_Workspace ws;
  ON_Interval span_domain;
  double *span_vector, *t, twice_area = 0.0;
  ON_3dPoint p0, p1;
  int degree, span_count, span_i, j;
  if ( !area )
    return false;
  *area = 0;
  if ( !curve )
    return false;
  const ON_PolyCurve* polycurve = ON_PolyCurve::Cast(curve);
  if ( polycurve )
  {
    span_count = polycurve->Count();  
    ON_Interval span_domain, segment_curve_domain;
    double s0, s1;
    for ( span_i = 0; span_i < span_count; span_i++ )
    {
      span_domain = polycurve->SegmentDomain(span_i);
      if ( span_domain[1] <= curve_domain[0] )
        continue;
      if ( span_domain[0] >= curve_domain[1] )
        break;
      const ON_Curve* segment_curve = polycurve->SegmentCurve(span_i);
      segment_curve_domain = segment_curve->Domain();
      if ( curve_domain[0] > span_domain[0] || curve_domain[1] < span_domain[1] )
      {
        s0 = (curve_domain[0] > span_domain[0]) ? curve_domain[0] : span_domain[0];
        s1 = (curve_domain[1] < span_domain[1]) ? curve_domain[1] : span_domain[1];
        if ( segment_curve_domain != span_domain )
        {
          s0 = span_domain.NormalizedParameterAt(s0);
          s1 = span_domain.NormalizedParameterAt(s1);
          s0 = segment_curve_domain.ParameterAt(s0);
          s1 = segment_curve_domain.ParameterAt(s1);
        }
        segment_curve_domain.Set(s0,s1);
      }
      if ( !curve_area( start_point, segment_curve, segment_curve_domain, xform, &twice_area ) )
      {
        *area = 0.0;
        return false;
      }
      *area += twice_area;
    }
  }
  else 
  {
    span_count = curve->SpanCount();
    if ( span_count < 1 )
      return false;
    degree = curve->Degree();
    if ( degree <= 1 )
    {
      degree = 1;
    }
    else if ( degree < 4)
    {
      degree = 4;
      // 6 January 2006 Dale Lear
      //     Every time you find a closed curve that
      //     gets the wrong dir, increase the number
      //     after the < by one until it works.  Add
      //     the curve to RR and list the RR number here.
      while ( span_count*degree < 16 )
        degree *= 2;
    }

    span_vector = ws.GetDoubleMemory(span_count+1+degree);
    t = span_vector+(span_count+1);
    t[0] = 0.0;
    for ( j = 1; j < degree; j++ ) {
      t[j] = ((double)(j))/(degree);
    }
    if ( !curve->GetSpanVector( span_vector ) )
      return false;

    p1 = xform ? (*xform)*start_point : start_point;
    for ( span_i = 0; span_i < span_count; span_i++ ) {
      span_domain.Set( span_vector[span_i], span_vector[span_i+1] );
      if ( span_domain[1] <= curve_domain[0] )
        continue;
      if ( span_domain[0] >= curve_domain[1] )
        break;
      if ( span_domain[1] > curve_domain[1] )
        span_domain.m_t[1] = curve_domain[1];
      if ( span_domain[0] < curve_domain[0] )
        span_domain.m_t[0] = curve_domain[0];
      if ( span_domain[0] >= span_domain[1] )
        continue;
      for ( j = 0; j < degree; j++ ) {
        p0 = p1;
        p1 = curve->PointAt(span_domain.ParameterAt(t[j]));
        if ( xform )
          p1 = (*xform)*p1;
        twice_area += (p0.x-p1.x)*(p0.y+p1.y);
        if ( !span_i && !j ) {
          // check gap
        }
      }
    }
    p0 = p1;
    p1 = curve->PointAt(curve_domain[1]);
    twice_area += (p0.x-p1.x)*(p0.y+p1.y);
    start_point = p1;
    *area = 0.5*twice_area;
  }  
  
  return true;
}

int ON_ClosedCurveOrientation( const ON_Curve& curve, const ON_Xform* xform )
{
  int curve_orientation = 0;
  double area = 0.0;
  ON_3dPoint start_point = curve.PointAtEnd();
  const ON_Interval curve_domain = curve.Domain();
  if ( xform && xform->IsIdentity() )
    xform = 0;
  if (curve_area( start_point, &curve, curve_domain, xform, &area ))
  {
    double noise = 0.0;
    if ( area > noise )
      curve_orientation = 1;
    else if (area < noise )
      curve_orientation = -1;
  }
  return curve_orientation;
}

static int loop_type_compar(const ON_BrepLoop *const* ppLoopA, const ON_BrepLoop *const* ppLoopB )
{
  const ON_BrepLoop* loopA = *ppLoopA;
  const ON_BrepLoop* loopB = *ppLoopB;
  if ( loopA->m_type == loopB->m_type )
    return 0;
  if ( loopA->m_type == ON_BrepLoop::unknown )
    return 1;
  if ( loopB->m_type == ON_BrepLoop::unknown )
    return -1;
  if ( loopA->m_type < loopB->m_type )
    return -1;
  if ( loopA->m_type > loopB->m_type )
    return 1;
  return 0;
}

bool ON_Brep::SortFaceLoops( ON_BrepFace& face ) const
{
  int fli, li, loop_type;
  const int face_loop_count = face.m_li.Count();
  const int loop_count = m_L.Count();
  if ( face_loop_count < 1 || loop_count < 1 )
    return false;
  bool rc = true;
  ON_SimpleArray<const ON_BrepLoop*> loop_ptr(face_loop_count);
  for ( fli = 0; fli < face_loop_count; fli++ )
  {
    li = face.m_li[fli];
    if ( li < 0 || li >= loop_count )
      return false;
    const ON_BrepLoop& loop = m_L[li];
    if ( loop.m_loop_index != li )
      return false;
    loop_type = loop.m_type;
    if ( loop_type <= ON_BrepLoop::unknown || loop_type >= ON_BrepLoop::type_count )
      rc = false;
    loop_ptr.Append( &m_L[li] );
  }
  loop_ptr.QuickSort( loop_type_compar );
  for ( fli = 0; fli < face_loop_count; fli++ )
  {
    face.m_li[fli] = loop_ptr[fli]->m_loop_index;
  }
  return rc;
}


int 
ON_Brep::LoopDirection( const ON_BrepLoop& loop ) const
{
  ON_3dPoint start_point;
  double d, a = 0.0;
  int ti, lti, c2i;
  const int brep_trim_count = m_T.Count();
  const int brep_C2_count = m_C2.Count();
  const int loop_trim_count = loop.m_ti.Count();

  double noise = 0.0;

  // reverse direction of individual trimming curves
  for ( lti = 0; lti < loop_trim_count; lti++ ) {
    ti = loop.m_ti[lti];
    if ( ti < 0 || ti >= brep_trim_count ) {
      a = 0.0;
      break;
    }
    c2i =  m_T[ti].m_c2i;
    if ( c2i < 0 || c2i >= brep_C2_count ) {
      a = 0.0;
      break;
    }
    if ( lti == 0 ) 
    {
      // evaluate start of first trim
      if ( m_C2[c2i] )
        start_point = m_T[ti].PointAtStart(); //m_C2[c2i]->PointAt(m_T[ti].m_t[0]);
    }
    if ( !curve_area( start_point, &m_T[ti], m_T[ti].Domain(), 0, &d ) ) {
      a = 0.0;
      break;
    }
    //noise += fabs(d);
    a += d;
  }

  //this fixes trr 9351.  Change at your own risk.
  //noise *= 10.0*ON_EPSILON;

  if (a > noise)
    return 1;
  else if (a < -noise)
    return -1;
  return 0;
}

bool ON_Brep::SetVertexTolerances( ON_BOOL32 bLazy )
{
  bool rc = true;
  int vi, vertex_count = m_V.Count();
  for ( vi = 0; vi < vertex_count; vi++ )
  {
    if ( !SetVertexTolerance( m_V[vi], bLazy ) )
      rc = false;
  }
  return rc;
}

bool
ON_Brep::SetVertexTolerance( ON_BrepVertex& vertex,
  ON_BOOL32 bLazySet // default = false
                // false: recompute tolerance even if
                //        its current value is positive
                // true:  recompute tolerance only if
                //        its current value is nonpositive
  ) const
{
  if ( vertex.m_tolerance < 0.0 || !bLazySet ) {
    const int vertex_edge_count = vertex.EdgeCount();
    if ( vertex_edge_count < 1 ) {
      vertex.m_tolerance = 0.0;
    }
    else {
      vertex.m_tolerance = ON_UNSET_VALUE;
      double tolerance = 0.0;
      double d;
      ON_3dPoint uv;
      ON_Interval edge_domain;
      //const ON_Curve* c=0;
      const ON_Surface* s=0;
      int vei, ei, eti, endi;
      const int vertex_index = vertex.m_vertex_index;
      for ( vei = 0; vei < vertex_edge_count; vei++ ) 
      {
        ei = vertex.m_ei[vei];
        if ( ei < 0 )
          return false;
        const ON_BrepEdge& edge = m_E[ei];
        if ( !edge.ProxyCurve() )
          return false;
        edge_domain = edge.Domain();
        for ( endi = 0; endi < 2; endi++ )
        {
          if ( edge.m_vi[endi] == vertex_index ) 
          {
            d = vertex.point.DistanceTo( edge.PointAt(edge_domain[endi]) );
            if ( tolerance < d )
              tolerance = d;
          }
        }
        const int edge_trim_count = edge.m_ti.Count();
        for ( eti = 0; eti < edge_trim_count; eti++ ) 
        {
          const ON_BrepTrim* trim = Trim(edge.m_ti[eti]);
          if ( 0 == trim )
            continue;
          if ( 0 == trim->TrimCurveOf() )
            continue;
          s = trim->SurfaceOf();
          if ( 0 == s )
            continue;
          for ( endi = 0; endi < 2; endi++ ) {
            if ( edge.m_vi[endi] == vertex_index ) {
              uv = trim->PointAt( trim->Domain()[trim->m_bRev3d?1-endi:endi] );
              d = vertex.point.DistanceTo( s->PointAt(uv.x,uv.y) );
              if ( tolerance < d )
                tolerance = d;
            }
          }
        }
      }
      vertex.m_tolerance = (tolerance <= ON_ZERO_TOLERANCE) ? 0.0 : 1.001*tolerance;
    }
  }
  return (vertex.m_tolerance >= 0.0) ? true : false;
}

bool
ON_Brep::SetTrimTolerance( ON_BrepTrim& trim, ON_BOOL32 bLazy ) const
{
  // The TL_Brep::SetTrimTolerance override of this virtual function
  // sets ON_BrepTrim::m_tolerance[] correctly.
  double ds, de, d;
  int dir, lti, prev_ti, next_ti;
  if ( trim.m_tolerance[0] < 0.0 || trim.m_tolerance[1] < 0.0 || !bLazy )
  {
    // set trim tolerance
    if ( trim.m_li >= 0 && trim.m_li < m_L.Count() )
    {
      const ON_BrepLoop& loop = m_L[trim.m_li];
      const int loop_trim_count = loop.m_ti.Count();
      for ( lti = 0; lti < loop_trim_count; lti++ )
      {
        if ( loop.m_ti[lti] == trim.m_trim_index )
        {
          prev_ti = loop.m_ti[(lti-1+loop_trim_count)%loop_trim_count];
          next_ti = loop.m_ti[(lti+1)%loop_trim_count];
          if ( prev_ti >= 0 && next_ti >= 0 && prev_ti < m_T.Count() && next_ti < m_T.Count() )
          {
            const ON_BrepTrim& prev_trim = m_T[prev_ti];
            const ON_BrepTrim& next_trim = m_T[next_ti];
            const ON_Curve* prev_c2 = prev_trim.TrimCurveOf();
            const ON_Curve* next_c2 = next_trim.TrimCurveOf();
            const ON_Curve* c2 = trim.TrimCurveOf();
            if ( prev_c2 && c2 && next_c2 )
            {
              ON_3dPoint prev_end = prev_trim.PointAtEnd(); //prev_c2->PointAt( prev_trim.m_t[1] );
              ON_3dPoint this_start = trim.PointAtStart(); //c2->PointAt( trim.m_t[0] );
              ON_3dPoint this_end = trim.PointAtEnd(); // c2->PointAt( trim.m_t[1] );
              ON_3dPoint next_start = next_trim.PointAtStart(); //prev_c2->PointAt( next_trim.m_t[0] );
              for ( dir = 0; dir < 2; dir++ )
              {
                if ( trim.m_tolerance[dir] < 0.0 || !bLazy )
                {
                  ds = fabs(prev_end[dir] - this_start[dir] );
                  de = fabs(this_end[dir] - next_start[dir] );
                  d = (ds >= de) ? ds : de;
                  trim.m_tolerance[dir] = ( d > ON_ZERO_TOLERANCE ) ? 1.001*d : 0.0;
                }
              }
            }
          }
          break;
        }
      }
    }
  }
  return (trim.m_tolerance[0] >= 0.0 && trim.m_tolerance[1] >= 0.0) ? true : false;
}

bool
ON_Brep::SetEdgeTolerance( ON_BrepEdge& edge, ON_BOOL32 bLazySet ) const
{
  if ( edge.m_tolerance < 0.0 || !bLazySet ) 
  {
    const int edge_trim_count = edge.m_ti.Count();
    if ( edge_trim_count < 1 ) 
    {
      edge.m_tolerance = 0.0;
    }
    else 
    {
      edge.m_tolerance = ON_UNSET_VALUE;
      // TL_Brep::SetEdgeTolerance overrides ON_Brep::SetEdgeTolerance
      // and sets teh tolerance correctly.
    }
  }
  return (edge.m_tolerance >= 0.0) ? true : false;
}

bool ON_Brep::SetTrimTolerances( ON_BOOL32 bLazy )
{
  bool rc = true;
  int ti, trim_count = m_T.Count();
  for ( ti = 0; ti < trim_count; ti++ )
  {
    if ( !SetTrimTolerance( m_T[ti], bLazy ) )
      rc = false;
  }
  return rc;
}

bool ON_Brep::SetEdgeTolerances( ON_BOOL32 bLazy )
{
  bool rc = true;
  int ei, edge_count = m_E.Count();
  for ( ei = 0; ei < edge_count; ei++ )
  {
    if ( !SetEdgeTolerance( m_E[ei], bLazy ) )
      rc = false;
  }
  return rc;
}


void ON_Brep::Dump( ON_TextLog& dump ) const
{
  dump.Print("ON_Brep:\n");

  if ( IsSurface() ) {
    dump.Print("(B-rep geometry is the same as underlying surface.)\n");
  }

  dump.Print("surfaces:  %d\n",m_S.Count());
  dump.Print("3d curve:  %d\n",m_C3.Count());
  dump.Print("2d curves: %d\n",m_C2.Count());
  dump.Print("vertices:  %d\n",m_V.Count());
  dump.Print("edges:     %d\n",m_E.Count());
  dump.Print("trims:     %d\n",m_T.Count());
  dump.Print("loops:     %d\n",m_L.Count());
  dump.Print("faces:     %d\n",m_F.Count());

  int c2i;
  for ( c2i = 0; c2i < m_C2.Count(); c2i++ )
  {
    const ON_Curve* c2 = m_C2[c2i];
    if ( c2 )
    {
      ON_Interval cdom = c2->Domain();
      ON_3dPoint c_start, c_end;
      c_start = c2->PointAtStart();
      c_end = c2->PointAtEnd();
      const char* s = c2->ClassId()->ClassName();
      if ( !s )
        s = "";
      dump.Print("curve2d[%2d]: %s domain(%g,%g) start(%g,%g) end(%g,%g)\n",
                  c2i, s, cdom[0], cdom[1],
                  c_start.x, c_start.y,
                  c_end.x, c_end.y);
    }
    else
    {
      dump.Print("curve2d[%2d]: NULL\n",c2i);
    }
  }

  int c3i;
  for ( c3i = 0; c3i < m_C3.Count(); c3i++ )
  {
    const ON_Curve* c3 = m_C3[c3i];
    if ( c3 )
    {
      ON_Interval cdom = c3->Domain();
      ON_3dPoint c_start, c_end;
      c_start = c3->PointAtStart();
      c_end = c3->PointAtEnd();
      const char* s = c3->ClassId()->ClassName();
      if ( !s )
        s = "";
      dump.Print("curve3d[%2d]: %s domain(%g,%g) start(%g,%g,%g) end(%g,%g,%g)\n",
                 c3i, s, cdom[0], cdom[1],
                 c_start.x, c_start.y, c_start.z,
                 c_end.x, c_end.y, c_end.z);
    }
    else
    {
      dump.Print("curve2d[%2d]: NULL\n",c3i);
    }
  }

  int si;
  for ( si = 0; si < m_S.Count(); si++ )
  {
    const ON_Surface* srf = m_S[si];
    if ( srf )
    {
      ON_Interval udom = srf->Domain(0);
      ON_Interval vdom = srf->Domain(1);
      const char* s = srf->ClassId()->ClassName();
      if ( !s )
        s = "";
      dump.Print("surface[%2d]: %s u(%g,%g) v(%g,%g)\n",
                 si, s, 
                 udom[0], udom[1], 
                 vdom[0], vdom[1]
                 );
      if ( m_S.Count() == 1 && IsSurface() )
      {
        dump.PushIndent();
        dump.Print("surface details:\n");
        dump.PushIndent();
        srf->Dump(dump);
        dump.PopIndent();
        dump.PopIndent();
      }
    }
    else
    {
      dump.Print("surface[%2d]: NULL\n",si);
    }
  }

  int vi;
  for ( vi = 0; vi < m_V.Count(); vi++ ) {
    const ON_BrepVertex& vertex = m_V[vi];
    dump.Print("vertex[%2d]: (%f %f %f) tolerance(%g)\n",
               vi,vertex.point.x,vertex.point.y,vertex.point.z,
               vertex.m_tolerance);
    if ( vertex.m_ei.Count() > 0 ) {
      int vei;
      dump.PushIndent();
      dump.Print("edges (");
      for ( vei = 0; vei < vertex.m_ei.Count(); vei++ ) {
        dump.Print( (vei)?",%d":"%d", vertex.m_ei[vei] );
      }
      dump.PopIndent();
      dump.Print(")\n");
    }
  }

  int ei,ti;
  for ( ei = 0; ei < m_E.Count(); ei++ ) {
    const ON_BrepEdge& edge = m_E[ei];
    dump.Print("edge[%2d]: v0(%2d) v1(%2d) 3d_curve(%d) tolerance(%g)\n",
               ei,edge.m_vi[0],edge.m_vi[1],edge.m_c3i,edge.m_tolerance);

    dump.PushIndent();

    const ON_Curve* c3 = edge.EdgeCurveOf();
    if ( c3 )
    {
      ON_3dPoint edge_start = edge.PointAtStart();
      ON_3dPoint edge_end = edge.PointAtEnd();
      dump.Print("domain(%g,%g) start(%g,%g,%g) end(%g,%g,%g)\n",
           edge.Domain()[0],edge.Domain()[1],
           edge_start.x,edge_start.y,edge_start.z,
           edge_end.x,edge_end.y,edge_end.z
           );
    }
    else
    {
      dump.Print("domain(%g,%g) start(?,?,?) end(?,?,?)\n",
           edge.Domain()[0],edge.Domain()[1]);
    }

    if ( edge.m_ti.Count() > 0 ) 
    {

      dump.Print("trims (",edge.m_ti.Count());
      int eti;
      for ( eti = 0; eti < edge.m_ti.Count(); eti++ )
      {
        ti = edge.m_ti[eti];
        const char* sign = "?";
        if ( ti >= 0 && ti < m_T.Count() ) {
          sign = m_T[ti].m_bRev3d ? "-" : "+";
        }
        dump.Print( (eti)?",%s%d":"%s%d", sign,edge.m_ti[eti]);
      }

      dump.Print(")\n");
    }

    dump.PopIndent();
  }

  int fi;
  for ( fi = 0; fi < m_F.Count(); fi++ ) {
    const ON_BrepFace& face = m_F[fi];
    const ON_Surface* face_srf = face.SurfaceOf();
    dump.Print("face[%2d]: surface(%d) reverse(%d) loops(",
               fi,face.m_si,face.m_bRev);
    int fli;
    for ( fli = 0; fli < face.m_li.Count(); fli++ ) {
      dump.Print( (fli)?",%d":"%d", face.m_li[fli]);
    }
    dump.Print(")\n");
    dump.PushIndent();
    if ( face.m_render_mesh ) 
    {
      const char* mp_style = "Custom";
      const ON_MeshParameters* mp = face.m_render_mesh->MeshParameters();
      if ( mp )
      {
        if ( 0 == mp->CompareGeometrySettings(ON_MeshParameters::FastRenderMesh) )
          mp_style = "Fast";
        else if ( 0 == mp->CompareGeometrySettings(ON_MeshParameters::QualityRenderMesh) )
          mp_style = "Quality";
      }
      dump.Print("%s render mesh: %d polygons\n",mp_style,face.m_render_mesh->FaceCount());
    }
    if ( face.m_analysis_mesh ) {
      dump.Print("Analysis mesh: %d polygons\n",face.m_analysis_mesh->FaceCount());
    }
    if ( FaceIsSurface(fi) ) {
      dump.Print("(Face geometry is the same as underlying surface.)\n");
    }


    for ( fli = 0; fli < face.m_li.Count(); fli++ ) 
    {
      const int li = face.m_li[fli];
      const ON_BrepLoop& loop = m_L[li];
      const char* sLoopType = 0;
      switch( loop.m_type ) 
      {
      case ON_BrepLoop::unknown:
        sLoopType = "unknown";
        break;
      case ON_BrepLoop::outer:
        sLoopType = "outer";
        break;
      case ON_BrepLoop::inner:
        sLoopType = "inner";
        break;
      case ON_BrepLoop::slit:
        sLoopType = "slit";
        break;
      case ON_BrepLoop::crvonsrf:
        sLoopType = "crvonsrf";
        break;
      default:
        sLoopType = "unknown";
        break;
      }
      dump.Print("loop[%2d]: type(%s) %d trims(",
                 li, sLoopType, loop.m_ti.Count());
      int lti;
      for ( lti = 0; lti < loop.m_ti.Count(); lti++ ) 
      {
        dump.Print( (lti)?",%d":"%d", loop.m_ti[lti]);
      }
      dump.Print(")\n");
      dump.PushIndent();
      for ( lti = 0; lti < loop.m_ti.Count(); lti++ ) 
      {
        const int ti = loop.m_ti[lti];
        const ON_BrepTrim& trim = m_T[ti];
        const char* sTrimType = "?";
        const char* sTrimIso = "-?";
        const ON_Curve* c2 = trim.TrimCurveOf();
        ON_3dPoint trim_start, trim_end;
        switch( trim.m_type ) {
        case ON_BrepTrim::unknown:
          sTrimType = "unknown ";
          break;
        case ON_BrepTrim::boundary:
          sTrimType = "boundary";
          break;
        case ON_BrepTrim::mated:
          sTrimType = "mated   ";
          break;
        case ON_BrepTrim::seam:
          sTrimType = "seam    ";
          break;
        case ON_BrepTrim::singular:
          sTrimType = "singular";
          break;
        case ON_BrepTrim::crvonsrf:
          sTrimType = "crvonsrf";
          break;
        default:
          sTrimType = "unknown";
          break;
        }
        switch( trim.m_iso ) {
        case ON_Surface::not_iso:
          sTrimIso = "";
          break;
        case ON_Surface::x_iso:
          sTrimIso = "-u iso";
          break;
        case ON_Surface::W_iso:
          sTrimIso = "-west side iso";
          break;
        case ON_Surface::E_iso:
          sTrimIso = "-east side iso";
          break;
        case ON_Surface::y_iso:
          sTrimIso = "-v iso";
          break;
        case ON_Surface::S_iso:
          sTrimIso = "-south side iso";
          break;
        case ON_Surface::N_iso:
          sTrimIso = "-north side iso";
          break;
        default:
          sTrimIso = "-unknown_iso_flag";
          break;
        }
        dump.Print("trim[%2d]: edge(%2d) v0(%2d) v1(%2d) tolerance(%g,%g)\n",
                   ti,
                   trim.m_ei,trim.m_vi[0],trim.m_vi[1],
                   trim.m_tolerance[0],trim.m_tolerance[1]);
        dump.PushIndent();
        dump.Print("type(%s%s) rev3d(%d) 2d_curve(%d)\n",
                   sTrimType, sTrimIso, trim.m_bRev3d, trim.m_c2i);
        if ( c2 )
        {
          trim_start = trim.PointAtStart();
          trim_end = trim.PointAtEnd();
          dump.Print("domain(%g,%g) start(%g,%g) end(%g,%g)\n",
               trim.Domain()[0],trim.Domain()[1],
               trim_start.x,trim_start.y,
               trim_end.x,trim_end.y);
          if ( 0 != face_srf )
          {
            ON_3dPoint trim_srfstart = face_srf->PointAt(trim_start.x,trim_start.y);
            ON_3dPoint trim_srfend = face_srf->PointAt(trim_end.x,trim_end.y);
            dump.Print("surface points start(%g,%g,%g) end(%g,%g,%g)\n",
                 trim_srfstart.x,trim_srfstart.y,trim_srfstart.z,
                 trim_srfend.x,trim_srfend.y,trim_srfend.z);
          }
        }
        else
        {
          dump.Print("domain(%g,%g) start(?,?) end(?,?)\n",
               trim.Domain()[0],trim.Domain()[1]);
        }
        dump.PopIndent();
      }
      dump.PopIndent();
    }
    dump.PopIndent();
  }

  //int si;
  //for ( si = 0; si < m_S.Count(); si++ ) {
  //  dump.Print("surface[%d]:\n",si);
  //  dump.PushIndent();
  //  if ( m_S[si] )
  //    m_S[si]->Dump(dump);
  //  else
  //    dump.Print("NULL\n");
  //  dump.PopIndent();
  //}

}



//int ON_Brep::FaceIndexOf( const ON_BrepTrim& trim ) const
//{
//  int fi = -1;
//  if ( trim.m_li >= 0 && trim.m_li < m_L.Count() )
//  {
//    fi = m_L[trim.m_li].m_fi;
//    if ( fi < 0 || fi >= m_F.Count() )
//      fi = -1;
//  }
//  return fi;
//}

//int ON_Brep::FaceIndexOf( const ON_BrepLoop& loop ) const
//{
//  int fi = -1;
//  if ( loop.m_fi >= 0 && loop.m_fi < m_F.Count() )
//    fi = loop.m_fi;
//  return fi;
//}

//const ON_BrepFace* ON_Brep::FaceOf( const ON_BrepTrim& trim ) const
//{
//  // OBSOLETE
//  return trim.Face();
//}

//const ON_BrepFace* ON_Brep::FaceOf( const ON_BrepLoop& loop ) const
//{
//  // OBSOLETE
//  return loop.Face();
//}


//int ON_Brep::SurfaceIndexOf( const ON_BrepTrim& trim ) const
//{
//  // OBSOLETE
//  return trim.SurfaceIndexOf();
//}

//int ON_Brep::SurfaceIndexOf( const ON_BrepLoop& loop ) const
//{
//  // OBSOLETE
//  return loop.SurfaceIndexOf();
//}

//int ON_Brep::SurfaceIndexOf( const ON_BrepFace& face ) const
//{
//  // OBSOLETE FUNCTION
//  return face.m_si;
//}

//ON_Surface* ON_Brep::SurfaceOf( const ON_BrepTrim& trim ) const
//{
//  // OBSOLETE FUNCTION
//  const int si = trim.SurfaceIndexOf();
//  return (si>=0)?m_S[si]:0;
//}

//ON_Surface* ON_Brep::SurfaceOf( const ON_BrepLoop& loop ) const
//{
//  // OBSOLETE FUNCTION
//  return const_cast<ON_Surface*>(loop.SurfaceOf());
//}

//ON_Surface* ON_Brep::SurfaceOf( const ON_BrepFace& face ) const
//{
//  // OBSOLETE FUNCTION
//  return const_cast<ON_Surface*>(face.SurfaceOf());
//}

//int ON_Brep::EdgeCurveIndexOf( const ON_BrepTrim& trim ) const
//{
//  // OBSOLETE FUNCTION
//  return trim.EdgeCurveIndexOf();
//}

//int ON_Brep::EdgeCurveIndexOf( const ON_BrepEdge& edge ) const
//{
//  // OBSOLETE FUNCTION
//  return edge.m_c3i;
//}

//ON_Curve* ON_Brep::EdgeCurveOf( const ON_BrepTrim& trim ) const
//{
//  // OBSOLETE FUNCTION
//  return const_cast<ON_Curve*>(trim.EdgeCurveOf());
//}

//ON_Curve* ON_Brep::EdgeCurveOf( const ON_BrepEdge& edge ) const
//{
//  return ((edge.m_c3i>=0&&edge.m_c3i<m_C3.Count())?m_C3[edge.m_c3i]:0);
//}

//int ON_Brep::TrimCurveIndexOf( const ON_BrepTrim& trim ) const
//{
//  return trim.m_c2i;
//}

//ON_Curve* ON_Brep::TrimCurveOf( const ON_BrepTrim& trim ) const
//{
//  return ((trim.m_c2i>=0&&trim.m_c2i<m_C2.Count())?m_C2[trim.m_c2i]:0);
//}

void ON_Brep::DeleteVertex(ON_BrepVertex& vertex)
{
  const int vi = vertex.m_vertex_index;
  vertex.m_vertex_index = -1;
  if ( vi >= 0 && vi < m_V.Count() ) {
    int vei, ei;
    for ( vei = vertex.m_ei.Count()-1; vei>=0; vei-- ) {
      ei = vertex.m_ei[vei];
      if ( ei >= 0 && ei < m_E.Count() ) {
        ON_BrepEdge& edge = m_E[ei];
        if ( edge.m_vi[0] == vi )
          edge.m_vi[0] = -1;
        if ( edge.m_vi[1] == vi )
          edge.m_vi[1] = -1;
        DeleteEdge( edge, false );
      }
    }
  }
  vertex.m_ei.Empty();
  vertex.m_tolerance = ON_UNSET_VALUE;
}

int ON_Brep::Loop3dCurve( 
  const ON_BrepLoop& loop,
  ON_SimpleArray<ON_Curve*>& curve_list,
  ON_BOOL32 bRevCurveIfFaceRevIsTrue
  ) const
{
  int curve_list_count0 = curve_list.Count();
  ON_PolyCurve* poly_curve = NULL;
  ON_Curve* loop_curve = NULL;
  ON_SimpleArray<int> trim_index( 2*loop.m_ti.Count() + 8);
  int i, lti, ti;
  int loop_trim_count = loop.m_ti.Count();
  if ( loop_trim_count < 1 )
    return 0;


  int seam_lti = -1; // index of first seam
  int wire_lti = -1;
  for ( lti = 0; lti < loop_trim_count; lti++ )
  {
    ti = loop.m_ti[lti];
    if ( ti >= 0 && ti < m_T.Count() )
    {
      const ON_BrepTrim& trim = m_T[ti];
      if ( seam_lti < 0 && trim.m_type == ON_BrepTrim::seam )
        seam_lti = lti;
      else if ( wire_lti < 0 && trim.m_type != ON_BrepTrim::singular )
        wire_lti = lti;
    }
  }

  if ( wire_lti < 0 )
    return 0; // sphere boundary, torus boundary, etc.

  if ( seam_lti < 0 )
  {
    // simple case;
    loop_curve = Loop3dCurve(loop,bRevCurveIfFaceRevIsTrue);
    if ( loop_curve )
      curve_list.Append(loop_curve);
    return curve_list.Count() - curve_list_count0;
  }

  bool bOnSeam = true;
  for ( lti = seam_lti; lti < seam_lti+loop_trim_count; lti++ )
  {
    ti = loop.m_ti[lti%loop_trim_count];

    if ( ti < 0 || ti >= m_T.Count() )
      ti = loop.m_ti[seam_lti]; // treat bogus indices as trims

    const ON_BrepTrim& trim = m_T[ti];
    if ( trim.m_type == ON_BrepTrim::seam )
    {
      if (!bOnSeam)
      {
        trim_index.Append(-1);
        bOnSeam = true;
      }
      continue;
    }
    // 10-1-03 Lowell - fixed typo
    if ( trim.m_type == ON_BrepTrim::singular )
      continue;
    bOnSeam = false;
    trim_index.Append(ti);
  }

  for ( i = 0; i < trim_index.Count(); i++ )
  {
    ti = trim_index[i];
    if ( ti < 0 )
    {
      if ( loop_curve )
        curve_list.Append(loop_curve);
      loop_curve = 0;
      poly_curve = 0;
      continue;
    }

    // get 3d curve associated with this trim's edge
    const ON_BrepTrim& trim = m_T[ti];
    const ON_BrepEdge& edge = m_E[trim.m_ei];
    ON_Curve* segment_curve = edge.DuplicateCurve();
    if ( !segment_curve )
      continue;
    if ( trim.m_bRev3d )
      segment_curve->Reverse();

    if ( !loop_curve )
      loop_curve = segment_curve;
    else if ( !poly_curve )
    {
      poly_curve = new ON_PolyCurve();
      poly_curve->Append(loop_curve);
      poly_curve->Append(segment_curve);
      loop_curve = poly_curve;
    }
    else
      poly_curve->Append( segment_curve );
  }

  // 10-1-03 Lowell - add the last non-seam segment
  if ( loop_curve )
    curve_list.Append(loop_curve);

  if ( bRevCurveIfFaceRevIsTrue )
  {
    int fi = loop.m_fi;
    if ( fi >= 0 && fi < m_F.Count() && m_F[fi].m_bRev )
    {
      for ( i = curve_list_count0; i < curve_list.Count(); i++ )
        curve_list[i]->Reverse();
    }
  }

  return curve_list.Count() - curve_list_count0;
}


ON_Curve* ON_Brep::Loop3dCurve( const ON_BrepLoop& loop, ON_BOOL32 bRevCurveIfFaceRevIsTrue ) const
{
  ON_PolyCurve* poly_curve = NULL;
  ON_Curve* loop_curve = NULL;
  ON_SimpleArray<int> trim_index( loop.m_ti.Count() );
  int i, lti, ti;
  for ( lti = 0; lti < loop.m_ti.Count(); lti++ )
  {
    ti = loop.m_ti[lti];
    if ( ti >= 0 && ti < m_T.Count() )
    {
      const ON_BrepTrim& trim = m_T[ti];
      if ( trim.EdgeCurveOf() )
        trim_index.Append(ti);
    }
  }

  for ( i = 0; i < trim_index.Count(); i++ )
  {
    // get 3d curve associated with this trim's edge
    const ON_BrepTrim& trim = m_T[trim_index[i]];
    const ON_BrepEdge& edge = m_E[trim.m_ei];
    ON_Curve* segment_curve = edge.DuplicateCurve();
    if ( !segment_curve )
      continue;
    if ( trim.m_bRev3d )
      segment_curve->Reverse();

    if ( !loop_curve )
      loop_curve = segment_curve;
    else if ( !poly_curve )
    {
      poly_curve = new ON_PolyCurve();
      poly_curve->Append(loop_curve);
      poly_curve->Append(segment_curve);
      loop_curve = poly_curve;
    }
    else
      poly_curve->Append( segment_curve );
  }
  if ( loop_curve && bRevCurveIfFaceRevIsTrue )
  {
    int fi = loop.m_fi;
    if ( fi >= 0 && fi < m_F.Count() && m_F[fi].m_bRev )
    {
      loop_curve->Reverse();
    }
  }
  return loop_curve;
}

ON_Curve* ON_Brep::Loop2dCurve( const ON_BrepLoop& loop ) const
{
  ON_PolyCurve* poly_curve = NULL;
  ON_Curve* loop_curve = NULL;
  ON_SimpleArray<int> trim_index( loop.m_ti.Count() );
  int i, lti, ti;
  for ( lti = 0; lti < loop.m_ti.Count(); lti++ )
  {
    ti = loop.m_ti[lti];
    if ( ti >= 0 && ti < m_T.Count() )
    {
      const ON_BrepTrim& trim = m_T[ti];
      if ( trim.TrimCurveOf() )
        trim_index.Append(ti);
    }
  }
  for ( i = 0; i < trim_index.Count(); i++ )
  {
    // get 2d curve associated with this trim's edge
    const ON_BrepTrim& trim = m_T[trim_index[i]];
    ON_Curve* segment_curve = trim.DuplicateCurve();
    if ( !segment_curve )
      continue;

    if ( !loop_curve )
      loop_curve = segment_curve;
    else if ( !poly_curve )
    {
      poly_curve = new ON_PolyCurve();
      poly_curve->Append(loop_curve);
      poly_curve->Append(segment_curve);
      loop_curve = poly_curve;
    }
    else
      poly_curve->Append( segment_curve );
  }
  return loop_curve;
}



void ON_Brep::DeleteEdge(ON_BrepEdge& edge, ON_BOOL32 bDeleteEdgeVertices )
{
  const int ei = edge.m_edge_index;
  edge.m_edge_index = -1;

  if ( ei >= 0 && ei < m_E.Count() ) {
    int eti, ti, evi, vei, vi;
    for ( eti = edge.m_ti.Count()-1; eti >= 0; eti-- ) {
      ti = edge.m_ti[eti];
      if ( ti >= 0 && ti < m_T.Count() ) {
        ON_BrepTrim& trim = m_T[ti];
        trim.m_ei = -1;
        if ( trim.m_li >= 0 && trim.m_li < m_L.Count() ) {
          ON_BrepLoop& loop = m_L[trim.m_li];
          if ( loop.m_fi >= 0 && loop.m_fi < m_F.Count() ) {
            DeleteFace( m_F[loop.m_fi], bDeleteEdgeVertices );
          }
        }
        DeleteTrim(trim,false);
      }
    }

    for (evi = 0; evi < 2; evi++ ) 
    {
      vi = edge.m_vi[evi];
      if ( vi >= 0 && vi < m_V.Count() ) 
      {
        ON_BrepVertex& v = m_V[vi];
        for ( vei = v.m_ei.Count()-1; vei >= 0; vei-- ) 
        {
          if ( v.m_ei[vei] == ei )
            v.m_ei.Remove(vei);
        }
        if ( bDeleteEdgeVertices && v.m_ei.Count() <= 0 )
        {
          v.m_ei.Destroy();
          DeleteVertex(v);
        }
      }
    }
  }

  edge.m_c3i = -1;
  edge.m_vi[0] = -1;
  edge.m_vi[1] = -1;
  edge.m_ti.Empty();
  edge.m_tolerance = ON_UNSET_VALUE;
  edge.m_brep = 0;
  edge.SetProxyCurve(0);
}

void ON_Brep::DeleteTrim(ON_BrepTrim& trim, ON_BOOL32 bDeleteTrimEdges )
{
  m_is_solid = 0;

  const int ti = trim.m_trim_index;
  trim.m_trim_index = -1;

  if ( ti >= 0 && ti < m_T.Count() ) 
  {
    const int ei = trim.m_ei;
    if ( ei >= 0 && ei < m_E.Count() ) 
    {
      ON_BrepEdge& edge = m_E[ei];
      if ( bDeleteTrimEdges && edge.m_ti.Count() == 1 && edge.m_ti[0] == ti ) 
      {
        edge.m_ti.Empty();
        DeleteEdge(edge,bDeleteTrimEdges);
      }
      else 
      {
        int mate_ti = (trim.m_type == ON_BrepTrim::mated) ? -1 : -2; // set to >= 0 if a single mate exists
        int seam_ti = (trim.m_type == ON_BrepTrim::seam) ? -1 : -2; // set to >= 0 if a single seam partner exists
        int eti;
        for ( eti = edge.m_ti.Count()-1; eti >= 0; eti-- ) 
        {
          int other_ti = edge.m_ti[eti];
          if ( other_ti == ti ) 
          {
            edge.m_ti.Remove(eti);
            if ( edge.m_ti.Count() == 0 )
              edge.m_tolerance = 0.0;
            continue;
          }
          
          if ( (mate_ti >= -1 || seam_ti >= -1 ) && other_ti >= 0 && other_ti < m_T.Count() )
          {
            const ON_BrepTrim& other_trim = m_T[other_ti];
            if ( other_trim.m_trim_index != other_ti )
              continue;
            if ( mate_ti >= -1 && other_trim.m_type == ON_BrepTrim::mated )
            {
              // see if other_trim is the only mate of trim
              if ( mate_ti == -1 )
                mate_ti = other_ti;
              else
                mate_ti = -2;
            }
            else if ( seam_ti >= -1 && other_trim.m_type == ON_BrepTrim::seam && other_trim.m_li == trim.m_li )
            {
              // trim and other_trim are both seam trims in the same loop connected
              // to the same edge.
              if ( seam_ti == -1 )
                seam_ti = other_ti;
              else
                seam_ti = -2;
            }
          }
        }

        if ( seam_ti >= 0  )
        {
          // m_T[seam_ti] used to be a seam partner with trim.
          // Now it is either a boundary trim or is mated to m_T[mate_ti]
          m_T[seam_ti].m_type = (mate_ti>=0) 
                              ? ON_BrepTrim::mated     // m_T[mate_ti] is mated to m_T[seam_ti]
                              : ON_BrepTrim::boundary; // m_T[seam_ti] is all alone
        }
        else if ( mate_ti >= 0 )
        {
          // m_T[mate_ti] just lost its only mate and is now a boundary
          m_T[mate_ti].m_type = ON_BrepTrim::boundary;
        }
      }
    }

    const int li = trim.m_li;
    if ( li >= 0 && li < m_L.Count() ) {
      ON_BrepLoop& loop = m_L[li];
      int lti;
      for ( lti = loop.m_ti.Count()-1; lti >= 0; lti-- ) {
        if ( loop.m_ti[lti] == ti )
          loop.m_ti.Remove(lti);
      }
    }
  }

  trim.m_c2i = -1;
  trim.m_ei = -1;
  trim.m_vi[0] = -1;
  trim.m_vi[1] = -1;
  trim.m_bRev3d = 0;
  trim.m_type = ON_BrepTrim::unknown;
  trim.m_iso = ON_Surface::not_iso;
  trim.m_li = -1;
  trim.m_tolerance[0] = ON_UNSET_VALUE;
  trim.m_tolerance[1] = ON_UNSET_VALUE;
  trim.m__legacy_2d_tol = ON_UNSET_VALUE;
  trim.m__legacy_3d_tol = ON_UNSET_VALUE;
  trim.m__legacy_flags = 0;
  trim.m_pbox.Destroy();
  trim.m_brep = 0;
  trim.SetProxyCurve(0);
}

void ON_Brep::DeleteLoop(ON_BrepLoop& loop,  ON_BOOL32 bDeleteLoopEdges  )
{
  m_is_solid = 0;

  const int li = loop.m_loop_index;
  loop.m_loop_index = -1;

  if ( loop.m_fi >= 0 )
    DestroyMesh(ON::any_mesh,true);

  if ( li >= 0 && li < m_L.Count() ) 
  {
    const int tcount = m_T.Count();
    int lti, ti;
    for ( lti = loop.m_ti.Count()-1; lti >= 0; lti-- )
    {
      ti = loop.m_ti[lti];
      if ( ti >= 0 && ti < tcount )
      {
        ON_BrepTrim& trim = m_T[ti];
        trim.m_li = -1;
        DeleteTrim(trim,bDeleteLoopEdges);
      }
    }

    const int fi = loop.m_fi;
    if ( fi >= 0 && fi < m_F.Count() ) 
    {
      ON_BrepFace& face = m_F[fi];
      int fli;
      for ( fli = face.m_li.Count()-1; fli >= 0; fli-- )
      {
        if ( face.m_li[fli] == li ) 
        {
          face.m_li.Remove(fli);
        }
      }
    }
  }

  loop.m_type = ON_BrepLoop::unknown;
  loop.m_ti.Empty();
  loop.m_fi = -1;
  loop.m_pbox.Destroy();
  loop.m_brep = 0;
}

void ON_Brep::DeleteFace(ON_BrepFace& face, ON_BOOL32 bDeleteFaceEdges )
{
  m_bbox.Destroy();
  m_is_solid = 0;

  const int fi = face.m_face_index;
  face.m_face_index = -1;

  if ( fi >= 0 && fi < m_F.Count() ) {
    const int lcount = m_L.Count();
    int fli, li;
    for ( fli = face.m_li.Count()-1; fli >= 0; fli-- ) {
      li = face.m_li[fli];
      if ( li >= 0 && li < lcount ) {
        ON_BrepLoop& loop = m_L[li];
        loop.m_fi = -1;
        DeleteLoop(loop,bDeleteFaceEdges);
      }
    }
  }

  face.m_si = -1;
  face.m_li.Empty();
  face.SetProxySurface(0);
  face.m_brep = 0;
  face.m_bbox.Destroy();
}

static void PropagateLabel(ON_Brep& B, 
                           ON_SimpleArray<int>& fids,
                           int label
                           )
//on input, each face in fids must have m_face_user.i = label
{
  if (fids.Count() == 0) return;
  ON_SimpleArray<int> new_fids(B.m_F.Count());
  for (int face_i=0; face_i<fids.Count(); face_i++)
  {
    const ON_BrepFace& F = B.m_F[fids[face_i]];
    for (int loop_i=0; loop_i<F.m_li.Count(); loop_i++)
    {
      ON_BrepLoop& L = B.m_L[F.m_li[loop_i]];
      memset(&L.m_loop_user,0,sizeof(L.m_loop_user));
      L.m_loop_user.i = label;
      for (int edge_i=0; edge_i<L.m_ti.Count(); edge_i++)
      {
        ON_BrepTrim& T = B.m_T[L.m_ti[edge_i]];
        memset(&T.m_trim_user,0,sizeof(T.m_trim_user));
        T.m_trim_user.i = label;
        if (T.m_ei < 0) 
          continue;
        ON_BrepEdge& E = B.m_E[T.m_ei];
        memset(&E.m_edge_user,0,sizeof(E.m_edge_user));
        E.m_edge_user.i = label;
        for (int vertex_i=0; vertex_i<2; vertex_i++)
        {
          if (E.m_vi[vertex_i] >= 0) 
          {
            ON_BrepVertex& V = B.m_V[E.m_vi[vertex_i]];
            memset(&V.m_vertex_user,0,sizeof(V.m_vertex_user));
            V.m_vertex_user.i = label;
          }
        }

        for (int trim_i=0; trim_i<E.m_ti.Count(); trim_i++)
        {
          int fi = B.m_T[E.m_ti[trim_i]].FaceIndexOf();
          if (fi < 0 || B.m_F[fi].m_face_user.i == label) 
            continue;
          ON_BrepFace& F = B.m_F[fi];
          memset(&F.m_face_user,0,sizeof(F.m_face_user));
          F.m_face_user.i = label;
          new_fids.Append(fi);
        }
      }
    }
  }
  PropagateLabel(B, new_fids, label);
  return;
}


void ON_Brep::LabelConnectedComponent(int face_index, int label)

{
  if (face_index < 0 || face_index >= m_F.Count())
    return;

  ON_SimpleArray<int> fids(1);
  fids.Append(face_index);
  ON_BrepFace& F = m_F[face_index];
  memset(&F.m_face_user,0,sizeof(F.m_face_user));
  F.m_face_user.i = label;
  PropagateLabel(*this, fids, label);
  return;
}

int ON_Brep::LabelConnectedComponents()

{
  Clear_user_i();
  int i;
  for (i=0; i<m_F.Count(); i++){
    if (m_F[i].m_face_index < 0)
      m_F[i].m_face_user.i = -1;
  }

  int label = 0;
  bool keep_going = true;
  while (keep_going)
  {
    int face_index = -1;
    for (int j=0; j<m_F.Count(); j++)
    {
      if (m_F[j].m_face_user.i == 0)
      {
        face_index = j;
        break;
      }
    }
    if (face_index == -1)
    {
      keep_going = false;
      continue;
    }
    label++;
    LabelConnectedComponent(face_index, label);
  }
  return label;
}

int ON_Brep::GetConnectedComponents( ON_SimpleArray< ON_Brep* >& components, bool bDuplicateMeshes ) const
{
  const int count0 = components.Count();
  ON_Brep brep(*this);
  int count = brep.LabelConnectedComponents();
  if ( count > 1 )
  {
    int cci;
    ON_SimpleArray<int> fi(brep.m_F.Count());
    for ( cci = 1; cci <= count; cci++ )
    {
      fi.SetCount(0);
      for ( int j = 0; j < brep.m_F.Count(); j++ )
      {
        if ( brep.m_F[j].m_face_user.i == cci )
          fi.Append(j);
      }
      if ( fi.Count() > 0 )
      {
        ON_Brep* cc = brep.DuplicateFaces( fi.Count(), fi.Array(), bDuplicateMeshes );
        if ( cc )
          components.Append(cc);
      }
    }
  }

  return components.Count() - count0;
}

ON_Brep* ON_Brep::DuplicateFace( int face_index, ON_BOOL32 bDuplicateMeshes ) const
{
  return DuplicateFaces( 1, &face_index, bDuplicateMeshes );
}

ON_Brep* ON_Brep::DuplicateFaces( int face_count, const int* face_index, ON_BOOL32 bDuplicateMeshes ) const
{
  int fi, si, fli, lti, li, ti, i;
  ON_BOOL32 rc = false;
  ON_Brep* brep_copy = 0;
  ON_Object* dup = 0;

  // mark vertices, edges, faces, surfaces, and curves to duplicate
  ON_SimpleArray<int> s_remap(m_S.Count());
  s_remap.SetCount(m_S.Count());
  s_remap.Zero();
  ON_SimpleArray<int> f_remap(m_F.Count());
  f_remap.SetCount(m_F.Count());
  f_remap.Zero();
  ON_SimpleArray<int> c2_remap(m_C2.Count());
  c2_remap.SetCount(m_C2.Count());
  c2_remap.Zero();
  ON_SimpleArray<int> c3_remap(m_C3.Count());
  c3_remap.SetCount(m_C3.Count());
  c3_remap.Zero();
  ON_SimpleArray<int> e_remap(m_E.Count());
  e_remap.SetCount(m_E.Count());
  e_remap.Zero();
  ON_SimpleArray<int> v_remap(m_V.Count());
  v_remap.SetCount(m_V.Count());
  v_remap.Zero();
  for (i = 0; i < face_count; i++ ) {
    fi = face_index[i];
    if (fi >= 0 && fi < m_F.Count() ) {
      const ON_BrepFace& face = m_F[fi];
      rc = true;
      f_remap[fi] = 1;
      si = face.m_si;
      if ( si >= 0 && si < m_S.Count() ) {
        s_remap[si] = 1;
      }
      for ( fli = 0; fli < face.m_li.Count(); fli++ ) 
      {
        li = face.m_li[fli];
        if ( li < 0 || li >= m_L.Count() )
          continue;
        const ON_BrepLoop& loop = m_L[li];
        for ( lti = 0; lti < loop.m_ti.Count(); lti++ ) 
        {
          ti = loop.m_ti[lti];
          if ( ti < 0 || ti >= m_T.Count() )
            continue;
          const ON_BrepTrim& trim = m_T[ti];
          if ( trim.m_ei >= 0 && trim.m_ei < m_E.Count() ) 
          {
            int vi;
            e_remap[trim.m_ei] = 1;
            vi = m_E[trim.m_ei].m_vi[0];
            if ( vi >= 0 )
              v_remap[vi] = 1;
            vi = m_E[trim.m_ei].m_vi[1];
            if ( vi >= 0 )
              v_remap[vi] = 1;
          }
          if ( trim.m_vi[0] >= 0 )
            v_remap[trim.m_vi[0]] = 1;
          if ( trim.m_vi[1] >= 0 )
            v_remap[trim.m_vi[1]] = 1;
          int ci = trim.EdgeCurveIndexOf();
          if ( ci >= 0 ) {
            c3_remap[ci] = 1;
          }
          ci = trim.TrimCurveIndexOf();
          if ( ci >= 0 )
            c2_remap[ci] = 1;
        }
      }
    }
  }
  if ( !rc )
    return NULL;

  brep_copy = new ON_Brep();

  // duplicate surfaces
  for ( i = 0; i < m_S.Count() && rc; i++ )
  {
    if ( s_remap[i] ) {
      if ( !m_S[i] )
        break;
      dup = m_S[i]->Duplicate();
      ON_Surface* srf_copy = ON_Surface::Cast(dup);
      if ( !srf_copy )
        break;
      s_remap[i] = brep_copy->AddSurface(srf_copy);
      dup = 0;
    }
    else
      s_remap[i] = -1;
  }
  rc = ( rc && i == m_S.Count() );

  // duplicate 2d curves
  for ( i = 0; i < m_C2.Count() && rc; i++ )
  {
    if ( c2_remap[i] ) {
      if ( !m_C2[i] )
        break;
      dup = m_C2[i]->Duplicate();
      ON_Curve* crv_copy = ON_Curve::Cast(dup);
      if ( !crv_copy )
        break;
      c2_remap[i] = brep_copy->AddTrimCurve(crv_copy);
      dup = 0;
    }
    else
      c2_remap[i] = -1;
  }
  rc = ( rc && i == m_C2.Count() );

  // duplicate 3d curves
  for ( i = 0; i < m_C3.Count() && rc; i++ )
  {
    if ( c3_remap[i] ) {
      if ( !m_C3[i] )
        break;
      dup = m_C3[i]->Duplicate();
      ON_Curve* crv_copy = ON_Curve::Cast(dup);
      if ( !crv_copy )
        break;
      c3_remap[i] = brep_copy->AddEdgeCurve(crv_copy);
      dup = 0;
    }
    else
      c3_remap[i] = -1;
  }
  rc = ( rc && i == m_C3.Count() );

  // duplicate vertices
  for (i = 0; i < m_V.Count() && rc; i++ ) 
  {
    if (v_remap[i]) 
    {
      ON_BrepVertex& vertex_copy = brep_copy->NewVertex(m_V[i].point);
      memset(&vertex_copy.m_vertex_user,0,sizeof(vertex_copy.m_vertex_user));
      vertex_copy.m_vertex_user.i = i;
      v_remap[i] = vertex_copy.m_vertex_index;
    }
    else
      v_remap[i] = -1;
  }
  rc = ( rc && i == m_V.Count() );

  // duplicate edges
  for (i = 0; i < m_E.Count() && rc; i++ ) 
  {
    if (e_remap[i]) 
    {
      const ON_BrepEdge& edge = m_E[i];
      //int vi0 = edge.m_vi[0];
      if ( edge.m_vi[0] < 0 || edge.m_vi[1] < 0 || edge.m_c3i < 0 )
        break;
      if ( v_remap[edge.m_vi[0]] < 0 || v_remap[edge.m_vi[1]] < 0 || c3_remap[edge.m_c3i] < 0)
        break;
      ON_BrepEdge& edge_copy = brep_copy->NewEdge( brep_copy->m_V[v_remap[edge.m_vi[0]]], 
                                                   brep_copy->m_V[v_remap[edge.m_vi[1]]], 
                                                   c3_remap[edge.m_c3i]
                                                   );
      edge_copy.SetProxyCurveDomain( edge.ProxyCurveDomain());
      if ( edge.ProxyCurveIsReversed() )
        edge_copy.ON_CurveProxy::Reverse();
      edge_copy.SetDomain(edge.Domain());

      memset(&edge_copy.m_edge_user,0,sizeof(edge_copy.m_edge_user));
      edge_copy.m_edge_user.i = i;
      edge_copy.m_tolerance = edge.m_tolerance;
      e_remap[i] = edge_copy.m_edge_index;
    }
    else
      e_remap[i] = -1;
  }
  rc = ( rc && i == m_E.Count() );

  //03/11/2010 Tim
  //More checking to prevent crashes
  //from bogus array indices
  bool bFoundBadIdx = false;

  // duplicate faces
  for ( fi = 0; rc && fi < m_F.Count() && rc && !bFoundBadIdx; fi++ )
  {
    if ( f_remap[fi] == 0 )
      continue;
    rc = false;
    const ON_BrepFace& face = m_F[fi];

    // duplicate face
    si = (face.m_si>=0) ? s_remap[face.m_si] : -1;
    if ( si < 0 )
      break;

    ON_BrepFace& face_copy = brep_copy->NewFace(si);
    memset(&face_copy.m_face_user,0,sizeof(face_copy.m_face_user));
    face_copy.m_face_user.i = fi;
    face_copy.m_bRev = face.m_bRev;
    face_copy.m_bbox = face.m_bbox;
    face_copy.m_domain[0] = face.m_domain[0];
    face_copy.m_domain[1] = face.m_domain[1];
    //face_copy.m_material_index = face.m_material_index;
    // do NOT duplicate meshes here

    // duplicate loops and trims
    for ( fli = 0; fli < face.m_li.Count() && !bFoundBadIdx; fli++ )
    {
      li = face.m_li[fli];
      if (0 > li || m_L.Count() <= li)
      {
        bFoundBadIdx = true;
        break;
      }

      const ON_BrepLoop& loop = m_L[li];
      ON_BrepLoop& loop_copy = brep_copy->NewLoop( loop.m_type, face_copy );
      memset(&loop_copy.m_loop_user,0,sizeof(loop_copy.m_loop_user));
      loop_copy.m_loop_user.i = li;
      for ( lti = 0; lti < loop.m_ti.Count() && !bFoundBadIdx; lti++ )
      {
        ti = loop.m_ti[lti];
        if (0 > ti || m_T.Count() <= ti)
        {
          bFoundBadIdx = true;
          break;
        }
        const ON_BrepTrim& trim = m_T[ti];
        i = (trim.m_c2i>=0) ? c2_remap[trim.m_c2i] : -1;
        if ( trim.m_ei >= 0 ) {
          i = brep_copy->NewTrim( brep_copy->m_E[e_remap[trim.m_ei]], trim.m_bRev3d, loop_copy, i ).m_trim_index;
        }
        else {
          i = brep_copy->NewTrim( trim.m_bRev3d, loop_copy, i ).m_trim_index;
          int vi0 = (trim.m_vi[0]>=0) ? v_remap[trim.m_vi[0]] : -1;
          int vi1 = (trim.m_vi[1]>=0) ? v_remap[trim.m_vi[1]] : -1;
          brep_copy->m_T[i].m_vi[0] = vi0;
          brep_copy->m_T[i].m_vi[1] = vi1;
        }
        ON_BrepTrim& trim_copy = brep_copy->m_T[i];
        
        //trim_copy.m_t = trim.m_t;
        trim_copy.SetProxyCurveDomain( trim.ProxyCurveDomain());
        if ( trim.ProxyCurveIsReversed() )
          trim_copy.ON_CurveProxy::Reverse();
        trim_copy.SetDomain(trim.Domain());

        memset(&trim_copy.m_trim_user,0,sizeof(trim_copy.m_trim_user));
        trim_copy.m_trim_user.i = ti;
        trim_copy.m_iso = trim.m_iso;
        trim_copy.m_tolerance[0] = trim.m_tolerance[0];
        trim_copy.m_tolerance[1] = trim.m_tolerance[1];
        trim_copy.m_pline = trim.m_pline;
        trim_copy.m_pbox = trim.m_pbox;
        trim_copy.m__legacy_2d_tol = trim.m__legacy_2d_tol;
        trim_copy.m__legacy_3d_tol = trim.m__legacy_3d_tol;
        trim_copy.m__legacy_flags = trim.m__legacy_flags;
      }

      if (bFoundBadIdx)
        break;
      
      loop_copy.m_pbox = loop.m_pbox;
    }

    if (bFoundBadIdx)
      break;

    if ( bDuplicateMeshes ) 
    {
      if ( face.m_render_mesh )
        face_copy.m_render_mesh = face.m_render_mesh->Duplicate();
      if ( face.m_analysis_mesh )
        face_copy.m_analysis_mesh = face.m_analysis_mesh->Duplicate();
      if ( face.m_preview_mesh )
        face_copy.m_preview_mesh = face.m_preview_mesh->Duplicate();
    }

    rc = true;
  }
  rc = ( rc && fi == m_F.Count() );
  
  if ( !rc ) {
    if ( dup ) {
      delete dup;
      dup = 0;
    }
    if ( brep_copy ) {
      delete brep_copy;
      brep_copy = 0;
    }
  }
  else 
  {
    // set flags, tolerances, etc. that have changed
    brep_copy->SetTrimTypeFlags();
    brep_copy->SetVertexTolerances();
  }
  return brep_copy;
}

ON_Brep* ON_Brep::ExtractFace( int face_index )
{
  ON_Brep* brep_copy = DuplicateFace(face_index,false);
  if ( brep_copy ) {
    ON_BrepFace& face = m_F[face_index];
    ON_BrepFace& face_copy = brep_copy->m_F[0];
    face_copy.m_render_mesh = face.m_render_mesh; face.m_render_mesh = 0;
    face_copy.m_analysis_mesh = face.m_analysis_mesh; face.m_analysis_mesh = 0;
    face_copy.m_preview_mesh = face.m_preview_mesh; face.m_preview_mesh = 0;
    DeleteFace( face, true );
  }
  return brep_copy;
}

void ON_Brep::DeleteSurface(int si)
{
  if ( si >= 0 && si < m_S.Count() ) {
    delete m_S[si];
    m_S[si] = 0;
  }
}

void ON_Brep::Delete2dCurve(int c2i)
{
  if ( c2i >= 0 && c2i < m_C2.Count() ) {
    delete m_C2[c2i];
    m_C2[c2i] = 0;
  }
}

void ON_Brep::Delete3dCurve(int c3i)
{
  if ( c3i >= 0 && c3i < m_C3.Count() ) {
    delete m_C3[c3i];
    m_C3[c3i] = 0;
  }
}


bool ON_Brep::CullUnusedFaces()
{
  bool rc = true;
  int fcount = m_F.Count();
  if (fcount > 0 ) {
    ON_Workspace ws;
    int *fmap = ws.GetIntMemory(fcount+1);
    *fmap++ = -1;
    memset( fmap, 0, fcount*sizeof(*fmap) );
    const int lcount = m_L.Count();
    int fi, li, mi = 0;

    // if face.m_face_index is -1, cull face
    for ( fi = 0; fi < fcount; fi++ ) {
      ON_BrepFace& face = m_F[fi];
      if ( face.m_face_index == -1)
        fmap[fi] = -1;
      else if ( face.m_face_index == fi )
        fmap[fi] = face.m_face_index = mi++;
      else {
        ON_ERROR("Brep face has illegal m_face_index.");
        rc = false;
        fmap[fi] = face.m_face_index;
      }
    }

    if ( mi == 0 ) {
      m_F.Destroy();
    }
    else if ( mi < fcount ) {
      // set new face indices
      mi = 0;
      for ( fi = fcount-1; fi >= 0; fi-- ) {
        if ( m_F[fi].m_face_index  == -1 )
          m_F.Remove(fi);
        else
          m_F[fi].m_face_index = fmap[fi];
      }

      // remap loop.m_fi indices
      for ( li = 0; li < lcount; li++ ) {
        ON_BrepLoop& loop = m_L[li];
        fi = loop.m_fi;
        if ( fi < -1 || fi >= fcount ) {
          ON_ERROR("Brep loop has illegal m_fi.");
          rc = false;
        }
        else 
          loop.m_fi = fmap[fi];
      }

    }
  }
  m_F.Shrink();
  return rc;
}

bool ON_Brep::CullUnusedSurfaces()
{
  // remove unused surfaces
  bool rc = true;
  const int fcount = m_F.Count();
  int scount = m_S.Count();
  int si, fi, mi;

  if ( scount > 0 ) {
    ON_Workspace ws;
    int* smap = ws.GetIntMemory(scount+1);
    *smap++ = -1;
    memset(smap,0,scount*sizeof(*smap));
    mi = 0;
    for ( fi = 0; fi < fcount; fi++ ) {
      ON_BrepFace& face = m_F[fi];
      if ( face.m_face_index == -1 ) {
        face.m_si = -1;
        continue;
      }
      si = face.m_si;
      if ( si == -1 )
        continue;
      if ( si < 0 || si >= scount ) {
        ON_ERROR("Brep face has illegal m_si.");
        rc = false;
      }
      else {
        if ( !smap[si] )
          mi++;
        smap[si]++;
      }
    }

    if ( mi == 0 ) {
      m_S.Destroy();
    }
    else if ( mi < scount ) {
      mi = 0;
      for ( si = 0; si < scount; si++ ) {
        if ( smap[si] )
          smap[si] = mi++;
        else {
          delete m_S[si];
          m_S[si] = 0;
          smap[si] = -1;
        }
      }

      for ( fi = 0; fi < fcount; fi++ ) {
        ON_BrepFace& face = m_F[fi];
        si = face.m_si;
        if ( si >= 0 && si < scount )
          face.m_si = smap[si];
      }

      for ( si = scount-1; si >= 0; si-- ) {
        if ( smap[si] < 0 ) {
          m_S.Remove(si);
          scount--;
        }
      }
    }
  }
  m_S.Shrink();
  return rc;
}

bool ON_Brep::CullUnused3dCurves()
{
  // remove unused surfaces
  bool rc = true;
  const int ecount = m_E.Count();
  int c3count = m_C3.Count();
  int c3i, ei, mi;

  if ( c3count > 0 ) {
    ON_Workspace ws;
    int* c3map = ws.GetIntMemory(c3count+1);
    *c3map++ = -1;
    memset(c3map,0,c3count*sizeof(*c3map));
    mi = 0;
    for ( ei = 0; ei < ecount; ei++ ) {
      ON_BrepEdge& edge = m_E[ei];
      if ( edge.m_edge_index == -1 ) {
        edge.m_c3i = -1;
        continue;
      }
      c3i = edge.m_c3i;
      if ( c3i == -1 )
        continue;
      if ( c3i < -1 || c3i >= c3count ) {
        ON_ERROR("Brep edge has illegal m_c3i.");
        rc = false;
      }
      else {
        if ( !c3map[c3i] )
          mi++;
        c3map[c3i]++;
      }
    }

    if ( mi == 0 ) {
      m_C3.Destroy();
    }
    else if ( mi < c3count ) {
      mi = 0;
      for ( c3i = 0; c3i < c3count; c3i++ ) {
        if ( c3map[c3i] )
          c3map[c3i] = mi++;
        else {
          delete m_C3[c3i];
          m_C3[c3i] = 0;
          c3map[c3i] = -1;
        }
      }

      for ( ei = 0; ei < ecount; ei++ ) {
        ON_BrepEdge& edge = m_E[ei];
        c3i = edge.m_c3i;
        if ( c3i >= 0 && c3i < c3count )
          edge.m_c3i = c3map[c3i];
      }

      for ( c3i = c3count-1; c3i >= 0; c3i-- ) {
        if ( c3map[c3i] < 0 ) {
          m_C3.Remove(c3i);
          c3count--;
        }
      }
    }
  }
  m_C3.Shrink();
  return rc;
}


bool ON_Brep::CullUnused2dCurves()
{
  // remove unused surfaces
  bool rc = true;
  const int tcount = m_T.Count();
  int c2count = m_C2.Count();
  int c2i, ti, mi;

  if ( c2count > 0 ) 
  {
    ON_Workspace ws;
    int* c2map = ws.GetIntMemory(c2count+1);
    *c2map++ = -1;
    memset(c2map,0,c2count*sizeof(*c2map));
    mi = 0;
    for ( ti = 0; ti < tcount; ti++ ) {
      ON_BrepTrim& trim = m_T[ti];
      if ( trim.m_trim_index == -1 ) {
        trim.m_c2i = -1;
        continue;
      }
      c2i = trim.m_c2i;
      if ( c2i == -1 )
        continue;
      if ( c2i < -1 || c2i >= c2count ) {
        ON_ERROR("Brep trim has illegal m_c2i.");
        rc = false;
      }
      else {
        if ( !c2map[c2i] )
          mi++;
        c2map[c2i]++;
      }
    }

    if ( mi == 0 ) {
      m_C2.Destroy();
    }
    else if ( mi < c2count ) {
      mi = 0;
      for ( c2i = 0; c2i < c2count; c2i++ ) {
        if ( c2map[c2i] )
          c2map[c2i] = mi++;
        else {
          delete m_C2[c2i];
          m_C2[c2i] = 0;
          c2map[c2i] = -1;
        }
      }

      for ( ti = 0; ti < tcount; ti++ ) {
        ON_BrepTrim& trim = m_T[ti];
        c2i = trim.m_c2i;
        if ( c2i >= 0 && c2i < c2count )
          trim.m_c2i = c2map[c2i];
      }

      for ( c2i = c2count-1; c2i >= 0; c2i-- ) {
        if ( c2map[c2i] < 0 ) {
          m_C2.Remove(c2i);
          c2count--;
        }
      }
    }
  }
  m_C2.Shrink();
  return rc;
}


bool ON_Brep::CullUnusedLoops()
{
  bool rc = true;
  const int lcount = m_L.Count();
  if ( lcount > 0 ) {
    ON_Workspace ws;
    int* lmap = ws.GetIntMemory(lcount+1);
    *lmap++ = -1;
    memset( lmap, 0, lcount*sizeof(*lmap) );
    const int fcount = m_F.Count();
    const int tcount = m_T.Count();
    int li, fli, flcnt, fi, ti, mi;

    mi = 0;
    for ( li = 0; li < lcount; li++ ) {
      ON_BrepLoop& loop = m_L[li];
      if ( loop.m_loop_index == -1)
        lmap[li] = -1;
      else if ( loop.m_loop_index == li )
        lmap[li] = loop.m_loop_index = mi++;
      else {
        ON_ERROR("Brep loop has illegal m_loop_index.");
        rc = false;
        lmap[li] = loop.m_loop_index;
      }
    }

    if ( mi == 0 ) {
      m_L.Destroy();
    }
    else if ( mi < lcount ) {

      // remap loops
      for ( li = lcount-1; li >= 0; li-- ) {
        if ( m_L[li].m_loop_index == -1 )
          m_L.Remove(li);
        else
          m_L[li].m_loop_index = lmap[li];
      }

      // remap ON_BrepFace.m_li[] indices
      for ( fi = 0; fi < fcount; fi++ ) {
        ON_BrepFace& face = m_F[fi];
        flcnt = face.m_li.Count();
        for ( fli = flcnt-1; fli >= 0; fli-- ) {
          li = face.m_li[fli];
          if ( li < -1 || li >= lcount ) {
            ON_ERROR("Brep face m_li[] has illegal loop index.");
            rc = false;
          }
          else {
            li = lmap[li];
            if (li >= 0 ) {
              face.m_li[fli] = li;
            }
            else {
              face.m_li.Remove(fli);
            }
          }
        }
      }

      // remap ON_BrepTrim.m_li indices
      for ( ti = 0; ti < tcount; ti++ ) {
        ON_BrepTrim& trim = m_T[ti];
        li = trim.m_li;
        if ( li < -1 || li >= lcount ) {
          ON_ERROR("Brep trim has illegal m_li.");
          rc = false;
        }
        else {
          trim.m_li = lmap[li];
        }
      }
    }
  }
  m_L.Shrink();
  return rc;
}

bool ON_Brep::CullUnusedTrims()
{
  bool rc = true;
  const int tcount = m_T.Count();
  if ( tcount > 0 ) {
    ON_Workspace ws;
    int *tmap = ws.GetIntMemory(tcount+1);
    *tmap++ = -1;
    memset( tmap, 0, tcount*sizeof(*tmap));
    const int lcount = m_L.Count();
    const int ecount = m_E.Count();
    int ti, li, ei, mi, ltcnt, lti, etcnt, eti;

    mi = 0;
    for ( ti = 0; ti < tcount; ti++ ) {
      ON_BrepTrim& trim = m_T[ti];
      if ( trim.m_trim_index == -1)
        tmap[ti] = -1;
      else if ( trim.m_trim_index == ti )
        tmap[ti] = trim.m_trim_index = mi++;
      else {
        ON_ERROR("Brep trim has illegal m_trim_index.");
        rc = false;
        tmap[ti] = trim.m_trim_index;
      }
    }

    if ( mi == 0 ) {
      m_T.Destroy();
    }
    else if ( mi < tcount ) {
      // remap trim indices
      for ( ti = tcount-1; ti >= 0; ti-- ) {
        if ( m_T[ti].m_trim_index == -1 ) {
          m_T.Remove(ti);
        }
        else {
          m_T[ti].m_trim_index = tmap[ti];
        }
      }

      // remap loop.m_ti[] indicies
      for ( li = 0; li < lcount; li++ ) {
        ON_BrepLoop& loop = m_L[li];
        ltcnt = loop.m_ti.Count();
        for ( lti = ltcnt-1; lti >= 0; lti-- ) {
          ti = loop.m_ti[lti];
          if ( ti < -1 || ti >= tcount ) {
            ON_ERROR("Brep loop.m_ti[] has illegal index.");
            rc = false;
          }
          else {
            ti = tmap[ti];
            if (ti >= 0 ) {
              loop.m_ti[lti] = ti;
            }
            else {
              loop.m_ti.Remove(lti);
            }
          }
        }
      }

      // remap edge.m_ti[] indicies
      for ( ei = 0; ei < ecount; ei++ ) {
        ON_BrepEdge& edge = m_E[ei];
        etcnt = edge.m_ti.Count();
        for ( eti = etcnt-1; eti >= 0; eti-- ) {
          ti = edge.m_ti[eti];
          if ( ti < -1 || ti >= tcount ) {
            ON_ERROR("Brep edge.m_ti[] has illegal index.");
            rc = false;
          }
          else {
            ti = tmap[ti];
            if (ti >= 0 ) {
              edge.m_ti[eti] = ti;
            }
            else {
              edge.m_ti.Remove(eti);
            }
          }
        }
      }
    }
  }
  m_T.Shrink();
  return rc;
}

bool ON_Brep::CullUnusedEdges()
{
  bool rc = true;
  const int ecount = m_E.Count();
  if ( ecount > 0 ) {
    ON_Workspace ws;
    int* emap = ws.GetIntMemory(ecount+1);
    *emap++ = -1;
    memset( emap, 0, ecount*sizeof(*emap) );
    const int vcount = m_V.Count();
    const int tcount = m_T.Count();
    int ei, ti, vi, mi, vecnt, vei;

    mi = 0;
    for ( ei = 0; ei < ecount; ei++ ) {
      ON_BrepEdge& edge = m_E[ei];
      if ( edge.m_edge_index == -1)
        emap[ei] = -1;
      else if ( edge.m_edge_index == ei )
        emap[ei] = edge.m_edge_index = mi++;
      else {
        ON_ERROR("Brep edge has illegal m_edge_index.");
        rc = false;
        emap[ei] = edge.m_edge_index;
      }
    }

    if ( mi == 0 ) {
      m_E.Destroy();
    }
    else if ( mi < ecount ) 
    {
      // remap edge indices
      for ( ei = ecount-1; ei >= 0; ei-- ) {
        if ( m_E[ei].m_edge_index == -1 ) {
          m_E.Remove(ei);
        }
        else {
          m_E[ei].m_edge_index = emap[ei];
        }
      }

      // remap trim.m_ei
      for ( ti = 0; ti < tcount; ti++ ) {
        ON_BrepTrim& trim = m_T[ti];
        ei = trim.m_ei;
        if ( ei < -1 || ei >= ecount ) {
          ON_ERROR("Brep trim.m_ei has illegal index.");
          rc = false;
        }
        else {
          trim.m_ei = emap[ei];
        }
      }

      // remap vertex.m_ei[]
      for ( vi = 0; vi < vcount; vi++ ) {
        ON_BrepVertex& vertex = m_V[vi];
        vecnt = vertex.m_ei.Count();
        for ( vei = vecnt-1; vei >= 0; vei-- ) {
          ei = vertex.m_ei[vei];
          if ( ei < -1 || ei >= ecount ) {
            ON_ERROR("Brep vertex.m_ei[] has illegal index.");
            rc = false;
          }
          else {
            ei = emap[ei];
            if (ei >= 0 ) {
              vertex.m_ei[vei] = ei;
            }
            else {
              vertex.m_ei.Remove(vei);
            }
          }
        }
      }
    }
  }
  m_E.Shrink();
  return rc;
}


bool ON_Brep::CullUnusedVertices()
{
  bool rc = true;
  const int vcount = m_V.Count();
  if ( vcount > 0 ) 
  {
    ON_Workspace ws;
    int* vmap = ws.GetIntMemory(vcount+1);
    *vmap++ = -1;
    memset(vmap,0,vcount*sizeof(*vmap));
    const int tcount = m_T.Count();
    const int ecount = m_E.Count();
    int vi, ei, ti, mi, j;

    if ( tcount > 0 )
    {
      // 11 Nov 2009 Dale Lear
      //  I added this code to fix bugs 55879 and 56191.
      for ( ti = 0; ti < tcount; ti++ )
      {
        const ON_BrepTrim& trim = m_T[ti];
        if ( -1 == trim.m_trim_index )
          continue;
        vi = trim.m_vi[0];
        if ( vi >= 0 && vi < vcount && -1 == m_V[vi].m_vertex_index )
        {
          // undelete this vertex
          // This error happens when the ON_Brep is invalid to begin with.
          // However, in order to prevent crashes, we have to refuse to delete
          // the vertex.  See bugs 55879 and 56191.
          ON_ERROR("ON_Brep::CullUnusedVertices() - deleted vertex referenced by trim.m_vi[0]");
          m_V[vi].m_vertex_index = vi;
        }
        vi = trim.m_vi[1];
        if ( vi >= 0 && vi < vcount && -1 == m_V[vi].m_vertex_index )
        {
          // undelete this vertex
          // This error happens when the ON_Brep is invalid to begin with.
          // However, in order to prevent crashes, we have to refuse to delete
          // the vertex.  See bugs 55879 and 56191.
          ON_ERROR("ON_Brep::CullUnusedVertices() - deleted vertex referenced by trim.m_vi[1]");
          m_V[vi].m_vertex_index = vi;
        }
      }
    }

    mi = 0;
    for ( vi = 0; vi < vcount; vi++ ) {
      ON_BrepVertex& vertex = m_V[vi];
      if ( vertex.m_vertex_index == -1)
        vmap[vi] = -1;
      else if ( vertex.m_vertex_index == vi )
        vmap[vi] = vertex.m_vertex_index = mi++;
      else {
        ON_ERROR("Brep vertex has illegal m_vertex_index.");
        rc = false;
        vmap[vi] = vertex.m_vertex_index;
      }
    }

    if ( mi == 0 ) 
    {
      m_V.Destroy();
    }
    else if ( mi < vcount ) 
    {
      // remap vertex indices
      for ( vi = vcount-1; vi >= 0; vi-- ) 
      {
        if ( m_V[vi].m_vertex_index == -1 )
        {
          m_V.Remove(vi);
        }
        else {
          m_V[vi].m_vertex_index = vmap[vi];
        }
      }

      // remap edge indices
      for ( ei = 0; ei < ecount; ei++ ) 
      {
        ON_BrepEdge& edge = m_E[ei];
        for ( j = 0; j < 2; j++ ) 
        {
          vi = edge.m_vi[j];
          if ( vi < -1 || vi >= vcount ) 
          {
            ON_ERROR("Brep edge.m_vi[] has illegal index.");
            rc = false;
          }
          else {
            edge.m_vi[j] = vmap[vi];
          }
        }
      }

      // remap trim indices
      for ( ti = 0; ti < tcount; ti++ )
      {
        ON_BrepTrim& trim = m_T[ti];
        for ( j = 0; j < 2; j++ ) 
        {
          vi = trim.m_vi[j];
          if ( vi < -1 || vi >= vcount ) 
          {
            ON_ERROR("Brep trim.m_vi[] has illegal index.");
            rc = false;
          }
          else {
            trim.m_vi[j] = vmap[vi];
          }
        }
      }

    }
  }
  m_V.Shrink();
  return rc;
}

bool ON_Brep::Compact()
{
  // Removes any unreferenced objects from arrays,
  // reindexes as needed, and shrinks arrays to
  // minimum required size.

  bool rc = true;
  if (!CullUnusedFaces())
    rc = false;
  if (!CullUnusedEdges())
    rc = false;
  if (!CullUnusedVertices())
    rc = false;
  if (!CullUnusedLoops())
    rc = false;
  if (!CullUnusedTrims())
    rc = false;

  if (!CullUnusedSurfaces())
    rc = false;
  if (!CullUnused3dCurves())
    rc = false;
  if (!CullUnused2dCurves())
    rc = false;

  // If 1-1 relationships exist between geometry and topology,
  // the synchronize the geometry and topology indices.  This
  // helps confused users of breps not have to understand the
  // differences between geometry and topology data.
  ON_SimpleArray<bool> used;
  bool bSyncUp;

  if ( m_C2.Count() == m_T.Count() )
  {
    int i, count = m_C2.Count();
    used.Reserve(count);
    used.SetCount(count);
    used.Zero();
    bSyncUp = true;
    for ( i = 0; i < count && bSyncUp; i++ )
    {
      const ON_BrepTrim& trim = m_T[i];
      if ( trim.m_trim_index != i || trim.m_c2i < 0 || trim.m_c2i >= count )
        bSyncUp = false;
      else
      {
        if (used[trim.m_c2i])
          bSyncUp = false;
        else
          used[trim.m_c2i] = true;
      }
    }
    if ( bSyncUp )
    {
      ON_SimpleArray< ON_Curve* > ptr(count);
      for( i = 0; i < count; i++ )
      {
        ON_BrepTrim& trim = m_T[i];
        ptr[i] = m_C2[trim.m_c2i];
        trim.m_c2i = i;
      }
      for( i = 0; i < count; i++ )
      {
        m_C2[i] = ptr[i];
      }
    }
  }

  if ( m_C3.Count() == m_E.Count() )
  {
    int i, count = m_C3.Count();
    used.Reserve(count);
    used.SetCount(count);
    used.Zero();
    bSyncUp = true;
    for ( i = 0; i < count && bSyncUp; i++ )
    {
      const ON_BrepEdge& edge = m_E[i];
      if ( edge.m_edge_index != i || edge.m_c3i < 0 || edge.m_c3i >= count )
        bSyncUp = false;
      else
      {
        if (used[edge.m_c3i])
          bSyncUp = false;
        else
          used[edge.m_c3i] = true;
      }
    }
    if ( bSyncUp )
    {
      ON_SimpleArray< ON_Curve* > ptr(count);
      for( i = 0; i < count; i++ )
      {
        ON_BrepEdge& edge = m_E[i];
        ptr[i] = m_C3[edge.m_c3i];
        edge.m_c3i = i;
      }
      for( i = 0; i < count; i++ )
      {
        m_C3[i] = ptr[i];
      }
    }
  }

  if ( m_S.Count() == m_F.Count() )
  {
    int i, count = m_S.Count();
    used.Reserve(count);
    used.SetCount(count);
    used.Zero();
    bSyncUp = true;
    for ( i = 0; i < count && bSyncUp; i++ )
    {
      const ON_BrepFace& face = m_F[i];
      if ( face.m_face_index != i || face.m_si < 0 || face.m_si >= count )
        bSyncUp = false;
      else
      {
        if (used[face.m_si])
          bSyncUp = false;
        else
          used[face.m_si] = true;
      }
    }
    if ( bSyncUp )
    {
      ON_SimpleArray< ON_Surface* > ptr(count);
      for( i = 0; i < count; i++ )
      {
        ON_BrepFace& face = m_F[i];
        ptr[i] = m_S[face.m_si];
        face.m_si = i;
      }
      for( i = 0; i < count; i++ )
      {
        m_S[i] = ptr[i];
      }
    }
  }

  return rc;
}


ON_Brep& ON_Brep::operator=(const ON_Brep& src)
{
  if ( this != &src ) 
  {
    Destroy();
    ON_Geometry::operator=(src);

    m_V.SetCapacity(src.m_V.Count());
    m_E.SetCapacity(src.m_E.Count());
    m_F.SetCapacity(src.m_F.Count());
    m_T.SetCapacity(src.m_T.Count());
    m_L.SetCapacity(src.m_L.Count());

    m_V.SetCount(src.m_V.Count());
    m_E.SetCount(src.m_E.Count());
    m_F.SetCount(src.m_F.Count());
    m_T.SetCount(src.m_T.Count());
    m_L.SetCount(src.m_L.Count());

    src.m_C2.Duplicate( m_C2 );
    src.m_C3.Duplicate( m_C3 );
    src.m_S.Duplicate( m_S );

    int i, count = m_V.Count();
    for ( i = 0; i < count; i++ ) 
    {
      m_V[i] = src.m_V[i];
    }

    count = m_E.Count();
    for ( i = 0; i < count; i++ ) 
    {
      m_E[i] = src.m_E[i];
      ON_BrepEdge& e = m_E[i];
      e.m_brep = this;

      // update curve proxy info to point at 3d curve in this brep
      e.SetProxyCurve( ( e.m_c3i >= 0 ) ? m_C3[e.m_c3i] : 0, 
                       src.m_E[i].ProxyCurveDomain()
                       );
      if ( src.m_E[i].ProxyCurveIsReversed() )
        e.ON_CurveProxy::Reverse();
      e.SetDomain( src.m_E[i].Domain() );
    }

    count = m_L.Count();
    for ( i = 0; i < count; i++ ) 
    {
      m_L[i].m_brep = this;
    }

    count = m_F.Count();
    for ( i = 0; i < count; i++ ) 
    {
      m_F[i] = src.m_F[i];
      ON_BrepFace& f = m_F[i];
      f.m_brep = this;
      // update surface proxy info to point at 3d surface in this brep
      f.SetProxySurface(( f.m_si >= 0 ) ? m_S[f.m_si] : 0);
      f.m_bbox = src.m_F[i].m_bbox; // because SetProxySurface destroys it
    }

    count = m_T.Count();
    for ( i = 0; i < count; i++ ) 
    {
      m_T[i] = src.m_T[i];
      ON_BrepTrim& trim = m_T[i];
      trim.m_brep = this;

      // update curve proxy info to point at 2d curve in this brep
      trim.SetProxyCurve( ( trim.m_c2i >= 0 ) ? m_C2[trim.m_c2i] : 0, 
                          src.m_T[i].ProxyCurveDomain()
                         );
      if ( src.m_T[i].ProxyCurveIsReversed() )
        trim.ON_CurveProxy::Reverse();
      trim.SetDomain( src.m_T[i].Domain() );
    }

    count = m_L.Count();
    for ( i = 0; i < count; i++ ) 
    {
      m_L[i] = src.m_L[i];
    }

    m_bbox = src.m_bbox;
    m_is_solid = src.m_is_solid;
  }
  return *this;
}

void ON_Brep::Destroy()
{
  m_V.Empty();
  m_E.Empty();
  m_F.Empty();
  m_T.Empty();
  m_L.Empty();

  int i, count = m_C2.Count();
  for ( i = 0; i < count; i++ ) {
    delete m_C2[i];
    m_C2[i] = 0;
  }
  m_C2.Empty();
  m_C2.Zero();

  count = m_C3.Count();
  for ( i = 0; i < count; i++ ) {
    delete m_C3[i];
    m_C3[i] = 0;
  }
  m_C3.Empty();
  m_C3.Zero();

  count = m_S.Count();
  for ( i = 0; i < count; i++ ) {
    delete m_S[i];
    m_S[i] = 0;
  }
  m_S.Empty();
  m_S.Zero();

  m_bbox.Destroy();
  m_is_solid = 0;
  // returns Brep to state it has after default construction
}

void ON_Brep::EmergencyDestroy()
{ 
  // call if memory pool used by b-rep members becomes invalid
  // but ON_Brep class memory is in a valid pool
  m_V.EmergencyDestroy();
  m_E.EmergencyDestroy();
  m_F.EmergencyDestroy();
  m_T.EmergencyDestroy();
  m_L.EmergencyDestroy();
  m_C2.EmergencyDestroy();
  m_C3.EmergencyDestroy();
  m_S.EmergencyDestroy();
  m_bbox.Destroy();
  m_is_solid = 0;
}

bool ON_Brep::CombineCoincidentVertices(ON_BrepVertex& vertex0, ON_BrepVertex& vertex1)
{

  bool rc = false;
  if (&vertex0 == &vertex1) {
    ON_ERROR("ON_Brep::CombineCoincidentVertices - vertex0 = vertex1.");
    return rc;
  }
  // moves information to vertex0 and deletes vertex1
  int runaway, vei, vecnt, ei, eti, etcnt, ti, prev_ti, next_ti;

  if ( vertex0.m_vertex_index >= 0 && vertex1.m_vertex_index != vertex0.m_vertex_index ) {
    rc = true;
    // update edges and trim references from vertex0 to vertex1
    vecnt = vertex1.m_ei.Count();
    for ( vei = 0; vei < vecnt; vei++ ) {
      ei = vertex1.m_ei[vei];
      if ( ei >= 0 ) {
        // update edge vertex indices
        ON_BrepEdge& edge = m_E[ei];
        if ( edge.m_vi[0] == vertex1.m_vertex_index )
          edge.m_vi[0] = vertex0.m_vertex_index;
        if ( edge.m_vi[1] == vertex1.m_vertex_index )
          edge.m_vi[1] = vertex0.m_vertex_index;

        // update trim vertex indices
        etcnt = edge.m_ti.Count();
        for (eti = 0; eti < etcnt; eti++ ) {
          ti = edge.m_ti[eti];
          if (ti >= 0 ) {
            ON_BrepTrim& trim = m_T[ti];
            if ( trim.m_vi[0] == vertex1.m_vertex_index ) {
              trim.m_vi[0] = vertex0.m_vertex_index;
              // check for previous singular trims using vertex0
              for (prev_ti = PrevTrim(ti), runaway=0;prev_ti >= 0 && prev_ti != ti && runaway < 1024;prev_ti=PrevTrim(prev_ti),runaway++) {
                ON_BrepTrim& prevtrim = m_T[prev_ti];
                if ( prevtrim.m_ei >= 0 )
                  break;
                if ( prevtrim.m_vi[0] == vertex1.m_vertex_index )
                  prevtrim.m_vi[0] = vertex0.m_vertex_index;
                if ( prevtrim.m_vi[1] == vertex1.m_vertex_index )
                  prevtrim.m_vi[1] = vertex0.m_vertex_index;
              }
            }
            if ( trim.m_vi[1] == vertex1.m_vertex_index ) {
              trim.m_vi[1] = vertex0.m_vertex_index;
               // check for previous singular trims using vertex0
              for (next_ti = NextTrim(ti), runaway=0;next_ti >= 0 && next_ti != ti && runaway < 1024;next_ti=NextTrim(next_ti),runaway++) {
                ON_BrepTrim& nexttrim = m_T[next_ti];
                if ( nexttrim.m_ei >= 0 )
                  break;
                if ( nexttrim.m_vi[0] == vertex1.m_vertex_index )
                  nexttrim.m_vi[0] = vertex0.m_vertex_index;
                if ( nexttrim.m_vi[1] == vertex1.m_vertex_index )
                  nexttrim.m_vi[1] = vertex0.m_vertex_index;
              }
            }
          }
        }
        vertex0.m_ei.Append(ei);
      }
    }
  }

  // update vertex tolerances
  if ( vertex0.m_tolerance != ON_UNSET_VALUE) 
    SetVertexTolerance(vertex0);

  vertex1.m_vertex_index = -1;
  vertex1.m_ei.Destroy();
  DeleteVertex(vertex1);

  return rc;
}


ON_BrepEdge* ON_Brep::CombineContiguousEdges( 
  int ei0, 
  int ei1, 
  double angle_tolerance_radians
  )
{
  // Bug fixers:
  //
  // Lots of (fast)testing is done to ensure the brep is
  // 100% valid at the merge vertex.  Do not change the
  // return 0 bail outs unless you are 100% sure of what
  // you are doing.

  // get edges to be merged
  const ON_BrepEdge* edge0 = Edge(ei0);
  const ON_BrepEdge* edge1 = Edge(ei1);
  if ( !edge0 || !edge1 )
    return 0;

  // clear any component index bits
  ei0 = edge0->m_edge_index;
  ei1 = edge1->m_edge_index;
  if ( ei0 < 0 || ei1 < 0 || ei0 == ei1 )
    return 0;

  // make sure edges have same number of trims
  if ( edge0->m_ti.Count() != edge1->m_ti.Count() )
    return 0;

  // figure out which edge ends to merge
	// GBA 1/6/03 Fixed TRR#8951.
	// Check that the vertex to be eliminated has exactly 2 incident edges.
  int end0 = 1, end1 = 0;
	bool MatchFound = false;			
	for(end0=1; !MatchFound && end0>=0; /* empty */){
		int vi = edge0->m_vi[end0];
		const ON_BrepVertex* v =  Vertex(vi);
		if(v && v->m_ei.Count()==2 ){
			for(end1=0; !MatchFound && end1<2; /*empty*/){
				MatchFound = (vi == edge1->m_vi[end1]);
				if(!MatchFound)
					end1++; 
			}	
		}
		if(!MatchFound)
			end0--;
	}
	if(!MatchFound)
		return 0;

  // vi_mid = index of vertex to be eliminated
  const int vi_mid = edge0->m_vi[end0];
  {
    const ON_BrepVertex* v = Vertex(vi_mid);
    if ( !v )
      return 0;
    if ( v->m_ei.Count() != 2 )
      return 0;
    if ( v->m_ei[0] != ei0 && v->m_ei[1] != ei0 )
      return 0;
    if ( v->m_ei[0] != ei1 && v->m_ei[1] != ei1 )
      return 0;
  }

  // evi0 = vertex index and other end of edge0
  const int evi0 = edge0->m_vi[1-end0];

  // evi = vertex index and other end of edge1
  const int evi1 = edge1->m_vi[1-end1];
  if ( evi0 == vi_mid )
    return 0;
  if ( evi1 == vi_mid )
    return 0;

  // new edge will start at vi0 and end at vi1
  const int vi0 = (end0==1) ? evi0 : evi1;
  const int vi1 = (end0==1) ? evi1 : evi0;

  // make sure the 3d kink angle at the merge point is <= angle_tolerance
  {
    ON_3dVector tan0 = edge0->TangentAt( edge0->Domain()[end0] );
    if ( end0 == 0 )
      tan0.Reverse();
    ON_3dVector tan1 = edge1->TangentAt( edge1->Domain()[end1] );
    if ( end1 == 1 )
      tan1.Reverse();
    double d = tan0*tan1;
    if ( d < cos(angle_tolerance_radians) )
      return 0;
  }

  // get corresponding pairs of trims to merge
  int trim_count = edge0->m_ti.Count();
  ON_SimpleArray<int> trim0_index(trim_count);
  ON_SimpleArray<int> trim1_index(trim_count);
  ON_SimpleArray<int> loop_lti0(trim_count);
  ON_SimpleArray<int> loop_lti1(trim_count);

  int eti;
  for ( eti = 0; eti < trim_count; eti++ )
  {
    const ON_BrepTrim* trim0 = Trim( edge0->m_ti[eti] );
    if ( !trim0 )
      return 0;
    int ti0 = trim0->m_trim_index;
    const ON_BrepLoop* loop = trim0->Loop();
    if ( !loop )
      return 0;
    if ( loop->m_ti.Count() < 2 )
      return 0;

    // get index of next/prev trim that corresponds to edge1
    bool bRev = (end0==0);
    if ( trim0->m_bRev3d )
      bRev = !bRev;
    int lti1 = -1;
    int lti0 = loop->m_ti.Search( &ti0, ON_CompareIncreasing<int> );
    if ( lti0 < 0 )
      return 0;
    if ( bRev )
      lti1 = lti0 - 1 + loop->m_ti.Count();
    else
      lti1 = lti0 +1;
    lti1 %= loop->m_ti.Count();
    const ON_BrepTrim* trim1 = loop->Trim(lti1);
    if ( !trim1 )
      return 0;
    if ( trim1->m_ei != ei1 )
      return 0;
    if ( trim0->m_trim_index == trim1->m_trim_index )
      return 0;

    // test for valid trim vertices and orientations
    int tend0 = trim0->m_bRev3d ? (1-end0) : end0;
    int tend1 = trim1->m_bRev3d ? (1-end1) : end1;
    if ( tend0 == tend1 )
      return 0;
    if ( trim0->m_vi[tend0] != vi_mid )
      return 0;
    if ( trim1->m_vi[tend1] != vi_mid )
      return 0;
    if ( trim0->m_vi[1-tend0] != evi0 )
      return 0;
    if ( trim1->m_vi[1-tend1] != evi1 )
      return 0;
    trim0_index.Append(trim0->m_trim_index);
    trim1_index.Append(trim1->m_trim_index);
    loop_lti0.Append(lti0);
    loop_lti1.Append(lti1);
  }

  // create new 3d edge curve geometry
  // new edge goes same direction as edge0
  ON_PolyCurve* ec = 0;
  {
    ON_Curve* ec0 = edge0->DuplicateCurve();
    if ( !ec0 )
      return 0;
    ON_Curve* ec1 = edge1->DuplicateCurve();
    if ( !ec1 )
    {
      delete ec0;
      return 0;
    }
    if ( end0 == end1 )
    {
      if ( !ec1->Reverse() )
      {
        delete ec0;
        delete ec1;
        return 0;
      }
    }
    ec = new ON_PolyCurve();
    if ( end0 == 1 )
    {
      ec->Append(ec0);
      ec->AppendAndMatch(ec1);
    }
    else
    {
      ec->Append(ec1);
      ec->AppendAndMatch(ec0);
    }
    ec->RemoveNesting();
  }

  // create new 2d trim curve geometry
  ON_SimpleArray<ON_Curve*> tc(trim_count);
  for ( eti = 0; eti < trim_count; eti++ )
  {
    const ON_BrepTrim* trim0 = Trim(trim0_index[eti]);
    if ( !trim0 )
      break;
    const ON_BrepTrim* trim1 = Trim(trim1_index[eti]);
    if ( !trim1 )
      break;
    ON_NurbsCurve* c0 = trim0->NurbsCurve();
    if ( !c0 )
      break;
    ON_NurbsCurve* c1 = trim1->NurbsCurve();
    if ( !c1 )
    {
      delete c0;
      break;
    }
    if ( trim0->m_vi[1] == vi_mid && trim1->m_vi[0] == vi_mid )
    {
      if ( !c0->Append(*c1) )
      {
        delete c0;
        delete c1;
        break;
      }
      delete c1;
      c1 = 0;
      tc.Append(c0);
    }
    else if ( trim0->m_vi[0] == vi_mid && trim1->m_vi[1] == vi_mid )
    {
      if ( !c1->Append(*c0) )
      {
        delete c0;
        delete c1;
        break;
      }
      delete c0;
      c0 = c1;
      c1 = 0;
      tc.Append(c0);
    }
  }

  if ( eti < trim_count )
  {
    delete ec;
    for ( eti = 0; eti < tc.Count(); eti++ )
      delete tc[eti];
    return 0;
  }

  // Add new edge from vi0 to vi1 that has the same orientation
  // as edge0.  Adding the new edge may change pointer values,
  // so the edge0 and edge1 pointers are reset.
  edge0 = 0;
  edge1 = 0;
  const int c3i = AddEdgeCurve(ec);
  ON_BrepEdge& edge = NewEdge( m_V[vi0], m_V[vi1], c3i );
  edge0 = Edge(ei0);
  edge1 = Edge(ei1);

	// Set edge tolerance
	if(edge0->m_tolerance<0 || edge1->m_tolerance<0)
		edge.m_tolerance= ON_UNSET_VALUE;
	else if ( edge0->m_tolerance> edge1->m_tolerance)
		edge.m_tolerance= edge0->m_tolerance;
	else 	
		edge.m_tolerance= edge1->m_tolerance;
		

  // dynamic m_T[] is grown to full size here.
  // Trim refs are good after NewTrim()
  m_T.Reserve( m_T.Count() + trim_count );
  for ( eti = 0; eti < trim_count; eti++ )
  {
    int c2i = AddTrimCurve( tc[eti] );
    ON_BrepTrim& trim0 = m_T[trim0_index[eti]];
    ON_BrepTrim& trim1 = m_T[trim1_index[eti]];
    ON_BrepTrim& trim = NewTrim( edge, trim0.m_bRev3d, c2i );
		// Set trim tolerance
		for(int i=0; i<2; i++){
			if( trim0.m_tolerance[i]<0 || trim1.m_tolerance[i]<0)
				trim.m_tolerance[i] = ON_UNSET_VALUE;
			else if(trim0.m_tolerance[i]>trim1.m_tolerance[i])
				trim.m_tolerance[i] = trim0.m_tolerance[i];
			else
				trim.m_tolerance[i] = trim1.m_tolerance[i];
		}
    trim.m_li = trim0.m_li;
    ON_BrepLoop& loop = m_L[trim.m_li];
    loop.m_ti[loop_lti0[eti]] = trim.m_trim_index;
    loop.m_ti.Remove( loop_lti1[eti] );

		//GBA 1/29/03 Fixes TRR#9233.  Removing an item from loop.m_ti
		//will cause loop indicies stored in loop_lti0[] and loop_lti1[]
		//to be wrong. So they must be reindexed
		int ri = loop_lti1[eti];			// removed index
    int li = loop.m_loop_index;
		for(int ii=0; ii<trim_count; ii++){
      if(loop_lti0[ii]>ri && m_T[trim0_index[ii]].m_li == li) 
        loop_lti0[ii]--;
			if(loop_lti1[ii]>ri && m_T[trim1_index[ii]].m_li == li) 
        loop_lti1[ii]--;
		}
		
		    
		trim.m_type = trim0.m_type;
		trim.m_iso = ON_Surface::not_iso;
		if( trim0.m_iso==trim1.m_iso) 
			trim.m_iso = trim0.m_iso;
    trim0.m_li = -1;
    trim1.m_li = -1;
  }

  // delete old edges
  DeleteEdge(m_E[ei0],true);
  DeleteEdge(m_E[ei1],true);

  return &m_E[edge.m_edge_index];
}

bool ON_Brep::GetTrimParameter(
                               int,     // trim_index          - formal parameter intentionally ignored in this virtual function
                               double,  // edge_t              - formal parameter intentionally ignored in this virtual function
                               double*, // trim_t              - formal parameter intentionally ignored in this virtual function
                               bool     // bOkToBuildTrimPline - formal parameter intentionally ignored in this virtual function
                               ) const
{
  // Rhino overrides this virtual function and makes it work
  return false;
}

bool ON_Brep::GetEdgeParameter(
                               int,    // trim_index - formal parameter intentionally ignored in this virtual function
                               double, // trim_t     - formal parameter intentionally ignored in this virtual function
                               double* // edge_t     - formal parameter intentionally ignored in this virtual function
                               ) const
{
  // Rhino overrides this virtual function and makes it work
  return false;
}

bool ON_Brep::SplitEdge(int eid, 
                        double t3d, 
                        const ON_SimpleArray<double>& t2d,
                        int vid,
                        bool bSetTrimBoxesAndFlags
                        )
{
  if ( eid > 0 )
    {
      // adjust eid from possible component index to true edge index
      const ON_BrepEdge* edge = Edge(eid);
      if ( !edge || edge->m_edge_index < 0 )
        return false;
      eid = edge->m_edge_index;
    }
  if ( vid > 0 )
    {
      // adjust vid from possible component index to true edge index
      const ON_BrepVertex* vertex = Vertex(vid);
      if ( !vertex || vertex->m_vertex_index < 0 )
        vid = -1;
      else
        vid = vertex->m_vertex_index;
    }

  if (vid == m_E[eid].m_vi[0] || vid == m_E[eid].m_vi[1])
    return true;
  if (t2d.Count() != m_E[eid].m_ti.Count())
    return false;
  m_E.Reserve(m_E.Count() + 1);
  ON_BrepEdge& Edge = m_E[eid];
  m_T.Reserve(m_T.Count()+t2d.Count());

  if (vid < 0){
    ON_3dPoint P = Edge.PointAt(t3d);
    ON_BrepVertex& NewV= NewVertex(P);
    vid = NewV.m_vertex_index;
  }

  ON_BrepVertex& NewV= m_V[vid];

  //new edge is to right of t3d
  ON_BrepEdge& NewE = NewEdge(NewV, m_V[Edge.m_vi[1]], Edge.m_c3i);
  NewE.ON_CurveProxy::operator = (Edge);
  ON_BrepVertex& OldV = m_V[Edge.m_vi[1]];
  int i;
  for (i=0; i<OldV.EdgeCount(); i++){
    if (OldV.m_ei[i] == eid){
      OldV.m_ei.Remove(i);
      break;
    }
  }

  Edge.m_vi[1] = vid;
  NewV.m_ei.Append(eid);



  //NewE.m_domain.m_t[1] = Edge.m_domain[1];
  //Edge.m_domain.m_t[1] = t3d;
  //NewE.m_domain.m_t[0] = t3d;

  NewE.ON_CurveProxy::Trim(ON_Interval(t3d, Edge.Domain()[1]));
  Edge.ON_CurveProxy::Trim(ON_Interval(Edge.Domain()[0], t3d));

  /*
  double real_t3d = Edge.RealCurveParameter(t3d);
  ON_Interval NewE_dom( real_t3d,Edge.ProxyCurveDomain()[1]);
  ON_Interval Edge_dom( Edge.ProxyCurveDomain()[0],real_t3d);
  NewE.SetProxyCurveDomain( NewE_dom );
  Edge.SetProxyCurveDomain( Edge_dom );
  NewE.SetDomain( t3d,Edge.Domain()[1] );
  Edge.SetDomain( Edge.Domain()[0],t3d );
  */

  NewE.m_tolerance = Edge.m_tolerance;

  for (i=0; i<Edge.m_ti.Count(); i++){
    ON_BrepTrim& T = m_T[Edge.m_ti[i]];
    T.m_pline.Destroy();
    T.m_pbox.Destroy();
    if (T.m_bRev3d) T.m_vi[0] = vid;
    else T.m_vi[1] = vid;
    ON_BrepTrim& NewT = NewTrim(NewE, T.m_bRev3d, T.m_c2i);
    NewT.m_pline.Destroy();
    NewT.m_pbox.Destroy();
    NewT.ON_CurveProxy::operator =(T);
    NewT.m_type = T.m_type;
    NewT.m_iso = T.m_iso;
    NewT.m_tolerance[0] = T.m_tolerance[0];
    NewT.m_tolerance[1] = T.m_tolerance[1];
    ON_BrepLoop& Loop = m_L[T.m_li];
    Loop.m_pbox.Destroy();
    NewT.m_li = T.m_li;
    int tid = 0;
    int j;
    for (j=0; j<Loop.m_ti.Count(); j++){
      if (Loop.m_ti[j] == T.m_trim_index){
        tid = j;
        break;
      }
    }

    ON_Interval left(T.Domain()[0],t2d[i]);
    ON_Interval right(t2d[i],T.Domain()[1]);

    if (!T.m_bRev3d)
      {
        //NewT.m_t.m_t[1] = T.m_t[1];
        //T.m_t.m_t[1] = NewT.m_t.m_t[0] = t2d[i];
        T.Trim(left);
        NewT.Trim(right);

        //insert NewT in Loop after T
        Loop.m_ti.Insert(tid+1, NewT.m_trim_index);
      }
    else 
      {
        //NewT.m_t.m_t[0] = T.m_t[0];
        //T.m_t.m_t[0] = NewT.m_t.m_t[1] = t2d[i];
        NewT.Trim(left);
        T.Trim(right);

        //insert NewT in Loop before T
        Loop.m_ti.Insert(tid, NewT.m_trim_index);
      }

    if (bSetTrimBoxesAndFlags && T.m_iso == ON_Surface::not_iso){
      SetTrimIsoFlags(T);
      SetTrimIsoFlags(NewT);
    }

  }

  if ( bSetTrimBoxesAndFlags )
    {
      for (i=0; i<Edge.m_ti.Count(); i++){
        ON_BrepLoop& L = m_L[m_T[Edge.m_ti[i]].m_li];
        SetTrimBoundingBoxes(L, true);
      }
    }

  return true;
}

bool ON_Brep::CombineCoincidentEdges(ON_BrepEdge& edge0, ON_BrepEdge& edge1)
{
  bool rc = false;
  if ( edge0.m_edge_index == edge1.m_edge_index ) 
  {
    ON_ERROR("ON_Brep::CombineCoincidentEdges - edge0 = edge1.");
    return rc;
  }
  int ti, eti, etcnt;
  if (    edge0.m_edge_index >= 0 
       && edge1.m_edge_index >= 0 
       && edge0.m_edge_index != edge1.m_edge_index
       && edge0.m_vi[0] == edge1.m_vi[0] 
       && edge0.m_vi[1] == edge1.m_vi[1] ) 
  {
    bool bIsGoodIso0 = false;
    if (edge0.m_tolerance == 0.0){
      for (eti=0; eti<edge0.m_ti.Count(); eti++){
        const ON_BrepTrim& T = m_T[edge0.m_ti[eti]];
        if (T.m_iso)
        {
          bIsGoodIso0 = true;
          break;
        }
      }
    }
    bool bIsGoodIso1 = false;
    if (edge1.m_tolerance == 0.0){
      for (eti=0; eti<edge1.m_ti.Count(); eti++){
        const ON_BrepTrim& T = m_T[edge1.m_ti[eti]];
        if (T.m_iso)
        {
          bIsGoodIso1 = true;
          break;
        }
      }
    }
    bool bKeep0 = (edge0.m_tolerance <= edge1.m_tolerance) ? true : false;
    if (edge0.m_tolerance == edge1.m_tolerance && edge0.m_tolerance == 0.0){
      if (bIsGoodIso1){
        if (!bIsGoodIso0)
          bKeep0 = false;
        else {//both are good.  Take the one with the lowest degree.
          if (edge1.Degree() < edge0.Degree())
            bKeep0 = false;
          else if (edge1.Degree() == edge0.Degree() && edge1.SpanCount() < edge0.SpanCount())
            bKeep0 = false;
        }
      }
    }

    ON_BrepEdge& EKeep = (bKeep0) ? edge0 : edge1;
    ON_BrepEdge& EToss = (bKeep0) ? edge1 : edge0;

    /*
    rc = true;
    etcnt = edge1.m_ti.Count();
    int tcount = m_T.Count();
    for ( eti = 0; eti < etcnt; eti++ ) {
      ti = edge1.m_ti[eti];
      if ( ti >= 0 && ti < tcount ) {
        ON_BrepTrim& trim = m_T[ti];
        trim.m_ei = edge0.m_edge_index;
        edge0.m_ti.Append(ti);
        // TODO - tolerances ?

        //set edge tolerance
        if (edge0.m_tolerance != ON_UNSET_VALUE && edge1.m_tolerance != ON_UNSET_VALUE)
          SetEdgeTolerance(edge0, false); 
        else edge0.m_tolerance = ON_UNSET_VALUE;
      }
    }
    edge1.m_ti.Destroy();
    DeleteEdge( edge1, false );

    etcnt =  edge0.m_ti.Count();
    if ( etcnt >= 2 ) for ( eti = 0; eti < etcnt; eti++ )
    {
      ti = edge0.m_ti[eti];
      if ( ti >= 0 && ti < tcount ) 
      {
        ON_BrepTrim& trim = m_T[ti];
        if ( trim.m_type == ON_BrepTrim::boundary )
          trim.m_type = ON_BrepTrim::mated;
      }
    }
    */
    rc = true;
    etcnt = EToss.m_ti.Count();
    int tcount = m_T.Count();
    for ( eti = 0; eti < etcnt; eti++ ) {
      ti = EToss.m_ti[eti];
      if ( ti >= 0 && ti < tcount ) {
        ON_BrepTrim& trim = m_T[ti];
        trim.m_ei = EKeep.m_edge_index;
        EKeep.m_ti.Append(ti);
        trim.UnsetPlineEdgeParameters();  
        // TODO - tolerances ?

        //set edge tolerance
        if (EKeep.m_tolerance != ON_UNSET_VALUE && EToss.m_tolerance != ON_UNSET_VALUE)
          SetEdgeTolerance(EKeep, false); 
        else EKeep.m_tolerance = ON_UNSET_VALUE;
      }
    }
    EToss.m_ti.Destroy();
    DeleteEdge( EToss, false );

    etcnt =  EKeep.m_ti.Count();
    if ( etcnt >= 2 ) for ( eti = 0; eti < etcnt; eti++ )
    {
      ti = EKeep.m_ti[eti];
      if ( ti >= 0 && ti < tcount ) 
      {
        ON_BrepTrim& trim = m_T[ti];
        if ( trim.m_type == ON_BrepTrim::boundary )
          trim.m_type = ON_BrepTrim::mated;
      }
    }
  }
  return rc;
}

bool ON_Brep::JoinEdges( 
                        ON_BrepEdge& edge, 
                        ON_BrepEdge& other_edge,
                        double join_tolerance,
          ON_BOOL32 bCheckFaceOrientaion
                         )
{
  double tol = ( join_tolerance == 0.0 ) ? ON_ZERO_TOLERANCE : join_tolerance;

  // since this is a user level function, do lots of checking
  // for bogus input.

  if ( edge.Brep() != this || other_edge.Brep() != this )
    return false;

  if ( edge.m_edge_index == other_edge.m_edge_index )
    return false;

  if ( tol <= 0.0 )
    return false;

  int i, j, ei, vi, ti;
  for ( i = 0; i < 2; i++ )
    {
      const ON_BrepEdge& e = i?other_edge:edge;
      ei = e.m_edge_index;
      if (ei < 0 || ei >= m_E.Count() )
        return false;
      if ( &e != m_E.Array() + ei )
        return false;
      for ( j = 0; j < 2; j++ )
        {
          vi = e.m_vi[j];
          if ( vi < 0 || vi >= m_V.Count() )
            return false;
        }
      for ( j = 0; j < e.m_ti.Count(); j++ )
        {
          ti = e.m_ti[j];
          if ( ti < 0 || ei >= m_T.Count() )
            return false;
          const ON_BrepTrim& trim = m_T[ti];
          if ( trim.m_trim_index != ti )
            return false;
          if ( trim.m_ei != e.m_edge_index )
            return false;
        }
    }

  ON_BrepVertex& v0 = m_V[edge.m_vi[0]];
  ON_BrepVertex& v1 = m_V[edge.m_vi[1]];
  ON_BrepVertex& other_v0 = m_V[other_edge.m_vi[0]];
  ON_BrepVertex& other_v1 = m_V[other_edge.m_vi[1]];

  const ON_BOOL32 bClosedEdge = (v0.m_vertex_index == v1.m_vertex_index) ? true : false;

  // both edges must be closed or both must be open
  if ( other_v0.m_vertex_index != other_v1.m_vertex_index && bClosedEdge)
    return false;
  if ( other_v0.m_vertex_index == other_v1.m_vertex_index && !bClosedEdge )
    return false;

  // bOppositeDir = true if edge and other_edge run in opposite directions.
  ON_BOOL32 bOppositeDir = false;
  if ( bClosedEdge )
    {
      // If these checks make your join fail, then you either need to
      // become an expert brep user and surgically apply
      // CombineCoincidentEdges and CombineCoincidentVertices,
      // or you need to do a better job of computing join_tolerance.
      double x = v0.point.DistanceTo( other_v0.point );
      if ( x > tol )
        return false;
      double ot1, ot2;
      ON_Interval e_dom = edge.Domain();
      double t1 = e_dom.ParameterAt(1.0/3.0);
      double t2 = e_dom.ParameterAt(2.0/3.0);
      ON_3dPoint P1 = edge.PointAt(t1);
      ON_3dPoint P2 = edge.PointAt(t2);
      if ( !other_edge.GetClosestPoint( P1, &ot1, tol ) )
        return false;
      if ( !other_edge.GetClosestPoint( P2, &ot2, tol ) )
        return false;
      if ( ot1 < ot2 )
        bOppositeDir = false;
      else if ( ot1 > ot2 )
        bOppositeDir = true;
      else
        return false;      
    }
  else
    {
      // If these checks make your join fail, then you either need to
      // become an expert brep user and surgically apply
      // CombineCoincidentEdges and CombineCoincidentVertices,
      // or you need to do a better job of computing join_tolerance.
      double x = v0.point.DistanceTo( v1.point );
      if ( x <= join_tolerance )
        return false;
      x = other_v0.point.DistanceTo( other_v1.point );
      if ( x <= join_tolerance )
        return false;
      double d0 = v0.point.DistanceTo( other_v0.point );
      double d1 = v1.point.DistanceTo( other_v1.point );
      double r0 = v0.point.DistanceTo( other_v1.point );
      double r1 = v1.point.DistanceTo( other_v0.point );

      // 0.71 is used because it is < 1 and a bit bigger than 1/sqrt(2).
      if ( d0 <= tol && d1 <= tol && d0 < 0.71*r0 && d1 < 0.71*r1 )
        bOppositeDir = false;
      else if ( r0 <= tol && r1 <= tol && r0 < 0.71*d0 && r1 < 0.71*d1 )
        bOppositeDir = true;
      else
        return false;
    }

  if ( bOppositeDir )
    other_edge.Reverse();

  if ( bCheckFaceOrientaion
       && edge.m_ti.Count() == 1 
       && other_edge.m_ti.Count() == 1 
       )
    {
      const ON_BrepTrim& trim = m_T[edge.m_ti[0]];
      const ON_BrepTrim& other_trim = m_T[other_edge.m_ti[0]];
      int fi = trim.FaceIndexOf();
      int other_fi = other_trim.FaceIndexOf();
      if (fi >= 0 && other_fi >= 0 && fi != other_fi)
        {
          bool same_trim_rev = (trim.m_bRev3d == other_trim.m_bRev3d) ? true : false;
          bool same_face_rev = (m_F[fi].m_bRev == m_F[other_fi].m_bRev) ? true : false;
          if (same_trim_rev == same_face_rev) 
            {
              // 29 May 2003 Chuck and Dale L - RR 10297
              //     Changed
              // FlipFace(m_F[other_fi])
              //   to the following component flipper.
              Clear_user_i();
              LabelConnectedComponent(other_fi,1);
              if ( 0 == m_F[fi].m_face_user.i && 1 == m_F[other_fi].m_face_user.i )
                {
                  int j;
                  for ( j = m_F.Count()-1; j >= 0; j-- )
                    {
                      if( 1 == m_F[j].m_face_user.i )
                        FlipFace(m_F[j]);
                    }
                }
              Clear_user_i();
            }
        }
    }
  
  // since we may have flipped other_edge, get these values again
  int other_vi0 = other_edge.m_vi[0];
  int other_vi1 = other_edge.m_vi[1];
  bool rc = true;
  if ( v0.m_vertex_index != other_vi0 )
    rc = CombineCoincidentVertices( v0, m_V[other_vi0] );
  if ( rc && !bClosedEdge && v1.m_vertex_index != other_vi1 )
    rc = CombineCoincidentVertices( v1, m_V[other_vi1] );
  if ( rc  )
    rc = CombineCoincidentEdges( edge, other_edge );
  return rc;
}

bool ON_Brep::Create( ON_Surface*& pS )
{
  bool rc = false;
  Destroy();
  ON_Surface* p = pS;
  if (p)
  {
    int vid[4] = {-1,-1,-1,-1};
    int eid[4] = {-1,-1,-1,-1};
    ON_BOOL32 bRev3d[4] = {0,0,0,0};
    ON_BrepFace* face = NewFace(p,vid,eid,bRev3d);
    if ( face )
    {
      rc = true;
      pS = 0;
    }
  }
  return rc;
}

/*
ON_BOOL32 ON_Brep::FaceTool( ON_Surface* pS )
{
  // private face adding tool
  if (!pS) 
    return false;
  double u[2], v[2];
  if (!pS->GetDomain(0, &u[0], &u[1])) 
      return false;
  if (!pS->GetDomain(1, &v[0], &v[1])) 
      return false;

  ON_3dPoint srf_P[2][2];
  if ( !pS->EvPoint(u[0],v[0],srf_P[0][0] )
    return false;
  if ( !pS->EvPoint(u[1],v[0],srf_P[1][0] )
    return false;
  if ( !pS->EvPoint(u[0],v[1],srf_P[0][1] )
    return false;
  if ( !pS->EvPoint(u[1],v[1],srf_P[1][1] )
    return false;

  int sw_vi, se_vi, ne_vi, nw_vi;

  m_F.Reserve( m_F.Count() + 1 );
  m_T.Reserve( m_T.Count() + 4 );
  m_L.Reserve( m_L.Count() + 1 );
  m_V.Reserve( m_V.Count() + 4 );
  m_E.Reserve( m_E.Count() + 4 );
  m_S.Reserve( m_S.Count() + 1 );
  m_C2.Reserve( m_C2.Count() + 1 );
  m_C3.Reserve( m_C3.Count() + 1 );

  sw_vi = NewVertex( srf_P[0][0], 0.0 ).m_vertex_index;

  ON_BOOL32 bIsClosed[2];
  bIsClosed[0] = pS->IsClosed(0);
  bIsClosed[1] = pS->IsClosed(1);

  ON_BOOL32 bIsSingular[4];
  bIsSingular[0] = pS->IsSingular(0);
  bIsSingular[1] = pS->IsSingular(1);
  bIsSingular[2] = pS->IsSingular(2);
  bIsSingular[3] = pS->IsSingular(3);


  if (bIsSingular[0] || bIsClosed[0]) 
    se_vi = sw_vi;
  else 
    se_vi = NewVertex( srf_P[1][0], 0.0 ).m_vertex_index;

  if (bIsSingular[1] || bIsClosed[1]) 
    ne_vi = se_vi;
  else 
    ne_vi = NewVertex( srf_P[1][1], 0.0 ).m_vertex_index;

  if (bIsSingular[2] || bIsClosed[0]) 
    nw_vi = ne_vi;
  else if (bIsSingular[3] || bIsClosed[1]) 
    nw_vi = sw_vi;
  else 
    nw_vi = NewVertex( srf_P[0][1], 0.0 ).m_vertex_index;

  ON_BrepVertex& sw_vertex = m_V[sw_vi];
  ON_BrepVertex& se_vertex = m_V[se_vi];
  ON_BrepVertex& ne_vertex = m_V[ne_vi];
  ON_BrepVertex& nw_vertex = m_V[nw_vi];

  ON_BrepFace& face = NewFace(AddSurface(pS));
  ON_BrepLoop& loop = NewLoop(ON_BrepLoop::outer, face);

  loop.m_pbox.m_min.x = u[0];
  loop.m_pbox.m_min.y = v[0];
  loop.m_pbox.m_min.z = 0.0;

  loop.m_pbox.m_max.x = u[1];
  loop.m_pbox.m_max.y = v[1];
  loop.m_pbox.m_max.z = 0.0;

  int id3[4] = {-1,-1,-1,-1};
  int eid[4] = {-1,-1,-1,-1};
  int c2i;

  ON_2dPoint sw_corner(u[0],v[0]);
  ON_2dPoint se_corner(u[1],v[0]);
  ON_2dPoint ne_corner(u[1],v[1]);
  ON_2dPoint nw_corner(u[0],v[1]);

  {//south side
    c2i = AddTrimCurve(new ON_LineCurve(sw_corner,se_corner));
    if (bIsSingular[0]) {
      NewSingularTrim(sw_vertex,loop,ON_Surface::S_iso,c2i);
    }
    else {
      id3[0] = AddEdgeCurve( pS->IsoCurve(0, v[0]) );
      ON_BrepEdge& edge = NewEdge(sw_vertex, se_vertex, id3[0]);
      edge.m_tolerance = 0.0;
      eid[0] = edge.m_edge_index;
      ON_BrepTrim& trim = NewTrim(edge, false, loop, c2i);
      trim.m_iso = ON_Surface::S_iso;
      if (bIsClosed[1]) 
        trim.m_type = ON_BrepTrim::seam;
      else 
        trim.m_type = ON_BrepTrim::boundary;
    }
  }

  { //east side
    c2i = AddTrimCurve(new ON_LineCurve(se_corner,ne_corner));
    if (bIsSingular[1]) {
      NewSingularTrim(se_vertex,loop,ON_Surface::E_iso,c2i);
    }
    else {
      id3[1] = AddEdgeCurve(pS->IsoCurve(1, u[1]));
      ON_BrepEdge& edge = NewEdge(se_vertex, ne_vertex, id3[1]);
      edge.m_tolerance = 0.0;
      eid[1] = edge.m_edge_index;
      ON_BrepTrim& trim = NewTrim(edge, false, loop, c2i);
      trim.m_iso = ON_Surface::E_iso;
      if (bIsClosed[0]) 
        trim.m_type = ON_BrepTrim::seam;
      else 
        trim.m_type = ON_BrepTrim::boundary;
    }
  }

  { //north side
    c2i = AddTrimCurve(new ON_LineCurve(ne_corner,nw_corner));
    ON_BOOL32 rev = false;
    if (bIsSingular[2]) {
      NewSingularTrim(ne_vertex,loop,ON_Surface::N_iso,c2i);
    }
    else{
      if (bIsClosed[1]) {
        id3[2] = id3[0];
        eid[2] = eid[0];
        rev = true;
      }
      else {
        ON_Curve* pC3 = pS->IsoCurve(0, v[1]);
        if (pC3) pC3->Reverse();
        id3[2] = AddEdgeCurve(pC3);
        ON_BrepEdge& edge = NewEdge(ne_vertex, nw_vertex, id3[2]);
        edge.m_tolerance = 0.0;
        eid[2] = edge.m_edge_index;
      }
      ON_BrepTrim& trim = NewTrim(m_E[eid[2]], rev, loop, c2i);
      trim.m_iso = ON_Surface::N_iso;
      if (bIsClosed[1]) 
        trim.m_type = ON_BrepTrim::seam;
      else 
        trim.m_type = ON_BrepTrim::boundary;
    }
  }

  { //west side
    c2i = AddTrimCurve(new ON_LineCurve(nw_corner,sw_corner));
    ON_BOOL32 rev = false;
    if (bIsSingular[3]){
      NewSingularTrim(nw_vertex,loop,ON_Surface::W_iso,c2i);
    }
    else {
      if (bIsClosed[0]){
      id3[3] = id3[1];
        eid[3] = eid[1];
        rev = true;
      }
      else {
        ON_Curve* pC3 = pS->IsoCurve(1, u[0]);
        if (pC3) pC3->Reverse();
        id3[3] = AddEdgeCurve(pC3);
        ON_BrepEdge& edge = NewEdge(nw_vertex, sw_vertex, id3[3]);
        edge.m_tolerance = 0.0;
        eid[3] = edge.m_edge_index;
      }
      ON_BrepTrim& trim = NewTrim( m_E[eid[3]], rev, loop, c2i );
      trim.m_iso = ON_Surface::W_iso;
      if (bIsClosed[0]) 
        trim.m_type = ON_BrepTrim::seam;
      else 
        trim.m_type = ON_BrepTrim::boundary;
    }
  }

  for ( int lti = 0; lti < 4; lti++ )
  {
    ti = loop.m_ti[lti];
    ON_BrepTrim& trim = m_T[ti];
    trim.m_tolerance[0] = 0.0;
    trim.m_tolerance[1] = 0.0;
    trim.m__legacy_2d_tol = 0.0;
    trim.m__legacy_3d_tol = 0.0;
    trim.m__legacy_flags_Set(-1,1);
  }

  return true;
}
*/

bool ON_Brep::Create( ON_NurbsSurface*& pNurbsSurface )
{
  ON_Surface* pSurface = pNurbsSurface;
  bool rc = Create(pSurface);
  if ( !pSurface )
    pNurbsSurface = 0;
  return rc;
}

bool ON_Brep::Create( ON_PlaneSurface*& pPlaneSurface )
{
  ON_Surface* pSurface = pPlaneSurface;
  bool rc = Create(pSurface);
  if ( !pSurface )
    pPlaneSurface = 0;
  return rc;
}

bool ON_Brep::Create( ON_RevSurface*& pRevSurface )
{
  ON_Surface* pSurface = pRevSurface;
  bool rc = Create(pSurface);
  if ( !pSurface )
    pRevSurface = 0;
  return rc;
}

bool ON_Brep::Create( ON_SumSurface*& pSumSurface )
{
  ON_Surface* pSurface = pSumSurface;
  bool rc = Create(pSurface);
  if ( !pSurface )
    pSumSurface = 0;
  return rc;
}


ON_BOOL32 ON_Brep::HasBrepForm() const
{
  return true;
}

ON_Brep* ON_Brep::BrepForm( ON_Brep* brep ) const
{
  if ( brep )
  {
    if ( brep != this )
      *brep = *this;      
  }
  else
  {
    brep = new ON_Brep(*this);
  }
  return brep;
}

void ON_Brep::Clear_vertex_user_i()
{
  int vi;
  int vertex_count = m_V.Count();
  for ( vi = 0; vi < vertex_count; vi++ ) 
  {
    memset(&m_V[vi].m_vertex_user,0,sizeof(ON_U));
  }
}

void ON_Brep::Clear_edge_user_i()
{
  int ei;
  int edge_count = m_E.Count();
  for ( ei = 0; ei < edge_count; ei++ ) 
  {
    memset(&m_E[ei].m_edge_user,0,sizeof(ON_U));
  }
}

void ON_Brep::Clear_edge_user_i(int i)
{
  int ei;
  int edge_count = m_E.Count();
  for ( ei = 0; ei < edge_count; ei++ ) 
  {
    memset(&m_E[ei].m_edge_user,0,sizeof(ON_U));
    m_E[ei].m_edge_user.i = i;
  }
}

void ON_Brep::Clear_trim_user_i()
{
  int ti;
  int trim_count = m_T.Count();
  for ( ti = 0; ti < trim_count; ti++ ) {
    memset(&m_T[ti].m_trim_user,0,sizeof(ON_U));
  }
}

void ON_Brep::Clear_loop_user_i()
{
  int li;
  int loop_count = m_L.Count();
  for ( li = 0; li < loop_count; li++ ) {
    memset(&m_L[li].m_loop_user,0,sizeof(ON_U));
  }
}

void ON_Brep::Clear_face_user_i()
{
  int fi;
  int face_count = m_F.Count();
  for ( fi = 0; fi < face_count; fi++ ) {
    memset(&m_F[fi].m_face_user,0,sizeof(ON_U));
  }
}

void ON_Brep::Clear_user_i()
{
  memset(&m_brep_user,0,sizeof(m_brep_user));
  Clear_vertex_user_i();
  Clear_edge_user_i();
  Clear_trim_user_i();
  Clear_loop_user_i();
  Clear_face_user_i();
}

void ON_Brep::Set_user(ON_U u)
{
  int i, count;
  m_brep_user=u;
  
  count = m_V.Count();
  ON_BrepVertex* V = m_V.Array();
  for ( i = 0; i < count; i++ )
  {
    V[i].m_vertex_user = u;
  }
  
  count = m_E.Count();
  ON_BrepEdge* E = m_E.Array();
  for ( i = 0; i < count; i++ )
  {
    E[i].m_edge_user = u;
  }

  
  count = m_T.Count();
  ON_BrepTrim* T = m_T.Array();
  for ( i = 0; i < count; i++ )
  {
    T[i].m_trim_user = u;
  }
  
  count = m_L.Count();
  ON_BrepLoop* L = m_L.Array();
  for ( i = 0; i < count; i++ )
  {
    L[i].m_loop_user = u;
  }
  
  count = m_F.Count();
  ON_BrepFace* F = m_F.Array();
  for ( i = 0; i < count; i++ )
  {
    F[i].m_face_user = u;
  }
}



ON_BrepVertex& ON_Brep::NewPointOnFace( 
  ON_BrepFace& face,
  double s,
  double t
  )
{
  ON_3dPoint point = face.PointAt(s,t);
  
  ON_BrepVertex& vertex = NewVertex( point );
  ON_BrepLoop& loop = NewLoop( ON_BrepLoop::ptonsrf, face );
  ON_BrepTrim& trim = NewTrim(false,loop,-1);

  vertex.m_tolerance = 0.0;
  trim.m_type = ON_BrepTrim::ptonsrf;
  trim.m_pbox.m_min.Set(s,t,0.0);
  trim.m_pbox.m_max.Set(s,t,0.0);
  trim.m_tolerance[0] = 0.0;
  trim.m_tolerance[1] = 0.0;
  loop.m_pbox = trim.m_pbox;
  trim.m_vi[0] = trim.m_vi[1] = vertex.m_vertex_index;

  return vertex;
}


ON_BrepTrim& ON_Brep::NewCurveOnFace( ON_BrepFace& face, ON_BrepEdge& edge, ON_BOOL32 bRev3d, int c2i )
{
  ON_BrepLoop& loop = NewLoop( ON_BrepLoop::crvonsrf, face );
  ON_BrepTrim& trim = NewTrim( edge, bRev3d, loop, c2i );
  trim.m_type = ON_BrepTrim::crvonsrf;
  const ON_Curve* trimcurve = trim.TrimCurveOf();
  if (trimcurve)
  {
    trimcurve->GetBoundingBox( trim.m_pbox );
    loop.m_pbox = trim.m_pbox;
  }
  return trim;
}

//For each i, let ti be the parameter along the chord (Points[0], Points[last])
//of the closest point to Points[i], and let di be the distance to the chord.
//Transform Points so that Points[0] = P0, Points[last] = P1, 
//and the new ti and di remain the same.  Don't do anything if the chord is short 
//relative to the cummulative dist between consecutive points on input.

static bool AdjustPointListAlongChord(ON_3dPointArray& Points, 
                                      const ON_3dPoint& P0, 
                                      const ON_3dPoint& P1)

{
  int count = Points.Count();
  if (count < 2)
    return false;

  ON_3dPoint A0 = Points[0];
  ON_3dPoint A1 = Points[count-1];
  double chord_dist = A0.DistanceTo(A1);
  if (chord_dist < ON_SQRT_EPSILON)
    return false;
  double cum_dist = 0.0;
  int i; 
  for (i=1; i<count; i++)
    cum_dist += Points[i-1].DistanceTo(Points[i]);
  if (chord_dist < 0.01*cum_dist)
    return false;
  ON_3dVector V0 = P0-A0;
  ON_3dVector V1 = P1-A1;
  ON_Line Aline(A0, A1);
  Points[0] = P0;
  Points[count-1] = P1;
  for (i=1; i<count-1; i++){
    double t;
    Aline.ClosestPointTo(Points[i], &t);
    Points[i] = Points[i] + (1.0-t)*V0 + t*V1;
  }
  return true;
}

static void AdjustNurbsCurve(ON_NurbsCurve& crv,
                             const ON_3dPoint& P0, 
                             const ON_3dPoint& P1)

{
  if (crv.Dimension() > 3)
    return;

  crv.ClampEnd(2);
  int cvc = crv.CVCount();
  ON_3dPointArray Points(cvc);
  int i;
  for (i=0; i<cvc; i++)
    crv.GetCV(i, Points.AppendNew());

  if (!AdjustPointListAlongChord(Points, P0, P1)){
    crv.SetStartPoint(P0);
    crv.SetEndPoint(P1);
    return;
  }

  bool rat = crv.IsRational();
  for (i=0; i<cvc; i++){
    double w = 1.0;
    if (rat){
      w = crv.Weight(i);
      Points[i] *= w;
    }
    crv.SetCV(i, Points[i]);
    if (rat)
      crv.SetWeight(i, w);
  }
  
  return;
}

static void AdjustPolylineCurve(ON_PolylineCurve& crv,
                             const ON_3dPoint& P0, 
                             const ON_3dPoint& P1)

{
  AdjustPointListAlongChord(crv.m_pline, P0, P1);
  crv.SetStartPoint(P0);
  crv.SetEndPoint(P1);
  return;
}

static void AdjustCurve(ON_Curve& crv, 
                        const ON_3dPoint& P0,
                        const ON_3dPoint& P1);

static void AdjustPolyCurve(ON_PolyCurve& crv,
                             const ON_3dPoint& P0, 
                             const ON_3dPoint& P1)

{

  if (crv.Count() == 1){
    ON_Curve* pSeg = crv.SegmentCurve(0);
    if (!pSeg)
      return;
    AdjustCurve(*pSeg, P0, P1);
    return;
  }

  ON_3dPointArray Points(crv.Count() + 1);
  Points.Append(crv.PointAtStart());

  int i;
  for (i=0; i<crv.Count(); i++)
    Points.Append(crv.SegmentCurve(i)->PointAtEnd());

  if (!AdjustPointListAlongChord(Points, P0, P1)){
    crv.SetStartPoint(P0);
    crv.SetEndPoint(P1);
    return;
  }

  for (i=0; i<crv.Count(); i++){
    ON_Curve* pSeg = crv.SegmentCurve(i);
    if (!pSeg)
      return;
    AdjustCurve(*pSeg, Points[i], Points[i+1]);
    Points[i+1] = pSeg->PointAtEnd();
  }

  return;
}

//Afterwards it is up to caller to check to see if the endpoints are where they should be.
static void AdjustCurve(ON_Curve& crv, 
                        const ON_3dPoint& P0,
                        const ON_3dPoint& P1)

{
  ON_LineCurve* lc = ON_LineCurve::Cast(&crv);
  if (lc){
    lc->SetStartPoint(P0);
    lc->SetEndPoint(P1);
    return;
  }

  ON_CurveProxy* pc = ON_CurveProxy::Cast(&crv);
  if (pc)
    return;

  if (crv.IsClosed()){
    if (P0 != P1)
      return;
    ON_3dPoint P = crv.PointAtStart();
    ON_3dVector TVec = P0-P;
    if (TVec.Length() > ON_SQRT_EPSILON){
      ON_Xform T;
      T.Translation(TVec);
      crv.Transform(T);
    }
    return;
  }

  ON_PolylineCurve* plc = ON_PolylineCurve::Cast(&crv);
  if (plc) {
    AdjustPolylineCurve(*plc, P0, P1);
    return;
  }

  ON_NurbsCurve* nc = ON_NurbsCurve::Cast(&crv);
  if (nc){
    AdjustNurbsCurve(*nc, P0, P1);
    return;
  }

  ON_PolyCurve* plyc = ON_PolyCurve::Cast(&crv);
  if (plyc){
    AdjustPolyCurve(*plyc, P0, P1);
    return;
  }

  ON_3dPoint A0 = crv.PointAtStart();
  ON_3dPoint A1 = crv.PointAtEnd();

  if (A0.DistanceTo(P0) < ON_SQRT_EPSILON && A1.DistanceTo(P1) < ON_SQRT_EPSILON){
    crv.SetStartPoint(P0);
    crv.SetEndPoint(P1);
    return;
  }

  double alen = A0.DistanceTo(A1);
  double plen = P0.DistanceTo(P1);
  if (alen < 0.1*plen || plen < 0.1*alen){
    crv.SetStartPoint(P0);
    crv.SetEndPoint(P1);
    return;
  }

  ON_3dPoint Ac = 0.5*(A0+A1);
  ON_3dPoint Pc = 0.5*(P0+P1);
  ON_3dVector TVec = Pc-Ac;
  if (TVec.Length() > ON_SQRT_EPSILON){
    ON_Xform T;
    T.Translation(TVec);
    crv.Transform(T);
  }

  A0 = crv.PointAtStart();
  A1 = crv.PointAtEnd();
  if (A0.DistanceTo(P0) < ON_SQRT_EPSILON && A1.DistanceTo(P1) < ON_SQRT_EPSILON){
    crv.SetStartPoint(P0);
    crv.SetEndPoint(P1);
    return;
  }

  if (fabs(plen - alen) > ON_SQRT_EPSILON){
    double scale = plen/alen;
    Ac = 0.5*(A0+A1);
    ON_Xform T;
    T.Scale(Ac, scale);
    crv.Transform(T);
  }

  A0 = crv.PointAtStart();
  A1 = crv.PointAtEnd();
  if (A0.DistanceTo(P0) < ON_SQRT_EPSILON && A1.DistanceTo(P1) < ON_SQRT_EPSILON){
    crv.SetStartPoint(P0);
    crv.SetEndPoint(P1);
    return;
  }

  if (plen < ON_SQRT_EPSILON){
    crv.SetStartPoint(P0);
    crv.SetEndPoint(P1);
    return;
  }

  ON_3dPoint C = 0.5*(Pc+Ac);
  ON_3dVector VA = A0-C;
  VA.Unitize();
  ON_3dVector VP = P0-C;
  VP.Unitize();

  ON_3dVector Axis = ON_CrossProduct(VA, VP);
  double sina = Axis.Length();
  if (sina < ON_SQRT_EPSILON){
    crv.SetStartPoint(P0);
    crv.SetEndPoint(P1);
    return;
  }
  Axis.Unitize();
  double cosa = VA*VP;

  ON_Xform T;
  T.Rotation(sina, cosa, Axis, C);
  crv.Transform(T);
  crv.SetStartPoint(P0);
  crv.SetEndPoint(P1);
  return;
  }

static void AdjustEdgeEnds(ON_BrepEdge& edge)

{
  ON_Brep* pB = edge.Brep();
  if (!pB)
    return;
  ON_Curve* c3 = const_cast<ON_Curve*>(edge.EdgeCurveOf());
  if( c3 )
  {
    ON_3dPoint A0 = c3->PointAtStart();
    ON_3dPoint P0 = A0;
    if (edge.m_vi[0] >= 0){
      ON_BrepVertex& V = pB->m_V[edge.m_vi[0]];
      if (V.IsValid())
        P0 = V.Point();
    }
    ON_3dPoint A1 = c3->PointAtEnd();
    ON_3dPoint P1 = A1;
    if (edge.m_vi[1] >= 0){
      ON_BrepVertex& V = pB->m_V[edge.m_vi[1]];
      if (V.IsValid())
        P1 = V.Point();
    }

    bool bQuit = true;
    if (P0 != A0 && edge.m_vi[0] >= 0){
      ON_BrepVertex& V = pB->m_V[edge.m_vi[0]];
      V.m_tolerance = ON_UNSET_VALUE;
      bQuit = false;
    }
    if (P1 != A1 && edge.m_vi[1] >= 0){
      ON_BrepVertex& V = pB->m_V[edge.m_vi[1]];
      V.m_tolerance = ON_UNSET_VALUE;
      bQuit = false;
    }
    if (bQuit)
      return;

    edge.m_tolerance = ON_UNSET_VALUE;
    AdjustCurve(*c3, P0, P1);
  }
  return;
}

bool ON_Brep::StandardizeEdgeCurve( int edge_index, bool bAdjustEnds )
{
  return StandardizeEdgeCurve(edge_index, bAdjustEnds, 0);
}

bool ON_Brep::StandardizeEdgeCurve( int edge_index, bool bAdjustEnds, int EdgeCurveUse )
{
  bool rc = false;
  ON_BrepEdge* edge = Edge(edge_index);
  if ( 0 != edge && edge->m_edge_index >= 0 )
  {
    edge_index = edge->m_edge_index;
    const ON_Curve* c3 = edge->EdgeCurveOf();
    if( c3 )
    {
      ON_Interval c3dom = c3->Domain();
      ON_Interval pdom = edge->ProxyCurveDomain();
      ON_Interval edom = edge->Domain();
      bool bNewCurve = false;
      if ( edge->ProxyCurveIsReversed() )
        bNewCurve = true;
      else if ( c3dom != pdom )
        bNewCurve = true; // curve proxy is trimmed
      else if ( EdgeCurveUse > 1 || (EdgeCurveUse < 1 && EdgeCurveUseCount( edge->m_c3i,2 ) > 1 ))
        bNewCurve = true; // 2 or more edges use c3
      else if ( edom != c3dom )
      {
        // can fix this problem by changing c3 domain
        // and proxy settings
        if ( m_C3[edge->m_c3i]->SetDomain(edom) )
        {
          edge->SetProxyCurveDomain(edom);
          edge->SetDomain(edom);
          rc = true;
        }
        else
        {
          bNewCurve = true;
        }
      }
      else
        rc = true;
      
      if ( bNewCurve )
      {
        ON_Curve* newc3 = c3->Duplicate();
        if ( !newc3 )
          return false;
        if ( !newc3->Trim(pdom) )
        {
          delete newc3;
          return false;
        }
        if ( edge->ProxyCurveIsReversed() )
        {
          if ( !newc3->Reverse() )
          {
            delete newc3;
            return false;
          }
        }
        newc3->SetDomain(edom);
        if ( newc3->Domain() != edom )
        {
          delete newc3;
          return false;
        }
        int c3i = AddEdgeCurve(newc3);
        edge->m_c3i = c3i;
        edge->SetProxyCurve(newc3);
      }
    }
  }
  if (rc && bAdjustEnds)
    AdjustEdgeEnds(*edge);
    /*
  {
    ON_Curve* c3 = const_cast<ON_Curve*>(edge->EdgeCurveOf());
    if( c3 )
    {
      if (edge->m_vi[0] >= 0)
      {
        const ON_BrepVertex& V = m_V[edge->m_vi[0]];
        if (V.IsValid())
          c3->SetStartPoint(V.Point());
      }
      if (edge->m_vi[1] >= 0)
      {
        const ON_BrepVertex& V = m_V[edge->m_vi[1]];
        if (V.IsValid())
          c3->SetEndPoint(V.Point());
      }
    }
  }
  */

  return rc;
} 

static int sort_ci(const ON_BrepEdge* E0, const ON_BrepEdge* E1)

{
  if (E0->m_c3i < E1->m_c3i)
    return -1;
  if (E0->m_c3i < E1->m_c3i)
    return 1;
  return 0;
}


void ON_Brep::StandardizeEdgeCurves( bool bAdjustEnds)
{

  //The ends will not adjust properly unless 
  //all of the edge curves have been standardized first.
  //So call standardize on all edges without adjusting, then do the adjusting
  //chuck - 9/5/2006
  int ei, edge_count = m_E.Count();


  //chuck - 10/13/2008.  The edge curve use counter called in StandardizeEdgeCurves(int,bool)
  //searches through the entire edge array.  In huge breps, this takes a long time.
  int* index = (int*)onmalloc(edge_count*sizeof(int));
  m_E.Sort(ON::quick_sort, index, sort_ci);

  for ( ei = 0; ei < edge_count; ei++ ){
    int ecc = (ei==edge_count-1 || m_E[index[ei+1]].m_c3i == m_E[index[ei]].m_c3i) ? 2 : 1;
    StandardizeEdgeCurve( index[ei], false, ecc);
  }

  onfree((void*)index);

  /*
  for ( ei = 0; ei < edge_count; ei++ )
  {
    StandardizeEdgeCurve( ei, false );
  }
  */

  if (bAdjustEnds){
    for ( ei = 0; ei < edge_count; ei++ )
      AdjustEdgeEnds(m_E[ei]);
    SetVertexTolerances(true);
    SetEdgeTolerances(true);
  }
}

bool ON_Brep::StandardizeTrimCurve( int trim_index )
{
  bool rc = false;
  ON_BrepTrim* trim = Trim(trim_index);
  if ( 0 != trim && trim->m_trim_index >= 0 )
  {
    trim_index = trim->m_trim_index;
    const ON_Curve* c2 = trim->TrimCurveOf();
    if( c2 )
    {
      ON_Interval c2dom = c2->Domain();
      ON_Interval pdom = trim->ProxyCurveDomain();
      ON_Interval tdom = trim->Domain();
      bool bNewCurve = false;
      if ( trim->ProxyCurveIsReversed() )
        bNewCurve = true;
      else if ( c2dom != pdom )
        bNewCurve = true; // curve proxy is trimmed
      else if ( TrimCurveUseCount( trim->m_c2i, 2 ) > 1 )
        bNewCurve = true; // 2 or more edges use c3
      else if ( tdom != c2dom )
      {
        // can fix this problem by changing c3 domain
        // and proxy settings
        if ( m_C2[trim->m_c2i]->SetDomain(tdom) )
        {
          trim->SetProxyCurveDomain(tdom);
          trim->SetDomain(tdom);
          rc = true;
        }
        else
        {
          bNewCurve = true;
        }
      }
      else
        rc = true;
      
      if ( bNewCurve )
      {
        ON_Curve* newc2 = c2->Duplicate();
        if ( !newc2 )
          return false;
        if ( !newc2->Trim(pdom) )
        {
          delete newc2;
          return false;
        }
        if ( trim->ProxyCurveIsReversed() )
        {
          if ( !newc2->Reverse() )
          {
            delete newc2;
            return false;
          }
        }
        newc2->SetDomain(tdom);
        if ( newc2->Domain() != tdom )
        {
          delete newc2;
          return false;
        }
        int c2i = AddTrimCurve(newc2);
        trim->m_c2i = c2i;
        trim->SetProxyCurve(newc2);
        rc = true;
      }
    }
  }
  return rc;
}

void ON_Brep::StandardizeTrimCurves()
{
  int ti, trim_count = m_T.Count();
  for ( ti = 0; ti < trim_count; ti++ )
  {
    StandardizeTrimCurve( ti );
  }
}

bool ON_Brep::StandardizeFaceSurface( int face_index )
{
  bool rc = false;
  ON_BrepFace* face = Face(face_index);
  if ( 0 != face && face->m_face_index >= 0 )
  {
    face_index = face->m_face_index;
    const ON_Surface* srf = face->SurfaceOf();
    if ( srf )
    {
      if ( face->m_bRev )
      {
        if ( SurfaceUseCount( face->m_si, 2 ) >= 2 )
        {
          ON_Surface* newsrf = srf->Duplicate();
          face->m_si = AddSurface(newsrf);
          face->SetProxySurface(m_S[face->m_si]);
          srf = newsrf;
        }
        rc = face->Transpose() ? true : false;
      }
      else
        rc = true;
    }
  }
  return rc;
}

void ON_Brep::StardardizeFaceSurfaces()
{
  // StardardizeFaceSurfaces() - misspelled function is obsolte
  // but left here to avoid breaking the SDK.
  StandardizeFaceSurfaces();
}

void ON_Brep::StandardizeFaceSurfaces()
{
  int fi, face_count = m_F.Count();
  for ( fi = 0; fi < face_count; fi++ )
  {
    StandardizeFaceSurface( fi );
  }
}

void ON_Brep::Standardize()
{
  StandardizeFaceSurfaces();
  StandardizeEdgeCurves(true);
  StandardizeTrimCurves();
}



bool ON_Brep::ShrinkSurface( ON_BrepFace& face, int DisableMask )
{
  ON_Surface* srf = const_cast<ON_Surface*>(face.SurfaceOf());
  if ( !srf )
    return false;

  ON_Interval srf_udom = srf->Domain(0);
  ON_Interval srf_vdom = srf->Domain(1);

  int fli, li, si=-1;
  int lti, ti;
  int outer_loop_li=-1;
  const int loop_count = m_L.Count();
  const int trim_count = m_T.Count();
  ON_BoundingBox outer_pbox;

  bool bAllTrimsAreIsoTrims = true; 
  bool bSomeTrimsAreIsoTrims = false;

  // 4 April 2003 Dale Lear:
  //    Shrink srf fix.
  ON_BoundingBox trim_iso_endbox; // bounding box of iso curve trim ends

  int face_loop_count = face.m_li.Count();
  bool bIsSrfEdge[4];
  int sei;
  for (sei=0; sei<4; sei++)
    bIsSrfEdge[sei] = false;
  for ( fli = 0; fli < face_loop_count; fli++ )
  {
    li = face.m_li[fli];
    if ( li < 0 )
      continue;
    if ( li >= loop_count )
      continue;
    const ON_BrepLoop& loop = m_L[li];
    if ( loop.m_type == ON_BrepLoop::outer )
    {
      // may be more than one outer loop
      if ( outer_loop_li )
        outer_loop_li = li;
      outer_pbox.Union( loop.m_pbox );

      int loop_trim_count = loop.m_ti.Count();
      for ( lti = 0; lti < loop_trim_count; lti++ )
      {
        ti = loop.m_ti[lti];
        if ( ti >= 0 && ti < trim_count )
        {
          bool bIsIso = false;
          switch( m_T[ti].m_iso )
          {
          case ON_Surface::x_iso:
          case ON_Surface::y_iso:
            bIsIso = true;
            break;
          case ON_Surface::W_iso:
            bIsIso = true;
            bIsSrfEdge[0] = true;
            break;
          case ON_Surface::S_iso:
            bIsIso = true;
            bIsSrfEdge[1] = true;
            break;
          case ON_Surface::E_iso:
            bIsIso = true;
            bIsSrfEdge[2] = true;
            break;
          case ON_Surface::N_iso:
            bIsIso = true;
            bIsSrfEdge[3] = true;
            break;
          default:
            // it's not an iso curve trim
            bAllTrimsAreIsoTrims = false;
          }
          if (bIsIso){
            // it's an iso curve trim
            trim_iso_endbox.Set( m_T[ti].PointAtStart(), true );
            trim_iso_endbox.Set( m_T[ti].PointAtEnd(), true );
            bSomeTrimsAreIsoTrims = true;
          }
        }
      }

    }
  }

  if ( !outer_pbox.IsValid() )
    return false;
  
  bool rc = false;
  ON_Interval outer_udom( outer_pbox.m_min.x, outer_pbox.m_max.x );
  ON_Interval outer_vdom( outer_pbox.m_min.y, outer_pbox.m_max.y );

  if ( !bAllTrimsAreIsoTrims )
  {
    // 4 April 2003 Dale Lear:
    //    Prevent shrinking surface to
    //    interior edge of wiggly trims so that
    //    3d edge curves will pullback correctly and
    //    brep-brep intersections will be
    //    transverse along complicated trims.
    double d;

    d = outer_udom.Length()*0.01;
    if ( (!bSomeTrimsAreIsoTrims || outer_udom[0] < trim_iso_endbox.m_min.x) && !bIsSrfEdge[0] )
      outer_udom[0] -= d;
    if ( (!bSomeTrimsAreIsoTrims || outer_udom[1] > trim_iso_endbox.m_max.x) && !bIsSrfEdge[2])
      outer_udom[1] += d;

    d = outer_vdom.Length()*0.01;
    if ( (!bSomeTrimsAreIsoTrims || outer_vdom[0] < trim_iso_endbox.m_min.y) && !bIsSrfEdge[1] )
      outer_vdom[0] -= d;
    if ( (!bSomeTrimsAreIsoTrims || outer_vdom[1] > trim_iso_endbox.m_max.y) && !bIsSrfEdge[3] )
      outer_vdom[1] += d;
  }

  outer_udom.Intersection( srf_udom );
  outer_vdom.Intersection( srf_vdom );

  bool bShrinkIt = false;

  /*
  // removed 4 April 2003 Dale Lear
  if ( outer_udom.IsIncreasing() && outer_vdom.IsIncreasing() )
  {
    if ( outer_udom.Length() < 0.99*srf_udom.Length() || outer_vdom.Length() < 0.99*srf_vdom.Length())
    {
      bShrinkIt = true;
    }
    else if ( outer_udom.Length() < srf_udom.Length() || outer_vdom.Length() < srf_vdom.Length())
    {
      // 13 Feb 2003 Dale Lear added this --
      // if all trims are isos, then perform micro shrink
      // so iso trims will lie on surface boundaries
      bShrinkIt = bAllTrimsAreIsoTrims;
    }
  }
  */

  // GBA 8 May 2006.  Added DiasbleMask 
  if( DisableMask & 0x0001)     // West
    outer_udom[0] = srf_udom[0];
  if( DisableMask & 0x0002)     // South
    outer_vdom[0] = srf_vdom[0];
  if( DisableMask & 0x0004)     // East
    outer_udom[1] = srf_udom[1];
  if( DisableMask & 0x0008)     // North
    outer_vdom[1] = srf_vdom[1];


  // added 4 April 2003 Dale Lear
  if ( outer_udom.IsIncreasing() && outer_vdom.IsIncreasing() )
  {
    //TRR #33381 28-April-08 GBA
    //  Make sure we don't keep allowing the surface to be shrunk.
    if ( outer_udom.Length()*ON_ZERO_TOLERANCE < (srf_udom.Length() - outer_udom.Length()) || 
         outer_vdom.Length()*ON_ZERO_TOLERANCE < (srf_vdom.Length() - outer_vdom.Length())  )  
      bShrinkIt = true;
  }

  if ( bShrinkIt )
  {
    int srf_use = SurfaceUseCount( face.m_si, 2);
    ON_Surface* small_srf = srf->Duplicate();
    if ( small_srf->Trim( 0, outer_udom ) )
    {
      if ( small_srf->Trim( 1, outer_vdom) )
        si = AddSurface(small_srf);
      if ( si >= 0 )
      {
				int srf_index = face.m_si;
        face.m_si = si;
        face.SetProxySurface( m_S[face.m_si] );

        // 5 Dec 2002 Chuck - dont delete original surface if used by more than one face
				if (srf_use == 1) DeleteSurface(srf_index);

        // 1 Nov 2002 Dale Lear - reset face bbox and destroy brep too big bounding box
        face.m_bbox = small_srf->BoundingBox();
        m_bbox.Destroy();

				// Set trim.m_iso flags
				for(int li=0; li<face.LoopCount(); li++){
					ON_BrepLoop& loop = *face.Loop(li);
					for(int ti=0; ti<loop.TrimCount(); ti++){
						ON_BrepTrim& trim = *loop.Trim(ti);
            //Since the slop used in calculating m_iso depends on the srf domain
            //all isos should be rechecked after shrinking

            /*
						if(	trim.m_iso==ON_Surface::x_iso || 
								trim.m_iso==ON_Surface::y_iso )
                */
            if (trim.m_iso != ON_Surface::not_iso)
							trim.m_iso = face.IsIsoparametric(trim);	
					}
				}
        rc = true;
      }
    }
    if ( !rc )
      delete small_srf;
  }

  return rc;
}

bool ON_Brep::ShrinkSurfaces()
{
  bool rc = true;
  int fi, face_count = m_F.Count();
  for ( fi = 0; fi < face_count; fi++ )
  {
    if ( !ShrinkSurface( m_F[fi] ) )
      rc = false;
  }
	Compact();
  return rc;
}

/*
int ON_Brep::ComponentIndex( const ON_BrepVertex& vertex ) const
{
  int component_index = vertex.m_vertex_index;
  if ( component_index >= 0 )
    component_index += brep_vertex;
  else
    component_index = -1;
  return component_index;
}

int ON_Brep::ComponentIndex( const ON_BrepEdge& edge ) const
{
  int component_index = edge.m_edge_index;
  if ( component_index >= 0 )
    component_index += brep_edge;
  else
    component_index = -1;
  return component_index;
}

int ON_Brep::ComponentIndex( const ON_BrepTrim& trim ) const
{
  int component_index = trim.m_trim_index;
  if ( component_index >= 0 )
    component_index += brep_trim;
  else
    component_index = -1;
  return component_index;
}

int ON_Brep::ComponentIndex( const ON_BrepLoop& loop ) const
{
  int component_index = loop.m_loop_index;
  if ( component_index >= 0 )
    component_index += brep_loop;
  else
    component_index = -1;
  return component_index;
}

int ON_Brep::ComponentIndex( const ON_BrepFace& face ) const
{
  int component_index = face.m_face_index;
  if ( component_index >= 0 )
    component_index += brep_face;
  else
    component_index = -1;
  return component_index;
}

ON_Brep::COMPONENT_TYPE ON_Brep::ComponentIndexType( int component_index )
{
  switch( brep_component_mask & component_index )
  {
  case brep_vertex: return brep_vertex;
  case brep_edge: return brep_edge;
  case brep_trim: return brep_trim;
  case brep_loop: return brep_loop;
  case brep_face: return brep_face;
  }
  return brep_component_unset;
}
*/

const ON_Geometry* ON_Brep::BrepComponent( 
  ON_COMPONENT_INDEX ci
  ) const
{
  const ON_Geometry* component = 0;
  switch ( ci.m_type )
  {
  case ON_COMPONENT_INDEX::brep_vertex:
    component = Vertex(ci.m_index);
    break;
  case ON_COMPONENT_INDEX::brep_edge:
    component = Edge(ci.m_index);
    break;
  case ON_COMPONENT_INDEX::brep_face:
    component = Face(ci.m_index);
    break;
  case ON_COMPONENT_INDEX::brep_trim:
    component = Trim(ci.m_index);
    break;
  case ON_COMPONENT_INDEX::brep_loop:
    component = Loop(ci.m_index);
    break;
  default:
    // other enum values skipped on purpose
    break;
  }
  return component;
}

/*
const ON_Geometry* ON_Brep::BrepComponent( 
  int component_index
  ) const
{
  const ON_Geometry* component = 0;
  if ( -1 != component_index && 0 != component_index)
  {
    switch( ON_Brep::ComponentIndexType(component_index) )
    {
    case brep_vertex: 
      component = Vertex(component_index);
      break;
    case brep_edge:
      component = Edge(component_index);
      break;
    case brep_trim:
      component = Trim(component_index);
      break;
    case brep_loop:
      component = Loop(component_index);
      break;
    case brep_face:
      component = Face(component_index);
      break;
    }
  }
  return component;
}
*/


ON_BrepVertex* ON_Brep::Vertex( int vertex_index ) const
{
  ON_BrepVertex* vertex = 0;
  if ( vertex_index>=0 && vertex_index < m_V.Count() )
    vertex = const_cast<ON_BrepVertex*>(&m_V[vertex_index]);
  return vertex;
}

ON_BrepVertex* ON_Brep::Vertex( ON_COMPONENT_INDEX vertex_index ) const
{
  ON_BrepVertex* vertex = 0;
  if ( ON_COMPONENT_INDEX::brep_vertex == vertex_index.m_type 
       && vertex_index.m_index >= 0 
       && vertex_index.m_index < m_V.Count() )
  {
    vertex = const_cast<ON_BrepVertex*>(&m_V[vertex_index.m_index]);
  }
  return vertex;
}


ON_BrepEdge* ON_Brep::Edge( int edge_index ) const
{
  ON_BrepEdge* edge = 0;
  if ( edge_index>=0 && edge_index < m_E.Count() )
    edge = const_cast<ON_BrepEdge*>(&m_E[edge_index]);
  return edge;
}

ON_BrepEdge* ON_Brep::Edge( ON_COMPONENT_INDEX edge_index ) const
{
  ON_BrepEdge* edge = 0;
  if ( ON_COMPONENT_INDEX::brep_edge == edge_index.m_type 
       && edge_index.m_index >= 0 
       && edge_index.m_index < m_E.Count() )
  {
    edge = const_cast<ON_BrepEdge*>(&m_E[edge_index.m_index]);
  }
  return edge;
}

ON_BrepTrim* ON_Brep::Trim( int trim_index ) const
{
  ON_BrepTrim* trim = 0;
  if ( trim_index>=0 && trim_index < m_T.Count() )
    trim = const_cast<ON_BrepTrim*>(&m_T[trim_index]);
  return trim;
}

ON_BrepTrim* ON_Brep::Trim( ON_COMPONENT_INDEX trim_index ) const
{
  ON_BrepTrim* trim = 0;
  if ( ON_COMPONENT_INDEX::brep_trim == trim_index.m_type 
       && trim_index.m_index >= 0 
       && trim_index.m_index < m_T.Count() )
  {
    trim = const_cast<ON_BrepTrim*>(&m_T[trim_index.m_index]);
  }
  return trim;
}

ON_BrepLoop* ON_Brep::Loop( int loop_index ) const
{
  ON_BrepLoop* loop = 0;
  if ( loop_index>=0 && loop_index < m_L.Count() )
    loop = const_cast<ON_BrepLoop*>(&m_L[loop_index]);
  return loop;
}

ON_BrepLoop* ON_Brep::Loop( ON_COMPONENT_INDEX loop_index ) const
{
  ON_BrepLoop* loop = 0;
  if ( ON_COMPONENT_INDEX::brep_loop == loop_index.m_type 
       && loop_index.m_index >= 0 
       && loop_index.m_index < m_L.Count() )
  {
    loop = const_cast<ON_BrepLoop*>(&m_L[loop_index.m_index]);
  }
  return loop;
}

ON_BrepFace* ON_Brep::Face( int face_index ) const
{
  ON_BrepFace* face = 0;
  if ( face_index>=0 && face_index < m_F.Count() )
    face = const_cast<ON_BrepFace*>(&m_F[face_index]);
  return face;
}

ON_BrepFace* ON_Brep::Face( ON_COMPONENT_INDEX face_index ) const
{
  ON_BrepFace* face = 0;
  if ( ON_COMPONENT_INDEX::brep_face == face_index.m_type 
       && face_index.m_index >= 0 
       && face_index.m_index < m_F.Count() )
  {
    face = const_cast<ON_BrepFace*>(&m_F[face_index.m_index]);
  }
  return face;
}

const ON_Surface* ON_BrepFace::SurfaceOf() const
{
  const ON_Surface* srf = ProxySurface();
  if ( 0 == srf && 0 != m_brep && m_si >= 0 && m_si < m_brep->m_S.Count() )
  {
    srf = m_brep->m_S[m_si];
  }
  return srf;
}



void ON_BrepTrim::DestroyPspaceInformation()
{
  m_pline.Destroy();
  m_pbox.Destroy();
}

bool ON_BrepTrim::ChangeTrimCurve( int c2i )
{
  if ( 0 == m_brep )
    return 0;
  if ( c2i < 0 || c2i >= m_brep->m_C2.Count() )
    return 0;
  const ON_Curve* c2 = m_brep->m_C2[c2i];
  m_c2i = c2i;
  DestroyPspaceInformation();
  SetProxyCurve(c2);
  if ( c2 )
  {
    m_pbox = c2->BoundingBox();
    m_pbox.m_min.z = 0.0;
    m_pbox.m_max.z = 0.0;
  }
  return true;
}

bool ON_BrepTrim::RemoveFromEdge( 
      bool bRemoveFromStartVertex,
      bool bRemoveFromEndVertex
      )
{
  bool rc = false;
  if ( 0 != m_brep || m_ei < 0  )
  {
    UnsetPlineEdgeParameters();
    if ( 0 != m_brep )
    {
      ON_BrepEdge* edge = m_brep->Edge(m_ei);
      if ( 0 != edge )
      {
        int eti = 0;
        while( eti < edge->m_ti.Count() )
        {
          if ( edge->m_ti[eti] == m_trim_index )
            edge->m_ti.Remove(eti);
          else
            eti++;
        }
      }
    }
    m_ei = -1;
    if (bRemoveFromStartVertex)
      m_vi[0] = -1;
    if (bRemoveFromEndVertex)
      m_vi[1] = -1;
    rc = true;
  }
  return rc;
}

bool ON_BrepTrim::AttachToEdge(
      int edge_index,
      bool bRev3d
      )
{
  bool rc = false;
  if ( 0 != m_brep )
  {
    ON_BrepEdge* edge = m_brep->Edge(edge_index);
    if ( 0 != edge )
    {
      rc = RemoveFromEdge(true,true);
      if (rc)
      {
        edge->m_ti.Append(m_trim_index);
        m_ei = edge->m_edge_index;
        m_bRev3d = bRev3d ? true : false;
        m_vi[0] = edge->m_vi[bRev3d?1:0];
        m_vi[1] = edge->m_vi[bRev3d?0:1];
      }
    }
  }
  return rc;
}



const ON_Curve* ON_BrepEdge::EdgeCurveOf() const
{
  const ON_Curve* c3 = ProxyCurve();
  if ( !c3 && m_brep && m_c3i >= 0 && m_c3i < m_brep->m_C3.Count())
  {
    // fallback to get answer if developer forgot to
    // set proxy ptr.
    c3 = m_brep->m_C3[m_c3i];
    if ( c3 )
    {
      ON_ERROR("ON_BrepEdge ProxyCurve() is NULL but m_c3i is valid");
    }
  }
  return c3;
}

int ON_BrepEdge::EdgeCurveIndexOf() const
{
  return (m_brep && m_c3i >= 0 && m_c3i < m_brep->m_C3.Count()) ? m_c3i : -1;
}

int ON_BrepTrim::EdgeCurveIndexOf() const
{
  int c3i = -1;
  if ( m_brep && m_ei >= 0 && m_ei < m_brep->m_E.Count() )
  {
    c3i = m_brep->m_E[m_ei].m_c3i;
    if ( c3i < 0 || c3i >= m_brep->m_C3.Count() )
      c3i = -1;
  }
  return c3i;
}

int ON_BrepTrim::TrimCurveIndexOf() const
{
  return ((m_brep && m_c2i >= 0 && m_c2i < m_brep->m_C2.Count()) ? m_c2i : -1);
}

const ON_Curve* ON_BrepTrim::EdgeCurveOf() const
{
  const ON_Curve* c3 = 0;
  if ( m_brep && m_ei >= 0 && m_ei < m_brep->m_C3.Count() )
  {
    c3 = m_brep->m_E[m_ei].EdgeCurveOf();
  }
  return c3;
}

bool ON_BrepEdge::ChangeEdgeCurve( int c3i )
{
  if ( 0 == m_brep )
    return 0;
  if ( c3i < 0 || c3i >= m_brep->m_C3.Count() )
    return 0;
  const ON_Curve* c3 = m_brep->m_C3[c3i];
  m_c3i = c3i;
  SetProxyCurve(c3);
  UnsetPlineEdgeParameters();
  return true;
}

const ON_Curve* ON_BrepTrim::TrimCurveOf() const
{
  const ON_Curve* c2 = ProxyCurve();
  if ( !c2 && m_brep && m_c2i >= 0 && m_c2i < m_brep->m_C2.Count() )
  {
    // fallback to get answer if developer forgot to
    // set proxy ptr.
    c2 = m_brep->m_C2[m_c2i];
    if ( c2 )
    {
      ON_ERROR("ON_BrepTrim ProxyCurve() = NULL but m_c2i is valid");
    }
  }
  return c2;
}

const ON_Surface* ON_BrepTrim::SurfaceOf() const
{
  const ON_Surface* srf = 0;
  if ( m_brep && m_li >= 0 && m_li < m_brep->m_L.Count() )
  {
    const int fi = m_brep->m_L[m_li].m_fi;
    if ( fi >= 0 && fi < m_brep->m_F.Count() )
    {
      srf = m_brep->m_F[fi].SurfaceOf();
    }
  }
  return srf;
}

const ON_Surface* ON_BrepLoop::SurfaceOf() const
{
  const ON_Surface* srf = 0;
  if ( m_brep && m_fi >= 0 && m_fi < m_brep->m_F.Count() )
  {
    srf = m_brep->m_F[m_fi].SurfaceOf();
  }
  return srf;
}

int ON_BrepTrim::SurfaceIndexOf() const
{
  int si = -1;
  if ( m_brep && m_li >= 0 && m_li < m_brep->m_L.Count() )
  {
    const int fi = m_brep->m_L[m_li].m_fi;
    if ( fi >= 0 && fi < m_brep->m_F.Count() )
    {
      si = m_brep->m_F[fi].m_si;
      if ( si < 0 || si >= m_brep->m_S.Count() )
        si = -1;
    }
  }
  return si;
}


int ON_BrepTrim::FaceIndexOf() const
{
  int fi = -1;
  if ( m_brep && m_li >= 0 && m_li < m_brep->m_L.Count() )
  {
    fi = m_brep->m_L[m_li].m_fi;
    if ( fi< 0 || fi >= m_brep->m_F.Count() )
    {
      fi = -1;
    }
  }
  return fi;
}

static
const ON_BrepTrim* SlitSeamMateHelper( const ON_BrepTrim& trim )
{
  if ( ON_BrepTrim::seam  != trim.m_type )
    return 0;
  if ( trim.m_li < 0 )
    return 0;
  if ( trim.m_ei < 0 )
    return 0;
  const ON_Brep* brep = trim.Brep();
  if ( !brep )
    return 0;
  if ( trim.m_ei >= brep->m_E.Count() )
    return 0;
  const ON_BrepEdge& edge = brep->m_E[trim.m_ei];
  int other_ti = -1;
  for ( int eti = 0; eti < edge.m_ti.Count(); eti++ )
  {
    int ti = edge.m_ti[eti];
    if ( trim.m_trim_index == ti )
      continue;
    if ( ti < 0 || ti >= brep->m_T.Count() )
      continue;
    if ( trim.m_li == brep->m_T[ti].m_li )
    {
      if (other_ti >= 0 )
        return 0;
      other_ti = ti;
    }
  }
  if ( other_ti < 0 )
    return 0;
  return &brep->m_T[other_ti];
}

bool ON_BrepTrim::IsSlit() const
{
  // 17 Nov 2006
  //     At this point in the development cycle, I cannot
  //     add a "slit" type to trim.  So, I will use this 
  //     function to distinguish between "slit" and "seam"
  //     trims.
  switch(m_iso)
  {
  case ON_Surface::E_iso:
  case ON_Surface::N_iso:
  case ON_Surface::S_iso:
  case ON_Surface::W_iso:
    return false;
    break;

  case ON_Surface::not_iso:
  case ON_Surface::x_iso:
  case ON_Surface::y_iso:
  case ON_Surface::iso_count:
    // anything else might be a slit
    break;
  }
  const ON_BrepTrim* other_trim = SlitSeamMateHelper(*this);
  if ( !other_trim )
    return false;
  return ( other_trim->m_iso == m_iso );
}

bool ON_BrepTrim::IsSeam() const
{
  // 17 Nov 2006
  //     At this point in the development cycle, I cannot
  //     add a "slit" type to trim.  So, I will use this 
  //     function to distinguish between "slit" and "seam"
  //     trims.
  ON_Surface::ISO other_iso = ON_Surface::not_iso;
  switch(m_iso)
  {
  case ON_Surface::E_iso:
    other_iso = ON_Surface::W_iso;
    break;
  case ON_Surface::N_iso:
    other_iso = ON_Surface::S_iso;
    break;
  case ON_Surface::S_iso:
    other_iso = ON_Surface::N_iso;
    break;
  case ON_Surface::W_iso:
    other_iso = ON_Surface::E_iso;
    break;
  default:
    return false;
  }
  const ON_BrepTrim* other_trim = SlitSeamMateHelper(*this);
  if ( !other_trim )
    return false;

  return ( other_trim->m_iso == other_iso );
}


int ON_BrepLoop::SurfaceIndexOf() const
{
  const ON_BrepFace* face = Face();
  return face ? face->m_si : -1;
}

int ON_BrepFace::SurfaceIndexOf() const
{
  return (m_brep && m_si >= 0 && m_si < m_brep->m_S.Count()) ? m_si : 0;
}

void ON_BrepTrim::UnsetPlineEdgeParameters()
{
  int count = m_pline.Count();
  if ( count > 0 )
  {
    ON_BrepTrimPoint* pline = m_pline.Array();
    while ( count-- )
      (pline++)->e = ON_UNSET_VALUE;
  }
}

void ON_BrepEdge::UnsetPlineEdgeParameters()
{
  int edge_trim_count, brep_trim_count, eti, ti;
  if ( 0 != m_brep )
  {
    edge_trim_count = m_ti.Count();
    if ( edge_trim_count > 0 )
    {
      brep_trim_count = m_brep->m_T.Count();
      for ( eti = 0; eti < edge_trim_count; eti++ )
      {
        ti = m_ti[eti];
        if ( ti >= 0 && ti < brep_trim_count )
        {
          m_brep->m_T[ti].UnsetPlineEdgeParameters();
        }
      }
    }
  }
}

bool ON_BrepFace::TransformTrim( const ON_Xform& xform )
{
  if ( !m_brep )
    return false;
  int fli;
  for ( fli = 0; fli < m_li.Count(); fli++ )
  {
    ON_BrepLoop* loop = m_brep->Loop( m_li[fli] );
    if ( loop )
    {
      if ( !loop->TransformTrim(xform) )
        return false;
    }
  }
  return true;
}

bool ON_BrepLoop::TransformTrim( const ON_Xform& xform )
{
  if ( !m_brep )
    return false;
  int lti;
  m_pbox.Destroy();
  for ( lti = 0; lti < m_ti.Count(); lti++ )
  {
    ON_BrepTrim* trim = m_brep->Trim( m_ti[lti] );
    if ( trim )
    {
      if ( !trim->TransformTrim(xform) )
        return false;
      m_pbox.Union( trim->m_pbox );
    }
  }
  return true;
}

bool ON_BrepTrim::TransformTrim( const ON_Xform& xform )
{
  // destroy cached information used to accelerate calculations
  DestroyCurveTree();
  m_pline.Destroy();

  if ( !m_brep )
    return false;

  // make sure only one trim uses the 2d curve
  if ( !m_brep->StandardizeTrimCurve( m_trim_index ) )
    return false;

  // transform 2d curve geometry
  ON_Curve* c2 = const_cast<ON_Curve*>(TrimCurveOf());
  if ( !c2 )
    return true;
  if ( !c2->Transform(xform) )
    return false;

  // update bounding box stored on trim
  m_pbox = c2->BoundingBox();
  m_pbox.m_min.z = 0.0;
  m_pbox.m_max.z = 0.0;

  // update 2d tolerances
  // Trim transforms can translate, scale and/or swap parameters.
  // The tolerances need to be adjusted for scaling and swapping.
  // Since the determinant can be < 0, fabs() must be applied.
  double tol0 = xform[0][0]*m_tolerance[0] + xform[0][1]*m_tolerance[1];
  double tol1 = xform[1][0]*m_tolerance[0] + xform[1][1]*m_tolerance[1];
  m_tolerance[0] = fabs(tol0);
  m_tolerance[1] = fabs(tol1);

  if ( m_iso != ON_Surface::not_iso )
  {
    m_iso = ON_Surface::not_iso;
    m_brep->SetTrimIsoFlags(*this);
  }

  return true;
}


void ON_BrepTrim::DestroyRuntimeCache( bool bDelete )
{
  ON_CurveProxy::DestroyRuntimeCache(bDelete);

  // This doesn't work right as of 30 Oct 2002 because
  // the pline is getting destroyed while it is still
  // valid and needed due to excessive calling
  // of DestroyRuntimeCache();

  //if ( bDelete )
  //  m_pline.Destroy();
  //else
  //  m_pline.EmergencyDestroy();

  // m_pbox.Destroy(); do not do this - it is not a runtime setting
  //                   and you will break the copy operators
}

void ON_BrepLoop::DestroyRuntimeCache( bool bDelete )
{
  ON_Object::DestroyRuntimeCache(bDelete);

  // m_pbox.Destroy(); do not do this - it is not a runtime setting
  //                   and you will break the copy operators
}

void ON_BrepFace::DestroyRuntimeCache( bool bDelete )
{
  ON_SurfaceProxy::DestroyRuntimeCache(bDelete);

  // 15 August 2003 Dale Lear:
  //    I added the line to destroy the face's m_bbox.
  //    Since m_bbox is private, it will be recalculated
  //    when it is needed.  (We hope.)  The fact the face
  //    m_bbox is private and recalculated as needed makes
  //    it different than the m_pbox info on trims and loops.
  m_bbox.Destroy();
}


/*
bool ON_Surface::AreaMassProperties(
  ON_MassProperties& mp,
  bool bArea,
  bool bFirstMoments,
  bool bSecondMoments,
  bool bProductMoments,
  double rel_tol,
  double abs_tol
  ) const
{
  bool rc = false;
  // The _MassPropertiesSurface() function is provided by the Rhino SDK.
  if ( 0 != _MassPropertiesSurface )
  {
    int mprc = _MassPropertiesSurface( 
            *this, NULL, 2, ON_UNSET_POINT, mp, 
            bArea, bFirstMoments, bSecondMoments, bProductMoments, 
            rel_tol, abs_tol );
    rc = (mprc != 0);
  }
  return rc;
}

bool ON_Surface::VolumeMassProperties(
  ON_MassProperties& mp, 
  bool bVolume,
  bool bFirstMoments,
  bool bSecondMoments,
  bool bProductMoments,
  ON_3dPoint base_point,
  double rel_tol,
  double abs_tol
  ) const
{
  bool rc = false;
  // The _MassPropertiesSurface() function is provided by the Rhino SDK.
  if ( 0 != _MassPropertiesSurface )
  {
    int mprc = _MassPropertiesSurface( 
            *this, NULL, 3, base_point, mp, 
            bVolume, bFirstMoments, bSecondMoments, bProductMoments, 
            rel_tol, abs_tol );
    rc = (mprc != 0);
  }
  return rc;
}
*/


int ON_BrepLoop::Dimension() const
{
  return 2;
}

ON_BOOL32 ON_BrepLoop::GetBBox(
        double* boxmin,
        double* boxmax,
        ON_BOOL32 bGrowBox
        ) const
{
  bool rc = m_pbox.IsValid();
  if (rc)
  {
    ON_BoundingBox bbox;
    if ( bGrowBox )
    {
      bbox.m_min.x = boxmin[0];
      bbox.m_min.y = boxmin[1];
      bbox.m_min.z = 0.0;
      bbox.m_max.x = boxmax[0];
      bbox.m_max.y = boxmax[1];
      bbox.m_max.z = 0.0;
      bbox.Union(m_pbox);
      boxmin[0] = bbox.m_min.x;
      boxmin[1] = bbox.m_min.y;
      boxmax[0] = bbox.m_max.x;
      boxmax[1] = bbox.m_max.y;
    }
    else
    {
      boxmin[0] = m_pbox.m_min.x;
      boxmin[1] = m_pbox.m_min.y;
      boxmax[0] = m_pbox.m_max.x;
      boxmax[1] = m_pbox.m_max.y;
    }
  }
  return rc;
}

ON_BOOL32 ON_BrepLoop::Transform( const ON_Xform& )
{
  return false;
}

ON_COMPONENT_INDEX ON_BrepVertex::ComponentIndex() const
{
  ON_COMPONENT_INDEX ci(ON_COMPONENT_INDEX::brep_vertex,m_vertex_index);
  return ci;
}

ON_COMPONENT_INDEX ON_BrepEdge::ComponentIndex() const
{
  ON_COMPONENT_INDEX ci(ON_COMPONENT_INDEX::brep_edge,m_edge_index);
  return ci;
}

ON_COMPONENT_INDEX ON_BrepFace::ComponentIndex() const
{
  ON_COMPONENT_INDEX ci(ON_COMPONENT_INDEX::brep_face,m_face_index);
  return ci;
}


ON_COMPONENT_INDEX ON_BrepTrim::ComponentIndex() const
{
  ON_COMPONENT_INDEX ci(ON_COMPONENT_INDEX::brep_trim,m_trim_index);
  return ci;
}



ON_COMPONENT_INDEX ON_BrepLoop::ComponentIndex() const
{
  ON_COMPONENT_INDEX ci(ON_COMPONENT_INDEX::brep_loop,m_loop_index);
  return ci;
}

blob
data 142517
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   Definition of b-rep and its parts
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_BREP_INC_)
#define OPENNURBS_BREP_INC_

class ON_BrepTrim;
class ON_BrepEdge;
class ON_BrepLoop;
class ON_BrepFace;


// TEMPORARY DEFINES SO I DON'T BREAK THE BUILD
#define m_vertex_user_i m_vertex_user.i
#define m_trim_user_i m_trim_user.i
#define m_edge_user_i m_edge_user.i
#define m_loop_user_i m_loop_user.i
#define m_face_user_i m_face_user.i

// Description:
//   Brep vertex information is stored in ON_BrepVertex classes.
//   ON_Brep.m_V[] is an array of all the vertices in the brep.
//
//   If a vertex is a point on a face, then brep.m_E[m_ei]
//   will be an edge with no 3d curve.  This edge will have
//   a single trim with type ON_BrepTrim::ptonsrf.  There
//   will be a loop containing this single trim.
//   Use ON_Brep::NewPointOnFace() to create vertices that are
//   points on faces. 
class ON_CLASS ON_BrepVertex : public ON_Point
{
  ON_OBJECT_DECLARE(ON_BrepVertex);

public:
  // Union available for application use.
  // The constructor zeros m_vertex_user.
  // The value is of m_vertex_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_vertex_user; 

  // index of the vertex in the ON_Brep.m_V[] array
  int m_vertex_index;

  /////////////////////////////////////////////////////////////////
  // Construction
  //
  // In general, you should not directly create ON_BrepVertex classes.
  // Use ON_Brep::NewVertex instead.
  ON_BrepVertex();
  ON_BrepVertex(
    int // vertex index
    );
  ON_BrepVertex& operator=(const ON_BrepVertex&);

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // virtual ON_Object::Dump() override
  void Dump( ON_TextLog& ) const; // for debugging

  // virtual ON_Object::Write() override
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  // virtual ON_Object::Read() override
  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Geometry::ComponentIndex() override
  ON_COMPONENT_INDEX ComponentIndex() const;

  /////////////////////////////////////////////////////////////////
  // Interface

  // Description:
  //   Set vertex location.
  // Parameters:
  //   point - [in] 3d vertex location
  bool SetPoint( 
          const ON_3dPoint& // point
          );

  // Returns:
  //   Vertex location.
  ON_3dPoint Point() const;

  // Returns:
  //   value of ON_BrepVertex::m_tolerance
  // Remarks:
  //   Use ON_Brep::SetVertexTolerance( ON_BrepVertex& ) to set tolerances.
  double Tolerance() const;

  // Returns:
  //   number of edges that begin or end at this vertex.
  int EdgeCount() const;

  /////////////////////////////////////////////////////////////////
  // Implementation

  // indices of edges starting/ending at this vertex
  //
  // For closed edges, edge.m_vi[0] = edge.m_vi[1] and 
  // edge.m_edge_index appears twice in the m_ei[] array.
  // The first occurance of edge.m_edge_index in m_ei[]
  // is for the closed edge starting the vertex.
  // The second occurance of edge,m_edge_index in m_ei[]
  // is for the closed edge ending at the vertex.
  // C.f. ON_Brep::Next/PrevEdge().
  ON_SimpleArray<int> m_ei;

  // accuracy of vertex point (>=0.0 or ON_UNSET_VALUE)
  //
  // A value of ON_UNSET_VALUE indicates that the
  // tolerance should be computed.
  //
  // A value of 0.0 indicates that the distance
  // from the vertex to any applicable edge or trim
  // end is <=  ON_ZERO_TOLERANCE
  //
  // If an edge begins or ends at this vertex,
  // then the distance from the vertex's 
  // 3d point to the appropriate end of the
  // edge's 3d curve must be <= this tolerance.
  //
  // If a trim begins or ends at this vertex,
  // then the distance from the vertex's 3d point
  // to the 3d point on the surface obtained by
  // evaluating the surface at the appropriate
  // end of the trimming curve must be <= this
  // tolerance.
  double m_tolerance;

private:
  ON_BrepVertex( const ON_BrepVertex& ); // no implementation

};

/*
Description:
  Brep edge information is stored in ON_BrepEdge classes.
  ON_Brep.m_E[] is an array of all the edges in the brep.

  An ON_BrepEdge is derived from ON_CurveProxy so the the
  edge can supply easy to use evaluation tools via 
  the ON_Curve virtual member functions.

  Note well that the domains and orientations of the curve
  m_C3[edge.m_c3i] and the edge as a curve may not
  agree.
*/
class ON_CLASS ON_BrepEdge : public  ON_CurveProxy
{
  ON_OBJECT_DECLARE(ON_BrepEdge);
public:

  // Union available for application use.
  // The constructor zeros m_edge_user.
  // The value is of m_edge_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_edge_user;

  // index of edge in ON_Brep.m_E[] array
  int m_edge_index;    


  // virtual ON_Curve::IsClosed override
  ON_BOOL32 IsClosed() const;

  /////////////////////////////////////////////////////////////////
  // Construction
  //
  // In general, you should not directly create ON_BrepEdge classes.
  // Use ON_Brep::NewVertex instead.
  ON_BrepEdge();
  ON_BrepEdge(int); // edge index
  ON_BrepEdge& operator=(const ON_BrepEdge&);

  // virtual ON_Object function
  // The ON_BrepEdge override returns ON::curve_object.
  ON::object_type ObjectType() const;

  /*
  Returns:
    Brep this edge belongs to.
  */
  ON_Brep* Brep() const;


  /*
  Parameters:
    eti - [in] index into the edge's m_ti[] array.
  Returns:
    The trim brep.m_T[edge.m_ti[eti]];
  */
  using ON_CurveProxy::Trim;
  ON_BrepTrim* Trim( int eti ) const;

  /*
  Returns:
    Number of trims attached to this edge.
  */
  int TrimCount() const;

  /*
  Parameters:
    evi - [in] 0 or 1
  Returns:
    Brep vertex at specified end of the edge.
  */
  ON_BrepVertex* Vertex(int evi) const;

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // virtual ON_Object::Dump() override
  void Dump( ON_TextLog& ) const; // for debugging

  // virtual ON_Object::Write() override
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  // virtual ON_Object::Read() override
  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Geometry::ComponentIndex() override
  ON_COMPONENT_INDEX ComponentIndex() const;

  // virtual ON_Curve::Reverse override
  ON_BOOL32 Reverse();

  // virtual ON_Curve::SetStartPoint override
  ON_BOOL32 SetStartPoint(
          ON_3dPoint start_point
          );

  // virtual ON_Curve::SetEndPoint override
  ON_BOOL32 SetEndPoint(
          ON_3dPoint end_point
          );

  /////////////////////////////////////////////////////////////////
  // Implementation

  /*
  Returns:
    brep.m_C3[] index of the 3d curve geometry used by this edge 
    or -1.
  */
  int EdgeCurveIndexOf() const;

  /*
  Returns:
    3d curve geometry used by this edge or NULL.
  */
  const ON_Curve* EdgeCurveOf() const;

  /*
  Description:
    Expert user tool that replaces the 3d curve geometry
    of an edge
  Parameters;
    c3i - [in] brep 3d curve index of new curve
  Returns:
    True if successful.
  Example:

            ON_Curve* pCurve = ...;
            int c3i = brep.AddEdgeCurve(pCurve);
            edge.ChangeEdgeCurve(c3i);

  Remarks:
    Sets m_c3i, calls SetProxyCurve, cleans runtime caches.
  */
  bool ChangeEdgeCurve(
    int c3i 
    );

  /*
  Description:
    When an edge is modified, the m_pline[].e values need
    to be set to ON_UNSET_VALUE by calling UnsetPlineEdgeParameters().
  */
  void UnsetPlineEdgeParameters();

  // index of 3d curve in m_C3[] array
  // (edge.m_curve also points to m_C3[m_c3i])
  int m_c3i;

  // indices of starting/ending vertex
  //
  // For closed edges, m_vi[0] = m_vi[1] and m_edge_index
  // appears twice in the m_V[m_vi[0]].m_ei[] array.
  // The first occurance of m_edge_index in m_V[m_vi[0]].m_ei[]
  // is for the closed edge starting the vertex.  The second
  // occurance of m_edge_index in m_V[m_vi[0]].m_ei[]
  // is for the closed edge edge ending at the vertex.
  // C.f. ON_Brep::Next/PrevEdge().
  int m_vi[2];

  // indices of Trims that use this edge
  ON_SimpleArray<int> m_ti;

  // accuracy of edge curve (>=0.0 or ON_UNSET_VALUE)
  //
  // A value of ON_UNSET_VALUE indicates that the
  // tolerance should be computed.
  //
  // The maximum distance from the edge's 3d curve
  // to any surface of a face that has this edge as
  // a portion of its boundary must be <= this
  // tolerance.
  double m_tolerance;

private:
  friend class ON_Brep;
  ON_Brep* m_brep; // so isolated edge class edge can get at it's 3d curve
  ON_BrepEdge( const ON_BrepEdge& ); // no implementation
};

struct ON_BrepTrimPoint
{
  ON_2dPoint p; // 2d surface parameter space point
  double t;     // corresponding trim curve parameter
  double e;     // corresponding edge curve parameter (ON_UNSET_VALUE if unknown)
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_SimpleArray<ON_BrepTrimPoint>;
#pragma warning( pop )
#endif


/*
Description:
  Brep trim information is stored in ON_BrepTrim classes.
  ON_Brep.m_T[] is an array of all the trim in the brep.

  An ON_BrepTrim is derived from ON_CurveProxy so the the
  trim can supply easy to use evaluation tools via 
  the ON_Curve virtual member functions.

  Note well that the domains and orientations of the curve
  m_C2[trim.m_c2i] and the trim as a curve may not
  agree.
*/
class ON_CLASS ON_BrepTrim : public  ON_CurveProxy
{
  ON_OBJECT_DECLARE(ON_BrepTrim);

public:
  void DestroyRuntimeCache( bool bDelete = true );

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // Union available for application use.
  // The constructor zeros m_trim_user.
  // The value is of m_trim_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_trim_user;

  int m_trim_index;  // index of trim in ON_Brep.m_T[] array

  // types of trim - access through m_type member.  Also see m_iso and ON_Surface::ISO
  enum TYPE 
  {
    unknown  = 0,
    boundary = 1,       // trim is connected to an edge, is part of an outer, 
                        // inner or slit loop, and is the only trim connected
                        // to the edge.
    mated    = 2,       // trim is connected to an edge, is part of an outer,
                        // inner or slit loop, no other trim from the same 
                        // loop is connected to the edge, and at least one 
                        // trim from a different loop is connected to the edge.
    seam     = 3,       // trim is connected to an edge, is part of an outer, 
                        // inner or slit loop, and one other trim from the 
                        // same loop is connected to the edge.
                        // (There can be other mated trims that are also
                        // connected to the edge.  For example, the non-mainfold
                        // edge that results when a surface edge lies in the
                        // middle of another surface.)  Non-mainfold "cuts"
                        // have seam trims too.
    singular = 4,       // trim is part of an outer loop, the trim's 2d curve
                        // runs along the singular side of a surface, and the
                        // trim is NOT connected to an edge. (There is no 3d
                        // edge because the surface side is singular.)
    crvonsrf = 5,       // trim is connected to an edge, is the only trim in
                        // a crfonsrf loop, and is the only trim connected to
                        // the edge.
    ptonsrf  = 6,       // trim is a point on a surface, trim.m_pbox is records
                        // surface parameters, and is the only trim
                        // in a ptonsrf loop.  This trim is not connected
                        // to an edge and has no 2d curve.
    slit     = 7,       // 17 Nov 2006 - reserved for future use
                        //   currently an invalid value
    trim_type_count = 8,
    force_32_bit_trim_type = 0xFFFFFFFF
  };

  /////////////////////////////////////////////////////////////////
  // Construction
  //
  // In general, you should not directly create ON_BrepTrim classes.
  // Use ON_Brep::NewTrim instead.
  ON_BrepTrim();
  ON_BrepTrim(int); // trim index
  ON_BrepTrim& operator=(const ON_BrepTrim&);

  /*
  Returns:
    Brep that this trim belongs to.
  */
  ON_Brep* Brep() const;

  /*
  Returns:
    Brep loop that this trim belongs to.
  */
  ON_BrepLoop* Loop() const;

  /*
  Returns:
    Brep face this trim belongs to.
  */
  ON_BrepFace* Face() const;

  /*
  Returns:
    Brep edge this trim uses or belongs to.  This will
    be NULL for singular trims.
  */
  ON_BrepEdge* Edge() const;

  /*
  Parameters:
    tvi - [in] 0 or 1
  Returns:
    Brep vertex at specified end of the trim.
  */
  ON_BrepVertex* Vertex(int tvi) const;

  /////////////////////////////////////////////////////////////////
  // ON_Object overrides
  //
  // (Trims are purely topologicial - geometry queries should be 
  //  directed at the trim's 2d curve or the trim's edge's 3d curve.)

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Geometry::ComponentIndex() override
  ON_COMPONENT_INDEX ComponentIndex() const;

  // virtual ON_Curve::Reverse override
  // Reverses curve - caller must make sure trim's m_bRev3d
  // flags are properly updated.  Use
  // ON_Brep::FlipTrim to reverse and trim and update all
  // m_bRev3d informtion.
  ON_BOOL32 Reverse();

  // virtual ON_Curve::SetStartPoint override
  ON_BOOL32 SetStartPoint(
          ON_3dPoint start_point
          );

  // virtual ON_Curve::SetEndPoint override
  ON_BOOL32 SetEndPoint(
          ON_3dPoint end_point
          );

  /////////////////////////////////////////////////////////////////
  // Interface
  
  /*
  Description:
    Expert user tool that replaces the 2d curve geometry
    of a trim
  Parameters;
    c2i - [in] brep 2d curve index of new curve
  Returns:
    True if successful.
  Example:

            ON_Curve* pCurve = ...;
            int c2i = brep.AddTrimCurve(pCurve);
            trim.ChangeTrimCurve(c2i);

  Remarks:
    Sets m_c2i, calls SetProxyCurve, cleans runtime caches,
    and updates m_pbox.
  */
  bool ChangeTrimCurve( int c2i );

  /*
  Description:
    Destroy parameter space information.
    Currently, this involves destroying m_pline
    and m_pbox. Parameter space information should
    be destroyed when the location of a trim
    curve is changed.
  */
  void DestroyPspaceInformation();
  
  /*
  Description:
    Expert user function.
    Removes a trim from an edge.
  Parameters:
    bRemoveFromStartVertex - [in] if true, the trim
      is removed from its start vertex by setting
      m_vi[0] to -1.
    bRemoveFromEndVertex - [in] if true, the trim
      is removed from its start vertex by setting
      m_vi[1] to -1.
  Remarks:
    If the trim is attached to an edge (m_ei>=0), then
    the trim is removed from the edge and the edge's
    m_ti[] list.  The trim's m_bRev3d and tolerance values
    are not changed.
  */
  bool RemoveFromEdge( 
        bool bRemoveFromStartVertex,
        bool bRemoveFromEndVertex
        );

  /*
  Description:
    Expert user function.
    Attaches a trim to an edge.
  Parameters:
    edge_index - [in] index of an edge.
    bRev3d - [in] value for trim's m_bRev3d field.
  Remarks:
    If the trim is attached to an edge (m_ei>=0), then
    the trim is removed from the edge and the edge's
    m_ti[] list.  The trim's tolerance values are not
    changed.
  */
  bool AttachToEdge(
        int edge_index,
        bool bRev3d
        );

  /*
  Returns:
    2d curve geometry used by this trim or NULL
  */
  const ON_Curve* TrimCurveOf() const;

  /*
  Returns:
    3d curve geometry used by this trim or NULL.
  */
  const ON_Curve* EdgeCurveOf() const;

  /*
  Returns:
    3d surface geometry used by this trim or NULL
  */
  const ON_Surface* SurfaceOf() const;

  /*
  Returns:
    brep.m_C2[] 2d curve index of the 2d curve geometry used by 
    this trim or -1.
  */
  int TrimCurveIndexOf() const;

  /*
  Returns:
    brep.m_C3[] 3d curve index of the 3d curve geometry used by 
    this trim or -1.
  */
  int EdgeCurveIndexOf() const;

  /*
  Returns:
    brep.m_S[] surface index of the 3d surface geometry used by 
    this trim or -1.
  */
  int SurfaceIndexOf() const;

  /*
  Returns:
    brep.m_F[] face index of the face used by this trim or -1.
  */
  int FaceIndexOf() const;

  /*
  Returns:
    True if the trim satisfies these four criteria.
      1) is part of a loop
      2) is connected to a 3d edge
      3) one other trim from the same loop is connected to the edge
      4) The 2d trim curve for the other trim is the reverse
         of the 2d trim curve for this trim.
  Remarks:
    In order for IsSlit() to work correctly, the m_type and m_iso
    fields must be set correctly.  In V4 SR1, this function will
    be removed and ON_BrepTrim::slit will be added as a type.
  */
  bool IsSlit() const;

  /*
  Returns:
    True if the trim satisfies these four criteria.
      1) is part of a loop
      2) is connected to a 3d edge
      3) one other trim from the same loop is connected to the edge
      4) the 2d trim curve for this trim lies along the side of 
         the face's parameter space and the 2d curve for the other
         trim lies on the opposite side of the face's parameter
         space.
  Remarks:
    In order for IsSeam() to work correctly, the m_type and m_iso
    fields must be set correctly.  In V4 SR1, this function will
    be removed and ON_BrepTrim::slit will be added as a type.
  */
  bool IsSeam() const;

  /*
  Description:
    Expert user tool that tranforms all the parameter space (2d)
    trimming curves in this loop.  Only 2d curve geometry is
    changed.  The caller is responsible for reversing loops,
    toggle m_bRev, flags, etc.
  Parameters:
    xform - [in] Transformation applied to 2d curve geometry.
  Returns
    True if successful.  If false is returned, the brep
    may be invalid.
  */
  bool TransformTrim( const ON_Xform& xform );

  // index of the 2d parameter space trimming curve
  int m_c2i;

  // index of 3d edge (-1 if ON_BrepTrim is singular)
  int m_ei;

  // Indices of start/end vertices.  Trims along singular
  // sides and trims that correspond to closed 3d edges
  // have m_vi[0] = m_vi[1].  Note that singular trims
  // and trims on the closed edge of a closed surface can
  // have an open 2d trimming curve and still have 
  // m_vi[0] = m_vi[1].
  int m_vi[2];
        
  // true if the 2d trim and 3d edge have opposite orientations.
  bool   m_bRev3d;

  TYPE   m_type;
  ON_Surface::ISO  m_iso;

  // index of loop that uses this trim
  int    m_li;

  // The values in m_tolerance[] record the accuracy of
  // the parameter space trimming curves.
  //
  // Remarks:
  //   m_tolerance[0] = accuracy of parameter space curve
  //   in first ( "u" ) parameter
  //
  //   m_tolerance[1] = accuracy of parameter space curve
  //   in second ( "v" ) parameter
  //
  //   A value of ON_UNSET_VALUE indicates that the 
  //   tolerance should be computed. If the value >= 0.0, 
  //   then the tolerance is set.  If the value is 
  //   ON_UNSET_VALUE, then the tolrance needs to be
  //   computed.
  //
  //   If the trim is not singular, then the trim must
  //   have an edge.  If P is a 3d point on the edge's
  //   curve and surface(u,v) = Q is the point on the 
  //   surface that is closest to P, then there must
  //   be a parameter t in the interval [m_t[0], m_t[1]]
  //   such that
  //
  //   |u - curve2d(t)[0]| <= m_tolerance[0]
  //
  //   and 
  //
  //   |v - curve2d(t)[1]| <= m_tolerance[1]
  //
  //   If P is the 3d point for the vertex brep.m_V[m_vi[k]]
  //   and (uk,vk) is the corresponding end of the trim's
  //   parameter space curve, then there must be a surface
  //   parameter (u,v) such that:
  //
  //   *  the distance from the 3d point surface(u,v) to P
  //      is <= brep.m_V[m_vi[k]].m_tolerance,
  //   *  |u-uk| <= m_tolerance[0].
  //   *  |v-vk| <= m_tolerance[1].
  double m_tolerance[2]; 

  // Runtime polyline approximation of trimming curve.
  // This information is not saved in 3DM archives.
  ON_SimpleArray<ON_BrepTrimPoint> m_pline;
  /*
  Description:
    When an edge is modified, the m_pline[].e values need
    to be set to ON_UNSET_VALUE by calling UnsetPlineEdgeParameters().
  */
  void UnsetPlineEdgeParameters();


  // Runtime parameter space trimming curve bounding box.
  // This information is not saved in 3DM archives.
  ON_BoundingBox m_pbox;

public:
  // values stored in legacy file formats - ignore

  void m__legacy_flags_Set(int,int);   // used internally - ignore
  bool m__legacy_flags_Get(int*,int*) const; // used internally - ignore
  double m__legacy_2d_tol; // used internally - ignore
  double m__legacy_3d_tol; // used internally - ignore
  int    m__legacy_flags;  // used internally - ignore

private:
  friend class ON_Brep;
  ON_Brep* m_brep; // so isolated edge class edge can get at it's 3d curve
  ON_BrepTrim( const ON_BrepTrim& ); // no implementation
};

class ON_CLASS ON_BrepLoop : public  ON_Geometry
{
  ON_OBJECT_DECLARE(ON_BrepLoop);

public:
  void DestroyRuntimeCache( bool bDelete = true );

  // virtual ON_Geometry overrides
  // A loop is derived from ON_Geometry so that is can 
  // be passed around to things that expect ON_Geometry
  // pointers.  It is not a very useful stand-alone object.

  /*
  Description:
    virtual ON_Geometry::Dimension() override.
  Returns:
    2
  */
  int Dimension() const;

  // virtual ON_Geometry::GetBBox() override.
  ON_BOOL32 GetBBox(
         double* boxmin,
         double* boxmax,
         int bGrowBox = false
         ) const;

  // virtual ON_Geometry::Transform() override.
  ON_BOOL32 Transform( 
         const ON_Xform& xform
         );
public:
  /*
  Returns:
   Brep that the loop belongs to.
  */
  ON_Brep* Brep() const;

  /*
  Returns:
    Brep face this loop belongs to.
  */
  ON_BrepFace* Face() const;

  /*
  Parameters:
    lti - [in] index into the loop's m_ti[] array.
  Returns:
    The trim brep.m_T[loop.m_ti[lti]];
  */
  ON_BrepTrim* Trim( int lti ) const;

  /*
  Returns:
    Number of trims in this loop.
  */
  int TrimCount() const;

  // Union available for application use.
  // The constructor zeros m_loop_user.
  // The value is of m_loop_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_loop_user;

  int m_loop_index;  // index of loop in ON_Brep.m_L[] array

  enum TYPE {
    unknown  = 0,
    outer    = 1,  // 2d loop curves form a simple closed curve with a counterclockwise orientation
    inner    = 2,  // 2d loop curves form a simple closed curve with a clockwise orientation
    slit     = 3,  // always closed - used internally during splitting operations
    crvonsrf = 4,  // "loop" is a curveonsrf made from a single 
                   // (open or closed) trim that is has type ON_BrepTrim::crvonsrf.
    ptonsrf = 5,   // "loop" is a ptonsrf made from a single 
                   // trim that is has type ON_BrepTrim::ptonsrf.
    type_count = 6
  };

  ON_BrepLoop();
  ON_BrepLoop(int); // loop index
  ON_BrepLoop& operator=(const ON_BrepLoop&);

  /////////////////////////////////////////////////////////////////
  // ON_Object overrides
  //
  // (Loops and trims are purely topologicial - geometry queries should be 
  // directed at the trim's 2d curve or the trim's edge's 3d curve.)

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Geometry::ComponentIndex() override
  ON_COMPONENT_INDEX ComponentIndex() const;

  /////////////////////////////////////////////////////////////////
  // Interface

  //////////
  // Returns the index i such that loop.m_ti[i] = trim.m_trim_index.
  // Returns -1 if the trim is not in this loop
  int IndexOfTrim( const ON_BrepTrim& ) const;

  /*
  Returns:
    brep.m_S[] surface index of the 3d surface geometry used by 
    this loop or -1.
  */
  int SurfaceIndexOf() const;

  /*
  Returns:
    Pointer to the surface geometry used by the loop.   
  */
  const ON_Surface* SurfaceOf() const;

  /*
  Description:
    Expert user tool that tranforms all the parameter space (2d)
    trimming curves in this loop.  Only 2d curve geometry is
    changed.  The caller is responsible for reversing loops,
    toggle m_bRev, flags, etc.
  Parameters:
    xform - [in] Transformation applied to 2d curve geometry.
  Returns
    True if successful.  If false is returned, the brep
    may be invalid.
  */
  bool TransformTrim( const ON_Xform& xform );

  ON_SimpleArray<int> m_ti;   // trim indices
  TYPE         m_type;
  int          m_fi;   // index of face that uses this loop

  //////////
  // parameter space trimming loop bounding box
  // runtime information - not saved
  ON_BoundingBox m_pbox;
private:
  friend class ON_Brep;
  ON_Brep* m_brep;
  ON_BrepLoop(const ON_BrepLoop&); // no implementation
};

class ON_CLASS ON_BrepFace : public ON_SurfaceProxy
{
  ON_OBJECT_DECLARE(ON_BrepFace);

public:
  void DestroyRuntimeCache( bool bDelete = true );

  // Union available for application use.
  // The constructor zeros m_face_user.
  // The value is of m_face_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_face_user;

  int m_face_index;  // index of face in ON_Brep.m_F[] array

  ON_BrepFace();
  ~ON_BrepFace();
  ON_BrepFace(int);
  ON_BrepFace& operator=(const ON_BrepFace&);

  /*
  Returns:
   Brep that the face belongs to.
  */
  ON_Brep* Brep() const;

  /*
  Parameters:
    fli - [in] index into the face's m_li[] array.
  Returns:
    The loop brep.m_L[face.m_li[fli]];
  */
  ON_BrepLoop* Loop( int fli ) const;

  /*
  Returns:
    Number of loops in this face.
  */
  int LoopCount() const;

  /*
  Returns:
    Outer boundary loop for this face.
  */
  ON_BrepLoop* OuterLoop() const;

  /*
  Parameters:
    dir
       1: side with underlying surface normal
         pointing into the topology region
      -1: side with underlying surface normal
          pointing out of the topology region
  Returns:
    Brep region topology face side.  If the region
    topology has not be created by calling
    ON_Brep::RegionToplogy(), then NULL is returned.
  */
  class ON_BrepFaceSide* FaceSide(int dir) const;


  /////////////////////////////////////////////////////////////////
  // ON_Object overrides
  //
  // (Faces are purely topologicial - geometry queries should be 
  //  directed at the face's 3d surface.)

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  void Dump( ON_TextLog& ) const; // for debugging

  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Geometry::ComponentIndex() override
  ON_COMPONENT_INDEX ComponentIndex() const;

  // virtual ON_Geometry::ClearBoundingBox() override
  void ClearBoundingBox();

  // virtual ON_Geometry::GetBBox() override
  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  /*
  Description:
    This is an override of the virtual ON_Surface::Reverse
    function.  It toggles the face's m_bRev flag so the abstract
    orientation of the face does not change.
  Parameters:
    dir - [in] 0 = reverse "s" parameter, 1 = reverse "t" parameter
         The domain changes from [a,b] to [-a,-b]
  Returns:
    True if successful.
  Remarks:
    The range of the face's trimming curves and the orientation direction
    of then loops are changed so that the resulting face is still valid.
  */
  ON_BOOL32 Reverse(
    int dir
    );

  /*
  Description:
    This is an override of the virtual ON_Surface::Transpose
    function.  It toggles the face's m_bRev flag so the abstract
    orientation of the face does not change.
  Returns:
    True if successful.
  Remarks:
    The range of the face's trimming curves and the orientation direction
    of then loops are changed so that the resulting face is still valid.
  */
  ON_BOOL32 Transpose();

  /*
  Description:
    This is an override of the virtual ON_Surface::SetDomain
    function.
  Parameters:
    dir - [in] 0 = set "u" domain, 1 = set "v" domain.
    t0 - [in]
    t1 - [in] t0 < t1  The new domain is the interval (t0,t1)
  Returns:
    True if successful.
  */
  ON_BOOL32 SetDomain(
    int dir,
    double t0,
    double t1
    );

  /*
  //////////
  // Change the domain of a face
  // This changes the parameterization of the face's surface and transforms
  // the "u" and "v" coordinates of all the face's parameter space trimming
  // curves.  The locus of the face is not changed.
  */
  bool SetDomain(
         ON_Interval udom,
         ON_Interval vdom
         );

  /////////////////////////////////////////////////////////////////
  // Rendering Interface
  //int MaterialIndex() const; // if -1, use parent's material definition
  //void SetMaterialIndex(int);

  // If true is returne, then ~ON_BrepFace will delete mesh.
  bool SetMesh( ON::mesh_type, ON_Mesh* mesh );

  const ON_Mesh* Mesh( ON::mesh_type mesh_type ) const;

  /*
  Description:
    Destroy meshes used to render and analyze surface and polysrf
    objects.
  Parameters:
    mesh_type - [in] type of mesh to destroy
    bDeleteMesh - [in] if true, cached mesh is deleted.
      If false, pointer to cached mesh is just set to NULL.
  See Also:
    CRhinoObject::GetMeshes
    CRhinoObject::MeshCount
    CRhinoObject::IsMeshable
  */
  void DestroyMesh( ON::mesh_type mesh_type, bool bDeleteMesh = true );

  /////////////////////////////////////////////////////////////////
  // "Expert" Interface

  /*
  Description:
    Expert user tool that tranforms all the parameter space (2d)
    trimming curves on this face.  Only 2d curve geometry is
    changed.  The caller is responsible for reversing loops,
    toggle m_bRev, flags, etc.
  Parameters:
    xform - [in] Transformation applied to 2d curve geometry.
  Returns
    True if successful.  If false is returned, the brep
    may be invalid.
  */
  bool TransformTrim( const ON_Xform& xform );

  /*
  Description:
    Expert user tool that replaces the 3d surface geometry
    use by the face.
  Parameters;
    si - [in] brep surface index of new surface
    bTransformTrimCurves - [in]
      If unsure, then pass true.
      If the surface's domain has changed and you are certain
      its parameterization still jibes with the trim curve
      locations, then pass false.
  Returns:
    True if successful.
  Example:

            ON_Surface* pSurface = ...;
            int si = brep.AddSurface(pSurface);
            face.ChangeSurface(si);

  Remarks:
    If the face had a surface and new surface has a different
    shape, then you probably want to call something like
    ON_Brep::RebuildEdges() to move the 3d edge curves so they
    will lie on the new surface. This doesn't delete the old 
    surface; call ON_Brep::CullUnusedSurfaces() or ON_Brep::Compact
    to remove unused surfaces.
  See Also:
    ON_Brep::RebuildEdges
    ON_Brep::CullUnusedSurfaces
  */
  bool ChangeSurface(
    int si
    );
  bool ChangeSurface(
    int si,
    bool bTransformTrimCurves
    );

  /*
  Returns:
    brep.m_S[] surface index of the 3d surface geometry used by 
    this face or -1.
  */
  int SurfaceIndexOf() const;

  /*
  Returns:
    Pointer to the surface geometry used by the face.   
  */
  const ON_Surface* SurfaceOf() const;

  ON_SimpleArray<int> m_li; // loop indices (outer loop is m_li[0])
  int m_si;            // index of surface in b-rep m_S[] array
  bool m_bRev;         // true if face orientation is opposite
                       //      of natural surface orientation

  // m_face_material_channel provides a way to have individual
  // brep faces use a rendering material that is different
  // from the rendering material used by the parent brep.
  // If m_face_material_channel is zero 
  // channel and m_face_material_channel.m_j is the back face
  // materal. The default is (0,0) which indicates the face
  // should use the parent brep's material.
  // If "mat" is the brep's rendering material and
  // 0 < m_material_channel.m_i < mat.m_material_channel.Count(),
  // then this face should use the material with id
  // mat.m_material_channel[face.m_material_channel.m_i-1].m_id.
  // If m_material_channel.m_i or the id is invalid in any way,
  // then the default should be used.
  int m_face_material_channel;

  // Persistent id for this face.  Default is ON_nil_uuid.
  ON_UUID m_face_uuid;
private:
  ON_BoundingBox m_bbox;      // 3d bounding box
  ON_Interval    m_domain[2]; // rectangular bounds of 2d curves
  ON_Mesh* m_render_mesh;
  ON_Mesh* m_analysis_mesh;
  ON_Mesh* m_preview_mesh;
  //int m_material_index; // if 0 (default), ON_Brep's object attributes
  //                      // determine material.
private:
  friend class ON_Brep;
  ON_Brep* m_brep;
  ON_BrepFace( const ON_BrepFace& );
};

class ON_CLASS ON_BrepFaceSide : public ON_Object
{
  ON_OBJECT_DECLARE(ON_BrepFaceSide);
public:
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // Union available for application use.
  // The constructor zeros m_faceside_user.
  // The value is of m_faceside_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_faceside_user;

  // index of face side in ON_BrepRegionTopology.m_FS[] array
  int m_faceside_index;  

  ON_BrepFaceSide();
  ~ON_BrepFaceSide();
  ON_BrepFaceSide& operator=(const ON_BrepFaceSide&);

  ON_BOOL32 Write(ON_BinaryArchive& binary_archive) const;
  ON_BOOL32 Read(ON_BinaryArchive& binary_archive);


  /*
  Returns:
   Brep this face side belongs to.
  */
  ON_Brep* Brep() const;

  /*
  Returns:
    Region topology this face side belongs to.
  */
  class ON_BrepRegionTopology* RegionTopology() const;

  /*
  Returns:
   Region the face side belongs to.
  */
  class ON_BrepRegion* Region() const;

  /*
  Returns:
   Face this side belongs to.
  */
  class ON_BrepFace* Face() const;

  /*
  Returns:
   +1: underlying geometric surface normal points
       into region.
   -1: underlying geometric surface normal points
       out of region.
  */
  int SurfaceNormalDirection() const;

public:
  int m_ri; // region index 
            // m_ri = -1 indicates this faceside overlaps
            // another faceside. Generally this is a flaw
            // in an ON_Brep.
  int m_fi; // face index
  int m_srf_dir; //  1 ON_BrepFace's surface normal points into region
                 // -1 ON_BrepFace's surface normal points out of region

private:
  friend class ON_Brep;
  friend class ON_BrepRegionTopology;
  ON_BrepRegionTopology* m_rtop;
  ON_BrepFaceSide( const ON_BrepFaceSide& );
};

class ON_CLASS ON_BrepRegion : public ON_Object
{
  ON_OBJECT_DECLARE(ON_BrepRegion);
public:
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  // Union available for application use.
  // The constructor zeros m_region_user.
  // The value is of m_region_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_region_user;

  // index of region in ON_BrepRegionTopology.m_R[] array
  int m_region_index;

  ON_BrepRegion();
  ~ON_BrepRegion();
  ON_BrepRegion& operator=(const ON_BrepRegion&);

  ON_BOOL32 Write(ON_BinaryArchive& binary_archive) const;
  ON_BOOL32 Read(ON_BinaryArchive& binary_archive);

  /*
  Returns:
   Brep this region belongs to.
  */
  ON_Brep* Brep() const;

  /*
  Returns:
    Region topology this region belongs to.
  */
  class ON_BrepRegionTopology* RegionTopology() const;

  /*
  Parameter:
    rfsi - [in] index into the region's m_fsi[] array.
  Returns:
    The face side in rtop.m_FS[m_fsi[rsi]], where
    rtop is the ON_BrepRegionTopology class this
    region belongs to.
  */
  ON_BrepFaceSide* FaceSide(int rfsi) const;

  /*
  Returns:
    True if the region is finite.
  */
  bool IsFinite() const;

  /*
  Returns:
   Region bounding box.
  */
  const ON_BoundingBox& BoundingBox() const;

  ON_SimpleArray<int> m_fsi; // indices of face sides
  int m_type; // 0 = infinte, 1 = bounded
  ON_BoundingBox m_bbox;

  /*
  Description:
    Get the boundary of a region as a brep object.  
    If the region is finite, the boundary will be a closed
    manifold brep.  The boundary may have more than one
    connected component.
  Parameters:
    brep - [in] if not NULL, the brep form is put into
                this brep.
  Returns: the region boundary as a brep or NULL if the
           calculation fails.
  */
  ON_Brep* RegionBoundaryBrep( ON_Brep* brep = NULL ) const;

private:
  friend class ON_Brep;
  friend class ON_BrepRegionTopology;
  ON_BrepRegionTopology* m_rtop;
  ON_BrepRegion( const ON_BrepRegion& );
};

#if defined(ON_DLL_TEMPLATE)
// This stuff is here because of a limitation in the way Microsoft
// handles templates and DLLs.  See Microsoft's knowledge base 
// article ID Q168958 for details.
#pragma warning( push )
#pragma warning( disable : 4231 )
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BrepVertex>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepVertex>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BrepEdge>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepEdge>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BrepTrim>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepTrim>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BrepLoop>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepLoop>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ClassArray<ON_BrepFace>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepFace>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepFaceSide>;
ON_DLL_TEMPLATE template class ON_CLASS ON_ObjectArray<ON_BrepRegion>;
#pragma warning( pop )
#endif

class ON_CLASS ON_BrepVertexArray : public ON_ObjectArray<ON_BrepVertex>
{
public:
  ON_BrepVertexArray();
  ~ON_BrepVertexArray();

  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepEdgeArray   : public  ON_ObjectArray<ON_BrepEdge>
{
public:
  ON_BrepEdgeArray();
  ~ON_BrepEdgeArray();
  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepTrimArray   : public  ON_ObjectArray<ON_BrepTrim>
{
public:
  ON_BrepTrimArray();
  ~ON_BrepTrimArray();
  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepLoopArray   : public  ON_ObjectArray<ON_BrepLoop>
{
public:
  ON_BrepLoopArray();
  ~ON_BrepLoopArray();
  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepFaceArray   : public  ON_ObjectArray<ON_BrepFace>
{
public:
  ON_BrepFaceArray();
  ~ON_BrepFaceArray();
  ON_BOOL32 Read( ON_BinaryArchive& );
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepFaceSideArray : public ON_ObjectArray<ON_BrepFaceSide>
{
public:
  ON_BrepFaceSideArray();
  ~ON_BrepFaceSideArray();

  bool Read( ON_BinaryArchive& );
  bool Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepRegionArray : public ON_ObjectArray<ON_BrepRegion>
{
public:
  ON_BrepRegionArray();
  ~ON_BrepRegionArray();

  bool Read( ON_BinaryArchive& );
  bool Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;
};

class ON_CLASS ON_BrepRegionTopology
{
public:
  ON_BrepRegionTopology();
  ON_BrepRegionTopology(const ON_BrepRegionTopology& src);
  ~ON_BrepRegionTopology();
  ON_BrepRegionTopology& operator=(const ON_BrepRegionTopology&);

  ON_BrepFaceSideArray m_FS;
  ON_BrepRegionArray m_R;

  ON_Brep* Brep() const;
  bool IsValid( ON_TextLog* text_log = 0 ) const;
  bool Read( ON_BinaryArchive& );
  bool Write( ON_BinaryArchive& ) const;

  unsigned int SizeOf() const;

private:
  friend class ON_BrepRegionTopologyUserData;
  friend class ON_Brep;
  ON_Brep* m_brep;
};

class ON_CLASS ON_Brep : public ON_Geometry 
{
  ON_OBJECT_DECLARE(ON_Brep);

public:
  // virtual ON_Object::DestroyRuntimeCache override
  void DestroyRuntimeCache( bool bDelete = true );

  // virtual ON_Object::SizeOf override
  unsigned int SizeOf() const;

  // virtual ON_Object::DataCRC override
  ON__UINT32 DataCRC(ON__UINT32 current_remainder) const;

  // virtual ON_Geometry override
  bool EvaluatePoint( const class ON_ObjRef& objref, ON_3dPoint& P ) const;

public:


  /*
  Description:
    Use ON_Brep::New() instead of new ON_Brep() when writing
    Rhino plug-ins (or when openNURBS is used as a Microsoft 
    DLL and you need to create a new ON_Brep in a different 
    .EXE or .DLL).
  Example:

              // bad - ON_Brep* pBrep = new ON_Brep();
              ON_Brep* pBrep = ON_Brep::New(); // good
              ...
              delete pBrep;
              pBrep = NULL;

  Returns:
    Pointer to an ON_Brep.  Destroy by calling delete.
  Remarks:
    When openNURBS is used as a Microsoft DLL, the CL.EXE
    compiler uses local vtables for classes that are new-ed
    in other executables but uses the ordinary vtable for
    for classes that are allocated in functions like
    ON_BrepCylinder(), ON_NurbsSurfaceQuadrilateral(),
    ON_Cylinder::RevSurfaceForm(NULL), etc.
    Using static New() functions like ON_Brep::New() insures
    that identical classes has the same vtable and makes
    all code run identically.
  */
  static ON_Brep* New();

  /*
  Description:
    Use ON_Brep::New(const ON_Brep& src) instead 
    of new ON_Brep(const ON_Brep& src).
  Returns:
    Pointer to an ON_Brep.  Destroy by calling delete.
  Remarks:
    See static ON_Brep* ON_Brep::New() for details.
  */
  static ON_Brep* New(const ON_Brep&);

	// Construction
  ON_Brep();
	~ON_Brep();		
  ON_Brep(const ON_Brep&);
  ON_Brep& operator=(const ON_Brep&);

  // Override of virtual ON_Object::MemoryRelocate
  void MemoryRelocate();


  /*
  Description:
    See if this and other are same brep geometry.
  Parameters:
    other - [in] other brep
    tolerance - [in] tolerance to use when comparing
                     control points.
  Returns:
    true if breps are the same
  */
  bool IsDuplicate( 
          const ON_Brep& other, 
          double tolerance = ON_ZERO_TOLERANCE 
          ) const;

  /////////////////////////////////////////////////////////////////
  // construction/destruction helpers

  // returns Brep to state it has after default construction
  void Destroy(); 

  // call if memory pool used by b-rep members becomes invalid
  void EmergencyDestroy(); 

  /*
  Description:
    Calculates polygon mesh approximation of the brep
    and appends one mesh for each face to the mesh_list[]
    array.
  Parameters:
    mp - [in] meshing parameters
    mesh_list - [out] meshes are appended to this array.
  Returns:
    Number of meshes appended to mesh_list[] array.
  */
  int CreateMesh( 
    const ON_MeshParameters& mp,
    ON_SimpleArray<ON_Mesh*>& mesh_list
    ) const;

  /*
  Description:
    Destroy meshes used to render and analyze brep.
  Parameters:
    mesh_type - [in] type of mesh to destroy
    bDeleteMesh - [in] if true, cached meshes are deleted.
      If false, pointers to cached meshes are just set to NULL.
  See Also:
    ON_Brep::GetMesh
    ON_BrepFace::DestroyMesh
    ON_BrepFace::Mesh
    ON_BrepFace::SetMesh
  */
  void DestroyMesh( ON::mesh_type mesh_type, bool bDeleteMesh = true );

  /*
  Description:
    Get cached meshes used to render and analyze brep.
  Parameters:
    mesh_type - [in] type of mesh to get
    meshes - [out] meshes are appended to this array.  The ON_Brep
      owns these meshes so they cannot be modified.
  Returns:
    Number of meshes added to array. (Same as m_F.Count())
  See Also:
    ON_Brep::DestroyMesh
    ON_BrepFace::DestroyMesh
    ON_BrepFace::Mesh
    ON_BrepFace::SetMesh
  */
  int GetMesh( ON::mesh_type mesh_type, ON_SimpleArray< const ON_Mesh* >& meshes ) const;

  /*
  Description:
    Create a brep from a surface.  The resulting surface has an outer
    boundary made from four trims.  The trims are ordered so that
    they run along the south, east, north, and then west side of the
    surface's parameter space.
  Parameters:
    pSurface - [in] pointer to a surface.  The brep will manage this
       pointer and delete it in ~ON_Brep.
  Returns:
    @untitled table
    true     successful
      When true is returned, the pSurface pointer is added to the
      brep's m_S[] array and it will be deleted by the brep's
      destructor.
    false
      brep cannot be created from this surface.
      When false is returned, then the caller is responsible
      for deleting pSurface unless it was previously added
      to the brep's m_S[] array.     
  Remarks:
    The surface class must be created with new so that the
    delete in ~ON_Brep will not cause a crash.
  */
  bool Create( 
          ON_Surface*& pSurface
          );

  bool Create( 
          ON_NurbsSurface*& pNurbsSurface
          );

  bool Create( 
          ON_PlaneSurface*& pPlaneSurface
          );

  bool Create( 
          ON_RevSurface*& pRevSurface
          );

  bool Create( 
          ON_SumSurface*& pSumSurface
          );

  /*
  Description:
    Tests an object to see if its data members are correctly
    initialized.
  Parameters:
    text_log - [in] if the object is not valid and text_log
        is not NULL, then a brief englis description of the
        reason the object is not valid is appened to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     object is valid
    false    object is invalid, uninitialized, etc.
  Remarks:
    Overrides virtual ON_Object::IsValid
  See Also:
    ON_Brep::SetTolerancesAndFlags
  */
  ON_BOOL32 IsValid( ON_TextLog* text_log = NULL ) const;

  /*
  Description:
    Tests the brep to see if its topology information is
    valid.
  Parameters:
    text_log - [in] if the brep topology is not valid and 
        text_log is not NULL, then a brief english 
        description of the problem is appended to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     brep topology is valid
    false    brep topology is not valid
  Remarks:
    ON_Brep::IsValidTopology can be called at any time.
  See Also:
    ON_Brep::IsValid
    ON_Brep::IsValidGeometry
    ON_Brep::IsValidTolerancesAndFlags
  */
  bool IsValidTopology( ON_TextLog* text_log = NULL ) const;


  /*
  Description:
    Expert user function that tests the brep to see if its
    geometry information is valid.  The value of 
    brep.IsValidTopology() must be true before 
    brep.IsValidGeometry() can be safely called.
  Parameters:
    text_log - [in] if the brep geometry is not valid and 
        text_log is not NULL, then a brief english 
        description of the problem is appended to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     brep geometry is valid
    false    brep geometry is not valid
  Remarks:
    ON_Brep::IsValidTopology must be true before you can
    safely call ON_Brep::IsValidGeometry.
  See Also:
    ON_Brep::IsValid
    ON_Brep::IsValidTopology
    ON_Brep::IsValidTolerancesAndFlags
  */
  bool IsValidGeometry( ON_TextLog* text_log = NULL ) const;

  /*
  Description:
    Expert user function that tests the brep to see if its
    tolerances and flags are valid.  The values of 
    brep.IsValidTopology() and brep.IsValidGeometry() must
    be true before brep.IsValidTolerancesAndFlags() can 
    be safely called.
  Parameters:
    text_log - [in] if the brep tolerance or flags are not
        valid and text_log is not NULL, then a brief english 
        description of the problem is appended to the log.
        The information appended to text_log is suitable for 
        low-level debugging purposes by programmers and is 
        not intended to be useful as a high level user 
        interface tool.
  Returns:
    @untitled table
    true     brep tolerance and flags are valid
    false    brep tolerance and flags are not valid
  Remarks:
    ON_Brep::IsValidTopology and ON_Brep::IsValidGeometry
    must be true before you can safely call
    ON_Brep::IsValidTolerancesAndFlags.
  See Also:
    ON_Brep::IsValid
    ON_Brep::IsValidTopology
    ON_Brep::IsValidGeometry
  */
  bool IsValidTolerancesAndFlags( ON_TextLog* text_log = NULL ) const;

  // Description:
  //   Tests brep to see if it is valid for 
  //   saving in V2 3DM archives.
  // Returns:
  //   true if brep is valid for V2 3DM archives.
  // Remarks:
  //   V2 breps could not have dangling curves.
  bool IsValidForV2() const;
  bool IsValidForV2( const ON_BrepTrim& ) const;
  bool IsValidForV2( const ON_BrepEdge& ) const;

  /*
  Description:
    Split any faces with creases into G1 pieces.
  Parameters:
    kink_tol_radians - [in] kink tolerance
    bCompactIfNeeded - [in]
      If true and splitting is performed, ON_Brep::Compact()
      will be called to clean up the unsued parts.
  Returns:
    True if successful.
  Remarks:
    If you need to detect when splitting occured, comare the
    before and after values of m_F.Count().
  */
  bool SplitKinkyFaces( 
                       double kink_tol_radians = ON_DEFAULT_ANGLE_TOLERANCE,
          bool bCompactIfNeeded = true
                        );

  /*
  Description:
    Split the face into G1 pieces.
  Parameters:
    face_index - [in] Index of the face to test and split.
    kink_tol_radians - [in] kink tolerance
  Returns:
    True if successful.
  Remarks:
    This function leaves deleted stuff in the brep.  
    Call ON_Brep::Compact() to remove deleted stuff.
  */
  virtual
    bool SplitKinkyFace( 
                        int face_index, 
                        double kink_tol_radians = ON_DEFAULT_ANGLE_TOLERANCE // ON_PI/180.0
                         );

  /*
  Description:
    Split the edge into G1 pieces.
  Parameters:
    edge_index - [in] Index of the edge to test and split.
    kink_tol_radians - [in] kink tolerance
  Returns:
    True if successful.
  Remarks:
    This function leaves deleted stuff in the brep.  
    Call ON_Brep::Compact() to remove deleted stuff.
  */
  virtual
    bool SplitKinkyEdge( 
                        int edge_index, 
                        double kink_tol_radians = ON_DEFAULT_ANGLE_TOLERANCE //ON_PI/180.0
                         );

  // virtual ON_Objet::Dump() override
  void Dump( ON_TextLog& ) const; // for debugging

  // virtual ON_Objet::Write() override
  ON_BOOL32 Write( ON_BinaryArchive& ) const;

  // virtual ON_Objet::Read() override
  ON_BOOL32 Read( ON_BinaryArchive& );

  // virtual ON_Objet::ObjectType() override
  ON::object_type ObjectType() const;

  // virtual ON_Geometry::Dimension() override
  int Dimension() const;

  // virtual ON_Geometry::ClearBoundingBox() override
  void ClearBoundingBox();

  // virtual ON_Geometry::GetBBox() override
  ON_BOOL32 GetBBox( // returns true if successful
         double*,    // minimum
         double*,    // maximum
         ON_BOOL32 = false  // true means grow box
         ) const;

  // virtual ON_Geometry::Transform() override
  ON_BOOL32 Transform( 
         const ON_Xform&
         );

  // virtual ON_Geometry::SwapCoordinates() override
  ON_BOOL32 SwapCoordinates(
        int, int        // indices of coords to swap
        );

  // virtual ON_Geometry::HasBrepForm() override
  ON_BOOL32 HasBrepForm() const; // returns true

  /*
  Description:
    If possible, BrepForm() creates a brep form of the
    ON_Geometry. 
  Parameters:
    brep - [in] if not NULL, brep is used to store the brep
        form of the geometry.
  Result:
    If brep is not NULL, then brep = this, otherwise
    a duplicate of this is returned.
  Remarks:
    Override of virtual ON_Geometry::BrepForm
  */
  ON_Brep* BrepForm( ON_Brep* brep = NULL ) const;

  /////////////////////////////////////////////////////////////////
  // Creation Interface

  // These add a new geometry piece to the b-rep and return the
  // index that should be used to reference the geometry.
  // -1 is returned if the input is not acceptable.
  // ~ON_Brep() will delete the geometry.
  int AddTrimCurve( ON_Curve* ); // 2d curve used by ON_BrepTrim
  int AddEdgeCurve( ON_Curve* ); // 3d curve used by ON_BrepEdge
  int AddSurface( ON_Surface* ); // 3d surface used by ON_BrepFace

  // Description:
  //   Set 3d curve geometry used by a b-rep edge.
  // Parameters:
  //   edge - [in]
  //   c3_index - [in] index of 3d curve in m_C3[] array
  //   sub_domain - [in] if not NULL, sub_domain is an increasing
  //      sub interval of m_C3[c3_index]->Domain().
  // Returns:
  //   true if successful.
  bool SetEdgeCurve( 
    ON_BrepEdge& edge,
    int c3_index,
    const ON_Interval* sub_domain = NULL
    );

  // Description:
  //   Set 2d curve geometry used by a b-rep trim.
  // Parameters:
  //   trim - [in]
  //   c2_index - [in] index of 2d curve in m_C2[] array
  //   sub_domain - [in] if not NULL, sub_domain is an increasing
  //      sub interval of m_C2[c2_index]->Domain().
  // Returns:
  //   true if successful.
  bool SetTrimCurve( 
    ON_BrepTrim& trim,
    int c2_index,
    const ON_Interval* sub_domain = NULL
    );

  // These add a new topology piece to the b-rep and return a 
  // reference that is intended to be used for initialization.
  ON_BrepVertex& NewVertex();
  ON_BrepVertex& NewVertex( 
    ON_3dPoint vertex_point,
    double vertex_tolerance = ON_UNSET_VALUE
    );

  ON_BrepEdge& NewEdge(
                  int = -1              // 3d curve index
                  );
  ON_BrepEdge& NewEdge( 
                  ON_BrepVertex&, // start vertex
                  ON_BrepVertex&, // end vertex
                  int = -1,       // 3d curve index
                  const ON_Interval* = NULL, // sub_domain
                  double edge_tolerance = ON_UNSET_VALUE
                  );

  /*
  Description:
    Add a new face to a brep.  An incomplete face is added.
    The caller must create and fill in the loops used by
    the face.
  Parameters:
    si - [in] index of surface in brep's m_S[] array
  Returns:
    Reference to new face.
  Remarks:
    Adding a new face may grow the dynamic m_F array.  When
    this happens pointers and references to memory in the
    previous m_F[] array may become invalid.  Use face indices
    if this is an issue.
  Example:
    See ON_BrepBox and ON_BrepSphere source code.
  See Also:
    ON_Brep::AddSurface
  */
  ON_BrepFace& NewFace(
                  int si = -1
                  );

  /*
  Description:
    Add a new face to a brep.  This creates a complete face with
    new vertices at the surface corners, new edges along the surface
    boundary, etc.  The loop of the returned face has four trims that
    correspond to the south, east, north, and west side of the 
    surface in that order.  If you use this version of NewFace to
    add an exiting brep, then you are responsible for using a tool
    like ON_Brep::JoinEdges() to hook the new face to its
    neighbors.
  Parameters:
    surface - [in] surface is copied.
  Returns:
    Pointer to new face.
  Remarks:
    Adding a new face may grow the dynamic arrays used to store
    vertices, edges, faces, loops, and trims.  When these dyamic
    arrays are grown, any pointers and references to memory in
    the previous arrays may become invalid.  Use indices
    if this is an issue.
  See Also:
    ON_Brep::JoinEdges
    ON_Brep::AddSurface
  */
  ON_BrepFace* NewFace( 
    const ON_Surface& surface 
    );

  /*
  Description:
    Add a new face to brep.  This version is for expert users.
  Parameters:
    pSurface - [in] the returned face will have an outer loop
                    that goes around the edges of the surface.
    vid - [in/out] four vertex indices that specify the vertices at
                   the (sw,se,nw,ne) corners.  If the input value
                   of a vertex index is -1, then the vertex will be 
                   created.
    eid - [in/out] four edge indices that specify the edges for
                   the (south,east,north,west) sides.  If the input value
                   of an edge index is -1, then the edge will be created.
    bRev3d - [in/out] four values of the trim m_bRev3d flags of
                   the (south,east,north,west) sides.
  Returns:
    If null is returned, then the caller must delete pSurace
    unless it was previously added to the brep's m_S[] array.
    Pointer to the new face or NULL if input is not valid.
  Remarks:
    Adding a new face may grow the dynamic m_F array.  When
    this happens pointers and references to memory in the
    previous m_F[] array may become invalid.  Use face indices
    if this is an issue.
  Example:
    See ON_BrepBox and ON_BrepSphere source code.
  See Also:
    ON_Brep::AddSurface
    ON_Brep::AddFace( int si )
    ON_Brep::Create( ON_Surface*& )
  */
  ON_BrepFace* NewFace(
       ON_Surface* pSurface,
       int vid[4],
       int eid[4],
       ON_BOOL32 bRev3d[4]
       );

  /*
  Description:
    Add a new face to the brep whose surface geometry is a 
    ruled surface between two edges.
  Parameters:
    edgeA - [in] The south side of the face's surface will
          run along edgeA.
    bRevEdgeA - [in] true if the new face's outer boundary
          orientation along edgeA is opposite the orientation
          of edgeA.
    edgeB - [in] The north side of the face's surface will
          run along edgeA.
    bRevEdgeB - [in] true if the new face's outer boundary
          orientation along edgeB is opposite the orientation
          of edgeB.
  Returns:
    A pointer to the new face or a NULL if the new face could
    not be created.
  */
  ON_BrepFace* NewRuledFace(
        const ON_BrepEdge& edgeA,
        bool bRevEdgeA,
        const ON_BrepEdge& edgeB, 
        bool bRevEdgeB
        );

  /*
  Description:
    Add a new face to the brep whose surface geometry is a 
    ruled cone with the edge as the base and the vertex as
    the apex point.
  Parameters:
    vertex - [in] The apex of the cone will be at this vertex.
                   The north side of the surface's parameter
                   space will be a singular point at the vertex.
    edge - [in] The south side of the face's surface will
          run along this edge.
    bRevEdge - [in] true if the new face's outer boundary
          orientation along the edge is opposite the 
          orientation of edge.
  Returns:
    A pointer to the new face or a NULL if the new face could
    not be created.
  */
  ON_BrepFace* NewConeFace(
        const ON_BrepVertex& vertex,
        const ON_BrepEdge& edge,
        bool bRevEdge
        );

  /*
  Description:
    Create a new outer boundary loop that runs along the edges
    of the underlying surface.
  Returns:
    New outer boundary loop.
  */
  ON_BrepLoop& NewLoop( ON_BrepLoop::TYPE );

  /*
  Description:
    Create a new boundary loop on a face.  After you get this
    ON_BrepLoop, you still need to create the vertices, edges, 
    and trims that define the loop.
  Returns:
    New loop that needs to be filled in.
  */
  ON_BrepLoop& NewLoop( ON_BrepLoop::TYPE loop_type, ON_BrepFace& face );

  /*
  Description:
    Create a new outer boundary loop that runs along the sides
    of the face's surface.  All the necessary trims, edges,
    and vertices are created and added to the brep.
  Parameters:
    face_index - [in] index of face that needs an outer boundary
                      that runs along the sides of its surface.
  Returns:
    New outer boundary loop that is complete.
  */
  ON_BrepLoop* NewOuterLoop( int face_index );

  /*
  Description:
    Add a new face to brep.  This version is for expert users.
  Parameters:
    face_index - [in] index of face that will get a new outer
                   loop running around the sides of the face's
                   underlying surface.
    vid - [in/out] four vertex indices that specify the vertices at
                   the (sw,se,nw,ne) corners.  If the input value
                   of a vertex index is -1, then the vertex will be 
                   created.
    eid - [in/out] four edge indices that specify the edges for
                   the (south,east,north,west) sides.  If the input value
                   of an edge index is -1, then the edge will be created.
    bRev3d - [in/out] four values of the trim m_bRev3d flags of
                   the (south,east,north,west) sides.
  Returns:
    Pointer to the new loop or NULL if input is not valid.
  Remarks:
    Adding a new loop may grow the dynamic m_L array.  When
    this happens pointers and references to memory in the
    previous m_L[] array may become invalid.  Use face indices
    if this is an issue.
  See Also:
    ON_Brep::NewFace
  */
  ON_BrepLoop* NewOuterLoop(
         int face_index,
         int vid[4],
         int eid[4],
         ON_BOOL32 bRev3d[4]
         );

  /*
  Description:
    Add a planar trimming loop to a planar face.
  Parameters:
    face_index - [in] index of planar face.  The underlying
        suface must be an ON_PlaneSurface.
    loop_type - [in] type of loop to add.  If loop_type is
        ON_BrepLoop::unknown, then the loop direction is tested
        and the the new loops type will be set to 
        ON_BrepLoop::outer or ON_BrepLoop::inner.  If the loop_type
        is ON_BrepLoop::outer, then the direction of the new loop
        is tested and flipped if it is clockwise. If the loop_type
        is ON_BrepLoop::inner, then the direction of the new loop
        is tested and flipped if it is counter-clockwise.
    boundary - [in] a list of 3d curves that form a simple (no self
        intersections) closed curve.  These curves define the 3d
        edge geometry and should be near the planar surface.
    bDuplicateCurves - [in] If true, then duplicates of the curves 
        in the boundary array are added to the brep.  If false, the
        curves in the boundary array are added to the brep and will
        be deleted by ON_Brep::~ON_Brep.
    Returns:
      true if successful.  The new loop will be brep.m_L.Last().
  */
  bool NewPlanarFaceLoop(
        int face_index,
        ON_BrepLoop::TYPE loop_type,
        ON_SimpleArray<ON_Curve*>& boundary,
        ON_BOOL32 bDuplicateCurves = true
        );


  /*
  Description:
    Add a new trim that will be part of an inner, outer, or slit loop
    to the brep.
  Parameters:
    c2i - [in] index of 2d trimming curve
  Returns:
    new trim
  Example:
    int c2i = brep->AddTrimCurve( p2dCurve );
    ON_BrepTrim& trim = NewTrim( edge, bRev3d, loop, c2i );
    trim.m_ei = ...;
    trim.m_li = ...;
    trim.m_tolerance[0] = ...;
    trim.m_tolerance[1] = ...;
    trim.m_type = ...;
    trim.m_iso = ...;
  Remarks:
    You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
    ON_BrepTrim::m_iso, ON_BrepTrim::m_li, and ON_BrepTrim::m_ei values.
        In general, you should try to use the
    ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.
    If you want to add a singular trim, use ON_Brep::NewSingularTrim.
    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
  See Also:
    ON_Brep::SetTrimTypeFlags
    ON_Brep::SetTrimIsoFlags
    ON_Brep::NewSingularTrim
    ON_Brep::NewPointOnFace
    ON_Brep::NewCurveOnFace
  */
  ON_BrepTrim& NewTrim(
                  int c2i = -1
                  );

  /*
  Description:
    Add a new trim that will be part of an inner, outer, or slit loop
    to the brep.
  Parameters:
    bRev3d - [in] ON_BrepTrim::m_bRev3d value.  true if the
       edge and trim have opposite directions.
    loop - [in] trim is appended to this loop
    c2i - [in] index of 2d trimming curve
  Returns:
    new trim
  Example:
    int c2i = brep->AddTrimCurve( p2dCurve );
    ON_BrepTrim& trim = NewTrim( edge, bRev3d, loop, c2i );
    trim.m_ei = ...;
    trim.m_tolerance[0] = ...;
    trim.m_tolerance[1] = ...;
    trim.m_type = ...;
    trim.m_iso = ...;
  Remarks:
    You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
    ON_BrepTrim::m_iso, and ON_BrepTrim::m_ei values.
        In general, you should try to use the
    ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.
    If you want to add a singular trim, use ON_Brep::NewSingularTrim.
    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
  See Also:
    ON_Brep::SetTrimTypeFlags
    ON_Brep::SetTrimIsoFlags
    ON_Brep::NewSingularTrim
    ON_Brep::NewPointOnFace
    ON_Brep::NewCurveOnFace
  */
  ON_BrepTrim& NewTrim(
                  ON_BOOL32 bRev3d,
                  ON_BrepLoop& loop,
                  int c2i = -1
                  );

  /*
  Description:
    Add a new trim that will be part of an inner, outer, or slit loop
    to the brep.
  Parameters:
    edge - [in] 3d edge associated with this trim
    bRev3d - [in] ON_BrepTrim::m_bRev3d value.  true if the
       edge and trim have opposite directions.
    c2i - [in] index of 2d trimming curve
  Returns:
    new trim
  Example:
    int c2i = brep->AddTrimCurve( p2dCurve );
    ON_BrepTrim& trim = NewTrim( edge, bRev3d, c2i );
    trim.m_li = ...;
    trim.m_tolerance[0] = ...;
    trim.m_tolerance[1] = ...;
    trim.m_type = ...;
    trim.m_iso = ...;
  Remarks:
    You should set the trim's ON_BrepTrim::m_tolerance, 
    ON_BrepTrim::m_type, ON_BrepTrim::m_iso, 
    and ON_BrepTrim::m_li values.
        In general, you should try to use the
    ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.
    If you want to add a singular trim, use ON_Brep::NewSingularTrim.
    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
  See Also:
    ON_Brep::SetTrimTypeFlags
    ON_Brep::SetTrimIsoFlags
    ON_Brep::NewSingularTrim
    ON_Brep::NewPointOnFace
    ON_Brep::NewCurveOnFace
  */
  ON_BrepTrim& NewTrim(
                  ON_BrepEdge& edge,
                  ON_BOOL32 bRev3d,
                  int c2i = -1
                  );

  /*
  Description:
    Add a new trim that will be part of an inner, outer, or slit loop
    to the brep.
  Parameters:
    edge - [in] 3d edge associated with this trim
    bRev3d - [in] ON_BrepTrim::m_bRev3d value.  true if the
       edge and trim have opposite directions.
    loop - [in] trim is appended to this loop
    c2i - [in] index of 2d trimming curve
  Returns:
    new trim
  Example:
    int c2i = brep->AddTrimCurve( p2dCurve );
    ON_BrepTrim& trim = brep->NewTrim( edge, bRev3d, loop, c2i );
    trim.m_tolerance[0] = ...;
    trim.m_tolerance[1] = ...;
  Remarks:
    You should set the trim's ON_BrepTrim::m_tolerance values.
    If c2i is -1, you must set the trim's ON_BrepTrim::m_iso values.
    This version of NewTrim sets the trim.m_type value.  If the
    input edge or loop are not currently valid, then you may
    need to adjust the trim.m_type value.
    If you want to add a singular trim, use ON_Brep::NewSingularTrim.
    If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
    If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
  See Also:
    ON_Brep::SetTrimTypeFlags
    ON_Brep::SetTrimIsoFlags
    ON_Brep::NewSingularTrim
    ON_Brep::NewPointOnFace
    ON_Brep::NewCurveOnFace
  */
  ON_BrepTrim& NewTrim(
                  ON_BrepEdge& edge,
                  ON_BOOL32 bRev3d,
                  ON_BrepLoop& loop,
                  int c2i = -1
                  );

  /*
  Description:
    Add a new singular trim to the brep.
  Parameters:
    vertex - [in] vertex along collapsed surface edge
    loop - [in] trim is appended to this loop
    iso - [in] one of ON_Surface::S_iso, ON_Surface::E_iso, 
               ON_Surface::N_iso, or ON_Surface::W_iso.
    c2i - [in] index of 2d trimming curve
  Returns:
    new trim
  See Also:
    ON_Brep::NewTrim
  */
  ON_BrepTrim& NewSingularTrim(
                  const ON_BrepVertex& vertex,
                  ON_BrepLoop& loop,
                  ON_Surface::ISO iso,
                  int c2i = -1
                  );

  /*
  Description:
    Adds a new point on face to the brep.
  Parameters:
    face - [in] face that vertex lies on
    s,t - [in] surface parameters
  Returns:
    new vertex that represents the point on face.
  Remarks:
    If a vertex is a point on a face, then brep.m_E[m_ei]
    will be an edge with no 3d curve.  This edge will have
    a single trim with type ON_BrepTrim::ptonsrf.  There
    will be a loop containing this single trim.
  */
  ON_BrepVertex& NewPointOnFace( 
    ON_BrepFace& face,
    double s,
    double t
    );

  /*
  Description:
    Add a new curve on face to the brep.
  Parameters:
    face - [in] face that curve lies on
    edge - [in] 3d edge associated with this curve on surface
    bRev3d - [in] true if the 3d edge and the 2d parameter space 
                  curve have opposite directions.
    c2i - [in] index of 2d curve in face's parameter space
  Returns:
    new trim that represents the curve on surface
  Remarks:
    You should set the trim's ON_BrepTrim::m_tolerance and
    ON_BrepTrim::m_iso values.
  */
  ON_BrepTrim& NewCurveOnFace(
                  ON_BrepFace& face,
                  ON_BrepEdge& edge,
                  ON_BOOL32 bRev3d = false,
                  int c2i = -1
                  );

  // appends a copy of brep to this and updates
  // indices of appended brep parts.  Duplicates are not removed.
  void Append( 
    const ON_Brep& // brep
    ); 

  // This function can be used to compute vertex information for a
  // b-rep when everything but the m_V array is properly filled in.
  // It is intended to be used when creating a ON_Brep from a 
  // definition that does not include explicit vertex information.
  void SetVertices(void);

  // This function can be used to set the ON_BrepTrim::m_iso
  // flag. It is intended to be used when creating a ON_Brep from
  // a definition that does not include compatible parameter space
  // type information.
  // See Also: ON_BrepSetFlagsAndTolerances
  bool SetTrimIsoFlags();    // sets all trim iso flags
  bool SetTrimIsoFlags( ON_BrepFace& );
  bool SetTrimIsoFlags( ON_BrepLoop& );
  bool SetTrimIsoFlags( ON_BrepTrim& );


  /*
  Description:
    Calculate the type (singular, mated, boundary, etc.) of
    an ON_BrepTrim object.
  Parameters:
    trim - [in]
    bLazy - [in] if true and trim.m_type is set to something other
       than ON_BrepTrim::unknown, then no calculation is
       performed and the value of trim.m_type is returned.
       If false, the value of trim.m_type is ignored and is caluculated.
  Returns:
    Type of trim.
  Remarks:
    The trim must be connected to a valid loop.
  See Also:
    ON_Brep::SetTrimTypeFlags
  */
  ON_BrepTrim::TYPE TrimType( 
    const ON_BrepTrim& trim, 
    ON_BOOL32 bLazy = true
    ) const;

  // This function can be used to set the ON_BrepTrim::m_type
  // flag.  If the optional bLazy argument is true, then only
  // trims with m_type = unknown are set.
  // See Also: ON_BrepSetFlagsAndTolerances
  bool SetTrimTypeFlags( ON_BOOL32 bLazy = false );    // sets all trim iso flags
  bool SetTrimTypeFlags( ON_BrepFace&, ON_BOOL32 bLazy = false );
  bool SetTrimTypeFlags( ON_BrepLoop&, ON_BOOL32 bLazy = false );
  bool SetTrimTypeFlags( ON_BrepTrim&, ON_BOOL32 bLazy = false );

  // GetTrim2dStart() evaluates the start of the
  // parameter space (2d) trim curve.
  bool GetTrim2dStart( 
          int trim_index,         // index of ON_BrepTrim in m_T[] array
          ON_2dPoint& 
          ) const;

  // GetTrim2dEnd() evaluates end of the
  // parameter space (2d) trim curve.
  bool GetTrim2dEnd(
          int,         // index of ON_BrepTrim in m_T[] array
          ON_2dPoint& 
          ) const;

  // GetTrim3dStart() evaluates the 3d surface at the start of the
  // parameter space (2d) trim curve.
  bool GetTrim3dStart( 
          int,         // index of ON_BrepTrim in m_T[] array
          ON_3dPoint& 
          ) const;

  // GetTrim3dEnd() evaluates the 3d surface at the end of the
  // parameter space (2d) trim curve.
  bool GetTrim3dEnd(
          int,         // index of ON_BrepTrim in m_T[] array
          ON_3dPoint& 
          ) const;

  // This function examines the 2d parameter space curves and returns
  // the loop's type based on their orientation.  Use this function for
  // debugging loop orientation problems.
  ON_BrepLoop::TYPE ComputeLoopType( const ON_BrepLoop& ) const;

  // These set the various tolerances.  The optional ON_BOOL32 argument
  // is called bLazy.  If bLazy is false, the tolerance is recomputed
  // from its definition.  If bLazy is true, the tolerance is computed
  // only if its current value is negative.
  bool SetVertexTolerance( ON_BrepVertex& vertex, ON_BOOL32 bLazy = false ) const;
  virtual
  bool SetTrimTolerance( ON_BrepTrim& trim, ON_BOOL32 bLazy = false ) const;
  virtual
  bool SetEdgeTolerance( ON_BrepEdge& edge, ON_BOOL32 bLazy = false ) const;

  /*
  Description:
    Set the brep's vertex tolerances.
  Parameters:
    bLazy - [in] if true, only vertex tolerances with the value
       ON_UNSET_VALUE will be set.  If false, the vertex tolerance
       is recomputed from the geometry in the brep.
  Returns:
    true if successful.
  See Also:
    ON_Brep::SetVertexTolerance
    ON_Brep::SetTrimTolerance
    ON_Brep::SetEdgeTolerance
    ON_Brep::SetVertexTolerances
    ON_Brep::SetTrimTolerances
    ON_Brep::SetEdgeTolerances
    ON_Brep::SetTolerancesAndFlags
  */
  bool SetVertexTolerances( ON_BOOL32 bLazy = false );

  /*
  Description:
    Set the brep's trim tolerances.
  Parameters:
    bLazy - [in] if true, only trim tolerances with the value
       ON_UNSET_VALUE will be set.  If false, the trim tolerance
       is recomputed from the geometry in the brep.
  Returns:
    true if successful.
  See Also:
    ON_Brep::SetVertexTolerance
    ON_Brep::SetTrimTolerance
    ON_Brep::SetEdgeTolerance
    ON_Brep::SetVertexTolerances
    ON_Brep::SetTrimTolerances
    ON_Brep::SetEdgeTolerances
    ON_Brep::SetTolerancesAndFlags
  */
  bool SetTrimTolerances( ON_BOOL32 bLazy = false );

  /*
  Description:
    Set the brep's edge tolerances.
  Parameters:
    bLazy - [in] if true, only edge tolerances with the value
       ON_UNSET_VALUE will be set.  If false, the edge tolerance
       is recomputed from the geometry in the brep.
  Returns:
    true if successful.
  See Also:
    ON_Brep::SetVertexTolerance
    ON_Brep::SetTrimTolerance
    ON_Brep::SetEdgeTolerance
    ON_Brep::SetVertexTolerances
    ON_Brep::SetTrimTolerances
    ON_Brep::SetEdgeTolerances
    ON_Brep::SetTolerancesAndFlags
  */
  bool SetEdgeTolerances( ON_BOOL32 bLazy = false );


  /*
  Description:
    Set the trim parameter space bounding box (trim.m_pbox).
  Parameters:
    trim - [in]
    bLazy - [in] if true and trim.m_pbox is valid, then
       the box is not set.
  Returns:
    true if trim ends up with a valid bounding box.
  */
  virtual
  bool SetTrimBoundingBox( ON_BrepTrim& trim, ON_BOOL32 bLazy=false );

  /*
  Description:
    Set the loop parameter space bounding box (loop.m_pbox).
  Parameters:
    loop - [in]
    bLazy - [in] if true and loop trim trim.m_pbox is valid, 
       then that trim.m_pbox is not recalculated.
  Returns:
    true if loop ends up with a valid bounding box.
  */
  virtual
  bool SetTrimBoundingBoxes( ON_BrepLoop& loop, ON_BOOL32 bLazy=false );


  /*
  Description:
    Set the loop and trim parameter space bounding boxes
    for every loop and trim in the face 
  Parameters:
    face - [in]
    bLazy - [in] if true and trim trim.m_pbox is valid, 
       then that trim.m_pbox is not recalculated.
  Returns:
    true if all the face's loop and trim parameter space bounding 
    boxes are valid.
  */
  virtual
  bool SetTrimBoundingBoxes( ON_BrepFace& face, ON_BOOL32 bLazy=false );

  /*
  Description:
    Set the loop and trim parameter space bounding boxes
    for every loop and trim in the brep.
  Parameters:
    bLazy - [in] if true and trim trim.m_pbox is valid, 
       then that trim.m_pbox is not recalculated.
  Returns:
    true if all the loop and trim parameter space bounding boxes
    are valid.
  */
  virtual
  bool SetTrimBoundingBoxes( ON_BOOL32 bLazy=false );

  /*
  Description:
    Set tolerances and flags in a brep
  Parameters:
    bLazy - [in] if true, only flags and tolerances that are not
       set will be calculated.
    bSetVertexTolerances - [in] true to compute vertex.m_tolerance values
    bSetEdgeTolerances - [in] true to compute edge.m_tolerance values
    bSetTrimTolerances - [in] true to compute trim.m_tolerance[0,1] values
    bSetTrimIsoFlags - [in] true to compute trim.m_iso values
    bSetTrimTypeFlags - [in] true to compute trim.m_type values
    bSetLoopTypeFlags - [in] true to compute loop.m_type values
    bSetTrimBoxes - [in] true to compute trim.m_pbox values
  See Also:
    ON_Brep::SetVertexTolerance
    ON_Brep::SetEdgeTolerance
    ON_Brep::SetTrimTolerance
    ON_Brep::SetTrimTypeFlags
    ON_Brep::SetTrimIsoFlags
    ON_Brep::ComputeLoopType
    ON_Brep::SetTrimBoundingBox
    ON_Brep::SetTrimBoundingBoxes
  */
  void SetTolerancesBoxesAndFlags(
       ON_BOOL32 bLazy = false,
       ON_BOOL32 bSetVertexTolerances = true,
       ON_BOOL32 bSetEdgeTolerances = true,
       ON_BOOL32 bSetTrimTolerances = true,
       ON_BOOL32 bSetTrimIsoFlags = true,
       ON_BOOL32 bSetTrimTypeFlags = true,
       ON_BOOL32 bSetLoopTypeFlags = true,
       ON_BOOL32 bSetTrimBoxes = true
       );


  /////////////////////////////////////////////////////////////////
  // Query Interface

  /*
  Description:
    Determine how many brep faces reference m_S[surface_index].
  Parameters:
    surface_index - [in] index of the surface in m_S[] array
    max_count - [in] counting stops if max_count > 0 and
                     at least max_count faces use the surface.
  Returns:
    Number of brep faces that reference the surface.
  */
  int SurfaceUseCount( 
              int surface_index,
              int max_count=0 ) 
              const;
  /*
  Description:
    Determine how many brep edges reference m_C3[c3_index].
  Parameters:
    c3_index - [in] index of the 3d curve in m_C3[] array
    max_count - [in] counting stops if max_count > 0 and
                     at least max_count edges use the 3d curve.
  Returns:
    Number of brep edges that reference the 3d curve.
  */
  int EdgeCurveUseCount( 
              int c3_index,
              int max_count=0 ) 
              const;

  /*
  Description:
    Determine how many brep trims reference m_C2[c2_index].
  Parameters:
    c2_index - [in] index of the 2d curve in m_C2[] array
    max_count - [in] counting stops if max_count > 0 and
                     at least max_count trims use the 2d curve.
  Returns:
    Number of brep trims that reference the 2d curve.
  */
  int TrimCurveUseCount( 
              int c2_index,
              int max_count=0 ) 
              const;

  /*
  Description:
    Get a single 3d curve that traces the entire loop
  Parameters:
    loop - [in] loop whose 3d curve should be duplicated
    bRevCurveIfFaceRevIsTrue - [in] If false, the returned
       3d curve has an orientation compatible with the
       2d curve returned by Loop2dCurve().
       If true and the m_bRev flag of the loop's face
       is true, then the returned curve is reversed.
  Returns:
    A pointer to a 3d ON_Curve.  The caller must delete
    this curve.
  */
  ON_Curve* Loop3dCurve( 
    const ON_BrepLoop& loop,
    ON_BOOL32 bRevCurveIfFaceRevIsTrue = false
    ) const;

  /*
  Description:
    Get a list of 3d curves that trace the non-seam edge
    portions of an entire loop
  Parameters:
    loop - [in] loop whose 3d curve should be duplicated
    curve_list - [out] 3d curves are appended to this list
    bRevCurveIfFaceRevIsTrue - [in] If false, the returned
       3d curves have an orientation compatible with the
       2d curve returned by Loop2dCurve().
       If true and the m_bRev flag of the loop's face
       is true, then the returned curves are reversed.
  Returns:
    Number of curves appended to curve_list.
  */
  int Loop3dCurve( 
    const ON_BrepLoop& loop,
    ON_SimpleArray<ON_Curve*>& curve_list,
    ON_BOOL32 bRevCurveIfFaceRevIsTrue = false
    ) const;


  /*
  Description:
    Get a 3d curve that traces the entire loop
  Parameters:
    loop - [in] loop whose 2d curve should be duplicated
  Returns:
    A pointer to a 2d ON_Curve.  The caller must delete
    this curve.
  */
  ON_Curve* Loop2dCurve( const ON_BrepLoop& loop ) const;

  /*
  Description:
    Determine orientation of a brep.
  Returns:
    @untitle table
    +2     brep is a solid but orientation cannot be computed
    +1     brep is a solid with outward facing normals
    -1     brep is a solid with inward facing normals
     0     brep is not a solid
  Remarks:
    The base class implementation returns 2 or 0.  This
    function is overridden in the Rhino SDK and returns
    +1, -1, or 0.
  See Also:
    ON_Brep::IsSolid
  */
  virtual
  int SolidOrientation() const;

  /*
  Description:
    Test brep to see if it is a solid.  (A "solid" is
    a closed oriented manifold.)
  Returns:
    @untitled table
    true       brep is a solid
    fals       brep is not a solid
  See Also:
    ON_Brep::SolidOrientation
    ON_Brep::IsManifold
  */
  bool IsSolid() const;
  
  /*
  Description:
    Test brep to see if it is an oriented manifold.
  Parameters:
    pbIsOriented - [in]  if not null, *pbIsOriented is set
        to true if b-rep is an oriented manifold and false
        if brep is not an oriented manifold.
    pbHasBoundary - [in]  if not null, *pbHasBoundary is set
        to true if b-rep has a boundary edge and false if
        brep does not have a boundary edge.
  Returns:
    true       brep is a manifold
    fals       brep is not a manifold
  See Also:
    ON_Brep::IsSolid
  */
  bool IsManifold( // returns true if b-rep is an oriented manifold
    ON_BOOL32* pbIsOriented = NULL,
    ON_BOOL32* pbHasBoundary = NULL
    ) const;

  /*
  Description: 
    Determine if P is inside Brep.  This question only makes sense
    when the brep is a closed manifold.  This function does not
    not check for closed or manifold, so result is not valid in
    those cases.  Intersects a line through P with brep, finds
    the intersection point Q closest to P, and looks at face 
    normal at Q.  If the point Q is on an edge or the intersection
    is not transverse at Q, then another line is used.
  Parameters:
    P - [in] 3d point
    tolerance - [in] 3d distance tolerance used for intersection
      and determining strict inclusion.
    bStrictlInside - [in] If bStrictlInside is true, then this
      function will return false if the distance from P is within
      tolerance of a brep face.
  Returns:
    True if P is in, false if not. See parameter bStrictlyIn.
  */
  bool IsPointInside(
          ON_3dPoint P, 
          double tolerance,
          bool bStrictlyInside
          ) const;


  bool IsSurface() const;      // returns true if the b-rep has a single face
                               // and that face is geometrically the same
                               // as the underlying surface.  I.e., the face
                               // has trivial trimming.  In this case, the
                               // surface is m_S[0].
                               // The flag m_F[0].m_bRev records
                               // the correspondence between the surface's
                               // natural parametric orientation and the
                               // orientation of the b-rep.


  bool FaceIsSurface(          // returns true if the face has a single
         int // index of face  // outer boundary and that boundary runs
         ) const;              // along the edges of the underlying surface.
                               // In this case the geometry of the surface
                               // is the same as the geometry of the face.
                               // If FaceIsSurface() is true, then
                               // m_S[m_F[face_index].m_si] is the surface.
                               // The flag m_F[face_index].m_bRev records
                               // the correspondence between the surface's
                               // natural parametric orientation and the
                               // orientation of face in the b-rep.

  bool LoopIsSurfaceBoundary(  // returns true if the loop's trims all run
         int // index of loop  // along the edge's of the underlying surface's
         ) const;              // parameter space.

  /////////////////////////////////////////////////////////////////
  // Modification Interface

  //////////
  // Clears all ON_BrepFace.m_bRev flags by ON_BrepFace::Transpose
  // on each face with a true m_bRev.
  bool FlipReversedSurfaces();

  //////////
  // Change the domain of a trim's 2d curve.  This changes only the
  // parameterization of the 2d trimming curve; the locus of the 
  // 2d trimming curve is not changed.
  bool SetTrimDomain(
         int, // index of trim in m_T[] array
         const ON_Interval&
         );

  //////////
  // Change the domain of an edge.  This changes only the
  // parameterization of the 3d edge curve; the locus of the 
  // 3d edge curve is not changed.
  bool SetEdgeDomain(
         int, // index of edge in m_E[] array
         const ON_Interval&
         );

  // Reverses entire brep orientation of all faces by toggling 
  // value of all face's ON_BrepFace::m_bRev flag.
  void Flip();

  // reverses orientation of a face by toggling ON_BrepFace::m_bRev
  void FlipFace(ON_BrepFace&);

  // Reverses orientation of trimming loop. 
  // This function is intended to be used by brep experts and does
  // does NOT modify ON_BrepLoop::m_type.  You should make sure 
  // ON_BrepLoop::m_type jibes with the loop's direction.  (Outer loops
  // should be counter-clockwise and inner loops should be clockwise.)
  // You can use ON_Brep::LoopDirection() to determine the direction of
  // a loop.
  void FlipLoop(ON_BrepLoop&); // reverses orientation of trimming loop

  // LoopDirection() examines the 2d trimming curve geometry that defines
  // the loop and returns
  //
  //   @untitled table
  //   +1    the loop is a counter-clockwise loop.
  //   -1    the loop is a clockwise loop.
  //    0    the loop is not a continuous closed loop.
  //
  // Since LoopDirection() calculates its result based on the 2d trimming
  // curve geometry, it can be use to set ON_BrepLoop::m_type to outer/inner
  // when translating from data definition where this distinction is murky.
  int LoopDirection( const ON_BrepLoop& ) const;


  /*
  Description:
    Sort the face.m_li[] array by loop type 
    (outer, inner, slit, crvonsrf, ptonsrf)
  Parameters:
    face - [in/out] face whose m_li[] array should be sorted.
  Returns:
    @untitled table
    true      success
    false     failure - no loops or loops with unset loop.m_type
  See Also:
    ON_Brep::ComputeLoopType
    ON_Brep::LoopDirection
  */
  bool SortFaceLoops( ON_BrepFace& face ) const;

  /*
  Description:
    Join coincident edges.
  Parameters:
    edge - [in] this edge will survive the joining process
      and the vertices at its ends will survive the joining process.
    other_edge - [in] this edge and the vertices at its ends will
      be removed.
    join_tolerance - [in] The distances between the ends
      of edge and other_edge must be at most join_tolerance
      in order for the edges to be joined.  The caller is
      responsible for insuring that the 3d location of 
      other_edge is within join_tolerance of edge.
    bCheckFaceOrientaion - [in]
      If true and edge and other_edge are boundary edges,
      then the orientation of the face using other_edge
      is adjusted to match the orientation of the face using
      edge.
  Returns:
    true if join is successful
  Example:

    // extrude an edge of a brep to make a new face
    // NOTE WELL:
    //   THIS IS A SIMPLE EXAMPLE THAT IS NOT VERY EFFICIENT
    //   Use ON_BrepExtrudeEdge if you really want to extrude an edge.
    ON_Brep brep = ...;
    // edge = some valid edge in brep
    const ON_BrepEdge& edge = brep.m_E[...];

    // extrude edge to make a surface
    ON_3dVector v = ...;
    ON_SumSurface* new_surface = new ON_SumSurface();
    new_surface->Create( edge, v );

    // 
    ON_Brep new_brep;
    new_brep.AddFace( Create( new_surface );
    brep.

  See Also:
    ON_Brep:CullUnusedEdges
    ON_Brep:CullUnusedVertices
    ON_Brep:CullUnused3dCurves
  */
  bool JoinEdges( 
                 ON_BrepEdge& edge, 
                 ON_BrepEdge& other_edge,
                 double join_tolerance,
    ON_BOOL32 bCheckFaceOrientaion = true
                  );

  /*
  Description:
    Expert user function.
  See Also:
    ON_Brep::JoinEdges
  */
  bool CombineCoincidentVertices(ON_BrepVertex&, ON_BrepVertex&); // moves information to first vertex and deletes second

  /*
  Description:
    Expert user function.
  See Also:
    ON_Brep::JoinEdges
  */
  bool CombineCoincidentEdges(ON_BrepEdge&, ON_BrepEdge&); // moves information to first edge and deletes second

  /*
  Description:
    Expert user function.
    Combines contiguous edges into a single edge.  The edges
    must share a common vertex, then angle between the edge
    tangents are the common vertex must be less than or
    equal to angle_tolerance_radians, and any associated
    trims must be contiguous in there respective boundaries.
  Parameters;
    edge_index0 - [in]
    edge_index1 - [in]
    angle_tolerance_radians - [in]
  Returns:
    Pointer to the new edge or NULL if the edges cannot
    be combined into a single edge.
  Remarks:
    The input edges are deleted but are still in the
    brep's m_E[] arrays.  Use ON_Brep::Compact to remove 
    the unused edges.
  */
  ON_BrepEdge* CombineContiguousEdges( 
    int edge_index0, 
    int edge_iindex1, 
    double angle_tolerance_radians = ON_PI/180.0
    );

  /*
  Description:
    Given a trim and parameter on the corresponding 3d edge,
    get the corresponding parameter on the 2d trim curve.
  Parameters:
    trim_index - [in] index of trim in m_T array
    edge_t - [in] parameter on 3d edge
    trim_t - [out] parameter on 2d trim curve
    bOkToBuildTrimPline - [in] 
       if true and m_T[trim_index].m_pline[] does not
       have its edge parameters set, then they are filled
       in.  This is slow the first time, but greatly
       increases the speed of GetTrimParameter
       and GetEdgeParameter on subsequent calls.
  Returns:
    @untitled table
    true        successful
    false       failure - trim_t not set
  See Also:
    TL_Brep::GetEdgeParameter
  */
  virtual
    bool GetTrimParameter(
                          int trim_index,
                          double edge_t,
                          double* trim_t,
          bool bOkToBuildTrimPline=true
                          ) const;

  /*
  Description:
    Given a trim and parameter on the 2d trim curve,
    get the corresponding parameter on the 3d edge curve.
  Parameters:
    trim_index - [in] index of trim in m_T array
    trim_t - [in] parameter on 2d trim curve
    edge_t - [out] parameter on 3d edge
  Returns:
    @untitled table
    true        successful
    false       failure - edge_t not set
  See Also:
    TL_Brep::GetTrimParameter
  */
  virtual
    bool GetEdgeParameter(
                          int trim_index,
                          double trim_t,
          double* edge_t
                          ) const;

  /*
  Description:
    Expert user function.
    Splits an edge into two edges.  The input edge
    becomes the left portion and a new edge is created
    for the right portion.
  Parameters:
    edge_index - [in] index of edge in brep.m_E[]
    edge_t - [in] 3d edge splitting parameter
    trim_t - [in] array of trim splitting parameters.
             trim_t[eti] is the parameter for splitting the
             trim brep.m_T[edge.m_ti[eti]].
    vertex_index - [in] if not -1, then this vertex will be
             used for the new vertex.  Otherwise a new
             vertex is created.
    bSetTrimBoxesAndFlags - [in] if true, trim boxes and flags
             are set.  If false, the user is responsible for
             doing this.  Set to true if you are unsure
             what to use.  If you pass false, then need to
             call SetTrimBoundingBoxes(..,bLazy=true)
             so that the trim iso flags and bounding info
             is correctly updated.  If you pass true, then
             the trim flags and bounding boxes get set
             inside of SplitEdge.
  Returns:
    True if successful.
  */
  bool SplitEdge(
                 int edge_index,
                 double edge_t,
                 const ON_SimpleArray<double>& trim_t,
                 int vertex_index = -1,
        bool bSetTrimBoxesAndFlags = true
                 );

  // These remove a topology piece from a b-rep but do not
  // rearrange the arrays that hold the brep objects.  The
  // deleted objects have their indices set to -1.  Deleting
  // an object that is connected to other objects will 
  // modify thos objects.
  void DeleteVertex(ON_BrepVertex& vertex);
  void DeleteEdge(ON_BrepEdge& edge, ON_BOOL32 bDeleteEdgeVertices); // pass true to delete vertices used only by edge
  void DeleteTrim(ON_BrepTrim& trim, ON_BOOL32 bDeleteTrimEdges); // pass true to delete edges and vertices used only by trim
  void DeleteLoop(ON_BrepLoop& loop, ON_BOOL32 bDeleteLoopEdges); // pass true to delete edges and vertices used only by trim
  void DeleteFace(ON_BrepFace& face, ON_BOOL32 bDeleteFaceEdges); // pass true to delete edges and vertices used only by face
  void DeleteSurface(int s_index);
  void Delete2dCurve(int c2_index);
  void Delete3dCurve(int c3_index);

  // Description:
  //   Set m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
  //   and m_trim_user.i values of faces of component including 
  //   m_F[face_index] to label. Numbering starts at 1.
  // Parameters:
  //   face_index - [in] index of face in component
  //   label - [in] value for m_*_user.i
  // Returns:
  // Remarks:
  //   Chases through trim lists of face edges to find adjacent faces.
  //   Does NOT check for vertex-vertex connections
  void LabelConnectedComponent(
    int face_index,
    int label
    );

  /*
  Description:
    Set  m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
    and m_trim_user.i values values to distinguish connected components.
  Parameters:
  Returns:
    number of connected components
  Remarks:
    For each face in the ith component, sets m_face_user.i to i>0.
    Chases through trim lists of face edges to find adjacent faces.
	  Numbering starts at 1. Does NOT check for vertex-vertex connections.
  See Also:
    ON_Brep::GetConnectedComponents
  */
  int LabelConnectedComponents();

  /*
  Description:
    If this brep has two or more connected components, 
    then duplicates of the connected components are appended
    to the components[] array.
  Parameters:
    components - [in] connected components are appended to this array.
    bDuplicateMeshes - [in] if true, any meshes on this brep are copied
         to the output breps.
  Returns:
    Number of connected components appended to components[] or zero
    if this brep has only one connected component.
  See Also:
    ON_Brep::GetConnectedComponents
  */
  int GetConnectedComponents( 
          ON_SimpleArray< ON_Brep* >& components,
          bool bDuplicateMeshes
          ) const;

  /*
  Description:
    Copy a subset of this brep.
  Parameters:
    subfi_count - [in] length of sub_fi[] array.
    sub_fi - [in] array of face indices in this
      brep to copy. (If any values inf sub_fi[]
      are out of range or if sub_fi[] contains
      duplicates, this function will return null.)
    sub_brep - [in] if this pointer is not null,
      then the subbrep will be created in this
      class.
  Returns:
    If the input is valid, a pointer to the
    subbrep is returned.  If the input is not
    valid, null is returned.  The faces in
    in the subbrep's m_F array are in the same
    order as they were specified in sub_fi[].
  */
  ON_Brep* SubBrep( 
    int subfi_count, 
    const int* sub_fi, 
    ON_Brep* sub_brep = 0 
    ) const;

  ///////////////////////////////////////////////////////////////////////
  //
  // region topology
  //
  bool HasRegionTopology() const;

  /*
  Description:
    Get region topology information:
    In order to keep the ON_Brep class efficient, rarely used
    region topology information is not maintained.  If you 
    require this information, call RegionTopology().
  */
  const ON_BrepRegionTopology& RegionTopology() const;

  /*
  Description:
    Get region topology information:
    In order to keep the ON_Brep class efficient, rarely used
    region topology information is not maintained.  If you 
    require this information, call RegionTopology().
  */
  void DestroyRegionTopology();
  // Description:
  //   Duplicate a single brep face.
  // Parameters:
  //   face_index - [in] index of face to duplicate
  //   bDuplicateMeshes - [in] if true, any attached meshes are duplicated
  // Returns:
  //   Single face brep.
  // Remarks:
  //   The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
  //   and m_trim_user.i values of the returned brep are are set to the 
  //   indices of the objects they duplicate.
  // See Also:
  //   ON_Brep::DeleteFace, ON_Brep::ExtractFace
  ON_Brep* DuplicateFace(
    int face_index,
    ON_BOOL32 bDuplicateMeshes
    ) const;

  // Description:
  //   Duplicate a a subset of a brep
  // Parameters:
  //   face_count - [in] length of face_index[] array
  //   face_index - [in] array of face indices
  //   bDuplicateMeshes - [in] if true, any attached meshes are duplicated
  // Returns:
  //   A brep made by duplicating the faces listed in the face_index[] array.
  // Remarks:
  //   The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
  //   and m_trim_user.i values of the returned brep are are set to the 
  //   indices of the objects they duplicate.
  // See Also:
  //   ON_Brep::DuplicateFace
  ON_Brep* DuplicateFaces(
    int face_count,
    const int* face_index,
    ON_BOOL32 bDuplicateMeshes
    ) const;

  // Description:
  //   Extract a face from a brep.
  // Parameters:
  //   face_index - [in] index of face to extract
  // Returns:
  //   Single face brep.
  // See Also:
  //   ON_Brep::DeleteFace, ON_Brep::DuplicateFace
  ON_Brep* ExtractFace(
    int face_index
    );


  /*
  Description:
    Standardizes the relationship between an ON_BrepEdge
    and the 3d curve it uses.  When done, the edge will
    be the only edge that references its 3d curve, the 
    domains of the edge and 3d curve will be the same, 
    and the edge will use the entire locus of the 3d curve.
  Parameters:
    edge_index - [in] index of edge to standardize.
    bAdjustEnds - [in] if true, move edge curve endpoints to vertices
  See Also:
    ON_Brep::StandardizeEdgeCurves
    ON_Brep::Standardize
  */
  bool StandardizeEdgeCurve( int edge_index, bool bAdjustEnds );


  /*
  Description:
    Expert user only.  Same as above, but to be used when the edge
    curve use count is known for the edge.
    Standardizes the relationship between an ON_BrepEdge
    and the 3d curve it uses.  When done, the edge will
    be the only edge that references its 3d curve, the 
    domains of the edge and 3d curve will be the same, 
    and the edge will use the entire locus of the 3d curve.
  Parameters:
    edge_index - [in] index of edge to standardize.
    bAdjustEnds - [in] if true, move edge curve endpoints to vertices
    EdgeCurveUse - [in] if > 1, then the edge curve for this edge is used by more than one
        edge.  if 1, then the edge curve is used only for this edge. 
        If <= 0, then use count is unknown.
  See Also:
    ON_Brep::StandardizeEdgeCurves
    ON_Brep::Standardize
  */
  bool StandardizeEdgeCurve( int edge_index, bool bAdjustEnds, int EdgeCurveUse );


  /*
  Description:
    Standardize all edges in the brep.
  Parameters:
    bAdjustEnds - [in] if true, move edge curve endpoints to vertices
  See Also:
    ON_Brep::StandardizeEdgeCurve
    ON_Brep::Standardize
  */
  void StandardizeEdgeCurves( bool bAdjustEnds );

  /*
  Description:
    Standardizes the relationship between an ON_BrepTrim
    and the 2d curve it uses.  When done, the trim will
    be the only trim that references its 2d curve, the 
    domains of the trim and 2d curve will be the same, 
    and the trim will use the entire locus of the 2d curve.
  Parameters:
    trim_index - [in] index of trim to standardize.
  See Also:
    ON_Brep::StandardizeTrimCurves
    ON_Brep::Standardize
  */
  bool StandardizeTrimCurve( int trim_index );

  /*
  Description:
    Standardize all trims in the brep.
  See Also:
    ON_Brep::StandardizeTrimCurve
    ON_Brep::Standardize
  */
  void StandardizeTrimCurves();

  /*
  Description:
    Standardizes the relationship between an ON_BrepFace
    and the 3d surface it uses.  When done, the face will
    be the only face that references its 3d surface, and
    the orientations of the face and 3d surface will be 
    the same. 
  Parameters:
    face_index - [in] index of face to standardize.
  See Also:
    ON_Brep::StardardizeFaceSurfaces
    ON_Brep::Standardize
  */
  bool StandardizeFaceSurface( int face_index );

  /*
  Description:
    Standardize all faces in the brep.
  See Also:
    ON_Brep::StandardizeFaceSurface
    ON_Brep::Standardize
  */
  void StandardizeFaceSurfaces();

  // misspelled function name is obsolete
  ON_DEPRECATED void StardardizeFaceSurfaces();

  /*
  Description:
    Standardize all trims, edges, and faces in the brep.
  Remarks:
    After standardizing, there may be unused curves and surfaces
    in the brep.  Call ON_Brep::Compact to remove these unused
    curves and surfaces.
  See Also:
    ON_Brep::StandardizeTrimCurves
    ON_Brep::StandardizeEdgeCurves
    ON_Brep::StandardizeFaceSurface
    ON_Brep::Compact
  */
  void Standardize();
  

  /*
  Description:
    Sometimes the ON_Surface used by a face extends far
    beyond the face's outer boundary.  ShrinkSurface uses
    ON_Surface::Trim to remove portions of the surface that
    extend beyond the face's outer boundary loop.
  Parameters:
    face - [in] face to test and whose surface should be shrunk.
    DisableSide - [in] This is a bit field.  A set bit indicates not to shrink
                the surface on a given side.  The default of 0 enables shrinking 
                on all four sides.
      @table  
      value       meaning
      0x0001     Dont shrink on the west side of domain.
      0x0002     Dont shrink on the south side of domain.
      0x0004     Dont shrink on the east side of domain.
      0x0008     Dont shrink on the north side of domain.
  Returns:
    @untitled table
    true        successful
    false       failure
  Remarks:
    If a surface needs to be shrunk it is copied.  After shrinking,
    you may want to call ON_Brep::CullUnusedSurfaces to remove
    any unused surfaces.
  See Also:
    ON_Brep::ShrinkSurfaces
    ON_Brep::CullUnusedSurfaces
  */
  bool ShrinkSurface( ON_BrepFace& face, int DisableSide=0 );

  /*
  Description:
    Sometimes the ON_Surface used by a face extends far
    beyond the face's outer boundary.  ShrinkSurfaces calls
    ON_Shrink::ShrinkSurface on each face to remove portions
    of surfaces that extend beyond their face's outer boundary
    loop.
  Returns:
    @untitled table
    true        successful
    false       failure
  Remarks:
    If a surface needs to be shrunk it is copied.  After shrinking,
    you may want to call ON_Brep::CullUnusedSurfaces to remove
    any unused surfaces.
  See Also:
    ON_Brep::ShrinkSurface
    ON_Brep::CullUnusedSurfaces
  */
  bool ShrinkSurfaces();

  /*
  Description:
    Uses the CullUnused*() members to delete any unreferenced
    objects from arrays, reindexes as needed, and shrinks
    arrays to minimum required size.
  See Also:
    ON_Brep::CullUnusedFaces
    ON_Brep::CullUnusedLoops
    ON_Brep::CullUnusedTrims
    ON_Brep::CullUnusedEdges
    ON_Brep::CullUnusedVertices
    ON_Brep::CullUnused3dCurves
    ON_Brep::CullUnused2dCurves
    ON_Brep::CullUnusedSurfaces
  */
  bool Compact();

  bool CullUnusedFaces(); // culls faces with m_face_index == -1
  bool CullUnusedLoops(); // culls loops with m_loop_index == -1
  bool CullUnusedTrims(); // culls trims with m_trim_index == -1
  bool CullUnusedEdges(); // culls edges with m_edge_index == -1
  bool CullUnusedVertices(); // culls vertices with m_vertex_index == -1
  bool CullUnused3dCurves(); // culls 2d curves not referenced by a trim
  bool CullUnused2dCurves(); // culls 3d curves not referenced by an edge
  bool CullUnusedSurfaces(); // culls surfaces not referenced by a face

  /////////////////////////////////////////////////////////////////
  // Navigation Interface

  // for moving around loops - returns trim index of prev/next trim in loop
  int PrevTrim(
        int // index of current trim (m_trim_index)
        ) const;
  int NextTrim(
        int // index of current trim (m_trim_index)
        ) const;

  /*
  Description:
    This is a simple tool for getting running through the edges
    that begin and end at a vertex.
  Parameters:
    current_edge_index - [in]
    endi - [in] 0 = use the edge start vertex, 1 = use the edge end vertex
    prev_endi - [out] 0 if previous edge begins at the vertex, 
                      1 if previous edge ends at the vertex
  Returns:
    edge index of the previous edge or -1 if there is only one edge
    that begins or ends at the vertex.
  Remarks:
    This is a tool that simplifies searching through the
    ON_BrepVertex.m_ei[] array.
    The edges are in no particular order.
  See Also:
    ON_Brep::NextEdge
  */
  int PrevEdge(
        int current_edge_index,
        int endi,
        int* prev_endi = NULL
        ) const;

  /*
  Description:
    This is a simple tool for getting running through the edges
    that begin and end at a vertex.
  Parameters:
    current_edge_index - [in]
    endi - [in] 0 = use the edge start vertex, 1 = use the edge end vertex
    next_endi - [out] 0 if next edge begins at the vertex, 
                      1 if next edge ends at the vertex
  Returns:
    edge index of the next edge or -1 if there is only one edge
    that begins or ends at the vertex.
  Remarks:
    This is a tool that simplifies searching through the
    ON_BrepVertex.m_ei[] array.  
    The edges are in no particular order.
  See Also:
    ON_Brep::NextEdge
  */
  int NextEdge(
        int current_edge_index,
        int endi,
        int* next_endi = NULL
        ) const;

  /*
  Description:
    Get a brep component from its index.
  Parameters:
    component_index - [in] 
  Returns:
    A const pointer to the component.  Do not delete
    the returned object.  It points to an object managed
    by this brep.
  See Also:
    ON_Brep::Face
    ON_Brep::Edge
    ON_Brep::Loop
    ON_Brep::Trim
    ON_Brep::Vertex
  */
  const ON_Geometry* BrepComponent( 
    ON_COMPONENT_INDEX ci
    ) const;

  /*
  Description:
    Get vertex from trim index or component index.
  Parameters:
    vertex_index - [in] either an index into m_V[] or a component index
                      of type brep_vertex.
  Returns:
    If the index is a valid vertex index or a valid vertex component
    index, then a pointer to the ON_BrepVertex is returned.  Otherwise
    NULL is returned.
  See Also
    ON_Brep::Component( const ON_BrepVertex& )
  */
  ON_BrepVertex* Vertex( int vertex_index ) const;
  ON_BrepVertex* Vertex( ON_COMPONENT_INDEX vertex_index ) const;

  /*
  Description:
    Get edge from edge index or component index.
  Parameters:
    edge_index - [in] either an index into m_E[] or a component index
                      of type brep_edge.
  Returns:
    If the index is a valid edge index or a valid edge component
    index, then a pointer to the ON_BrepEdge is returned.  Otherwise
    NULL is returned.
  See Also
    ON_Brep::Component( const ON_BrepEdge& )
  */
  ON_BrepEdge* Edge( int edge_index ) const;
  ON_BrepEdge* Edge( ON_COMPONENT_INDEX edge_index ) const;

  /*
  Description:
    Get trim from trim index or component index.
  Parameters:
    trim_index - [in] either an index into m_T[] or a component index
                      of type brep_trim.
  Returns:
    If the index is a valid trim index or a valid trim component
    index, then a pointer to the ON_BrepTrim is returned.  Otherwise
    NULL is returned.
  See Also
    ON_Brep::Component( const ON_BrepTrim& )
  */
  ON_BrepTrim* Trim( int trim_index ) const;
  ON_BrepTrim* Trim( ON_COMPONENT_INDEX trim_index ) const;

  /*
  Description:
    Get loop from loop index or component index.
  Parameters:
    loop_index - [in] either an index into m_L[] or a component index
                      of type brep_loop.
  Returns:
    If the index is a valid loop index or a valid loop component
    index, then a pointer to the ON_BrepLoop is returned.  Otherwise
    NULL is returned.
  See Also
    ON_Brep::Component( const ON_BrepLoop& )
  */
  ON_BrepLoop* Loop( int loop_index ) const;
  ON_BrepLoop* Loop( ON_COMPONENT_INDEX loop_index ) const;

  /*
  Description:
    Get face from face index or component index.
  Parameters:
    face_index - [in] either an index into m_F[] or a component index
                      of type brep_face.
  Returns:
    If the index is a valid face index or a valid face component
    index, then a pointer to the ON_BrepFace is returned.  Otherwise
    NULL is returned.
  See Also
    ON_Brep::Component( const ON_BrepFace& )
  */
  ON_BrepFace* Face( int face_index ) const;
  ON_BrepFace* Face( ON_COMPONENT_INDEX face_index ) const;

  /*
  Description:
    remove slit trims and slit boundaries from each face.
  Returns:
    true if any slits were removed
  Remarks:
    Caller should call Compact() afterwards.
  */
  bool RemoveSlits();

  /*
  Description:
    remove slit trims and slit boundaries from a face.
  Parameters:
    F - [in] brep face
  Returns:
    true if any slits were removed
  Remarks:
    Caller should call Compact() when done.
  */
  bool RemoveSlits(ON_BrepFace& F);

  /*
  Description:
    If fid0 != fid1 and m_F[fid0] and m_F[fid1] have the same surface (m_si is identical),
    and they are joined along a set of edges that do not have any other faces, then this will
    combine the two faces into one.
  Parameters:
    fid0, fid1 - [in] indices into m_F of faces to be merged.
  Returns:
    id of merged face if faces were successfully merged. -1 if not merged.
  Remarks:
    Caller should call Compact() when done.
  */
  int MergeFaces(int fid0, int fid1);

  /*
  Description:
    Merge all possible faces that have the same m_si
  Returns:
    true if any faces were successfully merged.
  Remarks:
    Caller should call Compact() when done.
  */
  bool MergeFaces();

  /*
  Description:
    Removes nested polycurves from the m_C2[] and m_C3[] arrays.
  Parameters:
    bExtractSingleSegments - [in] if true, polycurves with a
      single segment are replaced with the segment curve.
    bEdges - [in] if true, the m_C3[] array is processed
    bTrimCurves - [in] if true, the m_C2[] array is processed.  
  Returns:
    True if any nesting was removed and false if no nesting
    was removed.
  */
  bool RemoveNesting(
          bool bExtractSingleSegments,
          bool bEdges = true, 
          bool bTrimCurves = true
          );

  /*
  Description:
    Expert user tool to collapse a "short" edge to a vertex.
    The edge is removed and the topology is repaired
    so that everything that used to connect to the edge
    connects the specified vertex.
  Parameters:
    edge_index - [in] index of edge to remove
    bCloseTrimGap - [in] if true and the removal of the
       edge creates a gap in the parameter space trimming
       loop, then the 2d trim curves will be adjusted to
       close the gap.
    vertex_index - [in] if >= 0, this the edge is collapsed
       to this vertex.  Otherwise a vertex is automatically
       selected or created.
  Returns:
    True if edge was successfully collapsed.
  Remarks:
    After you finish cleaning up the brep, you need
    to call ON_Brep::Compact() to remove unused edge,
    trim, and vertex information from the brep's m_E[], 
    m_V[], m_T[], m_C2[], and m_C3[] arrays.
  */
  bool CollapseEdge(
    int edge_index,
    bool bCloseTrimGap = true,
    int vertex_index = -1
    );

  /*
  Description:
    Expert user tool to move trims and edges from
    one vertex to another.
  Parameters:
    old_vi - [in] index of old vertex
    new_vi - [in] index of new vertex
    bClearTolerances - [in] if true, then tolerances of
       edges and trims that are connected ot the old
       vertex are set to ON_UNSET_VALUE.
    vertex_index - [in] if >= 0, this the edge is collapsed
       to this vertex.  Otherwise a vertex is automatically
       selected or created.
  Returns:
    True if successful.
  Remarks:
    After you finish cleaning up the brep, you need
    to call ON_Brep::Compact() to remove unused edge,
    trim, and vertex information from the brep's m_E[], 
    m_V[], m_T[], m_C2[], and m_C3[] arrays.
  */
  bool ChangeVertex( 
    int old_vi, 
    int new_vi, 
    bool bClearTolerances 
    );

  /*
  Description:
    Expert user tool to remove any gap between adjacent trims.
  Parameters:
    trim0 - [in]
    trim1 - [in]
  Returns:
    True if successful.
  Remarks:
    The trims must be in the same trimming loop.  The vertex
    at the end of trim0 must be the same as the vertex at
    the start of trim1.  The trim's m_iso and m_type flags
    need to be correctly set.
  */
  bool CloseTrimGap( 
    ON_BrepTrim& trim0, 
    ON_BrepTrim& trim1 
    );

  /*
  Description:
    Remove edges that are not connected to a face.
  Parameters:
    bDeleteVertices - [in] if true, then the vertices
      at the ends of the wire edges are deleted if 
      they are not connected to face trimming edges.
  Returns:
    Number of edges that were removed.
  Remarks:
    After you finish cleaning up the brep, you need
    to call ON_Brep::Compact() to remove unused edge,
    trim, and vertex information from the brep's m_E[], 
    m_V[], m_T[], m_C2[], and m_C3[] arrays.

    If you want to remove wire edges and wiere
    After you finish cleaning up the brep, you need
    to call ON_Brep::Compact() to remove deleted vertices
    from the m_V[] array.
  See Also:
    ON_Brep::RemoveWireVertices
  */
  int RemoveWireEdges( bool bDeleteVertices = true );

  /*
  Description:
    Remove vertices that are not connected to an edge.
  Returns:
    Number of vertices that were deleted.
  Remarks:
    After you finish cleaning up the brep, you need
    to call ON_Brep::Compact() to remove deleted 
    vertices from the m_V[] array.
  See Also:
    ON_Brep::RemoveWireEdges
  */
  int RemoveWireVertices();

  /////////////////////////////////////////////////////////////////
  // "Expert" Interface

  void Set_user(ON_U u); // set every brep m_*_user value to u
  void Clear_vertex_user_i(); // zero all brep's m_vertex_user values
  void Clear_edge_user_i(int);   // zero all brep's m_edge_user values
  void Clear_edge_user_i();   // zero all brep's m_edge_user values
  void Clear_trim_user_i();   // zero all brep's m_trim_user values
  void Clear_loop_user_i();   // zero all brep's m_loop_user values
  void Clear_face_user_i();   // zero all brep's m_face_user values
  void Clear_user_i();        // zero all brep's m_*_user values

  // Union available for application use.
  // The constructor zeros m_brep_user.
  // The value is of m_brep_user is not saved in 3DM
  // archives and may be changed by some computations.
  ON_U m_brep_user; 

  // geometry 
  // (all geometry is deleted by ~ON_Brep().  Pointers can be NULL
  // or not referenced.  Use Compact() to remove unreferenced geometry.
  ON_CurveArray   m_C2;  // Pointers to parameter space trimming curves
                         // (used by trims).
  ON_CurveArray   m_C3;  // Pointers to 3d curves (used by edges).
  ON_SurfaceArray m_S;   // Pointers to parametric surfaces (used by faces)

  // topology
  // (all topology is deleted by ~ON_Brep().  Objects can be unreferenced.
  // Use Compact() to to remove unreferenced geometry.
  ON_BrepVertexArray  m_V;   // vertices
  ON_BrepEdgeArray    m_E;   // edges
  ON_BrepTrimArray    m_T;   // trims
  ON_BrepLoopArray    m_L;   // loops
  ON_BrepFaceArray    m_F;   // faces

protected:	
  friend class ON_BrepFace;
  friend class ON_BrepRegion;
  friend class ON_BrepFaceSide;
  ON_BoundingBox m_bbox;

  // Never directly set m_is_solid, use calls to IsSolid() and/or 
  // SolidOrientation() when you need to know the answer to this
  // question.
  // 0 = unset
  // 1 = solid with normals pointing out
  // 2 = solid with normals pointing in
  // 3 = not solid
  int m_is_solid;

  // These are friends so legacy tol values stored in v1 3dm files
  // can be used to set brep edge and trimming tolerances with a call
  // to ON_Brep::SetTolsFromLegacyValues().
  friend bool ON_BinaryArchive::ReadV1_TCODE_LEGACY_FAC(ON_Object**,ON_3dmObjectAttributes*);
  friend bool ON_BinaryArchive::ReadV1_TCODE_LEGACY_SHL(ON_Object**,ON_3dmObjectAttributes*);
  void Initialize();

  // helpers to set ON_BrepTrim::m_iso flag
  void SetTrimIsoFlag(int,double[6]);
  void SetTrimIsoFlag(int);

  // helpers to create and set vertices
  bool SetEdgeVertex(const int, const int, const int );
  bool HopAcrossEdge( int&, int& ) const;
  bool SetTrimStartVertex( const int, const int);
  void SetLoopVertices(const int);
  void ClearTrimVertices();
  void ClearEdgeVertices();

  // helpers for SwapFaceParameters()
  bool SwapLoopParameters(
        int // index of loop
        );
  bool SwapTrimParameters(
        int // index of trim
        );

  // helpers for validation checking
  bool IsValidTrim(int trim_index,ON_TextLog* text_log) const;
  bool IsValidTrimTopology(int trim_index,ON_TextLog* text_log) const;
  bool IsValidTrimGeometry(int trim_index,ON_TextLog* text_log) const;
  bool IsValidTrimTolerancesAndFlags(int trim_index,ON_TextLog* text_log) const;

  bool IsValidLoop(int loop_index,ON_TextLog* text_log) const;
  bool IsValidLoopTopology(int loop_index,ON_TextLog* text_log) const;
  bool IsValidLoopGeometry(int loop_index,ON_TextLog* text_log) const;
  bool IsValidLoopTolerancesAndFlags(int loop_index,ON_TextLog* text_log) const;

  bool IsValidFace(int face_index,ON_TextLog* text_log) const;
  bool IsValidFaceTopology(int face_index,ON_TextLog* text_log) const;
  bool IsValidFaceGeometry(int face_index,ON_TextLog* text_log) const;
  bool IsValidFaceTolerancesAndFlags(int face_index,ON_TextLog* text_log) const;
  
  bool IsValidEdge(int edge_index,ON_TextLog* text_log) const;
  bool IsValidEdgeTopology(int edge_index,ON_TextLog* text_log) const;
  bool IsValidEdgeGeometry(int edge_index,ON_TextLog* text_log) const;
  bool IsValidEdgeTolerancesAndFlags(int edge_index,ON_TextLog* text_log) const;

  bool IsValidVertex(int vertex_index,ON_TextLog* text_log) const;
  bool IsValidVertexTopology(int vertex_index,ON_TextLog* text_log) const;
  bool IsValidVertexGeometry(int vertex_index,ON_TextLog* text_log) const;
  bool IsValidVertexTolerancesAndFlags(int vertex_index,ON_TextLog* text_log) const;

  void SetTolsFromLegacyValues();

  // read helpers to support various versions
  bool ReadOld100( ON_BinaryArchive& ); // reads legacy old RhinoIO toolkit b-rep
  bool ReadOld101( ON_BinaryArchive& ); // reads legacy Rhino 1.1 b-rep
  bool ReadOld200( ON_BinaryArchive&, int ); // reads legacy trimmed surface
  ON_Curve* Read100_BrepCurve( ON_BinaryArchive& ) const;
  ON_Surface* Read100_BrepSurface( ON_BinaryArchive& ) const;

  // helpers for reading legacy v1 trimmed surfaces and breps
  bool ReadV1_LegacyTrimStuff( ON_BinaryArchive&, ON_BrepFace&, ON_BrepLoop& );
  bool ReadV1_LegacyTrim( ON_BinaryArchive&, ON_BrepFace&, ON_BrepLoop& );
  bool ReadV1_LegacyLoopStuff( ON_BinaryArchive&, ON_BrepFace& );
  bool ReadV1_LegacyLoop( ON_BinaryArchive&, ON_BrepFace& );
  bool ReadV1_LegacyFaceStuff( ON_BinaryArchive& );
  bool ReadV1_LegacyShellStuff( ON_BinaryArchive& );
};

///////////////////////////////////////////////////////////////////////////////
//
// brep construction tools
// 

/*
Description:
  Create a brep representation of a mesh.
Parameters:
  mesh_topology - [in]
  bTrimmedTriangles - [in] if true, triangles in the mesh
     will be represented by trimmed planes in the brep.
     If false, triangles in the mesh will be represented by
     untrimmed singular bilinear NURBS surfaces in the brep.
  pBrep - [in] If not NULL, this the mesh representation will
     be put into this brep.
Example:

          ON_Mesh mesh = ...;
          ON_Brep* pBrep = ON_BrepFromMesh( mesh.Topology() );
          ...
          delete pBrep;

See Also
  ON_BrepFromMesh( const ON_Mesh& mesh, ... );
*/
ON_DECL
ON_Brep* ON_BrepFromMesh( 
          const ON_MeshTopology& mesh_topology, 
          ON_BOOL32 bTrimmedTriangles = true,
          ON_Brep* pBrep = NULL 
          );

/*
Description:
  Get an ON_Brep definition of a box.
Parameters:
  box_corners - [in] 8 points defining the box corners
     arranged as the vN lables indicate.

          v7_______e6_____v6
           |\             |\
           | e7           | e5
           |  \ ______e4_____\ 
          e11  v4         |   v5
           |   |        e10   |
           |   |          |   |
          v3---|---e2----v2   e9
           \   e8         \   |
            e3 |           e1 |
             \ |            \ |
              \v0_____e0_____\v1

  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the box with topology

   edge              vertices
    m_E[ 0]           m_V[0], m_V[1]
    m_E[ 1]           m_V[1], m_V[2]
    m_E[ 2]           m_V[2], m_V[3]
    m_E[ 3]           m_V[3], m_V[0]
    m_E[ 4]           m_V[4], m_V[5]
    m_E[ 5]           m_V[5], m_V[6]
    m_E[ 6]           m_V[6], m_V[7]
    m_E[ 7]           m_V[7], m_V[4]
    m_E[ 8]           m_V[0], m_V[4]
    m_E[ 9]           m_V[1], m_V[5]
    m_E[10]           m_V[2], m_V[6]
    m_E[11]           m_V[3], m_V[7]

   face              boundary edges
    m_F[0]            +m_E[0] +m_E[9]  -m_E[4] -m_E[8]
    m_F[1]            +m_E[1] +m_E[10] -m_E[5] -m_E[9]
    m_F[2]            +m_E[2] +m_E[11] -m_E[6] -m_E[10]
    m_F[3]            +m_E[3] +m_E[8]  -m_E[7] -m_E[11]
    m_F[4]            -m_E[3] -m_E[2]  -m_E[1] -m_E[0]
//     m_F[5]            +m_E[4] +m_E[5]  +m_E[6] +m_E[7]
*/
ON_DECL
ON_Brep* ON_BrepBox( const ON_3dPoint* box_corners, ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a wedge.
Parameters:
  corners - [in] 6 points defining the box corners
     arranged as the vN lables indicate.

                     /v5    
                    /|\       
                   / | \     
                  e5 |  e4   
                 /   e8  \     
                /__e3_____\  
              v3|    |    |v4     
                |    |    |       
                |    /v2  |   
                e6  / \   e7   
                |  /   \  |   
                | e2    e1|   
                |/       \|     
                /____e0___\  
              v0           v1

  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the wedge with topology

  edge              vertices
    m_E[ 0]           m_V[0], m_V[1]
    m_E[ 1]           m_V[1], m_V[2]
    m_E[ 2]           m_V[2], m_V[0]
    m_E[ 3]           m_V[3], m_V[4]
    m_E[ 4]           m_V[4], m_V[5]
    m_E[ 5]           m_V[5], m_V[0]
    m_E[ 6]           m_V[0], m_V[3]
    m_E[ 7]           m_V[1], m_V[4]
    m_E[ 8]           m_V[2], m_V[5]

  face              boundary edges
    m_F[0]            +m_E[0] +m_E[7]  -m_E[3] -m_E[6]
    m_F[1]            +m_E[1] +m_E[8]  -m_E[4] -m_E[7]
    m_F[2]            +m_E[2] +m_E[6]  -m_E[5] -m_E[8]
    m_F[3]            +m_E[3] +m_E[8]  -m_E[7] -m_E[11]
    m_F[4]            -m_E[2]  -m_E[1] -m_E[0]
    m_F[5]            +m_E[3] +m_E[4]  +m_E[5]
*/
ON_DECL
ON_Brep* ON_BrepWedge( const ON_3dPoint* corners, ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a sphere.
Parameters:
  sphere - [in]
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the sphere with a single face,
  a single edge along the seam, and vertices at the north
  and south poles.
*/
ON_DECL
ON_Brep* ON_BrepSphere( const ON_Sphere& sphere, ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a torus.
Parameters:
  torus - [in]
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the torus with a single face
  a two edges along the seams.
*/
ON_DECL
ON_Brep* ON_BrepTorus( const ON_Torus& torus, ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a cylinder.
Parameters:
  cylinder - [in] cylinder.IsFinite() must be true
  bCapBottom - [in] if true end at cylinder.m_height[0] should be capped
  bCapTop - [in] if true end at cylinder.m_height[1] should be capped
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the cylinder with a single
  face for the cylinder, an edge along the cylinder seam, 
  and vertices at the bottom and top ends of this seam edge.
  The optional bottom/top caps are single faces with one
  circular edge starting and ending at the bottom/top vertex.
*/
ON_DECL
ON_Brep* ON_BrepCylinder( const ON_Cylinder& cylinder, 
                          ON_BOOL32 bCapBottom,
                          ON_BOOL32 bCapTop,
                          ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a cone.
Parameters:
  cylinder - [in] cylinder.IsFinite() must be true
  bCapBase - [in] if true the base of the cone should be capped.
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the cone with a single
  face for the cone, an edge along the cone seam, 
  and vertices at the base and apex ends of this seam edge.
  The optional cap is asingle face with one circular edge 
  starting and ending at the base vertex.
*/
ON_DECL
ON_Brep* ON_BrepCone( 
          const ON_Cone& cone, 
          ON_BOOL32 bCapBottom,
          ON_Brep* pBrep = NULL 
          );

/*
Description:
  Get an ON_Brep form of a surface of revolution.
Parameters:
  pRevSurface - [in] pointer to a surface of revolution.
     The brep will manage this pointer and delete it in ~ON_Brep.
  bCapStart - [in] if true, the start of the revolute is
     not on the axis of revolution, and the surface of revolution
     is closed, then a circular cap will be added to close
     of the hole at the start of the revolute.
  bCapEnd - [in] if true, the end of the revolute is
     not on the axis of revolution, and the surface of revolution
     is closed, then a circular cap will be added to close
     of the hole at the end of the revolute.
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  @untitled table
  true     successful
  false    brep cannot be created from this surface.
Remarks:
  The surface class must be created with new because
  it will be destroyed with the delete operator
  in ~ON_Brep.
*/
ON_DECL
ON_Brep* ON_BrepRevSurface( 
          ON_RevSurface*& pRevSurface,
          ON_BOOL32 bCapStart,
          ON_BOOL32 bCapEnd,
          ON_Brep* pBrep = NULL 
          );


          
/*
Description:
  Create an ON_Brep trimmed plane.
Parameters:
  plane - [in] plane that will be trimmed.
  boundary - [in] a simple (no self intersections) closed
      curve that defines the outer boundary of the trimmed
      plane.  This curve is copied for use in the brep.
  pBrep - [in] if not NULL, this brep will be used and returned.
Returns:
  An ON_Brep representation of the trimmed plane with a single face.
See Also:
  ON_Brep::NewPlanarFaceLoop()
*/
ON_DECL
ON_Brep* ON_BrepTrimmedPlane( 
            const ON_Plane& plane, 
            const ON_Curve& boundary,
            ON_Brep* pBrep = NULL );

/*
Description:
  Get an ON_Brep definition of a trimmed plane.
Parameters:
  plane - [in] plane that will be trimmed.
  boundary - [in] a list of 3d curves that form a simple 
      (no self intersections) closed curve that defines the
      outer boundary of the trimmed plane.
  bDuplicateCurves - [in] if true, duplicates of the
       curves in the boundary array are used in the brep.  If false
       the curves in the boundary array are used in the brep
       and the brep's destructor will delete the curves.
  pBrep - [in] if not NULL, this brep will be used and
               returned.
Returns:
  An ON_Brep representation of the trimmed plane with a singe face.
See Also:
  ON_Brep::NewPlanarFaceLoop()
*/
ON_DECL
ON_Brep* ON_BrepTrimmedPlane( 
            const ON_Plane& plane, 
            ON_SimpleArray<ON_Curve*>& boundary,
            ON_BOOL32 bDuplicateCurves = true,
            ON_Brep* pBrep = NULL );


/*
Description:
  Extrude a brep
Parameters:
  brep - [in/out]
  path_curve - [in] path to extrude along.
  bCap - [in] if true, the extusion is capped with a translation
              of the input brep.
Returns:
  True if successful.
See Also:
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new faces are appended to brep.m_F[]. It is the caller's
  responsibility to insure the result does not self intersect.
*/
ON_DECL
bool ON_BrepExtrude( 
          ON_Brep& brep,
          const ON_Curve& path_curve,
          bool bCap = true
          );

/*
Description:
  Extrude a face in a brep.
Parameters:
  brep - [in/out]
  face_index - [in] index of face to extrude.
  path_curve - [in] path to extrude along.
  bCap - [in] if true, the extusion is capped with a translation
              of the face being extruded.
Example:
  Extrude a face along a vector.

          ON_Brep brep = ...;
          int face_index = ...;
          ON_3dVector v = ...;
          ON_LineCurve line_curve( ON_Line( ON_origin, vector ) );
          ON_BrepExtrudeFace( brep, face_index, line_curve, true );

Returns:
  @untitled table
  0    failure
  1    successful - no cap added
  2    successful - cap added as last face
See Also:
  ON_BrepExtrude
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new faces are appended to brep.m_F[].  If a cap is requested
  it is the last face in the returned brep.m_F[]
*/
ON_DECL
int ON_BrepExtrudeFace( 
          ON_Brep& brep,
          int face_index,
          const ON_Curve& path_curve,
          bool bCap = true
          );

/*
Description:
  Extrude a loop in a brep.
Parameters:
  brep - [in/out]
  loop_index - [in] index of face to extrude.
  path_curve - [in] path to extrude along.
  bCap - [in] if true and the loop is closed, the extusion
              is capped.
Returns:
  @untitled table
  0    failure
  1    successful - no cap added
  2    successful - cap added as last face
See Also:
  ON_BrepExtrude
  ON_BrepExtrudeFace
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new faces are appended to brep.m_F[].  If a cap is requested
  it is the last face in the returned brep.m_F[]
*/
ON_DECL
int ON_BrepExtrudeLoop( 
          ON_Brep& brep,
          int loop_index,
          const ON_Curve& path_curve,
          bool bCap = true
          );

/*
Description:
  Extrude an edge in a brep.
Parameters:
  brep - [in/out]
  edge_index - [in] index of face to extrude.
  path_curve - [in] path to extrude along.
Returns:
  @untitled table
  0    failure
  1    successful
See Also:
  ON_BrepExtrude
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new face is appended to brep.m_F[].
*/
ON_DECL
int ON_BrepExtrudeEdge( 
          ON_Brep& brep,
          int edge_index,
          const ON_Curve& path_curve
          );


/*
Description:
  Extrude a vertex in a brep.
Parameters:
  brep - [in/out]
  vertex_index - [in] index of vertex to extrude.
  path_curve - [in] path to extrude along.
Returns:
  @untitled table
  0    failure
  1    successful
See Also:
  ON_BrepExtrude
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new vertex is appended to brep.m_V[] and
  the new edge is appended to brep.m_E[].
*/
ON_DECL
int ON_BrepExtrudeVertex( 
          ON_Brep& brep,
          int vertex_index,
          const ON_Curve& path_curve
          );


/*
Description:
  Cone a face in a brep.
Parameters:
  brep - [in/out]
  face_index - [in] index of face to extrude.
  apex_point - [in] apex of cone.
Returns:
  @untitled table
  0    failure
  1    successful
See Also:
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new faces are appended to brep.m_F[].
*/
ON_DECL
int ON_BrepConeFace( 
          ON_Brep& brep,
          int face_index,
          ON_3dPoint apex_point
          );

/*
Description:
  Cone a loop in a brep.
Parameters:
  brep - [in/out]
  loop_index - [in] index of face to extrude.
  apex_point - [in] apex of cone.
Returns:
  @untitled table
  0    failure
  1    successful
See Also:
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new faces are appended to brep.m_F[].
*/
ON_DECL
bool ON_BrepConeLoop( 
          ON_Brep& brep,
          int loop_index,
          ON_3dPoint apex_point
          );

/*
Description:
  Cone an edge in a brep.
Parameters:
  brep - [in/out]
  edge_index - [in] index of face to extrude.
  apex_point - [in] apex of cone.
Returns:
  @untitled table
  0    failure
  1    successful
See Also:
  ON_BrepExtrudeFace
  ON_BrepExtrudeLoop
  ON_BrepExtrudeEdge
  ON_BrepExtrudeVertex
  ON_BrepConeFace
  ON_BrepConeLoop
  ON_BrepConeEdge
Remarks:
  The new face is appended to brep.m_F[].
*/
ON_DECL
int ON_BrepConeEdge( 
          ON_Brep& brep,
          int edge_index,
          ON_3dPoint apex_point
          );

//These merge adjacent faces that have the same underlying surface.
ON_DECL
int ON_BrepMergeFaces(ON_Brep& B, int fid0, int fid1);

ON_DECL
bool ON_BrepMergeFaces(ON_Brep& B);

//This removes all slit trims  from F that are not joined to another face.
//Unlike ON_Brep::RemoveSlits(), this will remove slit pairs from a loop in cases 
//that will result in the creation of more loops. Caller is responsible for calling 
//ON_Brep::Compact() to get rid of deleted trims and loops.

ON_DECL
bool ON_BrepRemoveSlits(ON_BrepFace& F);

//Merges all possible edges
ON_DECL
void ON_BrepMergeAllEdges(ON_Brep& B);

/*
Description:
  Merges two breps into a single brep.  The
  result may be non-manifold or have multiple
  connected components.
Parameters:
  brep0 - [in]
  brep1 - [in]
  tolerance - [in]
Returns:
  Merged brep or NULL if calculation failed.
*/
ON_DECL
ON_Brep* ON_MergeBreps(
          const ON_Brep& brep0,
          const ON_Brep& brep1,
          double tolerance
          );

#endif
blob
data 2791
SET(openNURBS_ignore_files
BRL-CAD_changes.txt
Makefile.am
example_brep
example_gl
example_read
example_roundtrip
example_userdata
example_write
examples_linking_pragmas.h
faq.txt
license.txt
build_opennurbs_vs2010.sln
build_opennurbs_xcode.xcworkspace
build_opennurbs_xcode.xcworkspace/contents.xcworkspacedata
examples_linking_pragmas.h
opennurbs.vcxproj
opennurbs.vcxproj.filters
opennurbs_brep_changesrf.cpp
opennurbs_brep_kinky.cpp
opennurbs_staticlib.vcxproj
opennurbs_staticlib.vcxproj.filters
opennurbs_x.h
opennurbs.h
opennurbs.rc
opennurbs_3dm.h
opennurbs_3dm_attributes.h
opennurbs_3dm_properties.h
opennurbs_3dm_settings.h
opennurbs_annotation.h
opennurbs_annotation2.h
opennurbs_arc.h
opennurbs_arccurve.h
opennurbs_archive.h
opennurbs_array.h
opennurbs_array_defs.h
opennurbs_base32.h
opennurbs_base64.h
opennurbs_beam.h
opennurbs_bezier.h
opennurbs_bitmap.h
opennurbs_bounding_box.h
opennurbs_box.h
opennurbs_brep.h
opennurbs_circle.h
opennurbs_color.h
opennurbs_compress.h
opennurbs_cone.h
opennurbs_crc.h
opennurbs_curve.h
opennurbs_curveonsurface.h
opennurbs_curveproxy.h
opennurbs_cylinder.h
opennurbs_defines.h
opennurbs_detail.h
opennurbs_dimstyle.h
opennurbs_dll.cpp
opennurbs_dll_resource.h
opennurbs_ellipse.h
opennurbs_error.h
opennurbs_evaluate_nurbs.h
opennurbs_extensions.h
opennurbs_font.h
opennurbs_fpoint.h
opennurbs_fsp.h
opennurbs_fsp_defs.h
opennurbs_geometry.h
opennurbs_gl.cpp
opennurbs_gl.h
opennurbs_group.h
opennurbs_hatch.h
opennurbs_hsort_template.h
opennurbs_instance.h
opennurbs_intersect.h
opennurbs_knot.h
opennurbs_layer.h
opennurbs_light.h
opennurbs_line.h
opennurbs_linecurve.h
opennurbs_linestyle.h
opennurbs_linetype.h
opennurbs_lookup.h
opennurbs_mapchan.h
opennurbs_massprop.h
opennurbs_material.h
opennurbs_math.h
opennurbs_matrix.h
opennurbs_memory.h
opennurbs_mesh.h
opennurbs_nurbscurve.h
opennurbs_nurbssurface.h
opennurbs_object.h
opennurbs_object_history.h
opennurbs_objref.h
opennurbs_offsetsurface.h
opennurbs_optimize.h
opennurbs_plane.h
opennurbs_planesurface.h
opennurbs_pluginlist.h
opennurbs_point.h
opennurbs_pointcloud.h
opennurbs_pointgeometry.h
opennurbs_pointgrid.h
opennurbs_polycurve.h
opennurbs_polyedgecurve.h
opennurbs_polyline.h
opennurbs_polylinecurve.h
opennurbs_precompiledheader.cpp
opennurbs_qsort_template.h
opennurbs_rand.h
opennurbs_rendering.h
opennurbs_revsurface.h
opennurbs_rtree.h
opennurbs_sphere.h
opennurbs_string.h
opennurbs_sumsurface.h
opennurbs_surface.h
opennurbs_surfaceproxy.h
opennurbs_system.h
opennurbs_textlog.h
opennurbs_texture.h
opennurbs_texture_mapping.h
opennurbs_torus.h
opennurbs_unicode.h
opennurbs_userdata.h
opennurbs_uuid.h
opennurbs_version.h
opennurbs_viewport.h
opennurbs_workspace.h
opennurbs_xform.h
opennurbs_x.h
opennurbs_zlib.h
opennurbs_zlib_memory.cpp
readme.txt
)
