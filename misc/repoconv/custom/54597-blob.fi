blob
data 7412
# build shared libs by default
IF(NOT DEFINED BUILD_SHARED_LIBS)
  set(BUILD_SHARED_LIBS ON)
ENDIF(NOT DEFINED BUILD_SHARED_LIBS)

# build static libs by default
IF(NOT DEFINED BUILD_STATIC_LIBS)
  set(BUILD_STATIC_LIBS ON)
ENDIF(NOT DEFINED BUILD_STATIC_LIBS)

set(OPENNURBS_SOURCES
opennurbs_3dm_attributes.cpp
opennurbs_3dm_properties.cpp
opennurbs_3dm_settings.cpp
opennurbs_annotation.cpp
opennurbs_annotation2.cpp
opennurbs_arc.cpp
opennurbs_arccurve.cpp
opennurbs_archive.cpp
opennurbs_array.cpp
opennurbs_base32.cpp
opennurbs_base64.cpp
opennurbs_basic.cpp
opennurbs_beam.cpp
opennurbs_bezier.cpp
opennurbs_beziervolume.cpp
opennurbs_bitmap.cpp
opennurbs_bounding_box.cpp
opennurbs_box.cpp
opennurbs_brep.cpp
opennurbs_brep_extrude.cpp
opennurbs_brep_io.cpp
opennurbs_brep_isvalid.cpp
opennurbs_brep_region.cpp
opennurbs_brep_tools.cpp
opennurbs_brep_v2valid.cpp
opennurbs_circle.cpp
opennurbs_color.cpp
opennurbs_compress.cpp
opennurbs_cone.cpp
opennurbs_crc.cpp
opennurbs_curve.cpp
opennurbs_curveonsurface.cpp
opennurbs_curveproxy.cpp
opennurbs_cylinder.cpp
opennurbs_defines.cpp
opennurbs_detail.cpp
opennurbs_dimstyle.cpp
opennurbs_dll.cpp
opennurbs_ellipse.cpp
opennurbs_embedded_file.cpp
opennurbs_error.cpp
opennurbs_error_message.cpp
opennurbs_evaluate_nurbs.cpp
opennurbs_extensions.cpp
opennurbs_font.cpp
opennurbs_fsp.cpp
opennurbs_geometry.cpp
opennurbs_group.cpp
opennurbs_hatch.cpp
opennurbs_instance.cpp
opennurbs_intersect.cpp
opennurbs_knot.cpp
opennurbs_layer.cpp
opennurbs_light.cpp
opennurbs_line.cpp
opennurbs_linecurve.cpp
opennurbs_linetype.cpp
opennurbs_lookup.cpp
opennurbs_material.cpp
opennurbs_math.cpp
opennurbs_massprop.cpp
opennurbs_matrix.cpp
opennurbs_memory.c
opennurbs_memory_util.c
opennurbs_mesh.cpp
opennurbs_mesh_ngon.cpp
opennurbs_mesh_tools.cpp
opennurbs_morph.cpp
opennurbs_nurbscurve.cpp
opennurbs_nurbssurface.cpp
opennurbs_nurbsvolume.cpp
opennurbs_object.cpp
opennurbs_object_history.cpp
opennurbs_objref.cpp
opennurbs_offsetsurface.cpp
opennurbs_optimize.cpp
opennurbs_plane.cpp
opennurbs_planesurface.cpp
opennurbs_pluginlist.cpp
opennurbs_point.cpp
opennurbs_pointcloud.cpp
opennurbs_pointgeometry.cpp
opennurbs_pointgrid.cpp
opennurbs_polycurve.cpp
opennurbs_polyedgecurve.cpp
opennurbs_polyline.cpp
opennurbs_polylinecurve.cpp
opennurbs_rand.cpp
opennurbs_revsurface.cpp
opennurbs_rtree.cpp
opennurbs_sort.cpp
opennurbs_sphere.cpp
opennurbs_string.cpp
opennurbs_sum.cpp
opennurbs_sumsurface.cpp
opennurbs_surface.cpp
opennurbs_surfaceproxy.cpp
opennurbs_textlog.cpp
opennurbs_torus.cpp
opennurbs_unicode.cpp
opennurbs_userdata.cpp
opennurbs_uuid.cpp
opennurbs_viewport.cpp
opennurbs_workspace.cpp
opennurbs_wstring.cpp
opennurbs_x.cpp
opennurbs_xform.cpp
opennurbs_zlib.cpp
  )

SET(OPENNURBS_HEADERS
opennurbs.h
opennurbs_3dm.h
opennurbs_3dm_attributes.h
opennurbs_3dm_properties.h
opennurbs_3dm_settings.h
opennurbs_annotation.h
opennurbs_annotation2.h
opennurbs_arc.h
opennurbs_arccurve.h
opennurbs_archive.h
opennurbs_array.h
opennurbs_array_defs.h
opennurbs_base32.h
opennurbs_base64.h
opennurbs_beam.h
opennurbs_bezier.h
opennurbs_bitmap.h
opennurbs_bounding_box.h
opennurbs_box.h
opennurbs_brep.h
opennurbs_circle.h
opennurbs_color.h
opennurbs_compress.h
opennurbs_cone.h
opennurbs_crc.h
opennurbs_curve.h
opennurbs_curveonsurface.h
opennurbs_curveproxy.h
opennurbs_cylinder.h
opennurbs_defines.h
opennurbs_detail.h
opennurbs_dimstyle.h
opennurbs_dll_resource.h
opennurbs_ellipse.h
opennurbs_error.h
opennurbs_evaluate_nurbs.h
opennurbs_extensions.h
opennurbs_font.h
opennurbs_fpoint.h
opennurbs_fsp.h
opennurbs_fsp_defs.h
opennurbs_geometry.h
opennurbs_gl.h
opennurbs_group.h
opennurbs_hatch.h
opennurbs_hsort_template.h
opennurbs_instance.h
opennurbs_intersect.h
opennurbs_knot.h
opennurbs_layer.h
opennurbs_light.h
opennurbs_line.h
opennurbs_linecurve.h
opennurbs_linestyle.h
opennurbs_linetype.h
opennurbs_lookup.h
opennurbs_mapchan.h
opennurbs_massprop.h
opennurbs_material.h
opennurbs_math.h
opennurbs_matrix.h
opennurbs_memory.h
opennurbs_mesh.h
opennurbs_nurbscurve.h
opennurbs_nurbssurface.h
opennurbs_object.h
opennurbs_object_history.h
opennurbs_objref.h
opennurbs_offsetsurface.h
opennurbs_optimize.h
opennurbs_plane.h
opennurbs_planesurface.h
opennurbs_pluginlist.h
opennurbs_point.h
opennurbs_pointcloud.h
opennurbs_pointgeometry.h
opennurbs_pointgrid.h
opennurbs_polycurve.h
opennurbs_polyedgecurve.h
opennurbs_polyline.h
opennurbs_polylinecurve.h
opennurbs_qsort_template.h
opennurbs_rand.h
opennurbs_rendering.h
opennurbs_revsurface.h
opennurbs_rtree.h
opennurbs_sphere.h
opennurbs_string.h
opennurbs_sumsurface.h
opennurbs_surface.h
opennurbs_surfaceproxy.h
opennurbs_system.h
opennurbs_textlog.h
opennurbs_texture.h
opennurbs_texture_mapping.h
opennurbs_torus.h
opennurbs_unicode.h
opennurbs_userdata.h
opennurbs_uuid.h
opennurbs_version.h
opennurbs_viewport.h
opennurbs_workspace.h
opennurbs_x.h
opennurbs_xform.h
opennurbs_zlib.h
  )

SET(ON_DLL_HEADERS
  opennurbs_dll_resource.h
  )

INCLUDE(CheckIncludeFiles)
CHECK_INCLUDE_FILE(emmintrin.h HAVE_EMMINTRIN_H)
CHECK_INCLUDE_FILE(ieeefp.h HAVE_IEEEFP_H)
CHECK_INCLUDE_FILE(sys/stat.h HAVE_SYS_STAT_H)
if(HAVE_EMMINTRIN_H)
  add_definitions(-DHAVE_EMMINTRIN_H)
endif(HAVE_EMMINTRIN_H)
if(HAVE_IEEEFP_H)
  add_definitions(-DHAVE_IEEEFP_H)
endif(HAVE_IEEEFP_H)
if(HAVE_SYS_STAT_H)
  add_definitions(-DHAVE_SYS_STAT_H)
endif(HAVE_SYS_STAT_H)

IF(BUILD_STATIC_LIBS AND BRLCAD_ENABLE_BRLCAD_LIBRARY AND ${CMAKE_PROJECT_NAME}_ZLIB_BUILD AND NOT ${CMAKE_PROJECT_NAME}-ENABLE_SYSTEM_LIBS_ONLY)
  set(OPENNURBS_LINKLIBRARIES
    zlib-static
    )
ELSE(BUILD_STATIC_LIBS AND BRLCAD_ENABLE_BRLCAD_LIBRARY AND ${CMAKE_PROJECT_NAME}_ZLIB_BUILD AND NOT ${CMAKE_PROJECT_NAME}-ENABLE_SYSTEM_LIBS_ONLY)
  set(OPENNURBS_LINKLIBRARIES
    ${ZLIB_LIBRARY}
    )
ENDIF(BUILD_STATIC_LIBS AND BRLCAD_ENABLE_BRLCAD_LIBRARY AND ${CMAKE_PROJECT_NAME}_ZLIB_BUILD AND NOT ${CMAKE_PROJECT_NAME}-ENABLE_SYSTEM_LIBS_ONLY)

# Ideally, we should only need ZLIB here
include_directories(
  ${${CMAKE_PROJECT_NAME}_SOURCE_DIR}/include
  ${ZLIB_INCLUDE_DIR}
  )

if (MSVC)
  add_definitions(
    -DON_COMPILING_OPENNURBS
    -DON_DLL_EXPORTS
    )
  SET(OPENNURBS_HEADERS "${OPENNURBS_HEADERS};${ON_DLL_HEADERS}")
else (MSVC)
  add_definitions(
    -DON_COMPILING_OPENNURBS
    )
endif(MSVC)


if(MSVC)
  add_definitions(
    -DUNICODE
    )

  set(OPENNURBS_LINKLIBRARIES
    ${OPENNURBS_LINKLIBRARIES}
    Rpcrt4
    )
endif(MSVC)

IF(BUILD_SHARED_LIBS)
  add_library(openNURBS SHARED ${OPENNURBS_SOURCES})
  target_link_libraries(openNURBS ${OPENNURBS_LINKLIBRARIES})
  set_property(TARGET openNURBS PROPERTY LINK_INTERFACE_LIBRARIES "")
  SET_TARGET_PROPERTIES(openNURBS PROPERTIES VERSION "2010.04.95")
  install(TARGETS openNURBS
	  RUNTIME DESTINATION ${BIN_DIR}
	  LIBRARY DESTINATION ${LIB_DIR}
	  ARCHIVE DESTINATION ${LIB_DIR})
ENDIF(BUILD_SHARED_LIBS)
IF(NOT MSVC)
  IF(BUILD_STATIC_LIBS)
    add_library(openNURBS-static STATIC ${OPENNURBS_SOURCES})
    target_link_libraries(openNURBS-static ${OPENNURBS_LINKLIBRARIES})
    IF(NOT WIN32)
      SET_TARGET_PROPERTIES(openNURBS-static PROPERTIES OUTPUT_NAME "openNURBS")
    ENDIF(NOT WIN32)
    install(TARGETS openNURBS-static
	    RUNTIME DESTINATION ${BIN_DIR}
	    LIBRARY DESTINATION ${LIB_DIR}
	    ARCHIVE DESTINATION ${LIB_DIR})
  ENDIF(BUILD_STATIC_LIBS)
ENDIF(NOT MSVC)

install(FILES ${OPENNURBS_HEADERS} DESTINATION include/openNURBS)
blob
data 6167

lib_LTLIBRARIES = libopenNURBS.la
noinst_LTLIBRARIES = libopenNURBS_nil.la

ON_INC = \
	opennurbs.h \
	opennurbs_3dm.h \
	opennurbs_3dm_attributes.h \
	opennurbs_3dm_properties.h \
	opennurbs_3dm_settings.h \
	opennurbs_annotation.h \
	opennurbs_annotation2.h \
	opennurbs_arc.h \
	opennurbs_arccurve.h \
	opennurbs_archive.h \
	opennurbs_array.h \
	opennurbs_array_defs.h \
	opennurbs_base32.h \
	opennurbs_base64.h \
	opennurbs_beam.h \
	opennurbs_bezier.h \
	opennurbs_bitmap.h \
	opennurbs_bounding_box.h \
	opennurbs_box.h \
	opennurbs_brep.h \
	opennurbs_circle.h \
	opennurbs_color.h \
	opennurbs_compress.h \
	opennurbs_cone.h \
	opennurbs_crc.h \
	opennurbs_curve.h \
	opennurbs_curveonsurface.h \
	opennurbs_curveproxy.h \
	opennurbs_cylinder.h \
	opennurbs_defines.h \
	opennurbs_detail.h \
	opennurbs_dimstyle.h \
	opennurbs_ellipse.h \
	opennurbs_error.h \
	opennurbs_evaluate_nurbs.h \
	opennurbs_extensions.h \
	opennurbs_font.h \
	opennurbs_fpoint.h \
	opennurbs_fsp.h \
	opennurbs_fsp_defs.h \
	opennurbs_geometry.h \
	opennurbs_gl.h \
	opennurbs_group.h \
	opennurbs_hatch.h \
	opennurbs_hsort_template.h \
	opennurbs_instance.h \
	opennurbs_intersect.h \
	opennurbs_knot.h \
	opennurbs_layer.h \
	opennurbs_light.h \
	opennurbs_line.h \
	opennurbs_linecurve.h \
	opennurbs_linestyle.h \
	opennurbs_linetype.h \
	opennurbs_lookup.h \
	opennurbs_mapchan.h \
	opennurbs_massprop.h \
	opennurbs_material.h \
	opennurbs_math.h \
	opennurbs_matrix.h \
	opennurbs_memory.h \
	opennurbs_mesh.h \
	opennurbs_nurbscurve.h \
	opennurbs_nurbssurface.h \
	opennurbs_object.h \
	opennurbs_object_history.h \
	opennurbs_objref.h \
	opennurbs_offsetsurface.h \
	opennurbs_optimize.h \
	opennurbs_plane.h \
	opennurbs_planesurface.h \
	opennurbs_pluginlist.h \
	opennurbs_point.h \
	opennurbs_pointcloud.h \
	opennurbs_pointgeometry.h \
	opennurbs_pointgrid.h \
	opennurbs_polycurve.h \
	opennurbs_polyedgecurve.h \
	opennurbs_polyline.h \
	opennurbs_polylinecurve.h \
	opennurbs_qsort_template.h \
	opennurbs_rand.h \
	opennurbs_rendering.h \
	opennurbs_revsurface.h \
	opennurbs_rtree.h \
	opennurbs_sphere.h \
	opennurbs_string.h \
	opennurbs_sumsurface.h \
	opennurbs_surface.h \
	opennurbs_surfaceproxy.h \
	opennurbs_system.h \
	opennurbs_textlog.h \
	opennurbs_texture.h \
	opennurbs_texture_mapping.h \
	opennurbs_torus.h \
	opennurbs_unicode.h \
	opennurbs_userdata.h \
	opennurbs_uuid.h \
	opennurbs_version.h \
	opennurbs_viewport.h \
	opennurbs_workspace.h \
	opennurbs_x.h \
	opennurbs_xform.h \
	opennurbs_zlib.h

ON_SRC = \
	opennurbs_3dm_attributes.cpp \
	opennurbs_3dm_properties.cpp \
	opennurbs_3dm_settings.cpp \
	opennurbs_annotation.cpp \
	opennurbs_annotation2.cpp \
	opennurbs_arc.cpp \
	opennurbs_arccurve.cpp \
	opennurbs_archive.cpp \
	opennurbs_array.cpp \
	opennurbs_base32.cpp \
	opennurbs_base64.cpp \
	opennurbs_basic.cpp \
	opennurbs_beam.cpp \
	opennurbs_bezier.cpp \
	opennurbs_beziervolume.cpp \
	opennurbs_bitmap.cpp \
	opennurbs_bounding_box.cpp \
	opennurbs_box.cpp \
	opennurbs_brep.cpp \
	opennurbs_brep_extrude.cpp \
	opennurbs_brep_io.cpp \
	opennurbs_brep_isvalid.cpp \
	opennurbs_brep_region.cpp \
	opennurbs_brep_tools.cpp \
	opennurbs_brep_v2valid.cpp \
	opennurbs_circle.cpp \
	opennurbs_color.cpp \
	opennurbs_compress.cpp \
	opennurbs_cone.cpp \
	opennurbs_crc.cpp \
	opennurbs_curve.cpp \
	opennurbs_curveonsurface.cpp \
	opennurbs_curveproxy.cpp \
	opennurbs_cylinder.cpp \
	opennurbs_defines.cpp \
	opennurbs_detail.cpp \
	opennurbs_dimstyle.cpp \
	opennurbs_ellipse.cpp \
	opennurbs_embedded_file.cpp \
	opennurbs_error.cpp \
	opennurbs_error_message.cpp \
	opennurbs_evaluate_nurbs.cpp \
	opennurbs_extensions.cpp \
	opennurbs_font.cpp \
	opennurbs_fsp.cpp \
	opennurbs_geometry.cpp \
	opennurbs_group.cpp \
	opennurbs_hatch.cpp \
	opennurbs_instance.cpp \
	opennurbs_intersect.cpp \
	opennurbs_knot.cpp \
	opennurbs_layer.cpp \
	opennurbs_light.cpp \
	opennurbs_line.cpp \
	opennurbs_linecurve.cpp \
	opennurbs_linetype.cpp \
	opennurbs_lookup.cpp \
	opennurbs_massprop.cpp \
	opennurbs_material.cpp \
	opennurbs_math.cpp \
	opennurbs_matrix.cpp \
	opennurbs_memory.c \
	opennurbs_memory_util.c \
	opennurbs_mesh.cpp \
	opennurbs_mesh_ngon.cpp \
	opennurbs_mesh_tools.cpp \
	opennurbs_morph.cpp \
	opennurbs_nurbscurve.cpp \
	opennurbs_nurbssurface.cpp \
	opennurbs_nurbsvolume.cpp \
	opennurbs_object.cpp \
	opennurbs_object_history.cpp \
	opennurbs_objref.cpp \
	opennurbs_offsetsurface.cpp \
	opennurbs_optimize.cpp \
	opennurbs_plane.cpp \
	opennurbs_planesurface.cpp \
	opennurbs_pluginlist.cpp \
	opennurbs_point.cpp \
	opennurbs_pointcloud.cpp \
	opennurbs_pointgeometry.cpp \
	opennurbs_pointgrid.cpp \
	opennurbs_polycurve.cpp \
	opennurbs_polyedgecurve.cpp \
	opennurbs_polyline.cpp \
	opennurbs_polylinecurve.cpp \
	opennurbs_rand.cpp \
	opennurbs_revsurface.cpp \
	opennurbs_rtree.cpp \
	opennurbs_sort.cpp \
	opennurbs_sphere.cpp \
	opennurbs_string.cpp \
	opennurbs_sum.cpp \
	opennurbs_sumsurface.cpp \
	opennurbs_surface.cpp \
	opennurbs_surfaceproxy.cpp \
	opennurbs_textlog.cpp \
	opennurbs_torus.cpp \
	opennurbs_unicode.cpp \
	opennurbs_userdata.cpp \
	opennurbs_uuid.cpp \
	opennurbs_viewport.cpp \
	opennurbs_workspace.cpp \
	opennurbs_wstring.cpp \
	opennurbs_x.cpp \
	opennurbs_xform.cpp \
	opennurbs_zlib.cpp \
	opennurbs_zlib_memory.cpp

nurbincludedir = $(includedir)/openNURBS
nurbinclude_HEADERS = $(ON_INC)

libopenNURBS_nil_la_SOURCES = $(ON_SRC)
libopenNURBS_nil_la_CFLAGS = ${LIBZ_CPPFLAGS} ${NOWARN}
libopenNURBS_nil_la_CXXFLAGS = ${LIBZ_CPPFLAGS} ${NOWARN}
libopenNURBS_nil_la_LIBADD = ${LIBZ}

libopenNURBS_la_SOURCES =
libopenNURBS_la_LIBADD = libopenNURBS_nil.la

ON_EXTRA = \
	opennurbs.rc \
	opennurbs_dll.cpp \
	opennurbs_dll_resource.h \
	opennurbs_gl.cpp \
	opennurbs_precompiledheader.cpp

EXTRA_DIST = \
	${ON_EXTRA} \
	example_brep \
	example_dump \
	example_gl \
	example_read \
	example_roundtrip \
	example_userdata \
	example_write \
	examples_linking_pragmas.h \
	BRL-CAD_changes.txt \
	faq.txt \
	license.txt \
	readme.txt \
        CMakeLists.txt

if BUILD_ZLIB
DEPADD = src/other/libz
endif
DEPENDS = ${DEPADD}

include $(top_srcdir)/misc/Makefile.defs

blob
data 22824
/* $Header$ */
/* $NoKeywords: $ */
//
// Copyright (c) 1993-1998 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
////////////////////////////////////////////////////////////////

#include "../opennurbs.h"
#include "../opennurbs_staticlib_linking_pragmas.h"

// This example demonstrates two things:
//
// 1) How to dig through a ON_Brep face  and get at the surface
//    and trimming information.  See TraverseBrepFace() for
//    details.
//
// 2) How to write an OpenNURBS B-rep.  See MakeTwistedCube() for details.

void TraverseBrepFace( 
       const ON_Brep& brep,
       int fi,                  // brep face index
       ON_TextLog& error_log
       )
{
  if ( fi < 0 || fi >= brep.m_F.Count() ) 
  {
    error_log.Print("Invalid face index\n");
    return;
  }

  const ON_BrepFace& face = brep.m_F[fi];

  // pSrf = underlying untrimmed surface
  const ON_Surface* pSrf = NULL;
  if ( face.m_si < 0 || face.m_si >= brep.m_S.Count() )
    error_log.Print("ERROR: invalid brep.m_F[%d].m_si\n", fi );
  else {
    pSrf = brep.m_S[face.m_si];
    if ( !pSrf )
      error_log.Print("ERROR: invalid brep.m_S[%d] is NULL\n", face.m_si );
  }

  // The face is trimmed with one or more trimming loops.
  //
  // All the 2d trimming curves are oriented so that the
  // active region of the trimmed surface lies to the left
  // of the 2d trimming curve.  
  //
  // If face.m_bRev is true, the orientations of the face in
  // the b-rep is opposited the natural parameteric orientation
  // of the surface.

  // loop_count = number of trimming loops on this face (>=1)
  const int loop_count = face.m_li.Count(); 

  int fli; // face's loop index
  for ( fli = 0; fli < loop_count; fli++ ) {
    const int li = face.m_li[fli]; // li = brep loop index
    const ON_BrepLoop& loop = brep.m_L[li];

    // loop_edge_count = number of trimming edges in this loop
    const int loop_trim_count = loop.m_ti.Count();

    int lti; // loop's trim index
    for ( lti = 0; lti < loop_trim_count; lti++ ) {
      const int ti = loop.m_ti[lti]; // ti = brep trim index
      const ON_BrepTrim& trim = brep.m_T[ti];

      //////////////////////////////////////////////////////
      // 2d trimming information
      //
      // Each trim has a 2d parameter space curve.
      const ON_Curve* p2dCurve = NULL;
      const int c2i = trim.m_c2i; // c2i = brep 2d curve index
      if ( c2i < 0 || c2i >= brep.m_C2.Count() ) {
        error_log.Print("ERROR: invalid brep.m_T[%d].m_c2i\n", ti );
      }
      else {
        p2dCurve = brep.m_C2[c2i];
        if ( !p2dCurve )
          error_log.Print("ERROR: invalid brep.m_C2[%d] is NULL\n", c2i );
      }


      //////////////////////////////////////////////////////
      // topology and 3d geometry information
      //

      // Trim starts at v0 and ends at v1.  When the trim
      // is a loop or on a singular surface side, v0i and v1i
      // will be equal.
      //const int v0i = trim.m_vi[0]; // v0i = brep vertex index
      //const int v1i = trim.m_vi[1]; // v1i = brep vertex index
      //const ON_BrepVertex& v0 = brep.m_V[v0i];
      //const ON_BrepVertex& v1 = brep.m_V[v1i];
      // The vX.m_ei[] array contains the brep.m_E[] indices of
      // the edges that begin or end at vX.
      
      const int ei = trim.m_ei;
      if ( ei == -1 ) {
        // This trim lies on a portion of a singular surface side.
        // The vertex indices are still valid and will be equal.
      }
      else {
        // If trim.m_bRev3d is false, the orientations of the 3d edge
        // and the 3d curve obtained by composing the surface and 2d
        // curve agree.
        //
        // If trim.m_bRev3d is true, the orientations of the 3d edge
        // and the 3d curve obtained by composing the surface and 2d
        // curve are opposite.
        const ON_BrepEdge& edge = brep.m_E[ei];
        const int c3i = edge.m_c3i;
        const ON_Curve* p3dCurve = NULL;

        if ( c3i < 0 || c3i >= brep.m_C3.Count() ) {
          error_log.Print("ERROR: invalid brep.m_E[%d].m_c3i\n", ei );
        }
        else {
          p3dCurve = brep.m_C3[c3i];
          if ( !p3dCurve )
            error_log.Print("ERROR: invalid brep.m_C3[%d] is NULL\n", c3i );
        }

        // The edge.m_ti[] array contains the brep.m_T[] indices
        // for the other trims that are joined to this edge.
      }
    }
  }
}

// symbolic vertex index constants to make code more readable
static const int 
  A = 0,
  B = 1,
  C = 2,
  D = 3,
  E = 4,
  F = 5,
  G = 6,
  H = 7;

// symbolic edge index constants to make code more readable
static const int
  AB =  0,
  BC =  1,
  CD =  2,
  AD =  3,
  EF =  4,
  FG =  5,
  GH =  6,
  EH =  7,
  AE =  8,
  BF =  9,
  CG = 10,
  DH = 11;

// symbolic face index constants to make code more readable
static const int
  ABCD =  0,
  BCGF =  1,
  CDHG =  2,
  ADHE =  3,
  ABFE =  4,
  EFGH =  5;

static ON_Curve* TwistedCubeTrimmingCurve(
              const ON_Surface& s,
              int side // 0 = SW to SE
                       // 1 = SE to NE
                       // 2 = NE to NW
                       // 3 = NW to SW
              )
{
  // A trimming curve is a 2d curve whose image lies in the surface's domain.
  // The "active" portion of the surface is to the left of the trimming curve.
  // An outer trimming loop consists of a simple closed curve running 
  // counter-clockwise around the region it trims.

  ON_2dPoint from, to;
  double u0, u1, v0, v1;

  s.GetDomain( 0, &u0, &u1 );
  s.GetDomain( 1, &v0, &v1 );

  switch ( side ) {
  case 0:  // SW to SE
    from.x = u0; from.y = v0;
    to.x   = u1; to.y   = v0;
    break;
  case 1: // SE to NE
    from.x = u1; from.y = v0;
    to.x   = u1; to.y   = v1;
    break;
  case 2: // NE to NW
    from.x = u1; from.y = v1;
    to.x   = u0; to.y   = v1;
    break;
  case 3: // NW to SW
    from.x = u0; from.y = v1;
    to.x   = u0; to.y   = v0;
    break;
  default:
    return 0;
  }

  ON_Curve* c2d = new ON_LineCurve( from, to );
  c2d->SetDomain(0.0,1.0);

  return c2d;
}


static ON_Curve* TwistedCubeEdgeCurve( const ON_3dPoint& from, const ON_3dPoint& to )
{
  // creates a 3d line segment to be used as a 3d curve in a ON_Brep
  ON_Curve* c3d = new ON_LineCurve( from, to );
  c3d->SetDomain( 0.0, 1.0 );
  return c3d;
}

static ON_Surface* TwistedCubeSideSurface( 
                             const ON_3dPoint& SW, const ON_3dPoint& SE,
                             const ON_3dPoint& NE, const ON_3dPoint& NW
                             )
{
  ON_NurbsSurface* pNurbsSurface = new ON_NurbsSurface(
                                        3,     // dimension
                                        false, // not rational
                                        2,     // "u" order
                                        2,     // "v" order
                                        2,     // number of control vertices in "u" dir
                                        2      // number of control vertices in "v" dir
                                        );
  // corner CVs in counter clockwise order starting in the south west
  pNurbsSurface->SetCV( 0,0, SW );
  pNurbsSurface->SetCV( 1,0, SE );
  pNurbsSurface->SetCV( 1,1, NE );
  pNurbsSurface->SetCV( 0,1, NW );
  // "u" knots
  pNurbsSurface->SetKnot( 0,0, 0.0 );
  pNurbsSurface->SetKnot( 0,1, 1.0 );
  // "v" knots
  pNurbsSurface->SetKnot( 1,0, 0.0 );
  pNurbsSurface->SetKnot( 1,1, 1.0 );

  return pNurbsSurface;
}

static void MakeTwistedCubeEdge( ON_Brep& brep,
                                 int vi0, // index of start vertex
                                 int vi1, // index of end vertex
                                 int c3i  // index of 3d curve
                                 )
{
  ON_BrepVertex& v0 = brep.m_V[vi0];
  ON_BrepVertex& v1 = brep.m_V[vi1];
  ON_BrepEdge& edge = brep.NewEdge(v0,v1,c3i);
  edge.m_tolerance = 0.0;  // this simple example is exact - for models with
                           // non-exact data, set tolerance as explained in
                           // definition of ON_BrepEdge.
}

static void MakeTwistedCubeEdges( ON_Brep& brep )
{

  // In this simple example, the edge indices exactly match the 3d
  // curve indices.  In general,the correspondence between edge and
  // curve indices can be arbitrary.  It is permitted for multiple
  // edges to use different portions of the same 3d curve.  The 
  // orientation of the edge always agrees with the natural 
  // parametric orientation of the curve.
  
  // edge that runs from A to B
  MakeTwistedCubeEdge( brep, A, B, AB );
  
  // edge that runs from B to C
  MakeTwistedCubeEdge( brep, B, C, BC );

  // edge that runs from C to D
  MakeTwistedCubeEdge( brep, C, D, CD );

  // edge that runs from A to D
  MakeTwistedCubeEdge( brep, A, D, AD );

  // edge that runs from E to F
  MakeTwistedCubeEdge( brep, E, F, EF );

  // edge that runs from F to G
  MakeTwistedCubeEdge( brep, F, G, FG );

  // edge that runs from G to H
  MakeTwistedCubeEdge( brep, G, H, GH );

  // edge that runs from E to H
  MakeTwistedCubeEdge( brep, E, H, EH );

  // edge that runs from A to E
  MakeTwistedCubeEdge( brep, A, E, AE );

  // edge that runs from B to F
  MakeTwistedCubeEdge( brep, B, F, BF );

  // edge that runs from C to G
  MakeTwistedCubeEdge( brep, C, G, CG );

  // edge that runs from D to H
  MakeTwistedCubeEdge( brep, D, H, DH );
}

static int MakeTwistedCubeTrimmingLoop(  ON_Brep& brep, // returns index of loop
     ON_BrepFace& face,  // face loop is on
     //int vSWi, int vSEi, int vNEi, int vNWi, // Indices of corner vertices listed in SW,SE,NW,NE order
     int eSi,     // index of edge on south side of surface
     int eS_dir,  // orientation of edge with respect to surface trim
     int eEi,     // index of edge on south side of surface
     int eE_dir,  // orientation of edge with respect to surface trim
     int eNi,     // index of edge on south side of surface
     int eN_dir,  // orientation of edge with respect to surface trim
     int eWi,     // index of edge on south side of surface
     int eW_dir   // orientation of edge with respect to surface trim
                                )
{
  const ON_Surface& srf = *brep.m_S[face.m_si];

  ON_BrepLoop& loop = brep.NewLoop( ON_BrepLoop::outer, face );

  // Create trimming curves running counter clockwise around the surface's domain.
  // Start at the south side
  ON_Curve* c2;
  int c2i, ei=0, bRev3d=0;
  ON_2dPoint q;
  ON_Surface::ISO iso = ON_Surface::not_iso;

  for ( int side = 0; side < 4; side++ ) {
    // side: 0=south, 1=east, 2=north, 3=west
    
    c2 = TwistedCubeTrimmingCurve( srf, side );
    c2i = brep.m_C2.Count();
    brep.m_C2.Append(c2);

    switch ( side ) {
    case 0: // south
      ei = eSi;
      bRev3d = (eS_dir == -1);
      iso = ON_Surface::S_iso;
      break;
    case 1: // east
      ei = eEi;
      bRev3d = (eE_dir == -1);
      iso = ON_Surface::E_iso;
      break;
    case 2: // north
      ei = eNi;
      bRev3d = (eN_dir == -1);
      iso = ON_Surface::N_iso;
      break;
    case 3: // west
      ei = eWi;
      bRev3d = (eW_dir == -1);
      iso = ON_Surface::W_iso;
      break;
    }

    ON_BrepTrim& trim = brep.NewTrim( brep.m_E[ei], bRev3d, loop, c2i );
    q = c2->PointAtStart();
    //trim.m_P[0] = srf.PointAt( q.x, q.y );
    q = c2->PointAtEnd();
    //trim.m_P[1] = srf.PointAt( q.x, q.y );
    trim.m_iso = iso;
    trim.m_type = ON_BrepTrim::mated; // This b-rep is closed, so all trims
                                         // have mates.
    trim.m_tolerance[0] = 0.0; // This simple example is exact - for models with
    trim.m_tolerance[1] = 0.0; // non-exact data, set tolerance as explained in
                               // definition of ON_BrepTrim.
  }

  return loop.m_loop_index;
}

static void MakeTwistedCubeFace( ON_Brep& brep,
     int si,      // index of 3d surface
     int s_dir,   // orientation of surface with respect to brep
     //int vSWi, int vSEi, int vNEi, int vNWi, // Indices of corner vertices listed in SW,SE,NW,NE order
     int eSi,     // index of edge on south side of surface
     int eS_dir,  // orientation of edge with respect to surface trim
     int eEi,     // index of edge on south side of surface
     int eE_dir,  // orientation of edge with respect to surface trim
     int eNi,     // index of edge on south side of surface
     int eN_dir,  // orientation of edge with respect to surface trim
     int eWi,     // index of edge on south side of surface
     int eW_dir   // orientation of edge with respect to surface trim
                                )
{
  ON_BrepFace& face = brep.NewFace(si);

  MakeTwistedCubeTrimmingLoop( brep, face,
                //vSWi, vSEi, vNEi, vNWi, 
                eSi, eS_dir, 
                eEi, eE_dir, 
                eNi, eN_dir, 
                eWi, eW_dir 
                );

  face.m_bRev = (s_dir == -1);
}

static void MakeTwistedCubeFaces( ON_Brep& brep )
{

  MakeTwistedCubeFace( brep,
    ABCD,       // Index of surface ABCD
    +1,         // orientation of surface with respect to brep
    //A, B, C, D, // Indices of vertices listed in SW,SE,NW,NE order
    AB,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (AB)
    BC,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (BC)
    CD,+1,      // South side edge and its orientation with respect to
                // to the trimming curve   (CD)
    AD,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (AD)
    );

  MakeTwistedCubeFace( brep,
    BCGF,       // Index of surface BCGF
    -1,         // orientation of surface with respect to brep
    //B, C, G, F, // Indices of vertices listed in SW,SE,NW,NE order
    BC,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (BC)
    CG,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (CG)
    FG,-1,      // South side edge and its orientation with respect to
                // to the trimming curve   (FG)
    BF,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (BF)
    );

  MakeTwistedCubeFace( brep,
    CDHG,       // Index of surface CDHG
    -1,         // orientation of surface with respect to brep
    //C, D, H, G, // Indices of vertices listed in SW,SE,NW,NE order
    CD,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (CD)
    DH,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (DH)
    GH,-1,      // South side edge and its orientation with respect to
                // to the trimming curve   (GH)
    CG,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (CG)
    );

  MakeTwistedCubeFace( brep,
    ADHE,       // Index of surface ADHE
    +1,         // orientation of surface with respect to brep
    //A, D, H, E, // Indices of vertices listed in SW,SE,NW,NE order
    AD,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (AD)
    DH,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (DH)
    EH,-1,      // South side edge and its orientation with respect to
                // to the trimming curve   (EH)
    AE,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (AE)
    );

  MakeTwistedCubeFace( brep,
    ABFE,       // Index of surface ABFE
    -1,         // orientation of surface with respect to brep
    //A, B, F, E, // Indices of vertices listed in SW,SE,NW,NE order
    AB,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (AB)
    BF,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (BF)
    EF,-1,      // South side edge and its orientation with respect to
                // to the trimming curve   (EF)
    AE,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (AE)
    );

  MakeTwistedCubeFace( brep,
    EFGH,       // Index of surface EFGH
    -1,         // orientation of surface with respect to brep
    //E, F, G, H, // Indices of vertices listed in SW,SE,NW,NE order
    EF,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (EF)
    FG,+1,      // South side edge and its orientation with respect to
                // to the trimming curve.  (FG)
    GH,+1,      // South side edge and its orientation with respect to
                // to the trimming curve   (GH)
    EH,-1       // South side edge and its orientation with respect to
                // to the trimming curve   (EH)
    );
}


static ON_Brep* MakeTwistedCube( ON_TextLog& error_log )
{
  // This example demonstrates how to construct a ON_Brep
  // with the topology shown below.
  //
  //
  //             H-------e6-------G
  //            /                /|
  //           / |              / |
  //          /  e7            /  e5
  //         /   |            /   |
  //        /                e10  |
  //       /     |          /     |
  //      e11    E- - e4- -/- - - F
  //     /                /      /
  //    /      /         /      /
  //   D---------e2-----C      e9
  //   |     /          |     /
  //   |    e8          |    /
  //   e3  /            e1  /
  //   |                |  /
  //   | /              | /
  //   |                |/
  //   A-------e0-------B
  //
  //

  ON_3dPoint point[8] = {
    ON_3dPoint(  0.0,  0.0,  0.0 ),  // point A = geometry for vertex 0
    ON_3dPoint( 10.0,  0.0,  0.0 ),  // point B = geometry for vertex 1
    ON_3dPoint( 10.0,  8.0, -1.0 ),  // point C = geometry for vertex 2
    ON_3dPoint(  0.0,  6.0,  0.0 ),  // point D = geometry for vertex 3
    ON_3dPoint(  1.0,  2.0, 11.0 ),  // point E = geometry for vertex 4
    ON_3dPoint( 10.0,  0.0, 12.0 ),  // point F = geometry for vertex 5
    ON_3dPoint( 10.0,  7.0, 13.0 ),  // point G = geometry for vertex 6
    ON_3dPoint(  0.0,  6.0, 12.0 )   // point H = geometry for vertex 7
  };

  ON_Brep* brep = new ON_Brep();

  // create eight vertices located at the eight points
  int vi;
  for ( vi = 0; vi < 8; vi++ ) {
    ON_BrepVertex& v = brep->NewVertex(point[vi]);
    v.m_tolerance = 0.0; // this simple example is exact - for models with
                         // non-exact data, set tolerance as explained in
                         // definition of ON_BrepVertex.
  }

  // Create 3d curve geometry - the orientations are arbitrarily chosen
  // so that the end vertices are in alphabetical order.
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[A], point[B] ) ); // line AB
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[B], point[C] ) ); // line BC
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[C], point[D] ) ); // line CD
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[A], point[D] ) ); // line AD
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[E], point[F] ) ); // line EF
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[F], point[G] ) ); // line FG
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[G], point[H] ) ); // line GH
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[E], point[H] ) ); // line EH
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[A], point[E] ) ); // line AE
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[B], point[F] ) ); // line BF
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[C], point[G] ) ); // line CG
  brep->m_C3.Append( TwistedCubeEdgeCurve( point[D], point[H] ) ); // line DH

  // Create the 12 edges that connect the corners of the cube.
  MakeTwistedCubeEdges( *brep );

  // Create 3d surface geometry - the orientations are arbitrarily chosen so
  // that some normals point into the cube and others point out of the cube.
  brep->m_S.Append( TwistedCubeSideSurface( point[A], point[B], point[C], point[D] ) ); // ABCD
  brep->m_S.Append( TwistedCubeSideSurface( point[B], point[C], point[G], point[F] ) ); // BCGF
  brep->m_S.Append( TwistedCubeSideSurface( point[C], point[D], point[H], point[G] ) ); // CDHG
  brep->m_S.Append( TwistedCubeSideSurface( point[A], point[D], point[H], point[E] ) ); // ADHE
  brep->m_S.Append( TwistedCubeSideSurface( point[A], point[B], point[F], point[E] ) ); // ABFE
  brep->m_S.Append( TwistedCubeSideSurface( point[E], point[F], point[G], point[H] ) ); // EFGH


  // Create the CRhinoBrepFaces
  MakeTwistedCubeFaces( *brep );

  if ( !brep->IsValid() ) 
  {
    error_log.Print("Twisted cube b-rep is not valid.\n");
    delete brep;
    brep = NULL;
  }

  //ON_BOOL32 bIsManifold;
  //ON_BOOL32 bHasBoundary;
  //ON_BOOL32 b = brep->IsManifold( &bIsManifold,&bHasBoundary );

  return brep;
}

//int main( int argc, const char *argv[] )
int main()
{
  ON::Begin();

  ON_TextLog error_log;

  // Before working through this example, you should understand
  // the example_write.cpp example.

  ON_Brep* brep = MakeTwistedCube(error_log);
  if ( !brep )
    return 1;

  ONX_Model model;

  ONX_Model_Object& mo = model.m_object_table.AppendNew();
  mo.m_object = brep;
  mo.m_bDeleteObject = true; // ~ONX_Model will delete brep
  brep = 0;
  mo.m_attributes.m_name = "Twisted b-rep";

  // OPTIONAL - change values from defaults
  model.m_properties.m_Notes.m_notes = "File created by OpenNURBS example_brep.cpp";
  model.m_properties.m_Notes.m_bVisible = true;

  model.m_properties.m_Application.m_application_name 
    = "OpenNURBS example_brep.cpp";
  model.m_properties.m_Application.m_application_URL 
    = "http://www.opennurbs.org";
  model.m_properties.m_Application.m_application_details 
    = "OpenNURBS example showing how to create and write a simple b-rep";


  int version = 4; // File can be read by Rhino 4 and Rhino 5
  //int version = 5; // File can be read by Rhino 5
  model.Polish();
  const char* filename = "my_brep.3dm";
  bool rc = model.Write( filename, 
               version,
               __FILE__ " example_brep.cpp " __DATE__,
               &error_log
               );

  if (rc)
    printf("Wrote %s.\n",filename);
  else
    printf("Errors writing %s.\n",filename);

  ON::End();

  return 0;
}

blob
data 28316
/* $Header$ */
/* $NoKeywords: $ */
//
// Copyright (c) 1993-1998 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
////////////////////////////////////////////////////////////////

#include "../opennurbs.h"
#include "../opennurbs_gl.h"
#include "../opennurbs_staticlib_linking_pragmas.h"

#if defined(ON_COMPILER_MSC)

// Tested compilers:
//   Microsoft Developer Studio 6.0
//   Microsoft Visual Studio 2005
//   Support for other Windows compilers is not available.

#include <GL/GLaux.h>   // Open GL auxillary functions
#define ON_EXAMPLE_GL_USE_GLAUX

#elif defined(ON_COMPILER_XCODE)

// Tested compilers:
//   Apple XCode 2.4.1
//   Support for other Apple compilers is not available.
#include <GLUT/glut.h>   // Open GL auxillary functions
#define ON_EXAMPLE_GL_USE_GLUT

#else

// Unsupported compiler:
//   Support for other compilers is not available
#error Choose between OpenGL AUX or OpenGL GLUT.

//#include <GLaux.h>   // Open GL auxillary functions
//#define ON_EXAMPLE_GL_USE_GLAUX

//#include <glut.h>   // Open GL auxillary functions
//#define ON_EXAMPLE_GL_USE_GLUT

#endif


#if defined(_WINDOWS) || defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)
#define MY_GL_CALLBACK CALLBACK
#define MY_USE_WINDOWS_STUFF
#else
#define MY_GL_CALLBACK
#endif

// Before working on this file, be sure to study the OpenNURBS toolkit 
// file example_read.cpp and to read chapters 1 through 11 of the 
// _Open_GL_Programming_Guide_.
//
// This file contains simple example in modeled after those found in
// the _Open_GL_Programming_Guide_.  The nuts and bolts functions that
// demonstrate how to use Open GL to display OpenNURBS geometry are in
// opennurbs_gl.cpp.

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


class CModel : public ONX_Model
{
public:
  void GetObjectMaterial( int object_index, ON_Material& material ) const;
  ON_3dmView m_view;
  ON_BoundingBox m_bbox;
};

void CModel::GetObjectMaterial( 
          int object_index,
          ON_Material& material 
          ) const
{
  material.Default();
  //const ON_Geometry* geo = 0;

  if ( object_index >= 0 && object_index <= m_object_table.Count() )
  {
    const ONX_Model_Object& mo = m_object_table[object_index];
    if ( 0 != mo.m_object )
    {
      switch( mo.m_object->ObjectType() )
      {
      case ON::surface_object:
      case ON::brep_object:
      case ON::mesh_object:
      case ON::instance_reference:
        GetRenderMaterial( mo.m_attributes, material );
        break;
      default:
        {
          // use emmissive object color for curve objects
          ON_Color c = WireframeColor( mo.m_attributes );
          ON_Color black(0,0,0);
          material.Default();
          material.SetAmbient(black);
          material.SetDiffuse(black);
          material.SetSpecular(black);
          material.SetEmission(c);
        }
        break;
      }
    }
  }
}


void GetDefaultView( const ON_BoundingBox& bbox, ON_3dmView& view )
{
  // simple parallel projection of bounding box;
  double window_height = 1.0;
  double window_width = 1.0;
  double dx, dy, dz;
  double frus_near, frus_far;
  ON_3dPoint camLoc;
  ON_3dVector camDir, camUp;
  view.m_target = 0.5*(bbox.m_min + bbox.m_max);
  dx = 1.1*(bbox.m_max[0] - bbox.m_min[0]);
  dy = 1.1*(bbox.m_max[1] - bbox.m_min[1]);
  dz = 1.1*(bbox.m_max[2] - bbox.m_min[2]);
  if ( dx <= 1.0e-6 && dy <= 1.0e-6 )
    dx = dy = 2.0;
  if ( window_height*dx < window_width*dy ) {
    dx = dy*window_width/window_height;
  }
  else {
    dy = dx*window_height/window_width;
  }
  if ( dz <= 0.1*(dx+dy) )
    dz = 0.1*(dx+dy);
  dx *= 0.5;
  dy *= 0.5;
  dz *= 0.5;


  frus_near = 1.0;
  frus_far = frus_near + 2.0*dz;
  camLoc = view.m_target + (dz + frus_near)*ON_zaxis;
  camDir = -ON_zaxis;
  camUp = ON_yaxis;

  view.m_vp.SetProjection( ON::parallel_view );
  view.m_vp.SetCameraLocation( camLoc );
  view.m_vp.SetCameraDirection( camDir );
  view.m_vp.SetCameraUp( camUp );
  view.m_vp.SetFrustum( -dx, dx, -dy, dy, frus_near, frus_far );
}

///////////////////////////////////////////////////////////////////////
//
// Globals for myDisplay() function passed to auxMainLoop()
//
//////////////////////////////////////////////////////////////////////

// GL display list "name"
static GLuint glb_display_list_number = 1;

// global pointer to active model
CModel* glb_model = 0;

///////////////////////////////////////////////////////////////////////
//
// Functions used in main()
//
//////////////////////////////////////////////////////////////////////

ON_BOOL32 myInitGL( const ON_Viewport&, GLUnurbsObj*& );

void myBuildDisplayList( 
      GLuint,                  // display_list_number,
      GLUnurbsObj*,            // pointer to GL nurbs render
      const CModel&            // geometry to render
      );

extern "C" {
void MY_GL_CALLBACK myNurbsErrorCallback( GLenum ); // for gluNurbsCallback()

void MY_GL_CALLBACK myDisplay( void );              // for auxMainLoop()


void MY_GL_CALLBACK myKeyLeftArrowEvent( void );    // for auxKeyFunc();
void MY_GL_CALLBACK myKeyRightArrowEvent( void );   // for auxKeyFunc();
void MY_GL_CALLBACK myKeyUpArrowEvent( void );      // for auxKeyFunc();
void MY_GL_CALLBACK myKeyDownArrowEvent( void );    // for auxKeyFunc();
void MY_GL_CALLBACK myKeyViewExtents( void );       // for auxKeyFunc();

#if defined(ON_EXAMPLE_GL_USE_GLAUX)
void MY_GL_CALLBACK myGLAUX_Reshape( GLsizei, GLsizei );  // for auxReshapeFunc()

void MY_GL_CALLBACK myGLAUX_MouseLeftEvent( AUX_EVENTREC* );   // for auxMouseFunc();
void MY_GL_CALLBACK myGLAUX_MouseMiddleEvent( AUX_EVENTREC* ); // for auxMouseFunc();
void MY_GL_CALLBACK myGLAUX_MouseRightEvent( AUX_EVENTREC* );  // for auxMouseFunc();

typedef void (CALLBACK* RHINO_GL_NURBS_ERROR)();
#endif

#if defined(ON_EXAMPLE_GL_USE_GLUT)
void MY_GL_CALLBACK myGLUT_Reshape( int, int );  // for glutReshapeFunc()

void MY_GL_CALLBACK myGLUT_MouseEvent( int button, int state, int x, int y );
void MY_GL_CALLBACK myGLUT_KeyboardEvent( unsigned char ch, int x, int y );
void MY_GL_CALLBACK myGLUT_SpecialKeyEvent( int ch, int x, int y );    // for auxKeyFunc();

// If you are using Apple's Xcode and you get a compile error
// on the typedef below, then try using the commented out typedef.
//
// Apple's Xcode 2.4 likes this typedef with the (...)
//typedef void (CALLBACK* RHINO_GL_NURBS_ERROR)(...);
//
// Apple's Xcode 3.2 likes this typedef without the ()
typedef void (CALLBACK* RHINO_GL_NURBS_ERROR)();
#endif

}

///////////////////////////////////////////////////////////////////////
//
// used to set projections
//
void SetGLModelViewMatrix( const ON_Viewport& );
void SetGLProjectionMatrix( ON_Viewport& );
///////////////////////////////////////////////////////////////////////

int main( int argc, const char *argv[] )
{
  // reads model into global glb_model;
  ON::Begin();

  ON_TextLog error_log;

  ON_BOOL32 bOK;
  int window_width  = 500;
  int window_height = 500;
  //double port_aspect = ((double)window_width)/((double)window_height);

  // read the file into model
  if ( argc != 2 ) {
    printf("Syntax: %s filename.3dm\n",argv[0] );
    return 0;
  }
  const char* sFileName = argv[1];
  printf("\nFile:  %s\n", sFileName );

  // read the file
  CModel model;
  if ( !model.Read( sFileName, &error_log ) )
  {
    // read failed
    error_log.Print("Unable to read file %s\n",sFileName);
    return 1;
  }

  glb_model = &model;

  // set bbox = world bounding box of all the objects
  model.m_bbox = model.BoundingBox();
  if ( !model.m_bbox.IsValid() )
  {
    // nothing to look at in this model
    return 2;
  }

  // set model.m_view
  if ( model.m_settings.m_views.Count() > 0 )
  {
    // use first viewport projection in file
    double angle;
    model.m_view.m_vp = model.m_settings.m_views[0].m_vp;
    model.m_view.m_target = model.m_settings.m_views[0].m_target;
    model.m_view.m_vp.GetCameraAngle( &angle );
    model.m_view.m_vp.Extents( angle, model.m_bbox );
  }
  else 
  {
    GetDefaultView( model.m_bbox, model.m_view );
  }

  // If needed, enlarge frustum so its aspect matches the window's aspect.
  // Since the Rhino file does not store the far frustum distance in the
  // file, viewports read from a Rhil file need to have the frustum's far
  // value set by inspecting the bounding box of the geometry to be
  // displayed.

  
  ///////////////////////////////////////////////////////////////////
  //
  // GL stuff starts here
  //
  for(;;) {  
    
#if defined(ON_EXAMPLE_GL_USE_GLAUX)
    wchar_t sWindowTitleString[256];
#endif
#if defined(ON_EXAMPLE_GL_USE_GLUT)
    char sWindowTitleString[256];
#endif
    sWindowTitleString[255] = 0;
    if ( argv[0] && argv[0][0] )
    {
      int i;
      for ( i = 0; i < 254 && argv[0][i]; i++ )
        sWindowTitleString[i] = argv[0][i];
      sWindowTitleString[i] = 0;
    }

#if defined(ON_EXAMPLE_GL_USE_GLAUX)
    auxInitPosition( 0, 0, window_width, window_height );
    auxInitDisplayMode( AUX_SINGLE | AUX_RGB | AUX_DEPTH );
    auxInitWindow( sWindowTitleString );

    // register event handler functions
    auxIdleFunc( 0 );
    auxReshapeFunc( myGLAUX_Reshape );
    auxMouseFunc( AUX_LEFTBUTTON,   AUX_MOUSEDOWN, myGLAUX_MouseLeftEvent );
    auxMouseFunc( AUX_LEFTBUTTON,   AUX_MOUSEUP,   myGLAUX_MouseLeftEvent );
    auxMouseFunc( AUX_MIDDLEBUTTON, AUX_MOUSEDOWN, myGLAUX_MouseMiddleEvent );
    auxMouseFunc( AUX_MIDDLEBUTTON, AUX_MOUSEUP,   myGLAUX_MouseMiddleEvent );
    auxMouseFunc( AUX_RIGHTBUTTON,  AUX_MOUSEDOWN, myGLAUX_MouseRightEvent );
    auxMouseFunc( AUX_RIGHTBUTTON,  AUX_MOUSEUP,   myGLAUX_MouseRightEvent );
    auxKeyFunc( AUX_LEFT,  myKeyLeftArrowEvent );
    auxKeyFunc( AUX_RIGHT, myKeyRightArrowEvent );
    auxKeyFunc( AUX_UP,    myKeyUpArrowEvent );
    auxKeyFunc( AUX_DOWN,  myKeyDownArrowEvent );
    auxKeyFunc( AUX_E,  myKeyViewExtents );
    auxKeyFunc( AUX_e,  myKeyViewExtents );
    auxKeyFunc( AUX_Z,  myKeyViewExtents );
    auxKeyFunc( AUX_z,  myKeyViewExtents );
#endif

#if defined(ON_EXAMPLE_GL_USE_GLUT)
    glutInit(&argc,(char**)argv);
    glutInitWindowPosition( 0, 0);
    glutInitWindowSize( window_width, window_height );
    glutInitDisplayMode( GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH );
    glutCreateWindow( sWindowTitleString );

    // register event handler functions
    glutIdleFunc( 0 );
    glutReshapeFunc( myGLUT_Reshape );
    glutMouseFunc( myGLUT_MouseEvent );
    glutKeyboardFunc( myGLUT_KeyboardEvent );
    glutSpecialFunc( myGLUT_SpecialKeyEvent );
    glutDisplayFunc( myDisplay );
#endif

    // setup model view matrix, GL defaults, and the GL NURBS renderer
    GLUnurbsObj* pTheGLNURBSRender = NULL; // OpenGL NURBS rendering context
    bOK = myInitGL( model.m_view.m_vp, pTheGLNURBSRender );

    if ( bOK ) {
      // build display list
      myBuildDisplayList( glb_display_list_number,
                          pTheGLNURBSRender,
                          model );

      // look at it
#if defined(ON_EXAMPLE_GL_USE_GLAUX)
      auxMainLoop( myDisplay );
#endif

#if defined(ON_EXAMPLE_GL_USE_GLUT)
      glutMainLoop(  );
#endif

    }

    gluDeleteNurbsRenderer( pTheGLNURBSRender );

    break;
  }

  //
  // GL stuff ends here
  //
  ///////////////////////////////////////////////////////////////////

  ON::End();

  return 0;
}

///////////////////////////////////////////////////////////////////////
void SetGLModelViewMatrix( const ON_Viewport& viewport )
{
  ON_GL( viewport ); // updates GL model view matrix
}

void SetGLProjectionMatrix( ON_Viewport& viewport )
{
  int pl, pr, pb, pt;
  viewport.GetScreenPort( &pl, &pr, &pb, &pt, NULL, NULL );
  ON_GL( viewport, pl, pr, pb, pt ); // updates GL projection matrix
}

ON_BOOL32 myInitGL( const ON_Viewport& viewport, GLUnurbsObj*& nobj )
{
  // set the model view transform
  SetGLModelViewMatrix( viewport );

  // this stuff works with MSVC 4.2's Open GL. Changes may be needed for other
  // GLs.
  //ON_Color background_color(0,128,128);
  ON_Color background_color(0,63,127);
  //background_color = glb_model->m_settings.m_RenderSettings.m_background_color;
  glClearColor( (float)background_color.FractionRed(), 
                (float)background_color.FractionGreen(), 
                (float)background_color.FractionBlue(), 
                1.0f
                );

  glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE );
  glDisable( GL_CULL_FACE );
  
  // Rhino viewports have camera "Z" pointing at the camera in a right
  // handed coordinate system.
  glClearDepth( 0.0f );
  glEnable( GL_DEPTH_TEST );
  glDepthFunc( GL_GEQUAL );

  glEnable( GL_LIGHTING );
  glEnable( GL_DITHER );
  //glEnable( GL_AUTO_NORMAL );
  //glEnable( GL_NORMALIZE );

  // default material
  ON_GL( (ON_Material*)NULL );


  // GL rendering of NURBS objects requires a GLUnurbsObj.
  nobj = gluNewNurbsRenderer();
  if ( !nobj )
    return false;
  
  gluNurbsProperty( nobj, GLU_SAMPLING_TOLERANCE,   20.0f );
  gluNurbsProperty( nobj, GLU_PARAMETRIC_TOLERANCE, 0.5f );
  gluNurbsProperty( nobj, GLU_DISPLAY_MODE,         (GLfloat)GLU_FILL );
  //gluNurbsProperty( nobj, GLU_DISPLAY_MODE,         GLU_OUTLINE_POLYGON );
  //gluNurbsProperty( nobj, GLU_DISPLAY_MODE,         GLU_OUTLINE_PATCH );
  gluNurbsProperty( nobj, GLU_SAMPLING_METHOD,      (GLfloat)GLU_PATH_LENGTH );
  //gluNurbsProperty( nobj, GLU_SAMPLING_METHOD,      GLU_PARAMETRIC_ERROR );
  //gluNurbsProperty( nobj, GLU_SAMPLING_METHOD,      GLU_DOMAIN_DISTANCE );
  gluNurbsProperty( nobj, GLU_CULLING,              (GLfloat)GL_FALSE );

  // register GL NURBS error callback
  {
    // hack to get around C vs C++ type checking trauma
    RHINO_GL_NURBS_ERROR fn;
    fn = (RHINO_GL_NURBS_ERROR)myNurbsErrorCallback;
    gluNurbsCallback( nobj, GLU_ERROR, fn );
  }

  return true;
}

///////////////////////////////////////////////////////////////////////

#if defined(ON_EXAMPLE_GL_USE_GLAUX)
void MY_GL_CALLBACK myGLAUX_Reshape( GLsizei w, GLsizei h )
{
  static GLsizei w0 = 0;
  static GLsizei h0 = 0;
  if ( w != w0 || h != h0 ) {
    h0 = h;
    w0 = w;
    ON_GL( glb_model->m_view.m_vp, 0, w-1, h-1, 0 ); // set projection transform
  }
  glViewport( 0, 0, w, h );
}
#endif

#if defined(ON_EXAMPLE_GL_USE_GLUT)
void MY_GL_CALLBACK myGLUT_Reshape( int w, int h )
{
  static int w0 = 0;
  static int h0 = 0;
  if ( w != w0 || h != h0 ) {
    h0 = h;
    w0 = w;
    ON_GL( glb_model->m_view.m_vp, 0, w-1, h-1, 0 ); // set projection transform
  }
  glViewport( 0, 0, w, h );
}
#endif


///////////////////////////////////////////////////////////////////////
static void myRotateView( ON_Viewport& viewport,
                          const ON_3dVector& axis,
                          const ON_3dPoint& center,
                          double angle )
{
  ON_Xform rot;
  ON_3dPoint camLoc;
  ON_3dVector camY, camZ;

  rot.Rotation( angle, axis, center );

  if ( !viewport.GetCameraFrame( camLoc, NULL, camY, camZ ) )
    return;

  camLoc = rot*camLoc;
  camY   = rot*camY;
  camZ   = -(rot*camZ);

  viewport.SetCameraLocation( camLoc );
  viewport.SetCameraDirection( camZ );
  viewport.SetCameraUp( camY );

  ON_GL( viewport ); // update model view
}

static void myRotateLeftRight( ON_Viewport& viewport, double angle )
{
  // ON_3dVector axis = ON_zaxis; // rotate camera about world z axis (z up feel)
  ON_3dVector axis = ON_zaxis; // rotate camera about world y axis (u up feel)
  
  ON_3dPoint center;
  if ( glb_model )
    center = glb_model->m_view.m_target;
  else
    viewport.GetFrustumCenter( center );
  myRotateView( viewport, axis, center, angle );
}

static void myRotateUpDown( ON_Viewport& viewport, double angle )
{
  // rotates camera around the screen x axis
  ON_3dVector camX;
  ON_3dPoint center;
  if ( glb_model )
    center = glb_model->m_view.m_target;
  else
    viewport.GetFrustumCenter( center );
  viewport.GetCameraFrame( NULL, camX, NULL, NULL );
  myRotateView( viewport, camX, center, angle );
}

///////////////////////////////////////////////////////////////////////


void MY_GL_CALLBACK myKeyLeftArrowEvent( void )
{
  myRotateLeftRight( glb_model->m_view.m_vp, ON_PI/12.0 );
}

void MY_GL_CALLBACK myKeyRightArrowEvent( void )
{
  myRotateLeftRight( glb_model->m_view.m_vp, -ON_PI/12.0 );
}

void MY_GL_CALLBACK myKeyUpArrowEvent( void )
{
  myRotateUpDown( glb_model->m_view.m_vp, ON_PI/12.0 );
}

void MY_GL_CALLBACK myKeyDownArrowEvent( void )
{
  myRotateUpDown( glb_model->m_view.m_vp, -ON_PI/12.0 );
}

void MY_GL_CALLBACK myKeyViewExtents( void )
{
  double half_angle = 7.5*ON_PI/180.0;
  glb_model->m_view.m_vp.Extents( half_angle, glb_model->m_bbox );
  SetGLModelViewMatrix( glb_model->m_view.m_vp );
  SetGLProjectionMatrix( glb_model->m_view.m_vp );
}

#if defined(ON_EXAMPLE_GL_USE_GLAUX)

///////////////////////////////////////////////////////////////////////
//
// Mouse event handling
//

static void myGLAUX_MouseEvent( GLint button, const AUX_EVENTREC* event )
{
  static ON_BOOL32 bMouseActive = false;
  static int mx0, my0;
  int mx, my;

  if ( !event ) {
    bMouseActive = false;
    return;
  }

  if ( event->event == AUX_MOUSEDOWN ) {
    if ( bMouseActive ) {
      bMouseActive = false;
      return;
    }
    bMouseActive = true;
    mx0 = event->data[AUX_MOUSEX];
    my0 = event->data[AUX_MOUSEY];
    return;
  }

  if ( !bMouseActive || event->event != AUX_MOUSEUP )
    return;

  mx = event->data[AUX_MOUSEX];
  my = event->data[AUX_MOUSEY];

  switch (button) {
  case AUX_LEFTBUTTON:
    // zoom
    glb_model->m_view.m_vp.ZoomToScreenRect( mx0, my0, mx, my );
    break;
  case AUX_MIDDLEBUTTON:
    break;
  case AUX_RIGHTBUTTON:
    // dolly
    {
      ON_3dVector dolly_vector;
      double d;
      ON_3dPoint camLoc;
      ON_3dVector camZ;
      glb_model->m_view.m_vp.GetCameraFrame( camLoc, NULL, NULL, camZ );
      d = (camLoc-glb_model->m_view.m_target)*camZ;
      if ( glb_model->m_view.m_vp.GetDollyCameraVector(mx0,my0,mx,my,d,dolly_vector) ) {
        glb_model->m_view.m_vp.DollyCamera( dolly_vector );
      }
    }
    break;
  }

  // update GL model view and projection matrices to match viewport changes
  SetGLModelViewMatrix( glb_model->m_view.m_vp );
  SetGLProjectionMatrix( glb_model->m_view.m_vp );

  bMouseActive = false;
}

void MY_GL_CALLBACK myGLAUX_MouseLeftEvent( AUX_EVENTREC* event )
{
  myGLAUX_MouseEvent( AUX_LEFTBUTTON, event );
}

void MY_GL_CALLBACK myGLAUX_MouseMiddleEvent( AUX_EVENTREC* event )
{
  myGLAUX_MouseEvent( AUX_MIDDLEBUTTON, event );
}

void MY_GL_CALLBACK myGLAUX_MouseRightEvent( AUX_EVENTREC* event )
{
  myGLAUX_MouseEvent( AUX_RIGHTBUTTON, event );
}
#endif

#if defined(ON_EXAMPLE_GL_USE_GLUT)

void MY_GL_CALLBACK myGLUT_KeyboardEvent( unsigned char ch, int x, int y )
{
	int m = glutGetModifiers();
	if (m != GLUT_ACTIVE_ALT)
		return;
	if (ch == 'e' || ch == 'z') {
		myKeyViewExtents();
		glutPostRedisplay();
	}
}


void MY_GL_CALLBACK myGLUT_SpecialKeyEvent( int ch, int x, int y )
{
	if (ch == GLUT_KEY_LEFT)
		myKeyLeftArrowEvent();
	if (ch == GLUT_KEY_UP)
		myKeyUpArrowEvent();
	if (ch == GLUT_KEY_RIGHT)
		myKeyRightArrowEvent();
	if (ch == GLUT_KEY_DOWN)
		myKeyDownArrowEvent();
	glutPostRedisplay();
}

void myGLUT_MouseEvent( int button, int state, int x, int y )
{
	static int mx0, my0;
	static int mButton;

	if ( state == GLUT_DOWN ) {
		switch (button) {
		case GLUT_LEFT_BUTTON:
		case GLUT_MIDDLE_BUTTON:
		case GLUT_RIGHT_BUTTON:
			mButton = button;
			mx0 = x;
			my0 = y;
			break;
		}
	}

	if ( state == GLUT_UP && button == mButton ) {
		switch (mButton) {
		case GLUT_LEFT_BUTTON:
			// zoom
			glb_model->m_view.m_vp.ZoomToScreenRect( mx0, my0, x, y );
			break;
		case GLUT_MIDDLE_BUTTON:
			break;
		case GLUT_RIGHT_BUTTON:
			// dolly
			{
				ON_3dVector dolly_vector;
				double d;
				ON_3dPoint camLoc;
				ON_3dVector camZ;
				glb_model->m_view.m_vp.GetCameraFrame( camLoc, NULL, NULL, camZ );
				d = (camLoc-glb_model->m_view.m_target)*camZ;
				if ( glb_model->m_view.m_vp.GetDollyCameraVector(mx0,my0,x,y,d,dolly_vector) ) {
					glb_model->m_view.m_vp.DollyCamera( dolly_vector );
				}
			}
			break;
		}

		// update GL model view and projection matrices to match viewport changes
		SetGLModelViewMatrix( glb_model->m_view.m_vp );
		SetGLProjectionMatrix( glb_model->m_view.m_vp );
		glutPostRedisplay();
	}
}

#endif


///////////////////////////////////////////////////////////////////////

void myDisplayObject( const ON_Object& geometry, const ON_Material& material, GLUnurbsObj* nobj )
{
  // Called from myDisplay() to show geometry.
  // Uses ON_GL() functions found in rhinoio_gl.cpp.
  const ON_Point* point=0;
  const ON_PointCloud* cloud=0;
  const ON_Brep* brep=0;
  const ON_Mesh* mesh=0;
  const ON_Curve* curve=0;
  const ON_Surface* surface=0;

  // specify rendering material
  ON_GL( material );

  brep = ON_Brep::Cast(&geometry);
  if ( brep ) 
  {
    ON_GL(*brep, nobj);
    return;
  }

  mesh = ON_Mesh::Cast(&geometry);
  if ( mesh ) 
  {
    ON_GL(*mesh);
    return;
  }

  curve = ON_Curve::Cast(&geometry);
  if ( curve ) 
  {
    ON_GL( *curve, nobj );
    return;
  }

  surface = ON_Surface::Cast(&geometry);
  if ( surface ) 
  {
    gluBeginSurface( nobj );
    ON_GL( *surface, nobj );
    gluEndSurface( nobj );
    return;
  }

  point = ON_Point::Cast(&geometry);
  if ( point ) 
  {
    ON_GL(*point);
    return;
  }

  cloud = ON_PointCloud::Cast(&geometry);
  if ( cloud ) 
  {
    ON_GL(*cloud);
    return;
  }

}

///////////////////////////////////////////////////////////////////////

void MY_GL_CALLBACK myDisplayLighting( const ON_Viewport&, // viewport, // unreferenced
                                       const CModel& model
                                     )
{
  int light_count = model.m_light_table.Count();
  if ( light_count > 0 ) {
    int maxlighti = light_count;
    if ( maxlighti > GL_MAX_LIGHTS )
      maxlighti = GL_MAX_LIGHTS;
    int lighti;
    for ( lighti = 0; lighti < maxlighti; lighti++ ) {
      ON_GL( model.m_light_table[lighti].m_light, lighti+GL_LIGHT0 );
    }
  }
  else {
    // use default headlight
    // use basic bright white head light with a bit of ambient
    ON_Light head_light;
    head_light.Default();
    ON_GL( head_light, GL_LIGHT0 );
  }
}

///////////////////////////////////////////////////////////////////////

#if defined(MY_USE_WINDOWS_STUFF)
static void myDrawAxesSprite( const ON_Viewport& viewport, HDC hdc )
{
  // Use simple Windows calls to draw world axes sprite in lower left corner.
  // Note that Windows has screen (0,0) in the upper left corner; i.e,
  // screen "y" increases downwards.
  if ( !hdc )
    return;
  const int axes_size = 30;

  int port_left, port_right, port_top, port_bottom;
  if ( !viewport.GetScreenPort( &port_left, &port_right, &port_bottom, &port_top, NULL, NULL ) )
    return;
  const int scr_width  = port_right - port_left; // no "+1" here
  const int scr_height = port_bottom - port_top; // no "+1" here

  if (4*axes_size >= scr_width )
    return;
  if (4*axes_size >= scr_height )
    return;

  int x0 = 3*axes_size/2;
  int y0 = port_bottom - 3*axes_size/2;
  int indx[3] = {0,1,2};
  double scr_coord[3][2];
  viewport.GetCoordinateSprite( axes_size, x0, y0, indx, scr_coord );

#define LXSIZE 3
#define LYSIZE 3
#define LOFF 3

  // draw 3 axes from back to front
  HPEN axis_pen[3];
  axis_pen[0] = CreatePen( PS_SOLID, 2, RGB(255,0,0) );
  axis_pen[1] = CreatePen( PS_SOLID, 2, RGB(0,255,0) );
  axis_pen[2] = CreatePen( PS_SOLID, 2, RGB(0,0,255) );
  HGDIOBJ saved_pen = SelectObject( hdc, axis_pen[0] );

  int i, k, x, y, lx, ly;
  for (i=0;i<3;i++) {
    k = indx[i];
    x = (int)scr_coord[k][0];
    y = (int)scr_coord[k][1];
    // use direction of screen vector to determine letter placement
    lx = x-x0; ly = y-y0;
    if (abs(lx) > abs(ly)) {
      // center letter to right/left of axis end
      lx = (x >= x0) ? x + LXSIZE+LOFF : x - LXSIZE-LOFF;
      ly = y;
    }
    else if (abs(ly) > abs(lx)) {
      // center letter above/below axis end
      lx = x;
      ly = (y >= y0) ? y + LYSIZE+LOFF : y - LYSIZE-LOFF;
    }
    else if (lx) {
      // diagonal axis - center letter on axis
      lx = (x >= x0) ? x + LXSIZE+LOFF : x - LXSIZE-LOFF;
      ly = (y >= y0) ? y + LYSIZE+LOFF : y - LYSIZE-LOFF;
    }
    else {
      // axis is perp to screen - center letter at axis end
      lx = x;
      ly = y;
    }
    SelectObject( hdc, axis_pen[k] );

    // draw axis
    MoveToEx( hdc, x0, y0, NULL );
    LineTo( hdc, x, y );

    // draw axis label
    switch (k) {
    case 0: // X
      MoveToEx( hdc, lx-LXSIZE, ly-LYSIZE, NULL );
      LineTo(   hdc, lx+LXSIZE, ly+LYSIZE );
      MoveToEx( hdc, lx-LXSIZE, ly+LYSIZE, NULL );
      LineTo(   hdc, lx+LXSIZE, ly-LYSIZE );
      break;
    case 1: // Y
      MoveToEx( hdc, lx-LXSIZE, ly-LYSIZE, NULL );
      LineTo(   hdc, lx,    ly    );
      LineTo(   hdc, lx+LXSIZE, ly-LYSIZE );
      MoveToEx( hdc, lx,    ly, NULL    );
      LineTo(   hdc, lx,    ly+LYSIZE );
      break;
    case 2: // Z
      MoveToEx( hdc, lx-LXSIZE, ly-LYSIZE, NULL );
      LineTo(   hdc, lx+LXSIZE, ly-LYSIZE );
      LineTo(   hdc, lx-LXSIZE, ly+LYSIZE );
      LineTo(   hdc, lx+LXSIZE, ly+LYSIZE );
      break;
    }

  }
  SelectObject( hdc, saved_pen );
  DeleteObject( axis_pen[0] );
  DeleteObject( axis_pen[1] );
  DeleteObject( axis_pen[2] );

#undef LXSIZE
#undef LYSIZE
#undef LOFF

}
#endif

///////////////////////////////////////////////////////////////////////

void myBuildDisplayList( GLuint display_list_number,
                         GLUnurbsObj* pTheGLNurbsRender,
                         const CModel& model
                         )
{
  ON_Material material;
  glNewList( display_list_number, GL_COMPILE );

  // display Rhino geometry using ON_GL() functions found in rhinoio_gl.cpp
  int i;
  const int object_count = model.m_object_table.Count();
  for ( i = 0; i < object_count; i++ ) 
  {
    const ONX_Model_Object& mo = model.m_object_table[i];
    if ( 0 != mo.m_object )
    {
      model.GetObjectMaterial( i, material );
      myDisplayObject( *mo.m_object, material, pTheGLNurbsRender );
    }
  }

  glEndList();
}

///////////////////////////////////////////////////////////////////////

void MY_GL_CALLBACK myDisplay( void )
{
  // Uses globals glb_* because the GL aux tools don't provide an
  // easy way to pass information into this callback.
  int bUseRhinoSpotlights = false; // I like to use a simple headlight
                                   // for a basic preview.

  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

  // lights
  if ( bUseRhinoSpotlights && glb_model ) {
    // Rhino spotlights (currently rotate along with geometry)
    myDisplayLighting( glb_model->m_view.m_vp, *glb_model );
  }
  else {
    // simple bright white headlight
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();
    GLfloat pos[4]  = { (GLfloat)0.0, (GLfloat)0.0, (GLfloat)1.0, (GLfloat)0.0 };
    glLightfv( GL_LIGHT0, GL_POSITION,  pos );
    GLfloat black[4] = { (GLfloat)0.0, (GLfloat)0.0, (GLfloat)0.0, (GLfloat)1.0 };
    GLfloat white[4] = { (GLfloat)1.0, (GLfloat)1.0, (GLfloat)1.0, (GLfloat)1.0 };
    glLightfv( GL_LIGHT0, GL_AMBIENT,  black );
    glLightfv( GL_LIGHT0, GL_DIFFUSE,  white );
    glLightfv( GL_LIGHT0, GL_SPECULAR, white );
    glEnable( GL_LIGHT0 );
    glPopMatrix();
  }

  // display list built with myBuildDisplayList()
  glCallList( glb_display_list_number ); 

  glFlush();

#if defined(MY_USE_WINDOWS_STUFF)
  // Windows decorations
  myDrawAxesSprite( glb_model->m_view.m_vp, wglGetCurrentDC() );
#endif
}

///////////////////////////////////////////////////////////////////////

void MY_GL_CALLBACK myNurbsErrorCallback( GLenum errCode )
{
  const GLubyte* s = gluErrorString( errCode );
  printf("GL NURBS ERROR: (%d) %s\n",errCode, s );
}

///////////////////////////////////////////////////////////////////////
blob
data 3577
/* $Header$ */
/* $NoKeywords: $ */
//
// Copyright (c) 1993-1998 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
////////////////////////////////////////////////////////////////
//
//  example_read.cpp  
// 
//  Example program using the Rhino file IO toolkit.  The program reads in  
//  a Rhino 3dm model file and describes its contents.  The program is a 
//  console application that takes a filename as a command line argument.
//
////////////////////////////////////////////////////////////////////////

#include "../opennurbs.h"
#include "../opennurbs_staticlib_linking_pragmas.h"

int main( int argc, const char *argv[] )
{
  // If you are using OpenNURBS as a Windows DLL, then you MUST use
  // ON::OpenFile() to open the file.  If you are not using OpenNURBS
  // as a Windows DLL, then you may use either ON::OpenFile() or fopen()
  // to open the file.

  int argi;
  if ( argc < 2 ) 
  {
    printf("Syntax: %s [-out:outputfilename.txt] file1.3dm file2.3dm ...\n",argv[0] );
    return 0;
  }

  // Call once in your application to initialze opennurbs library
  ON::Begin();

  // default dump is to stdout
  ON_TextLog dump_to_stdout;
  ON_TextLog* dump = &dump_to_stdout;
  FILE* dump_fp = 0;

  ONX_Model model;

  bool bVerboseTextDump = true;

  for ( argi = 1; argi < argc; argi++ ) 
  {
    const char* arg = argv[argi];

    // check for -out or /out option
    if ( ( 0 == strncmp(arg,"-out:",5) || 0 == strncmp(arg,"/out:",5) ) 
         && arg[5] )
    {
      // change destination of dump file
      const char* sDumpFilename = arg+5;
      FILE* text_fp = ON::OpenFile(sDumpFilename,"w");
      if ( text_fp )
      {
        if ( dump_fp )
        {
          delete dump;
          ON::CloseFile(dump_fp);
        }
        dump_fp = text_fp;
        dump = new ON_TextLog(dump_fp);
      }
      continue;
    }

    const char* sFileName = arg;

    dump->Print("\nOpenNURBS Archive File:  %s\n", sFileName );

    // open file containing opennurbs archive
    FILE* archive_fp = ON::OpenFile( sFileName, "rb");
    if ( !archive_fp ) 
    {
      dump->Print("  Unable to open file.\n" );
      continue;
    }

    dump->PushIndent();

    // create achive object from file pointer
    ON_BinaryFile archive( ON::read3dm, archive_fp );

    // read the contents of the file into "model"
    bool rc = model.Read( archive, dump );

    // close the file
    ON::CloseFile( archive_fp );

    // print diagnostic
    if ( rc )
      dump->Print("Successfully read.\n");
    else
      dump->Print("Errors during reading.\n");

    // see if everything is in good shape
    if ( model.IsValid(dump) )
      dump->Print("Model is valid.\n");
    else
      dump->Print("Model is not valid.\n");

    // create a text dump of the model
    if ( bVerboseTextDump )
    {
      dump->PushIndent();
      model.Dump(*dump);
      dump->PopIndent();
    }

    // destroy this model
    model.Destroy();

    dump->PopIndent();
  }

  if ( dump_fp )
  {
    // close the text dump file
    delete dump;
    ON::CloseFile( dump_fp );
  }
  
  // OPTIONAL: Call just before your application exits to clean
  //           up opennurbs class definition information.
  //           Opennurbs will not work correctly after ON::End()
  //           is called.
  ON::End();

  return 0;
}

blob
data 4277
#include "../opennurbs.h"
#include "../opennurbs_staticlib_linking_pragmas.h"

int main( int argc, const char *argv[] )
{
  // If you are using OpenNURBS as a Windows DLL, then you MUST use
  // ON::OpenFile() to open the file.  If you are not using OpenNURBS
  // as a Windows DLL, then you may use either ON::OpenFile() or fopen()
  // to open the file.

  int argi;
  if ( argc < 2 ) 
  {
    printf("Syntax: %s [-out:outputfilename.txt] file1.3dm file2.3dm ...\n",argv[0] );
    return 0;
  }

  // Call once in your application to initialze opennurbs library
  ON::Begin();

  // default dump is to stdout
  ON_TextLog dump_to_stdout;
  ON_TextLog* dump = &dump_to_stdout;
  FILE* dump_fp = 0;

  ONX_Model model;

  for ( argi = 1; argi < argc; argi++ ) 
  {
    const char* arg = argv[argi];

    // check for -out or /out option
    if ( ( 0 == strncmp(arg,"-out:",5) || 0 == strncmp(arg,"/out:",5) ) 
         && arg[5] )
    {
      // change destination of dump file
      const char* sDumpFilename = arg+5;
      FILE* text_fp = ON::OpenFile(sDumpFilename,"w");
      if ( text_fp )
      {
        if ( dump_fp )
        {
          delete dump;
          ON::CloseFile(dump_fp);
        }
        dump_fp = text_fp;
        dump = new ON_TextLog(dump_fp);
      }
      continue;
    }

    const char* sFileName = arg;

    dump->Print("\nOpenNURBS Archive File:  %s\n", sFileName );

    // open file containing opennurbs archive
    FILE* archive_fp = ON::OpenFile( sFileName, "rb");
    if ( !archive_fp ) 
    {
      dump->Print("  Unable to open file.\n" );
      continue;
    }

    dump->PushIndent();

    // create achive object from file pointer
    ON_BinaryFile archive( ON::read3dm, archive_fp );

    // read the contents of the file into "model"
    bool rc = model.Read( archive, dump );

    // close the file
    ON::CloseFile( archive_fp );

    // print diagnostic
    if ( rc )
      dump->Print("Successfully read.\n");
    else
      dump->Print("Errors during reading.\n");

    // see if everything is in good shape
    if ( model.IsValid(dump) )
      dump->Print("Model is valid.\n");
    else
    {
      model.Polish();
      if ( model.IsValid() )
      {
        dump->Print("Model is valid after calling Polish().\n");
      }
      else
      {
        dump->Print("Model is not valid.\n");
      }
    }

    /*
    int oi = 14;
    if ( oi >=0 && oi < model.m_object_table.Count() )
    {
      dump->Print("m_object_table[%d].m_object:\n",oi);
      dump->PushIndent();
      model.m_object_table[oi].m_object->Dump(*dump);
      dump->PopIndent();
    }
    */

    // create a text dump of the model
    int version = 4; // File can be read by Rhino 4 and Rhino 5
    //int version = 5; // File can be read by Rhino 5

    ON_String outfile = sFileName;
    int len = outfile.Length() - 4;
    outfile.SetLength(len);
    outfile += "_roundtrip.3dm";
    bool outrc = model.Write( outfile, version, "roundtrip", dump );
    if ( outrc )
    {
      dump->Print("model.Write(%s) succeeded.\n",outfile.Array());
      ONX_Model model2;
      if ( model2.Read( outfile, dump ) )
      {
        dump->Print("model2.Read(%s) succeeded.\n",outfile.Array());
        if ( model2.IsValid(dump) )
        {
          dump->Print("Model2 is valid.\n");
        }
        else
        {
          dump->Print("Model2 is not valid.\n");
        }
        /*
        if ( oi >=0 && oi < model2.m_object_table.Count() )
        {
          dump->Print("m_object_table[%d].m_object:\n",oi);
          dump->PushIndent();
          model2.m_object_table[oi].m_object->Dump(*dump);
          dump->PopIndent();
        }
        */
      }
      else
      {
        dump->Print("model2.Read(%s) failed.\n",outfile.Array());
      }
    }
    else
      dump->Print("model.Write(%s) failed.\n",outfile.Array());

    // destroy this model
    model.Destroy();

    dump->PopIndent();
  }

  if ( dump_fp )
  {
    // close the text dump file
    delete dump;
    ON::CloseFile( dump_fp );
  }
  
  // OPTIONAL: Call just before your application exits to clean
  //           up opennurbs class definition information.
  //           Opennurbs will not work correctly after ON::End()
  //           is called.
  ON::End();

  return 0;
}

blob
data 2006
#include "../opennurbs.h"
#include "example_ud.h"

CExampleWriteUserData::CExampleWriteUserData()
{
  m_sn = ++m__sn;
  m_userdata_uuid = Id();
  m_userdata_copycount = 1;
}

// {2532FB4A-DED9-4600-B6A4-1568504B66A5}
static const ON_UUID ExampleWriteUserData_Id = 
{ 0x2532fb4a, 0xded9, 0x4600, { 0xb6, 0xa4, 0x15, 0x68, 0x50, 0x4b, 0x66, 0xa5 } };

CExampleWriteUserData::CExampleWriteUserData( const char* s)
{
  m_sn = ++m__sn;
  m_userdata_uuid = Id();
  m_application_uuid = ExampleWriteUserData_Id;
  m_userdata_copycount = 1;
  m_str = s;
}

CExampleWriteUserData::CExampleWriteUserData(const CExampleWriteUserData& src) : ON_UserData(src), m_str(src.m_str)
{
  m_sn = ++m__sn;
}

CExampleWriteUserData& CExampleWriteUserData::operator=(const CExampleWriteUserData& src)
{
  if ( this != &src )
  {
    ON_UserData::operator=(src);
    m_str = src.m_str;
  }
  return *this;
}

CExampleWriteUserData::~CExampleWriteUserData()
{
  m_sn = -abs(m_sn);
}

void CExampleWriteUserData::Dump( ON_TextLog& text_log ) const
{
  ON_UserData::Dump(text_log);
  text_log.PushIndent();
  const wchar_t* s = m_str;
  if ( 0 == s ) 
    s = L"";
  text_log.Print("m_str: %S\n",s);
  text_log.Print("m_sn: %d\n",m_sn);
  text_log.PopIndent();
}

ON_BOOL32 CExampleWriteUserData::GetDescription( ON_wString& description )
{
  description = L"example_write.exe user data";
  return true;
}


ON_BOOL32 CExampleWriteUserData::Archive() const
{
  return true;
}

ON_BOOL32 CExampleWriteUserData::Write(ON_BinaryArchive& file) const
{
  return file.WriteString(m_str);
}

ON_BOOL32 CExampleWriteUserData::Read(ON_BinaryArchive& file)
{
  return file.ReadString(m_str);
}

int CExampleWriteUserData::m__sn = 0;

ON_OBJECT_IMPLEMENT(CExampleWriteUserData,ON_UserData,"DADD17C5-706D-44ea-9B13-7D9D2C56D085");

ON_UUID CExampleWriteUserData::Id()
{
  // {6FC7CDF1-751E-4fa0-9D86-73E84D416DD7}
  static const ON_UUID id = 
  { 0x6fc7cdf1, 0x751e, 0x4fa0, { 0x9d, 0x86, 0x73, 0xe8, 0x4d, 0x41, 0x6d, 0xd7 } };
  return id;
}

blob
data 8508
#include "../opennurbs.h"
#include "../opennurbs_staticlib_linking_pragmas.h"

// This example demonstrates how to attach customized "user data"
// to any class derived from ON_Object.  In particular, you can
// attach custom information to any piece of geometry in a 3DM
// file and have it persist in files, transform, and copy.

class MyUserData : public ON_UserData
{
  ON_OBJECT_DECLARE(MyUserData);

public:
  // Note well:
  // 1) All constructors must initialize ON_UserData::m_userdata_uuid to
  //    the UUID that identifies this kind of user data.  
  // 2) All constructors must initialize ON_UserData::m_copy_count to
  //    1 if the user data should be copied when the parent object is
  //    copied.
  // For more details, see comments in the constructor code below.
  MyUserData();
  MyUserData(const MyUserData&);

  MyUserData& operator=(const MyUserData&);
  ~MyUserData();

  // In order to get your user data to persist in files, you must
  // override ON_UserData::Archive(), ON_Object::Write() and 
  // ON_Object::Read()

  ON_BOOL32 Write(
         ON_BinaryArchive&  // serialize definition to binary archive
       ) const;

  ON_BOOL32 Read(
         ON_BinaryArchive&  // restore definition from binary archive
       );

  // Archive() must return true in order for user data to get saved
  // in a file.
  ON_BOOL32 Archive() const;
  
  // You must override ON_UserData::GetDescription().
  ON_BOOL32 GetDescription( ON_wString& );

  // If your user data is attached to some type of ON_Geometry and you
  // want the user data to be transformed when the parent ON_Geometry
  // is transformed, then you must override ON_UserData::Transform().
  //
  // If you don't override ON_UserData::Transform(), then the net
  // result of any transforms is stored in ON_UserData::m_userdata_xform.
  // At appropriate times, you can inspect ON_UserData::m_userdata_xform
  // and reset it to the identity after you've taken whatever actions
  // you deem to be appropriate.
  ON_BOOL32 Transform( const ON_Xform& );

  // possible information you might want to attach.
  int       m_my_int;
  ON_Line   m_my_line;
  ON_String m_my_string;
};

ON_OBJECT_IMPLEMENT( MyUserData, ON_UserData, "53114529-1CD7-4872-818E-311CB19101FA" );

// {D11E26D2-9A77-4a2f-AEC8-4498F2EABBA1}
static const ON_UUID my_application_id = 
{ 0xd11e26d2, 0x9a77, 0x4a2f, { 0xae, 0xc8, 0x44, 0x98, 0xf2, 0xea, 0xbb, 0xa1 } };

MyUserData::MyUserData()
{
  // Each kind of user data needs a uuid and your constructors MUST
  // initialize ON_UserData::m_userdata_uuid with the value of this
  // uuid.  The value of ON_UserData::m_userdata_uuid uuid is used to
  // identify the user data and is passed to ON_Object::GetUserData()
  // when an application wants to access user data that has been
  // attached to an object.
  //
  // In simple cases, the class UUID can be used as is shown below.
  m_userdata_uuid = MyUserData::m_MyUserData_class_id.Uuid();

  // In order for user data to be saved in 3dm files, it must have
  // a non-nil application id.
  m_application_uuid = my_application_id;

  // If you want your user data to be copied when its parent ON_Object
  // is copied, then your constructor must initialize 
  // ON_UserData::m_userdata_copycount to 1.
  // By default, ON_UserData::m_userdata_copycount is zero and the
  // user data is not copied.  See the comments in the ON_UserData
  // class definition for more details.
  m_userdata_copycount = 1;

  m_my_int = 0;
}

MyUserData::MyUserData(const MyUserData& src) 
          : ON_UserData(src) // critical - be sure to call base class copy constructor
{
  // The base class copy constructor copies
  // m_userdata_uuid, m_application_id, m_userdata_copycount, 
  // and m_userdata_xform.  Then if m_userdata_copycount is
  // not zero, it is incremented.

  m_my_int = src.m_my_int;
  m_my_line = src.m_my_line;
  m_my_string = src.m_my_string;
}

MyUserData& MyUserData::operator=(const MyUserData& src)
{
  if ( this != &src ) {
    // critical - be sure to call base class operator=()
    ON_UserData::operator=(src);
    
    m_my_int = src.m_my_int;
    m_my_line = src.m_my_line;
    m_my_string = src.m_my_string;
  }
  return *this;
}

MyUserData::~MyUserData()
{
}

ON_BOOL32 MyUserData::Archive() const
{
  return true;
}


ON_BOOL32 MyUserData::Read( ON_BinaryArchive& file )
{
  ON_BOOL32 rc = true;
  if ( rc ) 
    rc = file.ReadInt(&m_my_int);
  if ( rc ) 
    rc = file.ReadLine(m_my_line);
  if ( rc ) 
    rc = file.ReadString(m_my_string);
  return rc;
}

ON_BOOL32 MyUserData::Write( ON_BinaryArchive& file ) const
{
  ON_BOOL32 rc = true;
  if ( rc ) 
    rc = file.WriteInt(m_my_int);
  if ( rc ) 
    rc = file.WriteLine(m_my_line);
  if ( rc ) 
    rc = file.WriteString(m_my_string);
  return rc;
}

ON_BOOL32 MyUserData::GetDescription( ON_wString& s )
{
  s = L"my user data with point, line, and string";
  return true;
}

ON_BOOL32 MyUserData::Transform( const ON_Xform& xform )
{
  // Optional: call the ON_UserData::Transform() if you want the
  // ON_UserData::m_userdata_xform value to be updated.
  ON_UserData::Transform(xform);


  // Transform any geometry you have in your class.
  ON_BOOL32 rc = m_my_line.Transform(xform);
  return rc;
}

static void write_file( const char* filename, const ON_Point& point )
{
  ONX_Model model;

  ONX_Model_Object& mo = model.m_object_table.AppendNew();
  mo.m_object = &point;
  mo.m_bDeleteObject = false;

  int version = 4; // File can be read by Rhino 4 and Rhino 5
  //int version = 5; // File can be read by Rhino 5

  model.Polish();
  model.Write( filename, version, "example_userdata.cpp file" );
}

static void read_file( const char* filename, ON_Object*& pObject )
{
  // see example_read.cpp for information about read 3dm files
  // This code will only read the file created by write_file().
  // This code should not be used as a model for reading general 3dm files.


  ONX_Model model;
  model.Read( filename );

  if ( model.m_object_table.Count() > 0 )
  {
    pObject = const_cast<ON_Object*>(model.m_object_table[0].m_object);
    model.m_object_table[0].m_object = 0; // so ~ONX_Model will not delete object
  }

}


int main()
{
  ON::Begin();

  // uuid used to get user data via ON_Object::GetUserData()
  const ON_UUID my_user_data_uuid = MyUserData::m_MyUserData_class_id.Uuid();

  // We'll attach a MyUserData user data to a point.  In general,
  // you can attach user data to any class derived from ON_Object.
  ON_Point point(0.0,0.0,0.0);

  // User data must be created by a call to new
  MyUserData* ud = new MyUserData();
  ud->m_my_int = 1;
  ud->m_my_line.from.Set(0.0,0.0,0.0);
  ud->m_my_line.to.Set(1.0,1.0,1.0);
  ud->m_my_string = "my user data";

  // This attaches the user data to point.  When the point is destroied,
  // the user data will be destroyed.  
  //
  point.AttachUserData(ud);

  // Use ON_Object::GetUserData() to get user data.
  MyUserData* original_ud = MyUserData::Cast( point.GetUserData( my_user_data_uuid ) );

  printf("original_ud->m_userdata_copycount = %d\n",original_ud->m_userdata_copycount);

  // When the point is copied, the user data will be copied if 
  // ud->m_userdata_copycount > 0.
  //
  ON_Point copy_of_point = point;

  // Use ON_Object::GetUserData() to get user data.
  MyUserData* copy_of_ud = MyUserData::Cast( copy_of_point.GetUserData( my_user_data_uuid ) );

  if ( 0 == copy_of_ud )
    printf("ON_UserData::m_copy_count must be > 0 for user data to be copied.\n");
  else
    printf("copy_of_ud->m_userdata_copycount = %d\n",copy_of_ud->m_userdata_copycount);

  // When the point is transformed, the virtual ON_UserData::Transform()
  // is called to transform the point.


  // When the point is saved to a file, the virtual ON_Object::Write() is
  // called to write the attached user data.
  const char* filename = "point_with_user_Data.3dm";
  write_file( filename, point );

  // When the point is read from a file, the virtual ON_Object::Read() is
  // called to read the user data.
  ON_Object* object_from_file = 0;
  read_file( filename, object_from_file );

  if ( 0 != object_from_file )
  {
    // Use ON_Object::GetUserData() to get user data.
    MyUserData* ud_from_file = MyUserData::Cast( object_from_file->GetUserData( my_user_data_uuid ) );

    printf("ud_from_file->m_userdata_copycount = %d\n",ud_from_file->m_userdata_copycount);

    // Clean up
    delete object_from_file;
    object_from_file = 0;
  }

  ON::End();

  return 0;
}
blob
data 44041
/* $Header$ */
/* $NoKeywords: $ */
//
// Copyright (c) 1993-2000 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Assoicates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
////////////////////////////////////////////////////////////////


#include "../opennurbs.h"
#include "../opennurbs_staticlib_linking_pragmas.h"

#include "../example_userdata/example_ud.h"

static bool write_simple_file_example(
            FILE* fp,
            int version,
            ON_TextLog& error_log,
            const char* sNotes,
            const ON_3dmSettings* settings,
            int material_count, const ON_Material* material,  // optional rendering material
            int layer_count,    const ON_Layer* layer,        // optional layer definitions
            int light_count,
            const ON_3dmObjectAttributes* light_attributes, // optional light attributes
            ON_Light*                     light,            // lights
            int object_count,
            const ON_3dmObjectAttributes* object_attributes, // optional object attributes
            ON_Object**                   object      // objects
            )
{
  ONX_Model model;
  int i;
  ON_3dmObjectAttributes attribs;


  // some notes
  model.m_properties.m_Notes.m_notes = sNotes;
  model.m_properties.m_Notes.m_bVisible = (model.m_properties.m_Notes.m_notes.Length() > 0);

  // set revision history information
  model.m_properties.m_RevisionHistory.NewRevision();
  
  // set application information
  model.m_properties.m_Application.m_application_name = "OpenNURBS write_simple_file_example() function";
  model.m_properties.m_Application.m_application_URL = "http://www.opennurbs.org";
  model.m_properties.m_Application.m_application_details = "Example program in OpenNURBS toolkit.";


  if ( 0 != settings )
    model.m_settings = *settings;

  if ( 0 != material && material_count > 0 )
  {
    model.m_material_table.Reserve(material_count);
    for ( i = 0; i < material_count; i++ )
      model.m_material_table.Append(material[i]);
  }

  // layer table
  {
    // Each object in the object table (written below)
    // should to be on a defined layer.  There should be
    // at least one layer with layer index 0 in every file.

    // layer table indices begin at 0
    ON_Layer default_layer;
    default_layer.SetLayerIndex(0);
    default_layer.SetLayerName("Default");
    if ( 0 == layer || layer_count <= 0 || layer[0].LayerIndex() != 0 ) {
      layer = &default_layer;
      layer_count = 1;
    }

    model.m_layer_table.Reserve(layer_count);
    for ( i = 0; i < layer_count; i++ ) 
    {
      // check that layer index is correct
      if ( layer[i].LayerIndex() != i ) 
      {
        error_log.Print("error: layer[%d].LayerIndex() == %d\n",i,layer[i].LayerIndex());
        layer_count = i;
        break;
      }
      // check that layer's material index is correct
      if (    layer[i].RenderMaterialIndex() < -1 
           || layer[i].RenderMaterialIndex() >= material_count ) 
      {
        error_log.Print("error: layer[%d].RenderMaterialIndex() == %d\n",i,layer[i].RenderMaterialIndex());
        layer_count = i;
        break;
      }
      model.m_layer_table.Append(layer[i]);
    }
  }

  if ( 0 != light && light_count > 0 )
  {
    for ( i = 0; i < light_count; i++ ) 
    {
      ONX_Model_RenderLight& mrl = model.m_light_table.AppendNew();
      mrl.m_light = light[i];
      if ( light_attributes )
        mrl.m_attributes = light_attributes[i];
    }
  }

  if ( 0 != object && object_count > 0 )
  {
    for ( i = 0; i < object_count; i++ ) 
    {
      // get object attributes and make sure layer and material indices are legit
      if ( object[i] ) 
      {
        ONX_Model_Object& mo = model.m_object_table.AppendNew();
        mo.m_object = object[i];
        mo.m_bDeleteObject = false;
        if ( object_attributes )
          mo.m_attributes = object_attributes[i];
      }
    }
  }

  // archive to write to
  ON_BinaryFile archive( ON::write3dm, fp );

  // Set uuid's, indices, etc.
  model.Polish();
  // writes model to archive
  bool ok = model.Write( archive,
                         version, 
                         __FILE__ " write_simple_file_example() " __DATE__, 
                         &error_log );

  return ok;
}

static bool write_points_example( FILE* fp, int version, ON_TextLog& error_log  )
{
  // example demonstrates how to write a singe points and point clouds
  ONX_Model model;


  // file properties (notes, preview image, revision history, ...)
  {
    // set revision history information
    model.m_properties.m_RevisionHistory.NewRevision();
    
    // set application information
    model.m_properties.m_Application.m_application_name = "OpenNURBS write_points_example() function";
    model.m_properties.m_Application.m_application_URL = "http://www.opennurbs.org";
    model.m_properties.m_Application.m_application_details = "Example program in OpenNURBS toolkit.";

    {
      // OPTIONAL - add some notes
      model.m_properties.m_Notes.m_notes = "This file was made with the OpenNURBS write_points_example() function.";
      model.m_properties.m_Notes.m_bVisible = true;
    }
  }

  // file settings (units, tolerances, views, ...)
  {
    // OPTIONAL - change values from defaults
    model.m_settings.m_ModelUnitsAndTolerances.m_unit_system = ON::meters;
    model.m_settings.m_ModelUnitsAndTolerances.m_absolute_tolerance = 0.01;
    model.m_settings.m_ModelUnitsAndTolerances.m_angle_tolerance = ON_PI/180.0; // radians
    model.m_settings.m_ModelUnitsAndTolerances.m_relative_tolerance = 0.01; // 1%
  }

  // layer table
  {
    // define some layers
    ON_Layer layer[3];

    layer[0].SetLayerName("Default");
    layer[0].SetVisible(true);
    layer[0].SetLocked(false);
    layer[0].SetLayerIndex(0);
    layer[0].SetColor( ON_Color(0,0,0) );

    layer[1].SetLayerName("red points");
    layer[1].SetVisible(true);
    layer[1].SetLocked(false);
    layer[1].SetLayerIndex(1);
    layer[1].SetColor( ON_Color(255,0,0) );

    layer[2].SetLayerName("one blue point");
    layer[2].SetVisible(true);
    layer[2].SetLocked(false);
    layer[2].SetLayerIndex(2);
    layer[2].SetColor( ON_Color(0,0,255) );

    model.m_layer_table.Append(layer[0]);
    model.m_layer_table.Append(layer[1]);
    model.m_layer_table.Append(layer[2]);
  }

  // group table
  {
    // we'll put 2 red and one blue point in a group
    ON_Group group;
    group.SetGroupName("group of points");
    group.SetGroupIndex(0);
    model.m_group_table.Append(group);
  }

  // object table

  // single point at (1,4,5) on default layer
  ON_Point point1(ON_3dPoint( 1.0, 4.0, 5.0 ));
  point1.AttachUserData( new CExampleWriteUserData("write_points_example()-point1") );
  {
    ONX_Model_Object& mo = model.m_object_table.AppendNew();
    mo.m_object = &point1;
    mo.m_bDeleteObject = false; // point1 is on the stack
    mo.m_attributes.m_layer_index = 0;
    mo.m_attributes.m_name = "first point";
  }

  // point "cloud" with 3 points on red point cloud layer
  ON_PointCloud* pointcloud = new ON_PointCloud();
  pointcloud->AppendPoint(ON_3dPoint( 1.0, 6.0, 5.0 ));
  pointcloud->AppendPoint(ON_3dPoint( 1.5, 4.5, 6.0 ));
  pointcloud->AppendPoint(ON_3dPoint( 2.0, 5.0, 7.0 ));

  pointcloud->AttachUserData( new CExampleWriteUserData("write_points_example()-pointcloud") );
  {
    ONX_Model_Object& mo = model.m_object_table.AppendNew();
    mo.m_object = pointcloud;
    mo.m_bDeleteObject = true; // ~ONX_Model will delete pointcloud.
    mo.m_attributes.m_layer_index = 1;
    mo.m_attributes.AddToGroup(0); // put these points in the group
    mo.m_attributes.m_name = "3 points";
  }

  // single point at (3,2,4) on red point layer
  ON_Point point2(ON_3dPoint( 3.0, 2.0, 4.0  ));
  point2.AttachUserData( new CExampleWriteUserData("write_points_example()-point2") );
  {
    ONX_Model_Object& mo = model.m_object_table.AppendNew();
    mo.m_object = &point2;
    mo.m_bDeleteObject = false;
    mo.m_attributes.m_layer_index = 2;
    mo.m_attributes.AddToGroup(0); // put this points in the group
    mo.m_attributes.m_name = "last point";
  }

  ON_BinaryFile archive( ON::write3dm, fp ); // fp = pointer from fopoen(...,"wb")

  // start section comment
  const char* sStartSectionComment = __FILE__ "write_points_example()" __DATE__;

  // Set uuid's, indices, etc.
  model.Polish();
  // writes model to archive
  bool ok = model.Write( archive, version, sStartSectionComment, &error_log );

  return ok;
}



static bool write_curves_example( FILE* fp, int version, ON_TextLog& error_log )
{
  // example demonstrates how to write a NURBS curve, line, and circle
  ONX_Model model;

  // file properties (notes, preview image, revision history, ...)

  // set revision history information
  model.m_properties.m_RevisionHistory.NewRevision();

  // set application information
  model.m_properties.m_Application.m_application_name = "OpenNURBS write_curves_example() function";
  model.m_properties.m_Application.m_application_URL = "http://www.opennurbs.org";
  model.m_properties.m_Application.m_application_details = "Example program in OpenNURBS toolkit.";

  // some notes
  model.m_properties.m_Notes.m_notes = "This file was made with the OpenNURBS write_curves_example() function.";
  model.m_properties.m_Notes.m_bVisible = true;


  // file settings (units, tolerances, views, ...)
  model.m_settings.m_ModelUnitsAndTolerances.m_unit_system = ON::inches;
  model.m_settings.m_ModelUnitsAndTolerances.m_absolute_tolerance = 0.001;
  model.m_settings.m_ModelUnitsAndTolerances.m_angle_tolerance = ON_PI/180.0; // radians
  model.m_settings.m_ModelUnitsAndTolerances.m_relative_tolerance = 0.01; // 1%


  // layer table
  {
    // OPTIONAL - define some layers
    ON_Layer layer[3];

    layer[0].SetLayerName("Default");
    layer[0].SetVisible(true);
    layer[0].SetLocked(false);
    layer[0].SetColor( ON_Color(0,0,0) );

    layer[1].SetLayerName("green NURBS wiggle");
    layer[1].SetVisible(true);
    layer[1].SetLocked(false);
    layer[1].SetLayerIndex(1);
    layer[1].SetColor( ON_Color(0,255,0) );

    layer[2].SetLayerName("blue circles");
    layer[2].SetVisible(true);
    layer[2].SetLocked(false);
    layer[2].SetLayerIndex(2);
    layer[2].SetColor( ON_Color(0,0,255) );

    model.m_layer_table.Append(layer[0]);
    model.m_layer_table.Append(layer[1]);
    model.m_layer_table.Append(layer[2]);
  }


  // object table
  {

    {
      // write a line on the default layer
      ONX_Model_Object& mo = model.m_object_table.AppendNew();
      mo.m_object = new ON_LineCurve( ON_Line( ON_3dPoint(1.0,2.0,-1.5), ON_3dPoint(5.0,3.0,2.0) ) );
      mo.m_bDeleteObject = true;
      mo.m_attributes.m_layer_index = 0;
      mo.m_attributes.m_name = "straight line curve";

    }

    {
      // write a wiggly cubic curve on the "green NURBS wiggle" layer
      ON_NurbsCurve* wiggle = new ON_NurbsCurve(
        3, // dimension
        false, // true if rational
        4,     // order = degree+1
        6      // number of control vertices
        );
      int i;
      for ( i = 0; i < wiggle->CVCount(); i++ ) {
        ON_3dPoint pt( 2*i, -i, (i-3)*(i-3) ); // pt = some 3d point
        wiggle->SetCV( i, pt );
      }

      // ON_NurbsCurve's have order+cv_count-2 knots.
      wiggle->SetKnot(0, 0.0);
      wiggle->SetKnot(1, 0.0);
      wiggle->SetKnot(2, 0.0);
      wiggle->SetKnot(3, 1.5);
      wiggle->SetKnot(4, 2.3);
      wiggle->SetKnot(5, 4.0);
      wiggle->SetKnot(6, 4.0);
      wiggle->SetKnot(7, 4.0);

      
      if ( wiggle->IsValid() ) 
      {
        ONX_Model_Object& mo = model.m_object_table.AppendNew();
        mo.m_object = wiggle;
        mo.m_bDeleteObject = true;
        mo.m_attributes.m_layer_index = 1;
        mo.m_attributes.m_name = "wiggly cubic curve";
      }
      else
        delete wiggle;
    }

    {
      // write two circles on the "blue circles"
      ONX_Model_Object& circle1 = model.m_object_table.AppendNew();
      circle1.m_object = new ON_ArcCurve( ON_Circle( ON_3dPoint(1.0,2.0,-1.5), 3.0 ) );
      circle1.m_bDeleteObject = true;
      circle1.m_attributes.m_layer_index = 2;
      circle1.m_attributes.m_name = "radius 3 circle";

      ONX_Model_Object& circle2 = model.m_object_table.AppendNew();
      circle2.m_object = new ON_ArcCurve( ON_Circle( ON_3dPoint(1.0,2.0,-1.5), 5.0 ) );
      circle2.m_bDeleteObject = true;
      circle2.m_attributes.m_layer_index = 2;
      circle2.m_attributes.m_name = "radius 5 circle";
    }

  }

  // start section comments
  const char* sStartSectionComment = __FILE__ "write_curves_example()" __DATE__;

  ON_BinaryFile archive( ON::write3dm, fp ); // fp = pointer from fopoen(...,"wb")

  // Set uuid's, indices, etc.
  model.Polish();
  // writes model to archive
  bool ok = model.Write(archive, version, sStartSectionComment, &error_log );

  return ok;
}


static bool write_surfaces_example( FILE* fp, int version )
{
  // example demonstrates how to write a NURBS surface

  //////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////

  // The code between the comment bands has nothing to do with I/O.
  // It is simply an easy way to get a NURBS surface to write.
  const int bIsRational = false;
  const int dim = 3;
  const int u_degree = 2;
  const int v_degree = 3;
  const int u_cv_count = 3;
  const int v_cv_count = 5;

  // The knot vectors do NOT have the 2 superfluous knots
  // at the start and end of the knot vector.  If you are
  // coming from a system that has the 2 superfluous knots,
  // just ignore them when writing a 3dm file.
  double u_knot[ u_cv_count + u_degree - 1 ];
  double v_knot[ v_cv_count + v_degree - 1 ];

  // make up a quadratic knot vector with no interior knots
  u_knot[0] = u_knot[1] = 0.0;
  u_knot[2] = u_knot[3] = 1.0;

  // make up a cubic knot vector with one simple interior knot
  v_knot[0] = v_knot[1] = v_knot[2] = 0.0;
  v_knot[3] = 1.5;
  v_knot[4] = v_knot[5] = v_knot[6] = 2.0;

  // Rational control points can be in either homogeneous
  // or euclidean form. Non-rational control points do not
  // need to specify a weight.  
  ON_3dPoint CV[u_cv_count][v_cv_count];

  int i, j;
  for ( i = 0; i < u_cv_count; i++ ) {
    for ( j = 0; j < v_cv_count; j++ ) {
      CV[i][j].x = i;
      CV[i][j].y = j;
      CV[i][j].z = i-j;
    }
  }

  // write a line on the default layer
  ON_NurbsSurface nurbs_surface( dim, bIsRational, 
                        u_degree+1, v_degree+1,
                        u_cv_count, v_cv_count );

  for ( i = 0; i < nurbs_surface.KnotCount(0); i++ )
    nurbs_surface.SetKnot( 0, i, u_knot[i] );

  for ( j = 0; j < nurbs_surface.KnotCount(1); j++ )
    nurbs_surface.SetKnot( 1, j, v_knot[j] );

  for ( i = 0; i < nurbs_surface.CVCount(0); i++ ) {
    for ( j = 0; j < nurbs_surface.CVCount(1); j++ ) {
      nurbs_surface.SetCV( i, j, CV[i][j] );
    }
  }

  bool ok = false;
  if ( nurbs_surface.IsValid() ) 
  {
    ON_BinaryFile archive( ON::write3dm, fp );
    ok = ON_WriteOneObjectArchive( archive, version, nurbs_surface );
  }

  return ok;
}


static bool write_mesh_example( FILE* fp, int version )
{
  // example demonstrates how to create and write a mesh

  // create a mesh to write
  // The mesh is a pyramid with 4 triangular sides and a quadranglar 
  // base.  The mesh has 5 vertices and 5 faces.  
  // The side faces share normals at their common vertices.  The
  // quadrangular base has normals different from the side normal.
  // Coincident vertices that have distinct normals must be
  // duplicated in the vertex list.
  //
  // The apex will be at (1,1.5,4) with normal (0,0,1).
  // The base corners will be at (0,0,0), (0,2,0), (2,3,0), (0,3,0).


  bool bHasVertexNormals = true; // we will specify vertex normals
  bool bHasTexCoords = false;    // we will not specify texture coordinates
  const int vertex_count = 5+4;  // 4 duplicates for different base normals
  const int face_count = 5; // 4 triangle sides and a quad base
  ON_Mesh mesh( face_count, vertex_count, bHasVertexNormals, bHasTexCoords);

  // The SetVertex(), SetNormal(), SetTCoord() and SetFace() functions
  // return true if successful and false if input is illegal.  It is
  // a good idea to inspect this returned value.

  // vertex #0: apex location and normal
  mesh.SetVertex( 0, ON_3dPoint(1.0,  1.5,  5.0) );
  mesh.SetVertexNormal( 0, ON_3dVector(0.0,  0.0,  1.0) );

  // vertex #1: SW corner vertex for sides
  mesh.SetVertex( 1, ON_3dPoint(0.0,  0.0,  0.0) );
  mesh.SetVertexNormal( 1, ON_3dVector(-1.0, -1.0,  0.0) ); // set normal will unitize if needed

  // vertex #2: SE corner vertex for sides
  mesh.SetVertex( 2, ON_3dPoint(2.0,  0.0,  0.0) );
  mesh.SetVertexNormal( 2, ON_3dVector(+1.0, -1.0,  0.0) );

  // vertex #3: NE corner vertex for sides
  mesh.SetVertex( 3, ON_3dPoint(2.0,  3.0,  0.0) );
  mesh.SetVertexNormal( 3, ON_3dVector(+1.0, +1.0,  0.0) );

  // vertex #4: NW corner vertex for sides
  mesh.SetVertex( 4, ON_3dPoint(0.0,  3.0,  0.0) );
  mesh.SetVertexNormal( 4, ON_3dVector(-1.0, +1.0,  0.0) );

  // vertex #5: SW corner vertex for base
  mesh.SetVertex( 5, ON_3dPoint(0.0,  0.0,  0.0) ); // == location of v1
  mesh.SetVertexNormal( 5, ON_3dVector(0.0,  0.0, -1.0) );

  // vertex #6: SE corner vertex for base
  mesh.SetVertex( 6, ON_3dPoint(2.0,  0.0,  0.0) ); // == location of v2
  mesh.SetVertexNormal( 6, ON_3dVector(0.0,  0.0, -1.0) );

  // vertex #7: SW corner vertex for base
  mesh.SetVertex( 7, ON_3dPoint(2.0,  3.0,  0.0) ); // == location of v3
  mesh.SetVertexNormal( 7, ON_3dVector(0.0,  0.0, -1.0) );

  // vertex #8: SW corner vertex for base
  mesh.SetVertex( 8, ON_3dPoint(0.0,  3.0,  0.0) ); // == location of v4
  mesh.SetVertexNormal( 8, ON_3dVector(0.0,  0.0, -1.0) );

  // faces have vertices ordered counter-clockwise

  // South side triangle
  mesh.SetTriangle( 0,   1, 2, 0 );

  // East side triangle
  mesh.SetTriangle( 1,   2, 3, 0 );

  // North side triangle
  mesh.SetTriangle( 2,   3, 4, 0 );

  // West side triangle
  mesh.SetTriangle( 3,   4, 1, 0 );

  // last face is quadrangular base
  mesh.SetQuad( 4,   5, 8, 7, 6 );

  //////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////

  bool ok = false;
  if ( mesh.IsValid() ) 
  {
    // Most applications expect vertex normals.
    // If they are not present, ComputeVertexNormals sets
    // them by averaging face normals.
    if ( !mesh.HasVertexNormals() )
      mesh.ComputeVertexNormals();
    ON_BinaryFile archive( ON::write3dm, fp );
    ok = ON_WriteOneObjectArchive( archive, version, mesh );
  }

  return ok;
}

static bool write_mesh_with_material_example( FILE* fp, int version, ON_TextLog& error_log )
{
  // example demonstrates how to create and write a mesh that uses
  // a rendering material.  You may want to study write_mesh_example() 
  // before examining this function.
  //
  // The key to attaching a texture is to create a mesh
  // with texture coordinates, create a material using the
  // texture as a bitmap, and to attach the material to the
  // mesh before writing the mesh.


  bool bHasVertexNormals = false; // we will NOT specify vertex normals
  bool bHasTexCoords = true;      // we will specify texture coordinates
  const int vertex_count = 40;
  const int face_count = 28;
  ON_Mesh mesh( face_count, vertex_count, bHasVertexNormals, bHasTexCoords);

  // The SetVertex(), SetNormal(), SetTextureCoord() and SetQuad() functions
  // return true if successful and false if input is illegal.  It is
  // a good idea to inspect this returned value.

  // cook up a 5 x 8 grid of vertices
  int vertex_index = 0;
  int i, j;
  for ( i = 0; i <= 4; i++ ) {
    for ( j = 0; j <= 7; j++ ) {
      ON_3fPoint v( (float)i, (float)j, (float)(sin( 2.0*3.14159*j/7.0 ) + cos( 3.14159*i/4.0 )) );
      mesh.SetVertex( vertex_index, v ); // 3d location

      // normalized texture coordinate
      double tcoord_u = i/4.0;
      double tcoord_v = j/7.0;
      mesh.SetTextureCoord( vertex_index, tcoord_u, tcoord_v ); // 2d texture coordinate

      vertex_index++;
    }
  }

  // faces have vertices ordered counter-clockwise

  // cook up a 4 x 7 grid of quadrangular faces
  int face_index = 0;
  for ( i = 0; i < 4; i++ ) {
    for ( j = 0; j < 7; j++ ) {
      int vi[4]; // indices of corner vertices
      vi[0] = i*8 + j;  // vertex at "lower left" corner
      vi[1] = vi[0]+8;  // vertex at "lower right" corner
      vi[2] = vi[1]+1;  // vertex at "upper left" corner
      vi[3] = vi[0]+1;  // vertex at "upper right" corner
      mesh.SetQuad( face_index, vi[0], vi[1], vi[2], vi[3] );
      face_index++;
    }
  }


  // rendering material with a texture map.
  ON_Material material;
  material.SetMaterialIndex(0);
  material.SetAmbient(  ON_Color(  40,  40,  40 ) );
  material.SetDiffuse(  ON_Color( 220, 220, 220 ) );
  material.SetEmission( ON_Color(   0,   0,   0 ) );
  material.SetSpecular( ON_Color( 180, 180, 180 ) );

  material.SetShine( 0.35*ON_Material::MaxShine() ); // 0 = flat
                                                        // MaxShine() = shiney

  material.SetTransparency( 0.2 );  // 0 = opaque, 1 = transparent

  // Texture and bump bitmaps can be Windows bitmap (.BMP), Targa (.TGA),
  // JPEG (.JPG), PCX or PNG files.  Version 1 of Rhino will not support
  // filenames using unicode or multibyte character sets.  As soon as
  // Rhino supports these character sets, the const char* filename will
  // changed to const _TCHAR*.

  // For Rhino to find the texture bitmap, the .3dm file and the
  // .bmp file need to be in the same directory.
  ON_Texture texture;
  texture.m_filename = L"example_texture.bmp";
  material.AddTexture( texture );

  // The render material name is a string used to identify rendering
  // materials in RIB, POV, OBJ, ..., files.  In Rhino, the render
  // material name is set with the SetObjectMaterial command and can
  // be viewed in the Info tab of the dialog displayed by the
  // Properties command.
  material.SetMaterialName( L"my render material" );

  bool ok = false;
  if ( mesh.IsValid() ) 
  {
    // Most applications expect vertex normals.
    // If they are not present, ComputeVertexNormals sets
    // them by averaging face normals.
    if ( !mesh.HasVertexNormals() )
      mesh.ComputeVertexNormals();

    ON_Object* object[1];
    object[0] = &mesh;
    ON_3dmObjectAttributes attributes;
    attributes.m_name = "my mesh with material";
    attributes.m_material_index = 0;
    attributes.SetMaterialSource( ON::material_from_object );
    ok = write_simple_file_example( fp, version, error_log,
         "OpenNURBS write_mesh_with_material_example()", // notes
         NULL,               // default settings
         1, &material,       // render material table
         0, NULL,            // layer table
         0,                  // light count
         NULL,               // light attributes
         NULL,               // lights
         1,                  // object count
         &attributes,        // array of object_count attributes
         object              // array of object_count objects
         );
  }

  return ok;
}

static bool write_spot_light_example( FILE* fp, int version, ON_TextLog& error_log )
{
  // create a blue spotlight shining on a white plane

  // white material for surface
  ON_Material material;
  ON_Color white(255,255,255);
  ON_Color black(0,0,0);
  material.SetMaterialIndex(0);
  material.SetAmbient(  white );
  material.SetDiffuse(  white );
  material.SetEmission( black );
  material.SetSpecular( white );
  material.SetShine( 0.35*ON_Material::MaxShine() ); // 0 = flat
                                                        // MaxShine() = shiney
  material.SetTransparency( 0.0 );  // 0 = opaque, 1 = transparent
  material.SetMaterialName( L"white material" );


  // 2 layers
  ON_Layer layer[2];
  layer[0].SetLayerName(L"surfaces");
  layer[0].SetVisible(true);
  layer[0].SetLocked(false);
  layer[0].SetLayerIndex(0);
  layer[0].SetColor( ON_Color(0, 0, 0) );

  layer[1].SetLayerName(L"lights");
  layer[1].SetVisible(true);
  layer[1].SetLocked(false);
  layer[1].SetLayerIndex(1);
  layer[1].SetColor( ON_Color(0, 0, 0) );


  // spotlight
  ON_Light light;
  light.SetLightIndex(0);
  light.SetLocation( ON_3dPoint(2.0, 3.0, 10.0) );
  light.SetDirection( ON_3dVector(-1.0, -1.0, -10.0) );
  light.SetDiffuse( ON_Color( 0, 0, 255 ) );
  light.SetAmbient( ON_Color( 0, 0, 0 ) );
  light.SetSpecular( ON_Color( 0, 0, 255 ) );
  light.SetSpotExponent( 60 );    // 0 = hard, 128 = soft
  light.SetSpotAngleDegrees( 30.0 );
  light.SetStyle(ON::world_spot_light);

  light.SetLightName( "Blue spot light" );

  ON_3dmObjectAttributes light_attributes;
  light_attributes.Default();
  light_attributes.m_layer_index = 1;     // spotlights layer we defined above
  light_attributes.m_name = "Blue spot light";


  // quick and dirty plane
  ON_PlaneSurface plane (ON_xy_plane);
  plane.SetDomain( 0, -10.0, +10.0 );
  plane.SetDomain( 1, -10.0, +10.0 );

  ON_3dmObjectAttributes object_attributes;
  object_attributes.Default();
  object_attributes.m_layer_index = 0; // surfaces layer we defined above
  object_attributes.m_material_index = 0; // white material we defined above
  object_attributes.SetMaterialSource(ON::material_from_object);
  object_attributes.m_name = "20x20 plane";

  ON_Object* object[1];
  object[0] = &plane;
  bool ok = write_simple_file_example( fp, version, error_log,
       "OpenNURBS write_spot_light_example()", // notes
       NULL,               // default settings
       0, NULL,            // render material table
       0, NULL,            // layer table
       1,                  // light_count
       &light_attributes,  // array of light_count attributes
       &light,             // array of light_count lights
       1,                  // object_count
       &object_attributes, // array of object_count attributes
       object              // array of object_count objects
       );

  return ok;
}


static bool write_viewport_example( FILE* fp, int version, ON_TextLog& error_log,
      const ON_Sphere& sphere // sphere containing region to be viewed
       )
{
  // Writes a 7 viewport layout - 3 along the right side,
  // 3 along the left side, and 1 big on in the middle
  // that displays the space inside the sphere.

  // Viewports have a "target" point inside of the view frustum.
  // This target is the center of view rotations.

  // Viewports have a "construction plane".  This plane is
  // (optionally) displayed as a grid.
  //

  ON_3dmSettings settings;
  {
    // OPTIONAL - change values from defaults
    settings.m_ModelUnitsAndTolerances.m_unit_system = ON::millimeters;
    settings.m_ModelUnitsAndTolerances.m_absolute_tolerance = 0.01;
    settings.m_ModelUnitsAndTolerances.m_angle_tolerance = ON_PI/180.0; // radians
    settings.m_ModelUnitsAndTolerances.m_relative_tolerance = 0.01; // 1%
  }

  // reserve room for 7 views
  settings.m_views.Reserve(7);

  // some values needed to fill in view information
  const double pos_x[4]  = {0.0,0.25,0.75,1.0};       // x: 0 = left, 1 = right
  const double pos_y[4]  = {0.0,1.0/3.0,2.0/3.0,1.0}; // y: 0 = top, 1 = bottom
  ON_3dVector camDir;
  double fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far;
  double target_distance;

  fr_left   = -sphere.radius;
  fr_right  =  sphere.radius;
  fr_bottom = -sphere.radius;
  fr_top    =  sphere.radius;
  fr_near         = 2.0*sphere.radius; // Rhino's default
  target_distance = 3.0*sphere.radius;
  fr_far          = 4.0*sphere.radius;

  // view number 1
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = -ON_zaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_yaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "+X+Y parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[0];
    view.m_position.m_wnd_right = pos_x[1];
    view.m_position.m_wnd_top = pos_y[2];
    view.m_position.m_wnd_bottom = pos_y[3];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane = ON_xy_plane;
  }

  // view number 2
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = ON_yaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_zaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "+X+Z parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[0];
    view.m_position.m_wnd_right = pos_x[1];
    view.m_position.m_wnd_top = pos_y[1];
    view.m_position.m_wnd_bottom = pos_y[2];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane = ON_zx_plane;
  }

  // view number 3
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = -ON_xaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_zaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "+Y+Z parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[0];
    view.m_position.m_wnd_right = pos_x[1];
    view.m_position.m_wnd_top = pos_y[0];
    view.m_position.m_wnd_bottom = pos_y[1];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane = ON_yz_plane;
  }

  // view number 4
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = ON_zaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_yaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "-X+Y parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[2];
    view.m_position.m_wnd_right = pos_x[3];
    view.m_position.m_wnd_top = pos_y[2];
    view.m_position.m_wnd_bottom = pos_y[3];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane.CreateFromFrame( ON_origin, -ON_xaxis, ON_yaxis );
  }

  // view number 5
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = -ON_yaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_zaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "-X+Z parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[2];
    view.m_position.m_wnd_right = pos_x[3];
    view.m_position.m_wnd_top = pos_y[1];
    view.m_position.m_wnd_bottom = pos_y[2];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane.CreateFromFrame( ON_origin, -ON_xaxis, ON_zaxis );
  }

  // view number 6
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    view.m_vp.SetProjection( ON::parallel_view );
    camDir = ON_xaxis;
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_zaxis );
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "-Y+Z parallel";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[2];
    view.m_position.m_wnd_right = pos_x[3];
    view.m_position.m_wnd_top = pos_y[0];
    view.m_position.m_wnd_bottom = pos_y[1];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane.CreateFromFrame( ON_origin, -ON_yaxis, ON_zaxis );
  }

  // view number 7
  {
    ON_3dmView& view = settings.m_views.AppendNew();

    // set primary view transformation information first
    target_distance = 10.0*sphere.radius;
    const double tan_half_angle = sphere.radius / target_distance;

    view.m_vp.SetProjection( ON::perspective_view );
    camDir = ON_3dVector(-40.0,75.0,-50.0);
    view.m_vp.SetCameraLocation( sphere.Center() - target_distance*camDir );
    view.m_vp.SetCameraDirection( camDir );
    view.m_vp.SetCameraUp( ON_zaxis );
    fr_near   = (target_distance - sphere.radius)/10.0;
    fr_far    = target_distance + 1.5*sphere.radius;
    double d  = fr_near*tan_half_angle;
    fr_left   = -d;
    fr_right  =  d;
    fr_bottom = -d;
    fr_top    =  d;
    view.m_vp.SetFrustum( fr_left, fr_right, fr_bottom, fr_top, fr_near, fr_far );

    view.SetTargetPoint(sphere.Center());

    // secondary view "fluff"
    view.m_name = "skew perspective";

    // position of viewport inside main window
    view.m_position.m_wnd_left = pos_x[1];
    view.m_position.m_wnd_right = pos_x[2];
    view.m_position.m_wnd_top = pos_y[0];
    view.m_position.m_wnd_bottom = pos_y[3];

    // construction plane
    view.m_cplane.Default(); // default grid settings
    view.m_cplane.m_plane = ON_xy_plane;
  }


  bool ok = write_simple_file_example( fp, version, error_log,
         "OpenNURBS write_viewport_example()", // notes
         &settings,          // default settings
         0, NULL,            // render material table
         0, NULL,            // layer table
         0,                  // light count
         NULL,               // light attributes
         NULL,               // lights
         0,                  // object count
         NULL,               // array of object_count attributes
         NULL                // array of object_count objects
         );

  return ok;
}

static void make_trimming_curves( ON_Brep& brep, 
                                  const ON_2dPoint& A2, // start point in parameter space
                                  const ON_2dPoint& B2, // end point in parameter space
                                  const ON_3dPoint& A3, // start point in parameter space
                                  const ON_3dPoint& B3  // end point in parameter space
                                  )
{
  ON_LineCurve* p2dCurve = new ON_LineCurve( A2, B2 );
  ON_LineCurve* p3dCurve = new ON_LineCurve( A3, B3 );

  // it is not necessary for the domains of the 2d and 3d curves
  // to match, but it makes it easier to understand the brep
  ON_Interval domain = p3dCurve->Domain();
  p2dCurve->SetDomain( domain.Min(), domain.Max() );

  brep.m_C2.Append(p2dCurve);

  brep.m_C3.Append(p3dCurve);
}


static bool write_trimmed_surface_example( FILE* fp, int version, ON_TextLog& error_log )
{
  // trimmed surfaces are written as a CRhinoBrep that has
  // a single surface and a single CRhinoBrepFace.
  //
  // Trimming loops are simple closed curves and are oriented
  // so that the active portion of the trimmed surface's
  // domain lies to the left of the trimming curves.

  ON_Brep brep;
  ON_2dPoint q;

  // Create a 10x10 plane surface at z=3 with domain [0,1]x[0,1]
  ON_PlaneSurface* pSurface = new ON_PlaneSurface( ON_Plane( ON_3dPoint( 0, 0,3), 
                                                             ON_3dPoint(10,10,3), 
                                                             ON_3dPoint(10, 0,3) ) );
  pSurface->SetDomain(0,0.0,10.0);
  pSurface->SetDomain(1,0.0,10.0);

  // ~ON_Brep() will delete this surface
  const int si = brep.m_S.Count(); // index of surface
  brep.m_S.Append(pSurface);

  // create simple trimming triangle
  ON_2dPoint A2(1.0, 2.0); // parameter space locations of 2d trim corners
  ON_2dPoint B2(9.0, 1.5);
  ON_2dPoint C2(7.0, 8.0);

  ON_3dPoint A3 = pSurface->PointAt(A2.x,A2.y);
  ON_3dPoint B3 = pSurface->PointAt(B2.x,B2.y);
  ON_3dPoint C3 = pSurface->PointAt(C2.x,C2.y);

  make_trimming_curves( brep, A2, B2, A3, B3 ); // creates 2d and 3d curve
  make_trimming_curves( brep, B2, C2, B3, C3 );
  make_trimming_curves( brep, C2, A2, C3, A3 );

  // there are vertices at the 3 corners
  brep.NewVertex( pSurface->PointAt( A2.x, A2.y ) );
  brep.NewVertex( pSurface->PointAt( B2.x, B2.y ) );
  brep.NewVertex( pSurface->PointAt( C2.x, C2.y ) );

  // the vertices are exact since we have lines on a plane
  brep.m_V[0].m_tolerance = 0.0;
  brep.m_V[1].m_tolerance = 0.0;
  brep.m_V[2].m_tolerance = 0.0;

  // there are 3 edges along the sides of the triangle
  brep.NewEdge( brep.m_V[0], brep.m_V[1], 0 ); // start vertex, end vertex, 3d curve index
  brep.NewEdge( brep.m_V[1], brep.m_V[2], 1 ); // start vertex, end vertex, 3d curve index
  brep.NewEdge( brep.m_V[2], brep.m_V[0], 2 ); // start vertex, end vertex, 3d curve index

  // the edges are exact since we have lines on a plane
  brep.m_E[0].m_tolerance = 0.0;
  brep.m_E[1].m_tolerance = 0.0;
  brep.m_E[2].m_tolerance = 0.0;

  // there is 1 face
  ON_BrepFace& face = brep.NewFace( si );

  // outer boundary trimming loops
  ON_BrepLoop& loop = brep.NewLoop( ON_BrepLoop::outer, face );

  // geometrically, loops are made from a contiguous list of 2d parameter space
  // curves that form a simple closed curve.
  brep.NewTrim( brep.m_E[0], false, loop, 0 ); // A to B
  brep.NewTrim( brep.m_E[1], false, loop, 1 ); // B to C
  brep.NewTrim( brep.m_E[2], false, loop, 2 ); // C to A

  // the trims are exact since we have lines on a plane
  q = brep.m_C2[0]->PointAtStart();
  //brep.m_T[0].m_P[0] = pSurface->PointAt(q.x,q.y);
  q = brep.m_C2[0]->PointAtEnd();
  //brep.m_T[0].m_P[1] = pSurface->PointAt(q.x,q.y);
  brep.m_T[0].m_type = ON_BrepTrim::boundary;
  brep.m_T[0].m_tolerance[0] = 0.0;
  brep.m_T[0].m_tolerance[1] = 0.0;

  q = brep.m_C2[0]->PointAtStart();
  //brep.m_T[1].m_P[0] = pSurface->PointAt(q.x,q.y);
  q = brep.m_C2[0]->PointAtEnd();
  //brep.m_T[1].m_P[1] = pSurface->PointAt(q.x,q.y);
  brep.m_T[1].m_type = ON_BrepTrim::boundary;
  brep.m_T[1].m_tolerance[0] = 0.0;
  brep.m_T[1].m_tolerance[1] = 0.0;

  q = brep.m_C2[0]->PointAtStart();
  //brep.m_T[2].m_P[0] = pSurface->PointAt(q.x,q.y);
  q = brep.m_C2[0]->PointAtEnd();
  //brep.m_T[2].m_P[1] = pSurface->PointAt(q.x,q.y);
  brep.m_T[2].m_type = ON_BrepTrim::boundary;
  brep.m_T[2].m_tolerance[0] = 0.0;
  brep.m_T[2].m_tolerance[1] = 0.0;

    // when debugging your code, IsValid(), IsSolid(), IsManifold() are useful
  // to check.

  bool ok = false;
  if ( brep.IsValid( &error_log ) )
  {
    ON_BinaryFile archive(ON::write3dm,fp);
    ok = ON_WriteOneObjectArchive( archive, version, brep );
  }
  
  int bIsManifold, bIsOriented, bHasBoundary, bIsSolid;
  bIsManifold = brep.IsManifold( &bIsOriented, &bHasBoundary );
  bIsSolid = brep.IsSolid();

  return ok;
}

//int main ( int argc, const char* argv[] )
int main ()
{
  bool rc;
  const char* filename;

  ON::Begin();
  // If you want to learn to write b-rep models, first work through
  // this example paying close attention to write_trimmed_surface_example(),
  // then examime example_brep.cpp.

  // The OpenNURBS toolkit will write version 2 and 3 and read
  // version 1, 2 and 3 of the 3DM file format.
  //
  // version 1 is the legacy Rhino I/O tookit format and was used by Rhino 1.x.
  // version 2 is the OpenNURBS format (released 1 July 2000) and is used by Rhino 2.x
  // version 3 is the OpenNURBS format (released 1 November 2002) and is used by Rhino 3.x
  // version 4 is the OpenNURBS format (released September 2006) and is used by Rhino 4.x
  // version 5 is the OpenNURBS format (released September 2009) and is used by Rhino 5.x

  // version to write
  int version = 4; // File can be read by Rhino 4 and Rhino 5
  //int version = 5; // File can be read by Rhino 5


  // errors printed to stdout
  ON_TextLog error_log;

  // messages printed to stdout
  ON_TextLog message_log;

  // errors logged in text file
  //FILE* error_log_fp = ON::OpenFile("error_log.txt","w");
  //ON_TextLog error_log(error_log_fp);

  filename = "my_points.3dm";
  FILE* fp = ON::OpenFile( filename, "wb" );
  rc = write_points_example( fp, version, error_log );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_curves.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_curves_example( fp, version, error_log );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_surfaces.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_surfaces_example( fp, version );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_mesh.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_mesh_example( fp, version );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_mesh_with_material.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_mesh_with_material_example( fp, version, error_log );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_spot_light.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_spot_light_example( fp, version, error_log );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_viewports.3dm";
  fp = ON::OpenFile( filename, "wb" );
  // views will display space inside the sphere
  ON_Sphere sphere ( ON_origin, 10.0 );
  rc = write_viewport_example( fp, version, error_log, sphere );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  filename = "my_trimmed_surface.3dm";
  fp = ON::OpenFile( filename, "wb" );
  rc = write_trimmed_surface_example( fp, version, error_log );
  ON::CloseFile( fp );
  if (rc)
    message_log.Print("Successfully wrote %s.\n",filename);
  else
    message_log.Print("Errors while writing %s.\n",filename);

  ON::End();

  return 0;
}
blob
data 7502
/* $NoKeywords: $ */
/*
//
// Copyright (c) 1993-2012 Robert McNeel & Associates. All rights reserved.
// OpenNURBS, Rhinoceros, and Rhino3D are registered trademarks of Robert
// McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//
// For complete openNURBS copyright information see <http://www.opennurbs.org>.
//
////////////////////////////////////////////////////////////////
*/

////////////////////////////////////////////////////////////////
//
//   Includes all openNURBS toolkit headers required to use the
//   openNURBS toolkit library.  See readme.txt for details.
//
////////////////////////////////////////////////////////////////

#if !defined(OPENNURBS_INC_)
#define OPENNURBS_INC_

#include "opennurbs_system.h"       /* system headers used by openNURBS code */

#include "opennurbs_3dm.h"          /* 3DM typecode (TCODE) definitions */

#include "opennurbs_defines.h"      /* openNURBS defines and enums */
#include "opennurbs_error.h"        /* error handling */
#include "opennurbs_memory.h"       /* memory management (onmalloc(), onrealloc(), onfree(), ...) */
#include "opennurbs_rand.h"         /* random number generator */
#include "opennurbs_crc.h"          /* cyclic redundancy check tool */
#include "opennurbs_uuid.h"         /* universally unique identifiers (UUID, a.k.a, GUID) */
#include "opennurbs_unicode.h"      /* unicode string conversion */

#if defined(ON_CPLUSPLUS)

#include "opennurbs_fsp.h"            // fixed size memory pool
#include "opennurbs_string.h"         // dynamic string classes (single and double byte)
#include "opennurbs_compress.h"
#include "opennurbs_base64.h"         // base64 encoding and decoding
#include "opennurbs_color.h"          // R G B color
#include "opennurbs_linestyle.h"      // line pattern, scale, and width
#include "opennurbs_point.h"          // double precision 2d, 3d, 4d points and 2d, 3d vectors
#include "opennurbs_fpoint.h"         // float precision 2d, 3d, 4d points and 2d, 3d vectors
#include "opennurbs_array.h"          // dynamic array templates
#include "opennurbs_base32.h"         // base32 encodeing and decoding
#include "opennurbs_pluginlist.h"
#include "opennurbs_bounding_box.h"   // simple 3d axis aligned bounding box
#include "opennurbs_matrix.h"         // general m X n matrix
#include "opennurbs_xform.h"          // 4 X 4 transformation matrix
#include "opennurbs_workspace.h"      // workspace memory allocation
#include "opennurbs_plane.h"          // simple 3d plane
#include "opennurbs_circle.h"         // simple 3d circle
#include "opennurbs_ellipse.h"        // simple 3d ellipse
#include "opennurbs_x.h"              // intersection events
#include "opennurbs_line.h"           // simple line
#include "opennurbs_polyline.h"       // simple polyline
#include "opennurbs_cylinder.h"       // simple 3d elliptical cylinder
#include "opennurbs_cone.h"           // simple 3d right circular cone
#include "opennurbs_sphere.h"         // simple 3d sphere
#include "opennurbs_box.h"            // simple 3d box
#include "opennurbs_torus.h"          // simple 3d torus
#include "opennurbs_bezier.h"         // simple bezier and polynomial curves and surfaces
#include "opennurbs_math.h"           // utilities for performing simple calculations
#include "opennurbs_intersect.h"      // utilities for performing simple intersections
#include "opennurbs_optimize.h"       // utilities for finding extrema and zeros
#include "opennurbs_knot.h"           // utilities for working with NURBS knot vectors
#include "opennurbs_evaluate_nurbs.h" // utilities for evaluating Beziers and NURBS
#include "opennurbs_textlog.h"        // text log for dumps, error logs, etc.
#include "opennurbs_zlib.h"           // ON_BinaryArchive needs z_stream definition.
#include "opennurbs_rtree.h"          // ON_RTree spatial search utility.
#include "opennurbs_mapchan.h"
#include "opennurbs_rendering.h"
#include "opennurbs_archive.h"        // binary arcive objects for serialization to file, memory blocks, etc.
#include "opennurbs_massprop.h"       // mass properties values
#include "opennurbs_arc.h"            // simple 3d circular arc
#include "opennurbs_object.h"         // virtual base class for all openNURBS objects
#include "opennurbs_userdata.h"       // class for attaching persistent user information to openNURBS objects
#include "opennurbs_geometry.h"       // virtual base class for geometric objects
#include "opennurbs_curve.h"          // virtual parametric curve
#include "opennurbs_surface.h"        // virtual parametric surface
#include "opennurbs_viewport.h"       // simple renering projection
#include "opennurbs_texture_mapping.h" // texture coordinate evaluation
#include "opennurbs_texture.h"        // texture definition
#include "opennurbs_material.h"       // simple rendering material
#include "opennurbs_layer.h"          // layer definition
#include "opennurbs_linetype.h"          // linetype definition
#include "opennurbs_group.h"          // group name and index
#include "opennurbs_font.h"           // font name and index
#include "opennurbs_light.h"          // light
#include "opennurbs_pointgeometry.h"  // single point
#include "opennurbs_pointcloud.h"     // point set
#include "opennurbs_curveproxy.h"     // proxy curve provides a way to use an existing curve
#include "opennurbs_surfaceproxy.h"   // proxy surface provides a way to use another surface
#include "opennurbs_mesh.h"           // render mesh object
#include "opennurbs_pointgrid.h"      // point grid object
#include "opennurbs_linecurve.h"      // line as a paramtric curve object
#include "opennurbs_arccurve.h"       // arc/circle as a paramtric curve object
#include "opennurbs_polylinecurve.h"  // polyline as a paramtric curve object
#include "opennurbs_nurbscurve.h"     // NURBS curve
#include "opennurbs_polycurve.h"      // polycurve (composite curve)
#include "opennurbs_curveonsurface.h" // curve on surface (other kind of composite curve)
#include "opennurbs_nurbssurface.h"   // NURBS surface
#include "opennurbs_planesurface.h"   // plane surface
#include "opennurbs_revsurface.h"     // surface of revolution
#include "opennurbs_sumsurface.h"     // sum surface
#include "opennurbs_brep.h"           // boundary rep
#include "opennurbs_beam.h"           // lightweight extrusion object
#include "opennurbs_bitmap.h"         // Windows and OpenGL bitmaps
#include "opennurbs_instance.h"       // instance definitions and references
#include "opennurbs_3dm_properties.h"
#include "opennurbs_3dm_settings.h"
#include "opennurbs_3dm_attributes.h"
#include "opennurbs_annotation.h"     // used to serialize annotation objects
#include "opennurbs_annotation2.h"    // used to serialize annotation2 objects
#include "opennurbs_hatch.h"          // hatch geometry definitions
#include "opennurbs_dimstyle.h"       // dimstyle name and index
#include "opennurbs_hatch.h"          // hatch geometry definitions
#include "opennurbs_linetype.h"       // linetype pattern definitions
#include "opennurbs_objref.h"         // ON_ObjRef definition
#include "opennurbs_offsetsurface.h"  // ON_OffsetSurface definition
#include "opennurbs_detail.h"         // ON_Detail definition
#include "opennurbs_lookup.h"         // ON_SerialNumberTable
#include "opennurbs_object_history.h"
#include "opennurbs_extensions.h"

#endif

#endif
blob
data 2481
SET(openNURBS_ignore_files
BRL-CAD_changes.txt
Makefile.am
example_brep
example_dump
example_gl
example_read
example_roundtrip
example_userdata
example_write
examples_linking_pragmas.h
faq.txt
license.txt
opennurbs.h
opennurbs.rc
opennurbs_3dm.h
opennurbs_3dm_attributes.h
opennurbs_3dm_properties.h
opennurbs_3dm_settings.h
opennurbs_annotation.h
opennurbs_annotation2.h
opennurbs_arc.h
opennurbs_arccurve.h
opennurbs_archive.h
opennurbs_array.h
opennurbs_array_defs.h
opennurbs_base32.h
opennurbs_base64.h
opennurbs_beam.h
opennurbs_bezier.h
opennurbs_bitmap.h
opennurbs_bounding_box.h
opennurbs_box.h
opennurbs_brep.h
opennurbs_circle.h
opennurbs_color.h
opennurbs_compress.h
opennurbs_cone.h
opennurbs_crc.h
opennurbs_curve.h
opennurbs_curveonsurface.h
opennurbs_curveproxy.h
opennurbs_cylinder.h
opennurbs_defines.h
opennurbs_detail.h
opennurbs_dimstyle.h
opennurbs_dll.cpp
opennurbs_dll_resource.h
opennurbs_ellipse.h
opennurbs_error.h
opennurbs_evaluate_nurbs.h
opennurbs_extensions.h
opennurbs_font.h
opennurbs_fpoint.h
opennurbs_fsp.h
opennurbs_fsp_defs.h
opennurbs_geometry.h
opennurbs_gl.cpp
opennurbs_gl.h
opennurbs_group.h
opennurbs_hatch.h
opennurbs_hsort_template.h
opennurbs_instance.h
opennurbs_intersect.h
opennurbs_knot.h
opennurbs_layer.h
opennurbs_light.h
opennurbs_line.h
opennurbs_linecurve.h
opennurbs_linestyle.h
opennurbs_linetype.h
opennurbs_lookup.h
opennurbs_mapchan.h
opennurbs_massprop.h
opennurbs_material.h
opennurbs_math.h
opennurbs_matrix.h
opennurbs_memory.h
opennurbs_mesh.h
opennurbs_nurbscurve.h
opennurbs_nurbssurface.h
opennurbs_object.h
opennurbs_object_history.h
opennurbs_objref.h
opennurbs_offsetsurface.h
opennurbs_optimize.h
opennurbs_plane.h
opennurbs_planesurface.h
opennurbs_pluginlist.h
opennurbs_point.h
opennurbs_pointcloud.h
opennurbs_pointgeometry.h
opennurbs_pointgrid.h
opennurbs_polycurve.h
opennurbs_polyedgecurve.h
opennurbs_polyline.h
opennurbs_polylinecurve.h
opennurbs_precompiledheader.cpp
opennurbs_qsort_template.h
opennurbs_rand.h
opennurbs_rendering.h
opennurbs_revsurface.h
opennurbs_rtree.h
opennurbs_sphere.h
opennurbs_string.h
opennurbs_sumsurface.h
opennurbs_surface.h
opennurbs_surfaceproxy.h
opennurbs_system.h
opennurbs_textlog.h
opennurbs_texture.h
opennurbs_texture_mapping.h
opennurbs_torus.h
opennurbs_unicode.h
opennurbs_userdata.h
opennurbs_uuid.h
opennurbs_version.h
opennurbs_viewport.h
opennurbs_workspace.h
opennurbs_xform.h
opennurbs_x.h
opennurbs_zlib.h
opennurbs_zlib_memory.cpp
readme.txt
)
