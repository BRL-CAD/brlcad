blob
data 134545
#                     C M A K E L I S T S . T X T
# BRL-CAD
#
# Copyright (c) 2010-2014 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
#
# 3. The name of the author may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# NOTE: BRL-CAD as a collective work is distributed under the LGPL.
#       BRL-CAD's build system is under the BSD license.
#       See the COPYING file for more details.
#
# ******************************************************************
#
# Early versions of this CMakeLists.txt file were based on the VTK
# CMakeLists.txt file, also licensed under Modified BSD.

# *******************************************************************
# ***                 BRL-CAD's CMakeLists.txt                    ***
# *******************************************************************
#
# This file defines the toplevel CMake build logic for BRL-CAD.
# As best as is reasonably possible, proper ordering and
# separation of tests and settings should be maintained per the
# recommended standard layout.  The tests should be added to the
# labeled sections below so that they are organized in stages as
# follows:
#
#   Stage 0 - information on the package and toplevel CMake settings
#   Stage 1 - define top level options
#   Stage 2 - check programs
#   Stage 3 - check compiler characteristics
#   Stage 4 - check libraries
#   Stage 5 - check headers
#   Stage 6 - check types/structures
#   Stage 7 - check functions
#   Stage 8 - check system services
#   Stage 9 - define the BRL-CAD build targets
#
# The output summary should report key information about the final
# configuration of the build.  Comprehensive information is available
# in the CMake cache file in the build directory, so just hit the
# high points in the summary.
#
# After the main configure process is finished, a summary is printed
# and various settings and configuration files that require full
# knowledge of the main configure results are handled.
#
# *******************************************************************
# ***                 Top Level Settings                          ***
# *******************************************************************
# This file contains the top level CMakeLists.txt logic for the
# BRL-CAD software package.

# We want to support a "distclean" build target that will clear all
# CMake-generated files from a source directory in the case of an
# in-source-dir configuration.  Not recommended, but we'll try to
# recover if it happens.
define_property(GLOBAL PROPERTY CMAKE_DISTCLEAN_TARGET_LIST BRIEF_DOCS "All CMake generated files" FULL_DOCS "List of all files generated by CMake")
macro(DISTCLEAN)
  foreach(item ${ARGN})
    set_property(GLOBAL APPEND PROPERTY CMAKE_DISTCLEAN_TARGET_LIST "${item}")
  endforeach(item ${ARGN})
endmacro(DISTCLEAN)

# Stash the initial CMakeCache.txt file, if it exists, for subsequent
# comparison
if(EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt)
  configure_file(${CMAKE_BINARY_DIR}/CMakeCache.txt ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev COPYONLY)
  DISTCLEAN(${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)
endif(EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt)
DISTCLEAN(${CMAKE_BINARY_DIR}/CMakeCache.txt)

# Used a variation on Fraser's approach for capturing command line args from
# http://stackoverflow.com/questions/10205986/how-to-capture-cmake-command-line-arguments
# to log what variables have been passed in from the user via -D arguments - haven't
# found a variable that saves the original ARGV list except for those defined in
# -P script mode, which doesn't help here.
get_cmake_property(VARS VARIABLES)
foreach(VAR ${VARS})
  get_property(VAR_HELPSTRING CACHE ${VAR} PROPERTY HELPSTRING)
  # Rather than look for "No help, variable specified on the command line."
  # exactly, match a slightly more robust subset...
  string(TOLOWER "${VAR_HELPSTRING}" VAR_HELPSTRING)
  if("${VAR_HELPSTRING}" MATCHES "specified on the command line")
    get_property(VAR_TYPE CACHE ${VAR} PROPERTY TYPE)
    if(NOT VAR_TYPE STREQUAL "UNINITIALIZED")
      set(VAR "${VAR}:${VAR_TYPE}")
    endif(NOT VAR_TYPE STREQUAL "UNINITIALIZED")
    set(CMAKE_ARGS "${CMAKE_ARGS} -D${VAR}=${${VAR}}")
  endif("${VAR_HELPSTRING}" MATCHES "specified on the command line")
endforeach(VAR ${VARS})
file(APPEND ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/CMakeOutput.log "${CMAKE_COMMAND} ${CMAKE_SOURCE_DIR}${CMAKE_ARGS}\n")

# Minimum required version of CMake
cmake_minimum_required(VERSION 2.8.4)
if(COMMAND CMAKE_POLICY)
  CMAKE_POLICY(SET CMP0003 NEW)
  CMAKE_POLICY(SET CMP0007 OLD)
  CMAKE_POLICY(SET CMP0017 OLD)
  if ("${CMAKE_VERSION}" VERSION_GREATER 2.99)
    CMAKE_POLICY(SET CMP0026 OLD)
  endif ("${CMAKE_VERSION}" VERSION_GREATER 2.99)
endif(COMMAND CMAKE_POLICY)

# set CMake project name
project(BRLCAD)

#---------------------------------------------------------------------
# Write out entries to populate a tm struct (will be used for time
# delta calculations later)
if(NOT BRLCAD_IS_SUBBUILD)
  set(DELTA_START "${CMAKE_BINARY_DIR}/CMakeTmp/DELTA_START")
  configure_file(${CMAKE_SOURCE_DIR}/misc/CMake/test_srcs/timedelta_start.c.in ${CMAKE_BINARY_DIR}/CMakeTmp/timedelta_start.c)
  TRY_RUN(TIME_RESULT TIME_COMPILED
    ${CMAKE_BINARY_DIR}/CMakeTmp
    ${CMAKE_BINARY_DIR}/CMakeTmp/timedelta_start.c
    OUTPUT_VARIABLE COMPILEMESSAGES)
endif(NOT BRLCAD_IS_SUBBUILD)


#---------------------------------------------------------------------
# If it exists, load a BRL-CAD_CONFIG.GLOBAL file.  This allows
# advanced users to specify options or preferences they want to always
# use by default even when doing clean BRL-CAD builds without a
# CMakeCache.txt file - for example, to always enable all local libs
# the following line can be added to BRL-CAD_CONFIG.GLOBAL:
#
# set(BRLCAD_BUNDLED_LIBS "Bundled" CACHE STRING "Enable all local libs")

# The user's configuration file can be defined by environment variable
# "BRLCAD_USER_GLOBAL_CONFIG_FILE" or, in its absence, by a file named
# "BRL-CAD_CONFIG.GLOBAL" located either above or in the BRL-CAD
# source directory.
set(BRLCAD_USER_GLOBAL_CONFIG_FILE "$ENV{BRLCAD_USER_GLOBAL_CONFIG_FILE}")
if(BRLCAD_USER_GLOBAL_CONFIG_FILE AND EXISTS ${BRLCAD_USER_GLOBAL_CONFIG_FILE})
  message("Reading user preference file '${BRLCAD_USER_GLOBAL_CONFIG_FILE}'")
  include(${BRLCAD_USER_GLOBAL_CONFIG_FILE})
elseif(EXISTS ${BRLCAD_SOURCE_DIR}/../BRL-CAD_CONFIG.GLOBAL)
  message("Reading user preference file '${BRLCAD_SOURCE_DIR}/../BRL-CAD_CONFIG.GLOBAL'")
  include(${BRLCAD_SOURCE_DIR}/../BRL-CAD_CONFIG.GLOBAL)
elseif(EXISTS ${BRLCAD_SOURCE_DIR}/BRL-CAD_CONFIG.GLOBAL)
  message("Reading user preference file '${BRLCAD_SOURCE_DIR}/BRL-CAD_CONFIG.GLOBAL'")
  include(${BRLCAD_SOURCE_DIR}/BRL-CAD_CONFIG.GLOBAL)
else(BRLCAD_USER_GLOBAL_CONFIG_FILE AND EXISTS ${BRLCAD_USER_GLOBAL_CONFIG_FILE})
  if(BRLCAD_USER_GLOBAL_CONFIG_FILE)
    message(WARNING "User preference file ${BRLCAD_USER_GLOBAL_CONFIG_FILE} specified but not found...")
  endif(BRLCAD_USER_GLOBAL_CONFIG_FILE)
endif(BRLCAD_USER_GLOBAL_CONFIG_FILE AND EXISTS ${BRLCAD_USER_GLOBAL_CONFIG_FILE})

#---------------------------------------------------------------------
# Allow the BRLCAD_ROOT environment variable to set CMAKE_INSTALL_PREFIX
# but be noisy about it.  This is generally not a good idea.
find_program(SLEEP_EXEC sleep)
mark_as_advanced(SLEEP_EXEC)
set(BRLCAD_ROOT "$ENV{BRLCAD_ROOT}")
if(BRLCAD_ROOT)
  if(NOT BRLCAD_ROOT_OVERRIDE)
    message(WARNING "}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\nBRLCAD_ROOT should only be used to override an install directory at runtime. BRLCAD_ROOT is presently set to \"${BRLCAD_ROOT}\"  It is *highly* recommended that BRLCAD_ROOT be unset and not used.\n}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}")
    if(CMAKE_INSTALL_PREFIX AND NOT CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
      if(${BRLCAD_ROOT} STREQUAL "${CMAKE_INSTALL_PREFIX}")
	message("BRLCAD_ROOT is not necessary and may cause unexpected behavior")
      else(${BRLCAD_ROOT} STREQUAL "${CMAKE_INSTALL_PREFIX}")
	message(FATAL_ERROR "BRLCAD_ROOT environment variable conflicts with CMAKE_INSTALL_PREFIX")
      endif(${BRLCAD_ROOT} STREQUAL "${CMAKE_INSTALL_PREFIX}")
    endif(CMAKE_INSTALL_PREFIX AND NOT CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
    if(SLEEP_EXEC)
      execute_process(COMMAND ${SLEEP_EXEC} 2)
    endif(SLEEP_EXEC)
  endif(NOT BRLCAD_ROOT_OVERRIDE)
endif(BRLCAD_ROOT)
if(NOT BRLCAD_ROOT_OVERRIDE)
  if(BRLCAD_ROOT STREQUAL "/usr" OR "${CMAKE_INSTALL_PREFIX}" STREQUAL "/usr")
    message(WARNING "}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\nIt is STRONGLY recommended that you DO NOT install BRL-CAD into /usr as BRL-CAD provides several libraries that may conflict with other libraries (e.g. librt, libbu, libbn) on certain system configurations.\nSince our libraries predate all those that we're known to conflict with and are at the very core of our geometry services and project heritage, we have no plans to change the names of our libraries at this time.\nINSTALLING INTO /usr CAN MAKE A SYSTEM COMPLETELY UNUSABLE.  If you choose to continue installing into /usr, you do so entirely at your own risk.  You have been warned.\n}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}")
    if(SLEEP_EXEC)
      message("Pausing 15 seconds...")
      execute_process(COMMAND ${SLEEP_EXEC} 15)
    endif(SLEEP_EXEC)
    if(${CMAKE_INSTALL_PREFIX} STREQUAL "/usr")
      message(FATAL_ERROR "If you wish to proceed using /usr as your prefix, define BRLCAD_ROOT_OVERRIDE=1 for CMake")
    endif(${CMAKE_INSTALL_PREFIX} STREQUAL "/usr")
  endif(BRLCAD_ROOT STREQUAL "/usr" OR "${CMAKE_INSTALL_PREFIX}" STREQUAL "/usr")
endif(NOT BRLCAD_ROOT_OVERRIDE)

# While we're at it, complain if BRLCAD_DATA is set
set(BRLCAD_DATA_ENV "$ENV{BRLCAD_DATA}")
if(BRLCAD_DATA_ENV)
  message(WARNING "}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}\nBRLCAD_DATA should only be used to override an install directory at runtime. BRLCAD_DATA is presently set to \"${BRLCAD_DATA_ENV}\"  It is *highly* recommended that BRLCAD_DATA be unset and not used.\n}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}")
  if(SLEEP_EXEC)
    execute_process(COMMAND ${SLEEP_EXEC} 2)
  endif(SLEEP_EXEC)
endif(BRLCAD_DATA_ENV)

#---------------------------------------------------------------------
# Load general utility routines for BRL-CAD CMake logic
include(${CMAKE_SOURCE_DIR}/misc/CMake/BRLCAD_Util.cmake)

# Define CMake routines for bookkeeping of build files
include(${CMAKE_SOURCE_DIR}/misc/CMake/BRLCAD_CMakeFiles.cmake)

# Make sure the BRL-CAD library list is initialized empty - this way
# if pieces are disabled between one configure and the next, they
# won't linger in the list
set(BRLCAD_LIBS "" CACHE STRING "BRL-CAD libraries" FORCE)


#---------------------------------------------------------------------
# Define the current BRL-CAD version.
# See HACKING for details on how to properly update the version

file(READ ${BRLCAD_SOURCE_DIR}/include/conf/MAJOR BRLCAD_VERSION_MAJOR)
string(STRIP ${BRLCAD_VERSION_MAJOR} BRLCAD_VERSION_MAJOR)
file(READ ${BRLCAD_SOURCE_DIR}/include/conf/MINOR BRLCAD_VERSION_MINOR)
string(STRIP ${BRLCAD_VERSION_MINOR} BRLCAD_VERSION_MINOR)
file(READ ${BRLCAD_SOURCE_DIR}/include/conf/PATCH BRLCAD_VERSION_PATCH)
string(STRIP ${BRLCAD_VERSION_PATCH} BRLCAD_VERSION_PATCH)

set(BRLCAD_VERSION "${BRLCAD_VERSION_MAJOR}.${BRLCAD_VERSION_MINOR}.${BRLCAD_VERSION_PATCH}")


#---------------------------------------------------------------------
# CMake derives much of its functionality from modules, typically
# stored in one directory - let CMake know where to find them.  If we
# are a subbuild, let the parent's CMAKE_MODULE_PATH supply files before
# our own, otherwise misc/CMake takes first priority.
set(BRLCAD_CMAKE_DIR "${BRLCAD_SOURCE_DIR}/misc/CMake")
if(BRLCAD_IS_SUBBUILD)
  set(CMAKE_MODULE_PATH "${CMAKE_MODULE_PATH};${BRLCAD_CMAKE_DIR}")
else(BRLCAD_IS_SUBBUILD)
  set(CMAKE_MODULE_PATH "${BRLCAD_CMAKE_DIR};${CMAKE_MODULE_PATH}")
endif(BRLCAD_IS_SUBBUILD)

#---------------------------------------------------------------------
# Define relative install locations and output directories.  Don't set
# these if they have already been set by some other means (like a
# higher level CMakeLists.txt file including this one).
# For output directories - where built library and executable
# files will be placed after building but prior to install.  The
# necessary variables change between single and multi configuration
# build systems, so it is necessary to handle both cases on a
# conditional basis.

include(${BRLCAD_CMAKE_DIR}/Path_Setup.cmake)

#---------------------------------------------------------------------
# Searching the system for packages presents something of a dilemma -
# in most situations it is Very Bad for a BRL-CAD build to be using
# older versions of libraries in install directories as search results.
# Generally, the desired behavior is to ignore whatever libraries are
# in the install directories, and only use external library results if
# they are something already found on the system due to non-BRL-CAD
# installation (source compile, package managers, etc.).  Unfortunately,
# CMake's standard behavior is to add CMAKE_INSTALL_PREFIX to the search
# path once defined, resulting in (for us) the unexpected behavior of
# returning old installed libraries when CMake is re-run in a directory.
#
# To work around this, there are two possible approaches.  One,
# identified by Maik Beckmann, operates on CMAKE_SYSTEM_PREFIX_PATH:
#
# http://www.cmake.org/pipermail/cmake/2010-October/040292.html
#
# The other, pointed out by Michael Hertling, uses the
# CMake_[SYSTEM_]IGNORE_PATH variables.
#
# http://www.cmake.org/pipermail/cmake/2011-May/044503.html
#
# BRL-CAD initially operated on CMAKE_SYSTEM_PREFIX_PATH, but has
# switched to using the *_IGNORE_PATH variables.  This requires
# CMake 2.8.3 or later.
#
# The complication with ignoring install paths is if we are
# installing to a "legitimate" system search path - i.e. our
# CMAKE_INSTALL_PREFIX value is standard enough that it is a legitimate
# search target for find_package. In this case, we can't exclude
# accidental hits on our libraries without also excluding legitimate
# find_package results.  So the net results are:
#
# 1.  If you are planning to install to a system directory (typically
#     a bad idea but the settings are legal) clean out the old system
#     first or accept that the old libraries will be found and used.
#
# 2.  For more custom paths, the logic below will avoid the value
#     of CMAKE_INSTALL_PREFIX in find_package searches
#
# (Note:  CMAKE_INSTALL_PREFIX must be checked in the case where someone
# sets it on the command line prior to CMake being run.  BRLCAD_PREFIX
# preserves the CMAKE_INSTALL_PREFIX setting from the previous CMake run.
# CMAKE_INSTALL_PREFIX does not seem to be immediately set in this context
# when CMake is re-run unless specified explicitly on the command line.
# To ensure the previous (and internally set) CMAKE_INSTALL_PREFIX value
# is available, BRLCAD_PREFIX is used to store the value in the cache.)

if(CMAKE_INSTALL_PREFIX)
  if(NOT ${CMAKE_INSTALL_PREFIX} STREQUAL "/usr" AND NOT ${CMAKE_INSTALL_PREFIX} STREQUAL "/usr/local")
    get_filename_component(PATH_NORMALIZED ${CMAKE_INSTALL_PREFIX}/${LIB_DIR} ABSOLUTE)
    set(CMAKE_SYSTEM_IGNORE_PATH ${PATH_NORMALIZED})
  endif(NOT ${CMAKE_INSTALL_PREFIX} STREQUAL "/usr" AND NOT ${CMAKE_INSTALL_PREFIX} STREQUAL "/usr/local")
endif(CMAKE_INSTALL_PREFIX)
if(BRLCAD_PREFIX)
  if(NOT ${BRLCAD_PREFIX} STREQUAL "/usr" AND NOT ${BRLCAD_PREFIX} STREQUAL "/usr/local")
    get_filename_component(PATH_NORMALIZED ${BRLCAD_PREFIX}/${LIB_DIR} ABSOLUTE)
    set(CMAKE_SYSTEM_IGNORE_PATH ${PATH_NORMALIZED})
  endif(NOT ${BRLCAD_PREFIX} STREQUAL "/usr" AND NOT ${BRLCAD_PREFIX} STREQUAL "/usr/local")
endif(BRLCAD_PREFIX)
mark_as_advanced(CMAKE_SYSTEM_IGNORE_PATH)

#---------------------------------------------------------------------
# For cleaning files as part of the distclean command, CMake needs
# to be aware of what various generators will (or might) write out
# in each build directory.
set(DISTCLEAN_OUTFILES
  CTestTestfile.cmake
  Testing/Temporary/CTestCostData.txt
  Testing/Temporary/LastTest.log
  )
if("${CMAKE_GENERATOR}" MATCHES "Make")
  set(DISTCLEAN_OUTFILES ${DISTCLEAN_OUTFILES} Makefile)
endif("${CMAKE_GENERATOR}" MATCHES "Make")
if("${CMAKE_GENERATOR}" MATCHES "Ninja")
  set(DISTCLEAN_OUTFILES ${DISTCLEAN_OUTFILES} build.ninja rules.ninja)
endif("${CMAKE_GENERATOR}" MATCHES "Ninja")

#---------------------------------------------------------------------
# By default (as of version 2.8.2) CMake does not provide access to
# global lists of executable and library targets.  This is useful
# in a number of situations related to formulating custom rules and
# target dependency management.  To avoid the necessity of replacing
# add_library and add_executable calls with custom macros, override
# the function names and call the _add_* functions to access the CMake
# functionality previously available under the add_* functions. See
# http://www.cmake.org/pipermail/cmake/2010-September/039388.html

# To allow a hypothetical parent build to disable this mechanism and
# replace it, we wrap the whole show in an IF conditional.  To avoid
# the distcheck setup, the parent file should define the variable
# BRLCAD_IS_SUBBUILD to ON.  Note that this also disables the
# liblib prefix check in add_library, making that the responsibility
# of the parent build as well, and disables the mechanism for ensuring
# that the timing code runs at the correct points during the build.

# We also need to provide bookkeeping logic here for the distribution
# verification or "distcheck" routines that will validate the state
# of the source tree against that expected and accounted for in the
# build files.  The global coverage needed for the purpose results in
# the add_library/add_executable command override mechanism having
# to serve two purposes at once; since we only override these functions
# once the logic for both jobs is intertwined below.

if(NOT BRLCAD_IS_SUBBUILD)
  # Functions in CMake have local variable scope,
  # hence the use of properties to allow access to directory-specific
  # and global information scopes.
  define_property(GLOBAL PROPERTY CMAKE_LIBRARY_TARGET_LIST BRIEF_DOCS "libtarget list" FULL_DOCS "Library target list")
  define_property(GLOBAL PROPERTY CMAKE_EXEC_TARGET_LIST BRIEF_DOCS "exec target list" FULL_DOCS "Executable target list")
  define_property(GLOBAL PROPERTY CMAKE_CUSTOM_TARGET_LIST BRIEF_DOCS "custom target list" FULL_DOCS "Custom target list")
  define_property(GLOBAL PROPERTY CMAKE_EXTERNAL_TARGET_LIST BRIEF_DOCS "external target list" FULL_DOCS "External target list")
  mark_as_advanced(CMAKE_LIBRARY_TARGET_LIST)
  mark_as_advanced(CMAKE_EXEC_TARGET_LIST)
  mark_as_advanced(CMAKE_CUSTOM_TARGET_LIST)
  mark_as_advanced(CMAKE_EXTERNAL_TARGET_LIST)

  # Override and wrap add_library.  While we're at it, avoid doubling up
  # on the lib prefix for libraries if the target name is lib<target>
  function(add_library name)
    _add_library(${name} ${ARGN})
    CMAKEFILES(${ARGN})
    if(${name} MATCHES "^lib*")
      set_target_properties(${name} PROPERTIES PREFIX "")
    endif(${name} MATCHES "^lib*")
    set_property(GLOBAL APPEND PROPERTY CMAKE_LIBRARY_TARGET_LIST ${name})
  endfunction(add_library)

  # Override and wrap add_executable
  function(add_executable name)
    _add_executable(${name} ${ARGN})
    CMAKEFILES(${ARGN})
    set_property(GLOBAL APPEND PROPERTY CMAKE_EXEC_TARGET_LIST ${name})
  endfunction(add_executable)

  # Override and wrap add_custom_target
  function(add_custom_target name)
    _add_custom_target(${name} ${ARGN})
    set_property(GLOBAL APPEND PROPERTY CMAKE_CUSTOM_TARGET_LIST ${name})
  endfunction(add_custom_target)

  # Note that at the moment we do not need to override CMake's external
  # project mechanisms because CMake does not use them, but if that changes
  # in the future an override will need to be added here - probably of the
  # ExternalProject_Add functionality.

  # Override and wrap configure_file.  In the case of configure_file, we'll
  # check that the file is part of the source tree and not itself a
  # generated file, but not reject full-path entries since there are quite a
  # few of them. This means that, unlike CMAKEFILES's reliance on full vs.
  # relative path comparisons, generated files supplied to configure_file
  # need to have the GENERATED property set in order to reliably tell which
  # files should be added to the build system's lists.  Not
  # so critical with not-in-src-dir builds, but makes a big difference
  # spotting files to avoid when all generated files have source directory
  # prefixes.
  function(configure_file file targetfile)
    _configure_file(${file} ${targetfile} ${ARGN})
    # Tag output from configure with the GENERATED tag
    set_source_files_properties(${targetfile} PROPERTIES GENERATED TRUE)
    # If it's a generated file, don't register it
    get_property(IS_GENERATED SOURCE ${file} PROPERTY GENERATED)
    if(NOT IS_GENERATED)
      get_filename_component(item_absolute ${file} ABSOLUTE)
      # If we're not in the source dir, we can do some extra checking.
      if(NOT "${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_BINARY_DIR}")
	IS_SUBPATH("${CMAKE_BINARY_DIR}" "${item_absolute}" SUBPATH_TEST)
      else(NOT "${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_BINARY_DIR}")
	set(SUBPATH_TEST "0")
      endif(NOT "${CMAKE_SOURCE_DIR}" STREQUAL "${CMAKE_BINARY_DIR}")
      if("${SUBPATH_TEST}" STREQUAL "0")
	IS_SUBPATH("${CMAKE_SOURCE_DIR}" "${item_absolute}" SUBPATH_TEST)
	if("${SUBPATH_TEST}" STREQUAL "1")
	  set_property(GLOBAL APPEND PROPERTY CMAKE_IGNORE_FILES "${item_absolute}")
	endif("${SUBPATH_TEST}" STREQUAL "1")
      else("${SUBPATH_TEST}" STREQUAL "0")
	message(WARNING "The generated file ${file} is passed to configure_file but does not have the GENERATED source file property set in CMake.  It is HIGHLY recommended that the generated property be set for this file in ${CMAKE_CURRENT_SOURCE_DIR}/CMakeLists.txt using a command with the following form:\nset_source_files_properties(<file> PROPERTIES GENERATED TRUE)\n(or in ${CMAKE_SOURCE_DIR}/src/other/CMakeLists.txt for third party components with their own build system.)\n")
      endif("${SUBPATH_TEST}" STREQUAL "0")
    endif(NOT IS_GENERATED)
    if(NOT ${targetfile} MATCHES "distclean")
      DISTCLEAN(${targetfile})
    endif(NOT ${targetfile} MATCHES "distclean")
  endfunction(configure_file)

  # Override and wrap add_subdirectory.
  function(add_subdirectory name)
    _add_subdirectory(${name} ${ARGN})
    set_property(GLOBAL APPEND PROPERTY CMAKE_IGNORE_FILES "${CMAKE_CURRENT_SOURCE_DIR}/${name}")
    set_property(GLOBAL APPEND PROPERTY CMAKE_IGNORE_FILES "${CMAKE_CURRENT_SOURCE_DIR}/${name}/CMakeLists.txt")
    DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/${name}/CMakeFiles)
    DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/${name}/cmake_install.cmake)
    foreach(clearpattern ${DISTCLEAN_OUTFILES})
      DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/${name}/${clearpattern})
    endforeach(clearpattern ${DISTCLEAN_OUTFILES})
  endfunction(add_subdirectory)

endif(NOT BRLCAD_IS_SUBBUILD)

# We wrap the message function to also append ALL messages to CMakeOutput.log,
# as well as printing them on the console output.
if(NOT BRLCAD_IS_SUBBUILD)
  function(message)
    _message(${ARGN})
    string(REPLACE ";" ": " msg "${ARGV}")
    file(APPEND ${BRLCAD_BINARY_DIR}/CMakeFiles/CMakeOutput.log "${msg}\n")
  endfunction(message)
endif(NOT BRLCAD_IS_SUBBUILD)

#---------------------------------------------------------------------
# Load macros that will be used to define the BRL-CAD
# build logic
include(${BRLCAD_CMAKE_DIR}/BRLCAD_Options.cmake)
include(${BRLCAD_CMAKE_DIR}/BRLCAD_Targets.cmake)
include(CheckTypeSize)
include(CheckCSourceCompiles)
include(CheckCXXSourceCompiles)

#---------------------------------------------------------------------
# Save the current LC_ALL, LC_MESSAGES, and LANG environment variables
# and set them to "C" so things like date output are as expected.
set(_orig_lc_all      $ENV{LC_ALL})
set(_orig_lc_messages $ENV{LC_MESSAGES})
set(_orig_lang        $ENV{LANG})
if(_orig_lc_all)
  set(ENV{LC_ALL}      C)
endif(_orig_lc_all)
if(_orig_lc_messages)
  set(ENV{LC_MESSAGES} C)
endif(_orig_lc_messages)
if(_orig_lang)
  set(ENV{LANG}        C)
endif(_orig_lang)

#---------------------------------------------------------------------
# Package creation with CMake depends on the value of umask - if permissions
# are such that temporary files are created without permissions needed for
# generated packages, the resulting packages may behave badly when installed.
# In particular, RPM packages may improperly reset permissions on core
# directories such as /usr.
macro(CHECK_UMASK umask_val status_var)
  string(REGEX REPLACE "[^x]" "" umask_x "${umask_val}")
  string(REGEX REPLACE "[^r]" "" umask_r "${umask_val}")
  string(LENGTH "${umask_r}" UMASK_HAVE_R)
  set(${status_var} 0)
  if(UMASK_HAVE_R AND "${umask_x}" STREQUAL "xxx")
    set(${status_var} 1)
  endif(UMASK_HAVE_R AND "${umask_x}" STREQUAL "xxx")
endmacro(CHECK_UMASK)
# Note - umask is not always an executable, so we can't use find_program
# to determine whether the umask check is appropriate.
IF(NOT WIN32)
  exec_program(umask ARGS -S OUTPUT_VARIABLE umask_curr)
  string(STRIP "${umask_curr}" umask_curr)
  CHECK_UMASK("${umask_curr}" UMASK_OK)
  if (NOT UMASK_OK)
    message(" ")
    message(WARNING "umask is set to ${umask_curr} - this setting is not recommended if one of the goals of this build is to generate packages. Use 'umask 022' for improved package behavior.")
    if(SLEEP_EXEC)
      execute_process(COMMAND ${SLEEP_EXEC} 1)
    endif(SLEEP_EXEC)
  endif (NOT UMASK_OK)
ENDIF(NOT WIN32)

#---------------------------------------------------------------------
# Unfortunately, CMake doesn't give you variables with current day,
# month, etc.  There are several possible approaches to this, but most
# (e.g. the date command) are not cross platform. We build a small C
# file which writes out the needed values to files in the build
# directory. Those files are then read and stripped by CMake.
set(CONFIG_TIME_DAY_FILE "${BRLCAD_BINARY_DIR}/include/conf/CONFIG_TIME_DAY")
set(CONFIG_TIME_MONTH_FILE "${BRLCAD_BINARY_DIR}/include/conf/CONFIG_TIME_MONTH")
set(CONFIG_TIME_YEAR_FILE "${BRLCAD_BINARY_DIR}/include/conf/CONFIG_TIME_YEAR")
set(CONFIG_TIMESTAMP_FILE "${BRLCAD_BINARY_DIR}/include/conf/CONFIG_TIMESTAMP")
DISTCLEAN(${CONFIG_TIME_DAY_FILE} ${CONFIG_TIME_MONTH_FILE}
  ${CONFIG_TIME_YEAR_FILE} ${CONFIG_TIMESTAMP_FILE})
file(MAKE_DIRECTORY "${BRLCAD_BINARY_DIR}/include")
file(MAKE_DIRECTORY "${BRLCAD_BINARY_DIR}/include/conf")
configure_file(${BRLCAD_CMAKE_DIR}/test_srcs/time.c.in ${CMAKE_BINARY_DIR}/CMakeTmp/time.c)
TRY_RUN(TIME_RESULT TIME_COMPILED
  ${CMAKE_BINARY_DIR}/CMakeTmp
  ${CMAKE_BINARY_DIR}/CMakeTmp/time.c
  OUTPUT_VARIABLE COMPILEMESSAGES)
if(TIME_RESULT MATCHES "^0$")
  file(READ ${CONFIG_TIME_DAY_FILE} CONFIG_DAY)
  string(STRIP ${CONFIG_DAY} CONFIG_DAY)
  file(READ ${CONFIG_TIME_MONTH_FILE} CONFIG_MONTH)
  string(STRIP ${CONFIG_MONTH} CONFIG_MONTH)
  file(READ ${CONFIG_TIME_YEAR_FILE} CONFIG_YEAR)
  string(STRIP ${CONFIG_YEAR} CONFIG_YEAR)
  set(CONFIG_DATE "${CONFIG_YEAR}${CONFIG_MONTH}${CONFIG_DAY}")
else(TIME_RESULT MATCHES "^0$")
  message(FATAL_ERROR "Code to determine current date and time failed!\n")
endif(TIME_RESULT MATCHES "^0$")

#---------------------------------------------------------------------
# print out the title with a pretty box computed to wrap around
BOX_PRINT("*** Configuring BRL-CAD Release ${BRLCAD_VERSION}, Build ${CONFIG_DATE} ***" "*")

#---------------------------------------------------------------------
# CMake by default provides four different configurations for multi-
# configuration build tools.  We want only two - Debug and Release.
if(CMAKE_CONFIGURATION_TYPES AND NOT "${CMAKE_CONFIGURATION_TYPES}" STREQUAL "Debug;Release")
  set(CMAKE_CONFIGURATION_TYPES "Debug;Release" CACHE STRING "Allowed BRL-CAD configuration types" FORCE)
endif(CMAKE_CONFIGURATION_TYPES AND NOT "${CMAKE_CONFIGURATION_TYPES}" STREQUAL "Debug;Release")

#---------------------------------------------------------------------
# We want to check /usr/local by default, so add it
set(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH} /usr/local)
set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES} /usr/local/include)

#---------------------------------------------------------------------

# Normalize the build type capitalization
if(CMAKE_BUILD_TYPE)
  string(TOUPPER "${CMAKE_BUILD_TYPE}" BUILD_TYPE_UPPER)
  if ("${BUILD_TYPE_UPPER}" STREQUAL "RELEASE")
    set(CMAKE_BUILD_TYPE "Release" CACHE STRING "Build Type" FORCE)
  endif ("${BUILD_TYPE_UPPER}" STREQUAL "RELEASE")
  if ("${BUILD_TYPE_UPPER}" STREQUAL "DEBUG")
    set(CMAKE_BUILD_TYPE "Debug" CACHE STRING "Build Type" FORCE)
  endif ("${BUILD_TYPE_UPPER}" STREQUAL "DEBUG")
endif(CMAKE_BUILD_TYPE)
# Stash the build type so we can set up a drop-down menu in the gui
if(NOT BRLCAD_IS_SUBBUILD)
  set(CMAKE_BUILD_TYPE "${CMAKE_BUILD_TYPE}" CACHE STRING "BRL-CAD high level build configuration")
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "" Debug Release)
endif(NOT BRLCAD_IS_SUBBUILD)

#---------------------------------------------------------------------
# The location in which to install BRL-CAD.  Only do this if
# CMAKE_INSTALL_PREFIX hasn't been set already, to try and allow
# parent builds (if any) some control.
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT OR NOT CMAKE_INSTALL_PREFIX)
  if(NOT CMAKE_CONFIGURATION_TYPES)
    if("${CMAKE_BUILD_TYPE}" MATCHES "Release")
      set(CMAKE_INSTALL_PREFIX "/usr/brlcad/rel-${BRLCAD_VERSION}")
    else("${CMAKE_BUILD_TYPE}" MATCHES "Release")
      set(CMAKE_INSTALL_PREFIX "/usr/brlcad/dev-${BRLCAD_VERSION}")
    endif("${CMAKE_BUILD_TYPE}" MATCHES "Release")
  else(NOT CMAKE_CONFIGURATION_TYPES)
    if(MSVC)
      if(CMAKE_CL_64)
	set(CMAKE_INSTALL_PREFIX "C:/Program Files/BRL-CAD ${BRLCAD_VERSION}")
      else(CMAKE_CL_64)
	set(CMAKE_INSTALL_PREFIX "C:/Program Files (x86)/BRL-CAD ${BRLCAD_VERSION}")
      endif(CMAKE_CL_64)
    else(MSVC)
      set(CMAKE_INSTALL_PREFIX "/usr/brlcad/dev-${BRLCAD_VERSION}")
    endif(MSVC)
  endif(NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_INSTALL_PREFIX ${CMAKE_INSTALL_PREFIX} CACHE PATH "BRL-CAD install prefix" FORCE)
  set(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT 0)
endif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT OR NOT CMAKE_INSTALL_PREFIX)
set(BRLCAD_PREFIX ${CMAKE_INSTALL_PREFIX} CACHE STRING "BRL-CAD install prefix")
mark_as_advanced(BRLCAD_PREFIX)

# If we've a Release build with a Debug path or vice versa, warn about
# it.  A "make install" of a Release build into a dev install
# directory or vice versa is going to result in an install that
# doesn't respect BRL-CAD standard naming conventions.
if("${CMAKE_BUILD_TYPE}" MATCHES "Release" AND ${CMAKE_INSTALL_PREFIX} STREQUAL "/usr/brlcad/dev-${BRLCAD_VERSION}")
  message(FATAL_ERROR "\nInstallation directory (CMAKE_INSTALL_PREFIX) is set to /usr/brlcad/dev-${BRLCAD_VERSION}, but build type is set to Release!\n")
endif("${CMAKE_BUILD_TYPE}" MATCHES "Release" AND ${CMAKE_INSTALL_PREFIX} STREQUAL "/usr/brlcad/dev-${BRLCAD_VERSION}")
if("${CMAKE_BUILD_TYPE}" MATCHES "Debug" AND ${CMAKE_INSTALL_PREFIX} STREQUAL "/usr/brlcad/rel-${BRLCAD_VERSION}")
  message(FATAL_ERROR "\nInstallation directory (CMAKE_INSTALL_PREFIX) is set to /usr/brlcad/rel-${BRLCAD_VERSION}, but build type is set to Debug!\n")
endif("${CMAKE_BUILD_TYPE}" MATCHES "Debug" AND ${CMAKE_INSTALL_PREFIX} STREQUAL "/usr/brlcad/rel-${BRLCAD_VERSION}")

#---------------------------------------------------------------------
# The following logic is what allows binaries to run successfully in
# the build directory AND install directory.  Thanks to plplot for
# identifying the necessity of setting CMAKE_INSTALL_NAME_DIR on OSX.
# Documentation of these options is available at
# http://www.cmake.org/Wiki/CMake_RPATH_handling

include(${BRLCAD_CMAKE_DIR}/RPath_Setup.cmake)

#---------------------------------------------------------------------
# We will need a brlcad_config.h.in file to hold all the #cmakedefine
# statements, which will in turn be used to generate a brlcad_conf.h
# file.  In autotools this process is handled by autoheader - in the
# case of CMake we wrap the CHECK_* functions and the creation of the
# entry in the brlcad_config.h.in file into one step via a macro.
#
# To avoid hitting the disk I/O any harder than necessary, we store
# the eventual contents of brlcad_config.h.in as a CMake string until
# it is ready to process.  A global property is needed to hold the
# contents, because subdirectories (in particular, src/other) may
# have content to contribute to the top level config.h.in file and
# the default local variable scope in subdirectories means those
# changes would not automatically propagate back up.
#
# We also allow for multiple projects with this macro, in case
# subprojects are also managing a config.h.in a file of their own.

set(CONFIG_H_FILE "${BRLCAD_BINARY_DIR}/include/brlcad_config.h.in")
set_source_files_properties(${CONFIG_H_FILE} PROPERTIES GENERATED TRUE)

set(CMAKE_CURRENT_PROJECT BRLCAD)

define_property(GLOBAL PROPERTY BRLCAD_CONFIG_H_CONTENTS BRIEF_DOCS "config.h.in contents" FULL_DOCS "config.h.in contents for BRL-CAD project")
if(NOT COMMAND CONFIG_H_APPEND)
  macro(CONFIG_H_APPEND PROJECT_NAME NEW_CONTENTS)
    if(PROJECT_NAME)
      get_property(${PROJECT_NAME}_CONFIG_H_CONTENTS GLOBAL PROPERTY ${PROJECT_NAME}_CONFIG_H_CONTENTS)
      set(${PROJECT_NAME}_CONFIG_H_FILE_CONTENTS "${${PROJECT_NAME}_CONFIG_H_CONTENTS}${NEW_CONTENTS}")
      set_property(GLOBAL PROPERTY ${PROJECT_NAME}_CONFIG_H_CONTENTS "${${PROJECT_NAME}_CONFIG_H_FILE_CONTENTS}")
    endif(PROJECT_NAME)
  endmacro(CONFIG_H_APPEND NEW_CONTENTS)
endif(NOT COMMAND CONFIG_H_APPEND)

CONFIG_H_APPEND(BRLCAD "/**** Define statements for CMake ****/\n")
CONFIG_H_APPEND(BRLCAD "#ifndef __CONFIG_H__\n")
CONFIG_H_APPEND(BRLCAD "#define __CONFIG_H__\n")

# Set up some of the define statements for path information and other basics
CONFIG_H_APPEND(BRLCAD "#define PACKAGE \"brlcad\"\n")
CONFIG_H_APPEND(BRLCAD "#define PACKAGE_BUGREPORT \"http://brlcad.org\"\n")
CONFIG_H_APPEND(BRLCAD "#define PACKAGE_NAME \"BRL-CAD\"\n")
CONFIG_H_APPEND(BRLCAD "#define PACKAGE_STRING \"BRL-CAD ${BRLCAD_VERSION}\"\n")
CONFIG_H_APPEND(BRLCAD "#define PACKAGE_TARNAME \"brlcad\"\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_DATA \"${CMAKE_INSTALL_PREFIX}/${DATA_DIR}\"\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_ROOT \"${CMAKE_INSTALL_PREFIX}\"\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_BIN_DIR \"${BIN_DIR}\"\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_LIB_DIR \"${LIB_DIR}\"\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_INCLUDE_DIR \"${INCLUDE_DIR}\"\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_DATA_DIR \"${DATA_DIR}\"\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_DOC_DIR \"${DOC_DIR}\"\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_MAN_DIR \"${MAN_DIR}\"\n")

# Write out our version information
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_VERSION_MAJOR ${BRLCAD_VERSION_MAJOR}\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_VERSION_MINOR ${BRLCAD_VERSION_MINOR}\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_VERSION_PATCH ${BRLCAD_VERSION_PATCH}\n")


#----------------------------------------------------------------------
# Decide whether to do a 32 or a 64 bit build.

set(WORD_SIZE_LABEL "Compile as 32BIT or 64BIT?")
if(NOT BRLCAD_WORD_SIZE)
  set(BRLCAD_WORD_SIZE "AUTO" CACHE STRING WORD_SIZE_LABEL)
endif(NOT BRLCAD_WORD_SIZE)
set_property(CACHE BRLCAD_WORD_SIZE PROPERTY STRINGS AUTO 32BIT 64BIT)
string(TOUPPER "${BRLCAD_WORD_SIZE}" BRLCAD_WORD_SIZE_UPPER)
set(BRLCAD_WORD_SIZE "${BRLCAD_WORD_SIZE_UPPER}" CACHE STRING WORD_SIZE_LABEL FORCE)
if(NOT BRLCAD_WORD_SIZE MATCHES "AUTO" AND NOT BRLCAD_WORD_SIZE MATCHES "64BIT" AND NOT BRLCAD_WORD_SIZE MATCHES "32BIT")
  message(WARNING "Unknown value ${BRLCAD_WORD_SIZE} supplied for BRLCAD_WORD_SIZE - defaulting to AUTO")
  message(WARNING "Valid options are AUTO, 32BIT and 64BIT")
  set(BRLCAD_WORD_SIZE "AUTO" CACHE STRING WORD_SIZE_LABEL FORCE)
endif(NOT BRLCAD_WORD_SIZE MATCHES "AUTO" AND NOT BRLCAD_WORD_SIZE MATCHES "64BIT" AND NOT BRLCAD_WORD_SIZE MATCHES "32BIT")
# On Windows, we can't set word size at CMake configure time - the
# compiler chosen at the beginning dictates the result.  Mark as
# advanced in that situation.
if(MSVC)
  mark_as_advanced(BRLCAD_WORD_SIZE)
endif(MSVC)

# calculate the size of a pointer if we haven't already
CHECK_TYPE_SIZE("void *" CMAKE_SIZEOF_VOID_P)

# still not defined?
if(NOT CMAKE_SIZEOF_VOID_P)
  message(WARNING "CMAKE_SIZEOF_VOID_P is not defined - assuming 32 bit platform")
  set(CMAKE_SIZEOF_VOID_P 4)
endif(NOT CMAKE_SIZEOF_VOID_P)

if(${BRLCAD_WORD_SIZE} MATCHES "AUTO")
  if(${CMAKE_SIZEOF_VOID_P} MATCHES "^8$")
    set(CMAKE_WORD_SIZE "64BIT")
    set(BRLCAD_WORD_SIZE "64BIT (AUTO)" CACHE STRING WORD_SIZE_LABEL FORCE)
  else(${CMAKE_SIZEOF_VOID_P} MATCHES "^8$")
    if(${CMAKE_SIZEOF_VOID_P} MATCHES "^4$")
      set(CMAKE_WORD_SIZE "32BIT")
      set(BRLCAD_WORD_SIZE "32BIT (AUTO)" CACHE STRING WORD_SIZE_LABEL FORCE)
    else(${CMAKE_SIZEOF_VOID_P} MATCHES "^4$")
      if(${CMAKE_SIZEOF_VOID_P} MATCHES "^2$")
	set(CMAKE_WORD_SIZE "16BIT")
	set(BRLCAD_WORD_SIZE "16BIT (AUTO)" CACHE STRING WORD_SIZE_LABEL FORCE)
      else(${CMAKE_SIZEOF_VOID_P} MATCHES "^2$")
	set(CMAKE_WORD_SIZE "8BIT")
	set(BRLCAD_WORD_SIZE "8BIT (AUTO)" CACHE STRING WORD_SIZE_LABEL FORCE)
      endif(${CMAKE_SIZEOF_VOID_P} MATCHES "^2$")
    endif(${CMAKE_SIZEOF_VOID_P} MATCHES "^4$")
  endif(${CMAKE_SIZEOF_VOID_P} MATCHES "^8$")
else(${BRLCAD_WORD_SIZE} MATCHES "AUTO")
  set(CMAKE_WORD_SIZE "${BRLCAD_WORD_SIZE}")
endif(${BRLCAD_WORD_SIZE} MATCHES "AUTO")
CONFIG_H_APPEND(BRLCAD "#define SIZEOF_VOID_P ${CMAKE_SIZEOF_VOID_P}\n")

# Enable/disable 64-bit build settings for MSVC, which is apparently
# determined at the CMake generator level - need to override other
# settings if the compiler disagrees with them.
if(MSVC)
  if(CMAKE_CL_64)
    if(NOT ${CMAKE_WORD_SIZE} MATCHES "64BIT")
      set(CMAKE_WORD_SIZE "64BIT")
      if(NOT "${BRLCAD_WORD_SIZE}" MATCHES "AUTO")
	message(WARNING "Selected MSVC compiler is 64BIT - setting word size to 64BIT.  To perform a 32BIT MSVC build, select the 32BIT MSVC CMake generator.")
	set(BRLCAD_WORD_SIZE "64BIT" CACHE STRING WORD_SIZE_LABEL FORCE)
      endif(NOT "${BRLCAD_WORD_SIZE}" MATCHES "AUTO")
    endif(NOT ${CMAKE_WORD_SIZE} MATCHES "64BIT")
    add_definitions("-D_WIN64")
  else(CMAKE_CL_64)
    if(NOT ${CMAKE_WORD_SIZE} MATCHES "32BIT")
      set(CMAKE_WORD_SIZE "32BIT")
      if(NOT "${BRLCAD_WORD_SIZE}" MATCHES "AUTO")
	message(WARNING "Selected MSVC compiler is 32BIT - setting word size to 32BIT.  To perform a 64BIT MSVC build, select the 64BIT MSVC CMake generator.")
	set(BRLCAD_WORD_SIZE "32BIT" CACHE STRING WORD_SIZE_LABEL FORCE)
      endif(NOT "${BRLCAD_WORD_SIZE}" MATCHES "AUTO")
    endif(NOT ${CMAKE_WORD_SIZE} MATCHES "32BIT")
  endif(CMAKE_CL_64)
endif(MSVC)

# Based on what we are doing, we may need to constrain our search paths
#
# NOTE: Ideally we would set a matching property for 32 bit paths
# on systems that default to 64 bit - as of 2.8.8 CMake doesn't yet
# support FIND_LIBRARY_USE_LIB32_PATHS.  There is a bug report on the
# topic here: http://www.cmake.org/Bug/view.php?id=11260
#
if(${CMAKE_WORD_SIZE} MATCHES "32BIT")
  set_property(GLOBAL PROPERTY FIND_LIBRARY_USE_LIB64_PATHS OFF)
else(${CMAKE_WORD_SIZE} MATCHES "32BIT")
  set_property(GLOBAL PROPERTY FIND_LIBRARY_USE_LIB64_PATHS ON)
endif(${CMAKE_WORD_SIZE} MATCHES "32BIT")

# One of the problems with 32/64 building is we need to search anew
# for 64 bit libs after a 32 bit configure, or vice versa.
if(PREVIOUS_CONFIGURE_TYPE)
  if(NOT ${PREVIOUS_CONFIGURE_TYPE} MATCHES ${CMAKE_WORD_SIZE})
    include(${BRLCAD_CMAKE_DIR}/ResetCache.cmake)
    RESET_CACHE_file()
  endif(NOT ${PREVIOUS_CONFIGURE_TYPE} MATCHES ${CMAKE_WORD_SIZE})
endif(PREVIOUS_CONFIGURE_TYPE)

set(PREVIOUS_CONFIGURE_TYPE ${CMAKE_WORD_SIZE} CACHE STRING "Previous configuration word size" FORCE)
mark_as_advanced(PREVIOUS_CONFIGURE_TYPE)

# Auto-reconfiguration - by default, a CMake generated build system
# will re-run CMake if it detects that build system logic has changed.
# This is normally a good thing, but becomes problematic when using
# Visual Studio - recent versions of MSVC will individually prompt for
# a re-loading of generated solution files one at a time.  Since
# BRL-CAD has over a thousand such files in a default build, the only
# viable approach is to close Visual Studio, re-run CMake manually,
# and re-open the project in Visual Studio.
if("${CMAKE_GENERATOR}" MATCHES "Visual Studio")
  set(CMAKE_SUPPRESS_REGENERATION ON)
endif("${CMAKE_GENERATOR}" MATCHES "Visual Studio")

# *******************************************************************
if(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)
  message("***********************************************************")
  message("*        Stage 1 of 9 - Top Level Configure Options       *")
  message("***********************************************************")
endif(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)
#
# Now we define the various options for BRL-CAD - ways to enable and
# disable features, select which parts of the system to build, etc.
# As much as possible, sane default options are either selected or
# detected.  Because documentation is autogenerated for BRL-CAD
# options, be sure to initialize the file.
set(CONFIG_OPT_STRING "CONFIGURATION OPTIONS\n---------------------\n")
file(WRITE ${CMAKE_BINARY_DIR}/OPTIONS "${CONFIG_OPT_STRING}")

# The BRL-CAD CMake build will also generate a configure script
# that emulates the command option style of GNU Autotool's
# configure.  Write the pre-defined header into the build-dir template
# to initialize the file.
file(REMOVE ${CMAKE_BINARY_DIR}/configure.new)
file(READ ${BRLCAD_CMAKE_DIR}/configure_prefix.sh CONFIG_PREFIX)
file(WRITE ${CMAKE_BINARY_DIR}/configure.new.tmp "${CONFIG_PREFIX}")
file(COPY ${CMAKE_BINARY_DIR}/configure.new.tmp DESTINATION
  ${CMAKE_BINARY_DIR}/CMakeFiles FILE_PERMISSIONS OWNER_READ OWNER_WRITE
  OWNER_EXECUTE GROUP_READ GROUP_EXECUTE WORLD_READ WORLD_EXECUTE)
file(REMOVE ${CMAKE_BINARY_DIR}/configure.new.tmp)
file(RENAME ${CMAKE_BINARY_DIR}/CMakeFiles/configure.new.tmp
  ${CMAKE_BINARY_DIR}/configure.new)

# Build shared libs by default.  Mark this as advanced - turning off
# ALL shared library building is unlikely to result in a working build
# and is not a typical configuration.  Note that turning this option off
# will not disable libraries specifically added as SHARED.
option(BUILD_SHARED_LIBS "Build shared libraries" ON)
mark_as_advanced(BUILD_SHARED_LIBS)

# Build static libs by default unless we're debugging. Note: this
# option will not disable libraries specifically added as STATIC even
# when OFF.  For multi-configuration options the build type determination
# is made at build time, so just default to "ON".
if(NOT CMAKE_CONFIGURATION_TYPES)
  AUTO_OPTION(BRLCAD_BUILD_STATIC_LIBS BUILD_STATIC_LIBS "OFF" "ON")
else(NOT CMAKE_CONFIGURATION_TYPES)
  if("${BRLCAD_BUILD_STATIC_LIBS}" STREQUAL "")
    set(BRLCAD_BUILD_STATIC_LIBS ON)
  endif("${BRLCAD_BUILD_STATIC_LIBS}" STREQUAL "")
  set(BUILD_STATIC_LIBS "${BRLCAD_BUILD_STATIC_LIBS}")
endif(NOT CMAKE_CONFIGURATION_TYPES)

# On Mac OS X, it is common to have third party package managers
# present for easy software installation (currently we're aware of
# Fink and MacPorts).  This can seriously complicate find_* results,
# so provide an option to specify whether or which of the third
# party setup to use.
include(${BRLCAD_CMAKE_DIR}/Fink_MacPorts.cmake)

# Option for librtserver, used to help Java programs interface with librt.
# Find Java and JNI, and conditionalize the default setting on Java's
# availability
FIND_PACKAGE(Java)
FIND_PACKAGE(JNI)
if(JNI_FOUND AND JAVA_FOUND)
  option(BRLCAD_ENABLE_RTSERVER "Enable the librtserver target." ON)
else(JNI_FOUND AND JAVA_FOUND)
  option(BRLCAD_ENABLE_RTSERVER "Enable the librtserver target." OFF)
endif(JNI_FOUND AND JAVA_FOUND)

# Turn off the brlcad.dll build.
# It's an expert's setting at the moment.
option(BRLCAD_ENABLE_BRLCAD_LIBRARY "Build the brlcad.dll" OFF)
mark_as_advanced(BRLCAD_ENABLE_BRLCAD_LIBRARY)

# Global third party controls - these options enable and disable ALL
# local copies of libraries in src/other.  Forcing all local
# libraries off is not usually recommended unless attempting to
# build packages for a distribution.  If both of these options are
# on the enabling of local packages is the "senior" option and will
# force the system libs option to off.
set(BRLCAD_BUNDLED_LIBS_ALIASES "ENABLE_ALL")
set(BRLCAD_BUNDLED_LIBS_DESCRIPTION "
Enables compilation of all 3rd party sources that are provided within a BRL-CAD
source distribution.  If used this option sets all other 3rd party library
build flags to ON by default.  However, that setting can be overridden by
manually setting individual variables. Default is \"AUTO\" - 3rd party sources
are compiled only if they are not detected as being available and functioning
as expected.
")

# Set the location of the BRL-CAD bundled Boost header directory:
set(BRLCAD_BOOST_INCLUDE_DIR "${CMAKE_SOURCE_DIR}/src/other/boost")

if(MSVC)
  set(BRLCAD_BUNDLED_LIBS_DEFAULT "BUNDLED")
else(MSVC)
  set(BRLCAD_BUNDLED_LIBS_DEFAULT "AUTO")
endif(MSVC)
BRLCAD_OPTION(${BRLCAD_BUNDLED_LIBS_DEFAULT} BRLCAD_BUNDLED_LIBS BRLCAD_BUNDLED_LIBS_ALIASES BRLCAD_BUNDLED_LIBS_DESCRIPTION)
set_property(CACHE BRLCAD_BUNDLED_LIBS PROPERTY STRINGS AUTO BUNDLED SYSTEM)
string(TOUPPER "${BRLCAD_BUNDLED_LIBS}" BRLCAD_BUNDLED_LIBS_UPPER)
set(BRLCAD_BUNDLED_LIBS "${BRLCAD_BUNDLED_LIBS_UPPER}" CACHE STRING "Build bundled libraries." FORCE)
if(${BRLCAD_BUNDLED_LIBS} MATCHES "ON")
  set(BRLCAD_BUNDLED_LIBS "BUNDLED" CACHE STRING "Build bundled libraries." FORCE)
endif(${BRLCAD_BUNDLED_LIBS} MATCHES "ON")
if(${BRLCAD_BUNDLED_LIBS} MATCHES "OFF")
  set(BRLCAD_BUNDLED_LIBS "SYSTEM" CACHE STRING "Build bundled libraries." FORCE)
endif(${BRLCAD_BUNDLED_LIBS} MATCHES "OFF")
if(NOT BRLCAD_BUNDLED_LIBS MATCHES "AUTO" AND NOT BRLCAD_BUNDLED_LIBS MATCHES "BUNDLED" AND NOT BRLCAD_BUNDLED_LIBS MATCHES "SYSTEM")
  message(WARNING "Unknown value BRLCAD_BUNDLED_LIBS supplied for BRLCAD_BUNDLED_LIBS - defaulting to AUTO")
  message(WARNING "Valid options are AUTO, BUNDLED and SYSTEM")
  set(BRLCAD_BUNDLED_LIBS "AUTO" CACHE STRING "Build bundled libraries." FORCE)
endif(NOT BRLCAD_BUNDLED_LIBS MATCHES "AUTO" AND NOT BRLCAD_BUNDLED_LIBS MATCHES "BUNDLED" AND NOT BRLCAD_BUNDLED_LIBS MATCHES "SYSTEM")

# Enable Aqua widgets on Mac OSX.  This impacts Tcl/Tk building and OpenGL
# building. Not currently working - needs work in at least Tk
# CMake logic (probably more), and the display manager/framebuffer codes are known to depend
# on either GLX or WGL specifically in their current forms.
option(BRLCAD_ENABLE_AQUA "Use Aqua instead of X11 whenever possible on OSX." OFF)
mark_as_advanced(BRLCAD_ENABLE_AQUA)

# Install example BRL-CAD Geometry Files
option(BRLCAD_INSTALL_EXAMPLE_GEOMETRY "Install the example BRL-CAD geometry files." ON)

# test for X11 on all platforms since we don't know when/where we'll find it
include(${BRLCAD_CMAKE_DIR}/FindX11.cmake)

# Set whether X11 is enabled or disabled by default
if(WIN32)
  # even if there is x11, we default to native
  option(BRLCAD_ENABLE_X11 "Use X11." OFF)
elseif(BRLCAD_ENABLE_AQUA)
  # aqua implies no X11
  option(BRLCAD_ENABLE_X11 "Use X11." OFF)
else(WIN32)
  # make everywhere else depend on whether we found a suitable X11
  if(X11_X11_LIB AND X11_Xext_LIB AND X11_Xi_LIB AND X11_Xlib_INCLUDE_PATH)
    option(BRLCAD_ENABLE_X11 "Use X11." ON)
  else(X11_X11_LIB AND X11_Xext_LIB AND X11_Xi_LIB AND X11_Xlib_INCLUDE_PATH)
    option(BRLCAD_ENABLE_X11 "Use X11." OFF)
  endif(X11_X11_LIB AND X11_Xext_LIB AND X11_Xi_LIB AND X11_Xlib_INCLUDE_PATH)
endif(WIN32)
mark_as_advanced(BRLCAD_ENABLE_X11)

# if X11 is enabled, make sure aqua is off
if(BRLCAD_ENABLE_X11)
  set(BRLCAD_ENABLE_AQUA OFF CACHE STRING "Don't use Aqua if we're doing X11" FORCE)
  set(OPENGL_USE_AQUA OFF CACHE STRING "Don't use Aqua if we're doing X11" FORCE)
endif(BRLCAD_ENABLE_X11)
mark_as_advanced(OPENGL_USE_AQUA)

# Enable/disable features requiring the Tk toolkit - usually this should
# be on, as a lot of functionality in BRL-CAD depends on Tk
option(BRLCAD_ENABLE_TK "Enable features requiring the Tk toolkit" ON)
mark_as_advanced(BRLCAD_ENABLE_TK)
if(NOT BRLCAD_ENABLE_X11 AND NOT BRLCAD_ENABLE_AQUA AND NOT WIN32)
  set(BRLCAD_ENABLE_TK OFF)
endif(NOT BRLCAD_ENABLE_X11 AND NOT BRLCAD_ENABLE_AQUA AND NOT WIN32)
if(BRLCAD_ENABLE_X11)
  set(TK_X11_GRAPHICS ON CACHE STRING "Need X11 Tk" FORCE)
endif(BRLCAD_ENABLE_X11)

# Enable features requiring OPENGL
# Be smart about this - if we don't have X11 or Aqua and we're
# not on Windows, we're non-graphical and that means OpenGL is
# a no-go.  The Windows version would have to be some sort of
# option for the WIN32 graphics layer?  Should probably think
# about that... for now, on Win32 don't try OpenGL if Tk is
# off.  That'll hold until we get a non-Tk based GUI - then
# setting non-graphical on Windows will take more thought.
if(NOT BRLCAD_ENABLE_X11 AND NOT BRLCAD_ENABLE_AQUA AND NOT WIN32)
  set(OPENGL_FOUND OFF)
  set(BRLCAD_ENABLE_OPENGL OFF CACHE BOOL "Disabled - NOT BRLCAD_ENABLE_X11 and NOT BRLCAD_ENABLE_AQUA" FORCE)
else(NOT BRLCAD_ENABLE_X11 AND NOT BRLCAD_ENABLE_AQUA AND NOT WIN32)
  include(${BRLCAD_CMAKE_DIR}/FindGL.cmake)
endif(NOT BRLCAD_ENABLE_X11 AND NOT BRLCAD_ENABLE_AQUA AND NOT WIN32)

set(BRLCAD_ENABLE_OPENGL_ALIASES
  ENABLE_OPENGL
  )
set(BRLCAD_ENABLE_OPENGL_DESCRIPTION "
Enable support for OpenGL based Display Managers in BRL-CAD.
Default depends on whether OpenGL is successfully detected -
if it is, default is to enable.
")
BRLCAD_OPTION(${OPENGL_FOUND} BRLCAD_ENABLE_OPENGL BRLCAD_ENABLE_OPENGL_ALIASES BRLCAD_ENABLE_OPENGL_DESCRIPTION)

# Enable RTGL.  Requires an enabled OpenGL.
option(BRLCAD_ENABLE_RTGL "Enable experimental RTGL code." OFF)
mark_as_advanced(BRLCAD_ENABLE_RTGL)
if(NOT BRLCAD_ENABLE_OPENGL AND BRLCAD_ENABLE_RTGL)
  message("RTGL requested, but OpenGL is not enabled - disabling")
  set(BRLCAD_ENABLE_RTGL OFF CACHE BOOL "Enable experimental RTGL code." FORCE)
endif(NOT BRLCAD_ENABLE_OPENGL AND BRLCAD_ENABLE_RTGL)
if(NOT BRLCAD_ENABLE_X11 AND BRLCAD_ENABLE_RTGL)
  message("RTGL currently works only with GLX, and X11 is not enabled - disabling")
  set(BRLCAD_ENABLE_RTGL OFF CACHE BOOL "Enable experimental RTGL code." FORCE)
endif(NOT BRLCAD_ENABLE_X11 AND BRLCAD_ENABLE_RTGL)
if(BRLCAD_ENABLE_AQUA)
  set(OPENGL_USE_AQUA ON CACHE STRING "Aqua enabled - use Aqua OpenGL" FORCE)
endif(BRLCAD_ENABLE_AQUA)

# Enable features requiring Qt
find_package(Qt5Widgets QUIET)
option(BRLCAD_ENABLE_QT "Enable features requiring Qt" OFF)
mark_as_advanced(BRLCAD_ENABLE_QT)
if(NOT Qt5Widgets_FOUND AND BRLCAD_ENABLE_QT)
  message("QT interface requested, but QT5 is not found - disabling")
  set(BRLCAD_ENABLE_QT OFF)
endif(NOT Qt5Widgets_FOUND AND BRLCAD_ENABLE_QT)
mark_as_advanced(Qt5Widgets_DIR)

# Enable features requiring OpenSceneGraph
option(BRLCAD_ENABLE_OSG "Enable features requiring OpenSceneGraph" OFF)
mark_as_advanced(BRLCAD_ENABLE_OSG)
if(BRLCAD_ENABLE_OSG)
  find_package(OpenSceneGraph 3.2.0 REQUIRED osgText osgViewer)
  if(NOT OSG_LIBRARY)
    message("OpenSceneGraph interface requested, but OSG is not found - disabling")
    set(BRLCAD_ENABLE_OSG OFF)
  endif(NOT OSG_LIBRARY)
endif(BRLCAD_ENABLE_OSG)

#----------------------------------------------------------------------
# The following are fine-grained options for enabling/disabling compiler
# and source code definition settings.  Typically these are set to
# various configurations by the toplevel CMAKE_BUILD_TYPE setting, but
# can also be individually set.

# Enable/disable runtime debugging - these are protections for
# minimizing the possibility of corrupted data files.  Generally
# speaking these should be left on.
set(BRLCAD_ENABLE_RUNTIME_DEBUG_ALIASES
  ENABLE_RUNTIME_DEBUG
  ENABLE_RUN_TIME_DEBUG
  ENABLE_RUNTIME_DEBUGGING
  ENABLE_RUN_TIME_DEBUGGING)
set(BRLCAD_ENABLE_RUNTIME_DEBUG_DESCRIPTION "
Enables support for application and library debugging facilities.
Disabling the run-time debugging facilities can provide a significant
(10%-30%) performance boost at the expense of extensive error
checking (that in turn help prevent corruption of your data).
Default is \"ON\", and should only be disabled for read-only render
work where performance is critical.
")
BRLCAD_OPTION(ON BRLCAD_ENABLE_RUNTIME_DEBUG BRLCAD_ENABLE_RUNTIME_DEBUG_ALIASES BRLCAD_ENABLE_RUNTIME_DEBUG_DESCRIPTION)
mark_as_advanced(BRLCAD_ENABLE_RUNTIME_DEBUG)
if(NOT BRLCAD_ENABLE_RUNTIME_DEBUG)
  message("}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}")
  message("While disabling run-time debugging should increase")
  message("performance, it will likewise remove several")
  message("data-protection safeguards that are in place to")
  message("minimize the possibility of corrupted data files")
  message("in the inevitable event of a user encountering a bug.")
  message("You have been warned.  Proceed at your own risk.")
  message("{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{")
  CONFIG_H_APPEND(BRLCAD "/*Define to not do anything for macros that only bomb on a fatal error. */\n")
  CONFIG_H_APPEND(BRLCAD "#define NO_BOMBING_MACROS 1\n")
  CONFIG_H_APPEND(BRLCAD "/*Define to not perform magic number checking */\n")
  CONFIG_H_APPEND(BRLCAD "#define NO_MAGIC_CHECKING 1\n")
  CONFIG_H_APPEND(BRLCAD "/*Define to not provide run-time debug facilities via RTG.debug */\n")
  CONFIG_H_APPEND(BRLCAD "#define NO_DEBUG_CHECKING 1\n")
endif(NOT BRLCAD_ENABLE_RUNTIME_DEBUG)

# Enable debug flags during compilation - we always want to use these
# unless explicitly told not to.
set(BRLCAD_FLAGS_DEBUG_ALIASES
  ENABLE_DEBUG
  ENABLE_FLAGS_DEBUG
  ENABLE_DEBUG_FLAGS
  )
set(BRLCAD_FLAGS_DEBUG_DESCRIPTION "
Add compiler flags to aid in program debugging.  Defaults to ON.
")
BRLCAD_OPTION(ON BRLCAD_FLAGS_DEBUG BRLCAD_FLAGS_DEBUG_ALIASES BRLCAD_FLAGS_DEBUG_DESCRIPTION)

# A variety of debugging messages in the code key off of the DEBUG
# definition - set it according to whether we're using debug flags.
if(BRLCAD_FLAGS_DEBUG)
  CONFIG_H_APPEND(BRLCAD "#define DEBUG 1\n")
endif(BRLCAD_FLAGS_DEBUG)

# Build with compiler warning flags
set(BRLCAD_ENABLE_COMPILER_WARNINGS_ALIASES
  ENABLE_WARNINGS
  ENABLE_COMPILER_WARNINGS
  )
set(BRLCAD_ENABLE_COMPILER_WARNINGS_DESCRIPTION "
Use extra compiler warning flags when compiling C/C++ code.  Defaults to ON.
")
BRLCAD_OPTION(ON BRLCAD_ENABLE_COMPILER_WARNINGS
  BRLCAD_ENABLE_COMPILER_WARNINGS_ALIASES
  BRLCAD_ENABLE_COMPILER_WARNINGS_DESCRIPTION)
mark_as_advanced(BRLCAD_ENABLE_COMPILER_WARNINGS)

# Enable/disable strict compiler settings - these are used for building
# BRL-CAD by default, but not src/other code.  Always used for BRL-CAD
# code unless the NO_STRICT option is specified when defining a target
# with BRLCAD_ADDEXEC or BRLCAD_ADDLIB.  If only C++ files in a target
# are not compatible with strict, the NO_STRICT_CXX option can be used.
set(BRLCAD_ENABLE_STRICT_ALIASES
  ENABLE_STRICT
  ENABLE_STRICT_COMPILE
  ENABLE_STRICT_COMPILE_FLAGS)
set(BRLCAD_ENABLE_STRICT_DESCRIPTION "
Causes all compilation warnings for C code to be treated as errors.  This is now
the default for BRL-CAD source code, and developers should address issues
discovered by these flags whenever possible rather than disabling strict
mode.
")
BRLCAD_OPTION(ON BRLCAD_ENABLE_STRICT BRLCAD_ENABLE_STRICT_ALIASES BRLCAD_ENABLE_STRICT_DESCRIPTION)
if(BRLCAD_ENABLE_STRICT)
  mark_as_advanced(BRLCAD_ENABLE_STRICT)
  CONFIG_H_APPEND(BRLCAD "#define STRICT_FLAGS 1\n")
endif(BRLCAD_ENABLE_STRICT)

# Build with compiler optimization flags.  This should normally be on for
# release builds.
AUTO_OPTION(BRLCAD_FLAGS_OPTIMIZATION BRLCAD_OPTIMIZED_BUILD "OFF" "ON")

# By default, we don't want any error reports at all from src/other
option(BRLCAD_DISABLE_SRC_OTHER_WARN "Disable warnings for src/other" ON)
mark_as_advanced(BRLCAD_DISABLE_SRC_OTHER_WARN)

# Build with full compiler lines visible by default (won't need make
# VERBOSE=1) on command line
option(BRLCAD_ENABLE_VERBOSE_PROGRESS "verbose output" OFF)
mark_as_advanced(BRLCAD_ENABLE_VERBOSE_PROGRESS)
if(BRLCAD_ENABLE_VERBOSE_PROGRESS)
  set(CMAKE_VERBOSE_MAKEFILE ON)
endif(BRLCAD_ENABLE_VERBOSE_PROGRESS)

# Build with profiling support
option(BRLCAD_ENABLE_PROFILING "Build with profiling support" OFF)
mark_as_advanced(BRLCAD_ENABLE_PROFILING)

#====== ALL CXX COMPILE ===================
# Build all C and C++ files with a C++ compiler
set(ENABLE_ALL_CXX_COMPILE_ALIASES "ENABLE_ALL_CXX")
set(ENABLE_ALL_CXX_COMPILE_DESCRIPTION "
Build all C and C++ files with a C++ compiler.  Defaults to OFF.

EXPERIMENTAL!
")
BRLCAD_OPTION(OFF ENABLE_ALL_CXX_COMPILE
  ENABLE_ALL_CXX_COMPILE_ALIASES
  ENABLE_ALL_CXX_COMPILE_DESCRIPTION)
mark_as_advanced(ENABLE_ALL_CXX_COMPILE)

# Build with coverage enabled
option(BRLCAD_ENABLE_COVERAGE "Build with coverage enabled" OFF)
mark_as_advanced(BRLCAD_ENABLE_COVERAGE)

#====== POSIX ===================
# Build with strict POSIX compliance checking
set(ENABLE_POSIX_COMPLIANCE_ALIASES "ENABLE_POSIX")
set(ENABLE_POSIX_COMPLIANCE_DESCRIPTION "
Build with strict POSIX compliance checking.  Defaults to OFF.

Causes compiler options to be set for strict compliance with the
minimum C and C++ standards acceptable according to current BRL-CAD
policy.  The current minimum C standard is ??.
There is no currently defined minimum C++ standard.
")
BRLCAD_OPTION(OFF ENABLE_POSIX_COMPLIANCE
  ENABLE_POSIX_COMPLIANCE_ALIASES
  ENABLE_POSIX_COMPLIANCE_DESCRIPTION)
mark_as_advanced(ENABLE_POSIX_COMPLIANCE)

#== ISO C ==
set(ENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE_ALIASES "STRICT_ISO_C")
set(ENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE_DESCRIPTION "
Build with strict ISO C compliance checking.  Defaults to OFF.

Causes C compiler options to be set for strict compliance with the
appropriate ISO C standard.
")
BRLCAD_OPTION(OFF ENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE
  ENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE_ALIASES
  ENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE_DESCRIPTION)
mark_as_advanced(ENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE)

# Build with dtrace support
option(BRLCAD_ENABLE_DTRACE "Build with dtrace support" OFF)
mark_as_advanced(BRLCAD_ENABLE_DTRACE)
if(BRLCAD_ENABLE_DTRACE)
  BRLCAD_INCLUDE_FILE(sys/sdt.h HAVE_SYS_SDT_H)
  if(NOT HAVE_SYS_SDT_H)
    set(BRLCAD_ENABLE_DTRACE OFF)
  endif(NOT HAVE_SYS_SDT_H)
endif(BRLCAD_ENABLE_DTRACE)

# Take advantage of parallel processors if available - highly recommended
option(BRLCAD_ENABLE_SMP "Enable SMP architecture parallel computation support" ON)
mark_as_advanced(BRLCAD_ENABLE_SMP)
if(BRLCAD_ENABLE_SMP)
  CONFIG_H_APPEND(BRLCAD "#define PARALLEL 1\n")
endif(BRLCAD_ENABLE_SMP)

#----------------------------------------------------------------------
# Some generators in CMake support generating folders in IDEs for
# organizing build targets.  We want to use them if they are there.
if(MSVC)
  set_property(GLOBAL PROPERTY USE_FOLDERS ON)
endif(MSVC)

#----------------------------------------------------------------------
# There are extra documentation files available requiring DocBook
# They are quite useful in graphical interfaces, but also add considerably
# to the overall build time.  If necessary BRL-CAD provides its own
# xsltproc (see src/other/xmltools), so the html and man page
# outputs are always potentially available.  PDF output, on the other hand,
# needs Apache FOP.  FOP is not a candidate for bundling with BRL-CAD for
# a number of reasons, so we simply check to see if it is present and set
# the options accordingly.

# Do we have the environment variable set locally?
if(NOT "$ENV{APACHE_FOP}" STREQUAL "")
  set(APACHE_FOP "$ENV{APACHE_FOP}")
endif(NOT "$ENV{APACHE_FOP}" STREQUAL "")
if(NOT APACHE_FOP)
  find_program(APACHE_FOP fop DOC "path to the exec script for Apache FOP")
endif(NOT APACHE_FOP)
mark_as_advanced(APACHE_FOP)
# We care about the FOP version, unfortunately - find out what we have.
if(APACHE_FOP)
  execute_process(COMMAND ${APACHE_FOP} -v OUTPUT_VARIABLE APACHE_FOP_INFO ERROR_QUIET)
  string(REGEX REPLACE "FOP Version ([0-9\\.]*)" "\\1" APACHE_FOP_VERSION_REGEX "${APACHE_FOP_INFO}")
  if(APACHE_FOP_VERSION_REGEX)
    string(STRIP ${APACHE_FOP_VERSION_REGEX} APACHE_FOP_VERSION_REGEX)
  endif(APACHE_FOP_VERSION_REGEX)
  if(NOT "${APACHE_FOP_VERSION}" STREQUAL "${APACHE_FOP_VERSION_REGEX}")
    message("-- Found Apache FOP: version ${APACHE_FOP_VERSION_REGEX}")
    set(APACHE_FOP_VERSION ${APACHE_FOP_VERSION_REGEX} CACHE STRING "Apache FOP version" FORCE)
    mark_as_advanced(APACHE_FOP_VERSION)
  endif(NOT "${APACHE_FOP_VERSION}" STREQUAL "${APACHE_FOP_VERSION_REGEX}")
endif(APACHE_FOP)

# Toplevel variable that controls all DocBook based documentation.  Key it off
# of what target level is enabled.
if(NOT BRLCAD_ENABLE_TARGETS OR "${BRLCAD_ENABLE_TARGETS}" GREATER 2)
  set(EXTRADOCS_DEFAULT "ON")
else(NOT BRLCAD_ENABLE_TARGETS OR "${BRLCAD_ENABLE_TARGETS}" GREATER 2)
  set(EXTRADOCS_DEFAULT "OFF")
endif(NOT BRLCAD_ENABLE_TARGETS OR "${BRLCAD_ENABLE_TARGETS}" GREATER 2)
set(BRLCAD_EXTRADOCS_ALIASES
  ENABLE_DOCS
  ENABLE_EXTRA_DOCS
  ENABLE_DOCBOOK
  )
set(BRLCAD_EXTRADOCS_DESCRIPTION "
The core option that enables and disables building of BRL-CAD's
DocBook based documentation (includes manuals and man pages for
commands, among other things).  Defaults to ON, but only HTML and MAN
formats are enabled by default - PDF must be enabled separately by use
of this option or one of its aliases.  Note that you may set
environment variable APACHE_FOP to point to your locally installed fop
executable file (which on Linux is usually a shell script with 0755
permissions).
")
BRLCAD_OPTION(${EXTRADOCS_DEFAULT} BRLCAD_EXTRADOCS BRLCAD_EXTRADOCS_ALIASES BRLCAD_EXTRADOCS_DESCRIPTION)

include(CMakeDependentOption)

# The HTML output is used in the graphical help browsers in MGED and Archer,
# as well as being the most likely candidate for external viewers. Turn this
# on unless explicitly instructed otherwise by the user or all extra
# documentation is disabled.
CMAKE_DEPENDENT_OPTION(BRLCAD_EXTRADOCS_HTML "Build MAN page output from DocBook documentation" ON "BRLCAD_EXTRADOCS" OFF)
mark_as_advanced(BRLCAD_EXTRADOCS_HTML)

# Normally, we'll turn on man page output by default, but there is
# no point in doing man page output for a Visual Studio build - the
# files aren't useful and it *seriously* increases the target build
# count/build time.  Conditionalize on the CMake MSVC variable NOT
# being set.
CMAKE_DEPENDENT_OPTION(BRLCAD_EXTRADOCS_MAN "Build MAN page output from DocBook documentation" ON "BRLCAD_EXTRADOCS;NOT MSVC" OFF)
mark_as_advanced(BRLCAD_EXTRADOCS_MAN)

# Don't do PDF by default, and hide the option unless the tools to do it are
# present.  Provide an option to disable the PDF output for man pages without
# disabling the rest of the PDF output - PDF generation for hundreds of man
# pages can be expensive in time.
set(BRLCAD_EXTRADOCS_PDF_DESCRIPTION "
Option that enables building of BRL-CAD's DocBook PDF-based documentation
(includes manuals and man pages for commands, among
other things.) Defaults to OFF.
Note that you may set environment variable APACHE_FOP
to point to your locally installed fop executable file (which on Linux is
usually a shell script with 0755 permissions).
")
set(BRLCAD_EXTRADOCS_PDF_MAN_DESCRIPTION "
Option that enables building of BRL-CAD's DocBook PDF-based documentation
for man pages only.  Defaults to OFF.
")
CMAKE_DEPENDENT_OPTION(BRLCAD_EXTRADOCS_PDF "Build PDF output from DocBook documentation" OFF "BRLCAD_EXTRADOCS;APACHE_FOP" OFF)
CMAKE_DEPENDENT_OPTION(BRLCAD_EXTRADOCS_PDF_MAN "Build PDF output from DocBook documentation for man pages" ON "BRLCAD_EXTRADOCS_PDF" OFF)

# Provide an option to enable/disable XML validation as part
# of the DocBook build - sort of a "strict flags" mode for DocBook.
# By default, this will be enabled when extra docs are built and
# the toplevel BRLCAD_ENABLE_STRICT setting is enabled.
# Unfortunately, Visual Studio 2010 seems to have issues when we
# enable validation on top of everything else... not clear why,
# unless build target counts >1800 are beyond MSVC's practical
# limit.  Until we either find a resolution or a way to reduce
# the target count on MSVC, disable validation there.
CMAKE_DEPENDENT_OPTION(BRLCAD_EXTRADOCS_VALIDATE "Perform validation for DocBook documentation" ON "BRLCAD_EXTRADOCS;BRLCAD_ENABLE_STRICT" OFF)
mark_as_advanced(BRLCAD_EXTRADOCS_VALIDATE)

# Load various wrapper macros for checking libraries, headers and
# functions, some in use by src/other build logic
include(${BRLCAD_CMAKE_DIR}/BRLCAD_CheckFunctions.cmake)


# *******************************************************************
if(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)
  message("***********************************************************")
  message("*             Stage 2 of 9 - Check for Programs           *")
  message("***********************************************************")
endif(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)

# A variety of tools, such as the benchmark utilities, need
# a Bourne shell and other commands - check for them.
include(${BRLCAD_CMAKE_DIR}/FindShellDeps.cmake)

# CMake can detect flex and bison, but apparently not generic lex/yacc.
# Solution is to make our own generic lex/yacc Find routines that look
# first for flex/bison, but will take whatever's available.  Since the
# BRL-CAD project isn't supposed to rely on flex/bison specific features
# anyway, there shouldn't be a problem.
include(${BRLCAD_CMAKE_DIR}/FindLEX.cmake)
include(${BRLCAD_CMAKE_DIR}/FindYACC.cmake)

# If using dtrace, we will need to find it
if(BRLCAD_ENABLE_DTRACE)
  find_program(DTRACE_EXEC NAMES dtrace DOC "path to dtrace executable")
endif(BRLCAD_ENABLE_DTRACE)

# SWIG is an automatic generator of wrappers for various
# software languages
find_package(SWIG)
mark_as_advanced(SWIG_EXECUTABLE)
mark_as_advanced(SWIG_DIR)
mark_as_advanced(SWIG_VERSION)

# Doxygen is a tool for generating formatted documentation
# from structured source code comments.
find_package(Doxygen)


# *******************************************************************
if(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)
  message("***********************************************************")
  message("*     Stage 3 of 9 - Check for Compiler Characteristics   *")
  message("***********************************************************")
endif(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)

# load our compiler testing macro definitions
include(${BRLCAD_CMAKE_DIR}/CompilerFlags.cmake)

# Cache the original CMake sets of build flags for later use
if(NOT CMAKE_BUILD_FLAGS_CACHED_CMAKE_DEFAULT)
  CACHE_BUILD_FLAGS(_CMAKE_DEFAULT)
endif(NOT CMAKE_BUILD_FLAGS_CACHED_CMAKE_DEFAULT)

# Clear out most CMake-assigned defaults - We're managing
# our own compile flags, and don't (for example) want NDEBUG
# if we have debugging flags enabled for a Release build.
# At the same time, pull in any flags that have been set
# in the environment.
CLEAR_BUILD_FLAGS()

# try to use -pipe to speed up the compiles
CHECK_C_FLAG(pipe)
CHECK_CXX_FLAG(pipe)

# check for -fno-strict-aliasing
# XXX - THIS FLAG IS REQUIRED if any level of optimization is
# enabled with GCC as we do use aliasing and type-punning.
CHECK_C_FLAG(fno-strict-aliasing)
CHECK_CXX_FLAG(fno-strict-aliasing)

# check for -fno-common (libtcl needs it on darwin)
CHECK_C_FLAG(fno-common)
CHECK_CXX_FLAG(fno-common)

# check for -fexceptions
# this is needed to resolve __Unwind_Resume when compiling and
# linking against openNURBS in librt for some binaries, for
# example rttherm (i.e. any -static binaries)
CHECK_C_FLAG(fexceptions)
CHECK_CXX_FLAG(fexceptions)

# check for -ftemplate-depth-NN this is needed in libpc and
# other code using boost where the template instantiation depth
# needs to be increased from the default ANSI minimum of 17.
CHECK_CXX_FLAG(ftemplate-depth-128)

# dynamic SSE optimizations for NURBS processing
#
# XXX disable the SSE flags for now as they can cause illegal instructions.
#     the test needs to also be tied to run-time functionality since gcc
#     may still output SSE instructions (e.g., for cross-compiling).
# CHECK_C_FLAG(msse)
# CHECK_C_FLAG(msse2)
CHECK_C_FLAG(msse3 BUILD_TYPES Debug)

# Check for c90 support with gnu extensions if we're not building for
# a release so we get more broad portability testing.  Since the
# default is debug, it will be the more difficult to keep working
# given it's the lesser feature-rich C standard.  If we're going for
# a strictly standard compliant build, use the c** options instead
# of the gnu variations
if(ENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE)
  CHECK_C_FLAG("std=c99" BUILD_TYPES Debug)
  CHECK_C_FLAG("std=c99" BUILD_TYPES Release VARS C99_FLAG)
  # we need to define some things as "empty" to avoid false positives
  # for bu_* functions using varargs and print specifiers
  CHECK_C_FLAG("D_BU_ATTR_PRINTF12=''")
  CHECK_C_FLAG("D_BU_ATTR_PRINTF23=''")
  CHECK_C_FLAG("D_BU_ATTR_SCANF23=''")
  # a hack to temp work around signal() handling in interrupt.c
  CHECK_C_FLAG("DC99_POSIX_USE_BSD")
  #=== C++
  CHECK_CXX_FLAG("std=c++03" BUILD_TYPES Debug)
  CHECK_CXX_FLAG("std=c++03" BUILD_TYPES Release VARS CXX03_FLAG)
  # for bu_* functions using varargs and print specifiers
  CHECK_CXX_FLAG("D_BU_ATTR_PRINTF12=''")
  CHECK_CXX_FLAG("D_BU_ATTR_PRINTF23=''")
  CHECK_CXX_FLAG("D_BU_ATTR_SCANF23=''")
  # a hack to temp work around signal() handling in interrupt.c
  CHECK_CXX_FLAG("DC99_POSIX_USE_BSD")
else()
  CHECK_C_FLAG("std=gnu89" BUILD_TYPES Debug)
  CHECK_C_FLAG("std=gnu99" BUILD_TYPES Release VARS C99_FLAG)
  CHECK_CXX_FLAG("std=gnu++98" BUILD_TYPES Debug)
  CHECK_CXX_FLAG("std=gnu++98" BUILD_TYPES Release VARS CXX03_FLAG)
endif()

# What POSIX do we want to target, initially?  See
# http://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html
# for options...
if(ENABLE_POSIX_COMPLIANCE)
  # use this version so three non-C99 functions (without bu*
  # replacements) will work (fileno, fdopen, and posix_memalign):
  CHECK_C_FLAG("D_POSIX_C_SOURCE=200112L")
  # need this for glibc < 2.12 (for gethostname):
  CHECK_C_FLAG("D_XOPEN_SOURCE=500")
  #=== same for C++
  CHECK_CXX_FLAG("D_POSIX_C_SOURCE=200112L")
  CHECK_CXX_FLAG("D_XOPEN_SOURCE=500")
endif()

# Silence check for unused arguments (used to silence clang warnings about
# unused options on the command line). By default clang generates a lot of
# warnings about such arguments, and we don't really care.
CHECK_C_FLAG(Qunused-arguments)
CHECK_CXX_FLAG(Qunused-arguments)

# 64bit compilation flags
if(${CMAKE_WORD_SIZE} MATCHES "64BIT" AND NOT CMAKE_CL_64)
  CHECK_C_FLAG(m64 VARS 64BIT_FLAG)
  CHECK_C_FLAG("arch x86_64" VARS 64BIT_FLAG)
  CHECK_C_FLAG(64 VARS 64BIT_FLAG)
  CHECK_C_FLAG("mabi=64" VARS  64BIT_FLAG)
  if(NOT 64BIT_FLAG AND ${CMAKE_WORD_SIZE} MATCHES "64BIT")
    message(FATAL_ERROR "Trying to compile 64BIT but all 64 bit compiler flag tests failed!")
  endif(NOT 64BIT_FLAG AND ${CMAKE_WORD_SIZE} MATCHES "64BIT")
  CHECK_C_FLAG(q64 VARS 64BIT_FLAG)
  ADD_NEW_FLAG(C 64BIT_FLAG ALL)
  ADD_NEW_FLAG(CXX 64BIT_FLAG ALL)
  ADD_NEW_FLAG(SHARED_LINKER 64BIT_FLAG ALL)
  ADD_NEW_FLAG(EXE_LINKER 64BIT_FLAG ALL)
endif(${CMAKE_WORD_SIZE} MATCHES "64BIT" AND NOT CMAKE_CL_64)

# 32 bit compilation flags
if(${CMAKE_WORD_SIZE} MATCHES "32BIT" AND NOT ${BRLCAD_WORD_SIZE} MATCHES "AUTO" AND NOT MSVC)
  CHECK_C_FLAG(m32 VARS 32BIT_FLAG)
  CHECK_C_FLAG("arch i686" VARS 32BIT_FLAG)
  CHECK_C_FLAG(32 VARS 32BIT_FLAG)
  CHECK_C_FLAG("mabi=32" VARS 32BIT_FLAG)
  CHECK_C_FLAG(q32 VARS 32BIT_FLAG)
  if(NOT 32BIT_FLAG AND ${CMAKE_WORD_SIZE} MATCHES "32BIT")
    message(FATAL_ERROR "Trying to compile 32BIT but all 32 bit compiler flag tests failed!")
  endif(NOT 32BIT_FLAG AND ${CMAKE_WORD_SIZE} MATCHES "32BIT")
  ADD_NEW_FLAG(C 32BIT_FLAG ALL)
  ADD_NEW_FLAG(CXX 32BIT_FLAG ALL)
  ADD_NEW_FLAG(SHARED_LINKER 32BIT_FLAG ALL)
  ADD_NEW_FLAG(EXE_LINKER 32BIT_FLAG ALL)
endif(${CMAKE_WORD_SIZE} MATCHES "32BIT" AND NOT ${BRLCAD_WORD_SIZE} MATCHES "AUTO" AND NOT MSVC)

if(BRLCAD_ENABLE_PROFILING)
  CHECK_C_FLAG(pg VARS PROFILE_FLAG)
  CHECK_C_FLAG(p VARS PROFILE_FLAG)
  CHECK_C_FLAG(prof_gen VARS PROFILE_FLAG)
  if(NOT PROFILE_FLAG)
    message("Warning - profiling requested, but don't know how to profile with this compiler - disabling.")
    set(BRLCAD_ENABLE_PROFILING OFF)
  else(NOT PROFILE_FLAG)
    ADD_NEW_FLAG(C PROFILE_FLAG ALL)
    ADD_NEW_FLAG(CXX PROFILE_FLAG ALL)
  endif(NOT PROFILE_FLAG)
endif(BRLCAD_ENABLE_PROFILING)

# Debugging flags
if(BRLCAD_FLAGS_DEBUG)
  CHECK_C_FLAG(g GROUPS DEBUG_C_FLAGS)
  CHECK_CXX_FLAG(g GROUPS DEBUG_CXX_FLAGS)
  if(APPLE)
    EXEC_PROGRAM(sw_vers ARGS -productVersion OUTPUT_VARIABLE MACOSX_VERSION)
    if(${MACOSX_VERSION} VERSION_LESS "10.5")
      CHECK_C_FLAG(ggdb3 GROUPS DEBUG_C_FLAGS)
      CHECK_CXX_FLAG(ggdb3 GROUPS DEBUG_CXX_FLAGS)
    else(${MACOSX_VERSION} VERSION_LESS "10.5")
      # CHECK_C_COMPILER_FLAG silently eats gstabs+ - also, compiler
      # apparently doesn't like mixing stabs with another debug flag.
      set(DEBUG_C_FLAGS "-ggdb")
      set(DEBUG_CXX_FLAGS "-ggdb")
    endif(${MACOSX_VERSION} VERSION_LESS "10.5")
  else(APPLE)
    CHECK_C_FLAG(ggdb3 GROUPS DEBUG_C_FLAGS)
    CHECK_CXX_FLAG(ggdb3 GROUPS DEBUG_CXX_FLAGS)
  endif(APPLE)
  if(CMAKE_CONFIGURATION_TYPES)
    set(debug_config_list "${CMAKE_CONFIGURATION_TYPES}")
  else(CMAKE_CONFIGURATION_TYPES)
    set(debug_config_list "ALL")
  endif(CMAKE_CONFIGURATION_TYPES)
  ADD_NEW_FLAG(C DEBUG_C_FLAGS "${debug_config_list}")
  ADD_NEW_FLAG(CXX DEBUG_CXX_FLAGS "${debug_config_list}")
  # TODO - need to figure out a way to actually test linker flags
  ADD_NEW_FLAG(SHARED_LINKER DEBUG_C_FLAGS "${debug_config_list}")
  ADD_NEW_FLAG(EXE_LINKER DEBUG_C_FLAGS "${debug_config_list}")
  mark_as_advanced(DEBUG_FLAGS)
endif(BRLCAD_FLAGS_DEBUG)


# Set the minimum compilation linkage for Mac systems if not already
# set, no harm if set elsewhere.
if(APPLE)
  set(MACOSX_DEPLOYMENT_TARGET "$ENV{MACOSX_DEPLOYMENT_TARGET}")
  if(NOT MACOSX_DEPLOYMENT_TARGET)
    set(ENV(MACOSX_DEPLOYMENT_TARGET) "10.3")
  endif(NOT MACOSX_DEPLOYMENT_TARGET)

  if(MACOSX_DEPLOYMENT_TARGET STREQUAL "10.3")
    CHECK_C_FLAG("mmacosx-version-min=10.3 -isysroot /Developer/SDKs/MacOSX10.3.9.sdk" VARS SDK_FLAG)
  endif(MACOSX_DEPLOYMENT_TARGET STREQUAL "10.3")
  if(MACOSX_DEPLOYMENT_TARGET STREQUAL "10.4")
    CHECK_C_FLAG("mmacosx-version-min=10.4 -isysroot /Developer/SDKs/MacOSX10.4u.sdk" VARS SDK_FLAG)
  endif(MACOSX_DEPLOYMENT_TARGET STREQUAL "10.4")
  if(MACOSX_DEPLOYMENT_TARGET STREQUAL "10.5")
    CHECK_C_FLAG("mmacosx-version-min=10.5 -isysroot /Developer/SDKs/MacOSX10.5.sdk" VARS SDK_FLAG)
  endif(MACOSX_DEPLOYMENT_TARGET STREQUAL "10.5")
  if(MACOSX_DEPLOYMENT_TARGET STREQUAL "10.6")
    CHECK_C_FLAG("mmacosx-version-min=10.6 -isysroot /Developer/SDKs/MacOSX10.6.sdk" VARS SDK_FLAG)
  endif(MACOSX_DEPLOYMENT_TARGET STREQUAL "10.6")

  ADD_NEW_FLAG(C SDK_FLAG ALL)
  ADD_NEW_FLAG(CXX SDK_FLAG ALL)
  ADD_NEW_FLAG(SHARED_LINKER SDK_FLAG ALL)
  ADD_NEW_FLAG(EXE_LINKER SDK_FLAG ALL)
endif(APPLE)

# Most of the src/other projects have their own logic for handling
# the C inline issue - BRL-CAD needs a fine-grained approach.  Mixed
# C and C++ sources require different treatment for the same build
# target, since C++11 doesn't allow inline to be re-defined. See
# misc/CMake/BRLCAD_Targets.cmake for handling of C_INLINE.
CHECK_C_INLINE(C_INLINE)

# If doing an optimized build, set _FORTIFY_SOURCE to 2.  Provides
# compile-time best-practice error checking on certain libc functions
# (e.g., memcpy), and provides run-time checks on buffer lengths and
# memory regions.  Unfortunately, glibc-1.6 made _FORTIFY_SOURCE spew
# an unquellable warning if optimization is disabled so we can't tie
# the flag to debug builds.
if(${BRLCAD_OPTIMIZED_BUILD} MATCHES "ON")
  CONFIG_H_APPEND(BRLCAD "#ifndef _FORTIFY_SOURCE\n#  define _FORTIFY_SOURCE 2\n#endif\n")
endif(${BRLCAD_OPTIMIZED_BUILD} MATCHES "ON")

# Enable this flag for additional reporting of undefined symbols.
# TODO: Fixing these is a work in progress.
# CHECK_C_COMPILER_FLAG("Wl,--no-undefined" NO_UNDEFINED_LINKER_FLAG)

if(NOT MSVC)
  # We could include this, but these tests are almost entirely for
  # gcc-style flags.  This file is intentionally included after we
  # wipe out the various FLAGS variables.
  include(${BRLCAD_CMAKE_DIR}/BRLCAD_CompilerFlags.cmake)
endif(NOT MSVC)


# *******************************************************************
if(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)
  message("***********************************************************")
  message("*             Stage 4 of 9 - Check for Libraries          *")
  message("***********************************************************")
endif(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)

# While the primary purpose of this section is to identify libraries,
# some of the headers we are looking for are associated with the
# libraries checked here.  In those cases, we will handle the header
# logic here as opposed to separating the header logic from the
# find_package call.

# TODO - need to make LINKOPT vars for anything here that will
# be referenced in a pkgconfig file

# Look for threads (doesn't check for headers)
# The variable CMAKE_THREAD_LIBS_INIT is the one of interest
# when writing target_link_libraries lists.
find_package(Threads)

# Check for the C++ STL library - need to link it explicitly in
# some compilation situations
find_package(STL)

# Check for the daemon function in -lbsd and/or -lc for adrt
BRLCAD_CHECK_LIBRARY(BSD bsd daemon)
BRLCAD_CHECK_LIBRARY(BSD c daemon)

# Check for CoreFoundation and Cocoa on Apple
if(APPLE)
  include(CMakeFindFrameworks)
  CMAKE_FIND_FRAMEWORKS(CoreFoundation)
  if(CoreFoundation_FRAMEWORKS)
    set(CoreFoundation_LIBRARIES "-framework CoreFoundation" CACHE FILEPATH "CoreFoundation framework" FORCE)
  endif(CoreFoundation_FRAMEWORKS)
  CMAKE_FIND_FRAMEWORKS(Cocoa)
  if(Cocoa_FRAMEWORKS)
    set(Cocoa_LIBRARIES "-framework Cocoa" CACHE FILEPATH "Cocoa framework" FORCE)
  endif(Cocoa_FRAMEWORKS)
  mark_as_advanced(CMAKE_OSX_ARCHITECTURES CMAKE_OSX_DEPLOYMENT_TARGET CMAKE_OSX_SYSROOT)
  mark_as_advanced(CoreFoundation_LIBRARIES Cocoa_LIBRARIES)
endif(APPLE)

# Do some extra Java related checks.
if(JNI_FOUND AND JAVA_FOUND)
  BRLCAD_INCLUDE_FILE(JavaVM/jni.h HAVE_JAVAVM_JNI_H)
  BRLCAD_INCLUDE_FILE(jni.h HAVE_JNI_H "${JNI_INCLUDE_DIRS}")
  if(NOT HAVE_JNI_H AND NOT HAVE_JAVAVM_JNI_H AND BRLCAD_ENABLE_RTSERVER)
    set(BRLCAD_ENABLE_RTSERVER OFF CACHE BOOL "RT server disabled due to unsatisfied Java requirements" FORCE)
    message("librtserver build requested, but JNI header not found - disabling")
  endif(NOT HAVE_JNI_H AND NOT HAVE_JAVAVM_JNI_H AND BRLCAD_ENABLE_RTSERVER)
else(JNI_FOUND AND JAVA_FOUND)
  if(BRLCAD_ENABLE_RTSERVER)
    set(BRLCAD_ENABLE_RTSERVER OFF CACHE BOOL "RT server disabled due to unsatisfied Java requirements" FORCE)
    message("librtserver build requested, but Java+JNI not found - disabling")
  endif(BRLCAD_ENABLE_RTSERVER)
endif(JNI_FOUND AND JAVA_FOUND)
mark_as_advanced(BRLCAD_ENABLE_RTSERVER)

# Mark X11 as available if it is enabled and we find Xlib.h
if(BRLCAD_ENABLE_X11)
  if(X11_Xlib_INCLUDE_PATH AND CONFIG_H_FILE)
    set(HAVE_X11_XLIB_H 1)
    CONFIG_H_APPEND(BRLCAD "#cmakedefine HAVE_X11_XLIB_H 1\n")
  endif(X11_Xlib_INCLUDE_PATH AND CONFIG_H_FILE)
endif(BRLCAD_ENABLE_X11)

# math library
BRLCAD_CHECK_LIBRARY(M m cos)

# network socket library (linux, bsd)
BRLCAD_CHECK_LIBRARY(SOCKET socket socket)

# network socket library (solaris)
BRLCAD_CHECK_LIBRARY(NSL nsl gethostbyaddr)

# network socket library (haiku, beos)
BRLCAD_CHECK_LIBRARY(NETWORK network socket)

# malloc library
BRLCAD_CHECK_LIBRARY(MALLOC c mallopt)
BRLCAD_CHECK_LIBRARY(MALLOC malloc mallopt)

# dynamic link library
BRLCAD_CHECK_LIBRARY(DL dl dlopen)

# Solaris lexer library
BRLCAD_CHECK_LIBRARY(SOLARIS_LEXER l yyless)

# timeSetEvent in Windows memory management
if("${HAVE_TIMESETEVENT}" MATCHES "^${HAVE_TIMESETEVENT}$")
  set(CMAKE_REQUIRED_LIBRARIES_BAK ${CMAKE_REQUIRED_LIBRARIES})
  set(CMAKE_REQUIRED_LIBRARIES "winmm.lib")
  check_c_source_compiles("#include <windows.h>\nint main() {(void)timeSetEvent(1000, 100, (LPTIMECALLBACK)NULL, (DWORD_PTR)NULL, TIME_ONESHOT);}" HAVE_TIMESETEVENT)
  if(HAVE_TIMESETEVENT)
    CONFIG_H_APPEND(BRLCAD "#cmakedefine HAVE_TIMESETEVENT 1\n")
    set(WINMM_LIBRARY "winmm.lib")
  endif(HAVE_TIMESETEVENT)
  set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES_BAK})
endif("${HAVE_TIMESETEVENT}" MATCHES "^${HAVE_TIMESETEVENT}$")


# *******************************************************************
if(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)
  message("***********************************************************")
  message("*               Stage 5 of 9 - Check for Headers          *")
  message("***********************************************************")
endif(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)

# C89 headers: assert.h, ctype.h, errno.h, float.h, limits.h, locale.h,
# math.h, setjmp.h, signal.h, stdarg.h, stddef.h, stdio.h, stdlib.h,
# string.h, time.h

# C95 headers: wchar.h, wctype.h, iso646.h

# C99 headers: complex.h, fenv.h, inttypes.h, stdbool.h, stdint.h,
# tgmath.h

# POSIX.1 headers includes C89, C95, and C99 plus the following:
# aio.h, arpa/inet.h, cpio.h, dirent.h, dlfcn.h, fcntl.h, fmtmsg.h,
# fnmatch.h, ftw.h, glob.h, grp.h, iconv.h, langinfo.h, libgen.h,
# monetary.h, mqueue.h, ndbm.h, net/if.h, netdb.h, netinet/in.h,
# netinet/tcp.h, nl_types.h, poll.h, pthread.h, pwd.h, regex.h,
# sched.h, search.h, semaphore.h, spawn.h, strings.h, stropts.h,
# sys/ipc.h, sys/mman.h, sys/msg.h, sys/resource.h, sys/select.h,
# sys/stat.h, sys/statvfs.h, sys/time.h, sys/timeb.h, sys/times.h,
# sys/types.h, sys/uio.h, sys/un.h, sys/utsname.h, sys/wait.h,
# syslog.h, tar.h, termios.h, trace.h, ucontext.h, ulimit.h, unistd.h,
# utime.h, utmpx.h, wordexp.h

# Because libtclcad, bwish and mged include Tcl headers, we need to define
# STDC_HEADERS here - the Tcl headers do need the definition.  Just
# define it - we require C89, so the test itself is not needed.
CONFIG_H_APPEND(BRLCAD "#define STDC_HEADERS 1\n")

# AC_HEADER_SYS_WAIT
BRLCAD_HEADER_SYS_WAIT()
# dirent.h is POSIX.1, but not present on Windows (grr)
# so we need to check for it
BRLCAD_INCLUDE_FILE(dirent.h HAVE_DIRENT_H)

# Need to compare this with the configure.ac list
BRLCAD_INCLUDE_FILE(arpa/inet.h HAVE_ARPA_INET_H)
BRLCAD_INCLUDE_FILE(curses.h HAVE_CURSES_H)
BRLCAD_INCLUDE_FILE(direct.h HAVE_DIRECT_H)
BRLCAD_INCLUDE_FILE(dlfcn.h HAVE_DLFCN_H)
BRLCAD_INCLUDE_FILE(dslib.h HAVE_DSLIB_H)
BRLCAD_INCLUDE_FILE(emmintrin.h HAVE_EMMINTRIN_H)
BRLCAD_INCLUDE_FILE(getopt.h HAVE_GETOPT_H)
BRLCAD_INCLUDE_FILE(gl/device.h HAVE_GL_DEVICE_H)
BRLCAD_INCLUDE_FILE(gl/glext.h HAVE_GL_GLEXT_H)
BRLCAD_INCLUDE_FILE(gl/wglext.h HAVE_GL_WGLEXT_H)
BRLCAD_INCLUDE_FILE(grp.h HAVE_GRP_H)
BRLCAD_INCLUDE_FILE(inttypes.h HAVE_INTTYPES_H)
BRLCAD_INCLUDE_FILE(io.h HAVE_IO_H)
BRLCAD_INCLUDE_FILE(libgen.h HAVE_LIBGEN_H)
BRLCAD_INCLUDE_FILE(mach/thread_policy.h HAVE_MACH_THREAD_POLICY_H)
BRLCAD_INCLUDE_FILE(memory.h HAVE_MEMORY_H)
BRLCAD_INCLUDE_FILE(ncurses.h HAVE_NCURSES_H)
BRLCAD_INCLUDE_FILE(netdb.h HAVE_NETDB_H)
BRLCAD_INCLUDE_FILE(netinet/in.h HAVE_NETINET_IN_H)
BRLCAD_INCLUDE_FILE(poll.h HAVE_POLL_H)
BRLCAD_INCLUDE_FILE(pthread.h HAVE_PTHREAD_H)
BRLCAD_INCLUDE_FILE(pthread_np.h HAVE_PTHREAD_NP_H)
BRLCAD_INCLUDE_FILE(pwd.h HAVE_PWD_H)
BRLCAD_INCLUDE_FILE(rle.h HAVE_RLE_H)
BRLCAD_INCLUDE_FILE(sched.h HAVE_SCHED_H)
BRLCAD_INCLUDE_FILE(sgtty.h HAVE_SGTTY_H)
BRLCAD_INCLUDE_FILE(signal.h HAVE_SIGNAL_H)
BRLCAD_INCLUDE_FILE(stdint.h HAVE_STDINT_H)
BRLCAD_INCLUDE_FILE(stdlib.h HAVE_STDLIB_H)
BRLCAD_INCLUDE_FILE(string.h HAVE_STRING_H)
BRLCAD_INCLUDE_FILE(strings.h HAVE_STRINGS_H)
BRLCAD_INCLUDE_FILE(sys/_ioctl.h HAVE_SYS__IOCTL_H)
BRLCAD_INCLUDE_FILE(sys/cpuset.h HAVE_SYS_CPUSET_H)
BRLCAD_INCLUDE_FILE(sys/file.h HAVE_SYS_FILE_H)
BRLCAD_INCLUDE_FILE(sys/ioctl.h HAVE_SYS_IOCTL_H)
BRLCAD_INCLUDE_FILE(sys/ioctl_compat.h HAVE_SYS_IOCTL_COMPAT_H)
BRLCAD_INCLUDE_FILE(sys/machd.h HAVE_SYS_MACHD_H)
BRLCAD_INCLUDE_FILE(sys/mman.h HAVE_SYS_MMAN_H)
BRLCAD_INCLUDE_FILE(sys/mount.h HAVE_SYS_MOUNT_H)
BRLCAD_INCLUDE_FILE(sys/param.h HAVE_SYS_PARAM_H)
BRLCAD_INCLUDE_FILE(sys/prctl.h HAVE_SYS_PRCTL_H)
BRLCAD_INCLUDE_FILE(sys/resource.h HAVE_SYS_RESOURCE_H)
BRLCAD_INCLUDE_FILE(sys/sched.h HAVE_SYS_SCHED_H)
BRLCAD_INCLUDE_FILE(sys/select.h HAVE_SYS_SELECT_H)
BRLCAD_INCLUDE_FILE(sys/socket.h HAVE_SYS_SOCKET_H)
BRLCAD_INCLUDE_FILE(sys/stat.h HAVE_SYS_STAT_H)
BRLCAD_INCLUDE_FILE(sys/sysctl.h HAVE_SYS_SYSCTL_H)
BRLCAD_INCLUDE_FILE(sys/sysinfo.h HAVE_SYS_SYSINFO_H)
BRLCAD_INCLUDE_FILE(sys/sysmp.h HAVE_SYS_SYSMP_H)
BRLCAD_INCLUDE_FILE(sys/time.h HAVE_SYS_TIME_H)
BRLCAD_INCLUDE_FILE(sys/times.h HAVE_SYS_TIMES_H)
BRLCAD_INCLUDE_FILE(sys/types.h HAVE_SYS_TYPES_H)
BRLCAD_INCLUDE_FILE(sys/un.h HAVE_SYS_UN_H)
BRLCAD_INCLUDE_FILE(sys/wait.h HAVE_SYS_WAIT_H)
BRLCAD_INCLUDE_FILE(syslog.h HAVE_SYSLOG_H)
BRLCAD_INCLUDE_FILE(term.h HAVE_TERM_H)
BRLCAD_INCLUDE_FILE(termcap.h HAVE_TERMCAP_H)
BRLCAD_INCLUDE_FILE(terminfo.h HAVE_TERMINFO_H)
BRLCAD_INCLUDE_FILE(termio.h HAVE_TERMIO_H)
BRLCAD_INCLUDE_FILE(termios.h HAVE_TERMIOS_H)
BRLCAD_INCLUDE_FILE(termlib.h HAVE_TERMLIB_H)
BRLCAD_INCLUDE_FILE(tinfo.h HAVE_TINFO_H)
BRLCAD_INCLUDE_FILE(ulocks.h HAVE_ULOCKS_H)
BRLCAD_INCLUDE_FILE(unistd.h HAVE_UNISTD_H)
BRLCAD_INCLUDE_FILE(windows.h HAVE_WINDOWS_H) # for QueryPerformanceCounter() on Windows
BRLCAD_INCLUDE_FILE(winsock.h HAVE_WINSOCK_H)

# C++
BRLCAD_INCLUDE_FILE_CXX(istream HAVE_ISTREAM)
BRLCAD_INCLUDE_FILE_CXX(limits HAVE_LIMITS)

# Other special-case tests that need custom macros
BRLCAD_CHECK_BASENAME()
BRLCAD_CHECK_DIRNAME()

# OpenGL headers
if(BRLCAD_ENABLE_OPENGL)
  if(OPENGL_INCLUDE_DIR_GL)
    CONFIG_H_APPEND(BRLCAD "#define HAVE_GL_GL_H 1\n")
  endif(OPENGL_INCLUDE_DIR_GL)
  if(OPENGL_INCLUDE_DIR_GLX)
    CONFIG_H_APPEND(BRLCAD "#define HAVE_GL_GLX_H 1\n")
  endif(OPENGL_INCLUDE_DIR_GLX)
endif(BRLCAD_ENABLE_OPENGL)

# may have the header, but ensure it works in pedantic mode (gcc bug)
if(HAVE_EMMINTRIN_H)
  check_cxx_source_compiles("#include <emmintrin.h>\nint main() { return 0; }" HAVE_EMMINTRIN)
  if(HAVE_EMMINTRIN)
    CONFIG_H_APPEND(BRLCAD "#define HAVE_EMMINTRIN 1\n")
  endif(HAVE_EMMINTRIN)
endif(HAVE_EMMINTRIN_H)


# *******************************************************************
if(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)
  message("***********************************************************")
  message("*          Stage 6 of 9 - Check for Types/Structures      *")
  message("***********************************************************")
endif(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)


BRLCAD_STRUCT_MEMBER("struct stat" st_blksize sys/stat.h STRUCT_STAT_ST_BLKSIZE)
BRLCAD_STRUCT_MEMBER("struct stat" st_blocks sys/stat.h STRUCT_STAT_ST_BLOCKS)
BRLCAD_STRUCT_MEMBER("struct stat" st_rdev sys/stat.h STRUCT_STAT_ST_RDEV)

# socklen_t
BRLCAD_TYPE_SIZE("socklen_t" "sys/types.h")
if(NOT HAVE_SOCKLEN_T)
  BRLCAD_TYPE_SIZE("socklen_t" "sys/socket.h")
endif(NOT HAVE_SOCKLEN_T)
BRLCAD_TYPE_SIZE("cpu_set_t" "sched.h")

BRLCAD_TYPE_SIZE("int" "")
BRLCAD_TYPE_SIZE("long" "")
BRLCAD_TYPE_SIZE("long long" "")
BRLCAD_TYPE_SIZE("off_t" "")
BRLCAD_TYPE_SIZE("ptrdiff_t" "")
BRLCAD_TYPE_SIZE("size_t" "")
BRLCAD_TYPE_SIZE("ssize_t" "")
BRLCAD_TYPE_SIZE("uint64_t" "")
BRLCAD_TYPE_SIZE("uintptr_t" "")
BRLCAD_TYPE_SIZE("sig_t" "signal.h")

# see if we have a TLS intrinsic, first check C++11 compliance
check_cxx_source_compiles("static thread_local int i = 0; int main() { return i; }" HAVE_THREAD_LOCAL)
if (HAVE_THREAD_LOCAL)
  CONFIG_H_APPEND(BRLCAD "#define HAVE_THREAD_LOCAL 1\n")
else (HAVE_THREAD_LOCAL)
  # try GCC except Mac OS X
  include(CheckCXXSourceRuns)
  check_cxx_source_runs("static __thread int i = 0; int main() { return i; }" HAVE___THREAD)
  if (HAVE___THREAD)
    CONFIG_H_APPEND(BRLCAD "#define HAVE___THREAD 1\n")
  else (HAVE___THREAD)
    # try Windows
    check_cxx_source_compiles("static __declspec(thread) int i = 0; int main() { return i; }" HAVE___DECLSPEC_THREAD)
    if (HAVE___DECLSPEC_THREAD)
      CONFIG_H_APPEND(BRLCAD "#define HAVE___DECLSPEC_THREAD 1\n")
    endif (HAVE___DECLSPEC_THREAD)
  endif (HAVE___THREAD)
endif (HAVE_THREAD_LOCAL)

# see if the compiler supports %z as a size_t print width specifier
BRLCAD_CHECK_C99_FORMAT_SPECIFIERS()


# *******************************************************************
if(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)
  message("***********************************************************")
  message("*              Stage 7 of 9 - Check for Functions         *")
  message("***********************************************************")
endif(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)


# ALLOCA test - based on AC_FUNC_ALLOCA
BRLCAD_ALLOCA()

BRLCAD_FUNCTION_EXISTS(XQueryExtension HAVE_XQUERYEXTENSION)
BRLCAD_FUNCTION_EXISTS(alarm HAVE_ALARM)
BRLCAD_FUNCTION_EXISTS(dlopen HAVE_DLOPEN)
BRLCAD_FUNCTION_EXISTS(drand48 HAVE_DRAND48)
BRLCAD_FUNCTION_EXISTS(fchmod HAVE_FCHMOD)
BRLCAD_FUNCTION_EXISTS(fsync HAVE_FSYNC)
BRLCAD_FUNCTION_EXISTS(getcwd HAVE_GETCWD)
BRLCAD_FUNCTION_EXISTS(getegid HAVE_GETEGID)
BRLCAD_FUNCTION_EXISTS(geteuid HAVE_GETEUID)
BRLCAD_FUNCTION_EXISTS(gethostname HAVE_GETHOSTNAME)
BRLCAD_FUNCTION_EXISTS(getloadavg HAVE_GETLOADAVG)
BRLCAD_FUNCTION_EXISTS(getopt_long HAVE_GETOPT_LONG)
BRLCAD_FUNCTION_EXISTS(getprogname HAVE_GETPROGNAME) # bsd
BRLCAD_FUNCTION_EXISTS(lrand48 HAVE_LRAND48)
BRLCAD_FUNCTION_EXISTS(memset HAVE_MEMSET)
BRLCAD_FUNCTION_EXISTS(mkstemp HAVE_MKSTEMP)
BRLCAD_FUNCTION_EXISTS(pipe HAVE_PIPE)
BRLCAD_FUNCTION_EXISTS(popen HAVE_POPEN)
BRLCAD_FUNCTION_EXISTS(posix_memalign HAVE_POSIX_MEMALIGN) # IEEE Std 1003.1-2001
BRLCAD_FUNCTION_EXISTS(random HAVE_RANDOM)
BRLCAD_FUNCTION_EXISTS(realpath HAVE_REALPATH)
BRLCAD_FUNCTION_EXISTS(setenv HAVE_SETENV)
BRLCAD_FUNCTION_EXISTS(setpgid HAVE_SETPGID)
BRLCAD_FUNCTION_EXISTS(setpriority HAVE_SETPRIORITY)
BRLCAD_FUNCTION_EXISTS(srand48 HAVE_SRAND48)
BRLCAD_FUNCTION_EXISTS(strcasecmp HAVE_STRCASECMP)
BRLCAD_FUNCTION_EXISTS(strncasecmp HAVE_STRNCASECMP)
BRLCAD_FUNCTION_EXISTS(strchr HAVE_STRCHR)
BRLCAD_FUNCTION_EXISTS(strdup HAVE_STRDUP)
BRLCAD_FUNCTION_EXISTS(strlcat HAVE_STRLCAT)
BRLCAD_FUNCTION_EXISTS(strlcpy HAVE_STRLCPY)
BRLCAD_FUNCTION_EXISTS(strsep HAVE_STRSEP)
BRLCAD_FUNCTION_EXISTS(strtok HAVE_STRTOK)
BRLCAD_FUNCTION_EXISTS(sync HAVE_SYNC)
BRLCAD_FUNCTION_EXISTS(sysctl HAVE_SYSCTL)
BRLCAD_FUNCTION_EXISTS(sysmp HAVE_SYSMP)
BRLCAD_FUNCTION_EXISTS(vfork HAVE_VFORK)
BRLCAD_FUNCTION_EXISTS(vsscanf HAVE_VSSCANF)
BRLCAD_FUNCTION_EXISTS(writev HAVE_WRITEV)

# we may compile in strict pedantic mode, but still want access to
# some POSIX functions.  test whether some symbols (below) are
# declared in addition to whether they resolve (above).
#
# we do this manually for now because CHECK_SYMBOL_EXISTS and
# CHECK_PROTOTYPE_EXISTS are both terribly broken.
#
# FIXME: wrap these into a BRLCAD_CHECK_SYMBOL() macro or similar.

# test for kill()
BRLCAD_FUNCTION_EXISTS(kill HAVE_KILL)
if("${HAVE_DECL_KILL}" MATCHES "^${HAVE_DECL_KILL}$")
  check_c_source_compiles("#include <sys/types.h>\n#include <signal.h>\nint main() { (void)kill; return 0; }" HAVE_DECL_KILL)
  if(HAVE_DECL_KILL)
    CONFIG_H_APPEND(BRLCAD "#cmakedefine HAVE_DECL_KILL 1\n")
  endif(HAVE_DECL_KILL)
endif("${HAVE_DECL_KILL}" MATCHES "^${HAVE_DECL_KILL}$")

# test for fileno()
BRLCAD_FUNCTION_EXISTS(fileno HAVE_FILENO)
if("${HAVE_DECL_FILENO}" MATCHES "^${HAVE_DECL_FILENO}$")
  check_c_source_compiles("#include <stdio.h>\nint main() { (void)fileno; return 0; }" HAVE_DECL_FILENO)
  if(HAVE_DECL_FILENO)
    CONFIG_H_APPEND(BRLCAD "#cmakedefine HAVE_DECL_FILENO 1\n")
  endif(HAVE_DECL_FILENO)
endif("${HAVE_DECL_FILENO}" MATCHES "^${HAVE_DECL_FILENO}$")

# test for program_invocation_name global variable
if("${HAVE_PROGRAM_INVOCATION_NAME}" MATCHES "^${HAVE_PROGRAM_INVOCATION_NAME}$")
  check_c_source_compiles("#define _GNU_SOURCE\n#include <errno.h>\nint main() { return (program_invocation_name)?0:1; }" HAVE_PROGRAM_INVOCATION_NAME)
  if(HAVE_PROGRAM_INVOCATION_NAME)
    CONFIG_H_APPEND(BRLCAD "#cmakedefine HAVE_PROGRAM_INVOCATION_NAME 1\n")
  endif(HAVE_PROGRAM_INVOCATION_NAME)
endif("${HAVE_PROGRAM_INVOCATION_NAME}" MATCHES "^${HAVE_PROGRAM_INVOCATION_NAME}$")

# test for lrint
BRLCAD_FUNCTION_EXISTS(lrint HAVE_LRINT)
if("${HAVE_LRINT}" MATCHES "^${HAVE_LRINT}$")
  set(CMAKE_REQUIRED_LIBRARIES_BAK ${CMAKE_REQUIRED_LIBRARIES})
  set(CMAKE_REQUIRED_LIBRARIES ${M_LIBRARY})
  check_c_source_compiles("#include <math.h>\nint main() {return lrint(3.14);}" HAVE_LRINT)
  if(HAVE_LRINT)
    CONFIG_H_APPEND(BRLCAD "#cmakedefine HAVE_LRINT 1\n")
  else(HAVE_LRINT)
    check_c_source_compiles("#include \"${CMAKE_CURRENT_SOURCE_DIR}/misc/CMake/test_srcs/lrint_macro.h\"\n#include <math.h>\nint main() {return lrint(3.14);}" HAVE_WORKING_LRINT_MACRO)
    if(HAVE_WORKING_LRINT_MACRO)
      CONFIG_H_APPEND(BRLCAD "#cmakedefine HAVE_WORKING_LRINT_MACRO 1\n")
    endif(HAVE_WORKING_LRINT_MACRO)
  endif(HAVE_LRINT)
  set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES_BAK})
endif("${HAVE_LRINT}" MATCHES "^${HAVE_LRINT}$")

# test for tgamma
BRLCAD_FUNCTION_EXISTS(tgamma HAVE_TGAMMA)
if("${HAVE_TGAMMA}" MATCHES "^${HAVE_TGAMMA}$")
  set(CMAKE_REQUIRED_LIBRARIES_BAK ${CMAKE_REQUIRED_LIBRARIES})
  set(CMAKE_REQUIRED_LIBRARIES ${M_LIBRARY})
  check_c_source_compiles("#include <math.h>\nint main() {double tga = tgamma(3.14); return 0;}" HAVE_TGAMMA)
  if(HAVE_TGAMMA)
    CONFIG_H_APPEND(BRLCAD "#cmakedefine HAVE_TGAMMA 1\n")
  endif(HAVE_TGAMMA)
  set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES_BAK})
endif("${HAVE_TGAMMA}" MATCHES "^${HAVE_TGAMMA}$")

#-----------------------------------------------------------------------
# check C99 and POSIX 200112L missing functions with a more
# rigorously-controlled compiler environment
if(ENABLE_POSIX_COMPLIANCE
    OR ENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE)

  set(needed_FUNCS
    test_fdopen
    test_fileno
    test_realpath
    test_gethostname
    test_posix_memalign
    test_strcasecmp
    test_strncasecmp
    test_sigaction
    test_strtok_r
    )

  foreach(tprog ${needed_FUNCS})
    # remove "test_" from tprog
    STRING(REGEX REPLACE "test_" "" func ${tprog})
    STRING(TOUPPER "${func}" FUNC)

    TRY_COMPILE(success
      "${CMAKE_BINARY_DIR}/test_funcs"
      "${CMAKE_SOURCE_DIR}/misc/CMake/compat/${tprog}.c"
      CMAKE_FLAGS "${CMAKE_C_FLAGS}"
      )

    if(success)
      CONFIG_H_APPEND(BRLCAD "#define HAVE_WORKING_${FUNC}_FUNCTION 1\n")
      message("Try compile '${tprog}.c' (function ${func}) SUCCESS")
    else()
      message("Try compile '${tprog}.c' (function ${func}) FAIL")
    endif()

  endforeach()

endif()
#-----------------------------------------------------------------------

# On Windows, we need to check for hypot etc.  This test pertains
# to the windows specific config file, not CONFIG_H_FILE - hence,
# just run the test and it will be handled by configure_file later.
include(CheckSymbolExists)
if(WIN32)
  # consider all warnings as errors (MSVC)
  set(CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS} /WX)

  CHECK_SYMBOL_EXISTS(hypot "math.h" HAVE_HYPOT)
  #If we don't have it, need to define it as _hypot in config_win
  if(NOT HAVE_HYPOT)
    set(hypot 1)
  endif(NOT HAVE_HYPOT)

  CHECK_SYMBOL_EXISTS(asinh "math.h" HAVE_ASINH)
  #If we don't have it, need to define it in config_win
  if(NOT HAVE_ASINH)
    set(asinh 1)
  endif(NOT HAVE_ASINH)

  BRLCAD_FUNCTION_EXISTS(_fseeki64 HAVE__FSEEKI64)
  BRLCAD_FUNCTION_EXISTS(_ftelli64 HAVE__FTELLI64)

endif(WIN32)

# Check whether we need to add import/export lines to libraries
if(MSVC)
  set(CPP_DLL_DEFINES 1)
endif(MSVC)

# *******************************************************************
if(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)
  message("***********************************************************")
  message("*          Stage 8 of 9 - Check for System Services       *")
  message("***********************************************************")
endif(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)

# For Windows, we need some dlls to be redistributed with the
# installer
if(MSVC)
  # By default, do not warn when built on machines using only VS Express
  # From: http://www.cmake.org/pipermail/cmake/2011-May/044166.html
  if(NOT DEFINED CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_NO_WARNINGS)
    set(CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_NO_WARNINGS ON)
  endif()
  include(InstallRequiredSystemLibraries)
endif(MSVC)

# Before we finalize, set some specific global linker flags
if(MSVC)
  set(CMAKE_EXE_LINKER_FLAGS_INIT ${CMAKE_EXE_LINKER_FLAGS_INIT} /NOLOGO)
  set(CMAKE_SHARED_LINKER_FLAGS_INIT ${CMAKE_EXE_LINKER_FLAGS_INIT} /NOLOGO)
  set(CMAKE_MODULE_LINKER_FLAGS_INIT ${CMAKE_EXE_LINKER_FLAGS_INIT} /NOLOGO)
endif(MSVC)

#-----------------------------------------------------------------------------
# Before we head into src/other and misc/tools, store all the build
# flags that have been built up.  It's hard to be sure what will and
# won't be set in those directories, so make sure we can restore the
# BRL-CAD flags for the actual BRL-CAD subdirectories.
CACHE_BUILD_FLAGS(_BRLCAD)

# For lower build levels, some of the third party components are not
# needed.  define some variables we can use for testing.
set(BRLCAD_LEVEL2 0)
set(BRLCAD_LEVEL3 0)
if(NOT BRLCAD_ENABLE_TARGETS)
  set(BRLCAD_LEVEL2 1)
  set(BRLCAD_LEVEL3 1)
else(NOT BRLCAD_ENABLE_TARGETS)
  if(${BRLCAD_ENABLE_TARGETS} GREATER 1)
    set(BRLCAD_LEVEL2 1)
  endif(${BRLCAD_ENABLE_TARGETS} GREATER 1)
  if(${BRLCAD_ENABLE_TARGETS} GREATER 2)
    set(BRLCAD_LEVEL3 1)
  endif(${BRLCAD_ENABLE_TARGETS} GREATER 2)
endif(NOT BRLCAD_ENABLE_TARGETS)

# At the start, clear the src/other subdirs list so repeated
# configures will correctly add the required directories
set(SRC_OTHER_ADDED_DIRS "" CACHE STRING "initialize 3rd party sub-directories list" FORCE)
mark_as_advanced(SRC_OTHER_ADDED_DIRS)

macro(SetTargetFolder targetname folder)
  if(TARGET ${targetname})
    set_target_properties(${targetname} PROPERTIES FOLDER "${folder}")
  endif(TARGET ${targetname})
endmacro(SetTargetFolder)

# Load some CMake macros to handle the special case of third party libraries.
include(${BRLCAD_CMAKE_DIR}/ThirdParty.cmake)

# Add misc/tools for tools that are used in BRL-CAD's build process
# but are not otherwise usable in BRL-CAD (due to licensing, design
# intent, etc.)
add_subdirectory(misc/tools)

# Now that we've done the system tests with BRL-CAD's compile flags,
# add src/other to pick up any tests it needs.  We must add src/other
# before the main BRL-CAD directories to provide the necessary build
# targets.  Remember that src/other wipes the top level flags generated
# by BRL-CAD for its own subdirectories - it is added after the BRL-CAD
# tests so the CACHE reflects BRL-CAD's test results.
add_subdirectory(src/other)

# Now put back the BRL-CAD flags
RESTORE_CACHED_BUILD_FLAGS(_BRLCAD)

# *******************************************************************
if(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)
  message("***********************************************************")
  message("*        Stage 9 of 9 - Define BRL-CAD Build Targets      *")
  message("***********************************************************")
endif(NOT EXISTS ${CMAKE_BINARY_DIR}/CMakeCache.txt.prev)

# Make sure the flags that were cleared earlier are at least set
# to empty - CMake considers them "required internal variables".
set(CMAKE_REQUIRED_FLAG_VARS
  CMAKE_C_FLAGS
  CMAKE_CXX_FLAGS
  CMAKE_SHARED_LINKER_FLAGS
  CMAKE_EXE_LINKER_FLAGS
  )
foreach(req_var ${CMAKE_REQUIRED_FLAG_VARS})
  if(NOT DEFINED ${req_var})
    set(${req_var} "")
  endif(NOT DEFINED ${req_var})
endforeach(req_var ${CMAKE_REQUIRED_FLAG_VARS})

# Enable CTest Testing support - this is done after src/other is
# added to avoid incorporating src/other CTests into BRL-CAD's own
# testing.  TODO - probably should control this with an option.
ENABLE_TESTING()

# We've done the toplevel configure steps, now add the subdirectories
macro(verbose_add_subdirectory root dir)
  if(NOT EXISTS ${BRLCAD_BINARY_DIR}/CMakeCache.txt.prev)
    if(NOT "${root}" STREQUAL "")
      message("-- Adding ${root}/${dir}...")
    else(NOT "${root}" STREQUAL "")
      message("-- Adding ${dir}...")
    endif(NOT "${root}" STREQUAL "")
  endif(NOT EXISTS ${BRLCAD_BINARY_DIR}/CMakeCache.txt.prev)
  add_subdirectory(${dir})
  if(NOT EXISTS ${BRLCAD_BINARY_DIR}/CMakeCache.txt.prev)
    if(NOT "${root}" STREQUAL "")
      message("-- Adding ${root}/${dir} - done")
    else(NOT "${root}" STREQUAL "")
      message("-- Adding ${dir} - done")
    endif(NOT "${root}" STREQUAL "")
  endif(NOT EXISTS ${BRLCAD_BINARY_DIR}/CMakeCache.txt.prev)
endmacro()

verbose_add_subdirectory("" src)
verbose_add_subdirectory("" include)
verbose_add_subdirectory("" sh)
verbose_add_subdirectory("" misc)
if(NOT BRLCAD_ENABLE_TARGETS OR "${BRLCAD_ENABLE_TARGETS}" GREATER 2)
  verbose_add_subdirectory("" doc)
  verbose_add_subdirectory("" db)
  verbose_add_subdirectory("" bench)
  verbose_add_subdirectory("" regress)
else(NOT BRLCAD_ENABLE_TARGETS OR "${BRLCAD_ENABLE_TARGETS}" GREATER 2)
  CMAKEFILES(doc bench regress db)
endif(NOT BRLCAD_ENABLE_TARGETS OR "${BRLCAD_ENABLE_TARGETS}" GREATER 2)

# *******************************************************************
# ***        Output and Summarize Results - Stage 9 of 9          ***
# *******************************************************************

#---------------------------------------------------------------------
# Record compile-time information we may want to report at run-time.
# Generate the include/conf files.

# COUNT - Count how many times the configuration has changed.  Currently
# we are detecting a configuration change by looking at the previous version
# of the CMakeCache.txt file and looking for changes between values stored
# there and settings in the current environment.  This has the disadvantage
# of not spotting completely new variables in the current environment, but
# the internal CMake variable list is too noisy so at the moment this looks
# like the best alternative we have.

if(EXISTS ${BRLCAD_BINARY_DIR}/include/conf/COUNT)
  include(${BRLCAD_CMAKE_DIR}/DiffCache.cmake)
  DIFF_CACHE_file()
  if(INCREMENT_COUNT_FILE)
    file(READ ${BRLCAD_BINARY_DIR}/include/conf/COUNT buildCounter_raw)
    string(STRIP ${buildCounter_raw} buildCounter)
    math(EXPR buildCounter "${buildCounter} + 1")
    file(WRITE ${BRLCAD_BINARY_DIR}/include/conf/COUNT "${buildCounter}\n")
  endif(INCREMENT_COUNT_FILE)
else(EXISTS ${BRLCAD_BINARY_DIR}/include/conf/COUNT)
  set(buildCounter 0)
  file(WRITE ${BRLCAD_BINARY_DIR}/include/conf/COUNT "${buildCounter}\n")
endif(EXISTS ${BRLCAD_BINARY_DIR}/include/conf/COUNT)
DISTCLEAN(${BRLCAD_BINARY_DIR}/include/conf/COUNT)

# DATE - Increment this when we increment the COUNT, to avoid triggering
# excessive relinking (an RFC2822 timestamp changes every second).
file(READ ${CONFIG_TIMESTAMP_FILE} DATESTAMP)
string(STRIP ${DATESTAMP} DATESTAMP)
if(INCREMENT_COUNT_FILE OR NOT EXISTS ${BRLCAD_BINARY_DIR}/include/conf/DATE)
  file(WRITE ${BRLCAD_BINARY_DIR}/include/conf/DATE.tmp "\"${DATESTAMP}\"\n")
  execute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BRLCAD_BINARY_DIR}/include/conf/DATE.tmp ${BRLCAD_BINARY_DIR}/include/conf/DATE)
  execute_process(COMMAND ${CMAKE_COMMAND} -E remove	${BRLCAD_BINARY_DIR}/include/conf/DATE.tmp)
endif(INCREMENT_COUNT_FILE OR NOT EXISTS ${BRLCAD_BINARY_DIR}/include/conf/DATE)
DISTCLEAN(${BRLCAD_BINARY_DIR}/include/conf/DATE)

# HOST
configure_file(${BRLCAD_CMAKE_DIR}/test_srcs/report_hostname.c.in ${CMAKE_BINARY_DIR}/CMakeTmp/report_hostname.c)
if(NOT MSVC)
  TRY_RUN(TIME_RESULT TIME_COMPILED
    ${CMAKE_BINARY_DIR}/CMakeTmp
    ${CMAKE_BINARY_DIR}/CMakeTmp/report_hostname.c
    OUTPUT_VARIABLE COMPILEMESSAGES)
else(NOT MSVC)
  set(CMAKE_REQUIRED_LIBRARIES ws2_32.lib)
  TRY_RUN(TIME_RESULT TIME_COMPILED
    ${CMAKE_BINARY_DIR}/CMakeTmp
    ${CMAKE_BINARY_DIR}/CMakeTmp/report_hostname.c
    OUTPUT_VARIABLE COMPILEMESSAGES
    CMAKE_FLAGS "-DLINK_LIBRARIES:STRING=ws2_32.lib")
endif(NOT MSVC)
# Let CMake give us the proper newline character(s) for the current platform
file(APPEND ${BRLCAD_BINARY_DIR}/include/conf/HOST.tmp "\n")
execute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BRLCAD_BINARY_DIR}/include/conf/HOST.tmp ${BRLCAD_BINARY_DIR}/include/conf/HOST)
execute_process(COMMAND ${CMAKE_COMMAND} -E remove	${BRLCAD_BINARY_DIR}/include/conf/HOST.tmp)
DISTCLEAN(${BRLCAD_BINARY_DIR}/include/conf/HOST)

# USER
configure_file(${BRLCAD_CMAKE_DIR}/test_srcs/report_username.c.in ${CMAKE_BINARY_DIR}/CMakeTmp/report_username.c)
TRY_RUN(TIME_RESULT TIME_COMPILED
  ${CMAKE_BINARY_DIR}/CMakeTmp
  ${CMAKE_BINARY_DIR}/CMakeTmp/report_username.c
  OUTPUT_VARIABLE COMPILEMESSAGES)
# Let CMake give us the proper newline character(s) for the current platform
file(APPEND ${BRLCAD_BINARY_DIR}/include/conf/USER.tmp "\n")
execute_process(COMMAND ${CMAKE_COMMAND} -E copy_if_different ${BRLCAD_BINARY_DIR}/include/conf/USER.tmp ${BRLCAD_BINARY_DIR}/include/conf/USER)
execute_process(COMMAND ${CMAKE_COMMAND} -E remove ${BRLCAD_BINARY_DIR}/include/conf/USER.tmp)
DISTCLEAN(${BRLCAD_BINARY_DIR}/include/conf/USER)


# Write out version and compilation information

file(READ ${BRLCAD_BINARY_DIR}/include/conf/DATE BRLCAD_COMPILE_DATE)
file(READ ${BRLCAD_BINARY_DIR}/include/conf/HOST BRLCAD_COMPILE_HOST)
file(READ ${BRLCAD_BINARY_DIR}/include/conf/USER BRLCAD_COMPILE_USER)
file(READ ${BRLCAD_BINARY_DIR}/include/conf/COUNT BRLCAD_COMPILE_COUNT)

string(STRIP ${BRLCAD_COMPILE_DATE} BRLCAD_COMPILE_DATE)
string(STRIP ${BRLCAD_COMPILE_HOST} BRLCAD_COMPILE_HOST)
string(STRIP ${BRLCAD_COMPILE_USER} BRLCAD_COMPILE_USER)
string(STRIP ${BRLCAD_COMPILE_COUNT} BRLCAD_COMPILE_COUNT)

CONFIG_H_APPEND(BRLCAD "#define BRLCAD_COMPILE_DATE ${BRLCAD_COMPILE_DATE}\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_COMPILE_HOST ${BRLCAD_COMPILE_HOST}\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_COMPILE_USER ${BRLCAD_COMPILE_USER}\n")
CONFIG_H_APPEND(BRLCAD "#define BRLCAD_COMPILE_COUNT ${BRLCAD_COMPILE_COUNT}\n")

# If we're building on Windows, use config_win.h file
if(WIN32)
  CONFIG_H_APPEND(BRLCAD "#include \"config_win.h\"\n")
endif(WIN32)

# Now that all the tests are done, configure the brlcad_config.h file:
CONFIG_H_APPEND(BRLCAD "#endif /* __CONFIG_H__ */\n")
get_property(CONFIG_H_FILE_CONTENTS GLOBAL PROPERTY ${CMAKE_PROJECT_NAME}_CONFIG_H_CONTENTS)
file(WRITE ${CONFIG_H_FILE} "${CONFIG_H_FILE_CONTENTS}")
configure_file(${CONFIG_H_FILE} ${BRLCAD_BINARY_DIR}/include/brlcad_config.h)

# Generate the windows specific file, if needed
if(WIN32)
  configure_file(${BRLCAD_SOURCE_DIR}/include/config_win.h.in ${BRLCAD_BINARY_DIR}/include/config_win.h)
endif(WIN32)

# Create a 1 second sleep utility executable
try_compile(BUILD_SLEEP
  "${CMAKE_CURRENT_BINARY_DIR}/CMakeTmp"
  "${BRLCAD_CMAKE_DIR}/test_srcs/sleep.c"
  COMPILE_DEFINITIONS -DBRLCADBUILD -DHAVE_CONFIG_H
  -I"${CMAKE_CURRENT_BINARY_DIR}/include"
  -I"${CMAKE_CURRENT_SOURCE_DIR}/include"
  OUTPUT_VARIABLE BUILD_SLEEP_LOG
  COPY_FILE "${CMAKE_CURRENT_BINARY_DIR}/CMakeTmp/sleep.bin")
if(NOT BUILD_SLEEP)
  message(FATAL_ERROR "BUILD_SLEEP failure: ${BUILD_SLEEP_LOG}")
endif(NOT BUILD_SLEEP)

# Rules for the toplevel documentation files
set(toplevel_DOCFILES
  AUTHORS
  CHANGES
  COPYING
  HACKING
  INSTALL
  NEWS
  README
  )
BRLCAD_ADDDATA(toplevel_DOCFILES ".")

# Now that everything is configured, print a summary of the build
# settings.
if(NOT BRLCAD_DISABLE_SUMMARY)
  include(${BRLCAD_CMAKE_DIR}/BRLCAD_Summary.cmake)
endif(NOT BRLCAD_DISABLE_SUMMARY)


# *******************************************************************
# ***                      Timestamp Rules                        ***
# *******************************************************************
# TODO - As of CMake 2.8.11, the string command has a TIMESTAMP option
# that may be able to simplify some of the current timestamp system.
# We would need to be able to require 2.8.11 or newer, so there will
# be a bit of a wait, but it's something to look into.
if(NOT BRLCAD_IS_SUBBUILD)
  # Set up rules to print a timestamp string during build
  set(BUILD_DELTA_FILE "${CMAKE_BINARY_DIR}/CMakeTmp/BUILD_DELTA_FILE")
  set(BUILD_DELTA_START "${CMAKE_BINARY_DIR}/CMakeTmp/BUILD_DELTA_START")
  set(BUILD_DELTA_END "${CMAKE_BINARY_DIR}/CMakeTmp/BUILD_DELTA_END")
  configure_file(${BRLCAD_CMAKE_DIR}/test_srcs/builddelta_start.c.in
    ${CMAKE_BINARY_DIR}/CMakeTmp/builddelta_start.c)
  # The install instructions at the end of the message are tool specific - key
  # off of generators or build tools.
  if("${CMAKE_GENERATOR}" MATCHES "Make")
    set(INSTALL_LINE "Run 'make install' to begin installation into ${CMAKE_INSTALL_PREFIX}")
    set(BENCHMARK_LINE "Run 'make benchmark' to run the BRL-CAD Benchmark Suite")
  endif("${CMAKE_GENERATOR}" MATCHES "Make")
  if("${CMAKE_GENERATOR}" MATCHES "Ninja")
    set(INSTALL_LINE "Run 'ninja install' to begin installation into ${CMAKE_INSTALL_PREFIX}")
    set(BENCHMARK_LINE "Run 'ninja benchmark' to run the BRL-CAD Benchmark Suite")
  endif("${CMAKE_GENERATOR}" MATCHES "Ninja")
  if("${CMAKE_GENERATOR}" MATCHES "Xcode")
    set(INSTALL_LINE "Run 'xcodebuild -target install' to begin installation into ${CMAKE_INSTALL_PREFIX}")
    set(BENCHMARK_LINE "Run 'xcodebuild -target benchmark' to run the BRL-CAD Benchmark Suite")
  endif("${CMAKE_GENERATOR}" MATCHES "Xcode")
  if(MSVC)
    # slightly misuse the lines for MSVC, since we don't usually do the
    # install/benchmark routine there. (Benchmarks aren't currently supported
    # in MSVC anyway.)
    set(INSTALL_LINE "To build, launch Visual Studio and open ${CMAKE_BINARY_DIR}/BRLCAD.sln")
    set(BENCHMARK_LINE "Build the ALL_BUILD target.  To create an NSIS installer, build the PACKAGE target")
  endif(MSVC)
  configure_file(${BRLCAD_CMAKE_DIR}/test_srcs/builddelta_end.c.in
    ${CMAKE_BINARY_DIR}/CMakeTmp/builddelta_end.c)
  add_executable(printtimestamp misc/CMake/test_srcs/print_timestamp.c)
  set_target_properties(printtimestamp PROPERTIES FOLDER "Compilation Utilities")
  add_executable(buildtimestart ${CMAKE_BINARY_DIR}/CMakeTmp/builddelta_start.c)
  set_target_properties(buildtimestart PROPERTIES FOLDER "Compilation Utilities")
  add_executable(buildtimeend ${CMAKE_BINARY_DIR}/CMakeTmp/builddelta_end.c)
  set_target_properties(buildtimeend PROPERTIES FOLDER "Compilation Utilities")
  add_custom_command(
    OUTPUT ${BUILD_DELTA_FILE}
    COMMAND buildtimestart
    COMMENT ""
    DEPENDS buildtimestart
    )
  add_custom_target(timestamp ALL
    COMMAND printtimestamp
    COMMAND ${CMAKE_COMMAND} -E rename ${BUILD_DELTA_FILE} ${BUILD_DELTA_START}
    DEPENDS ${BUILD_DELTA_FILE} printtimestamp
    )
  set_target_properties(timestamp PROPERTIES FOLDER "Compilation Utilities")
  add_custom_target(buildtimedelta ALL
    COMMAND buildtimeend
    COMMAND ${CMAKE_COMMAND} -E remove ${BUILD_DELTA_START}
    DEPENDS buildtimeend
    )
  set_target_properties(buildtimedelta PROPERTIES FOLDER "Compilation Utilities")
endif(NOT BRLCAD_IS_SUBBUILD)

# We want the timestamp to come first, so make ALL library,
# exec and external targets depend on timestamp (except for
# the exec target printtimestamp, which is needed by timestamp)
# Similarly, buildtimedelta needs to depend on every target.
if(NOT BRLCAD_IS_SUBBUILD)
  get_property(CMAKE_LIBRARY_TARGET_LIST GLOBAL PROPERTY CMAKE_LIBRARY_TARGET_LIST)
  get_property(CMAKE_EXEC_TARGET_LIST GLOBAL PROPERTY CMAKE_EXEC_TARGET_LIST)
  get_property(CMAKE_CUSTOM_TARGET_LIST GLOBAL PROPERTY CMAKE_CUSTOM_TARGET_LIST)
  get_property(CMAKE_EXTERNAL_TARGET_LIST GLOBAL PROPERTY CMAKE_EXTERNAL_TARGET_LIST)
  mark_as_advanced(CMAKE_LIBRARY_TARGET_LIST)
  mark_as_advanced(CMAKE_EXEC_TARGET_LIST)
  mark_as_advanced(CMAKE_CUSTOM_TARGET_LIST)
  mark_as_advanced(CMAKE_EXTERNAL_TARGET_LIST)
  list(REMOVE_DUPLICATES CMAKE_LIBRARY_TARGET_LIST)
  list(REMOVE_DUPLICATES CMAKE_EXEC_TARGET_LIST)
  list(REMOVE_DUPLICATES CMAKE_CUSTOM_TARGET_LIST)
  if(CMAKE_EXTERNAL_TARGET_LIST)
    list(REMOVE_DUPLICATES CMAKE_EXTERNAL_TARGET_LIST)
  endif(CMAKE_EXTERNAL_TARGET_LIST)
  foreach(libtarget ${CMAKE_LIBRARY_TARGET_LIST})
    #TODO - can this locate test be replaced with if(TARGET ${libtarget}) ?
    if(NOT CMAKE_BUILD_TYPE)
      get_target_property(target_location ${libtarget} LOCATION)
    else(NOT CMAKE_BUILD_TYPE)
      get_target_property(target_location ${libtarget} LOCATION_${CMAKE_BUILD_TYPE})
    endif(NOT CMAKE_BUILD_TYPE)
    if(target_location)
      add_dependencies(${libtarget} timestamp)
      add_dependencies(buildtimedelta ${libtarget})
    endif(target_location)
  endforeach(libtarget ${CMAKE_LIBRARY_TARGET_LIST})
  foreach(exectarget ${CMAKE_EXEC_TARGET_LIST})
    if(NOT CMAKE_BUILD_TYPE)
      get_target_property(target_location ${exectarget} LOCATION)
    else(NOT CMAKE_BUILD_TYPE)
      get_target_property(target_location ${exectarget} LOCATION_${CMAKE_BUILD_TYPE})
    endif(NOT CMAKE_BUILD_TYPE)
    if(target_location)
      if(NOT ${exectarget} MATCHES "printtimestamp" AND NOT ${exectarget} MATCHES "buildtimestart")
	add_dependencies(${exectarget} timestamp)
      endif()
      add_dependencies(buildtimedelta ${exectarget})
    endif(target_location)
  endforeach(exectarget ${CMAKE_EXEC_TARGET_LIST})
  foreach(custtarget ${CMAKE_CUSTOM_TARGET_LIST})
    if(NOT ${custtarget} MATCHES "timestamp")
      add_dependencies(${custtarget} timestamp)
    endif()
    if(NOT ${custtarget} MATCHES "buildtimedelta")
      get_target_property(not_in_all ${custtarget} EXCLUDE_FROM_ALL)
      if(NOT not_in_all)
	add_dependencies(buildtimedelta ${custtarget})
      endif(NOT not_in_all)
    endif(NOT ${custtarget} MATCHES "buildtimedelta")
  endforeach(custtarget ${CMAKE_CUSTOM_TARGET_LIST})
  foreach(externaltarget ${CMAKE_EXTERNAL_TARGET_LIST})
    get_target_property(target_confcmd ${externaltarget} _EP_CONFIGURE_COMMAND)
    if(target_confcmd)
      add_dependencies(${externaltarget} timestamp)
      add_dependencies(buildtimedelta ${externaltarget})
    endif(target_confcmd)
  endforeach(externaltarget ${CMAKE_EXTERNAL_TARGET_LIST})

endif(NOT BRLCAD_IS_SUBBUILD)


# To set correct install paths for CMake at build time, rather than CMake
# time, some rather special logic is necessary - a build target that needs
# to be run when the current build type changes, and introspective scripting
# that updates the CMake files themselves to have the correct path.
# Unfortunately, there does not appear to be a way to control this well enough
# from the CMake level - a build-type aware path is technically possible, but
# it does not conform to BRL-CAD's conventions for installation directory
# naming.
if(CMAKE_CONFIGURATION_TYPES AND NOT BRLCAD_IS_SUBBUILD)
  # if we have stale cmake_install.cmake.orig files around, clear them now.
  file(GLOB_RECURSE ALL_CMAKE_INSTALL_FILES_ORIG "*cmake_install.cmake.orig")
  if(ALL_CMAKE_INSTALL_FILES_ORIG)
    file(REMOVE ${ALL_CMAKE_INSTALL_FILES_ORIG})
  endif(ALL_CMAKE_INSTALL_FILES_ORIG)
  # need a build target for this one - install directory may be dependent on configuration, but that won't
  # do for BRL-CAD reporting purposes - must get the fully qualified path at build time.
  string(REPLACE "\${BUILD_TYPE}" "----BUILD_TYPE----" CMAKE_INSTALL_PREFIX_CFG "${CMAKE_INSTALL_PREFIX}")
  configure_file(${BRLCAD_CMAKE_DIR}/multiconfig_path_clean.cmake.in ${CMAKE_BINARY_DIR}/CMakeTmp/multiconfig_path_clean.cmake @ONLY)
  configure_file(${BRLCAD_CMAKE_DIR}/multiconfig_path_read.cmake.in ${CMAKE_BINARY_DIR}/CMakeTmp/multiconfig_path_read.cmake @ONLY)
  if(EXISTS ${CMAKE_BINARY_DIR}/CMakeTmp/CURRENT_PATH)
    file(REMOVE_RECURSE ${CMAKE_BINARY_DIR}/CMakeTmp/CURRENT_PATH)
  endif(EXISTS ${CMAKE_BINARY_DIR}/CMakeTmp/CURRENT_PATH)
  file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/CMakeTmp/CURRENT_PATH)
  add_custom_command(
    OUTPUT "${CMAKE_BINARY_DIR}/CMakeTmp/CURRENT_PATH/${CMAKE_CFG_INTDIR}.done"
    COMMAND "${CMAKE_COMMAND}" -P "${CMAKE_BINARY_DIR}/CMakeTmp/multiconfig_path_clean.cmake"
    COMMAND "${CMAKE_COMMAND}" -E touch "${CMAKE_BINARY_DIR}/CMakeTmp/CURRENT_PATH/${CMAKE_CFG_INTDIR}"
    COMMAND "${CMAKE_COMMAND}" -P "${CMAKE_BINARY_DIR}/CMakeTmp/multiconfig_path_read.cmake"
    COMMAND "${CMAKE_COMMAND}" -E touch "${CMAKE_BINARY_DIR}/CMakeTmp/CURRENT_PATH/${CMAKE_CFG_INTDIR}.done"
    )
  # To make sure multiconfig_path runs in time for the source code builds it might impact, we will need to add the output file as a dependency
  # to the first target to run - the timestamp printing.
  add_custom_target(multiconfig_path DEPENDS "${CMAKE_BINARY_DIR}/CMakeTmp/CURRENT_PATH/${CMAKE_CFG_INTDIR}.done")
  set_target_properties(multiconfig_path PROPERTIES FOLDER "Compilation Utilities")
  add_dependencies(timestamp multiconfig_path)
endif(CMAKE_CONFIGURATION_TYPES AND NOT BRLCAD_IS_SUBBUILD)


# CPack is used to produce tgz files, RPMS, etc.  If SUBBUILD is enabled this
# becomes the responsibility of the parent project.
if(NOT BRLCAD_IS_SUBBUILD)
  option(BRLCAD_VERSIONED_RPM_NAME "Incorporate BRL-CAD version into RPM package name" OFF)
  mark_as_advanced(BRLCAD_VERSIONED_RPM_NAME)
  set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "BRL-CAD - a powerful cross-platform open source solid modeling system")
  set(CPACK_PACKAGE_VENDOR "BRL-CAD Development Team")
  set(CPACK_RESOURCE_FILE_README ${CMAKE_CURRENT_SOURCE_DIR}/README)
  set(CPACK_RESOURCE_FILE_LICENSE ${CMAKE_CURRENT_SOURCE_DIR}/COPYING)
  set(CPACK_PACKAGE_VERSION_MAJOR ${BRLCAD_VERSION_MAJOR})
  set(CPACK_PACKAGE_VERSION_MINOR ${BRLCAD_VERSION_MINOR})
  set(CPACK_PACKAGE_VERSION_PATCH ${BRLCAD_VERSION_PATCH})
  if(BRLCAD_VERSIONED_RPM_NAME)
    set(CPACK_RPM_PACKAGE_NAME "BRL-CAD_${BRLCAD_VERSION}")
  endif(BRLCAD_VERSIONED_RPM_NAME)

  if(UNIX)
    set(CPACK_STRIP_FILES TRUE)
  endif(UNIX)

  if(UNIX)
    set(CPACK_PACKAGING_INSTALL_PREFIX ${CMAKE_INSTALL_PREFIX})
  endif(UNIX)

  if(UNIX AND NOT APPLE)
    set(CPACK_GENERATOR TGZ TBZ2)

    find_program(RPMBUILD_EXEC rpmbuild)
    mark_as_advanced(RPMBUILD_EXEC)
    if(RPMBUILD_EXEC)
      # Since RPM packages present a particular problem with bad umask
      # settings and RPM package building is enabled, raise the issue again
      # with a longer wait time.
      if (NOT UMASK_OK)
	message(" ")
	message(WARNING "umask is set to ${umask_curr} and RPM package building is enabled - this is not a 'standard' umask setting for BRL-CAD RPM packages.  Double check that these umask permissions will have the desired results when installed - RPM packages can impact permissions on system directories such as /usr\nIf the umask settings need to be changed, it is recommended that the build directory be cleared and cmake re-run after the umask setting has been changed.")
	if(SLEEP_EXEC)
	  execute_process(COMMAND ${SLEEP_EXEC} 5)
	endif(SLEEP_EXEC)
      endif (NOT UMASK_OK)

      set(CPACK_GENERATOR ${CPACK_GENERATOR} RPM)
      set(CPACK_RPM_PACKAGE_LICENSE "LGPL 2.1")
      set(CPACK_RPM_PACKAGE_GROUP "Applications/Engineering")
      #set(CPACK_RPM_PACKAGE_NAME "brlcad_${BRLCAD_VERSION_MAJOR}_${BRLCAD_VERSION_MINOR}_${BRLCAD_VERSION_PATCH}")
      #if(EXISTS /etc/redhat-release)
      #	file(READ /etc/redhat-release REDHAT_RELEASE)
      #	string(REGEX MATCH "[0-9]+" REDHAT_VERSION ${REDHAT_RELEASE})
      #	string(REGEX MATCH "Enterprise Linux" LINUX_DIST_TYPE ${REDHAT_RELEASE})
      #	if(LINUX_DIST_TYPE)
      #		set(LINUX_DIST_TYPE "el")
      #	else(LINUX_DIST_TYPE)
      #		set(LINUX_DIST_TYPE "rh")
      #	endif(LINUX_DIST_TYPE)
      #	set(CPACK_RPM_PACKAGE_RELEASE 1.${LINUX_DIST_TYPE}${REDHAT_VERSION})
      #else(EXISTS /etc/redhat-release)
      #	#set(CPACK_RPM_PACKAGE_RELEASE 2)
      #endif(EXISTS /etc/redhat-release)
    endif(RPMBUILD_EXEC)
    set(CPACK_RPM_PACKAGE_ARCHITECTURE "${CMAKE_SYSTEM_PROCESSOR}")
    if(NOT CPACK_RPM_PACKAGE_RELEASE)
      set(CPACK_RPM_PACKAGE_RELEASE 1)
    endif(NOT CPACK_RPM_PACKAGE_RELEASE)
    if(${CMAKE_WORD_SIZE} MATCHES "32BIT" AND ${CMAKE_SYSTEM_PROCESSOR} STREQUAL "x86_64")
      set(CPACK_PACKAGE_FILE_NAME "BRL-CAD_${BRLCAD_VERSION}_x86_${CMAKE_SYSTEM_NAME}_${CPACK_RPM_PACKAGE_RELEASE}")
    else(${CMAKE_WORD_SIZE} MATCHES "32BIT" AND ${CMAKE_SYSTEM_PROCESSOR} STREQUAL "x86_64")
      set(CPACK_PACKAGE_FILE_NAME "BRL-CAD_${BRLCAD_VERSION}_${CMAKE_SYSTEM_PROCESSOR}_${CMAKE_SYSTEM_NAME}_${CPACK_RPM_PACKAGE_RELEASE}")
    endif(${CMAKE_WORD_SIZE} MATCHES "32BIT" AND ${CMAKE_SYSTEM_PROCESSOR} STREQUAL "x86_64")
  else(UNIX AND NOT APPLE)
    set(CPACK_PACKAGE_FILE_NAME "BRL-CAD_${BRLCAD_VERSION}_${CMAKE_SYSTEM_PROCESSOR}")
  endif(UNIX AND NOT APPLE)

  if(WIN32)
    set(CPACK_GENERATOR NSIS)
    set(CPACK_NSIS_PACKAGE_NAME "BRL-CAD")
    set(CPACK_SOURCE_DIR ${CMAKE_SOURCE_DIR})
    set(CPACK_DATA_DIR "${DATA_DIR}")
    # There is a bug in NSI that does not handle full unix paths properly. Make
    # sure there is at least one set of four (4) backslashes.
    set(CPACK_NSIS_MUI_ICON "${CMAKE_SOURCE_DIR}/misc/nsis\\\\brlcad.ico")
    set(CPACK_NSIS_MUI_UNIICON "${CMAKE_SOURCE_DIR}/misc/nsis\\\\uninstall.ico")
    set(CPACK_NSIS_DISPLAY_NAME "BRL-CAD")
    set(CPACK_NSIS_MODIFY_PATH ON)
  endif(WIN32)
  if(CMAKE_CL_64)
    set(CPACK_PACKAGE_FILE_NAME "BRL-CAD_${BRLCAD_VERSION}_x64")
  endif(CMAKE_CL_64)

  set(CPACK_SOURCE_GENERATOR TGZ TBZ2 ZIP)
  set(CPACK_SOURCE_PACKAGE_FILE_NAME "brlcad-${BRLCAD_VERSION}")
  set(CPACK_SOURCE_IGNORE_FILES "\\\\.svn/")

  configure_file("${BRLCAD_CMAKE_DIR}/BRLCAD_CPackOptions.cmake.in" "${CMAKE_BINARY_DIR}/BRLCAD_CPackOptions.cmake" @ONLY)
  set(CPACK_PROJECT_CONFIG_FILE "${CMAKE_BINARY_DIR}/BRLCAD_CPackOptions.cmake")

  include(CPack)

  # Some files to ignore for distcheck.  For this case
  # only, we add CMakeLists.txt (others are handled
  # by add_subdirectory wrapper
  set(toplevel_ignore_files
    BUGS
    ChangeLog
    TODO
    configure
    CMakeLists.txt
    )
  CMAKEFILES(${toplevel_ignore_files})

  # Handle some toplevel distclean listings
  DISTCLEAN(${CMAKE_BINARY_DIR}/cmakefiles.cmake)
  DISTCLEAN(${CMAKE_BINARY_DIR}/cmakedirs.cmake)
  DISTCLEAN(${CMAKE_BINARY_DIR}/cmake_install.cmake)
  DISTCLEAN(${CMAKE_BINARY_DIR}/install_manifest.txt)
  DISTCLEAN(${CMAKE_BINARY_DIR}/OPTIONS)
  DISTCLEAN(${CMAKE_BINARY_DIR}/CMakeFiles)
  DISTCLEAN(${CMAKE_BINARY_DIR}/CMakeTmp)
  DISTCLEAN(${CMAKE_BINARY_DIR}/configure.new)
  DISTCLEAN(${CMAKE_BINARY_DIR}/INSTALL.new)
  DISTCLEAN(${CMAKE_BINARY_DIR}/include/brlcad_config.h.in)
  foreach(clearpattern ${DISTCLEAN_OUTFILES})
    DISTCLEAN(${CMAKE_BINARY_DIR}/${clearpattern})
  endforeach(clearpattern ${DISTCLEAN_OUTFILES})
  if("${CMAKE_GENERATOR}" MATCHES "Ninja")
    DISTCLEAN(${CMAKE_BINARY_DIR}/.ninja_log)
  endif("${CMAKE_GENERATOR}" MATCHES "Ninja")

  # ----------------------------------------------------------------------------
  # Define a distcheck target.  This performs a variety of tests to determine
  # whether BRL-CAD is in a distribution ready state.  Default to the standard
  # set of tests - Debug and Release build configurations
  include(${BRLCAD_CMAKE_DIR}/Distcheck.cmake)

  # Define some custom distcheck targets for distcheck-full (not run by default)
  #
  # CREATE_DISTCHECK(TARGET_SUFFIX CMAKE_OPTS source_dir build_dir install_dir [custom_template])
  CREATE_DISTCHECK(default_build_type "-DBRLCAD_BUNDLED_LIBS=AUTO" "${CPACK_SOURCE_PACKAGE_FILE_NAME}" "build" "install")
  CREATE_DISTCHECK(no_tk "-DCMAKE_BUILD_TYPE=Debug -DBRLCAD_BUNDLED_LIBS=BUNDLED -DBRLCAD_ENABLE_TK=OFF" "${CPACK_SOURCE_PACKAGE_FILE_NAME}" "build" "install")
  CREATE_DISTCHECK(autodetect_debug "-DCMAKE_BUILD_TYPE=Debug -DBRLCAD_BUNDLED_LIBS=AUTO" "${CPACK_SOURCE_PACKAGE_FILE_NAME}" "build" "install")
  CREATE_DISTCHECK(autodetect_release "-DCMAKE_BUILD_TYPE=Release -DBRLCAD_BUNDLED_LIBS=AUTO" "${CPACK_SOURCE_PACKAGE_FILE_NAME}" "build" "install")
  CREATE_DISTCHECK(odd_pathnames "-DCMAKE_BUILD_TYPE=Debug -DBRLCAD_BUNDLED_LIBS=BUNDLED" "1 Odd_ source dir ++" "1 Odd_ build dir ++" "1 Odd_ install dir ++")
  CREATE_DISTCHECK(in_src_dir "-DCMAKE_BUILD_TYPE=Debug -DBRLCAD_BUNDLED_LIBS=BUNDLED" "${CPACK_SOURCE_PACKAGE_FILE_NAME}" "${CPACK_SOURCE_PACKAGE_FILE_NAME}" "install" distcheck_in_src_dir.cmake.in)

  # Now that we're set up and have added the extra targets we want for distcheck-full, define the build targets
  DEFINE_DISTCHECK_TARGET(STD)
endif(NOT BRLCAD_IS_SUBBUILD)

# ----------------------------------------------------------------------------
# Mark various miscellaneous things as advanced that we don't want in our
# default view
mark_as_advanced(CMAKE_BACKWARDS_COMPATIBILITY)
mark_as_advanced(EXECUTABLE_OUTPUT_PATH)
mark_as_advanced(LIBRARY_OUTPUT_PATH)
mark_as_advanced(CMAKE_CXX_COMPILER)
mark_as_advanced(CMAKE_C_COMPILER)

# ----------------------------------------------------------------------------
# If options have been defined that we are going to document, by now they've
# been documented.  Make an updated copy of the "INSTALL" file and see whether
# anything has changed.
#
# Although the general principle of this build is to leave the src dir
# pristine after configuration and compilation, the INSTALL and configure files
# represent one of two cases where the default behavior is to alter the files
# if changes have occurred.  (The other is cached generated outputs from tools
# such as re2c and lemon.) For the purposes of this project, a given
# option's documentation is defined in the CMakeLists.txt source file with
# the option definition logic - the text in INSTALL is simply an output from
# that, and is never the correct place for manual changes.
#
# As with generated outputs, this auto-updating behavior can be overridden
# by setting the CMake variable LOCKED_SOURCE_DIR to ON - in that case, a
# warning about out-of-sync files is printed but no automatic updating takes
# place in the source tree.

file(READ ${BRLCAD_SOURCE_DIR}/INSTALL SRC_INSTALL_STR)
string(REGEX REPLACE "${CONFIG_OPT_STRING}.*" "" INSTALL_PREFIX "${SRC_INSTALL_STR}")
file(WRITE ${BRLCAD_BINARY_DIR}/INSTALL.new "${INSTALL_PREFIX}")
file(READ ${BRLCAD_BINARY_DIR}/OPTIONS INSTALL_OPTS)
file(APPEND ${BRLCAD_BINARY_DIR}/INSTALL.new "${INSTALL_OPTS}")
file(APPEND ${BRLCAD_BINARY_DIR}/INSTALL.new "\n\n*** Note - Do not add or edit configuration option descriptions and alias
   lists in this file - those entries are auto-generated from information in
   the toplevel CMakeLists.txt file and src/other/CMakeLists.txt - any changes
   should be made in those files.  The CMake configuration process will
   automatically re-generate INSTALL with the new descriptions and alias
   information.\n")
execute_process(COMMAND ${CMAKE_COMMAND} -E compare_files
  ${BRLCAD_SOURCE_DIR}/INSTALL ${BRLCAD_BINARY_DIR}/INSTALL.new
  RESULT_VARIABLE IS_DIFFERENT OUTPUT_VARIABLE DIFF_OUTPUT ERROR_VARIABLE
  DIFF_ERROR)
if(IS_DIFFERENT)
  if(LOCKED_SOURCE_DIR)
    message(WARNING "\n${BRLCAD_SOURCE_DIR}/INSTALL is out of date.  An updated version has been generated at ${BRLCAD_BINARY_DIR}/INSTALL.new\nTo clear this warning, replace ${BRLCAD_SOURCE_DIR}/INSTALL with ${BRLCAD_BINARY_DIR}/INSTALL.new\n")
  else(LOCKED_SOURCE_DIR)
    set_source_files_properties(${BRLCAD_BINARY_DIR}/INSTALL.new PROPERTIES GENERATED TRUE)
    configure_file(${BRLCAD_BINARY_DIR}/INSTALL.new ${BRLCAD_SOURCE_DIR}/INSTALL COPYONLY)
  endif(LOCKED_SOURCE_DIR)
endif(IS_DIFFERENT)

# Do the same thing for the configure shell script - finish it and check
# for differences.
file(READ ${BRLCAD_CMAKE_DIR}/configure_suffix.sh CONFIG_SUFFIX)
file(APPEND ${CMAKE_BINARY_DIR}/configure.new "${CONFIG_SUFFIX}")
# Compare
execute_process(COMMAND ${CMAKE_COMMAND} -E compare_files
  ${BRLCAD_SOURCE_DIR}/configure ${BRLCAD_BINARY_DIR}/configure.new
  RESULT_VARIABLE IS_CONFIG_SH_DIFFERENT OUTPUT_VARIABLE DIFF_OUTPUT ERROR_VARIABLE
  DIFF_ERROR)
if(IS_CONFIG_SH_DIFFERENT)
  if(LOCKED_SOURCE_DIR)
    message(WARNING "\n${BRLCAD_SOURCE_DIR}/configure is out of date. An updated version has been generated at ${BRLCAD_BINARY_DIR}/configure.new\nTo clear this warning, replace ${BRLCAD_SOURCE_DIR}/configure with ${BRLCAD_BINARY_DIR}/configure.new\n")
  else(LOCKED_SOURCE_DIR)
    set_source_files_properties(${BRLCAD_BINARY_DIR}/configure.new PROPERTIES GENERATED TRUE)
    configure_file(${BRLCAD_BINARY_DIR}/configure.new ${BRLCAD_SOURCE_DIR}/configure COPYONLY)
  endif(LOCKED_SOURCE_DIR)
endif(IS_CONFIG_SH_DIFFERENT)


# Because the build-time-delta needs a configure-file but comes at the
# end of the CMake configure, the preparation of the final distclean
# list must account for it.  Also, the distclean script itself must
# be added to the list, as it is generated by CMake
DISTCLEAN(${CMAKE_BINARY_DIR}/CMakeTmp/timedelta_end.c)
get_property(CMAKE_DISTCLEAN_TARGET_LIST GLOBAL PROPERTY CMAKE_DISTCLEAN_TARGET_LIST)
list(REMOVE_DUPLICATES CMAKE_DISTCLEAN_TARGET_LIST)
configure_file(${BRLCAD_CMAKE_DIR}/distclean.cmake.in	${BRLCAD_BINARY_DIR}/distclean.cmake @ONLY)
if("${CMAKE_GENERATOR}" MATCHES "Make")
  add_custom_target(distclean
    COMMAND ${CMAKE_COMMAND} -E echo "Running make clean..."
    COMMAND ${CMAKE_COMMAND} -E chdir ${BRLCAD_BINARY_DIR} $(MAKE) clean
    COMMAND ${CMAKE_COMMAND} -E echo "Running make clean... done."
    COMMAND ${CMAKE_COMMAND} -P ${BRLCAD_BINARY_DIR}/distclean.cmake
    )
elseif("${CMAKE_GENERATOR}" MATCHES "Ninja")
  add_custom_target(distclean
    COMMAND ${CMAKE_COMMAND} -E echo "Running make clean..."
    COMMAND ${CMAKE_COMMAND} -E chdir ${BRLCAD_BINARY_DIR} ninja -t clean
    COMMAND ${CMAKE_COMMAND} -E echo "Running make clean... done."
    COMMAND ${CMAKE_COMMAND} -P ${BRLCAD_BINARY_DIR}/distclean.cmake
    )
else("${CMAKE_GENERATOR}" MATCHES "Make")
  add_custom_target(distclean
    COMMAND ${CMAKE_COMMAND} -E echo "Not implemented for generator ${CMAKE_GENERATOR}"
    )
endif("${CMAKE_GENERATOR}" MATCHES "Make")
if(TARGET distclean)
  set_target_properties(distclean PROPERTIES FOLDER "Compilation Utilities")
endif(TARGET distclean)

# Not sure what this is - created automatically by CMake in MSVC?
SetTargetFolder(core "CMakePredefinedTargets")

# Have touched every file and directory that we are going to touch with the
# build system - time to write out our lists for future processing.
get_property(CMAKE_IGNORE_FILES GLOBAL PROPERTY CMAKE_IGNORE_FILES)
get_property(CMAKE_IGNORE_DIRS GLOBAL PROPERTY CMAKE_IGNORE_DIRS)
string(REPLACE ";" "\n" CMAKE_IGNORE_FILES "${CMAKE_IGNORE_FILES}")
string(REPLACE ";" "\n" CMAKE_IGNORE_DIRS "${CMAKE_IGNORE_DIRS}")
file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/cmakefiles.cmake "${CMAKE_IGNORE_FILES}")
file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/cmakedirs.cmake "${CMAKE_IGNORE_DIRS}")

#Done with all really time-consuming steps - do the configure time delta
if(NOT BRLCAD_IS_SUBBUILD)
  set(DELTA_END "${CMAKE_BINARY_DIR}/CMakeTmp/DELTA_END")
  configure_file(${BRLCAD_CMAKE_DIR}/test_srcs/timedelta_end.c.in ${CMAKE_BINARY_DIR}/CMakeTmp/timedelta_end.c)
  TRY_RUN(TIME_RESULT TIME_COMPILED
    ${CMAKE_BINARY_DIR}/CMakeTmp
    ${CMAKE_BINARY_DIR}/CMakeTmp/timedelta_end.c
    OUTPUT_VARIABLE COMPILEMESSAGES)
  file(READ ${DELTA_END} CONFIG_TIME_MSG)
  string(STRIP "${CONFIG_TIME_MSG}" CONFIG_TIME_MSG)
  set(CONFIG_TIME_MSG_LABEL "Elapsed configuration time")
  string(LENGTH "${CONFIG_TIME_MSG_LABEL}" CURRENTLENGTH)
  while(${SETTINGLABELLENGTH} GREATER ${CURRENTLENGTH})
    set(CONFIG_TIME_MSG_LABEL "${CONFIG_TIME_MSG_LABEL}.")
    string(LENGTH "${CONFIG_TIME_MSG_LABEL}" CURRENTLENGTH)
  endwhile(${SETTINGLABELLENGTH} GREATER ${CURRENTLENGTH})
  message("${CONFIG_TIME_MSG_LABEL}..: ${CONFIG_TIME_MSG}")
endif(NOT BRLCAD_IS_SUBBUILD)

# Local Variables:
# tab-width: 8
# mode: cmake
# indent-tabs-mode: t
# End:
# ex: shiftwidth=2 tabstop=8
blob
data 25875
The Installation Guide to BRL-CAD
=================================

Please read this document if you are interested in installing BRL-CAD.

This document covers the basics of installing BRL-CAD from either a
source or binary distribution.  Please see the 'Reporting Problems'
section if you run into any trouble installing BRL-CAD.

Some platforms have additional platform-specific documentation
provided in the doc/ directory of the source distribution that should
be consulted if that is the platform you are installing on.  This
presently includes the following:

  doc/README.AIX        -- IBM's Advanced Interactive eXecutive OS
  doc/README.BSD        -- FreeBSD, NetBSD, OpenBSD, etc.
  doc/README.IRIX	-- SGI IRIX and IRIX64
  doc/README.Linux	-- Various Linux distributions
  doc/README.MacOSX	-- Apple Mac OS X
  doc/README.Solaris    -- Oracle Solaris, OpenIndiana (Illumos), etc.
  doc/README.Windows    -- Microsoft Windows
  doc/README.VAX        -- Virtual Address eXtension architecture from DEC.
                           One of the original BRL-CAD platforms. These
                           days, re-created using the simh simulator.


TABLE OF CONTENTS
-----------------
  Introduction
  Table of Contents
  Quick Installation
  Installing from Binary
  Installing from Source
  Testing Functionality
  Post-Installation
  Reporting Problems
  Configuration Options


QUICK INSTALLATION
------------------

Note that the downloaded files have two check sums calculated
automatically by the Source Forge file release system.  The values are
used to verify the integrity of the files as distributed.  Get those
data by clicking on the 'i' button at the end of each file's name.
You should ensure those data are retained and kept with the files if
you re-distribute them.


If you downloaded a binary distribution of BRL-CAD for your system,
please read the INSTALLING FROM BINARY section of this document down
below.  The rest of this quick installation section is only relevant
to source code distributions of BRL-CAD.

For the impatient or simplistic, the following steps should compile,
test, and install an optimized BRL-CAD quickly into the /usr/brlcad/rel-X.Y.Z
directory if CMake is installed on your system:

  gunzip brlcad-X.Y.Z.tar.gz
  tar -xvf brlcad-X.Y.Z.tar
  mkdir brlcad-build
  cd brlcad-build
  cmake ../brlcad-X.Y.Z -DBRLCAD_BUNDLED_LIBS=ON -DCMAKE_BUILD_TYPE=Release
  make
  make benchmark
  make regress
  make install   # as root, e.g. sudo make install

If any of the listed steps fail, then something unexpected happened.
See the REPORTING PROBLEMS section of this document to report the
problem or the INSTALLING FROM SOURCE section for more comprehensive
instructions.

Once installed, add /usr/brlcad/rel-X.Y.Z/bin to your path, and you should be
able to run any of the 400+ applications that constitute BRL-CAD.  For
example, to run the MGED solid modeler:

PATH=/usr/brlcad/rel-X.Y.Z/bin:$PATH ; export PATH
mged

If you use tcsh or another C-shell based command shell, use this
instead:

set path=( /usr/brlcad/rel-X.Y.Z/bin $path ) ; rehash
mged


INSTALLING FROM BINARY
----------------------

There are a variety of different kinds of binary distributions of
BRL-CAD.  Some of the binary distributions are sufficiently generic and
are simply a binary compressed tarball distribution.  Others are
specific to a particular platform such as Debian, Mac OS X, FreeBSD,
and Windows etc.


Generic Binary Distributions:

For the unspecialized binary distributions that are basically
compressed tarballs of the installation root, they should contain the
entire hierarchy of the distribution.  To put that hierarchy in its
"installed" location, you just create the directory and move the
expanded tarball contents:

gunzip BRL-CAD_7.2.4_Linux_ia64.tar.gz
tar -xvf BRL-CAD_7.2.4_Linux_ia64.tar
sudo mkdir /usr/brlcad/rel-7.2.4
sudo mv BRL-CAD_7.2.4_Linux_ia64/* /usr/brlcad/rel-7.2.4/

Of course, there are other compression options possible including zip
and bzip2.  By default, BRL-CAD expects to be installed into
/usr/brlcad/rel-7.2.4. On some platforms the binary may be relocatable,
but this is not guaranteed. It's recommended that you start from a source
distribution if you would like to install into an alternate installation
location.  That said, if you do desire to install and/or run BRL-CAD from
a different location, give it a try...on some platforms it will work.

Something to be aware of, even if a binary distribution IS relocatable:
it will use its local copies of things like libraries only so long as the
"final" installed target directory that the build was compiled for
does not contain a BRL-CAD installation.  Due to the way path logic
is set, an installed copy of a library in the correct location will
always be loaded first, regardless of the presence of a "local" copy.


Mac OS X Disk Mounting Image:

Mount the .dmg and run the Installer .pkg contained therein.  This
will install into /usr/brlcad/rel-X.Y.Z and will only require confirming that
your environment is set up properly (i.e. add /usr/brlcad/rel-X.Y.Z/bin to your
path) as described in the Quick Installation section.


INSTALLING FROM SOURCE
----------------------

There are a couple of ways to obtain the BRL-CAD sources, usually via
one of the following starting points:

  1) from a SVN checkout/export, or
  2) from a source distribution tarball

Using the latest SVN sources is recommended where possible since it
will have the latest changes.  See the corresponding section below for
details on how to install from either starting point.


Starting From a SVN Checkout/Export:

With CMake, there is no longer any difference between building from
a subversion checkout and a tarball--follow the Source Distribution
instructions below.

Starting From a Source Distribution:

There are many different ways to build BRL-CAD and depending on what
you need/want will determine which configuration options you should
use.  See the CONFIGURATION OPTIONS section below for details on how
to go about selecting which options are appropriate for you.

By default, the default configuration will prepare the build system
to perform a Debug build and install into the /usr/brlcad/dev-X.Y.Z
directory.   The CMAKE_INSTALL_PREFIX option may be used to change
that directory, or a Release build type may be specified to install to
/usr/brlcad/rel-X.Y.Z - more on this below.  The
tradition of non-system installation paths goes back a couple of decades
and is a convenient means to isolate the BRL-CAD solid modeling
system from your system, resolves conflicts, facilitates uninstalls,
and simplifies upgrades.  The default configuration is performed by
running `cmake'.  It is not required to do the build in a directory
different from your source directory, but it is much cleaner and
*highly* recommended - this guide will illustrate the build process
with the assumption that the BRL-CAD source code is in the directory
brlcad-7.2.4 and the directory intended to hold the build output is
brlcad-build, located in the same parent directory as brlcad-7.2.4:

  .
  ./brlcad-7.2.4
  ./brlcad-build

To start the build process, cd into brlcad-build and run CMake,
pointing it to the source directory:

  cd brlcad-build
  cmake ../brlcad-7.2.4

As mentioned earlier, CMake uses two "build types", controlled by
the CMAKE_BUILD_TYPE variable, that are useful for specific purposes:

* Debug (-DCMAKE_BUILD_TYPE=Debug) - Debug is the configuration that most
  developers will want to use when working on BRL-CAD.  It will add
  debug flags to the compile, and sets the default install directory to
  be /usr/brlcad/dev-X.Y.Z - in order to run the resulting installed
  binaries, the developer should ensure that the dev-X.Y.Z  path is
  first in his or her PATH environment variable.

* Release (-DCMAKE_BUILD_TYPE=Release) - A release build is intended for
  final consumption by end users and as such has optimizations enabled.
  It also sets the install path to /usr/brlcad/rel-X.Y.Z - best practice
  for release installation is to set up symbolic links in /usr/brlcad to
  point to the most current BRL-CAD release, while allowing older versions
  to remain installed on the system in case they are needed.

In both of these cases any individual variable may be overridden - for
example, setting -DCMAKE_INSTALL_PREFIX=/usr/brlcad in a Debug build will
override the ../brlcad-install default.  Build types are a convenient way
to bundle sets of settings, but they do not prevent overrides if a more
custom setup is needed.

By default, all components and functionality will be built.
Note that BRL-CAD does require and include several 3rd party
components.  If your system does not include a sufficient version of
those required 3rd party components, they will be automatically
configured for compilation.

If the autodetection mechanisms fail to produce a working configuration,
the next simplest approach is typically to enable ALL the third party
components - this is typically a well tested configuration, but will
increase both the build time and final install size of BRL-CAD on
the system.  To set this variable on the command line, use -D to
define BRLCAD_BUNDLED_LIBS for CMake:

  -DBRLCAD_BUNDLED_LIBS=Bundled

If the graphical interface (cmake-gui) is in use, it will list this
and other common options by default, allowing the user change them
graphically.  This is often quicker and more convenient than
defining options on the command line, but both will work.

You can also force on or off any individual 3rd party library by
setting the BRL-CAD variable for that feature to either on or off:

  -DBRLCAD_<LIBRARY>=ON

Other variables control BRL-CAD features.  For example, to NOT
enable functionality using OpenGL, set

  -DBRLCAD_ENABLE_OPENGL=OFF

To obtain an optimized build (for example, for BRL-CAD Benchmark
performance evaluation), enable BRLCAD_FLAGS_OPTIMIZATION:

  -DBRLCAD_FLAGS_OPTIMIZATION=ON

See the CONFIGURATION OPTIONS below for more details on all of the
possible settings.

You can specify options or preferences you want to always use by
default.  For example, to always enable all local libs the following
line can be added to your own configuration file:

  set(BRLCAD_BUNDLED_LIBS "Bundled" CACHE STRING "Enable all local libs")

You can define your own configuration file in one of three ways.  The
build system will search for the file in this order:

  ${BRLCAD_SOURCE_DIR}/../BRL-CAD_CONFIG.GLOBAL

  ${BRLCAD_SOURCE_DIR}/BRL-CAD_CONFIG.GLOBAL

  the file defined in the environment variable "BRLCAD_USER_GLOBAL_CONFIG_FILE"

The build system will use the first file defined that exists.

Once configured, you should be able to successfully build BRL-CAD via
make:

  make

(On multicore systems, adding the -j flag (e.g. -j6) is recommended)

Installing the Compilation:

After the build successfully completes and assuming the benchmark also
produces correct results, installation may begin.  Like any package,
you must have sufficient filesystem permissions to install.  To
install into a system location, you can generally either become a
super user via the su command and run

  make install

or on operating systems set up to use sudo:

  sudo make install


TESTING FUNCTIONALITY
---------------------

To test BRL-CAD before installation, you can run the BRL-CAD benchmark.
The benchmark will report if the results are correct, testing a
majority of the core functionality of BRL-CAD in addition to testing
your system's performance:

  make benchmark

Note that the benchmark target will build ONLY the pieces required for
the benchmark tests, unless a general make has already been performed.
For more testing, you can run the regression test suite:

  make regress


POST-INSTALLATION
-----------------

Permissions:

Something to be aware of with CMake installations is that umask settings
are ignored by current versions of CMake.  It is a common situation in
Unix environments to want "group" members to have read/write access -
to achieve this, after installation the following find command can be
run (of course, substituting the actual BRL-CAD version for X.Y.Z):

find /usr/brlcad/rel-X.Y.Z -type d -exec chmod ug+rwx {} \; -exec chmod o+rx {} \; -o -type f -exec chmod ug+rw {} \; -exec chmod o+r {} \;

The above 'find' line will set up permissions across a /usr/brlcad
rooted installation such that 'user' and 'group' will have read-write
access and 'other' will have read access consistently across all
files.


System PATH:

Normally, BRL-CAD's install directories are not in system PATH lists and
consequently BRL-CAD's executables will not be invokable without specifying
their full path.  This is normally handled in Unix environments by adding
the desired BRL-CAD installation's binary directory to the user's local path:

In the bash shell: export PATH=/usr/brlcad/rel-X.Y.Z:$PATH
In the csh shell:  setenv PATH /usr/brlcad/rel-X.Y.Z:$PATH

REPORTING PROBLEMS
------------------

Please report any bugs encountered to the project bug tracker at
http://sourceforge.net/tracker/?group_id=105292&atid=640802

Similarly, please post any request for feature enhancements or support
to http://sourceforge.net/tracker/?group_id=105292&atid=640805 and
http://sourceforge.net/tracker/?group_id=105292&atid=640803
respectively.


CONFIGURATION OPTIONS
---------------------

--- BRLCAD_BUNDLED_LIBS ---

Enables compilation of all 3rd party sources that are provided within a BRL-CAD
source distribution.  If used this option sets all other 3rd party library
build flags to ON by default.  However, that setting can be overridden by
manually setting individual variables. Default is "AUTO" - 3rd party sources
are compiled only if they are not detected as being available and functioning
as expected.

Aliases:  ENABLE_ALL


--- BRLCAD_ENABLE_OPENGL ---

Enable support for OpenGL based Display Managers in BRL-CAD.
Default depends on whether OpenGL is successfully detected -
if it is, default is to enable.

Aliases:  ENABLE_OPENGL


--- BRLCAD_ENABLE_RUNTIME_DEBUG ---

Enables support for application and library debugging facilities.
Disabling the run-time debugging facilities can provide a significant
(10%-30%) performance boost at the expense of extensive error
checking (that in turn help prevent corruption of your data).
Default is "ON", and should only be disabled for read-only render
work where performance is critical.

Aliases:  ENABLE_RUNTIME_DEBUG, ENABLE_RUN_TIME_DEBUG, ENABLE_RUNTIME_DEBUGGING
          ENABLE_RUN_TIME_DEBUGGING


--- BRLCAD_FLAGS_DEBUG ---

Add compiler flags to aid in program debugging.  Defaults to ON.

Aliases:  ENABLE_DEBUG, ENABLE_FLAGS_DEBUG, ENABLE_DEBUG_FLAGS


--- BRLCAD_ENABLE_COMPILER_WARNINGS ---

Use extra compiler warning flags when compiling C/C++ code.  Defaults to ON.

Aliases:  ENABLE_WARNINGS, ENABLE_COMPILER_WARNINGS


--- BRLCAD_ENABLE_STRICT ---

Causes all compilation warnings for C code to be treated as errors.  This is now
the default for BRL-CAD source code, and developers should address issues
discovered by these flags whenever possible rather than disabling strict
mode.

Aliases:  ENABLE_STRICT, ENABLE_STRICT_COMPILE, ENABLE_STRICT_COMPILE_FLAGS


--- ENABLE_ALL_CXX_COMPILE ---

Build all C and C++ files with a C++ compiler.  Defaults to OFF.

EXPERIMENTAL!

Aliases:  ENABLE_ALL_CXX


--- ENABLE_POSIX_COMPLIANCE ---

Build with strict POSIX compliance checking.  Defaults to OFF.

Causes compiler options to be set for strict compliance with the
minimum C and C++ standards acceptable according to current BRL-CAD
policy.  The current minimum C standard is ??.
There is no currently defined minimum C++ standard.

Aliases:  ENABLE_POSIX


--- ENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE ---

Build with strict ISO C compliance checking.  Defaults to OFF.

Causes C compiler options to be set for strict compliance with the
appropriate ISO C standard.

Aliases:  STRICT_ISO_C


--- BRLCAD_EXTRADOCS ---

The core option that enables and disables building of BRL-CAD's
DocBook based documentation (includes manuals and man pages for
commands, among other things).  Defaults to ON, but only HTML and MAN
formats are enabled by default - PDF must be enabled separately by use
of this option or one of its aliases.  Note that you may set
environment variable APACHE_FOP to point to your locally installed fop
executable file (which on Linux is usually a shell script with 0755
permissions).

Aliases:  ENABLE_DOCS, ENABLE_EXTRA_DOCS, ENABLE_DOCBOOK


--- BRLCAD_ASTYLE ---

Option for enabling and disabling compilation of the Artistic Style
(astyle) utility provided with BRL-CAD's source distribution.  Default is
AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_ASTYLE


--- BRLCAD_XSLTPROC ---

Option for enabling and disabling compilation of the xsltproc XML
transformation utility provided with BRL-CAD's source distribution.
Used for DocBook documentation processing.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
Depends on BRLCAD_EXTRADOCS.

Aliases:  ENABLE_XSLTPROC


--- BRLCAD_XMLLINT ---

Option for enabling and disabling compilation of the xmllint XML
validation utility provided with BRL-CAD's source distribution.  Used
for DocBook documentation validation.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_XMLLINT


--- BRLCAD_REGEX ---

Option for enabling and disabling compilation of the Regular
Expression Library provided with BRL-CAD's source distribution.
Default is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option
and testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.

Aliases:  ENABLE_REGEX


--- BRLCAD_ZLIB ---

Option for enabling and disabling compilation of the zlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_ZLIB, ENABLE_LIBZ


--- BRLCAD_LEMON ---

Option for enabling and disabling compilation of the lemon parser
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_LEMON


--- BRLCAD_RE2C ---

Option for enabling and disabling compilation of the re2c scanner
utility provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_RE2C


--- BRLCAD_PERPLEX ---

Option for enabling and disabling compilation of the perplex scanner
generator provided with BRL-CAD's source distribution.  Default is
AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.  perplex requires a working re2c.

Aliases:  ENABLE_PERPLEX


--- BRLCAD_TERMLIB ---

Option for enabling and disabling compilation of the termlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO. (Except when building with Visual Studio, where it is
disabled. Windows does not support the termlib API.)

Aliases:  ENABLE_TERMLIB


--- BRLCAD_PNG ---

Option for enabling and disabling compilation of the Portable Network
Graphics library provided with BRL-CAD's source distribution.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.

Aliases:  ENABLE_PNG


--- BRLCAD_UTAHRLE ---

Option for enabling and disabling compilation of the Utah Raster
Toolkit library provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_UTAHRLE


--- BRLCAD_TCL ---

Option for enabling and disabling compilation of the Tcl library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_TCL


--- BRLCAD_TK ---

Option for enabling and disabling compilation of the Tk library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the BRLCAD_TCL option and testing first for a system version if
BRLCAD_BUNDLED_LIBS is also AUTO. Option for enabling and disabling
compilation of the Tk graphics package for Tcl provided with BRL-CAD's
source distribution.  Default is AUTO, auto-enabling if the BRLCAD_TCL
option is set to BUNDLED and testing first for a system version if
BRLCAD_TCL is set to AUTO or SYSTEM.  If BRLCAD_TK is set to BUNDLED,
local copy is built even if a system version is present.  This option
also depends on BRLCAD_ENABLE_TK being ON.

Aliases:  ENABLE_TK


--- BRLCAD_ITCL ---

Option for enabling and disabling compilation of the IncrTcl package
for Tcl objects provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_ITCL is set to BUNDLED, local copy is built even if
a system version is present.

Aliases:  ENABLE_ITCL


--- BRLCAD_ITK ---

Option for enabling and disabling compilation of the IncrTcl itk
package for Tk objects provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_ITK is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_ITK


--- BRLCAD_IWIDGETS ---

Option for enabling and disabling compilation of the IWidgets Tk
widget package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_IWIDGETS is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_IWIDGETS


--- BRLCAD_TKHTML ---

Option for enabling and disabling compilation of the Tkhtml HTML
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKHTML is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_TKHTML


--- BRLCAD_TKPNG ---

Option for enabling and disabling compilation of the tkpng PNG image
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKPNG is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_TKPNG


--- BRLCAD_TKTABLE ---

Option for enabling and disabling compilation of the Tktable graphical
table widget package provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TKTABLE is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_TKTABLE


--- BRLCAD_OPENNURBS ---

Option for enabling and disabling compilation of the openNURBS library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_OPENNURBS


--- BRLCAD_SC ---

Option for enabling and disabling compilation of the NIST Step Class
Libraries provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_SCL, ENABLE_STEP, ENABLE_STEP_CLASS_LIBRARIES


--- BRLCAD_VDS ---

Option for enabling and disabling compilation of the libvds triangle
simplification library provided with BRL-CAD's source code.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.

Aliases:  ENABLE_VDS


--- BRLCAD_GDIAM ---

Option for enabling and disabling compilation of the libgdiam approximate
tight bounding box library provided with BRL-CAD's source code.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.

Aliases:  ENABLE_GDIAM



*** Note - Do not add or edit configuration option descriptions and alias
   lists in this file - those entries are auto-generated from information in
   the toplevel CMakeLists.txt file and src/other/CMakeLists.txt - any changes
   should be made in those files.  The CMake configuration process will
   automatically re-generate INSTALL with the new descriptions and alias
   information.
blob
data 12146
#!/bin/sh
#
# This is a simple script to translate autotools style
# configure options into CMake variables.  The resulting
# translation is then run as a CMake configure.

srcpath=$(dirname $0)
options="$srcpath"
while [ "$1" != "" ]
do
   case $1
   in
     --enable-all)                options="$options -DBRLCAD_BUNDLED_LIBS=ON";
                                  shift;;
     --disable-all)                options="$options -DBRLCAD_BUNDLED_LIBS=OFF";
                                  shift;;
     --enable-opengl)                options="$options -DBRLCAD_ENABLE_OPENGL=ON";
                                  shift;;
     --disable-opengl)                options="$options -DBRLCAD_ENABLE_OPENGL=OFF";
                                  shift;;
     --enable-runtime-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-runtime-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-run-time-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-run-time-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-runtime-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-runtime-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-run-time-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-run-time-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=ON";
                                  shift;;
     --disable-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=OFF";
                                  shift;;
     --enable-flags-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=ON";
                                  shift;;
     --disable-flags-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=OFF";
                                  shift;;
     --enable-debug-flags)                options="$options -DBRLCAD_FLAGS_DEBUG=ON";
                                  shift;;
     --disable-debug-flags)                options="$options -DBRLCAD_FLAGS_DEBUG=OFF";
                                  shift;;
     --enable-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=ON";
                                  shift;;
     --disable-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=OFF";
                                  shift;;
     --enable-compiler-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=ON";
                                  shift;;
     --disable-compiler-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=OFF";
                                  shift;;
     --enable-strict)                options="$options -DBRLCAD_ENABLE_STRICT=ON";
                                  shift;;
     --disable-strict)                options="$options -DBRLCAD_ENABLE_STRICT=OFF";
                                  shift;;
     --enable-strict-compile)                options="$options -DBRLCAD_ENABLE_STRICT=ON";
                                  shift;;
     --disable-strict-compile)                options="$options -DBRLCAD_ENABLE_STRICT=OFF";
                                  shift;;
     --enable-strict-compile-flags)                options="$options -DBRLCAD_ENABLE_STRICT=ON";
                                  shift;;
     --disable-strict-compile-flags)                options="$options -DBRLCAD_ENABLE_STRICT=OFF";
                                  shift;;
     --enable-all-cxx)                options="$options -DENABLE_ALL_CXX_COMPILE=ON";
                                  shift;;
     --disable-all-cxx)                options="$options -DENABLE_ALL_CXX_COMPILE=OFF";
                                  shift;;
     --enable-posix)                options="$options -DENABLE_POSIX_COMPLIANCE=ON";
                                  shift;;
     --disable-posix)                options="$options -DENABLE_POSIX_COMPLIANCE=OFF";
                                  shift;;
     --strict-iso-c)                options="$options -DENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE=ON";
                                  shift;;
     --strict-iso-c)                options="$options -DENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE=OFF";
                                  shift;;
     --enable-docs)                options="$options -DBRLCAD_EXTRADOCS=ON";
                                  shift;;
     --disable-docs)                options="$options -DBRLCAD_EXTRADOCS=OFF";
                                  shift;;
     --enable-extra-docs)                options="$options -DBRLCAD_EXTRADOCS=ON";
                                  shift;;
     --disable-extra-docs)                options="$options -DBRLCAD_EXTRADOCS=OFF";
                                  shift;;
     --enable-docbook)                options="$options -DBRLCAD_EXTRADOCS=ON";
                                  shift;;
     --disable-docbook)                options="$options -DBRLCAD_EXTRADOCS=OFF";
                                  shift;;
     --enable-astyle)                options="$options -DBRLCAD_ASTYLE=BUNDLED";
                                  shift;;
     --disable-astyle)                options="$options -DBRLCAD_ASTYLE=SYSTEM";
                                  shift;;
     --enable-xsltproc)                options="$options -DBRLCAD_XSLTPROC=BUNDLED";
                                  shift;;
     --disable-xsltproc)                options="$options -DBRLCAD_XSLTPROC=SYSTEM";
                                  shift;;
     --enable-xmllint)                options="$options -DBRLCAD_XMLLINT=BUNDLED";
                                  shift;;
     --disable-xmllint)                options="$options -DBRLCAD_XMLLINT=SYSTEM";
                                  shift;;
     --enable-regex)                options="$options -DBRLCAD_REGEX=BUNDLED";
                                  shift;;
     --disable-regex)                options="$options -DBRLCAD_REGEX=SYSTEM";
                                  shift;;
     --enable-zlib)                options="$options -DBRLCAD_ZLIB=BUNDLED";
                                  shift;;
     --disable-zlib)                options="$options -DBRLCAD_ZLIB=SYSTEM";
                                  shift;;
     --enable-libz)                options="$options -DBRLCAD_ZLIB=BUNDLED";
                                  shift;;
     --disable-libz)                options="$options -DBRLCAD_ZLIB=SYSTEM";
                                  shift;;
     --enable-lemon)                options="$options -DBRLCAD_LEMON=BUNDLED";
                                  shift;;
     --disable-lemon)                options="$options -DBRLCAD_LEMON=SYSTEM";
                                  shift;;
     --enable-re2c)                options="$options -DBRLCAD_RE2C=BUNDLED";
                                  shift;;
     --disable-re2c)                options="$options -DBRLCAD_RE2C=SYSTEM";
                                  shift;;
     --enable-perplex)                options="$options -DBRLCAD_PERPLEX=BUNDLED";
                                  shift;;
     --disable-perplex)                options="$options -DBRLCAD_PERPLEX=SYSTEM";
                                  shift;;
     --enable-termlib)                options="$options -DBRLCAD_TERMLIB=BUNDLED";
                                  shift;;
     --disable-termlib)                options="$options -DBRLCAD_TERMLIB=SYSTEM";
                                  shift;;
     --enable-png)                options="$options -DBRLCAD_PNG=BUNDLED";
                                  shift;;
     --disable-png)                options="$options -DBRLCAD_PNG=SYSTEM";
                                  shift;;
     --enable-utahrle)                options="$options -DBRLCAD_UTAHRLE=BUNDLED";
                                  shift;;
     --disable-utahrle)                options="$options -DBRLCAD_UTAHRLE=SYSTEM";
                                  shift;;
     --enable-tcl)                options="$options -DBRLCAD_TCL=BUNDLED";
                                  shift;;
     --disable-tcl)                options="$options -DBRLCAD_TCL=SYSTEM";
                                  shift;;
     --enable-tk)                options="$options -DBRLCAD_TK=BUNDLED";
                                  shift;;
     --disable-tk)                options="$options -DBRLCAD_TK=SYSTEM";
                                  shift;;
     --enable-itcl)                options="$options -DBRLCAD_ITCL=BUNDLED";
                                  shift;;
     --disable-itcl)                options="$options -DBRLCAD_ITCL=SYSTEM";
                                  shift;;
     --enable-itk)                options="$options -DBRLCAD_ITK=BUNDLED";
                                  shift;;
     --disable-itk)                options="$options -DBRLCAD_ITK=SYSTEM";
                                  shift;;
     --enable-iwidgets)                options="$options -DBRLCAD_IWIDGETS=BUNDLED";
                                  shift;;
     --disable-iwidgets)                options="$options -DBRLCAD_IWIDGETS=SYSTEM";
                                  shift;;
     --enable-tkhtml)                options="$options -DBRLCAD_TKHTML=BUNDLED";
                                  shift;;
     --disable-tkhtml)                options="$options -DBRLCAD_TKHTML=SYSTEM";
                                  shift;;
     --enable-tkpng)                options="$options -DBRLCAD_TKPNG=BUNDLED";
                                  shift;;
     --disable-tkpng)                options="$options -DBRLCAD_TKPNG=SYSTEM";
                                  shift;;
     --enable-tktable)                options="$options -DBRLCAD_TKTABLE=BUNDLED";
                                  shift;;
     --disable-tktable)                options="$options -DBRLCAD_TKTABLE=SYSTEM";
                                  shift;;
     --enable-opennurbs)                options="$options -DBRLCAD_OPENNURBS=BUNDLED";
                                  shift;;
     --disable-opennurbs)                options="$options -DBRLCAD_OPENNURBS=SYSTEM";
                                  shift;;
     --enable-scl)                options="$options -DBRLCAD_SC=BUNDLED";
                                  shift;;
     --disable-scl)                options="$options -DBRLCAD_SC=SYSTEM";
                                  shift;;
     --enable-step)                options="$options -DBRLCAD_SC=BUNDLED";
                                  shift;;
     --disable-step)                options="$options -DBRLCAD_SC=SYSTEM";
                                  shift;;
     --enable-step-class-libraries)                options="$options -DBRLCAD_SC=BUNDLED";
                                  shift;;
     --disable-step-class-libraries)                options="$options -DBRLCAD_SC=SYSTEM";
                                  shift;;
     --enable-vds)                options="$options -DBRLCAD_VDS=BUNDLED";
                                  shift;;
     --disable-vds)                options="$options -DBRLCAD_VDS=SYSTEM";
                                  shift;;
     --enable-gdiam)                options="$options -DBRLCAD_GDIAM=BUNDLED";
                                  shift;;
     --disable-gdiam)                options="$options -DBRLCAD_GDIAM=SYSTEM";
                                  shift;;
     --prefix=*)   	          inputstr=$1;
				  options="$options -DCMAKE_INSTALL_PREFIX=${inputstr#--prefix=}";
				  shift;;
     *) 	   	          echo "Warning: unknown option $1";
				  shift;;
   esac
done
echo cmake $options
cmake $options
blob
data 3299
# Third party tools



# Clear all pre-defined CMake flags
CLEAR_BUILD_FLAGS()

# Restore CMake defaults, in case they are needed
RESTORE_CACHED_BUILD_FLAGS(_CMAKE_DEFAULT)

# Quiet all warnings in this directory
if(BRLCAD_DISABLE_SRC_OTHER_WARN)
  add_definitions(-w)
endif(BRLCAD_DISABLE_SRC_OTHER_WARN)

# Most third party items have a list calling out files for distcheck -
# these are stored in files in the dlists directory.  Ignore that
# directory for distcheck
file(GLOB dlists "*.dist")
foreach(ITEM ${dlists})
  get_filename_component(dlist ${ITEM} NAME)
  CMAKEFILES(${dlist})
endforeach(ITEM ${dlists})

# To enforce style guidelines rigorously, BRL-CAD bundles the
# Artistic Style code formatter.  This tool is LGPLv3 licensed
# and its code can *not* be used in BRL-CAD itself - it
# is present striclty and only to be used as a tool in the
# compilation process.
set(astyle_ALIASES ENABLE_ASTYLE)
set(astyle_DESCRIPTION "
Option for enabling and disabling compilation of the Artistic Style
(astyle) utility provided with BRL-CAD's source distribution.  Default is
AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY_EXECUTABLE(astyle astyle "BRLCAD_LEVEL2" astyle_ALIASES astyle_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/astyle/Makefile)

CMAKEFILES(astyle.dist)

# dom2dox - Doc-O-Matic to Doxygen C++ source converter
include(${CMAKE_CURRENT_SOURCE_DIR}/dom2dox.dist)
CMAKEFILES_IN_DIR(dom2dox_ignore_files dom2dox)

# libxml and libxslt tools for DocBook processing.  We build just
# enough library support to get these two tools working.
set(xsltproc_ALIASES ENABLE_XSLTPROC)
set(xsltproc_DESCRIPTION "
Option for enabling and disabling compilation of the xsltproc XML
transformation utility provided with BRL-CAD's source distribution.
Used for DocBook documentation processing.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
Depends on BRLCAD_EXTRADOCS.
")
THIRD_PARTY_EXECUTABLE(xsltproc xmltools "BRLCAD_EXTRADOCS;BRLCAD_LEVEL3" xsltproc_ALIASES xsltproc_DESCRIPTION)
SetTargetFolder(xsltproc "Compilation Utilities")

# Used only when validating XML for schema compliance
# (BRLCAD_EXTRADOCS_VALIDATE must be on to use this, although it is compiled
# regardless if the xmltools subdirectory build is added.)
set(xmllint_ALIASES ENABLE_XMLLINT)
set(xmllint_DESCRIPTION "
Option for enabling and disabling compilation of the xmllint XML
validation utility provided with BRL-CAD's source distribution.  Used
for DocBook documentation validation.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY_EXECUTABLE(xmllint xmltools "BRLCAD_EXTRADOCS_VALIDATE;BRLCAD_LEVEL3" xmllint_ALIASES xmllint_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/xmltools/include)
SetTargetFolder(xmllint "Compilation Utilities")

SetTargetFolder(xml "Third Party Libraries")
SetTargetFolder(xslt "Third Party Libraries")
SetTargetFolder(exslt "Third Party Libraries")

# Locac Variables:
# tab-width: 8
# mode: cmake
# indent-tabs-mode: t
# End:
# ex: shiftwidth=2 tabstop=8
blob
data 21125
/*                         C O N V 3 D M - G . H
 * BRL-CAD
 *
 * Copyright (c) 2004-2014 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file conv3dm-g.cpp
 *
 * Program to convert a Rhino model (in a .3dm file) to a BRL-CAD .g
 * file.
 *
 */




#include "common.h"


/* disabled if OBJ_BREP is not available */
#ifdef OBJ_BREP

#include "conv3dm-g.hpp"

#include <sstream>
#include <stdexcept>

#include "bu/getopt.h"
#include "vmath.h"
#include "wdb.h"



namespace
{




static const bool verbose_mode = false;


static const std::string ROOT_UUID = "00000000-0000-0000-0000-000000000000";
static const std::string DEFAULT_LAYER_NAME = "Default";
static const std::string DEFAULT_NAME = "noname";
static const std::pair<std::string, std::string> DEFAULT_SHADER("plastic", "");

/* UUID buffers must be >= 37 chars per openNURBS API */
static const std::size_t UUID_LEN = 37;


static struct _InitOpenNURBS {
    _InitOpenNURBS()
    {
	ON::Begin();
    }


    ~_InitOpenNURBS()
    {
	ON::End();
    }
} _init_opennurbs;




static inline std::string
UUIDstr(const ON_UUID &uuid)
{
    char buf[UUID_LEN];
    return ON_UuidToString(uuid, buf);
}




static inline std::string
w2string(const ON_wString &source)
{
    if (!source) return "";
    return ON_String(source).Array();
}




static inline bool
is_toplevel(const ON_Layer &layer)
{
    return UUIDstr(layer.m_parent_layer_id) == ROOT_UUID;
}




static std::string
gen_bitmap_id(std::size_t index)
{
    std::ostringstream ss;
    ss << "bitmap_" << index;
    return ss.str();
}




static std::string
basename(const std::string &path)
{
    char *buf = new char[path.size() + 1];
    bu_basename(buf, path.c_str());
    std::string result = buf;
    delete[] buf;

    return result;
}




static void
xform2mat_t(const ON_Xform &source, mat_t dest)
{
    const int dmax = 4;
    for (int row = 0; row < dmax; ++row)
	for (int col = 0; col < dmax; ++col)
	    dest[row*dmax + col] = source[row][col];
}




// Removes all leading and trailing non alpha-numeric characters,
// then replaces all remaining non alpha-numeric characters with
// the '_' character. The allow string is an exception list where
// these characters are allowed, but not leading or trailing, in
// the name.
static std::string
CleanName(ON_wString name)
{
    ON_wString allow(".-_");
    ON_wString new_name;
    bool was_cleaned = false;

    bool found_first = false;
    int idx_first = 0, idx_last = 0;

    for (int j = 0; j < name.Length(); j++) {
	wchar_t c = name.GetAt(j);

	bool ok_char = false;
	if (isalnum(c)) {
	    if (!found_first) {
		idx_first = idx_last = j;
		found_first = true;
	    } else {
		idx_last = j;
	    }
	    ok_char = true;
	} else {
	    for (int k = 0 ; k < allow.Length() ; k++) {
		if (c == allow.GetAt(k)) {
		    ok_char = true;
		    break;
		}
	    }
	}
	if (!ok_char) {
	    c = L'_';
	    was_cleaned = true;
	}
	new_name += c;
    }
    if (idx_first != 0 || name.Length() != ((idx_last - idx_first) + 1)) {
	new_name = new_name.Mid(idx_first, (idx_last - idx_first) + 1);
	was_cleaned = true;
    }
    if (was_cleaned) {
	name.Destroy();
	name = new_name;
    }

    if (name)
	return w2string(name);
    else
	return DEFAULT_NAME;
}




}




namespace conv3dm
{




class RhinoConverter::Color
{
public:
    static Color random();


    Color();
    Color(int red, int green, int blue);
    Color(const ON_Color &src);

    bool operator==(const Color &rhs) const;

    const unsigned char *get_rgb() const;


private:
    void set_rgb(int red, int green, int blue);

    unsigned char m_rgb[3];
};




struct RhinoConverter::ModelObject {
    std::string m_name;
    std::vector<std::string> m_children;
    bool is_in_idef;

    ModelObject() :
	m_name(),
	m_children(),
	is_in_idef(false)
    {}
};




RhinoConverter::Color
RhinoConverter::Color::random()
{
    int red = static_cast<int>(255 * drand48());
    int green = static_cast<int>(255 * drand48());
    int blue = static_cast<int>(255 * drand48());

    return Color(red, green, blue);
}




RhinoConverter::Color::Color()
{
    set_rgb(0, 0, 0);
}




RhinoConverter::Color::Color(int red, int green, int blue)
{
    set_rgb(red, green, blue);
}



RhinoConverter::Color::Color(const ON_Color &src)
{
    set_rgb(src.Red(), src.Green(), src.Blue());
}




bool
RhinoConverter::Color::operator==(const Color &rhs) const
{
    return m_rgb[0] == rhs.m_rgb[0]
	   && m_rgb[1] == rhs.m_rgb[1]
	   && m_rgb[2] == rhs.m_rgb[2];
}




const unsigned char *
RhinoConverter::Color::get_rgb() const
{
    return m_rgb;
}




void
RhinoConverter::Color::set_rgb(int red, int green, int blue)
{
    if (red < 0 || red > 255
	|| green < 0 || green > 255
	|| blue < 0 || blue > 255)
	throw std::out_of_range("invalid color");

    m_rgb[0] = static_cast<unsigned char>(red);
    m_rgb[1] = static_cast<unsigned char>(green);
    m_rgb[2] = static_cast<unsigned char>(blue);
}




RhinoConverter::RhinoConverter(const std::string &output_path) :
    m_use_uuidnames(false),
    m_random_colors(false),
    m_output_dirname(),
    m_obj_map(),
    m_log(new ON_TextLog),
    m_model(new ONX_Model),
    m_db(NULL)
{
    char *buf = bu_dirname(output_path.c_str());
    m_output_dirname = buf;
    bu_free(buf, "bu_dirname buffer");

    m_db = wdb_fopen(output_path.c_str());
    if (!m_db)
	throw std::runtime_error("failed to open database");

    mk_id(m_db, "3dm -> g conversion");
}




RhinoConverter::~RhinoConverter()
{
    wdb_close(m_db);
}




void
RhinoConverter::write_model(const std::string &path, bool use_uuidnames,
			    bool random_colors)
{
    m_use_uuidnames = use_uuidnames;
    m_random_colors = random_colors;

    if (!m_model->Read(path.c_str(), m_log.get()))
	throw std::runtime_error("failed to read 3dm file");

    m_log->Print("Loaded 3dm model '%s'\n", path.c_str());
    clean_model();
    m_log->Print("Number of NURBS objects read: %d\n\n", m_model->m_object_table.Count());

    m_obj_map[ROOT_UUID].m_name = basename(path);

    map_uuid_names();
    create_all_bitmaps();
    create_all_idefs();
    create_all_geometry();
    nest_all_layers();
    create_all_layers();

    m_model->Destroy();

    m_log->Print("Done.\n");
}




void
RhinoConverter::clean_model()
{
    if (!m_model->IsValid(m_log.get())) {
	m_log->Print("Model is NOT valid. Attempting repairs.\n");

	m_model->Polish(); // fill in defaults

	int repair_count = 0;
	ON_SimpleArray<int> warnings;
	m_model->Audit(true, &repair_count, m_log.get(), &warnings); // repair

	m_log->Print("%d objects were repaired.\n", repair_count);
	for (int warn_i = 0; warn_i < warnings.Count(); ++warn_i)
	    m_log->Print("%s\n", warnings[warn_i]);

	if (m_model->IsValid(m_log.get()))
	    m_log->Print("Repair successful, model is now valid.\n");
	else
	    m_log->Print("Repair unsuccessful, model is still NOT valid.\n");
    }
}




void
RhinoConverter::map_uuid_names()
{
    for (int i = 0; i < m_model->m_object_table.Count(); ++i) {
	const ON_Object *object = m_model->m_object_table[i].m_object;
	const ON_3dmObjectAttributes &myAttributes = m_model->m_object_table[i].m_attributes;
	const std::string obj_uuid = UUIDstr(myAttributes.m_uuid);

	std::string suffix = ".s";
	if (object->ObjectType() == ON::instance_reference)
	    suffix = ".c";

	if (m_use_uuidnames)
	    m_obj_map[obj_uuid].m_name = unique_name(obj_uuid, suffix);
	else
	    m_obj_map[obj_uuid].m_name =
		unique_name(CleanName(myAttributes.m_name), suffix);

    }


    for (int i = 0; i < m_model->m_idef_table.Count(); ++i) {
	const ON_InstanceDefinition &idef = m_model->m_idef_table[i];
	const std::string idef_uuid = UUIDstr(idef.m_uuid);

	if (m_use_uuidnames)
	    m_obj_map[idef_uuid].m_name = unique_name(idef_uuid, ".c");
	else
	    m_obj_map[idef_uuid].m_name =
		unique_name(CleanName(idef.Name()), ".c");
    }


    for (int i = 0; i < m_model->m_layer_table.Count(); ++i) {
	const ON_Layer &layer = m_model->m_layer_table[i];
	const std::string layer_uuid = UUIDstr(layer.m_layer_id);

	std::string suffix = ".c";
	if (!m_random_colors && is_toplevel(layer))
	    suffix = ".r";

	if (m_use_uuidnames)
	    m_obj_map[layer_uuid].m_name = unique_name(layer_uuid, suffix);
	else
	    m_obj_map[layer_uuid].m_name =
		unique_name(CleanName(layer.m_name), suffix);
    }


    for (int i = 0; i < m_model->m_bitmap_table.Count(); ++i) {
	const ON_Bitmap *bitmap = m_model->m_bitmap_table[i];
	const std::string bitmap_uuid = gen_bitmap_id(i);

	if (m_use_uuidnames)
	    m_obj_map[bitmap_uuid].m_name = unique_name(bitmap_uuid, ".pix");
	else {
	    std::string bitmap_name = CleanName(bitmap->m_bitmap_name);
	    if (bitmap_name == DEFAULT_NAME)
		bitmap_name = CleanName(bitmap->m_bitmap_filename);

	    m_obj_map[bitmap_uuid].m_name = unique_name(bitmap_name, ".pix");
	}
    }
}




void
RhinoConverter::create_all_bitmaps()
{
    m_log->Print("Creating bitmaps...\n");

    for (int i = 0; i < m_model->m_bitmap_table.Count(); ++i) {
	const ON_Bitmap *bitmap = m_model->m_bitmap_table[i];
	const std::string bitmap_uuid = gen_bitmap_id(i);
	const std::string &bitmap_name = m_obj_map.at(bitmap_uuid).m_name;

	m_log->Print("Creating bitmap '%s'\n", bitmap_name.c_str());
	create_bitmap(bitmap);
    }
}




void
RhinoConverter::create_bitmap(const ON_Bitmap *bmap)
{
    if (const ON_EmbeddedBitmap *bitmap = ON_EmbeddedBitmap::Cast(bmap)) {
	const std::string path = w2string(bitmap->m_bitmap_filename);
	const std::string base = basename(path);

	std::string dest_path = m_output_dirname + BU_DIR_SEPARATOR + base;
	int counter = 0;
	while (bu_file_exists(dest_path.c_str(), NULL)) {
	    std::ostringstream ss;
	    ss << m_output_dirname << BU_DIR_SEPARATOR << "3dm-g-" <<
	       ++counter << '_' << base;
	    dest_path = ss.str();
	}

	m_log->Print("Extracting bitmap to '%s'\n", dest_path.c_str());
	std::ofstream file(dest_path.c_str(), std::ofstream::binary);
	file.exceptions(std::ofstream::failbit | std::ofstream::badbit);
	file.write(static_cast<const char *>(bitmap->m_buffer), bitmap->m_sizeof_buffer);
	file.close();
    } else
	m_log->Print("Skipping non-embedded bitmap\n"); // FIXME
}




void
RhinoConverter::nest_all_layers()
{
    for (int i = 0; i < m_model->m_layer_table.Count(); ++i) {
	const ON_Layer &layer = m_model->m_layer_table[i];
	const std::string layer_uuid = UUIDstr(layer.m_layer_id);
	const std::string parent_layer_uuid = UUIDstr(layer.m_parent_layer_id);

	m_obj_map.at(parent_layer_uuid).m_children.push_back(layer_uuid);
    }
}




void
RhinoConverter::create_all_layers()
{
    m_log->Print("Creating layers...\n");

    for (int i = 0; i < m_model->m_layer_table.Count(); ++i) {
	const ON_Layer &layer = m_model->m_layer_table[i];
	const std::string &layer_name = m_obj_map.at(UUIDstr(layer.m_layer_id)).m_name;
	m_log->Print("Creating layer '%s'\n", layer_name.c_str());
	create_layer(layer);
    }
}




void
RhinoConverter::create_layer(const ON_Layer &layer)
{
    const std::string layer_uuid = UUIDstr(layer.m_layer_id);
    const std::vector<std::string> &child_vec = m_obj_map.at(layer_uuid).m_children;
    const bool is_region = !m_random_colors && is_toplevel(layer);
    const bool do_inherit = false;
    const std::pair<std::string, std::string> shader =
	get_shader(layer.m_material_index);


    std::string layer_name = m_obj_map.at(layer_uuid).m_name;
    if (layer_name == DEFAULT_LAYER_NAME + ".c" || layer_name == DEFAULT_LAYER_NAME + ".r")
	layer_name = m_obj_map.at(ROOT_UUID).m_name;

    wmember members;
    BU_LIST_INIT(&members.l);
    for (std::vector<std::string>::const_iterator it = child_vec.begin();
	 it != child_vec.end(); ++it) {
	const ModelObject &obj = m_obj_map.at(*it);
	if (obj.is_in_idef) continue;
	mk_addmember(obj.m_name.c_str(), &members.l, NULL, WMOP_UNION);
    }

    // FIXME code duplication
    Color color;
    if (m_random_colors)
	color = Color::random();
    else
	color = layer.m_color;

    if (color == Color(0, 0, 0)) {
	m_log->Print("Object has no color; setting color to red\n");
	color = Color(255, 0, 0);
    }

    mk_comb(m_db, layer_name.c_str(), &members.l, is_region,
	    shader.first.c_str(), shader.second.c_str(), color.get_rgb(),
	    0, 0, 0, 0, do_inherit, false, false);

}




void
RhinoConverter::create_all_idefs()
{
    m_log->Print("Creating Instance Definitions...\n");

    for (int i = 0; i < m_model->m_idef_table.Count(); ++i) {
	const ON_InstanceDefinition &idef = m_model->m_idef_table[i];
	const std::string &idef_name =
	    m_obj_map.at(UUIDstr(idef.m_uuid)).m_name;

	m_log->Print("Creating idef '%s'\n", idef_name.c_str());
	create_idef(idef);
    }
}




void
RhinoConverter::create_idef(const ON_InstanceDefinition &idef)
{
    wmember members;
    BU_LIST_INIT(&members.l);

    for (int i = 0; i < idef.m_object_uuid.Count(); ++i) {
	const std::string member_uuid = UUIDstr(idef.m_object_uuid[i]);

	const int geom_index = m_model->ObjectIndex(idef.m_object_uuid[i]);
	if (geom_index == -1) {
	    m_log->Print("referenced uuid=%s does not exist\n", member_uuid.c_str());
	    continue;
	}

	std::string &member_name = m_obj_map.at(member_uuid).m_name;
	mk_addmember(member_name.c_str(), &members.l, NULL, WMOP_UNION);
	m_obj_map.at(member_uuid).is_in_idef = true;
    }

    const std::string &idef_name =
	m_obj_map.at(UUIDstr(idef.m_uuid)).m_name;
    mk_lfcomb(m_db, idef_name.c_str(), &members, false);
}




void
RhinoConverter::create_iref(const ON_InstanceRef &iref,
			    const ON_3dmObjectAttributes &iref_attrs)
{
    mat_t matrix;
    xform2mat_t(iref.m_xform, matrix);

    wmember members;
    BU_LIST_INIT(&members.l);

    const std::string iref_uuid = UUIDstr(iref_attrs.m_uuid);
    const std::string &iref_name = m_obj_map.at(iref_uuid).m_name;
    const bool do_inherit = false;
    const std::pair<std::string, std::string> shader =
	get_shader(iref_attrs.m_material_index);

    const std::string member_uuid = UUIDstr(iref.m_instance_definition_uuid);
    const std::string &member_name = m_obj_map.at(member_uuid).m_name;

    mk_addmember(member_name.c_str(), &members.l, matrix, WMOP_UNION);
    mk_comb(m_db, iref_name.c_str(), &members.l, false,
	    shader.first.c_str(), shader.second.c_str(),
	    get_color(iref_attrs).get_rgb(),
	    0, 0, 0, 0, do_inherit, false, false);

    const std::string parent_uuid =
	UUIDstr(m_model->m_layer_table[iref_attrs.m_layer_index].m_layer_id);
    m_obj_map.at(parent_uuid).m_children.push_back(iref_uuid);
}




bool
RhinoConverter::is_name_taken(const std::string &name) const
{
    for (std::map<std::string, ModelObject>::const_iterator it = m_obj_map.begin();
	 it != m_obj_map.end(); ++it)
	if (name == it->second.m_name)
	    return true;


    return false;
}




std::string
RhinoConverter::unique_name(const std::string &name,
			    const std::string &suffix) const
{
    std::string new_name = name + suffix;
    int counter = 0;
    while (is_name_taken(new_name)) {
	std::ostringstream s;
	s << ++counter;
	new_name = name + s.str() + suffix;
    }

    return new_name;
}




RhinoConverter::Color
RhinoConverter::get_color(const ON_3dmObjectAttributes &obj_attrs) const
{
    Color color;
    if (m_random_colors)
	return Color::random();
    else
	switch (obj_attrs.ColorSource()) {
	    case ON::color_from_parent:
	    case ON::color_from_layer:
		color = m_model->m_layer_table[obj_attrs.m_layer_index].m_color;
		break;

	    case ON::color_from_object:
		color = obj_attrs.m_color;
		break;

	    case ON::color_from_material:
		color = m_model->m_material_table[obj_attrs.m_material_index].m_ambient;
		break;

	    default:
		m_log->Print("ERROR: unknown color source\n");
		return Color(255, 0, 0);
	}


    if (color == Color(0, 0, 0)) {
	m_log->Print("Object has no color; setting color to red\n");
	return Color(255, 0, 0);
    } else
	return color;
}




std::pair<std::string, std::string>
RhinoConverter::get_shader(int index) const
{
    if (index == -1)
	return DEFAULT_SHADER;

    const ON_Material &material = m_model->m_material_table[index];

    std::ostringstream args;
    args << "{";
    args << " tr " << material.m_transparency;
    args << " re " << material.m_reflectivity;
    args << " sp " << material.m_specular;
    args << " di " << material.m_diffuse;
    args << " ri " << material.m_index_of_refraction;
    args << " sh " << material.m_shine;
    // args << " ex " << ??;
    args << " em " << material.m_emission;
    args << " }";

    return std::make_pair(DEFAULT_SHADER.first, args.str());
}




void
RhinoConverter::create_brep(const ON_Brep &brep, const ON_3dmObjectAttributes &brep_attrs)
{
    const std::string brep_uuid = UUIDstr(brep_attrs.m_uuid);
    const std::string &brep_name = m_obj_map.at(brep_uuid).m_name;

    m_log->Print("Creating BREP '%s'\n", brep_name.c_str());

    mk_brep(m_db, brep_name.c_str(), const_cast<ON_Brep *>(&brep));
    const std::string parent_uuid =
	UUIDstr(m_model->m_layer_table[brep_attrs.m_layer_index].m_layer_id);

    m_obj_map.at(parent_uuid).m_children.push_back(brep_uuid);
}




void
RhinoConverter::create_all_geometry()
{
    for (int i = 0; i < m_model->m_object_table.Count(); ++i) {
	const ON_3dmObjectAttributes &obj_attrs = m_model->m_object_table[i].m_attributes;
	const std::string obj_uuid = UUIDstr(obj_attrs.m_uuid);
	const std::string &obj_name = m_obj_map.at(obj_uuid).m_name;

	m_log->Print("Object %d of %d...", i + 1, m_model->m_object_table.Count());

	const ON_Geometry *pGeometry = ON_Geometry::Cast(m_model->m_object_table[i].m_object);
	if (pGeometry)
	    create_geometry(pGeometry, obj_attrs);
	else
	    m_log->Print("WARNING: Skipping non-Geometry entity: %s\n", obj_name.c_str());
    }
}




void
RhinoConverter::create_geometry(const ON_Geometry *pGeometry,
				const ON_3dmObjectAttributes &obj_attrs)
{
    if (const ON_Brep *brep = ON_Brep::Cast(pGeometry)) {
	create_brep(*brep, obj_attrs);
    } else if (pGeometry->HasBrepForm()) {
	ON_Brep *new_brep = pGeometry->BrepForm();
	create_brep(*new_brep, obj_attrs);
	delete new_brep;
    } else if (const ON_Curve *curve = ON_Curve::Cast(pGeometry)) {
	m_log->Print("Skipping: Type: ON_Curve\n");
	if (verbose_mode) curve->Dump(*m_log);
    } else if (const ON_Surface *surface = ON_Surface::Cast(pGeometry)) {
	m_log->Print("Skipping: Type: ON_Surface\n");
	if (verbose_mode) surface->Dump(*m_log);
    } else if (const ON_Mesh *mesh = ON_Mesh::Cast(pGeometry)) {
	m_log->Print("Skipping: Type: ON_Mesh\n");
	if (verbose_mode) mesh->Dump(*m_log);
    } else if (const ON_RevSurface *revsurf = ON_RevSurface::Cast(pGeometry)) {
	m_log->Print("Skipping: Type: ON_RevSurface\n");
	if (verbose_mode) revsurf->Dump(*m_log);
    } else if (const ON_PlaneSurface *planesurf = ON_PlaneSurface::Cast(pGeometry)) {
	m_log->Print("Skipping: Type: ON_PlaneSurface\n");
	if (verbose_mode) planesurf->Dump(*m_log);
    } else if (const ON_InstanceDefinition *instdef = ON_InstanceDefinition::Cast(pGeometry)) {
	m_log->Print("Skipping: Type: ON_InstanceDefinition\n");
	if (verbose_mode) instdef->Dump(*m_log);
    } else if (const ON_InstanceRef *instref = ON_InstanceRef::Cast(pGeometry)) {

	const std::string &iref_name =
	    m_obj_map.at(UUIDstr(obj_attrs.m_uuid)).m_name;

	m_log->Print("Creating iref '%s'\n", iref_name.c_str());
	if (verbose_mode) instref->Dump(*m_log);

	create_iref(*instref, obj_attrs);

    } else if (const ON_Layer *layer = ON_Layer::Cast(pGeometry)) {
	m_log->Print("Skipping: Type: ON_Layer\n");
	if (verbose_mode) layer->Dump(*m_log);
    } else if (const ON_Light *light = ON_Light::Cast(pGeometry)) {
	m_log->Print("Skipping: Type: ON_Light\n");
	if (verbose_mode) light->Dump(*m_log);
    } else if (const ON_NurbsCage *nurbscage = ON_NurbsCage::Cast(pGeometry)) {
	m_log->Print("Skipping: Type: ON_NurbsCage\n");
	if (verbose_mode) nurbscage->Dump(*m_log);
    } else if (const ON_MorphControl *morphctrl = ON_MorphControl::Cast(pGeometry)) {
	m_log->Print("Skipping: Type: ON_MorphControl\n");
	if (verbose_mode) morphctrl->Dump(*m_log);
    } else if (const ON_Group *group = ON_Group::Cast(pGeometry)) {
	m_log->Print("Skipping: Type: ON_Group\n");
	if (verbose_mode) group->Dump(*m_log);
    } else m_log->Print("Skipping unknown object type\n");

    if (verbose_mode) {
	m_log->PopIndent();
	m_log->Print("\n\n");
    }
}




}




#endif //OBJ_BREP




/*
 * Local Variables:
 * tab-width: 8
 * mode: C++
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 45132
#-----------------------------------------------------------------------
# Local Copies of External Libraries
#
# BRL-CAD depends on a variety of external libraries and tools -
# rather than fail if those requirements are not satisfied, we build
# local copies at need.
#
# There are three overall approaches to the handling of these
# dependencies:
#
# 1.  Auto - detect system libraries and use them if suitable,
#     otherwise build and use the local copy.  This is the default
#     approach.
#
# 2.  Bundled - regardless of system conditions, build and use all
#     bundled libraries.
#
# 3.  System - fail to build if the system libraries do not satisfy
#     requirements.  This is primarily useful for distributions that
#     want to ensure packages are using external libraries.
#
# In addition to the broad toplevel control, individual libraries can
# also be overridden - for example, if the toplevel setting is for
# Bundled libs, it is still possible to request a system library in
# individual cases.
#
#-----------------------------------------------------------------------

# Clear all BRL-CAD defined CMake flags
CLEAR_BUILD_FLAGS()

# Restore CMake's original flags
RESTORE_CACHED_BUILD_FLAGS(_CMAKE_DEFAULT)

# Quiet all warnings in this directory
if(BRLCAD_DISABLE_SRC_OTHER_WARN)
  add_definitions(-w)
endif(BRLCAD_DISABLE_SRC_OTHER_WARN)

# Ideally we wouldn't need this, but in a few cases we're using
# BRL-CAD's include dirs.
include_directories(
  ${BRLCAD_BINARY_DIR}/include
  ${BRLCAD_SOURCE_DIR}/include
  )

# Most third party items have a list calling out files for distcheck -
# these are stored in files in the dlists directory.  Ignore that
# directory for distcheck
file(GLOB dlists "*.dist")
foreach(ITEM ${dlists})
  get_filename_component(dlist ${ITEM} NAME)
  CMAKEFILES(${dlist})
endforeach(ITEM ${dlists})

# libregex library -  often needed by tools, so do this one first.
set(regex_ALIASES ENABLE_REGEX)
set(regex_DESCRIPTION "
Option for enabling and disabling compilation of the Regular
Expression Library provided with BRL-CAD's source distribution.
Default is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option
and testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.
")
THIRD_PARTY(libregex REGEX regex regex_DESCRIPTION ALIASES ${regex_ALIASES})
BRLCAD_INCLUDE_FILE(regex.h HAVE_REGEX_H)
SetTargetFolder(regex "Third Party Libraries")
SetTargetFolder(regex-static "Third Party Libraries")

CHECK_LIBRARY_EXISTS(c regcomp "" HAVE_LIBC_REGEX)
if(BUILD_SHARED_LIBS AND HAVE_LIBC_REGEX AND "${BRLCAD_REGEX}" MATCHES "BUNDLED")
  # Our tests indicate that the system libc defines regex symbols, but
  # we're still building with our local libregex.
  #
  # Platform differences in default linker behavior make it difficult
  # to guarantee that our libregex symbols will override libc. We'll
  # avoid the issue by renaming our libregex symbols to be
  # incompatible with libc.

  # First we add definitions to our config file to rename all of the
  # regex function calls in our first-party code.
  CONFIG_H_APPEND(BRLCAD "#define regcomp  libregex_regcomp\n")
  CONFIG_H_APPEND(BRLCAD "#define regerror libregex_regerror\n")
  CONFIG_H_APPEND(BRLCAD "#define regexec  libregex_regexec\n")
  CONFIG_H_APPEND(BRLCAD "#define regfree  libregex_regfree\n")

  # Second, we add the same definitions to libregex to rename the
  # function declarations and definitions to match the calls.
  #
  # Note that this is necessary despite the fact that libregex/regex.h
  # includes common.h. Our config file is intentionally omitted from
  # common.h until after the third party dirs are processed, so the
  # above definitions don't affect libregex.
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regcomp=libregex_regcomp)
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regerror=libregex_regerror)
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regexec=libregex_regexec)
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regfree=libregex_regfree)
endif(BUILD_SHARED_LIBS AND HAVE_LIBC_REGEX AND "${BRLCAD_REGEX}" MATCHES "BUNDLED")

# Same deal for zlib Library - common requirement, deal with it up front
set(zlib_ALIASES ENABLE_ZLIB ENABLE_LIBZ)
set(zlib_DESCRIPTION "
Option for enabling and disabling compilation of the zlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(libz ZLIB zlib zlib_DESCRIPTION ALIASES ${zlib_ALIASES})
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libz/CTestTestfile.cmake)
SetTargetFolder(zlib "Third Party Libraries")
SetTargetFolder(zlib-static "Third Party Libraries")
SetTargetFolder(example "Third Party Executables")
SetTargetFolder(minigzip "Third Party Executables")

#-----------------------------------------------------------------------------

#---------------------------------------------------------------------------------
# Local Copies of Tools
#---------------------------------------------------------------------------------

# Because we sometimes need to override system versions of tools, it
# is essential that the variables containing the executable to be run
# for each of the following tools use full paths - if just the name of
# the target is used, there is a chance that name is the same as the
# executable name itself.  In that case, if the system executable is
# in the path, it may get called instead of resolving to the compiled
# exectuable associated with the CMake target.  (Information from the
# CMake devs indicates this is not expected behavior, but at some
# point during the development efforts a problem apparently related to
# this came up.)  On single configuration systems we can reference
# specify the full path to the binary directory at CMake configure
# time, but this isn't possible for multi-configuration systems like
# Visual Studio since that path changes at run-time.  For those
# situations, CMake provides a variable CMAKE_CFG_INTDIR that will
# insert the correct logic for config-dependent paths.

# For those wanting to use a system version of the LEMON parser
# generator from sqlite, remember that the presence of /usr/bin/lemon
# is not enough.  LEMON needs a template file, lempar.c, and by
# default it needs it in the same directory as /usr/bin/lemon.  The
# typical approach to avoiding that requirement is to patch lemon,
# like this Gentoo ebuild:
#
# http://gentoo-overlays.zugaina.org/gentoo-zh/portage/dev-util/lemon/
#
# LEMON packages for other major Linux/BSD distros will do the same.
# BRL-CAD's FindLEMON.cmake macros will look for the template file in
# the executable directory first, and if not there will check in
# /usr/share/lemon (the location used by several distributions.)  If
# your distribution has a working lemon with the lempar.c template
# file in a custom location, specify the full path to the template
# with the variable LEMON_TEMPLATE - something like:
#
# cmake .. -DLEMON_TEMPLATE=/etc/lemon/lempar.c
#
# This is not to tell LEMON what template to use - that information is
# usually hardcoded in LEMON itself - but to let FindLEMON.cmake know
# there is a working LEMON installation.
set(lemon_ALIASES ENABLE_LEMON)
set(lemon_DESCRIPTION "
Option for enabling and disabling compilation of the lemon parser
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
if("${BRLCAD_BUNDLED_LIBS}" STREQUAL "BUNDLED" OR "${BRLCAD_LEMON}" MATCHES "BUNDLED")
  set(LEMON_TEMPLATE "${BRLCAD_SOURCE_DIR}/src/other/lemon/lempar.c")
endif("${BRLCAD_BUNDLED_LIBS}" STREQUAL "BUNDLED" OR "${BRLCAD_LEMON}" MATCHES "BUNDLED")
THIRD_PARTY_EXECUTABLE(lemon lemon "BRLCAD_LEVEL2" lemon_ALIASES lemon_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/lemon/Makefile)
# Unless some parent logic has already defined the macro, we need to
# load LEMON_Util to be able to define LEMON targets.
if(NOT COMMAND LEMON_TARGET)
  include(${BRLCAD_CMAKE_DIR}/LEMON_Util.cmake)
endif(NOT COMMAND LEMON_TARGET)
SetTargetFolder(lemon "Compilation Utilities")
SetTargetFolder(lempar_cp "Compilation Utilities")

set(re2c_ALIASES ENABLE_RE2C)
set(re2c_DESCRIPTION "
Option for enabling and disabling compilation of the re2c scanner
utility provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY_EXECUTABLE(re2c re2c "BRLCAD_LEVEL2" re2c_ALIASES re2c_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/re2c/Makefile)
SetTargetFolder(re2c "Compilation Utilities")
SetTargetFolder(re2c_bootstrap "Compilation Utilities")

# Unless some parent logic has already defined the macro, we need to
# load RE2C_Util to be able to define RE2C targets.

if(NOT COMMAND RE2C_TARGET)
  include(${BRLCAD_SOURCE_DIR}/misc/CMake/RE2C_Util.cmake)
endif(NOT COMMAND RE2C_TARGET)

# Perplex is set up as a src/other sub-build, but at this time it is
# entirely a BRL-CAD effort and not distributed or maintained as its
# own project.

# For all BRL-CAD projects, we will use the perplex template in
# src/other/perplex
set(PERPLEX_TEMPLATE "${CMAKE_CURRENT_SOURCE_DIR}/perplex/perplex_template.c" CACHE STRING "Perplex template file" FORCE)
mark_as_advanced(PERPLEX_TEMPLATE)

set(perplex_ALIASES ENABLE_PERPLEX)
set(perplex_DESCRIPTION "
Option for enabling and disabling compilation of the perplex scanner
generator provided with BRL-CAD's source distribution.  Default is
AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.  perplex requires a working re2c.
")
THIRD_PARTY_EXECUTABLE(perplex perplex "BRLCAD_LEVEL2" perplex_ALIASES perplex_DESCRIPTION NOSYS)
# Unless some parent logic has already defined the macro, we need to
# load PERPLEX_Util to be able to define PERPLEX targets.
if(NOT COMMAND PERPLEX_TARGET)
  include(${BRLCAD_SOURCE_DIR}/misc/CMake/PERPLEX_Util.cmake)
endif(NOT COMMAND PERPLEX_TARGET)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/perplex/Makefile)
SetTargetFolder(perplex "Compilation Utilities")
SetTargetFolder(perplex_template_cp "Compilation Utilities")

# --------------------------------------------------------------------
# Third Party Sources
# --------------------------------------------------------------------
# Ignore the boost subdir - it's only used for the boost headers and
# is not compiled
CMAKEFILES(boost)

# The incrtTcl subdirectory isn't directly referenced, but its
# subdirectories are used - mark incrTcl as ignored
CMAKEFILES(incrTcl)

# Ignore the osl subdir
CMAKEFILES(osl)

# libtermlib Library Only on WIN32 will the combination of the build
# search tests and libtermlib fail to find a valid term, so set
# variables accordingly
if(NOT WIN32)
  set(HAVE_TERMLIB ON CACHE BOOL "Have some termlib" FORCE)
ELSE(NOT WIN32)
  set(BRLCAD_TERMLIB_BUILD "System" CACHE STRING "Disable libtermlib build on WIN32." FORCE)
  mark_as_advanced(BRLCAD_TERMLIB_BUILD)
  set(HAVE_TERMLIB OFF CACHE BOOL "Have some termlib" FORCE)
endif(NOT WIN32)
mark_as_advanced(HAVE_TERMLIB)

set(termlib_ALIASES ENABLE_TERMLIB)
set(termlib_DESCRIPTION "
Option for enabling and disabling compilation of the termlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO. (Except when building with Visual Studio, where it is
disabled. Windows does not support the termlib API.)
")
THIRD_PARTY(libtermlib TERMLIB termlib termlib_DESCRIPTION REQUIRED_VARS HAVE_TERMLIB
  BRLCAD_LEVEL2 ALIASES ${termlib_ALIASES})
if(BRLCAD_TERMLIB_BUILD)
  set(HAVE_TERMCAP_H ON CACHE BOOL "src/other termlib is on" FORCE)
  CONFIG_H_APPEND(BRLCAD "#undef HAVE_TERMCAP_H\n#cmakedefine HAVE_TERMCAP_H 1\n")
  mark_as_advanced(HAVE_TERMCAP_H)
endif(BRLCAD_TERMLIB_BUILD)

# libpng Library - Checks for ZLIB, so need to handle libpng AFTER
# zlib to set the variables if using a local copy of zlib.  If not
# using a local copy of zlib, FindZLIB results will be identical in
# both cases so there is no danger of harming the libpng setup.  The
# PNG CMake system needs some options set and some variables
# translated to fit BRL-CAD's standard assumptions, so handle that
# here as well.  BRL-CAD needs PNG's IO - turn it on (i.e. turn off
# the disabling flags)

set(PNG_NO_CONSOLE_IO OFF CACHE BOOL "Option to disable Console IO in PNG" FORCE)
mark_as_advanced(PNG_NO_CONSOLE_IO)
set(PNG_NO_STDIO OFF CACHE BOOL "Option to disable STDIO in PNG" FORCE)
mark_as_advanced(PNG_NO_STDIO)
set(SKIP_INSTALL_EXPORT ON CACHE BOOL "We dont't want export for this application" FORCE)
mark_as_advanced(SKIP_INSTALL_EXPORT)
set(PNG_MAN_DIR ${MAN_DIR} CACHE STRING "Set PNG_MAN_DIR to the global MAN_DIR" FORCE)
mark_as_advanced(PNG_MAN_DIR)
set(CMAKE_INSTALL_LIBDIR ${LIB_DIR})
set(png_ALIASES ENABLE_PNG)
set(png_DESCRIPTION "
Option for enabling and disabling compilation of the Portable Network
Graphics library provided with BRL-CAD's source distribution.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.
")
# Note - we don't actually know the libpng build target name for the
# shared library at this point - use png as a stub and override
# once we know what PNG_LIB_NAME is.
THIRD_PARTY(libpng PNG png png_DESCRIPTION REQUIRED_VARS BRLCAD_LEVEL2 ALIASES ${png_ALIASES})
if(BRLCAD_PNG_BUILD)
  # PNG_LIB_NAME doesn't automatically propagate to toplevel due to
  # scoping of CMake variables - use get_directory_property to recover
  # the value (which is later put in the CACHE)

  get_directory_property(PNG_LIBRARY DIRECTORY libpng DEFINITION PNG_LIB_NAME)

  # On Haiku the find_library call sets this variable directly, which is not
  # how we handle things elsewhere in BRL-CAD - unset the variable in that
  # situation so the remainder of the build logic works normally
  if("${M_LIBRARY}" MATCHES "NOTFOUND")
    unset(M_LIBRARY CACHE)
  endif("${M_LIBRARY}" MATCHES "NOTFOUND")
  SetTargetFolder(png16 "Third Party Libraries")
  SetTargetFolder(png16_static "Third Party Libraries")
  SetTargetFolder(pngtest "Third Party Libraries")
  SetTargetFolder(pngstest "Third Party Libraries")
  SetTargetFolder(pngvalid "Third Party Libraries")
ELSE(BRLCAD_PNG_BUILD)
  # The PNG CMake file seems to set PNG_PNG_INCLUDE_DIR rather than
  # PNG_INCLUDE_DIR, so a generic macro won't pick up the setting -
  # handle it here.
  set(PNG_INCLUDE_DIR ${PNG_PNG_INCLUDE_DIR} CACHE STRING "PNG include directory" FORCE)
endif(BRLCAD_PNG_BUILD)

# Make sure this value is in the cache, regardless of
# BRLCAD_PNG_BUILD, so it can be referenced unconditionally elsewhere.
set(PNG_LIBRARY "${PNG_LIBRARY}" CACHE STRING "libpng name for targets" FORCE)

DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/CTestTestfile.cmake)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng.pc)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng-config)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng${CMAKE_SHARED_LIBRARY_SUFFIX})
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng${CMAKE_STATIC_LIBRARY_SUFFIX})
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng.pc)
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng-config)
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng${CMAKE_SHARED_LIBRARY_SUFFIX})
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng${CMAKE_STATIC_LIBRARY_SUFFIX})
# Other PNG options to mark as advanced
mark_as_advanced(PNGARG)
mark_as_advanced(PNG_DEBUG)
mark_as_advanced(PNG_SHARED)
mark_as_advanced(PNG_STATIC)
mark_as_advanced(PNG_TESTS)
mark_as_advanced(uname_executable)


# libutahrle Library - The directory to perform ADD_SUBDIRECTORY on
# and the include directory for utahrle are different, so override the
# macro's setting of UTAHRLE_INCLUDE_DIR here.

set(utahrle_ALIASES ENABLE_UTAHRLE)
set(utahrle_DESCRIPTION "
Option for enabling and disabling compilation of the Utah Raster
Toolkit library provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(libutahrle UTAHRLE utahrle utahrle_DESCRIPTION REQUIRED_VARS BRLCAD_LEVEL3
  ALIASES ${utahrle_ALIASES} FLAGS NOSYS)
if(BRLCAD_UTAHRLE_BUILD)
  SetTargetFolder(utahrle "Third Party Libraries")
  SetTargetFolder(utahrle-static "Third Party Libraries")
  set(UTAHRLE_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/libutahrle/include" CACHE STRING "directory with rle.h header" FORCE)
  set(BRLCAD_UTAHRLE_INCLUDE_DIR "${UTAHRLE_INCLUDE_DIR}" CACHE STRING "directory with rle.h header" FORCE)
  mark_as_advanced(UTAHRLE_INCLUDE_DIR)
  mark_as_advanced(BRLCAD_UTAHRLE_INCLUDE_DIR)
endif(BRLCAD_UTAHRLE_BUILD)


# URTToolkit - Programs, not a library - needs libutahrle, but the
# "check for system install" logic will be different here.  Ignore for
# now, revisit later.

if(BRLCAD_LEVEL3)
  add_subdirectory(URToolkit)
endif(BRLCAD_LEVEL3)
include(${CMAKE_CURRENT_SOURCE_DIR}/URToolkit.dist)
CMAKEFILES_IN_DIR(URToolkit_ignore_files URToolkit)

# Tcl/Tk presents a number of complexities for BRL-CAD and CMake.
# BRL-CAD requires far more knowledge of the details of a Tcl/Tk
# installation than most programs, which unfortunately means the
# standard FindTCL.cmake is not sufficient. We have our own FindTCL
# routine which handles Tcl/Tk and its stubs, so trigger this using
# the THIRD_PARTY macro for TCL.

include(${BRLCAD_SOURCE_DIR}/misc/CMake/TCL_PKGINDEX.cmake)

# Set Tcl/Tk requirements for BRL-CAD so FindTCL.cmake knows what to reject
set(TCL_PATH_NOMATCH_PATTERNS "/usr/brlcad;brlcad-install;${CMAKE_INSTALL_PREFIX}" CACHE STRING "Paths to avoid when looking for tcl/tk" FORCE)
set(TCL_MIN_VERSION "8.5" CACHE STRING "Minimum acceptable Tcl/Tk version" FORCE)

if(BRLCAD_ENABLE_TK)
  set(TCL_REQUIRE_TK 1)
ELSE(BRLCAD_ENABLE_TK)
  set(TCL_REQUIRE_TK 0)
endif(BRLCAD_ENABLE_TK)

set(tcl_ALIASES ENABLE_TCL)
set(tcl_DESCRIPTION "
Option for enabling and disabling compilation of the Tcl library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.
")

THIRD_PARTY(tcl TCL tcl tcl_DESCRIPTION ALIASES ${tcl_ALIASES})
if(BRLCAD_TCL_BUILD)
  SetTargetFolder(tclsh "Third Party Executables")
  SetTargetFolder(tcl "Third Party Libraries")
  SetTargetFolder(tclstub "Third Party Libraries")
  # Set the variables ourselves since FindTCL.cmake doesn't know about our build
  set(TCL_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/tcl)
  set(TCL_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
  set(TCL_LIBRARY tcl CACHE STRING "TCL_LIBRARY" FORCE)
  set(TCL_LIBRARIES tcl CACHE STRING "TCL_LIBRARY" FORCE)
  set(TCL_CONF_PREFIX "NONE-CMake" CACHE STRING "TCL_CONF_PREFIX" FORCE)
  set(TCL_STUB_LIBRARY tclstub CACHE STRING "TCL_LIBRARY" FORCE)
  set(TCL_STUB_LIBRARIES tclstub CACHE STRING "TCL_LIBRARY" FORCE)
  get_directory_property(TCL_INCLUDE_DIRS DIRECTORY tcl DEFINITION TCL_INCLUDE_DIRS)
  set(TCL_INCLUDE_DIRS "${TCL_INCLUDE_DIRS}" CACHE STRING "Tcl include paths" FORCE)
  set(TCL_INCLUDE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/tcl/generic" CACHE STRING "Tcl include path" FORCE)
  set(TCL_TCLSH_EXECUTABLE tclsh CACHE STRING "Tcl shell" FORCE)
  set(TCL_TCLSH tclsh CACHE STRING "Tcl shell" FORCE)
  get_directory_property(TCL_VERSION_MAJOR DIRECTORY tcl DEFINITION TCL_VERSION_MAJOR)
  set(TCL_VERSION_MAJOR "${TCL_VERSION_MAJOR}" CACHE STRING "Tcl MAJOR version" FORCE)
  get_directory_property(TCL_VERSION_MINOR DIRECTORY tcl DEFINITION TCL_VERSION_MINOR)
  set(TCL_VERSION_MINOR "${TCL_VERSION_MINOR}" CACHE STRING "Tcl MINOR version" FORCE)
  CONFIG_H_APPEND(BRLCAD "#define HAVE_TCL_H 1\n")
  CONFIG_H_APPEND(BRLCAD "#define TCL_SYSTEM_INITTCL_PATH \"\"\n")
  include(${CMAKE_CURRENT_SOURCE_DIR}/tcl.dist)
  CMAKEFILES_IN_DIR(tcl_ignore_files tcl)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/Makefile)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/man1)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/man3)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/mann)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/library/Makefile)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tcl8)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tcl8.5)
ELSE(BRLCAD_TCL_BUILD)
  if(${TCL_TCLSH_EXECUTABLE})
    BRLCAD_INCLUDE_FILE(tcl.h HAVE_TCL_H)
    # We're going to need the path to the system init.tcl for btclsh and bwish
    set(inittcl_script "
set filename \"${CMAKE_BINARY_DIR}/CMakeTmp/tcl_inittcl\"
set fileID [open $filename \"w\"]
puts $fileID $auto_path
close $fileID
exit
")
    set(inittcl_scriptfile "${CMAKE_BINARY_DIR}/CMakeTmp/tcl_inittcl.tcl")
    file(WRITE ${inittcl_scriptfile} ${inittcl_script})
    EXEC_PROGRAM(${TCL_TCLSH_EXECUTABLE} ARGS ${inittcl_scriptfile} OUTPUT_VARIABLE EXECOUTPUT)
    file(READ ${CMAKE_BINARY_DIR}/CMakeTmp/tcl_inittcl tcl_inittcl_raw)
    STRING(REGEX REPLACE "\n" "" tcl_inittcl_paths_1 ${tcl_inittcl_raw})
    STRING(REGEX REPLACE " " ";" tcl_inittcl_paths ${tcl_inittcl_paths_1})
    FIND_PATH(tcl_inittcl NAMES init.tcl PATHS ${tcl_inittcl_paths})
    mark_as_advanced(tcl_inittcl)
    CONFIG_H_APPEND(BRLCAD "#define TCL_SYSTEM_INITTCL_PATH \"${tcl_inittcl}\"\n")
  endif(${TCL_TCLSH_EXECUTABLE})
endif(BRLCAD_TCL_BUILD)
mark_as_advanced(TCL_COMPILE_DEBUG)
mark_as_advanced(TCL_COMPILE_STATS)
mark_as_advanced(TCL_DEBUG)
mark_as_advanced(TCL_ENABLE_64BIT)
mark_as_advanced(TCL_ENABLE_DLL_UNLOADING)
mark_as_advanced(TCL_ENABLE_LANGINFO)
mark_as_advanced(TCL_ENABLE_LOAD)
mark_as_advanced(TCL_OPTIMIZED)
mark_as_advanced(TCL_THREADS)
mark_as_advanced(TCL_TIMEZONE_DATA)
mark_as_advanced(M_LIBRARY)

# Depending on the Tcl/Tk results, look for packages required by BRL-CAD.  If
# building local Tcl/Tk, go ahead and enable all the packages as well - otherwise,
# check the found Tcl/Tk and enable what it doesn't supply.  If doing a non-graphical
# build, only compile extensions that don't use Tk.
include(${BRLCAD_CMAKE_DIR}/ThirdParty_TCL.cmake)

# The first package to settle is Tk itself
set(tk_ALIASES ENABLE_TK)
set(tk_DESCRIPTION "
Option for enabling and disabling compilation of the Tk library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the BRLCAD_TCL option and testing first for a system version if
BRLCAD_BUNDLED_LIBS is also AUTO. Option for enabling and disabling
compilation of the Tk graphics package for Tcl provided with BRL-CAD's
source distribution.  Default is AUTO, auto-enabling if the BRLCAD_TCL
option is set to BUNDLED and testing first for a system version if
BRLCAD_TCL is set to AUTO or SYSTEM.  If BRLCAD_TK is set to BUNDLED,
local copy is built even if a system version is present.  This option
also depends on BRLCAD_ENABLE_TK being ON.
")
THIRD_PARTY_TCL_PACKAGE(Tk tk "${TCL_TCLSH_EXECUTABLE}" "tcl" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL2" "tk" tk_ALIASES tk_DESCRIPTION)
if(BRLCAD_TK_BUILD)
  SetTargetFolder(wish "Third Party Executables")
  SetTargetFolder(tk "Third Party Libraries") 
  SetTargetFolder(tkstub "Third Party Libraries") 
  # Set the variables ourselves since FindTCL.cmake doesn't know about our build
  set(TCL_TK_LIBRARY tk CACHE STRING "TCL_TK_LIBRARY" FORCE)
  set(TCL_TK_CONF_PREFIX "NONE-CMake" CACHE STRING "TCL_TK_CONF_PREFIX" FORCE)
  set(TCL_LIBRARIES ${TCL_LIBRARIES} tk CACHE STRING "TCL_LIBRARIES" FORCE)
  set(TK_LIBRARY tk CACHE STRING "TK_LIBRARY" FORCE)
  set(TCL_STUB_LIBRARIES tkstub ${TCL_STUB_LIBRARIES} CACHE STRING "TCL_TK_STUBLIBRARIES" FORCE)
  set(TCL_TK_STUB_LIBRARY tkstub CACHE STRING "TCL_TK_STUB_LIBRARY" FORCE)
  set(TK_STUB_LIBRARY tkstub CACHE STRING "TK_STUB_LIBRARY" FORCE)
  set(TK_INCLUDE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/tk/generic" CACHE STRING "Tk include path" FORCE)
  set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${TK_INCLUDE_PATH} CACHE STRING "Tcl include paths" FORCE)
  if(WIN32)
    set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/tk/win ${CMAKE_CURRENT_SOURCE_DIR}/tk/xlib CACHE STRING "Tcl include paths" FORCE)
  endif(WIN32)
  set(TCL_WISH_EXECUTABLE wish CACHE STRING "Tk shell" FORCE)
  set(TK_WISH wish CACHE STRING "Tk shell" FORCE)
  if(WIN32)
    set(TK_SYSTEM_GRAPHICS "win32" CACHE STRING "Tk system graphics" FORCE)
  ELSEif(APPLE)
    if(OPENGL_USE_AQUA)
      set(TK_SYSTEM_GRAPHICS "aqua" CACHE STRING "Tk system graphics" FORCE)
    ELSE(OPENGL_USE_AQUA)
      set(TK_SYSTEM_GRAPHICS "x11" CACHE STRING "Tk system graphics" FORCE)
    endif(OPENGL_USE_AQUA)
  ELSEif(UNIX)
    set(TK_SYSTEM_GRAPHICS "x11" CACHE STRING "Tk system graphics" FORCE)
  endif(WIN32)
  CONFIG_H_APPEND(BRLCAD "#define HAVE_TK_H 1\n")
  mark_as_advanced(TK-ENABLE_FREETYPE)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/Makefile)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/man1)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/man3)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/mann)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/library/Makefile)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tk8.5)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tk8.5.9)
ELSE(BRLCAD_TK_BUILD)
  if(BRLCAD_ENABLE_TK)
    BRLCAD_INCLUDE_FILE(tk.h HAVE_TK_H)
  endif(BRLCAD_ENABLE_TK)
endif(BRLCAD_TK_BUILD)
mark_as_advanced(TK_INCLUDE_PATH)
mark_as_advanced(TK_LIBRARY)
mark_as_advanced(TK_STUB_LIBRARY)
mark_as_advanced(TK_SYSTEM_GRAPHICS)
mark_as_advanced(TK_WISH)
mark_as_advanced(TK_ENABLE_XFT)

# Now that Tcl/Tk is settled, define the HAVE_TK flag for the config.h
# file

if(BRLCAD_ENABLE_TK)
  set(HAVE_TK 1 CACHE STRING "C level Tk flag" FORCE)
  CONFIG_H_APPEND(BRLCAD "#cmakedefine HAVE_TK\n")
ELSE(BRLCAD_ENABLE_TK)
  set(HAVE_TK 0 CACHE STRING "C level Tk flag" FORCE)
endif(BRLCAD_ENABLE_TK)
mark_as_advanced(HAVE_TK)

# Tcl/Tk extensions need a variety of settings provided for them -
# take care of those here.  Because system Tcl/Tk installations are
# not guaranteed to have what is needed in the way of headers, go
# ahead and assign includedir settings based on the local sources even
# if system versions are enabled.  Ugly, but an unfortunate
# consequence of current Tcl/Tk coding styles

set(TCL_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/tcl)
set(TK_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/tk)
set(ITCL_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/incrTcl/itcl)
if(WIN32)
  set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/tcl/generic ${CMAKE_CURRENT_SOURCE_DIR}/tcl/win ${CMAKE_CURRENT_SOURCE_DIR}/tcl/libtommath)
  set(TK_INCLUDE_PATH ${TK_INCLUDE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/tk/generic ${CMAKE_CURRENT_SOURCE_DIR}/tk/xlib ${CMAKE_CURRENT_SOURCE_DIR}/tk/win ${CMAKE_CURRENT_SOURCE_DIR}/tk/bitmaps)
ELSE(WIN32)
  set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/tcl/generic ${CMAKE_CURRENT_SOURCE_DIR}/tcl/unix ${CMAKE_CURRENT_SOURCE_DIR}/tcl/libtommath)
  set(TK_INCLUDE_PATH ${TK_INCLUDE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/tk/generic ${CMAKE_CURRENT_SOURCE_DIR}/tk/unix ${CMAKE_CURRENT_SOURCE_DIR}/tk/bitmaps)
endif(WIN32)
set(ITCL_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/incrTcl/itcl/generic)
if(BRLCAD_TCL_BUILD)
  set(TCL_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
ELSE(BRLCAD_TCL_BUILD)
  get_filename_component(TCL_BIN_PREFIX ${TCL_LIBRARY} PATH)
endif(BRLCAD_TCL_BUILD)
if(BRLCAD_ENABLE_TK)
  if(BRLCAD_TK_BUILD)
    set(TK_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
    get_directory_property(TK_X11_INCLUDE_DIRS DIRECTORY tk DEFINITION TK_X11_INCLUDE_DIRS)
  ELSE(BRLCAD_TK_BUILD)
    if(TCL_TK_LIBRARY)
      get_filename_component(TK_BIN_PREFIX ${TCL_TK_LIBRARY} PATH)
    endif(TCL_TK_LIBRARY)
    if(X11_INCLUDE_DIR)
      set(TK_X11_INCLUDE_DIRS ${X11_INCLUDE_DIR})
    endif(X11_INCLUDE_DIR)
    if(X11_Xft_INCLUDE_PATH)
      set(TK_X11_INCLUDE_DIRS ${TK_X11_INCLUDE_DIRS}
	${X11_Xft_INCLUDE_PATH})
    endif(X11_Xft_INCLUDE_PATH)
    if(X11_Xrender_INCLUDE_PATH)
      set(TK_X11_INCLUDE_DIRS ${TK_X11_INCLUDE_DIRS}
	${X11_Xrender_INCLUDE_PATH})
    endif(X11_Xrender_INCLUDE_PATH)
    if(X11_Xscreensaver_INCLUDE_PATH)
      set(TK_X11_INCLUDE_DIRS ${TK_X11_INCLUDE_DIRS}
	${X11_Xscreensaver_INCLUDE_PATH})
    endif(X11_Xscreensaver_INCLUDE_PATH)
  endif(BRLCAD_TK_BUILD)
endif(BRLCAD_ENABLE_TK)


# First up, look for IncrTcl's Itcl.
set(itcl_ALIASES ENABLE_ITCL)
set(itcl_DESCRIPTION "
Option for enabling and disabling compilation of the IncrTcl package
for Tcl objects provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_ITCL is set to BUNDLED, local copy is built even if
a system version is present.
")
THIRD_PARTY_TCL_PACKAGE(Itcl incrTcl/itcl "${TCL_TCLSH_EXECUTABLE}" "tcl" "BRLCAD_LEVEL2" "itcl" itcl_ALIASES itcl_DESCRIPTION)
if(BRLCAD_ITCL_BUILD)
  set(ITCL_LIBRARY itcl CACHE STRING "ITCL_LIBRARY" FORCE)
  set(ITCL_STUB_LIBRARY itclstub CACHE STRING "ITCL_STUB_LIBRARY" FORCE)
  get_directory_property(ITCL_INCLUDE_DIRS DIRECTORY incrTcl/itcl DEFINITION ITCL_INCLUDE_DIRS)
  set(ITCL_INCLUDE_DIRS "${ITCL_INCLUDE_DIRS}" CACHE STRING "Itcl include paths" FORCE)
  set(ITCL_VERSION "3.4" CACHE STRING "ITCL_VERSION" FORCE)
  set(ITCL_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/incrTcl/itcl/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/itcl3.4)
  SetTargetFolder(itcl "Third Party Libraries")
  SetTargetFolder(itclstub "Third Party Libraries")
ELSE(BRLCAD_ITCL_BUILD)
  # We have Itcl package AND Itcl library - we're good.
  set(ITCL_VERSION "${ITCL_PACKAGE_VERSION}" CACHE STRING "ITCL_VERSION" FORCE)
  set(ITCL_LIBRARY ${ITCL_LIBRARY} CACHE STRING "ITCL_LIBRARY" FORCE)
  if(ITCL_LIBRARY)
    get_filename_component(ITCL_BIN_PREFIX ${ITCL_LIBRARY} PATH)
  endif(ITCL_LIBRARY)
endif(BRLCAD_ITCL_BUILD)
CONFIG_H_APPEND(BRLCAD "#cmakedefine ITCL_VERSION	\"${ITCL_VERSION}\"\n")
mark_as_advanced(ITCL_LIBRARY)
mark_as_advanced(ITCL_STUB_LIBRARY)
mark_as_advanced(ITCL_INCLUDE_DIRS)
mark_as_advanced(ITCL_VERSION)

# Look for IncrTcl's Itk.
set(itk_ALIASES ENABLE_ITK)
set(itk_DESCRIPTION "
Option for enabling and disabling compilation of the IncrTcl itk
package for Tk objects provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_ITK is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Itk incrTcl/itk "${TCL_WISH_EXECUTABLE}" "tcl;itcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "itk" itk_ALIASES itk_DESCRIPTION)
if(BRLCAD_ITK_BUILD)
  SetTargetFolder(itk "Third Party Libraries")
  SetTargetFolder(itkstub "Third Party Libraries")
  # does not handle C library settings.
  set(ITK_LIBRARY itk CACHE STRING "ITK_LIBRARY" FORCE)
  set(ITK_VERSION "3.3" CACHE STRING "ITK_VERSION" FORCE)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/incrTcl/itk/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/itk3.4)
ELSE(BRLCAD_ITK_BUILD)
  # We have Itcl/Itk packages AND Itcl/Itk libraries - we're good.
  set(ITK_VERSION "${ITCL_VERSION}" CACHE STRING "ITK_VERSION" FORCE)
  set(ITK_LIBRARY ${ITK_LIBRARY} CACHE STRING "ITK_LIBRARY" FORCE)
  if(ITK_LIBRARY)
    get_filename_component(ITK_BIN_PREFIX ${ITK_LIBRARY} PATH)
  endif(ITK_LIBRARY)
endif(BRLCAD_ITK_BUILD)
mark_as_advanced(ITK_VERSION)
mark_as_advanced(ITK_LIBRARY)

set(iwidgets_ALIASES ENABLE_IWIDGETS)
set(iwidgets_DESCRIPTION "
Option for enabling and disabling compilation of the IWidgets Tk
widget package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_IWIDGETS is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Iwidgets iwidgets "${TCL_WISH_EXECUTABLE}" "tcl;tk;itcl;itk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" iwidgets_ALIASES iwidgets_DESCRIPTION)
if(BRLCAD_IWIDGETS_BUILD)
  set(IWIDGETS_VERSION "4.0.1" CACHE STRING "IWIDGETS_VERSION" FORCE)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/iwidgets/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/Iwidgets4.0.1)
ELSE(BRLCAD_IWIDGETS_BUILD)
  set(IWIDGETS_VERSION "${IWIDGETS_PACKAGE_VERSION}" CACHE STRING "IWIDGETS_VERSION" FORCE)
endif(BRLCAD_IWIDGETS_BUILD)
CONFIG_H_APPEND(BRLCAD "#define IWIDGETS_VERSION \"${IWIDGETS_VERSION}\"\n")
mark_as_advanced(IWIDGETS_VERSION)

set(tkhtml_ALIASES ENABLE_TKHTML)
set(tkhtml_DESCRIPTION "
Option for enabling and disabling compilation of the Tkhtml HTML
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKHTML is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Tkhtml tkhtml "${TCL_WISH_EXECUTABLE}" "tcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tkhtml_ALIASES tkhtml_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tkhtml/pkgIndex.tcl)
DISTCLEAN(${CMAKE_BINARY_DIR}/lib/Tkhtml3.0)
SetTargetFolder(Tkhtml "Third Party Libraries")
SetTargetFolder(tkhtml_n_gen "Compilation Utilities")

set(tkpng_ALIASES ENABLE_TKPNG)
set(tkpng_DESCRIPTION "
Option for enabling and disabling compilation of the tkpng PNG image
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKPNG is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(tkpng tkpng "${TCL_WISH_EXECUTABLE}" "tcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tkpng_ALIASES tkpng_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tkpng/pkgIndex.tcl)
DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tkpng0.8)
SetTargetFolder(tkpng "Third Party Libraries")

set(tktable_ALIASES ENABLE_TKTABLE)
set(tktable_DESCRIPTION "
Option for enabling and disabling compilation of the Tktable graphical
table widget package provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TKTABLE is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Tktable tktable "${TCL_WISH_EXECUTABLE}" "tcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tktable_ALIASES tktable_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tktable/pkgIndex.tcl)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tktable/tktable_cfg.h)
DISTCLEAN(${CMAKE_BINARY_DIR}/lib/Tktable2.10)
SetTargetFolder(Tktable "Third Party Libraries")
SetTargetFolder(tktable_header_gen "Compilation Utilities")

#set(tktreectrl_ALIASES ENABLE_TKTREECTRL)
#set(tktreectrl_DESCRIPTION "
#Option for enabling and disabling compilation of the TkTreeCtrl graphical
#table widget package provided with BRL-CAD's source distribution.
#Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
#BUNDLED and testing first for a system version if BRLCAD_TCL is set to
#AUTO or SYSTEM.  If BRLCAD_TKTREECTRL is set to BUNDLED, local copy is built
#even if a system version is present.  This package will be disabled if
#BRLCAD_ENABLE_TK is OFF.
#")
#THIRD_PARTY_TCL_PACKAGE(tktreectrl tktreectrl "${TCL_WISH_EXECUTABLE}" "tcl;tk"
#  "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tktreectrl_ALIASES tktreectrl_DESCRIPTION)
#DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tktreectrl/pkgIndex.tcl)
#DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tktreectrl/tktreectrl_cfg.h)
#DISTCLEAN(${CMAKE_BINARY_DIR}/lib/TkTreeCtrl2.4)

# OpenNURBS Library
set(opennurbs_ALIASES ENABLE_OPENNURBS)
set(opennurbs_DESCRIPTION "
Option for enabling and disabling compilation of the openNURBS library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(openNURBS OPENNURBS openNURBS opennurbs_DESCRIPTION ALIASES
  ${opennurbs_ALIASES} FLAGS NOSYS)
SetTargetFolder(openNURBS "Third Party Libraries")
SetTargetFolder(openNURBS-static "Third Party Libraries")

# STEPcode 
# Need Lemon/Perplex to build STEP - conditionalize

# Set some options for the SCL build
set(SC_PYTHON_GENERATOR OFF)
set(SC_ENABLE_TESTING OFF)
set(SC_ENABLE_COVERAGE OFF)
set(SC_IS_SUBBUILD ON)
set(SC_BUILD_TYPE "${CMAKE_BUILD_TYPE}")
set(INCLUDE_INSTALL_DIR ${INCLUDE_DIR})
set(BIN_INSTALL_DIR ${BIN_DIR})
set(LIB_INSTALL_DIR ${LIB_DIR})

set(sc_ALIASES ENABLE_SCL ENABLE_STEP ENABLE_STEP_CLASS_LIBRARIES)
set(sc_DESCRIPTION "
Option for enabling and disabling compilation of the NIST Step Class
Libraries provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
set(IS_SUBBUILD_STASH ${IS_SUBBUILD})
set(IS_SUBBUILD ON)
set(SC_BUILD_SCHEMAS "" CACHE STRING "Disable schema builds for BRL-CAD" FORCE)
# Lots of "libraries" associated with stepcode - use "stepcode" as the
# stand-in for the build target var.
THIRD_PARTY(stepcode SC stepcode sc_DESCRIPTION REQUIRED_VARS LEMON_EXECUTABLE
  PERPLEX_EXECUTABLE BRLCAD_LEVEL3 ALIASES ${sc_ALIASES} RESET_VARS
  EXP2CXX_EXEC EXP2CXX_EXECUTABLE_TARGET FLAGS NOSYS)
if(BRLCAD_SC_BUILD)
  set(EXP2CXX_EXEC exp2cxx CACHE STRING "Express to C++ executable" FORCE)
  set(EXP2CXX_EXECUTABLE_TARGET exp2cxx CACHE STRING "Express to C++ executable target" FORCE)
  mark_as_advanced(EXP2CXX_EXEC)
  mark_as_advanced(EXP2CXX_EXECUTABLE_TARGET)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/stepcode/include/sc_cf.h.in)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/stepcode/sc_version_string.h.txt)
endif(BRLCAD_SC_BUILD)
set(IS_SUBBUILD ${IS_SUBBUILD_STASH})
mark_as_advanced(SC_BUILD_TYPE)
mark_as_advanced(SC_BUILD_SCHEMAS)
mark_as_advanced(SC_GENERATE_LEXER_PARSER)
mark_as_advanced(SC_BUILD_SHARED_LIBS)
mark_as_advanced(SC_BUILD_STATIC_LIBS)
mark_as_advanced(SC_CPP_GENERATOR)
mark_as_advanced(SC_ENABLE_COVERAGE)
mark_as_advanced(SC_ENABLE_TESTING)
mark_as_advanced(SC_PYTHON_GENERATOR)
mark_as_advanced(SC_MEMMGR_ENABLE_CHECKS)
mark_as_advanced(SC_SDAI_ADDITIONAL_EXES_SRCS)
mark_as_advanced(SC_TRACE_FPRINTF)
SetTargetFolder(exp2cxx "Third Party Executables")
SetTargetFolder(print_attrs "Compilation Utilities")
SetTargetFolder(print_schemas "Compilation Utilities")
SetTargetFolder(exppp "Third Party Executables")
SetTargetFolder(libexppp "Third Party Libraries")
SetTargetFolder(check-express "Third Party Executables")
SetTargetFolder(express "Third Party Libraries")
SetTargetFolder(express_sync_generated_files "Third Party Executables")
SetTargetFolder(express_verify "Third Party Libraries")
SetTargetFolder(base "Third Party Libraries")
SetTargetFolder(stepcore "Third Party Libraries")
SetTargetFolder(stepdai "Third Party Libraries")
SetTargetFolder(stepeditor "Third Party Libraries")
SetTargetFolder(steputils "Third Party Libraries")
SetTargetFolder(version_string "Compilation Utilities")

# Clipper polygon clipping library - for now, we're going to use our copy
if(BRLCAD_LEVEL2)
  add_subdirectory(clipper)
  include(${CMAKE_CURRENT_SOURCE_DIR}/clipper.dist)
  CMAKEFILES_IN_DIR(clipper_ignore_files clipper)
  DISTCLEAN(${CMAKE_CURRENT_SOURCE_DIR}/clipper/Makefile)
  set(CLIPPER_LIBRARY "clipper" CACHE STRING "Clipper library" FORCE)
  set(CLIPPER_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/clipper" CACHE STRING "Directory containing clipper header" FORCE)
  mark_as_advanced(CLIPPER_LIBRARY)
  mark_as_advanced(CLIPPER_INCLUDE_DIR)
  SetTargetFolder(clipper "Third Party Libraries")
else(BRLCAD_LEVEL2)
  CMAKEFILES(clipper)
endif(BRLCAD_LEVEL2)

# VDSlib - A View-Dependent Simplification and Rendering Library For
# the moment, this is marked NOSYS - it's possible that some Debian
# systems would have 0.9 of vdslib installed, but it's unmaintained
# and we're likely to be making changes.  If our own copy of VDSlib
# ever spins back off into its own project, revisit the NOSYS

set(libvds_ALIASES ENABLE_VDS)
set(libvds_DESCRIPTION "
Option for enabling and disabling compilation of the libvds triangle
simplification library provided with BRL-CAD's source code.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.
")
THIRD_PARTY(libvds VDS libvds libvds_DESCRIPTION ALIASES ${libvds_ALIASES} FLAGS NOSYS)
set(LIBVDS_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/libvds" CACHE STRING "Directory containing libvds headers." FORCE)
SetTargetFolder(libvds "Third Party Libraries")
SetTargetFolder(libvds-static "Third Party Libraries")
SetTargetFolder(stdvds "Third Party Libraries")
SetTargetFolder(stdvds-static "Third Party Libraries")

# gdiam

set(libgdiam_ALIASES ENABLE_GDIAM)
set(libgdiam_DESCRIPTION "
Option for enabling and disabling compilation of the libgdiam approximate
tight bounding box library provided with BRL-CAD's source code.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.
")
THIRD_PARTY(libgdiam GDIAM libgdiam libgdiam_DESCRIPTION ALIASES ${libgdiam_ALIASES}
  FLAGS NOSYS)
set(LIBGDIAM_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/libgdiam" CACHE STRING "Directory containing libgdiam headers." FORCE)
SetTargetFolder(libgdiam "Third Party Libraries")
SetTargetFolder(libgdiam-static "Third Party Libraries")

# Bullet is not yet integrated as a src/other subbuild, but there is
# code that will make use of it if it is available.  If that code
# becomes sufficiently useful, Bullet will be integrated.  In the
# meantime, locate the find logic for that package here.

# Bullet physics library
if(BRLCAD_LEVEL2)
  if (BRLCAD_ENABLE_BULLET)
    find_package(Bullet)
    if(BULLET_FOUND)
      CONFIG_H_APPEND(BRLCAD "#define HAVE_BULLET 1\n")
    endif(BULLET_FOUND)
    # Let the rest of the package know the results
    set(BULLET_LIBRARIES "${BULLET_LIBRARIES}" CACHE STRING "Bullet libs" FORCE) 
    set(BULLET_FOUND "${BULLET_FOUND}" CACHE BOOL "Bullet status" FORCE) 
    mark_as_advanced(BULLET_INCLUDE_DIR)
    mark_as_advanced(BULLET_FOUND)
    mark_as_advanced(BULLET_LIBRARIES)
  endif (BRLCAD_ENABLE_BULLET)
endif(BRLCAD_LEVEL2)

# Adaptagrams is not yet integrated as a src/other subbuild, but there
# is code that will make use of it if it is available.  If that code
# becomes sufficiently useful, Adaptagrams will be integrated.  In the
# meantime, locate the find logic for that package here.

# Adaptagrams library
if(BRLCAD_LEVEL2)
  find_package(ADAPTAGRAMS)
  if(ADAPTAGRAMS_FOUND)
    CONFIG_H_APPEND(BRLCAD "#define HAVE_ADAPTAGRAMS 1\n")
  endif(ADAPTAGRAMS_FOUND)
  set(ADAPTAGRAMS_LIBRARIES "${ADAPTAGRAMS_LIBRARIES}" CACHE STRING "Adaptagrams libs" FORCE) 
  set(ADAPTAGRAMS_FOUND "${ADAPTAGRAMS_FOUND}" CACHE BOOL "Adaptagrams status" FORCE) 
  mark_as_advanced(ADAPTAGRAMS_FOUND)
  mark_as_advanced(ADAPTAGRAMS_LIBRARIES)
endif(BRLCAD_LEVEL2)

# Poly2Tri CDT library
add_subdirectory(poly2tri)
include(${CMAKE_CURRENT_SOURCE_DIR}/poly2tri.dist)
CMAKEFILES_IN_DIR(poly2tri_ignore_files poly2tri)
DISTCLEAN(${CMAKE_CURRENT_SOURCE_DIR}/poly2tri/Makefile)
set(P2T_LIBRARY "p2t" CACHE STRING "Poly2Tri library" FORCE)
set(P2T_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/poly2tri" CACHE STRING "Directory containing poly2tri header" FORCE)
SetTargetFolder(p2t "Third Party Libraries")
SetTargetFolder(p2t_static "Third Party Libraries")
mark_as_advanced(P2T_LIBRARY)
mark_as_advanced(P2T_INCLUDE_DIR)
mark_as_advanced(P2T_SHARED)
mark_as_advanced(P2T_STATIC)
mark_as_advanced(P2T_TESTS)

# Eigen is used for advanced linear algebra functionality It consists
# entirely of headers and does not need to be installed.
CMAKEFILES(Eigen)

# TCLAP is used for option parsing - consists entirely of headers
# and does not need to be installed, but does need to generate a
# config file
add_subdirectory(tclap)
CMAKEFILES(tclap)

if(BRLCAD_ENABLE_OSL)
  add_subdirectory(osl)
endif(BRLCAD_ENABLE_OSL)

CMAKEFILES(README)

# Local Variables:
# tab-width: 8
# mode: cmake
# indent-tabs-mode: t
# End:
# ex: shiftwidth=2 tabstop=8

blob
data 19991
/*                          P I P E . C
 * BRL-CAD
 *
 * Copyright (c) 2004-2014 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file proc-db/pipe.c
 *
 * Generate piping (fuel, hydraulic lines, etc.) in MGED format from
 * input (points in space defining the routing).  Makes both tubing
 * regions and fluid regions or solid cable.  Automatically generates
 * elbow regions (and fluid in the elbows) when the piping changes
 * direction.
 *
 */

#include "common.h"

#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "bio.h"

#include "bu/getopt.h"
#include "vmath.h"
#include "raytrace.h"
#include "wdb.h"


#define NAMESIZE 80		/* in v5, they can be longer than 16 */

#ifdef VERSION
#  undef VERSION
#endif
#define VERSION 3
#define RELEASE 1

#define REGION 1

#define MINR 2.		/* minimum bending radius is MINR*tubingradius */
/* note, the bending radius is measured to the */
/* edge of the tube, NOT the centerline of tube */

struct points
{
    point_t p;		/* data point */
    point_t p1;		/* adjusted point torward previous point */
    point_t p2;		/* adjusted point torward next point */
    point_t center;	/* center point for tori elbows */
    vect_t nprev;	/* unit vector towards previous point */
    vect_t nnext;	/* unit vector towards next point */
    fastf_t alpha;	/* angle between "nprev" and "nnext" */
    vect_t norm;	/* unit vector normal to "nprev" and "nnext" */
    vect_t nmitre;	/* unit vector along mitre joint */
    vect_t mnorm;	/* unit vector normal to mitre joint and "norm" */
    char tube[NAMESIZE], tubflu[NAMESIZE];			/* solid names */
    char elbow[NAMESIZE], elbflu[NAMESIZE], cut[NAMESIZE];	/* solid names */
    char tube_r[NAMESIZE], tubflu_r[NAMESIZE];		/* region names */
    char elbow_r[NAMESIZE], elbflu_r[NAMESIZE];		/* region names */
    struct points *next, *prev;
};


double radius, wall, pi, unit_conversion_factor;
struct points *root;
char name[16];
float delta=10.0;		/* 10mm excess in ARB sizing for cutting tubes */
mat_t identity;

int torus=0, sphere=0, mitre=0, nothing=0, cable=0;

/* formats for solid and region names */
char *tor_out="%02d-out.tor", *tor_in="%02d-in.tor";
char *haf="%02d.haf";
char *sph_out="%02d-out.sph", *sph_in="%02d-in.sph";
char *rcc_out="%02d-out.rcc", *rcc_in="%02d-in.rcc";
char *tub_reg="%02d.tube", *tub_flu="%02d.tubflu";
char *elb_reg="%02d.elbow", *elb_flu="%02d.elbflu";
char *arb="%02d.arb";

void Usage(void);

struct rt_wdb *fdout;	/* file for libwdb writes */

void
Make_name(char *ptr, const char *form, const char *base, int number)
{

    char scrat[NAMESIZE];
    size_t len;

    bu_strlcpy(ptr, base, NAMESIZE);
    snprintf(scrat, NAMESIZE, form, number);

    len = strlen(ptr) + strlen(scrat);
    if (len > (NAMESIZE-1))
	ptr[ (NAMESIZE-1) - strlen(scrat) ] = '\0';

    bu_strlcat(ptr, scrat, NAMESIZE);
}


void
Readpoints(void)
{
    struct points *ptr, *prev;
    double x, y, z;

    ptr = root;
    prev = NULL;


    printf("X Y Z (^D for end): ");
    while (scanf("%lf%lf%lf", &x, &y, &z) ==  3) {
	if (ptr == NULL) {
	    BU_ALLOC(ptr, struct points);
	    root = ptr;
	} else {
	    BU_ALLOC(ptr->next, struct points);
	    ptr = ptr->next;
	}
	ptr->next = NULL;
	ptr->prev = prev;
	prev = ptr;
	VSET(ptr->p, unit_conversion_factor*x, unit_conversion_factor*y, unit_conversion_factor*z);
	ptr->tube[0] = '\0';
	ptr->tubflu[0] = '\0';
	ptr->elbow[0] = '\0';
	ptr->elbflu[0] = '\0';
	ptr->cut[0] = '\0';
	printf("X Y Z (^D for end): ");
    }
}


void
Names(void)
{
    struct points *ptr;
    char *inform=NULL, *outform=NULL, *cutform=NULL;
    int nummer=0;


    if (torus) {
	outform = tor_out;
	inform = tor_in;
	cutform = arb;
    } else if (sphere) {
	outform = sph_out;
	inform = sph_in;
    } else if (mitre)
	cutform = haf;

    ptr = root;
    while (ptr->next != NULL) {
	nummer++;

	/* Outer RCC */
	Make_name(ptr->tube, rcc_out, name, nummer);

	if (!cable) /* Inner RCC */
	    Make_name(ptr->tubflu, rcc_in, name, nummer);

	if ((sphere || torus) && ptr != root) {
	    /* Outer elbow */
	    Make_name(ptr->elbow, outform, name, nummer);

	    if (!cable) /* Inner elbow */
		Make_name(ptr->elbflu, inform, name, nummer);
	}
	if ((torus || mitre) && !sphere)	/* Make cutting solid name */
	    Make_name(ptr->cut, cutform, name, nummer);

	/* Make region names */
	Make_name(ptr->tube_r, tub_reg, name, nummer); /* tube region */

	if ((torus || sphere) && ptr != root)	/* Make elbow region name */
	    Make_name(ptr->elbow_r, elb_reg, name, nummer);

	/* Make fluid region names */
	if (!cable) {
	    Make_name(ptr->tubflu_r, tub_flu, name, nummer);

	    if ((torus || sphere) && ptr != root)	/* Make elbow fluid region names */
		Make_name(ptr->elbflu_r, elb_flu, name, nummer);
	}

	ptr = ptr->next;
    }
    ptr->tube[0] = '\0';
    ptr->tubflu[0] = '\0';
    ptr->elbow[0] = '\0';
    ptr->elbflu[0] = '\0';
    ptr->cut[0] = '\0';
    ptr->tube_r[0] = '\0';
    ptr->tubflu_r[0] = '\0';
    ptr->elbow_r[0] = '\0';
    ptr->elbflu_r[0] = '\0';
}


void
Normals(void)
{
    struct points *ptr;


    if (root == NULL)
	return;

    ptr = root->next;
    if (ptr == NULL)
	return;

    VSUB2(root->nnext, ptr->p, root->p);
    VUNITIZE(root->nnext);

    while (ptr->next != NULL) {
	VREVERSE(ptr->nprev, ptr->prev->nnext);
	VSUB2(ptr->nnext, ptr->next->p, ptr->p);
	VUNITIZE(ptr->nnext);
	VCROSS(ptr->norm, ptr->nprev, ptr->nnext);
	VUNITIZE(ptr->norm);
	VADD2(ptr->nmitre, ptr->nprev, ptr->nnext);
	VUNITIZE(ptr->nmitre);
	VCROSS(ptr->mnorm, ptr->norm, ptr->nmitre);
	VUNITIZE(ptr->mnorm);
	if (VDOT(ptr->mnorm, ptr->nnext) > 0.0)
	    VREVERSE(ptr->mnorm, ptr->mnorm);
	ptr->alpha = acos(VDOT(ptr->nnext, ptr->nprev));
	ptr = ptr->next;
    }
}


void
Adjust(void)
{
    fastf_t beta, d, len;
    struct points *ptr;

    if (root == NULL)
	return;

    VMOVE(root->p1, root->p);
    VMOVE(root->p2, root->p);

    ptr = root->next;
    if (ptr == NULL)
	return;

    if (ptr->next == NULL) {
	VMOVE(ptr->p1, ptr->p);
	VMOVE(ptr->p2, ptr->p);
	return;
    }


    while (ptr->next != NULL) {
	if (!torus && !mitre) {
	    VMOVE(ptr->p1, ptr->p);
	    VMOVE(ptr->p2, ptr->p);
	} else if (torus) {
	    /* beta=.5*(pi-ptr->alpha);
	       d=(MINR+1.0)*radius*tan(beta); */ /* dist from new endpts to p2 */

	    beta = 0.5 * ptr->alpha;
	    d = (MINR + 1.0) * radius / tan(beta);
	    VJOIN1(ptr->p1, ptr->p, d, ptr->nprev);
	    VJOIN1(ptr->p2, ptr->p, d, ptr->nnext);
	    d = sqrt(d*d + (MINR+1.0)*(MINR+1.)*radius*radius);
	    VJOIN1(ptr->center, ptr->p, d, ptr->nmitre);
	} else if (mitre) {
	    len = radius/tan(ptr->alpha/2.0);
	    VJOIN1(ptr->p1, ptr->p, -len, ptr->nprev);
	    VJOIN1(ptr->p2, ptr->p, -len, ptr->nnext);
	}
	ptr = ptr->next;
    }
    VMOVE(ptr->p1, ptr->p);
    VMOVE(ptr->p2, ptr->p);
}


void
Pipes(void)
{
    vect_t ht;
    struct points *ptr;
    fastf_t len;
    int comblen;
    struct wmember head;

    BU_LIST_INIT(&head.l);

    ptr = root;
    if (ptr == NULL)
	return;

    while (ptr->next != NULL) {

	/* Make the basic pipe solids */

	VSUB2(ht, ptr->next->p1, ptr->p2);

	mk_rcc(fdout, ptr->tube, ptr->p2, ht, radius);	/* make a solid record */

	if (!cable) /* make inside solid */
	    mk_rcc(fdout, ptr->tubflu, ptr->p2, ht, radius-wall);

	if (torus) {
	    /* Make tubing region */
	    mk_addmember(ptr->tube, &head.l, NULL, WMOP_UNION);	/* make 'u' member record */

	    if (!cable) {
		/* Subtract inside solid */
		mk_addmember(ptr->tubflu, &head.l, NULL, WMOP_SUBTRACT);	/* make '-' member record */

		/* Make fluid region */
		mk_comb1(fdout, ptr->tubflu_r, ptr->tubflu, 1);
	    }
	    mk_lfcomb(fdout, ptr->tube_r, &head, 1);
	} else if (mitre) {
	    if (ptr->prev != NULL) {
		len = VDOT(ptr->p, ptr->mnorm);
		mk_half(fdout, ptr->cut, ptr->mnorm, len);
	    }

	    comblen = 4 - cable;
	    if (ptr->next->next == NULL)
		comblen--;
	    if (ptr->prev == NULL)
		comblen--;

	    mk_addmember(ptr->tube, &head.l, NULL, WMOP_UNION);	/* make 'u' member record */

	    if (!cable)
		mk_addmember(ptr->tubflu, &head.l, NULL, WMOP_SUBTRACT);	/* make '-' member record */

	    if (ptr->next->next != NULL)
		mk_addmember(ptr->next->cut, &head.l, NULL, WMOP_SUBTRACT);	/* make '+' member record */

	    if (ptr->prev != NULL)
		mk_addmember(ptr->cut, &head.l, NULL, WMOP_INTERSECT);	/* subtract HAF */

	    mk_lfcomb(fdout, ptr->tube_r, &head, 1);

	    if (!cable) {
		/* Make fluid region */

		comblen = 3;
		if (ptr->next->next == NULL)
		    comblen--;
		if (ptr->prev == NULL)
		    comblen--;

		mk_addmember(ptr->tubflu, &head.l, NULL, WMOP_UNION);	/* make 'u' member record */

		if (ptr->next->next != NULL)
		    mk_addmember(ptr->next->cut, &head.l, NULL, WMOP_SUBTRACT);	/* make '+' member record */

		if (ptr->prev != NULL)
		    mk_addmember(ptr->cut, &head.l, NULL, WMOP_INTERSECT);	/* subtract */

		mk_lfcomb(fdout, ptr->tubflu_r, &head, 1);	/* make REGION comb record */
	    }
	} else if (sphere) {

	    /* make REGION comb record for tube */
	    comblen = 2;
	    if (cable)
		comblen--;
	    if (ptr->next->tube[0] != '\0')
		comblen++;
	    if (!cable && ptr->prev != NULL)
		comblen++;

	    /* make 'u' member record */

	    mk_addmember(ptr->tube, &head.l, NULL, WMOP_UNION);

	    /* make '-' member record */
	    if (!cable)
		mk_addmember(ptr->tubflu, &head.l, NULL, WMOP_SUBTRACT);

	    if (ptr->next->tube[0] != '\0')	/* subtract outside of next tube */
		mk_addmember(ptr->next->tube, &head.l, NULL, WMOP_SUBTRACT);
	    if (!cable && ptr->prev != NULL) /* subtract inside of previous tube */
		mk_addmember(ptr->prev->tubflu, &head.l, NULL, WMOP_SUBTRACT);

	    mk_lfcomb(fdout, ptr->tube_r, &head, REGION);

	    if (!cable) {
		/* make REGION for fluid */

		/* make 'u' member record */

		mk_addmember(ptr->tubflu, &head.l, NULL, WMOP_UNION);

		if (ptr->next->tubflu[0] != '\0')	/* subtract inside of next tube */
		    mk_addmember(ptr->next->tubflu, &head.l, NULL, WMOP_SUBTRACT);

		mk_lfcomb(fdout, ptr->tubflu_r, &head, REGION);
	    }
	} else if (nothing) {

	    /* make REGION comb record for tube */
	    comblen = 2;
	    if (cable)
		comblen--;
	    if (ptr->next->tube[0] != '\0')
		comblen++;
	    if (!cable && ptr->prev != NULL)
		comblen++;

	    /* make 'u' member record */

	    mk_addmember(ptr->tube, &head.l, NULL, WMOP_UNION);

	    /* make '-' member record */
	    if (!cable)
		mk_addmember(ptr->tubflu, &head.l, NULL, WMOP_SUBTRACT);

	    if (ptr->next->tube[0] != '\0')	/* subtract outside of next tube */
		mk_addmember(ptr->next->tube, &head.l, NULL, WMOP_SUBTRACT);
	    if (!cable && ptr->prev != NULL) /* subtract inside of previous tube */
		mk_addmember(ptr->prev->tubflu, &head.l, NULL, WMOP_SUBTRACT);

	    mk_lfcomb(fdout, ptr->tube_r, &head, REGION);

	    if (!cable) {
		/* make REGION for fluid */

		/* make 'u' member record */

		mk_addmember(ptr->tubflu, &head.l, NULL, WMOP_UNION);

		if (ptr->next->tubflu[0] != '\0')	/* subtract inside of next tube */
		    mk_addmember(ptr->next->tubflu, &head.l, NULL, WMOP_SUBTRACT);

		mk_lfcomb(fdout, ptr->tubflu_r, &head, REGION);
	    }
	}
	ptr = ptr->next;
    }
}


void
Elbows(void)	/* make a tubing elbow and fluid elbow */
{
    vect_t RN1, RN2;
    point_t pts[8];
    fastf_t len;
    struct points *ptr;
    struct wmember head;

    if (nothing || mitre)
	return;

    if (root == NULL)
	return;

    BU_LIST_INIT(&head.l);

    ptr = root->next;
    while (ptr->next != NULL) {

	/* Make outside elbow solid */
	if (torus)
	    mk_tor(fdout, ptr->elbow, ptr->center, ptr->norm, (MINR+1)*radius, radius);
	else if (sphere)
	    mk_sph(fdout, ptr->elbow, ptr->p, radius);

	/* Make inside elbow solid */
	if (!cable) {
	    if (torus)
		mk_tor(fdout, ptr->elbflu, ptr->center, ptr->norm, (MINR+1)*radius, radius-wall);
	    else if (sphere)
		mk_sph(fdout, ptr->elbflu, ptr->p, radius-wall);
	}

	/* Make ARB8 solid */
	if (torus) {
	    len = ((MINR+2)*radius + delta) / cos((pi-ptr->alpha)/4.0);
	    /* vector from center of torus to rcc end */
	    VSUB2(RN1, ptr->p1, ptr->center);
	    VUNITIZE(RN1);		/* unit vector */
	    /* beginning of next rcc */
	    VSUB2(RN2, ptr->p2, ptr->center);
	    VUNITIZE(RN2);		/* and unitize again */

	    /* build the eight points for the ARB8 */

	    VJOIN1(pts[0], ptr->center, radius+delta, ptr->norm);
	    VJOIN1(pts[1], pts[0], len, RN1);
	    VJOIN1(pts[2], pts[0], -len, ptr->nmitre);
	    VJOIN1(pts[3], pts[0], len, RN2);
	    VJOIN1(pts[4], ptr->center, -radius-delta, ptr->norm);
	    VJOIN1(pts[5], pts[4], len, RN1);
	    VJOIN1(pts[6], pts[4], -len, ptr->nmitre);
	    VJOIN1(pts[7], pts[4], len, RN2);

	    mk_arb8(fdout, ptr->cut, &pts[0][X]);
	}

	if (torus) {
	    mk_addmember(ptr->elbow, &head.l, NULL, WMOP_UNION);	/* make 'u' member record */
	    if (!cable)
		mk_addmember(ptr->elbflu, &head.l, NULL, WMOP_SUBTRACT);	/* make '-' member record */
	    mk_addmember(ptr->cut, &head.l, NULL, WMOP_INTERSECT);
	    mk_lfcomb(fdout, ptr->elbow_r, &head, REGION);	/* make REGION comb record */

	    if (!cable) {
		mk_addmember(ptr->elbflu, &head.l, NULL, WMOP_UNION);	/* make 'u' member record */
		mk_addmember(ptr->cut, &head.l, NULL, WMOP_INTERSECT);
		mk_lfcomb(fdout, ptr->elbflu_r, &head, REGION);		/* make REGION comb record */
	    }
	} else if (sphere) {
	    mk_addmember(ptr->elbow, &head.l, NULL, WMOP_UNION);	/* make 'u' member record */
	    if (!cable)
		mk_addmember(ptr->elbflu, &head.l, NULL, WMOP_SUBTRACT);	/* make '-' member record */
	    mk_addmember(ptr->tube, &head.l, NULL, WMOP_SUBTRACT);
	    mk_addmember(ptr->prev->tube, &head.l, NULL, WMOP_SUBTRACT);

	    mk_lfcomb(fdout, ptr->elbow_r, &head, REGION);	/* make REGION comb record */

	    if (!cable) {
		mk_addmember(ptr->elbflu, &head.l, NULL, WMOP_UNION);	/* make 'u' member record */
		mk_addmember(ptr->tube, &head.l, NULL, WMOP_SUBTRACT);
		mk_addmember(ptr->prev->tube, &head.l, NULL, WMOP_SUBTRACT);
		mk_lfcomb(fdout, ptr->elbflu_r, &head, REGION);		/* make REGION comb record */
	    }
	}
	ptr = ptr->next;
    }
}


void
Groups(void)
{
    struct points *ptr;
    char tag[NAMESIZE];
    char *pipe_group=".pipe";
    char *fluid_group=".fluid";
    int comblen=0;
    struct wmember head;

    BU_LIST_INIT(&head.l);

    ptr = root;
    if (ptr == NULL)
	return;

    while (ptr->next != NULL) {
	if (!nothing && !mitre && comblen)	/* count elbow sections (except first point) */
	    comblen++;
	comblen++;	/* count pipe sections */

	ptr = ptr->next;
    }

    if (comblen) {

	/* Make name for pipe group = "name".pipe */
	Make_name(tag, pipe_group, name, 0);

	/* Make group */
	ptr = root;
	while (ptr->next != NULL) {
	    mk_addmember(ptr->tube_r, &head.l, NULL, WMOP_UNION);	/* tube regions */

	    if (!nothing && !mitre && ptr != root)
		mk_addmember(ptr->elbow_r, &head.l, NULL, WMOP_UNION);	/* elbows */

	    ptr = ptr->next;
	}
	mk_lfcomb(fdout, tag, &head, 0);

	if (!cable) {
	    /* Make name for fluid group = "name".fluid */
	    Make_name(tag, fluid_group, name, 0);

	    /* Make group */
	    ptr = root;
	    while (ptr->next != NULL) {
		mk_addmember(ptr->tubflu_r, &head.l, NULL, WMOP_UNION);	/* fluid in tubes */

		if (!nothing && !mitre && ptr != root)
		    mk_addmember(ptr->elbflu_r, &head.l, NULL, WMOP_UNION); /* fluid in elbows */

		ptr = ptr->next;
	    }
	    mk_lfcomb(fdout, tag, &head, 0);
	}
    }
}


int
main(int argc, char **argv)
{
    int done = 0;
    char units[16], fname[80];
    int optc;

    while ((optc = bu_getopt(argc, argv, "tsmnch?")) != -1) {
	/* Set joint type and cable option */
	switch (optc) {
	    case 't':
		torus = 1;
		break;
	    case 's':
		sphere = 1;
		break;
	    case 'm':
		mitre = 1;
		break;
	    case 'n':
		nothing = 1;
		break;
	    case 'c':
		cable = 1;
		break;
	    default:
		Usage();
		return 1;

	}
    }

    /* Too many joint options */
    if ((torus + sphere + mitre + nothing) > 1) {
	Usage();
	fprintf(stderr, "Options t, s, m, n are mutually exclusive\n");
	return 1;
    }

    if ((argc - bu_optind) != 2) {
	Usage();
	return 1;
    }

    if ((torus + sphere + mitre + nothing) == 0)
	torus = 1;		/* default */

    bu_strlcpy(name, argv[bu_optind++], sizeof(name)); /* Base name for objects */

    fdout = wdb_fopen(argv[bu_optind]);
    if (fdout == NULL) {
	fprintf(stderr, "Cannot open %s\n", argv[bu_optind]);
	perror("Pipe");
	Usage();
	return 1;
    }

    MAT_IDN(identity);	/* Identity matrix for all objects */
    pi = M_PI;	/* PI */

    printf("FLUID & PIPING V%d.%d 10 Mar 89\n\n", VERSION, RELEASE);
    printf("Append %s to your target description using 'concat' in mged.\n", argv[bu_optind]);

#define MM_TO_CM 10.0
#define MM_TO_M  1000.0
#define MM_TO_IN 25.4
#define MM_TO_FT 304.8

    unit_conversion_factor = 0.0;
    while (ZERO(unit_conversion_factor)) {
	printf("UNITS? (ft, in, m, cm, default is millimeters) ");
	bu_fgets(units, sizeof(units), stdin);
	switch (units[0]) {
	    case '\0':
	    case '\n':
	    case '\r':
		unit_conversion_factor=1.0;
		break;

	    case 'f':
		unit_conversion_factor=MM_TO_FT;
		break;

	    case 'i':
		unit_conversion_factor=MM_TO_IN;
		break;

	    case 'm':
		if (units[1] != 'm')
		    unit_conversion_factor=MM_TO_M;
		else
		    unit_conversion_factor=1.0;
		break;

	    case 'c':
		unit_conversion_factor=MM_TO_CM;
		break;

	    default:
		printf("\n%s is not a legal choice for units\n", units);
		printf("Try again\n");
		break;
	}
    }

    done = 0;
    while (!done) {
	if (!cable) {
	    printf("radius and wall thickness: ");
	    if (scanf("%lf %lf", &radius, &wall) == EOF)
		return 1;
	    if (radius > wall)
		done = 1;
	    else {
		printf(" *** bad input!\n\n");
		printf("radius must be larger than wall thickness\n");
		printf("Try again\n");
	    }
	} else {
	    printf("radius: ");
	    if (scanf("%lf", &radius) == EOF)
		return 1;
	    done=1;
	}
    }
    if (radius < SMALL_FASTF)
	radius = SMALL_FASTF;

    radius=unit_conversion_factor*radius;
    wall=unit_conversion_factor*wall;

    Readpoints();	/* Read data points */

    Names();	/* Construct names for all solids */

    Normals();	/* Calculate normals and other vectors */

    Adjust();       /* Adjust points to allow for elbows */

/* Generate Title */

    bu_strlcpy(fname, name, sizeof(fname));

    if (!cable)
	bu_strlcat(fname, " pipe and fluid", sizeof(fname));
    else
	bu_strlcat(fname, " cable", sizeof(fname));

/* Create ident record */

    mk_id(fdout, fname);

    Pipes();	/* Construct the piping */

    Elbows();	/* Construct the elbow sections */

    Groups();	/* Make some groups */

    return 0;
}


void
Usage(void)
{
    fprintf(stderr, "Usage: pipe [-tsmnc] tag filename\n");
    fprintf(stderr, "   where 'tag' is the name of the piping run and is used by mged in object names;\n");
    fprintf(stderr, "   and 'filename' is the .g file (e.g., fuel.g)\n");
    fprintf(stderr, "   -t -> use tori at the bends (default)\n");
    fprintf(stderr, "   -s -> use spheres at the corners\n");
    fprintf(stderr, "   -m -> mitre the corners\n");
    fprintf(stderr, "   -n -> nothing at the corners\n");
    fprintf(stderr, "   -c -> cable (no fluid)\n");
}


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 10
/bin
/lib
