blob
data 10442
#******************************************************************************
#
#                           BRL-CAD NIST Density Table v 1.0
#
#     *** IMPORTANT: This file may change over time and should not be
#     *** relied upon for production analysis work.
#

#     Based on data present in various databases available at
#     http://www.nist.gov - each subsection below cites the particular
#     database from which information is drawn.
#
#     The numbering provided for each entry is somewhat arbitrary in
#     that the number does not typically contain any information about
#     the particular material in question, but each "grouping" of
#     materials will share a common two digit prefix.  For example,
#     all pure elements will share the prefix "11".
#
#     All densities are in units of g/cm^3.
#
#******************************************************************************
#
# To use the file with rtweight, copy the file to your working directory:
#   cp NIST_DENSITIES .density
#
# To use the file with gqa, import the file data as a binary object:
#   mged file.g bo -i u c _DENSITIES NIST_DENSITIES
#
#******************************************************************************


#			  Densities of Elementally Pure Materials
#
# Drawn from the FCOMP database file included with ESTAR, available
# from this web address:
#
# http://physics.nist.gov/PhysRefData/Star/Text/contents.html
#
# Numbering Conventions: All pure elements will have a prefix of "11".
# The last three digits will be the atomic number of the element in
# question.  The third digit will be the beginning of a counter - the
# first value will always be one, and any subsequent entries for the
# same element will be counted up.
#
# Note: For BRL-CAD use, the first digit (1) has been dropped to allow
# the resulting material code to fit in the MAXMTLS array (32768).

11001	0.000083748	Hydrogen
11002	0.000166322	Helium
11003	0.534000	Lithium
11004	1.84800		Beryllium
11005	2.37000		Boron
11006	2.00000		Carbon, Amorphous
12006	1.70000		Carbon, Graphite
11007	0.00116528	Nitrogen
11008	0.00133151	Oxygen
11009	0.00158029	Fluorine
11010	0.000838505	Neon
11011	0.97100		Sodium
11012	1.74000		Magnesium
11013	2.69890		Aluminum
11014	2.33000		Silicon
11015	2.20000		Phosphorus
11016	2.00000		Sulfur
11017	0.00299473	Chlorine
11018	0.00166201	Argon
11019	0.862000	Potassium
11020	1.55000		Calcium
11021	2.98900		Scandium
11022	4.54000		Titanium
11023	6.11000		Vanadium
11024	7.18000		Chromium
11025	7.44000		Manganese
11026	7.87400		Iron
11027	8.90000		Cobalt
11028	8.90200		Nickel
11029	8.96000		Copper
11030	7.13300		Zinc
11031	5.90400		Gallium
11032	5.32300		Germanium
11033	5.73000		Arsenic
11034	4.50000		Selenium
11035	0.00707218	Bromine
11036	0.00347832	Krypton
11037	1.53200		Rubidium
11038	2.54000		Strontium
11039	4.46900		Yttrium
11040	6.50600		Zirconium
11041	8.57000		Niobium
11042	10.2200		Molybdenum
11043	11.5000		Technetium
11044	12.4100		Ruthenium
11045	12.4100		Rhodium
11046	12.0200		Palladium
11047	10.5000		Silver
11048	8.65000		Cadmium
11049	7.31000		Indium
11050	7.31000		Tin
11051	6.69100		Antimony
11052	6.24000		Tellurium
11053	4.93000		Iodine
11054	0.00548536	Xenon
11055	1.87300		Cesium
11056	3.50000		Barium
11057	6.15400		Lanthanum
11058	6.65700		Cerium
11059	6.71000		Praseodymium
11060	6.90000		Neodymium
11061	7.22000		Promethium
11062	7.46000		Samarium
11063	5.24300		Europium
11064	7.90040		Gadolinium
11065	8.22900		Terbium
11066	8.55000		Dysprosium
11067	8.79500		Holmium
11068	9.06600		Erbium
11069	9.32100		Thulium
11070	6.73000		Ytterbium
11071	9.84000		Lutetium
11072	13.3100		Hafnium
11073	16.6540		Tantalum
11074	19.3000		Tungsten
11075	21.0200		Rhenium
11076	22.5700		Osmium
11077	22.4200		Iridium
11078	21.4500		Platinum
11079	19.3200		Gold
11080	13.5460		Mercury
11081	11.7200		Thallium
11082	11.3500		Lead
11083	9.74700		Bismuth
11084	9.32000		Polonium
11085	9.32000		Astatine
11086	0.00906618	Radon
11087	1.00000		Francium
11088	5.00000		Radium
11089	10.0700		Actinium
11090	11.7200		Thorium
11091	15.3700		Protactinium
11092	18.9500		Uranium
11093	20.2500		Neptunium
11094	19.8400		Plutonium
11095	13.6700		Americium
11096	13.5100		Curium
11097	14.0000		Berkelium
11098	10.0000		Californium

#			     Densities of Real World Materials
#
# Drawn from the FCOMP database file included with ESTAR, available
# from this web address:
#
# http://physics.nist.gov/PhysRefData/Star/Text/contents.html
#
# Numbering Conventions: All real world materials from FCOMP will have
# a prefix of 12, followed by their ID number in the FCOMP database.

12099	1.12700		A-150 Tissue-Equivalent Plastic
12100	0.78990		Acetone
12101	0.00109670	Acetylene
12102	1.35000		Adenine
12103	9.20000		Adipose Tissue (ICRP)
12104	0.00120479	Air, Dry (near sea level)
12105	1.42000		Alanine
12106	3.97000		Aluminum Oxide
12107	1.10000		Amber
12108	0.000826019	Ammonia
12109	1.02350		Aniline
12110	1.28300		Anthracene
12111	1.45000		B-100 Bone-Equivalent Plastic
12112	1.25000		Bakelite
12113	4.89000		Barium Fluoride
12114	4.50000		Barium Sulfate
12115	0.878650	Benzene
12116	3.01000		Beryllium oxide
12117	7.13000		Bismuth Germanium oxide
12118	1.06000		Blood (ICRP)
12119	1.85000		Bone, Compact (ICRU)
12120	1.85000		Bone, Cortical (ICRP)
12121	2.52000		Boron Carbide
12122	1.81200		Boron Oxide
12123	1.03000		Brain (ICRP)
12124	0.00249343	Butane
12125	0.809800	N-Butyl Alcohol
12126	1.76000		C-552 Air-Equivalent Plastic
12127	6.20000		Cadmium Telluride
12128	7.90000		Cadmium Tungstate
12129	2.80000		Calcium Carbonate
12130	3.18000		Calcium Fluoride
12131	3.30000		Calcium Oxide
12132	2.96000		Calcium Sulfate
12133	6.06200		Calcium Tungstate
12134	0.00184212	Carbon Dioxide
12135	1.59400		Carbon Tetrachloride
12136	1.42000		Cellulose Acetate, Cellophane
12137	1.20000		Cellulose Acetate Butyrate
12138	1.49000		Cellulose Nitrate
12139	1.03000		Ceric Sulfate Dosimeter Solution
12140	4.11500		Cesium Fluoride
12141	4.51000		Cesium Iodide
12142	1.10580		Chlorobenzene
12143	1.48320		Chloroform
12144	2.30000		Concrete, Portland
12145	0.779000	Cyclohexane
12146	1.30480		1,2-Dichlorobenzene
12147	1.21990		Dichlorodiethyl Ether
12148	1.23510		1,2-Dichloroethane
12149	0.713780	Diethyl Ether
12150	0.948700	N,N-Dimethyl Formamide
12151	1.10140		Dimethyl Sulfoxide
12152	0.00125324	Ethane
12153	0.789300	Ethyl Alcohol
12154	1.13000		Ethyl Cellulose
12155	0.00117497	Ethylene
12156	1.10000		Eye Lens (ICRP)
12157	5.20000		Ferric Oxide
12158	7.15000		Ferroboride
12159	5.70000		Ferrous Oxide
12160	1.02400		Ferrous Sulfate Dosimeter Solution
12161	1.12000		Freon-12
12162	1.80000		Freon-12B2
12163	0.95000		Freon-13
12164	1.50000		Freon-13B1
12165	1.80000		Freon-13I1
12166	7.44000		Gadolinium Oxysulfide
12167	5.31000		Gallium Arsenide
12168	1.29140		Gel in Photographic Emulsion
12169	2.23000		Glass, Pyrex
12170	6.22000		Glass, Lead
12171	2.40000		Glass, Plate
12172	1.54000		Glucose
12173	1.46000		Glutamine
12174	1.26130		Glycerol
12175	1.58000		Guanine
12176	2.32000		Gypsum, Plaster of Paris
12177	0.683760	N-Heptane
12178	0.660300	N-Hexane
12179	1.42000		Kapton Polyimide Film
12180	6.28000		Lanthanum Oxybromide
12181	5.86000		Lanthanum Oxysulfide
12182	9.53000		Lead Oxide
12183	1.17800		Lithium Amide
12184	2.11000		Lithium Carbonate
12185	2.63500		Lithium Fluoride
12186	0.820000	Lithium Hydride
12187	3.49400		Lithium Iodide
12188	2.01300		Lithium Oxide
12189	2.44000		Lithium Tetraborate
12190	1.05000		Lung (ICRP)
12191	1.05000		M3 Wax
12192	2.95800		Magnesium Carbonate
12193	3.00000		Magnesium Fluoride
12194	3.58000		Magnesium Oxide
12195	2.53000		Magnesium Tetraborate
12196	6.36000		Mercuric Iodide
12197	0.000667151	Methane
12198	0.791400	Methanol
12199	0.990000	Mix D Wax
12200	1.000000	MS20 Tissue Substitute
12201	1.04000		Muscle, Skeletal
12202	1.04000		Muscle, Striated
12203	1.11000		Muscle-Equivalent Liquid, with Sucrose
12204	1.07000		Muscle-Equivalent Liquid, without Sucrose
12205	1.14500		Naphthalene
12206	1.19867		Nitrobenzene
12207	0.00183094	Nitrous Oxide
12208	1.08000		Nylon, Du Pont ELVAmide 8062
12209	1.14000		Nylon, type 6 and type 6/6
12210	1.14000		Nylon, type 6/10
12211	1.42500		Nylon, type 11 (Rilsan)
12212	0.702600	Octane, Liquid
12213	0.930000	Paraffin Wax
12214	0.626200	N-Pentane
12215	3.81500		Photographic Emulsion
12216	1.03200		Plastic Scintillator (Vinyltoluene based)
12217	1.14600		Plutonium Dioxide
12218	1.17000		Polyacrylonitrile
12219	1.20000		Polycarbonate (Makrolon, Lexan)
12220	1.30000		Polychlorostyrene
12221	0.940000	Polyethylene
12222	1.40000		Polyethylene Terephthalate (Mylar)
12223	1.19000		Polymethyl Methacralate (Lucite, Perspex)
12224	1.42500		Polyoxymethylene
12225	0.900000	Polypropylene
12226	1.06000		Polystyrene
12227	2.20000		Polytetrafluoroethylene (Teflon)
12228	2.10000		Polytrifluorochloroethylene
12229	1.19000		Polyvinyl Acetate
12230	1.30000		Polyvinyl Alcohol
12231	1.12000		Polyvinyl Butyral
12232	1.30000		Polyvinyl Chloride
12233	1.70000		Polyvinylidene Chloride, Saran
12234	1.76000		Polyvinylidene Fluoride
12235	1.25000		Polyvinyl Pyrrolidone
12236	3.13000		Potassium Iodide
12237	2.32000		Potassium Oxide
12238	0.00187939	Propane
12239	0.430000	Propane, Liquid
12240	0.803500	N-Propyl Alcohol
12241	0.981900	Pyridine
12242	0.920000	Rubber, Butyl
12243	0.920000	Rubber, Natural
12244	1.23000		Rubber, Neoprene
12245	2.32000		Silicon Dioxide
12246	6.47300		Silver Bromide
12247	5.56000		Silver Chloride
12248	6.47000		Silver Halides in Photographic Emulsion
12249	6.01000		Silver Iodide
12250	1.10000		Skin (ICRP)
12251	2.53200		Sodium Carbonate
12252	3.66700		Sodium Iodide
12253	2.27000		Sodium Monoxide
12254	2.26100		Sodium Nitrate
12255	0.970700	Stilbene
12256	1.58050		Sucrose
12257	1.23400		Terphenyl
12258	1.04000		Testes (ICRP)
12259	1.62500		Tetrachloroethylene
12260	7.00400		Thallium Chloride
12261	1.00000		Tissue, Soft (ICRP)
12262	1.00000		Tissue, Soft (ICRU four-component)
12263	0.00106409	Tissue-Equivalent GAS (Methane based)
12264	0.00182628	Tissue-Equivalent GAS (Propane based)
12265	4.26000		Titanium Dioxide
12266	0.866900	Toluene
12267	1.46000		Trichloroethylene
12268	1.07000		Triethyl Phosphate
12269	2.40000		Tungsten Hexafluoride
12270	11.2800		Uranium Dicarbide
12271	13.6300		Uranium Monocarbide
12272	10.9600		Uranium Oxide
12273	1.32300		Urea
12274	1.23000		Valine
12275	1.80000		Viton Fluoroelastomer
12276	1.00000		Water, Liquid
12277	0.000756182	Water Vapor
12278	0.870000	Xylene
blob
data 1434
###
#
# This is the BRL-CAD package file for Arch Linux.
#
# Contributor: Loui Chang <louipc.ist@NOSPAMgmail.com>
#
###
pkgname=brlcad
pkgdesc="An extensive 3D solid modeling CAD system."
_major=$(cat ../../include/conf/MAJOR)
_minor=$(cat ../../include/conf/MINOR)
_patch=$(cat ../../include/conf/PATCH)
pkgver=$_major.$_minor.$_patch
pkgrel=1
url="http://brlcad.org"
license=('LGPL' 'BSD' 'custom:BDL')
arch=('i686' 'x86_64')
install=$pkgname.install
makedepends=('bc' 'libxslt')
depends=('boost' 'flex' 'libgl' 'libpng' 'mesa' 'tk' 'zlib')

optdepends=(
    'fop: for building pdf documentation'
)

options=('!libtool' '!strip' 'docs')

_pkgprefix=/opt/$pkgname

build() {
    mkdir $srcdir/build
    cd $srcdir/build

    cmake $startdir/../../ \
    -DCMAKE_INSTALL_PREFIX=${_pkgprefix} \
    -DCMAKE_BUILD_TYPE=Release \
    -DBRLCAD_ENABLE_STRICT=OFF

    make
}

package() {
    cd $srcdir/build

    make DESTDIR=$pkgdir install

    mkdir -p $pkgdir/etc/profile.d
    echo "export PATH=\$PATH:$_pkgprefix/bin" > $pkgdir/etc/profile.d/$pkgname.sh
    chmod 755 $pkgdir/etc/profile.d/$pkgname.sh

    mkdir -p $pkgdir/usr/share/licenses/$pkgname
    cp $srcdir/../../doc/legal/bdl.txt \
        $pkgdir/usr/share/licenses/$pkgname
    cp $srcdir/../../doc/legal/bsd.txt \
        $pkgdir/usr/share/licenses/$pkgname

    mkdir -p $pkgdir/etc/ld.so.conf.d
    echo ${_pkgprefix}/lib > $pkgdir/etc/ld.so.conf.d/$pkgname.conf
}

blob
data 1965
#!/bin/sh
#                  B R L C A D . I N S T A L L
# BRL-CAD
#
# Copyright (c) 2007-2014 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
#
# 3. The name of the author may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
###
#
# This is the BRL-CAD post-install script.
#
# Contributor: Loui Chang <louipc.ist@gmail.com>
#
###

# arg 1:  the new package version
post_install() {
  pre_remove
}

post_upgrade() {
  pre_remove
}

# arg 1:  the old package version
pre_remove() {
  cat etc/ld.so.conf | grep -v '/opt/brlcad/lib' >/tmp/.pacbrlcad
  mv /tmp/.pacbrlcad etc/ld.so.conf
  chmod 644 etc/ld.so.conf
  sbin/ldconfig -r .
}
blob
data 3015
;;
;;           b a t c h - i n d e n t - r e g i o n . e l
;;
;; Copyright (C) 2005 Christopher Sean Morrison
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions
;; are met:
;;
;; 1. Redistributions of source code must retain the above copyright
;; notice, this list of conditions and the following disclaimer.
;;
;; 2. Redistributions in binary form must reproduce the above copyright
;; notice, this list of conditions and the following disclaimer in the
;; documentation and/or other materials provided with the distribution.
;;
;; 3. The name of the author may not be used to endorse or promote
;; products derived from this software without specific prior written
;; permission.
;;
;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
;; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
;; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
;; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
;; GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
;; IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
;; OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
;; IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;
;;;;;;
;;
;; batch-indent-region.el provides automatic emacs source indentation.
;;
;; Using the emacs batch mode, this script will perform source code
;; indentation per the formatting rules specified by the editing mode.
;; Emacs local variable blocks may be used override default formatting
;; styles, as shown below.  Here is an example usage:
;;
;; emacs -batch -l batch-indent-region.el -f batch-indent-region pi.c
;;
;; Author: Christopher Sean Morrison <morrison@brlcad.org>
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun batch-indent-region ()
    "Run `batch-indent-region' on the files specified.  Use this from the
command line, with `-batch' only; it won't work in an interactive
Emacs. For example, invoke:
  emacs -batch -l batch-indent-region.el -f batch-indent-region *.c"

    (if (not noninteractive)
	(error "`batch-indent-region' is to be used only with -batch"))

    (while command-line-args-left
	(setq c-auto-align-backslashes nil)
	(setq c-label-minimum-indentation 0)
	(setq file (car command-line-args-left))
	(print file)
	(find-file file)
	(c-set-offset 'case-label '+)
	(c-set-offset 'statement-case-open '+)
	(c-set-offset 'innamespace 0)
	(c-set-offset 'inline-open 0)
	(indent-region (point-min) (point-max) nil)
	(save-buffer)
	(setq command-line-args-left (cdr command-line-args-left))))

;; Local Variables:
;; mode: Lisp
;; tab-width: 8
;; lisp-indent-offset: 4
;; indent-tabs-mode: t
;; End:
;; ex: shiftwidth=4 tabstop=8
blob
data 8322
#!/bin/sh
#                B R L C A D - C O N F I G . I N
# BRL-CAD
#
# Copyright (c) 2007-2014 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
#
# 3. The name of the author may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
###
#
# BRL-CAD configuration script for determining compilation
# characteristics of a given install.
###

prefix=@prefix@
exec_prefix=@exec_prefix@
includedir=@includedir@
libdir=@libdir@


usage ( ) {
    cat <<EOF
Usage: brlcad-config [OPTIONS] [LIBRARIES]

Options:
    [ --help ]
    [ --version ]
    [ --cflags ]
    [ --ldflags ]
    [ --libs ]
    [ --prefix[=DIR] ]
    [ --libdir[=DIR] ]
    [ --includedir[=DIR] ]

Libraries:
    analyze
    bn
    brlcad (default)
    bu
    dm
    fb
    fft
    gcv
    ged
    multispectral
    optical
    pkg
    rt
    wdb
EOF
    exit 1
}

# need at least a library or an action
if test $# -eq 0; then
    usage 1>&2
fi

libs=""
specified=no
while test $# -gt 0; do
    case "$1" in
	-*=*) optarg=`echo "$1" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
	*) optarg= ;;
    esac

    case $1 in
	--prefix)
	    echo_prefix=yes
	    specified=yes
	    ;;
	--prefix=*)
	    prefix="$optarg"
	    exec_prefix="$prefix"
	    includedir="${prefix}/include"
	    libdir="${prefix}/lib"
	    ;;
	--includedir)
	    echo_includedir=yes
	    specified=yes
	    ;;
	--includedir=*)
	    includedir="$optarg"
	    ;;
	--libdir)
	    echo_libdir=yes
	    specified=yes
	    ;;
	--libdir=*)
	    libdir="$optarg"
	    ;;
	--version)
	    echo_version=yes
	    specified=yes
	    ;;
	--cflags)
	    echo_cflags=yes
	    specified=yes
	    ;;
	--ldflags)
	    echo_ldflags=yes
	    specified=yes
	    ;;
	--libs)
	    echo_libs=yes
	    specified=yes
	    ;;
	--help)
	    usage 1>&2
	    ;;
	analyze)
	    libs="$libs -lanalyze"
	    ;;
	bn)
	    libs="$libs -lbn"
	    ;;
	brlcad)
	    libs="$libs -lbrlcad"
	    ;;
	bu)
	    libs="$libs -lbu"
	    ;;
	dm)
	    libs="$libs -ldm"
	    ;;
	fb)
	    libs="$libs -lfb"
	    ;;
	fft)
	    libs="$libs -lfft"
	    ;;
	gcv)
	    libs="$libs -lgcv"
	    ;;
	ged)
	    libs="$libs -lged"
	    ;;
	multispectral)
	    libs="$libs -lmultispectral"
	    ;;
	optical)
	    libs="$libs -loptical"
	    ;;
	pkg)
	    libs="$libs -lpkg"
	    ;;
	rt)
	    libs="$libs -lrt"
	    ;;
	wdb)
	    libs="$libs -lwdb"
	    ;;
	*)
	    usage 1>&2
	    ;;
    esac
    shift
done

# determine the behavior of echo
case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
    *c*,-n*) ECHO_N= ECHO_C='
' ECHO_T='	' ;;
    *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
    *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
esac

# default action is libs and ldflags
if test "x$specified" = "xno" ; then
    echo_libs=yes
    echo_ldflags=yes
fi

if test "x$libs" = "x" ; then
    # default lib is libbrlcad
    libs="-lbrlcad"
fi

if test "x$echo_version" = "xyes" ; then
    echo "@BRLCAD_VERSION@"
fi

if test "x$echo_prefix" = "xyes"; then
    echo "${prefix}"
fi

if test "x$echo_libdir" = "xyes"; then
    echo "${libdir}"
fi

if test "x$echo_includedir" = "xyes"; then
    echo "${includedir}"
fi


check ( ) {
    __cadlibs="$*"
    __result=""
    for new in $__cadlibs ; do
	case "x$new" in
	    x/*)
		new="`basename \"$new\"`"
		new="-l`echo $new | sed 's/^lib//' | sed 's/\.la$//'`"
		;;
	    x-L/src/other*)
		new=""
		;;
	    x-I/src/other*)
		new=""
		;;
	    x-I/include)
		new=""
		;;
	    *)
		;;
	esac

	__found=no
	for already in $__result ; do
	    if test "x$new" = "x$already" ; then
		__found=yes
		break
	    fi
	done
	if test "x$__found" = "xno" ; then
	    __result="$__result $new"
	fi
    done
    echo $__result
}


# stash the info
ANALYZE="@ANALYZE@ @ANALYZE_LIBS@"
BN="@BN@ @BN_LIBS@"
BRLCAD="@BRLCAD@ @BRLCAD_LIBS@"
BU="@BU@ @BU_LIBS@"
DM="@DM@ @DM_LIBS@"
FB="@FB@ @FB_LIBS@"
FFT="@FFT@ @FFT_LIBS@"
GCV="@GCV@ @GCV_LIBS@"
GED="@GED@ @GED_LIBS@"
MULTISPECTRAL="@MULTISPECTRAL@ @MULTISPECTRAL_LIBS@"
OPTICAL="@OPTICAL@ @OPTICAL_LIBS@"
PKG="@PKG@ @PKG_LIBS@"
RT="@RT@ @RT_LIBS@"
WDB="@WDB@ @WDB_LIBS@"


cadlibs=""
for lib in $libs ; do
    case $lib in
	-lanalyze)
	    if test "x$analyzeadded" = "x" ; then
		cadlibs="$cadlibs $ANALYZE"
		cadlibs="`check \"$cadlibs\"`"
		analyzeadded=yes
	    fi
	    ;;
	-lbn)
	    if test "x$bnadded" = "x" ; then
		cadlibs="$cadlibs $BN"
		cadlibs="`check \"$cadlibs\"`"
		bnadded=yes
	    fi
	    ;;
	-lbrlcad)
	    if test "x$brlcadadded" = "x" ; then
		cadlibs="$cadlibs $BRLCAD"
		cadlibs="`check \"$cadlibs\"`"
		brlcadadded=yes
	    fi
	    ;;
	-lbu)
	    if test "x$buadded" = "x" ; then
		cadlibs="$cadlibs $BU"
		cadlibs="`check \"$cadlibs\"`"
		buadded=yes
	    fi
	    ;;
	-ldm)
	    if test "x$dmadded" = "x" ; then
		cadlibs="$cadlibs $DM"
		cadlibs="`check \"$cadlibs\"`"
		dmadded=yes
	    fi
	    ;;
	-lfb)
	    if test "x$fbadded" = "x" ; then
		cadlibs="$cadlibs $FB"
		cadlibs="`check \"$cadlibs\"`"
		fbadded=yes
	    fi
	    ;;
	-lfft)
	    if test "x$fftadded" = "x" ; then
		cadlibs="$cadlibs $FFT"
		cadlibs="`check \"$cadlibs\"`"
		fftadded=yes
	    fi
	    ;;
	-lgcv)
	    if test "x$gcvadded" = "x" ; then
		cadlibs="$cadlibs $GCV"
		cadlibs="`check \"$cadlibs\"`"
		gcvadded=yes
	    fi
	    ;;
	-lged)
	    if test "x$gedadded" = "x" ; then
		cadlibs="$cadlibs $GED"
		cadlibs="`check \"$cadlibs\"`"
		gedadded=yes
	    fi
	    ;;
	-lmultispectral)
	    if test "x$multispectraladded" = "x" ; then
		cadlibs="$cadlibs $MULTISPECTRAL"
		cadlibs="`check \"$cadlibs\"`"
		multispectraladded=yes
	    fi
	    ;;
	-loptical)
	    if test "x$opticaladded" = "x" ; then
		cadlibs="$cadlibs $OPTICAL"
		cadlibs="`check \"$cadlibs\"`"
		opticaladded=yes
	    fi
	    ;;
	-lpkg)
	    if test "x$pkgadded" = "x" ; then
		cadlibs="$cadlibs $PKG"
		cadlibs="`check \"$cadlibs\"`"
		pkgadded=yes
	    fi
	    ;;
	-lrt)
	    if test "x$rtadded" = "x" ; then
		cadlibs="$cadlibs $RT"
		cadlibs="`check \"$cadlibs\"`"
		rtadded=yes
	    fi
	    ;;
	-lwdb)
	    if test "x$wdbadded" = "x" ; then
		cadlibs="$cadlibs $WDB"
		cadlibs="`check \"$cadlibs\"`"
		wdbadded=yes
	    fi
	    ;;
	*)
	    if test "x$need_newline" = "xyes" ; then
		echo ""
	    fi
	    echo "Internal Error: improperly added library encountered"
	    exit 2
	    ;;
    esac
done


CPPFLAGS="@CPPFLAGS@"
CPPFLAGS="`check $CPPFLAGS`"
CFLAGS="@CFLAGS@"
CFLAGS="`check $CFLAGS`"
LDFLAGS="@LDFLAGS@"
LDFLAGS="`check $LDFLAGS`"
LIBS="@LIBS@"
LIBS="`check $LIBS`"

# keep track of whether we need a trailing newline
need_newline=no

if test "x$echo_cflags" = "xyes"; then
    echo $ECHO_N "-I${includedir}/brlcad -I${includedir} $CPPFLAGS $CFLAGS $ECHO_C"
    need_newline=yes
fi

if test "x$echo_ldflags" = "xyes"; then
    echo $ECHO_N "-L${libdir} $LDFLAGS $ECHO_C"
    need_newline=yes
fi

if test "x$echo_libs" = "xyes"; then
    echo $ECHO_N "-L${libdir} $cadlibs $LIBS $ECHO_C"
    need_newline=yes
fi

if test "x$need_newline" = "xyes" ; then
    echo ""
fi

# Local Variables:
# tab-width: 8
# mode: sh
# indent-tabs-mode: t
# End:
# ex: shiftwidth=4 tabstop=8
blob
data 1794
#                  B R L C A D . S P E C . I N
# BRL-CAD
#
# Copyright (c) 2004-2014 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# version 2.1 as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this file; see the file named COPYING for more
# information.
#
###

Summary: BRL-CAD Open Source Solid Modeling
Name: BRL-CAD
Version: @BRLCAD_VERSION@
Release: 1
License: LGPL, BSD
Vendor: BRL-CAD Open Source
Url: http://brlcad.org
Group: Productivity/Graphics/CAD
Source0: http://prdownloads.sourceforge.net/brlcad/brlcad-@BRLCAD_VERSION@.tar.gz
BuildRoot: %{_tmppath}/%{name}-%{version}
BuildRequires: cmake, make, sed, bison, flex

%description
BRL-CAD is a powerful cross-platform open source solid modeling system
that includes interactive geometry editing, high-performance
ray-tracing for rendering and geometric analysis, image and
signal-processing tools, a system performance analysis benchmark
suite, libraries for robust geometric representation, with more than
25 years of active development.

%prep
%setup -q
%build
cmake .
make

%install
rm -rf $RPM_BUILD_ROOT
make DESTDIR=$RPM_BUILD_ROOT install

%clean
rm -rf $RPM_BUILD_ROOT

%files
$RPM_BUILD_ROOT

%changelog


# Local Variables:
# mode: autoconf
# tab-width: 8
# indent-tabs-mode: t
# End:
# ex: shiftwidth=8 tabstop=8
blob
data 1557
brlcad (7.24.2-0) unstable; urgency=low

  * update brlcad version

 -- Jordi Sayol <g.sayol@yahoo.es>  Thu, 05 Sep 2013 23:44:51 +0200

brlcad (7.24.0-0) unstable; urgency=low

  * update brlcad version

 -- Jordi Sayol <g.sayol@yahoo.es>  Mon, 25 Jun 2012 20:09:17 +0200

brlcad (7.22.0-0) unstable; urgency=low

  * update brlcad version

 -- Jordi Sayol <g.sayol@yahoo.es>  Tue, 24 Jan 2012 21:53:52 +0100

brlcad (7.20.4-0) unstable; urgency=low

  * moved to CMAKE building
  * changed mime-types names and mime-types icons names

 -- Jordi Sayol <g.sayol@yahoo.es>  Wed, 24 Aug 2011 12:12:44 +0200

brlcad (7.18.6-0) unstable; urgency=low

  - new BRL-CAD release

 -- Jordi Sayol <g.sayol@yahoo.es>  Sat, 16 Apr 2011 14:41:48 +0200

brlcad (7.18.4-0) unstable; urgency=low

  * add magic mime-type association for geometry db file v.4 and v.5
  * add new mime-type icons for geometry db file v.4 and v.5

 -- Jordi Sayol <g.sayol@yahoo.es>  Sat, 05 Mar 2011 23:10:51 +0100

brlcad (7.18.2-0) unstable; urgency=low

  * created new menu entries
  * added new icons
  * created new brlcad geometry mime-type
  * added brlcad geometry file mime-type association
  * switched from shared libraries to build-in ones
  * switched --prefix from /usr to /usr/brlcad
  * modified sh/make_deb.sh builder script

 -- Jordi Sayol <g.sayol@yahoo.es>  Sat, 29 Jan 2011 12:05:33 +0100

brlcad (7.16.10-1) unstable; urgency=low

  * Initial release (Closes: #289632).

 -- Manuel A. Fernandez Montecelo <manuel.montezelo@gmail.com>  Wed, 25 Aug 2010 11:16:45 +0200
blob
data 1130
Source: brlcad
Section: graphics
Priority: optional
Maintainer: Jordi Sayol <g.sayol@yahoo.es>
Build-Depends: build-essential, fakeroot, debhelper (>= 7.0.0), make (>= 3.8.0), cmake, sed, bison, flex, libxi-dev, xsltproc, libglu1-mesa-dev, libpango1.0-dev
Standards-Version: 3.9.1
Homepage: http://brlcad.org/
Vcs-Svn: https://brlcad.svn.sourceforge.net/svnroot/brlcad/
Vcs-Browser: http://brlcad.svn.sourceforge.net/viewvc/brlcad/

Package: brlcad
Architecture: any
Depends: ${misc:Depends}, ${shlibs:Depends}, xterm
Description: BRL-CAD open source solid modeling
 BRL-CAD is a powerful cross-platform Open Source combinatorial
 Constructive Solid Geometry (CSG) solid modeling system that
 includes interactive 3D solid geometry editing, high-performance
 ray-tracing support for rendering and geometric analysis,
 network-distributed framebuffer support, image and signal-processing
 tools, path-tracing and photon mapping support for realistic image
 synthesis, a system performance analysis benchmark suite, an embedded
 scripting interface, and libraries for robust high-performance
 geometric representation and analysis.
blob
data 2634
This package was debianized by: Jordi Sayol <g.sayol@yahoo.es>
on Wed, 24 Aug 2011 12:12:44 +0200

It was downloaded from: http://brlcad.org/

Upstream Authors: BRL-CAD Development Team <devs@brlcad.org>
	See AUTHORS for more information.


Copyright:

	All contributions to BRL-CAD have been provided under agreement.  By
	requiring all contributions be given back to the BRL-CAD developers,
	this agreement allows the BRL-CAD project to continue to grow
	unhindered.  As such, a majority of the source code is copyright by
	the United States Government as represented by the United States Army
	Research Laboratory.

	Authors and other BRL-CAD contributors must comply with the copyright
	terms for their respective contributions unless otherwise noted or
	arranged.  This includes an implicit assignment of copyright for any
	and all contributions being made.  The following notice should be
	prominent in the BRL-CAD sources:

	  Copyright (c) 1984-2014 United States Government as represented by
	  the U.S. Army Research Laboratory.

License:

	BRL-CAD is Open Source software with copyright primarily held by the
	U.S. Government.  The source code is controlled and maintained by a
	core team of Open Source developers working around the world.  Those
	core developers operate under a meritocracy organizational structure
	adhering to developer guidelines outlined in the HACKING developer's
	guide and to the legal conventions and requirements outlined in this
	document.

	As a unified work, BRL-CAD is made available under the terms of the
	GNU Lesser General Public License (LGPL) as published by the Free
	Software Foundation.

	As distinctly organized and separate components, parts of BRL-CAD are
	made available under different licenses for different portions
	including the BSD license and files in the public domain. The Overview
	section describes how the various licenses apply to the different
	portions of BRL-CAD.

	BRL-CAD is distributed in the hope that it will be useful, but WITHOUT
	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
	FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
	License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this file.  If you did not, please contact one of
	the BRL-CAD project administrators listed at the SourceForge project
	site http://sf.net/projects/brlcad/ or listed in the AUTHORS file
	included as part of the distribution.

On Debian GNU/Linux systems, the complete text of the GNU Lesser
General Public License can be found in
'/usr/share/common-licenses/LGPL-2.1'.
blob
data 1357
#!/usr/bin/make -f

# Author: Jordi Sayol <g.sayol@yahoo.es>

# Uncomment this to turn on verbose mode.
#export DH_VERBOSE=1

# override dpkg-buildflags flags
CFLAGS =
CPPFLAGS =
CXXFLAGS =
FFLAGS =
LDFLAGS =

# DEB_BUILD_OPTIONS

ifneq (,$(findstring parallel,$(DEB_BUILD_OPTIONS)))
    PARALLEL_JOBS = $(shell echo $(DEB_BUILD_OPTIONS) | \
        sed -e 's/.*parallel=\([0-9]\+\).*/\1/')
    PARALLEL_OPTIONS = -j$(PARALLEL_JOBS)
endif

build: build-stamp

build-stamp:
	dh_testdir

	cmake -DBRLCAD_BUNDLED_LIBS=ON \
		  -DBRLCAD_FLAGS_OPTIMIZATION=ON \
		  -DBRLCAD_ENABLE_STRICT=OFF \
		  -DBRLCAD_FLAGS_DEBUG=OFF \
		  -DCMAKE_BUILD_TYPE=Release \
		  -DCMAKE_INSTALL_PREFIX=/usr/brlcad \
		  -DDATA_DIR=share \
		  -DMAN_DIR=share/man

	$(MAKE) $(PARALLEL_OPTIONS)

	touch build-stamp

clean:
	dh_testdir
	dh_testroot
	dh_clean

install: install-stamp

install-stamp: build-stamp
	dh_testdir
	dh_testroot
	dh_prep
	dh_installdirs

	$(MAKE) install DESTDIR=$(CURDIR)/debian/tmp

# Build architecture-dependent files here.
binary-arch: build install
	dh_testdir
	dh_testroot
	dh_installdocs -a
	dh_installchangelogs -a
	dh_install -a --list-missing
	dh_compress -a
	dh_fixperms -a
#	dh_makeshlibs -a
	dh_installdeb -a
	dh_shlibdeps -a
	dh_gencontrol -a
	dh_md5sums -a
	dh_builddeb -a

binary: binary-arch
.PHONY: build clean binary-arch binary install
blob
data 74622
#!/usr/bin/env python

"""flawfinder: Find potential security flaws ("hits") in source code.
 Usage:
   flawfinder [options] [source_code_file]+

 See the man page for a description of the options."""

version="1.27"

# The default output is as follows:
# filename:line_number [risk_level] (type) function_name: message
#   where "risk_level" goes from 0 to 5. 0=no risk, 5=maximum risk.
# The final output is sorted by risk level, most risky first.
# Optionally ":column_number" can be added after the line number.
#
# Currently this program can only analyze C/C++ code.
#
# Copyright (C) 2001-2007 David A. Wheeler
# This is released under the General Public License (GPL):
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA



import sys, re, string, getopt
import pickle               # To support load/save/diff of hitlist
import os, glob, operator   # To support filename expansion on Windows
import os.path
import time
# import formatter

# Program Options - these are the default values:
show_context = 0
minimum_level = 1
show_immediately = 0
show_inputs = 0          # Only show inputs?
falsepositive = 0        # Work to remove false positives?
allowlink = 0            # Allow symbolic links?
skipdotdir = 1           # If 1, don't recurse into dirs beginning with "."
                         # Note: This doesn't affect the command line.
num_links_skipped = 0    # Number of links skipped.
num_dotdirs_skipped = 0  # Number of dotdirs skipped.
show_columns = 0
never_ignore = 0         # If true, NEVER ignore problems, even if directed.
list_rules = 0           # If true, list the rules (helpful for debugging)
patch_file = ""          # File containing (unified) diff output.
loadhitlist = None
savehitlist = None
diffhitlist = None
quiet = 0
showheading = 1          # --dataonly turns this off
output_format = 0        # 0 = normal, 1 = html.
single_line = 0          # 1 = singleline (can 't be 0 if html)
omit_time = 0            # 1 = omit time-to-run (needed for testing)

displayed_header = 0    # Have we displayed the header yet?
num_ignored_hits = 0    # Number of ignored hits (used if never_ignore==0)

def error(message):
  sys.stderr.write("Error: %s\n"% message)


# Support routines: find a pattern.
# To simplify the calling convention, several global variables are used
# and these support routines are defined, in an attempt to make the
# actual calls simpler and clearer.
#

filename = ""      # Source filename.
linenumber = 0     # Linenumber from original file.
ignoreline = -1    # Line number to ignore.
sumlines = 0       # Number of lines (total) examined.
sloc = 0           # Physical SLOC
starttime = time.time()  # Used to determine analyzed lines/second.


line_beginning = re.compile( r'(?m)^' )
blank_line     = re.compile( r'(?m)^\s+$' )


# The following code accepts unified diff format from both subversion (svn)
# and GNU diff, which aren't well-documented.  It gets filenames from
# "Index:" if exists, else from the "+++ FILENAME ..." entry.
# Note that this is different than some tools (which will use "+++" in
# preference to "Index:"), but subversion's nonstandard format is easier
# to handle this way.
# Since they aren't well-documented, here's some info on the diff formats:
# GNU diff format:
#    --- OLDFILENAME OLDTIMESTAMP
#    +++ NEWFILENAME NEWTIMESTAMP
#    @@ -OLDSTART,OLDLENGTH +NEWSTART,NEWLENGTH @@
#    ... Changes where preceding "+" is add, "-" is remove, " " is unchanged.
#
#    ",OLDLENGTH" and ",NEWLENGTH" are optional  (they default to 1).
#    GNU unified diff format doesn't normally output "Index:"; you use
#    the "+++/---" to find them (presuming the diff user hasn't used --label
#    to mess it up).
#
# Subversion format:
#    Index: FILENAME
#    --- OLDFILENAME (comment)
#    +++ NEWFILENAME (comment)
#    @@ -OLDSTART,OLDLENGTH +NEWSTART,NEWLENGTH @@
#
#    In subversion, the "Index:" always occurs, and note that paren'ed
#    comments are in the oldfilename/newfilename, NOT timestamps like
#    everyone else.
#
# Single Unix Spec version 3 (http://www.unix.org/single_unix_specification/)
# does not specify unified format at all; it only defines the older
# (obsolete) context diff format.  That format DOES use "Index:", but
# only when the filename isn't specified otherwise.
# We're only supporting unified format directly; if you have an older diff
# format, use "patch" to apply it, and then use "diff -u" to create a
# unified format.
#

diff_index_filename = re.compile( r'^Index:\s+(?P<filename>.*)' )
diff_newfile = re.compile( r'^\+\+\+\s(?P<filename>.*)$' )
diff_hunk = re.compile( r'^@@ -\d+(,\d+)?\s+\+(?P<linenumber>\d+)[, ].*@@$' )
diff_line_added = re.compile( r'^\+[^+].*' )
diff_line_del = re.compile( r'^-[^-].*' )
# The "+++" newfile entries have the filename, followed by a timestamp
# or " (comment)" postpended.
# Timestamps can be of these forms:
#   2005-04-24 14:21:39.000000000 -0400
#   Mon Mar 10 15:13:12 1997
# Also, "newfile" can have " (comment)" postpended.  Find and eliminate this.
# Note that the expression below is Y10K (and Y100K) ready. :-).
diff_findjunk = re.compile( r'^(?P<filename>.*)((\s\d\d\d\d+-\d\d-\d\d\s+\d\d:\d[0-9:.]+Z?(\s+[\-\+0-9A-Z]+)?)|(\s[A-Za-z][a-z]+\s[A-za-z][a-z]+\s\d+\s\d+:\d[0-9:.]+Z?(\s[\-\+0-9]*)?\s\d\d\d\d+)|(\s\(.*\)))\s*$')

def is_svn_diff(sLine):
  if (sLine.find('Index:') != -1):
    return True
  return False

def svn_diff_get_filename(sLine):
  return diff_index_filename.match(sLine)

def gnu_diff_get_filename(sLine):
  newfile_match = diff_newfile.match(sLine)
  if (newfile_match):
    patched_filename = string.strip(newfile_match.group('filename'))
    # Clean up filename - remove trailing timestamp and/or (comment).
    return diff_findjunk.match(patched_filename)

  return None


# For each file found in the file patch_file, keep the
# line numbers of the new file (after patch is applied) which are added.
# We keep this information in a hash table for a quick access later.
#
def load_patch_info(patch_file):
  patch={}
  line_counter= 0
  initial_number= 0
  index_statement = False # Set true if we see "Index:".
  try: hPatch = open(patch_file, 'r')
  except:
    print "Error: failed to open", h(patch_file)
    sys.exit(1)

  patched_filename = "" # Name of new file patched by current hunk.

  sLine = hPatch.readline()
  #Heuristic to determine if it's a svn diff or a GNU diff.
  #Read the first line. If it contains 'Index:', it's a svn diff else it is a
  #GNU diff.
  #By default we try to get filename in svn diff
  fn_get_filename=svn_diff_get_filename
  if (is_svn_diff(sLine) == False):
    fn_get_filename=gnu_diff_get_filename

  while True: # Loop-and-half construct.  Read a line, end loop when no more

    # This is really a sequence of if ... elsif ... elsif..., but
    # because Python forbids '=' in conditions, we do it this way.
    filename_match = fn_get_filename(sLine)
    if (filename_match):
      patched_filename = string.strip(filename_match.group('filename'))
      if (patch.has_key(patched_filename) == True):
        error("filename occurs more than once in the patch: %s" %
               patched_filename)
        sys.exit(1)
      else:
        patch[patched_filename] = {}
    else:
      hunk_match = diff_hunk.match(sLine)
      if (hunk_match):
        if (patched_filename == ""):
            error("wrong type of patch file : we have a line number without having seen a filename")
            sys.exit(1)
        initial_number= hunk_match.group('linenumber')
        line_counter= 0
      else:
        line_added_match = diff_line_added.match(sLine)
        if (line_added_match):
          line_added = line_counter + int(initial_number)
          patch[patched_filename][line_added] = True
          # Let's also warn about the lines above and below this one,
          # so that errors that "leak" into adjacent lines are caught.
          # Besides, if you're creating a patch, you had to at least look
          # at adjacent lines, so you're in a position to fix them.
          patch[patched_filename][line_added - 1] = True
          patch[patched_filename][line_added + 1] = True
          line_counter += 1
        else:
          line_del_match = diff_line_del.match(sLine)
          if (line_del_match == None):
            line_counter += 1

    sLine = hPatch.readline()
    if (sLine == ''): break  # Done reading.

  return patch


def htmlize(s):
  # Take s, and return legal (UTF-8) HTML.
  s1 = string.replace(s,"&","&amp;")
  s2 = string.replace(s1,"<","&lt;")
  s3 = string.replace(s2,">","&gt;")
  return s3

def h(s):
  # htmlize s if we're generating html, otherwise just return s.
  if output_format: return htmlize(s)
  else:             return s

def print_multi_line(text):
  # Print text as multiple indented lines.
  width = 72
  prefix = " "
  starting_position = len(prefix) + 1
  printed_something = 0  # Have we printed on this line?
  position = starting_position
  nextword = ""

  print prefix,
  for c in text:
    if (c == " "):
      print nextword,
      position = position + 1 # account for space we just printed.
      printed_something = 1
      nextword = ""
    else: # NonSpace.
      nextword = nextword + c
      position = position + 1
      if position > width: # Whups, out of space
        if (printed_something):  # We've printed something out.
          print # Done with this line, move to next.
          print prefix,
          position = starting_position
  print nextword, # Print remainder (can be overlong if no spaces)


class Hit:
  """
  Each instance of Hit is a warning of some kind in a source code file.
  See the rulesets, which define the conditions for triggering a hit.
  Hit is initialized with a tuple containing the following:
    hook: function to call when function name found.
    level: (default) warning level, 0-5. 0=no problem, 5=very risky.
    warning: warning (text saying what's the problem)
    suggestion: suggestion (text suggesting what to do instead)
    category: One of "buffer" (buffer overflow), "race" (race condition),
              "tmpfile" (temporary file creation), "format" (format string).
              Use "" if you don't have a better category.
    url: URL fragment reference.
    other:  A dictionary with other settings.

  Other settings usually set:

    name: function name
    parameter: the function parameters (0th parameter null)
    input: set to 1 if the function inputs from external sources.
    start: start position (index) of the function name (in text)
    end:  end position of the function name (in text)
    filename: name of file
    line: line number in file
    column: column in line in file
    context_text: text surrounding hit"""

  # Set default values:
  source_position = 2 # By default, the second parameter is the source.
  format_position = 1 # By default, the first parameter is the format.
  input = 0           # By default, this doesn't read input.
  note = ""          # No additional notes.
  filename = ""      # Empty string is filename.
  extract_lookahead = 0 # Normally don't extract lookahead.

  def __init__(self, data):
    hook, level, warning, suggestion, category, url, other = data
    self.hook, self.level = hook, level
    self.warning, self.suggestion = warning, suggestion
    self.category, self.url = category, url
    # These will be set later, but I set them here so that
    # analysis tools like PyChecker will know about them.
    self.column = 0
    self.line = 0
    self.name = ""
    self.context_text = ""
    for key in other.keys():
      setattr(self, key, other[key])

  def __cmp__(self, other):
    return (cmp(other.level, self.level) or  # Highest risk first.
            cmp(self.filename, other.filename) or
            cmp(self.line, other.line) or
            cmp(self.column, other.column) or
            cmp(self.name, other.name))

  def __getitem__(self, X):   # Define this so this works: "%(line)" % hit
    return getattr(self, X)

  def show(self):
    if output_format: print "<li>",
    sys.stdout.write(h(self.filename))

    if show_columns: print ":%(line)s:%(column)s:" % self,
    else:            print ":%(line)s:" % self,

    if output_format: print "<b>",
    # Extra space before risk level in text, makes it easier to find:
    print " [%(level)s]" % self,
    if output_format: print "</b>",
    print "(%(category)s)" % self,
    if output_format: print "<i>",
    print h("%(name)s:" % self),
    if single_line:
      print h("%(warning)s." % self),
      if self.suggestion: print h(self.suggestion)+".",
      print h(self.note),
    else:
      main_text = h("%(warning)s. " % self)
      if self.suggestion: main_text = main_text + h(self.suggestion) + ". "
      main_text = main_text + h(self.note)
      print
      print_multi_line(main_text)
    if output_format: print "</i>",
    print
    if show_context:
      if output_format: print "<pre>"
      print h(self.context_text)
      if output_format: print "</pre>"



# The "hitlist" is the list of all hits (warnings) found so far.
# Use add_warning to add to it.

hitlist = []

def add_warning(hit):
  global hitlist, num_ignored_hits
  if show_inputs and not hit.input: return
  if hit.level >= minimum_level:
    if linenumber == ignoreline:
      num_ignored_hits = num_ignored_hits + 1
    else:
      hitlist.append(hit)
      if show_immediately:
        hit.show()

def internal_warn(message):
  print h(message)

# C Language Specific

def extract_c_parameters(text, pos=0):
  "Return a list of the given C function's parameters, starting at text[pos]"
  # '(a,b)' produces ['', 'a', 'b']
  i = pos
  # Skip whitespace and find the "("; if there isn't one, return []:
  while i < len(text):
    if text[i] == '(':                 break
    elif text[i] in string.whitespace: i = i + 1
    else:                              return []
  else:  # Never found a reasonable ending.
    return []
  i = i + 1
  parameters = [""]  # Insert 0th entry, so 1st parameter is parameter[1].
  currentstart = i
  parenlevel = 1
  instring = 0  # 1=in double-quote, 2=in single-quote
  incomment = 0
  while i < len(text):
    c = text[i]
    if instring:
      if c == '"' and instring == 1: instring = 0
      elif c == "'" and instring == 2: instring = 0
      # if \, skip next character too.  The C/C++ rules for
      # \ are actually more complex, supporting \ooo octal and
      # \xhh hexadecimal (which can be shortened), but we don't need to
      # parse that deeply, we just need to know we'll stay in string mode:
      elif c == '\\': i = i + 1
    elif incomment:
      if c == '*' and text[i:i+2]=='*/':
        incomment = 0
        i = i + 1
    else:
      if c == '"': instring = 1
      elif c == "'": instring = 2
      elif c == '/' and text[i:i+2]=='/*':
         incomment = 1
         i = i + 1
      elif c == '/' and text[i:i+2]=='//':
         while i < len(text) and text[i] != "\n":
           i = i + 1
      elif c == '\\' and text[i:i+2]=='\\"': i = i + 1 # Handle exposed '\"'
      elif c == '(': parenlevel = parenlevel + 1
      elif c == ',' and (parenlevel == 1):
        parameters.append(string.strip(
                    p_trailingbackslashes.sub('', text[currentstart:i])))
        currentstart = i + 1
      elif c == ')':
        parenlevel = parenlevel - 1
        if parenlevel <= 0:
            parameters.append(string.strip(
                    p_trailingbackslashes.sub('', text[currentstart:i])))
            # Re-enable these for debugging:
            # print " EXTRACT_C_PARAMETERS: ", text[pos:pos+80]
            # print " RESULTS: ", parameters
            return parameters
      elif c == ';':
          internal_warn("Parsing failed to find end of parameter list; "
                        "semicolon terminated it in %s" % text[pos:pos+200])
          return parameters
    i = i + 1
  internal_warn("Parsing failed to find end of parameter list in %s" %
                text[pos:pos+200])


# These patterns match gettext() and _() for internationalization.
# This is compiled here, to avoid constant recomputation.
# FIXME: assumes simple function call if it ends with ")",
# so will get confused by patterns like  gettext("hi") + function("bye")
# In practice, this doesn't seem to be a problem; gettext() is usually
# wrapped around the entire parameter.
# The ?s makes it possible to match multi-line strings.
gettext_pattern = re.compile(r'(?s)^\s*' + 'gettext' + r'\s*\((.*)\)\s*$')
undersc_pattern = re.compile(r'(?s)^\s*' + '_(T(EXT)?)?' + r'\s*\((.*)\)\s*$')

def strip_i18n(text):
  "Strip any internationalization function calls surrounding 'text', "
  "such as gettext() and _()."
  match = gettext_pattern.search(text)
  if match: return string.strip(match.group(1))
  match = undersc_pattern.search(text)
  if match: return string.strip(match.group(3))
  return text

p_trailingbackslashes = re.compile( r'(\s|\\(\n|\r))*$')

p_c_singleton_string = re.compile( r'^\s*"([^\\]|\\[^0-6]|\\[0-6]+)?"\s*$')

def c_singleton_string(text):
  "Returns true if text is a C string with 0 or 1 character."
  if p_c_singleton_string.search(text): return 1
  else: return 0

# This string defines a C constant.
p_c_constant_string = re.compile( r'^\s*"([^\\]|\\[^0-6]|\\[0-6]+)*"$')

def c_constant_string(text):
  "Returns true if text is a constant C string."
  if p_c_constant_string.search(text): return 1
  else: return 0


# Precompile patterns for speed.


def c_buffer(hit):
  source_position = hit.source_position
  if source_position <= len(hit.parameters)-1:
    source=hit.parameters[source_position]
    if c_singleton_string(source):
      hit.level = 1
      hit.note = "Risk is low because the source is a constant character."
    elif c_constant_string(strip_i18n(source)):
      hit.level = max( hit.level - 2, 1)
      hit.note = "Risk is low because the source is a constant string."
  add_warning(hit)


p_dangerous_strncat = re.compile(r'^\s*sizeof\s*(\(\s*)?[A-Za-z_$0-9]+'  +
                                    r'\s*(\)\s*)?(-\s*1\s*)?$')
# This is a heuristic: constants in C are usually given in all upper case letters.
# Yes, this need not be true, but it's true often enough that it's worth
# using as a heuristic.  strncat better not be passed a constant as the length!
p_looks_like_constant = re.compile(r'^\s*[A-Z][A-Z_$0-9]+\s*(-\s*1\s*)?$')

def c_strncat(hit):
  if len(hit.parameters) > 3:
    # A common mistake is to think that when calling strncat(dest,src,len), that
    # "len" means the ENTIRE length of the destination.  This isn't true, it must
    # be the length of the characters TO BE ADDED at most.  Which is one reason that
    # strlcat is better than strncat.  We'll detect a common case of this error;
    # if the length parameter is of the form "sizeof(dest)", we have this error.
    # Actually, sizeof(dest) is okay if the dest's first character is always \0,
    # but in that case the programmer should use strncpy, NOT strncat.
    # The following heuristic will certainly miss some dangerous cases, but
    # it at least catches the most obvious situation.
    # This particular heuristic is overzealous; it detects ANY sizeof, instead of
    # only the sizeof(dest)  (where dest is given in hit.parameters[1]).
    # However, there aren't many other likely candidates for sizeof; some people
    # use it to capture just the length of the source, but this is just as dangerous,
    # since then it absolutely does NOT take care of the destination maximum length
    # in general.  It also detects if a constant is given as a length, if the
    # constant follows common C naming rules.
    length_text=hit.parameters[3]
    if p_dangerous_strncat.search(length_text) or p_looks_like_constant.search(length_text):
      hit.level = 5
      hit.note = ( "Risk is high; the length parameter appears to be a constant, " +
                 "instead of computing the number of characters left.")
      add_warning(hit)
      return
  c_buffer(hit)

def c_printf(hit):
  format_position = hit.format_position
  if format_position <= len(hit.parameters)-1:
    # Assume that translators are trusted to not insert "evil" formats:
    source = strip_i18n(hit.parameters[format_position])
    if c_constant_string(source):
      # Parameter is constant, so there's no risk of format string problems.
      if hit.name == "snprintf" or hit.name == "vsnprintf":
        hit.level = 1
        hit.warning = \
          "On some very old systems, snprintf is incorrectly implemented " \
          "and permits buffer overflows; there are also incompatible " \
          "standard definitions of it"
        hit.suggestion = "Check it during installation, or use something else"
        hit.category = "port"
      else:
        # We'll pass it on, just in case it's needed, but at level 0 risk.
        hit.level = 0
        hit.note = "Constant format string, so not considered very risky (there's some residual risk, especially in a loop)."
  add_warning(hit)


p_dangerous_sprintf_format = re.compile(r'%-?([0-9]+|\*)?s')

# sprintf has both buffer and format vulnerabilities.
def c_sprintf(hit):
  source_position = hit.source_position
  if source_position <= len(hit.parameters)-1:
    source=hit.parameters[source_position]
    if c_singleton_string(source):
      hit.level = 1
      hit.note = "Risk is low because the source is a constant character."
    else:
      source = strip_i18n(source)
      if c_constant_string(source):
        if not p_dangerous_sprintf_format.search(source):
          hit.level = max( hit.level - 2, 1)
          hit.note = "Risk is low because the source has a constant maximum length."
        # otherwise, warn of potential buffer overflow (the default)
      else:
        # Ho ho - a nonconstant format string - we have a different problem.
        hit.warning = "Potential format string problem"
        hit.suggestion = "Make format string constant"
        hit.level = 4
        hit.category = "format"
        hit.url = ""
  add_warning(hit)

p_dangerous_scanf_format = re.compile(r'%s')
p_low_risk_scanf_format = re.compile(r'%[0-9]+s')

def c_scanf(hit):
  format_position = hit.format_position
  if format_position <= len(hit.parameters)-1:
    # Assume that translators are trusted to not insert "evil" formats;
    # it's not clear that translators will be messing with INPUT formats,
    # but it's possible so we'll account for it.
    source = strip_i18n(hit.parameters[format_position])
    if c_constant_string(source):
      if p_dangerous_scanf_format.search(source): pass # Accept default.
      elif p_low_risk_scanf_format.search(source):
        # This is often okay, but sometimes extremely serious.
        hit.level = 1
        hit.warning = "it's unclear if the %s limit in the format string is small enough"
        hit.suggestion = "Check that the limit is sufficiently small, or use a different input function"
      else:
        # No risky scanf request.
        # We'll pass it on, just in case it's needed, but at level 0 risk.
        hit.level = 0
        hit.note = "No risky scanf format detected."
    else:
      # Format isn't a constant.
      hit.warning = "If format strings to scanf's family of functions can be influenced by an attacker, they can be exploited"
      hit.suggestion = "Use a constant for the format specification"
  add_warning(hit)


p_dangerous_multi_byte = re.compile(r'^\s*sizeof\s*(\(\s*)?[A-Za-z_$0-9]+'  +
                                    r'\s*(\)\s*)?(-\s*1\s*)?$')
p_safe_multi_byte =      re.compile(r'^\s*sizeof\s*(\(\s*)?[A-Za-z_$0-9]+\s*(\)\s*)?' +
                                     r'/\s*sizeof\s*\(\s*?[A-Za-z_$0-9]+\s*' +
                                     r'\[\s*0\s*\]\)\s*(-\s*1\s*)?$')

def c_multi_byte_to_wide_char(hit):
  # Unfortunately, this doesn't detect bad calls when it's a #define or constant
  # set by a sizeof(), but trying to do so would create FAR too many false positives.
  if len(hit.parameters)-1 >= 6:
    num_chars_to_copy=hit.parameters[6]
    if p_dangerous_multi_byte.search(num_chars_to_copy):
      hit.level = 5
      hit.note = ("Risk is high, it appears that the size is given as bytes, but the " +
                 "function requires size as characters.")
    elif p_safe_multi_byte.search(num_chars_to_copy):
      # This isn't really risk-free, since it might not be the destination, or the
      # destination might be a character array (if it's a char pointer, the pattern
      # is actually quite dangerous, but programmers are unlikely to make that error).
      hit.level = 1
      hit.note = "Risk is very low, the length appears to be in characters not bytes."
  add_warning(hit)

p_null_text = re.compile(r'^ *(NULL|0|0x0) *$')

def c_hit_if_null(hit):
  null_position = hit.check_for_null
  if null_position <= len(hit.parameters)-1:
    null_text=hit.parameters[null_position]
    if p_null_text.search(null_text):
      add_warning(hit)
    else:
      return
  add_warning(hit) # If insufficient # of parameters.

p_static_array = re.compile(r'^[A-Za-z_]+\s+[A-Za-z0-9_$,\s\*()]+\[[^]]')

def c_static_array(hit):
  # This is cheating, but it does the job for most real code.
  # In some cases it will match something that it shouldn't.
  # We don't match ALL arrays, just those of certain types (e.g., char).
  # In theory, any array can overflow, but in practice it seems that
  # certain types are far more prone to problems, so we just report those.
  if p_static_array.search(hit.lookahead):
    add_warning(hit) # Found a static array, warn about it.

def normal(hit):
  add_warning(hit)


# "c_ruleset": the rules for identifying "hits" in C (potential warnings).
# It's a dictionary, where the key is the function name causing the hit,
# and the value is a tuple with the following format:
#  (hook, level, warning, suggestion, category, {other})
# See the definition for class "Hit".
# The key can have multiple values separated with "|".

c_ruleset = {
  "strcpy" :
     (c_buffer, 4,
      "Does not check for buffer overflows when copying to destination",
      "Consider using strncpy or strlcpy (warning, strncpy is easily misused)",
      "buffer", "", {}),
  "lstrcpy|wcscpy|_tcscpy|_mbscpy" :
     (c_buffer, 4,
      "Does not check for buffer overflows when copying to destination",
      "Consider using a function version that stops copying at the end of the buffer",
      "buffer", "", {}),
  "memcpy|CopyMemory|bcopy" :
     (normal, 2, # I've found this to have a lower risk in practice.
      "Does not check for buffer overflows when copying to destination",
      "Make sure destination can always hold the source data",
      "buffer", "", {}),
  "strcat" :
     (c_buffer, 4,
      "Does not check for buffer overflows when concatenating to destination",
      "Consider using strncat or strlcat (warning, strncat is easily misused)",
      "buffer", "", {}),
  "lstrcat|wcscat|_tcscat|_mbscat" :
     (c_buffer, 4,
      "Does not check for buffer overflows when concatenating to destination",
      "",
      "buffer", "", {}),
  "strncpy" :
     (c_buffer,
      1, # Low risk level, because this is often used correctly when FIXING security
      # problems, and raising it to a higher risk level would cause many false positives.
      "Easily used incorrectly; doesn't always \\0-terminate or " +
         "check for invalid pointers",
      "",
      "buffer", "", {}),
  "lstrcpyn|wcsncpy|_tcsncpy|_mbsnbcpy" :
     (c_buffer,
      1, # Low risk level, because this is often used correctly when FIXING security
      # problems, and raising it to a higher risk levle would cause many false positives.
      "Easily used incorrectly; doesn't always \\0-terminate or " +
         "check for invalid pointers",
      "",
      "buffer", "", {}),
  "strncat" :
     (c_strncat,
      1, # Low risk level, because this is often used correctly when
         # FIXING security problems, and raising it to a
         # higher risk level would cause many false positives.
      "Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add)",
      "Consider strlcat or automatically resizing strings",
      "buffer", "", {}),
  "lstrcatn|wcsncat|_tcsncat|_mbsnbcat" :
     (c_strncat,
      1, # Low risk level, because this is often used correctly when FIXING security
      # problems, and raising it to a higher risk level would cause many false positives.
      "Easily used incorrectly (e.g., incorrectly computing the correct maximum size to add)",
      "Consider strlcat or automatically resizing strings",
      "buffer", "", {}),
  "strccpy|strcadd":
     (normal, 1,
      "Subject to buffer overflow if buffer is not as big as claimed",
      "Ensure that destination buffer is sufficiently large",
      "buffer", "", {}),
  "char|TCHAR|wchar_t":  # This isn't really a function call, but it works.
     (c_static_array, 2,
      "Statically-sized arrays can be overflowed",
      ("Perform bounds checking, use functions that limit length, " +
        "or ensure that the size is larger than the maximum possible length"),
      "buffer", "", {'extract_lookahead' : 1}),

  "gets|_getts":
     (normal, 5, "Does not check for buffer overflows",
      "Use fgets() instead", "buffer", "", {'input' : 1}),

  # The "sprintf" hook will raise "format" issues instead if appropriate:
  "sprintf|vsprintf|swprintf|vswprintf|_stprintf|_vstprintf":
     (c_sprintf, 4,
      "Does not check for buffer overflows",
      "Use snprintf or vsnprintf",
      "buffer", "", {}),

  # TODO: Add "wide character" versions of these functions.
  "printf|vprintf|vwprintf|vfwprintf|_vtprintf":
     (c_printf, 4,
      "If format strings can be influenced by an attacker, they can be exploited",
      "Use a constant for the format specification",
      "format", "", {}),

  "fprintf|vfprintf|_ftprintf|_vftprintf":
     (c_printf, 4,
      "If format strings can be influenced by an attacker, they can be exploited",
      "Use a constant for the format specification",
      "format", "", { 'format_position' : 2}),

  # The "syslog" hook will raise "format" issues.
  "syslog":
     (c_printf, 4,
      "If syslog's format strings can be influenced by an attacker, " +
      "they can be exploited",
      "Use a constant format string for syslog",
      "format", "", { 'format_position' : 2} ),

  "snprintf|vsnprintf|_snprintf|_sntprintf|_vsntprintf":
     (c_printf, 4,
      "If format strings can be influenced by an attacker, they can be " +
      "exploited, and note that sprintf variations do not always \\0-terminate",
      "Use a constant for the format specification",
      "format", "", { 'format_position' : 3}),

  "scanf|vscanf|wscanf|_tscanf":
     (c_scanf, 4,
      "The scanf() family's %s operation, without a limit specification, " +
        "permits buffer overflows",
      "Specify a limit to %s, or use a different input function",
      "buffer", "", {'input' : 1}),

  "fscanf|sscanf|vsscanf|vfscanf|_ftscanf":
     (c_scanf, 4,
      "The scanf() family's %s operation, without a limit specification, "
      "permits buffer overflows",
      "Specify a limit to %s, or use a different input function",
      "buffer", "", {'input' : 1, 'format_position' : 2}),

  "strlen|wcslen|_tcslen|_mbslen" :
     (normal,
      1, # Often this isn't really a risk, and even when, it usually at worst causes
      # program crash (and nothing worse).
      "Does not handle strings that are not \\0-terminated (it could cause a crash " +
         "if unprotected)",
      "",
      "buffer", "", {}),

  "MultiByteToWideChar" : # Windows
     (c_multi_byte_to_wide_char,
      2, # Only the default - this will be changed in many cases.
      "Requires maximum length in CHARACTERS, not bytes",
      "",
      "buffer", "", {}),

  "streadd|strecpy":
     (normal, 4,
      "This function does not protect against buffer overflows",
      "Ensure the destination has 4 times the size of the source, to leave room for expansion",
      "buffer", "dangers-c", {}),

  "strtrns":
     (normal, 3,
      "This function does not protect against buffer overflows",
      "Ensure that destination is at least as long as the source",
      "buffer", "dangers-c", {}),

  "realpath":
     (normal, 3,
      "This function does not protect against buffer overflows, " +
        "and some implementations can overflow internally",
      "Ensure that the destination buffer is at least of size MAXPATHLEN, and" +
        "to protect against implementation problems, the input argument should also " +
        "be checked to ensure it is no larger than MAXPATHLEN",
      "buffer", "dangers-c", {}),

  "getopt|getopt_long":
     (normal, 3,
     "Some older implementations do not protect against internal buffer overflows ",
      "Check implementation on installation, or limit the size of all string inputs",
      "buffer", "dangers-c", {'input' : 1}),

  "getpass":
     (normal, 3,
     "Some implementations may overflow buffers",
      "",
      "buffer", "dangers-c", {'input' : 1}),

  "getwd":
     (normal, 3,
     "This does not protect against buffer overflows "
     "by itself, so use with caution",
      "Use getcwd instead",
      "buffer", "dangers-c", {'input' : 1}),

  # fread not included here; in practice I think it's rare to mistake it.
  "getchar|fgetc|getc|read|_gettc":
     (normal, 1,
     "Check buffer boundaries if used in a loop", # loops may be via recursion, too.
      "",
      "buffer", "dangers-c", {'input' : 1}),

  "access":        # ???: TODO: analyze TOCTOU more carefully.
     (normal, 4,
      "This usually indicates a security flaw.  If an " +
      "attacker can change anything along the path between the " +
      "call to access() and the file's actual use (e.g., by moving " +
      "files), the attacker can exploit the race condition",
      "Set up the correct permissions (e.g., using setuid()) and " +
      "try to open the file directly",
      "race",
      "avoid-race#atomic-filesystem", {}),
  "chown":
     (normal, 5,
      "This accepts filename arguments; if an attacker " +
      "can move those files, a race condition results. ",
      "Use fchown( ) instead",
      "race", "", {}),
  "chgrp":
     (normal, 5,
      "This accepts filename arguments; if an attacker " +
      "can move those files, a race condition results. ",
      "Use fchgrp( ) instead",
      "race", "", {}),
  "chmod":
     (normal, 5,
      "This accepts filename arguments; if an attacker " +
      "can move those files, a race condition results. ",
      "Use fchmod( ) instead",
      "race", "", {}),
  "vfork":
     (normal, 2,
      "On some old systems, vfork() permits race conditions, and it's " +
      "very difficult to use correctly",
      "Use fork() instead",
      "race", "", {}),
  "readlink":
     (normal, 5,
      "This accepts filename arguments; if an attacker " +
      "can move those files or change the link content, " +
      "a race condition results.  Also, it does not terminate with ASCII NUL",
      # This is often just a bad idea, and it's hard to suggest a
      # simple alternative:
      "Reconsider approach",
      "race", "", {'input' : 1}),

  "tmpfile":
     (normal, 2,
      "Function tmpfile() has a security flaw on some systems (e.g., older System V systems)",
      "",
      "tmpfile", "", {}),
  "tmpnam|tempnam":
     (normal, 3,
      "Temporary file race condition",
      "",
      "tmpfile", "avoid-race", {}),

  # TODO: Detect GNOME approach to mktemp and ignore it.
  "mktemp":
     (normal, 4,
      "Temporary file race condition",
      "",
      "tmpfile", "avoid-race", {}),

  "mkstemp":
     (normal, 2,
     "Potential for temporary file vulnerability in some circumstances.  Some older Unix-like systems create temp files with permission to write by all by default, so be sure to set the umask to override this. Also, some older Unix systems might fail to use O_EXCL when opening the file, so make sure that O_EXCL is used by the library",
      "",
      "tmpfile", "avoid-race", {}),

  "fopen|open":
     (normal, 2,
     "Check when opening files - can an attacker redirect it (via symlinks), force the opening of special file type (e.g., device files), move things around to create a race condition, control its ancestors, or change its contents?",
      "",
      "misc", "", {}),

  "umask":
     (normal, 1,
      "Ensure that umask is given most restrictive possible setting (e.g., 066 or 077)",
      "",
      "access", "", {}),

  # Windows.  TODO: Detect correct usage approaches and ignore it.
  "GetTempFileName":
     (normal, 3,
      "Temporary file race condition in certain cases " +
        "(e.g., if run as SYSTEM in many versions of Windows)",
      "",
      "tmpfile", "avoid-race", {}),

  # TODO: Need to detect varying levels of danger.
  "execl|execlp|execle|execv|execvp|system|popen|WinExec|ShellExecute":
     (normal, 4,
      "This causes a new program to execute and is difficult to use safely",
      "try using a library call that implements the same functionality " +
      "if available",
      "shell", "", {}),

  # TODO: Need to detect varying levels of danger.
  "execl|execlp|execle|execv|execvp|system|popen|WinExec|ShellExecute":
     (normal, 4,
      "This causes a new program to execute and is difficult to use safely",
      "try using a library call that implements the same functionality " +
      "if available",
      "shell", "", {}),

  # TODO: Be more specific.  The biggest problem involves "first" param NULL,
  # second param with embedded space. Windows.
  "CreateProcessAsUser|CreateProcessWithLogon":
     (normal, 3,
      "This causes a new process to execute and is difficult to use safely",
      "Especially watch out for embedded spaces",
      "shell", "", {}),

  # TODO: Be more specific.  The biggest problem involves "first" param NULL,
  # second param with embedded space. Windows.
  "CreateProcess":
     (c_hit_if_null, 3,
      "This causes a new process to execute and is difficult to use safely",
      "Specify the application path in the first argument, NOT as part of the second, " +
        "or embedded spaces could allow an attacker to force a different program to run",
      "shell", "", {'check_for_null' : 1}),

  "atoi|atol":
     (normal, 2,
      "Unless checked, the resulting number can exceed the expected range",
      " If source untrusted, check both minimum and maximum, even if the" +
      " input had no minus sign (large numbers can roll over into negative" +
      " number; consider saving to an unsigned value if that is intended)",
      "integer", "dangers-c", {}),

  # Random values.  Don't trigger on "initstate", it's too common a term.
  "drand48|erand48|jrand48|lcong48|lrand48|mrand48|nrand48|random|seed48|setstate|srand|strfry|srandom":
     (normal, 3,
      "This function is not sufficiently random for security-related functions such as key and nonce creation",
      "use a more secure technique for acquiring random values",
      "random", "", {}),

  "crypt":
     (normal, 4,
      "Function crypt is a poor one-way hashing algorithm; since it only accepts passwords of 8 " +
        "characters or less, and only a two-byte salt, it is excessively vulnerable to " +
        "dictionary attacks given today's faster computing equipment",
      "Use a different algorithm, such as SHA-1, with a larger non-repeating salt",
      "crypto", "", {}),

  # OpenSSL EVP calls to use DES.
  "EVP_des_ecb|EVP_des_cbc|EVP_des_cfb|EVP_des_ofb|EVP_desx_cbc":
     (normal, 4,
      "DES only supports a 56-bit keysize, which is too small given today's computers",
      "Use a different patent-free encryption algorithm with a larger keysize, " +
         "such as 3DES or AES",
      "crypto", "", {}),

  # Other OpenSSL EVP calls to use small keys.
  "EVP_rc4_40|EVP_rc2_40_cbc|EVP_rc2_64_cbc":
     (normal, 4,
      "These keysizes are too small given today's computers",
      "Use a different patent-free encryption algorithm with a larger keysize, " +
        "such as 3DES or AES",
      "crypto", "", {}),

  "chroot":
     (normal, 3,
      "chroot can be very helpful, but is hard to use correctly",
      "Make sure the program immediately chdir(\"/\")," +
      " closes file descriptors," +
      " and drops root privileges, and that all necessary files" +
      " (and no more!) are in the new root",
      "misc", "", {}),

  "getenv|curl_getenv":
     (normal, 3, "Environment variables are untrustable input if they can be" +
                 " set by an attacker.  They can have any content and" +
                 " length, and the same variable can be set more than once",
      "Check environment variables carefully before using them",
      "buffer", "", {'input' : 1}),

  "g_get_home_dir":
     (normal, 3, "This function is synonymous with 'getenv(\"HOME\")';" +
                 "it returns untrustable input if the environment can be" +
                 "set by an attacker.  It can have any content and length, " +
                 "and the same variable can be set more than once",
      "Check environment variables carefully before using them",
      "buffer", "", {'input' : 1}),

  "g_get_tmp_dir":
     (normal, 3, "This function is synonymous with 'getenv(\"TMP\")';" +
                 "it returns untrustable input if the environment can be" +
                 "set by an attacker.  It can have any content and length, " +
                 "and the same variable can be set more than once",
      "Check environment variables carefully before using them",
      "buffer", "", {'input' : 1}),


  # These are Windows-unique:

  # TODO: Should have lower risk if the program checks return value.
  "RpcImpersonateClient|ImpersonateLoggedOnUser|CoImpersonateClient|" +
     "ImpersonateNamedPipeClient|ImpersonateDdeClientWindow|ImpersonateSecurityContext|" +
     "SetThreadToken":
     (normal, 4, "If this call fails, the program could fail to drop heightened privileges",
      "Make sure the return value is checked, and do not continue if a failure is reported",
      "access", "", {}),

  "InitializeCriticalSection":
     (normal, 3, "Exceptions can be thrown in low-memory situations",
      "Use InitializeCriticalSectionAndSpinCount instead",
      "misc", "", {}),

  "EnterCriticalSection":
     (normal, 3, "On some versions of Windows, exceptions can be thrown in low-memory situations",
      "Use InitializeCriticalSectionAndSpinCount instead",
      "misc", "", {}),

  "LoadLibrary|LoadLibraryEx":
     (normal, 3, "Ensure that the full path to the library is specified, or current directory may be used",
      "Use registry entry or GetWindowsDirectory to find library path, if you aren't already",
      "misc", "", {'input' : 1}),

  "SetSecurityDescriptorDacl":
     (c_hit_if_null, 5,
      "Never create NULL ACLs; an attacker can set it to Everyone (Deny All Access), " +
        "which would even forbid administrator access",
      "",
      "misc", "", {'check_for_null' : 3}),

  "AddAccessAllowedAce":
     (normal, 3,
      "This doesn't set the inheritance bits in the access control entry (ACE) header",
      "Make sure that you set inheritance by hand if you wish it to inherit",
      "misc", "", {}),

  "getlogin":
     (normal, 4,
      "It's often easy to fool getlogin.  Sometimes it does not work at all, because some program messed up the utmp file.  Often, it gives only the first 8 characters of the login name. The user currently logged in on the controlling tty of our program need not be the user who started it.  Avoid getlogin() for security-related purposes",
      "Use getpwuid(geteuid()) and extract the desired information instead",
      "misc", "", {}),

  "cuserid":
     (normal, 4,
      "Exactly what cuserid() does is poorly defined (e.g., some systems use the effective uid, like Linux, while others like System V use the real uid). Thus, you can't trust what it does. It's certainly not portable (The cuserid function was included in the 1988 version of POSIX, but removed from the 1990 version).  Also, if passed a non-null parameter, there's a risk of a buffer overflow if the passed-in buffer is not at least L_cuserid characters long",
      "Use getpwuid(geteuid()) and extract the desired information instead",
      "misc", "", {}),

  "getpw":
     (normal, 4,
      "This function is dangerous; it may overflow the provided buffer. It extracts data from a 'protected' area, but most systems have many commands to let users modify the protected area, and it's not always clear what their limits are.  Best to avoid using this function altogether",
      "Use getpwuid() instead",
      "buffer", "", {}),

  "getpass":
     (normal, 4,
      "This function is obsolete and not portable. It was in SUSv2 but removed by POSIX.2.  What it does exactly varies considerably between systems, particularly in where its prompt is displayed and where it gets its data (e.g., /dev/tty, stdin, stderr, etc.)",
      "Make the specific calls to do exactly what you want.  If you continue to use it, or write your own, be sure to zero the password as soon as possible to avoid leaving the cleartext password visible in the process' address space",
      "misc", "", {}),

  "gsignal|ssignal":
     (normal, 2,
      "These functions are considered obsolete on most systems, and very non-portable (Linux-based systems handle them radically different, basically if gsignal/ssignal were the same as raise/signal respectively, while System V considers them a separate set and obsolete)",
      "Switch to raise/signal, or some other signalling approach",
      "obsolete", "", {}),

  "memalign":
     (normal, 1,
     "On some systems (though not Linux-based systems) an attempt to free() results from memalign() may fail. This may, on a few systems, be exploitable.  Also note that memalign() may not check that the boundary parameter is correct",
      "Use posix_memalign instead (defined in POSIX's 1003.1d).  Don't switch to valloc(); it is marked as obsolete in BSD 4.3, as legacy in SUSv2, and is no longer defined in SUSv3.  In some cases, malloc()'s alignment may be sufficient",
      "free", "", {}),

  "ulimit":
     (normal, 1,
     "This C routine is considered obsolete (as opposed to the shell command by the same name, which is NOT obsolete)",
      "Use getrlimit(2), setrlimit(2), and sysconf(3) instead",
      "obsolete", "", {}),

  "usleep":
     (normal, 1,
     "This C routine is considered obsolete (as opposed to the shell command by the same name).   The interaction of this function with SIGALRM and other timer functions such as sleep(), alarm(), setitimer(), and nanosleep() is unspecified",
      "Use nanosleep(2) or setitimer(2) instead",
      "obsolete", "", {}),


   # Input functions, useful for -I
  "recv|recvfrom|recvmsg|fread|readv":
     (normal, 0, "Function accepts input from outside program",
      "Make sure input data is filtered, especially if an attacker could manipulate it",
      "input", "", {'input' : 1}),


  # TODO: detect C++'s:   cin >> charbuf, where charbuf is a char array; the problem
  #       is that flawfinder doesn't have type information, and ">>" is safe with
  #       many other types.
  # ("send" and friends aren't todo, because they send out.. not input.)
  # TODO: cwd("..") in user's space - TOCTOU vulnerability
  # TODO: There are many more rules to add, esp. for TOCTOU.
  }

template_ruleset = {
  # This is a template for adding new entries (the key is impossible):
  "9":
     (normal, 2,
      "",
      "",
      "tmpfile", "", {}),
  }


def find_column(text, position):
  "Find column number inside line."
  newline = string.rfind(text, "\n", 0, position)
  if newline == -1:
    return position + 1
  else:
    return position - newline

def get_context(text, position):
  "Get surrounding text line starting from text[position]"
  linestart = string.rfind(text, "\n", 0, position+1) + 1
  lineend   = string.find(text, "\n", position, len(text))
  if lineend == -1: lineend = len(text)
  return text[linestart:lineend]

def c_valid_match(text, position):
  # Determine if this is a valid match, or a false positive.
  # If false positive controls aren't on, always declare it's a match:
  i = position
  while i < len(text):
    c = text[i]
    if c == '(':                 return 1
    elif c in string.whitespace: i = i + 1
    else:
      if falsepositive: return 0       # No following "(", presume invalid.
      if c in "=+-":
        # This is very unlikely to be a function use. If c is '=',
        # the name is followed by an assignment or is-equal operation.
        # Since the names of library functions are really unlikely to be
        # followed by an assignment statement or 'is-equal' test,
        # while this IS common for variable names, let's declare it invalid.
        # It's possible that this is a variable function pointer, pointing
        # to the real library function, but that's really improbable.
        # If c is "+" or "-", we have a + or - operation.
        # In theory "-" could be used for a function pointer difference
        # computation, but this is extremely improbable.
        # More likely: this is a variable in a computation, so drop it.
        return 0
      return 1
  return 0 # Never found anything other than "(" and whitespace.

def process_directive():
  "Given a directive, process it."
  global ignoreline, num_ignored_hits
  # TODO: Currently this is just a stub routine that simply removes
  # hits from the current line, if any, and sets a flag if not.
  # Thus, any directive is considered the "ignore" directive.
  # Currently that's okay because we don't have any other directives yet.
  if never_ignore: return
  hitfound = 0
  # Iterate backwards over hits, to be careful about the destructive iterator
  for i in xrange(len(hitlist)-1, -1, -1):
    if hitlist[i].line == linenumber:
      del hitlist[i] # DESTROY - this is a DESTRUCTIVE iterator.
      hitfound = 1   # Don't break, because there may be more than one.
      num_ignored_hits = num_ignored_hits + 1
  if not hitfound:
    ignoreline = linenumber + 1  # Nothing found - ignore next line.

# Characters that can be in a string.
# 0x4, 4.4e4, etc.
numberset=string.hexdigits+"_x.Ee"

# Patterns for various circumstances:
p_whitespace = re.compile( r'[ \t\v\f]+' )
p_include = re.compile( r'#\s*include\s+(<.*?>|".*?")' )
p_digits  = re.compile( r'[0-9]' )
p_alphaunder = re.compile( r'[A-Za-z_]' )  # Alpha chars and underline.
# A "word" in C.  Note that "$" is permitted -- it's not permitted by the
# C standard in identifiers, but gcc supports it as an extension.
p_c_word = re.compile( r'[A-Za-z_][A-Za-z_0-9$]*' )
# We'll recognize ITS4 and RATS ignore directives, as well as our own,
# for compatibility's sake:
p_directive = re.compile( r'(?i)\s*(ITS4|Flawfinder|RATS):\s*([^\*]*)' )

max_lookahead=500  # Lookahead limit for c_static_array.

def process_c_file(f, patch_infos):
  global filename, linenumber, ignoreline, sumlines, num_links_skipped
  global sloc
  filename=f
  linenumber = 1
  ignoreline = -1

  incomment = 0
  instring = 0
  linebegin = 1
  codeinline = 0 # 1 when we see some code (so increment sloc at newline)

  if ((patch_infos != None) and (not patch_infos.has_key(f))):
    # This file isn't in the patch list, so don't bother analyzing it.
    if not quiet:
      if output_format:
        print "Skipping unpatched file ", h(f), "<br>"
      else:
        print "Skipping unpatched file", f
      sys.stdout.flush()
    return

  if f == "-":
   input = sys.stdin
  else:
    # Symlinks should never get here, but just in case...
    if ((not allowlink) and os.path.islink(f)):
      print "BUG! Somehow got a symlink in process_c_file!"
      num_links_skipped = num_links_skipped + 1
      return
    try:
      input = open(f, "r")
    except:
      print "Error: failed to open", h(f)
      sys.exit(1)

  # Read ENTIRE file into memory.  Use readlines() to convert \n if necessary.
  # This turns out to be very fast in Python, even on large files, and it
  # eliminates lots of range checking later, making the result faster.
  # We're examining source files, and today, it would be EXTREMELY bad practice
  # to create source files larger than main memory space.
  # Better to load it all in, and get the increased speed and reduced
  # development time that results.

  if not quiet:
    if output_format:
      print "Examining", h(f), "<br>"
    else:
      print "Examining", f
    sys.stdout.flush()

  text = string.join(input.readlines(),"")

  i = 0
  while i < len(text):
    # This is a trivial tokenizer that just tries to find "words", which
    # match [A-Za-z_][A-Za-z0-9_]*.  It skips comments & strings.
    # It also skips "#include <...>", which must be handled specially
    # because "<" and ">" aren't usually delimiters.
    # It doesn't bother to tokenize anything else, since it's not used.
    # The following is a state machine with 3 states: incomment, instring,
    # and "normal", and a separate state "linebegin" if at BOL.

    # Skip any whitespace
    m = p_whitespace.match(text,i)
    if m:
      i = m.end(0)

    c = text[i]
    if linebegin:  # If at beginning of line, see if #include is there.
       linebegin = 0
       if c == "#": codeinline = 1  # A directive, count as code.
       m = p_include.match(text,i)
       if m:  # Found #include, skip it.  Otherwise: #include <stdio.h>
         i = m.end(0)
         continue
    if c == "\n":
      linenumber = linenumber + 1
      sumlines = sumlines + 1
      linebegin = 1
      if codeinline: sloc = sloc + 1
      codeinline = 0
      i = i +1
      continue
    i = i + 1   # From here on, text[i] points to next character.
    if i < len(text): nextc = text[i]
    else:             nextc = ''
    if incomment:
       if c=='*' and nextc=='/':
           i = i + 1
           incomment = 0
    elif instring:
       if c == '\\' and (nextc != "\n"): i = i + 1
       elif c == '"' and instring == 1: instring = 0
       elif c == "'" and instring == 2: instring = 0
    else:
      if c=='/' and nextc=='*':
          m = p_directive.match(text, i+1)  # Is there a directive here?
          if m:
            process_directive()
          i = i + 1
          incomment = 1
      elif c=='/' and nextc=='/':  # "//" comments - skip to EOL.
          m = p_directive.match(text, i+1)  # Is there a directive here?
          if m:
            process_directive()
          while i<len(text) and text[i] != "\n":
            i = i + 1
      elif c=='"':
          instring = 1
          codeinline = 1
      elif c=="'":
          instring = 2
          codeinline = 1
      else:
          codeinline = 1  # It's not whitespace, comment, or string.
          m = p_c_word.match(text, i-1)
          if m:                        # Do we have a word?
            startpos=i-1
            endpos = m.end(0)
            i = endpos
            word = text[startpos:endpos]
            # print "Word is:", text[startpos:endpos]
            if c_ruleset.has_key(word) and c_valid_match(text, endpos):
              if ( (patch_infos == None) or ((patch_infos != None) and patch_infos[f].has_key(linenumber))):
        	# FOUND A MATCH, setup & call hook.
        	# print "HIT: #%s#\n" % word
        	# Don't use the tuple assignment form, e.g., a,b=c,d
        	# because Python (least 2.2.2) does that slower
        	# (presumably because it creates & destroys temporary tuples)
        	hit = Hit(c_ruleset[word])
        	hit.name = word
        	hit.start = startpos
        	hit.end = endpos
        	hit.line = linenumber
        	hit.column = find_column(text, startpos)
        	hit.filename=filename
        	hit.context_text = get_context(text, startpos)
        	hit.parameters = extract_c_parameters(text, endpos)
        	if hit.extract_lookahead:
        	  hit.lookahead = text[startpos:startpos+max_lookahead]
        	apply(hit.hook, (hit, ))
          elif p_digits.match(c):
            while i<len(text) and p_digits.match(text[i]): # Process a number.
              i = i + 1
          # else some other character, which we ignore.
  # End of loop through text. Wrap up.
  if codeinline: sloc = sloc + 1
  if incomment: error("File ended while in comment.")
  if instring: error("File ended while in string.")

def expand_ruleset(ruleset):
  # Rulesets can have compressed sets of rules
  # (multiple function names separated by "|".
  # Expand the given ruleset.
  # Note that this for loop modifies the ruleset while it's iterating!
  for rule in ruleset.keys():
    if string.find(rule, "|") != -1:  # We found a rule to expand.
      for newrule in string.split(rule, "|"):
        if ruleset.has_key(newrule):
          print "Error: Rule %s, when expanded, overlaps %s" % ( rule, newrule )
          sys.exit(1)
        ruleset[newrule] = ruleset[rule]
      del ruleset[rule]
  # To print out the set of keys in the expanded ruleset, run:
  #   print `ruleset.keys()`

def display_ruleset(ruleset):
  # First, sort the list by function name:
  sortedkeys = ruleset.keys()
  sortedkeys.sort()
  # Now, print them out:
  for key in sortedkeys:
    print key, ruleset[key][1] # function name and default level.

def initialize_ruleset():
  expand_ruleset(c_ruleset)
  if showheading:
    print "Number of dangerous functions in C/C++ ruleset:", len(c_ruleset)
    if output_format: print "<p>"
  if list_rules:
    display_ruleset(c_ruleset)
    sys.exit(0)


# Show the header, but only if it hasn't been shown yet.
def display_header():
  global displayed_header
  if not showheading: return
  if not displayed_header:
    if output_format:
      print ('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" ' +
            '"http://www.w3.org/TR/html4/loose.dtd">')
      print "<html>"
      print "<head>"
      print '<meta http-equiv="Content-type" content="text/html; charset=utf8">'
      print "<title>Flawfinder Results</title>"
      print '<meta name="author" content="David A. Wheeler">'
      print '<meta name="keywords" lang="en" content="flawfinder results, security scan">'
      print "</head>"
      print "<body>"
      print "<h1>Flawfinder Results</h1>"
      print "Here are the security scan results from"
      print '<a href="http://www.dwheeler.com/flawfinder">Flawfinder version %s</a>,' % version
      print '(C) 2001-2004 <a href="http://www.dwheeler.com">David A. Wheeler</a>.'
    else:
      print "Flawfinder version %s, (C) 2001-2004 David A. Wheeler." % version
    displayed_header = 1


c_extensions = { '.c' : 1, '.h' : 1,
                 '.ec': 1, '.ecp': 1,  # Informix embedded C.
                 '.pgc': 1,            # Postgres embedded C.
                 '.C': 1, '.cpp': 1, '.CPP': 1, '.cxx': 1, '.cc': 1, # C++
                 '.CC' : 1, '.c++' :1,  # C++.
                 '.pcc': 1,            # Oracle C++
                 '.hpp': 1, '.H' : 1,  # .h - usually C++.
               }


def maybe_process_file(f, patch_infos):
  # process f, but only if (1) it's a directory (so we recurse), or
  # (2) it's source code in a language we can handle.
  # Currently, for files that means only C/C++, and we check if the filename
  # has a known C/C++ filename extension.  If it doesn't, we ignore the file.
  # We accept symlinks only if allowlink is true.
  global num_links_skipped, num_dotdirs_skipped
  if os.path.isdir(f):
    if (not allowlink) and os.path.islink(f):
      if not quiet: print "Warning: skipping symbolic link directory", h(f)
      num_links_skipped = num_links_skipped + 1
      return
    base_filename = os.path.basename(f)
    if (skipdotdir and len(base_filename) > 0 and ("." == base_filename[0])):
      if not quiet: print "Warning: skipping directory with initial dot", h(f)
      num_dotdirs_skipped = num_dotdirs_skipped + 1
      return
    for file in os.listdir(f):
      maybe_process_file(os.path.join(f, file), patch_infos)
  # Now we will FIRST check if the file appears to be a C/C++ file, and
  # THEN check if it's a regular file or symlink.  This is more complicated,
  # but I do it this way so that there won't be a lot of pointless
  # warnings about skipping files we wouldn't have used anyway.
  dotposition = string.rfind(f, ".")
  if dotposition > 1:
    extension = f[dotposition:]
    if c_extensions.has_key(extension):
      # Its name appears to be a C/C++ source code file.
      if (not allowlink) and os.path.islink(f):
        if not quiet: print "Warning: skipping symbolic link file", h(f)
        num_links_skipped = num_links_skipped + 1
      elif not os.path.isfile(f):
        # Skip anything not a normal file.  This is so that
        # device files, etc. won't cause trouble.
        if not quiet: print "Warning: skipping non-regular file", h(f)
      else:
        # We want to know the difference only with files found in the patch.
        if ( (patch_infos == None) or (patch_infos != None and patch_infos.has_key(f) == True) ):
          process_c_file(f, patch_infos)


def process_file_args(files, patch_infos):
  # Process the list of "files", some of which may be directories,
  # which were given on the command line.
  # This is handled differently than anything not found on the command line
  # (i.e. through recursing into a directory) because flawfinder
  # ALWAYS processes normal files given on the command line.
  # This is done to give users control over what's processed;
  # if a user really, really wants to analyze a file, name it!
  # If user wants to process "this directory and down", just say ".".
  # We handle symlinks specially, handle normal files and directories,
  # and skip the rest to prevent security problems. "-" is stdin.
  global num_links_skipped
  for f in files:
    if (not allowlink) and os.path.islink(f):
       if not quiet: print "Warning: skipping symbolic link", h(f)
       num_links_skipped = num_links_skipped + 1
    elif os.path.isfile(f) or f == "-":
       # If on the command line, FORCE processing of it.
       # Currently, we only process C/C++.
       # check if we only want to review a patch
       if ( (patch_infos != None and patch_infos.has_key(f) == True) or (patch_infos == None) ):
        process_c_file(f, patch_infos)
    elif os.path.isdir(f):
       # At one time flawfinder used os.path.walk, but that Python
       # built-in doesn't give us enough control over symbolic links.
       # So, we'll walk the filesystem hierarchy ourselves:
       maybe_process_file(f, patch_infos)
    else:
       if not quiet: print "Warning: skipping non-regular file", h(f)

def usage():
  print """
flawfinder [--help] [--context]  [-c]  [--columns | -C] [--html]
           [--dataonly | -D]
           [--minlevel=X | -m X]
           [--immediate] [-i] [--inputs | -I] [--neverignore | -n]
           [ --patch=F ] [--quiet | -Q] [--singleline | -S ]
           [--loadhitlist=F ] [ --savehitlist=F ] [ --diffhitlist=F ]
           [--listrules]
           [--] [ source code file or source root directory ]+

  --help      Show this usage help

  --allowlink
              Allow symbolic links.
  --followdotdir
              Follow directories whose names begin with ".".

  --context
  -c          Show context (the line having the "hit"/potential flaw)

  --columns   Show  the  column  number  (as well as the file name and
              line number) of each hit; this is shown after the line number
              by adding a colon and the column number in the line (the first
              character in a line is column number 1).

  --html      Display as HTML output.

  -m X
  --minlevel=X
              Set minimum risk level to X for inclusion in hitlist.  This
              can be from 0 (``no risk'')  to  5  (``maximum  risk'');  the
              default is 1.

  -S
  --singleline Single-line output.

  --neverignore
  -n          Never ignore security issues, even if they have an ``ignore''
              directive in a comment.

  --immediate
  -i          Immediately display hits (don't just wait until the end).

  --inputs    Show only functions that obtain data from outside the program;
  -I          this also sets minlevel to 0.

  --nolink    Skip symbolic links (ignored).

  --omittime  Omit time to run.

  --patch=F   display information related to the patch F. (patch must be already applied)

  --Q
  --quiet     Don't display status information (i.e., which files are being
              examined) while the analysis is going on.

  --D
  --dataonly  Don't display the headers and footers of the analysis;
              use this along with --quiet to get just the results.

  --listrules List the rules in the ruleset (rule database).

  --loadhitlist=F
              Load hits from F instead of analyzing source programs.

  --savehitlist=F
              Save all hits (the "hitlist") to F.

  --diffhitlist=F
              Show only hits (loaded or analyzed) not in F.


  For more information, please consult the manpage or available
  documentation.
"""

def process_options():
  global show_context, show_inputs, allowlink, skipdotdir, omit_time
  global output_format, minimum_level, show_immediately, single_line
  global falsepositive
  global show_columns, never_ignore, quiet, showheading, list_rules
  global loadhitlist, savehitlist, diffhitlist
  global patch_file
  try:
    # Note - as a side-effect, this sets sys.argv[].
    optlist, args = getopt.getopt(sys.argv[1:], "cm:nih?CSDQIFP:",
                    ["context", "minlevel=", "immediate", "inputs", "input",
                     "nolink", "falsepositive", "falsepositives",
                     "columns", "listrules", "omittime", "allowlink", "patch=",
                     "followdotdir",
                     "neverignore", "quiet", "dataonly", "html", "singleline",
                     "loadhitlist=", "savehitlist=", "diffhitlist=",
                     "version", "help" ])
    for (opt,value) in optlist:
      if   opt == "--context" or opt == "-c":
        show_context = 1
      elif opt == "--columns" or opt == "-C":
        show_columns = 1
      elif opt == "--quiet" or opt == "-Q":
        quiet = 1
      elif opt == "--dataonly" or opt == "-D":
        showheading = 0
      elif opt == "--inputs" or opt == "--input" or opt == "-I":
        show_inputs = 1
        minimum_level = 0
      elif opt == "--falsepositive" or opt == "falsepositives" or opt == "-F":
        falsepositive = 1
      elif opt == "--nolink":
        allowlink = 0
      elif opt == "--omittime":
        omit_time = 1
      elif opt == "--allowlink":
        allowlink = 1
      elif opt == "--followdotdir":
        skipdotdir = 0
      elif opt == "--listrules":
        list_rules = 1
      elif opt == "--html":
        output_format = 1
        single_line = 0
      elif opt == "--minlevel" or opt == "-m":
        minimum_level = string.atoi(value)
      elif opt == "--singleline" or opt == "-S":
        single_line = 1
      elif opt == "--immediate" or opt == "-i":
        show_immediately = 1
      elif opt == "-n" or opt == "--neverignore":
        never_ignore = 1
      elif opt == "-P" or opt == "--patch":
        # Note: This is -P, so that a future -p1 option can strip away
        # pathname prefixes (with the same option name as "patch").
        patch_file = value
        # If we consider ignore comments we may change a line which was
        # previously ignored but which will raise now a valid warning without
        # noticing it now.  So, set never_ignore.
        never_ignore = 1
      elif opt == "--loadhitlist":
        loadhitlist = value
        display_header()
        if showheading: print "Loading hits from", value
      elif opt == "--savehitlist":
        savehitlist = value
        display_header()
        if showheading: print "Saving hitlist to", value
      elif opt == "--diffhitlist":
        diffhitlist = value
        display_header()
        if showheading: print "Showing hits not in", value
      elif opt == "--version":
        print version
        sys.exit(0)
      elif opt in [ '-h', '-?', '--help' ]:
        usage()
        sys.exit(0)
    # For DOS/Windows, expand filenames; for Unix, DON'T expand them
    # (the shell will expand them for us).  Some sloppy Python programs
    # always call "glob", but that's WRONG -- on Unix-like systems that
    # will expand twice.  Python doesn't have a clean way to detect
    # "has globbing occurred", so this is the best I've found:
    if os.name == "windows" or os.name == "nt" or os.name == "dos":
       sys.argv[1:] = reduce(operator.add, map(glob.glob, args))
    else:
       sys.argv[1:] = args
  # In Python 2 the convention is "getopt.GetoptError", but we
  # use "getopt.error" here so it's compatible with both
  # Python 1.5 and Python 2.
  except getopt.error, text:
    print "*** getopt error:", text
    usage()
    sys.exit(1)



def process_files():
  global hitlist
  if loadhitlist:
    f = open(loadhitlist)
    hitlist = pickle.load(f)
  else:
    patch_infos = None
    if (patch_file != ""):
      patch_infos = load_patch_info(patch_file)
    files = sys.argv[1:]
    if not files:
        print "*** No input files"
        return None
    process_file_args(files, patch_infos)
    return 1


def show_final_results():
  global hitlist
  count = 0
  count_per_level = {}
  count_per_level_and_up = {}
  for i in range(0,6):  # Initialize count_per_level
    count_per_level[i] = 0
  for i in range(0,6):  # Initialize count_per_level
    count_per_level_and_up[i] = 0
  if show_immediately:   # Separate the final results.
    print
    if showheading:
      if output_format:
        print "<h1>Final Results</h1>"
      else:
        print "FINAL RESULTS:"
        print
  hitlist.sort()
  # Display results.  The HTML format now uses
  # <ul> so that the format differentiates each entry.
  # I'm not using <ol>, because its numbers might be confused with
  # the risk levels or line numbers.
  if diffhitlist:
    diff_file = open(diffhitlist)
    diff_hitlist = pickle.load(diff_file)
    if output_format: print "<ul>"
    for h in hitlist:
      if h not in diff_hitlist:
        h.show()
        count_per_level[h.level] = count_per_level[h.level] + 1
        count = count + 1
    if output_format: print "</ul>"
    diff_file.close()
    if showheading:
      if output_format:
        print "<p>"
      if count > 0:
        print "Hits not in original histlist =", count
      else:
        print "No hits found that weren't already in the hitlist."
      if output_format:
        print "<br>"
  else:
    if output_format: print "<ul>"
    for h in hitlist:
      h.show()
      count_per_level[h.level] = count_per_level[h.level] + 1
    if output_format: print "</ul>"
    count = len(hitlist)
    if showheading:
      if output_format:
        print "<p>"
      else:
        print
      if count > 0:
        print "Hits =", count
      else:
        print "No hits found."
      if output_format:
        print "<br>"
  if showheading:
    # Compute the amount of time spent, and lines analyzed/second.
    # By computing time here, we also include the time for
    # producing the list of hits, which is reasonable.
    time_analyzing = time.time() - starttime
    print "Lines analyzed = %d" % sumlines,
    if time_analyzing > 0 and not omit_time:  # Avoid divide-by-zero.
      print "in %.2f seconds (%d lines/second)" % (
             time_analyzing + 0.5,
             (int) (sumlines / time_analyzing + 0.5) )
    else:
      print
    if output_format: print "<br>"
    print "Physical Source Lines of Code (SLOC) = %d" % sloc
    if output_format: print "<br>"
    # Output hits@each level.
    print "Hits@level =",
    for i in range(0,6):
      print "[%d] %3d" % (i, count_per_level[i]),
    if output_format:
      print "<br>"
    else:
      print
    # Compute hits at "level x or higher"
    print "Hits@level+ =",
    for i in range(0,6):
      for j in range(i,6):
        count_per_level_and_up[i] = count_per_level_and_up[i] + count_per_level[j]
    # Display hits at "level x or higher"
    for i in range(0,6):
      print "[%d+] %3d" % (i, count_per_level_and_up[i]),
    if output_format:
      print "<br>"
    else:
      print
    if (sloc > 0):
      print "Hits/KSLOC@level+ =",
      for i in range(0,6):
        print "[%d+] %3g" % (i, count_per_level_and_up[i]*1000.0/sloc),
    if output_format:
      print "<br>"
    else:
      print
    #
    if num_links_skipped:
      print "Symlinks skipped =", num_links_skipped, "(--allowlink overrides but see doc for security issue)"
      if output_format:
        print "<br>"
    if num_dotdirs_skipped:
      print "Dot directories skipped =", num_dotdirs_skipped, "(--followdotdir overrides)"
      if output_format:
        print "<br>"
    if num_ignored_hits > 0:
      print "Suppressed hits =", num_ignored_hits, "(use --neverignore to show them)"
      if output_format:
        print "<br>"
    print "Minimum risk level = %d" % minimum_level
    if output_format: print "<br>"
    if count > 0:
       print "Not every hit is necessarily a security vulnerability."
       if output_format:
         print "<br>"
    print "There may be other security vulnerabilities; review your code!"
    if output_format:
      print "</body>"
      print "</html>"


def save_if_desired():
  # We'll save entire hitlist, even if only differences displayed.
  if savehitlist:
    print "Saving hitlist to", savehitlist
    f = open(savehitlist, "w")
    pickle.dump(hitlist, f)
    f.close()

def flawfind():
  process_options()
  display_header()
  initialize_ruleset()
  if process_files():
    show_final_results()
    save_if_desired()

if __name__ == '__main__':
  try:
    flawfind()
  except KeyboardInterrupt:
    print "*** Flawfinder interrupted"

blob
data 3070
      program brlcad

c     This is really a pointer to a BRL-CAD data structure.  With the advent
c     of FORTRAN-90 perhaps it should be declared as such.
      integer*8 rtip

c     flag: did frtree fail to read the geometry?
      integer*8 fail

c     The number of hit locations we want returned to us
      integer*8 nloc

c     These next 4 are for the values we get when we shoot a ray
      REAL*8  indist(3)
      REAL*8  outdist(3)
      integer*8 region_ids(3)

c     we need six double-precision floating point values for context
c     for each possible result.  Since we are accepting 3 partitions
c     (the dimension of the arrays above) we need 3*6 = 18 values
c     for our context array.
c
c     Historically, this was done this way.  It can also be done as a
c     common block.  With the advent of FORTRAN-90 it could even be made
c     to resemble the C data structure that is actually being represented:
c
c     struct context {
c	double		co_vpriv[3];
c	struct soltab	*co_stp;
c	char		*co_priv;
c	int		co_inflip;
c     };

      REAL*8  context(18)

c     The ray origin and direction
      REAL*8  pt(3)
      REAL*8  dir(3)

c     Open a BRL-CAD geometry file called 'model.g' for reading
c     The "7" is the length of the string 'model.g'
      call frdir(rtip, 'model.g', 7)
      if (rtip .eq. 0) then
	 stop
      end if


c     From the BRL-CAD geometry file, extract the geometry for the
c     object called 'all.g' (including everything that goes into making it)
c     The 5 is the length of the string 'all.g'
      call frtree(fail, rtip, 'all.g', 5)
      if (fail .ne. 0) then
	 stop
      end if

c     Prepare the geometry for ray-tracing
c     This allows the library to pre-compute certain often-used values,
c     and prepare the geometry for raytracing
      call frprep(rtip)

c     Now we are going to shoot rays.
c     for this example we will shoot only 2 rays
c     First we set the point for the ray origin
c     and the direction for the ray.
      pt(1) = -.50
      pt(2) = .50
      pt(3) = .50
      dir(1) = 1.0
      dir(2) = 0.0
      dir(3) = 0.0

c     nloc indicates how many "partitions" we want to compute
c     and are prepared to handle.
c     A partition consists of both an inhit and an outhit
      nloc = 3;

c     shoot the ray
      call frshot(nloc, indist, outdist, region_ids, context,
     1 rtip, pt, dir)

c     look to see how many things we hit and print them
      print *, 'number of partitions=',nloc
      if (nloc .gt. 0) then
	 do i=1,nloc
	    print *,indist(i),' --- ',outdist(i)
	 end do
      end if

c     change directions and shoot a different ray from the same origin
      dir(1) = 0.0
      dir(2) = 0.0
      dir(3) = 1.0

      nloc = 3;

c     shoot the ray
      call frshot(nloc, indist, outdist, region_ids, context,
     1 rtip, pt, dir)

c     look to see how many things we hit and print them
      print *, 'number of partitions=',nloc
      if (nloc .gt. 0) then
	 do i=1,nloc
	    print *,indist(i),' --- ',outdist(i)
	 end do
      end if

      stop
      end
blob
data 5453
{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fnil\fcharset77 Copperplate;\f1\fnil\fcharset77 Skia-Regular;\f2\fnil\fcharset77 Copperplate-Bold;
}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww9700\viewh6860\viewkind0
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f0\fs48 \cf0 BRL-CAD\
Copying and Distribution Terms\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f1\fs28 \cf0 \
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f0 \cf0 Copyright (c) 2005-2014 United States Government as represented by the U.S. Army Research Laboratory.  All Rights Reserved.
\f1 \
\
BRL-CAD is open source software controlled and maintained by the designated project developers and the US Army Research Laboratory.\
\
BRL-CAD is made available under the terms of the GNU Lesser General Public License (LGPL) version 2.1 as published by the Free Software Foundation.\
\
BRL-CAD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.\
\

\f2\b \ul Overview\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f1\b0 \cf0 \ulnone BRL-CAD consists primarily of libraries, applications, scripts, documentation, geometric models, images, and build infrastructure. The BRL-CAD libraries include the headers in the include/ directory as well as all of the directories that begin with the prefix "lib" in the src/ directory (e.g. src/librt/).  All of BRL-CAD's applications and libraries are covered by the terms of the GNU Lesser General Public License (LGPL) as published by the Free Software Foundation unless noted otherwise in the source files.\
\
Most of BRL-CAD's build infrastructure (i.e. files required by the GNU Build System such as the configure.ac and all Makefile.am files), a variety of scripts located in the misc/ and sh/ directories, and the testing infrastructure (scripts and resources) are provided either under the BSD license or are in the public domain.  Refer to each individual file for specific terms.\
\
BRL-CAD's documentation consists of manual pages located throughout the package, most of the files in the doc/ directory, and the top-level administrative project text files (e.g. README & AUTHORS).  Unless otherwise denoted, all of BRL-CAD's documentation is made available under the terms of the GNU Free Documentation License (GFDL) or, at your option, under the terms of the GNU Lesser General Public License (LGPL) version 2.1 as published by the Free Software Foundation.  Several older documents (e.g. published by the U.S. Government prior to being released as Open Source) are in the public domain.  Refer to each document and the original author(s) individually for specific terms.\
\
Unless previously described or otherwise already covered by another license, the BRL-CAD package is covered under the terms of the GNU Lesser General Public License (LGPL) version 2.1 as published by the Free Software Foundation.  This includes but is not limited to the applications, geometric models, images, and other resource data included in the BRL-CAD distribution.\
\
The full text of the GPL, LGPL, GFDL, and BSD license should be included in the source distribution of BRL-CAD in the doc/legal/ directory.  Refer to the full license text for more details, information, and implications of each license.\
\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f2\b \cf0 \ul \ulc0 3rd Party Components\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f1\b0 \cf0 \ulnone The BRL-CAD package utilizes and redistributes copies of several 3rd party source code, libraries, and/or applications.  Said 3rd party source code, libraries, and/or applications all retain their respective agreements, licenses, and copyrights and should be referred to individually for their specific terms.  \
\
When referring to BRL-CAD, its source code, documentation, and/or libraries, this is not meant to include or imply 3rd party source code, libraries, and/or applications unless specifically stated otherwise.\
\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f2\b \cf0 \ul Copyright\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f1\b0 \cf0 \ulnone All contributions to BRL-CAD have been provided under agreement.  By requiring all contributions be given back to the BRL-CAD developers, this agreement allows the BRL-CAD project to continue to grow unhindered.  As such, a majority of the source code is copyright by the United States Government.\
\
Authors and other BRL-CAD contributors must comply with the copyright and distribution terms for their respective contributions unless otherwise arranged.  The following copyright should be prominent in all BRL-CAD source contributions:\
\
  Copyright (c) 2005-2014 United States Government as represented by the U.S. Army Research Laboratory.  All Rights Reserved.\
\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f2\b \cf0 \ul Trademark\ulnone \
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f1\b0 \cf0 The word mark "BRL-CAD" and the "BRL-CAD Eagle" image are registered trademarks of the Department of the Army, United States Government. All rights are reserved.\
\
\pard\tx1440\tx2880\tx4320\tx5760\tx7200\ql\qnatural

\f2\b\fs36 \cf0 By continuing, you agree to the terms and conditions of the BRL-CAD distribution as detailed above.\
}
blob
data 2001
{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fnil\fcharset77 GillSans-BoldItalic;\f1\fnil\fcharset77 GillSans;\f2\fmodern\fcharset77 CourierNewPSMT;
\f3\fnil\fcharset77 GillSans-Italic;\f4\fmodern\fcharset77 CourierNewPS-BoldItalicMT;\f5\fmodern\fcharset77 Courier;
\f6\fmodern\fcharset77 Courier-Bold;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww8060\viewh7760\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf0 {{\NeXTGraphic brlcad_logo_tiny.png \width3040 \height2560
}}\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\i\b\fs72 \cf0 README
\fs36 \

\f1\i0\b0\fs28 This is BRL-CAD 7.24.0 for Mac OS X.  Please send any bugs, comments, questions, or suggestions to the project website.\

\fs22 \

\fs28 Project website:  \f2 http://sf.net/projects/brlcad/\

\f1 Main website:  \f2 http://brlcad.org\

\f1 \

\f3\i No modifications to the filesystem are made outside of
\f4\b\fs24 /usr/brlcad
\f1\i0\b0\fs28 \
\

\f0\i\b\fs32 Remember to add /usr/brlcad/bin to your path.
\f1\i0\b0\fs28 \

\fs20 \
For Bourne-shell-based shells (sh, bash, ash, zsh) add the following to your
\f5 ~/.profile
\f1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f2 \cf0 PATH=/usr/brlcad/bin:$PATH ; export PATH
\f1 \
\
For C-shell-based shells (csh, tcsh, etc.) add the following to your
\f6\b ~/.cshrc
\f1\b0 \

\f2 set path=( /usr/brlcad/bin:$PATH ) ; rehash
\f1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\fs28 \cf0 \
This distribution has been created with the assumption that Apple's X11 is installed.  X11 should be in the /Applications/Utilities folder.  Future versions may not have a dependency on Apple's X11 for the Mac OS X distribution.  Good luck and enjoy!\
\
Cheers!\
Christopher Sean Morrison\

\f2\fs24 morrison@brlcad.org
\f1\fs28 \
}
blob
data 779
{\rtf1\mac\ansicpg10000\cocoartf102
{\fonttbl\f0\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww8020\viewh6280\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs22 \cf0 This installer will guide you through the installation of BRL-CAD 7.24.0 for Mac OS X and Darwin.\
\
This distribution of BRL-CAD requires approximately 250 MB of available disk space and does not include source code.\
\
If you have an existing BRL-CAD installation, you are advised to backup any files you have in /usr/brlcad.  Any existing BRL-CAD installation will be overwritten.\

\fs10 \

\fs36 Select 'Continue' to proceed...{{\NeXTGraphic brlcad_logo_tiny.png \width3040 \height2560
}}}blob
data 2843
/*
 * Copyright (c) 2001 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code
 * as defined in and are subject to the
 * Apple
 * Public             ( quell
 * Source               ohloh
 * License              license
 * Version 1.1          detection )
 * (the "License").
 * You may not use this file except in compliance with the License.
 * Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT. Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Shantonu Sen
 * openUp.c - program to set the "first-open-window" field of a volume
 *
 * Get the directory ID for the first argument, and set it as word 2
 * of the Finder Info fields for the volume it lives on
 *
 * cc -o openUp openUp.c
 * Usage: openUp /Volumes/Foo/OpenMe/
 *
 * This program is used to cause a window to open up when a volume is
 * mounted.  This is particularly useful for disk images made with
 * DiskCopy, such as those often used for application installation.
 */

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/attr.h>
#include <sys/stat.h>
#include <sys/mount.h>

struct directoryinfo {
    unsigned long length;
    u_int32_t dirid;
};

struct volumeinfo {
    unsigned long length;
    u_int32_t finderinfo[8];
};

int main(int argc, char *argv[]) {

    char *path = NULL;
    struct attrlist alist;
    struct directoryinfo dirinfo;
    struct volumeinfo volinfo;
    struct statfs sfs;

    if (argc <= 1) {
	fprintf(stderr,"Usage: %s /Volumes/Foo/OpenMe/\n", argv[0]);
	exit(1);
    }

    path = argv[1];

    memset(&alist, 0, sizeof(alist));
    alist.bitmapcount = 5;
    alist.commonattr = ATTR_CMN_OBJID;

    getattrlist(path, &alist, &dirinfo, sizeof(dirinfo), 0);

    printf("directory id: %lu\n", dirinfo.dirid);

    statfs(path, &sfs);

    printf("mountpoint: %s\n", sfs.f_mntonname);

    alist.commonattr = ATTR_CMN_FNDRINFO;
    alist.volattr = ATTR_VOL_INFO;

    getattrlist(sfs.f_mntonname, &alist, &volinfo, sizeof(volinfo), 0);
    volinfo.finderinfo[2] = dirinfo.dirid;
    setattrlist(sfs.f_mntonname, &alist, volinfo.finderinfo, sizeof(volinfo.finderinfo), 0);

    return 0;
}

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 6816
; brlcad.nsi

RequestExecutionLevel user

;--------------------------------
;BRL-CAD Version Variables

!include VERSION.txt

;--------------------------------

; Modern User Interface
!include "MUI.nsh"
!include "FileFunc.nsh"
!include "WordFunc.nsh"

!insertmacro GetFileName
!insertmacro WordFind3X

Function .onInit
  ; For the moment this must be global (nsis requires it)
  Var /GLOBAL PROG_FILES

  ReadEnvStr $PROG_FILES "PROGRAMFILES"
  StrCpy $INSTDIR "$PROG_FILES\BRL-CAD\${VERSION}"
FunctionEnd

; Tack on BRL-CAD if it's not already there
Function .onVerifyInstDir
  ${GetFileName} $INSTDIR $R0
  StrCmp "BRL-CAD" $R0 found notFound

  notFound:
    ${WordFind3X} $INSTDIR "\" "BRL-CAD" " "  "+1" $R0
    StrCmp "BRL-CAD" $R0 found stillNotFound

  stillNotFound:
    StrCpy $INSTDIR "$INSTDIR\BRL-CAD"

  found:

FunctionEnd

;--------------------------------
;Configuration

  ; The name of the installer
  Name "BRL-CAD"

  ; The file to write
  OutFile "BRL-CAD_${VERSION}${INSTALLERSUFFIX}.exe"

  ; The default installation directory
  InstallDir $PROGRAMFILES\BRL-CAD\${VERSION}

  ; Make it look pretty in XP
  XPStyle on

;--------------------------------
;Variables

  Var MUI_TEMP
  Var STARTMENU_FOLDER
  Var BRLCAD_DATA_DIR

;--------------------------------
;Interface Settings

  ;Icons
  !define MUI_ICON "brlcad.ico"
  !define MUI_UNICON "uninstall.ico"

  ;Bitmaps
  !define MUI_WELCOMEFINISHPAGE_BITMAP "side.bmp"
  !define MUI_UNWELCOMEFINISHPAGE_BITMAP "side.bmp"

  !define MUI_HEADERIMAGE
  !define MUI_HEADERIMAGE_BITMAP "header.bmp"
  !define MUI_COMPONENTSPAGE_CHECKBITMAP "${NSISDIR}\Contrib\Graphics\Checks\simple-round2.bmp"

  !define MUI_COMPONENTSPAGE_SMALLDESC

  ;Show a warning before aborting install
  !define MUI_ABORTWARNING

;--------------------------------

; Pages

  ;Welcome page configuration
  !define MUI_WELCOMEPAGE_TEXT "This wizard will guide you through the installation of BRL-CAD ${VERSION}.\r\n\r\nBRL-CAD is a powerful cross-platform open source solid modeling system.\r\n\r\nSelect Next to continue."

  !insertmacro MUI_PAGE_WELCOME
  !insertmacro MUI_PAGE_LICENSE "..\..\COPYING"
  !insertmacro MUI_PAGE_COMPONENTS
  !insertmacro MUI_PAGE_DIRECTORY
  !insertmacro MUI_PAGE_STARTMENU Application $STARTMENU_FOLDER
  !insertmacro MUI_PAGE_INSTFILES

  ;Finished page configuration
  !define MUI_FINISHPAGE_NOAUTOCLOSE
  !define MUI_FINISHPAGE_SHOWREADME "..\..\README"
  !define MUI_FINISHPAGE_SHOWREADME_TEXT "View ReadMe"
  !define MUI_FINISHPAGE_SHOWREADME_NOTCHECKED

  !define MUI_FINISHPAGE_LINK "BRL-CAD Website"
  !define MUI_FINISHPAGE_LINK_LOCATION "http://brlcad.org/"

  !insertmacro MUI_PAGE_FINISH

  !insertmacro MUI_UNPAGE_WELCOME
  !insertmacro MUI_UNPAGE_CONFIRM
  !insertmacro MUI_UNPAGE_INSTFILES

  !define MUI_UNFINISHPAGE_NOAUTOCLOSE
  !insertmacro MUI_UNPAGE_FINISH

;--------------------------------
;Languages

  !insertmacro MUI_LANGUAGE "English"

;--------------------------------
;Installer Sections

; The stuff to install
Section "BRL-CAD (required)" BRL-CAD

  SectionIn RO

  ; Set output path to the installation directory.
  SetOutPath $INSTDIR
  File /r "..\..\brlcadInstall${PLATFORM}\archer.ico"
  File /r "..\..\brlcadInstall${PLATFORM}\brlcad.ico"

  SetOutPath $INSTDIR\bin
  File /r "..\..\brlcadInstall${PLATFORM}\bin\*"

  SetOutPath $INSTDIR\include
  File /r "..\..\brlcadInstall${PLATFORM}\include\*"

  SetOutPath $INSTDIR\lib
  File /r "..\..\brlcadInstall${PLATFORM}\lib\*"

  SetOutPath $INSTDIR\share
  File /r "..\..\brlcadInstall${PLATFORM}\share\*"

  ;Create uninstaller
  WriteUninstaller "uninstall.exe"


  StrCpy $BRLCAD_DATA_DIR "$INSTDIR\share\brlcad\${VERSION}"

  ; Create desktop icons
  SetOutPath $INSTDIR
  CreateShortCut "$DESKTOP\Archer${INSTALLERSUFFIX}.lnk" "$INSTDIR\bin\archer.bat" "" "$INSTDIR\archer.ico" 0
  CreateShortCut "$DESKTOP\MGED${INSTALLERSUFFIX}.lnk" "$INSTDIR\bin\mged.bat" "" "$INSTDIR\brlcad.ico" 0
  CreateShortCut "$DESKTOP\RtWizard${INSTALLERSUFFIX}.lnk" "$INSTDIR\bin\rtwizard.bat" "" "$INSTDIR\brlcad.ico" 0

  !insertmacro MUI_STARTMENU_WRITE_BEGIN Application
    ;Main start menu shortcuts
    SetOutPath $INSTDIR
    CreateDirectory "$SMPROGRAMS\$STARTMENU_FOLDER${INSTALLERSUFFIX}"
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER${INSTALLERSUFFIX}\Archer.lnk" "$INSTDIR\bin\archer.bat" "" "$INSTDIR\archer.ico" 0
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER${INSTALLERSUFFIX}\MGED.lnk" "$INSTDIR\bin\mged.bat" "" "$INSTDIR\brlcad.ico" 0
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER${INSTALLERSUFFIX}\RtWizard.lnk" "$INSTDIR\bin\rtwizard.bat" "" "$INSTDIR\brlcad.ico" 0
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER${INSTALLERSUFFIX}\Uninstall.lnk" "$INSTDIR\uninstall.exe" "" "$INSTDIR\uninstall.exe" 0
  !insertmacro MUI_STARTMENU_WRITE_END

SectionEnd

Section "Documentation (required)" Documentation
  !insertmacro MUI_STARTMENU_WRITE_BEGIN Application
    ;Main start menu shortcuts
    SetOutPath $INSTDIR
    CreateDirectory "$SMPROGRAMS\$STARTMENU_FOLDER${INSTALLERSUFFIX}\Manuals"
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER${INSTALLERSUFFIX}\Manuals\BRL-CAD.lnk" "$BRLCAD_DATA_DIR\html\manuals\index.html" "" "$INSTDIR\brlcad.ico" 0
    CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER${INSTALLERSUFFIX}\Manuals\MGED.lnk" "$BRLCAD_DATA_DIR\html\manuals\mged\index.html" "" "$INSTDIR\brlcad.ico" 0
  !insertmacro MUI_STARTMENU_WRITE_END
SectionEnd


;--------------------------------
;Descriptions


  ;Language strings
  LangString DESC_BRL-CAD ${LANG_ENGLISH} "Installs the main application and the associated data files."
  LangString DESC_Documentation ${LANG_ENGLISH} "Installs documentation for BRL-CAD."


  ;Assign language strings to sections
  !insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN
    !insertmacro MUI_DESCRIPTION_TEXT ${BRL-CAD} $(DESC_BRL-CAD)
    !insertmacro MUI_DESCRIPTION_TEXT ${Documentation} $(DESC_Documentation)
  !insertmacro MUI_FUNCTION_DESCRIPTION_END


;--------------------------------

; Uninstaller

Section "Uninstall"

  !insertmacro MUI_STARTMENU_GETFOLDER Application $MUI_TEMP

  ; Remove shortcuts, if any
  Delete "$SMPROGRAMS\$MUI_TEMP${INSTALLERSUFFIX}\Manuals\*"
  Delete "$SMPROGRAMS\$MUI_TEMP${INSTALLERSUFFIX}\*"
  Delete "$DESKTOP\Archer${INSTALLERSUFFIX}.lnk"
  Delete "$DESKTOP\MGED${INSTALLERSUFFIX}.lnk"
  Delete "$DESKTOP\RtWizard${INSTALLERSUFFIX}.lnk"


  ; Remove miscellaneous files
  Delete "$INSTDIR\archer.ico"
  Delete "$INSTDIR\brlcad.ico"
  Delete "$INSTDIR\uninstall.exe"


  ; Remove directories used
  RMDir /r "$INSTDIR\bin"
  RMDir /r "$INSTDIR\include"
  RMDir /r "$INSTDIR\lib"
  RMDir /r "$INSTDIR\share"
  RMDir "$INSTDIR"
  RMDir "$SMPROGRAMS\$MUI_TEMP${INSTALLERSUFFIX}\Manuals"
  RMDir "$SMPROGRAMS\$MUI_TEMP${INSTALLERSUFFIX}"

SectionEnd
blob
data 2935
#                      U P D A T E V E R S I O N . T C L
# BRL-CAD
#
# Copyright (c) 2002-2014 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License
# version 2.1 as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this file; see the file named COPYING for more
# information.
#
###
#
# Description:
#    Script for creating VERSION.txt (used by brlcad.nsi) and
#    VERSION.bat (used by asc2g.vcproj).
#

set rootDir [file normalize ../../../]
if {![file exists [file join $rootDir include]]} {
    puts "$rootDir must exist and must be the root of the BRL-CAD source tree. "
    return
}

set missingFile 0

if {![file exists [file join $rootDir include conf MAJOR]]} {
    puts "Missing [file join $rootDir include conf MAJOR]]"
    set missingFile 1
}

if {![file exists [file join $rootDir include conf MINOR]]} {
    puts "Missing [file join $rootDir include conf MINOR]]"
    set missingFile 1
}

if {![file exists [file join $rootDir include conf PATCH]]} {
    puts "Missing [file join $rootDir include conf PATCH]]"
    set missingFile 1
}


if {$missingFile} {
    return
}

set fd [open [file join $rootDir include conf MAJOR] "r"]
set major [read $fd]
close $fd

set fd [open [file join $rootDir include conf MINOR] "r"]
set minor [read $fd]
close $fd

set fd [open [file join $rootDir include conf PATCH] "r"]
set patch [read $fd]
close $fd

set major [string trim $major]
set minor [string trim $minor]
set patch [string trim $patch]

if {![string is int $major] ||
    ![string is int $minor] ||
    ![string is int $patch]} {
    puts "Failed to acquire BRL-CAD's version."
    puts "Bad value for one or more of the following:"
    puts "major - $major, minor - $minor, patch - $patch"
    return
}

set platform [lindex $argv 0]
if {$platform == "x64"} {
    set brlcadInstall "brlcadInstallx64"
    set installerSuffix " (64-bit)"
} else {
    set platform ""
    set brlcadInstall brlcadInstall
    set installerSuffix ""
}

set version "$major.$minor.$patch"

# Create VERSION.txt
set fd [open [file join $rootDir misc nsis VERSION.txt] "w"]
puts $fd "!define MAJOR '$major'"
puts $fd "!define MINOR '$minor'"
puts $fd "!define PATCH '$patch'"
puts $fd "!define VERSION '$version'"
puts $fd "!define PLATFORM '$platform'"
puts $fd "!define INSTALLERSUFFIX '$installerSuffix'"
close $fd

# Create VERSION.bat
set fd [open [file join $rootDir misc nsis VERSION.bat] "w"]
puts $fd "set BrlcadVersion=$version"
close $fd
