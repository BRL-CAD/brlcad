blob
data 26502
The Installation Guide to BRL-CAD
=================================

Please read this document if you are interested in installing BRL-CAD.

This document covers the basics of installing BRL-CAD from either a
source or binary distribution.  Please see the 'Reporting Problems'
section if you run into any trouble installing BRL-CAD.

Some platforms have additional platform-specific documentation
provided in the doc/ directory of the source distribution that should
be consulted if that is the platform you are installing on.  This
presently includes the following:

  doc/README.AIX        -- IBM's Advanced Interactive eXecutive OS
  doc/README.BSD        -- FreeBSD, NetBSD, OpenBSD, etc.
  doc/README.IRIX	-- SGI IRIX and IRIX64
  doc/README.Linux	-- Various Linux distributions
  doc/README.MacOSX	-- Apple Mac OS X
  doc/README.Solaris    -- Oracle Solaris, OpenIndiana (Illumos), etc.
  doc/README.Windows    -- Microsoft Windows
  doc/README.VAX        -- Virtual Address eXtension architecture from DEC.
                           One of the original BRL-CAD platforms. These
                           days, re-created using the simh simulator.


TABLE OF CONTENTS
-----------------
  Introduction
  Table of Contents
  Quick Installation
  Installing from Binary
  Installing from Source
  Testing Functionality
  Post-Installation
  Reporting Problems
  Configuration Options


QUICK INSTALLATION
------------------

Note that the downloaded files have two check sums calculated
automatically by the Source Forge file release system.  The values are
used to verify the integrity of the files as distributed.  Get those
data by clicking on the 'i' button at the end of each file's name.
You should ensure those data are retained and kept with the files if
you re-distribute them.


If you downloaded a binary distribution of BRL-CAD for your system,
please read the INSTALLING FROM BINARY section of this document down
below.  The rest of this quick installation section is only relevant
to source code distributions of BRL-CAD.

For the impatient or simplistic, the following steps should compile,
test, and install an optimized BRL-CAD quickly into the /usr/brlcad/rel-X.Y.Z
directory if CMake is installed on your system:

  gunzip brlcad-X.Y.Z.tar.gz
  tar -xvf brlcad-X.Y.Z.tar
  mkdir brlcad-build
  cd brlcad-build
  cmake ../brlcad-X.Y.Z -DBRLCAD_BUNDLED_LIBS=ON -DCMAKE_BUILD_TYPE=Release
  make
  make benchmark
  make regress
  make install   # as root, e.g. sudo make install

If any of the listed steps fail, then something unexpected happened.
See the REPORTING PROBLEMS section of this document to report the
problem or the INSTALLING FROM SOURCE section for more comprehensive
instructions.

Once installed, add /usr/brlcad/rel-X.Y.Z/bin to your path, and you should be
able to run any of the 400+ applications that constitute BRL-CAD.  For
example, to run the MGED solid modeler:

PATH=/usr/brlcad/rel-X.Y.Z/bin:$PATH ; export PATH
mged

If you use tcsh or another C-shell based command shell, use this
instead:

set path=( /usr/brlcad/rel-X.Y.Z/bin $path ) ; rehash
mged


INSTALLING FROM BINARY
----------------------

There are a variety of different kinds of binary distributions of
BRL-CAD.  Some of the binary distributions are sufficiently generic and
are simply a binary compressed tarball distribution.  Others are
specific to a particular platform such as Debian, Mac OS X, FreeBSD,
and Windows etc.


Generic Binary Distributions:

For the unspecialized binary distributions that are basically
compressed tarballs of the installation root, they should contain the
entire hierarchy of the distribution.  To put that hierarchy in its
"installed" location, you just create the directory and move the
expanded tarball contents:

gunzip BRL-CAD_7.2.4_Linux_ia64.tar.gz
tar -xvf BRL-CAD_7.2.4_Linux_ia64.tar
sudo mkdir /usr/brlcad/rel-7.2.4
sudo mv BRL-CAD_7.2.4_Linux_ia64/* /usr/brlcad/rel-7.2.4/

Of course, there are other compression options possible including zip
and bzip2.  By default, BRL-CAD expects to be installed into
/usr/brlcad/rel-7.2.4. On some platforms the binary may be relocatable,
but this is not guaranteed. It's recommended that you start from a source
distribution if you would like to install into an alternate installation
location.  That said, if you do desire to install and/or run BRL-CAD from
a different location, give it a try...on some platforms it will work.

Something to be aware of, even if a binary distribution IS relocatable:
it will use its local copies of things like libraries only so long as the
"final" installed target directory that the build was compiled for
does not contain a BRL-CAD installation.  Due to the way path logic
is set, an installed copy of a library in the correct location will
always be loaded first, regardless of the presence of a "local" copy.


Mac OS X Disk Mounting Image:

Mount the .dmg and run the Installer .pkg contained therein.  This
will install into /usr/brlcad/rel-X.Y.Z and will only require confirming that
your environment is set up properly (i.e. add /usr/brlcad/rel-X.Y.Z/bin to your
path) as described in the Quick Installation section.


INSTALLING FROM SOURCE
----------------------

There are a couple of ways to obtain the BRL-CAD sources, usually via
one of the following starting points:

  1) from a SVN checkout/export, or
  2) from a source distribution tarball

Using the latest SVN sources is recommended where possible since it
will have the latest changes.  See the corresponding section below for
details on how to install from either starting point.


Starting From a SVN Checkout/Export:

With CMake, there is no longer any difference between building from
a subversion checkout and a tarball--follow the Source Distribution
instructions below.

Starting From a Source Distribution:

There are many different ways to build BRL-CAD and depending on what
you need/want will determine which configuration options you should
use.  See the CONFIGURATION OPTIONS section below for details on how
to go about selecting which options are appropriate for you.

By default, the default configuration will prepare the build system
to perform a Debug build and install into the /usr/brlcad/dev-X.Y.Z
directory.   The CMAKE_INSTALL_PREFIX option may be used to change
that directory, or a Release build type may be specified to install to
/usr/brlcad/rel-X.Y.Z - more on this below.  The
tradition of non-system installation paths goes back a couple of decades
and is a convenient means to isolate the BRL-CAD solid modeling
system from your system, resolves conflicts, facilitates uninstalls,
and simplifies upgrades.  The default configuration is performed by
running `cmake'.  It is not required to do the build in a directory
different from your source directory, but it is much cleaner and
*highly* recommended - this guide will illustrate the build process
with the assumption that the BRL-CAD source code is in the directory
brlcad-7.2.4 and the directory intended to hold the build output is
brlcad-build, located in the same parent directory as brlcad-7.2.4:

  .
  ./brlcad-7.2.4
  ./brlcad-build

To start the build process, cd into brlcad-build and run CMake,
pointing it to the source directory:

  cd brlcad-build
  cmake ../brlcad-7.2.4

As mentioned earlier, CMake uses two "build types", controlled by
the CMAKE_BUILD_TYPE variable, that are useful for specific purposes:

* Debug (-DCMAKE_BUILD_TYPE=Debug) - Debug is the configuration that most
  developers will want to use when working on BRL-CAD.  It will add
  debug flags to the compile, and sets the default install directory to
  be /usr/brlcad/dev-X.Y.Z - in order to run the resulting installed
  binaries, the developer should ensure that the dev-X.Y.Z  path is
  first in his or her PATH environment variable.

* Release (-DCMAKE_BUILD_TYPE=Release) - A release build is intended for
  final consumption by end users and as such has optimizations enabled.
  It also sets the install path to /usr/brlcad/rel-X.Y.Z - best practice
  for release installation is to set up symbolic links in /usr/brlcad to
  point to the most current BRL-CAD release, while allowing older versions
  to remain installed on the system in case they are needed.

In both of these cases any individual variable may be overridden - for
example, setting -DCMAKE_INSTALL_PREFIX=/usr/brlcad in a Debug build will
override the ../brlcad-install default.  Build types are a convenient way
to bundle sets of settings, but they do not prevent overrides if a more
custom setup is needed.

By default, all components and functionality will be built.
Note that BRL-CAD does require and include several 3rd party
components.  If your system does not include a sufficient version of
those required 3rd party components, they will be automatically
configured for compilation.

If the autodetection mechanisms fail to produce a working configuration,
the next simplest approach is typically to enable ALL the third party
components - this is typically a well tested configuration, but will
increase both the build time and final install size of BRL-CAD on
the system.  To set this variable on the command line, use -D to
define BRLCAD_BUNDLED_LIBS for CMake:

  -DBRLCAD_BUNDLED_LIBS=Bundled

If the graphical interface (cmake-gui) is in use, it will list this
and other common options by default, allowing the user change them
graphically.  This is often quicker and more convenient than
defining options on the command line, but both will work.

You can also force on or off any individual 3rd party library by
setting the BRL-CAD variable for that feature to either on or off:

  -DBRLCAD_<LIBRARY>=ON

Other variables control BRL-CAD features.  For example, to NOT
enable functionality using OpenGL, set

  -DBRLCAD_ENABLE_OPENGL=OFF

To obtain an optimized build (for example, for BRL-CAD Benchmark
performance evaluation), enable BRLCAD_FLAGS_OPTIMIZATION:

  -DBRLCAD_FLAGS_OPTIMIZATION=ON

See the CONFIGURATION OPTIONS below for more details on all of the
possible settings.

You can specify options or preferences you want to always use by
default.  For example, to always enable all local libs the following
line can be added to your own configuration file:

  set(BRLCAD_BUNDLED_LIBS "Bundled" CACHE STRING "Enable all local libs")

You can define your own configuration file in one of three ways.  The
build system will search for the file in this order:

  ${BRLCAD_SOURCE_DIR}/../BRL-CAD_CONFIG.GLOBAL

  ${BRLCAD_SOURCE_DIR}/BRL-CAD_CONFIG.GLOBAL

  the file defined in the environment variable "BRLCAD_USER_GLOBAL_CONFIG_FILE"

The build system will use the first file defined that exists.

Once configured, you should be able to successfully build BRL-CAD via
make:

  make

(On multicore systems, adding the -j flag (e.g. -j6) is recommended)

Installing the Compilation:

After the build successfully completes and assuming the benchmark also
produces correct results, installation may begin.  Like any package,
you must have sufficient filesystem permissions to install.  To
install into a system location, you can generally either become a
super user via the su command and run

  make install

or on operating systems set up to use sudo:

  sudo make install


TESTING FUNCTIONALITY
---------------------

To test BRL-CAD before installation, you can run the BRL-CAD benchmark.
The benchmark will report if the results are correct, testing a
majority of the core functionality of BRL-CAD in addition to testing
your system's performance:

  make benchmark

Note that the benchmark target will build ONLY the pieces required for
the benchmark tests, unless a general make has already been performed.
For more testing, you can run the regression test suite:

  make regress


POST-INSTALLATION
-----------------

Permissions:

Something to be aware of with CMake installations is that umask settings
are ignored by current versions of CMake.  It is a common situation in
Unix environments to want "group" members to have read/write access -
to achieve this, after installation the following find command can be
run (of course, substituting the actual BRL-CAD version for X.Y.Z):

find /usr/brlcad/rel-X.Y.Z -type d -exec chmod ug+rwx {} \; -exec chmod o+rx {} \; -o -type f -exec chmod ug+rw {} \; -exec chmod o+r {} \;

The above 'find' line will set up permissions across a /usr/brlcad
rooted installation such that 'user' and 'group' will have read-write
access and 'other' will have read access consistently across all
files.


System PATH:

Normally, BRL-CAD's install directories are not in system PATH lists and
consequently BRL-CAD's executables will not be invokable without specifying
their full path.  This is normally handled in Unix environments by adding
the desired BRL-CAD installation's binary directory to the user's local path:

In the bash shell: export PATH=/usr/brlcad/rel-X.Y.Z:$PATH
In the csh shell:  setenv PATH /usr/brlcad/rel-X.Y.Z:$PATH

REPORTING PROBLEMS
------------------

Please report any bugs encountered to the project bug tracker at
http://sourceforge.net/tracker/?group_id=105292&atid=640802

Similarly, please post any request for feature enhancements or support
to http://sourceforge.net/tracker/?group_id=105292&atid=640805 and
http://sourceforge.net/tracker/?group_id=105292&atid=640803
respectively.


CONFIGURATION OPTIONS
---------------------

--- BRLCAD_BUNDLED_LIBS ---

Enables compilation of all 3rd party sources that are provided within a BRL-CAD
source distribution.  If used this option sets all other 3rd party library
build flags to ON by default.  However, that setting can be overridden by
manually setting individual variables. Default is "AUTO" - 3rd party sources
are compiled only if they are not detected as being available and functioning
as expected.

Aliases:  ENABLE_ALL


--- BRLCAD_ENABLE_OPENGL ---

Enable support for OpenGL based Display Managers in BRL-CAD.
Default depends on whether OpenGL is successfully detected -
if it is, default is to enable.

Aliases:  ENABLE_OPENGL


--- BRLCAD_ENABLE_RUNTIME_DEBUG ---

Enables support for application and library debugging facilities.
Disabling the run-time debugging facilities can provide a significant
(10%-30%) performance boost at the expense of extensive error
checking (that in turn help prevent corruption of your data).
Default is "ON", and should only be disabled for read-only render
work where performance is critical.

Aliases:  ENABLE_RUNTIME_DEBUG, ENABLE_RUN_TIME_DEBUG, ENABLE_RUNTIME_DEBUGGING
          ENABLE_RUN_TIME_DEBUGGING


--- BRLCAD_FLAGS_DEBUG ---

Add compiler flags to aid in program debugging.  Defaults to ON.

Aliases:  ENABLE_DEBUG, ENABLE_FLAGS_DEBUG, ENABLE_DEBUG_FLAGS


--- BRLCAD_ENABLE_COMPILER_WARNINGS ---

Use extra compiler warning flags when compiling C/C++ code.  Defaults to ON.

Aliases:  ENABLE_WARNINGS, ENABLE_COMPILER_WARNINGS


--- BRLCAD_ENABLE_STRICT ---

Causes all compilation warnings for C code to be treated as errors.  This is now
the default for BRL-CAD source code, and developers should address issues
discovered by these flags whenever possible rather than disabling strict
mode.

Aliases:  ENABLE_STRICT, ENABLE_STRICT_COMPILE, ENABLE_STRICT_COMPILE_FLAGS


--- ENABLE_ALL_CXX_COMPILE ---

Build all C and C++ files with a C++ compiler.  Defaults to OFF.

EXPERIMENTAL!

Aliases:  ENABLE_ALL_CXX


--- ENABLE_POSIX_COMPLIANCE ---

Build with strict POSIX compliance checking.  Defaults to OFF.

Causes compiler options to be set for strict compliance with the
minimum C and C++ standards acceptable according to current BRL-CAD
policy.  The current minimum C standard is ??.
There is no currently defined minimum C++ standard.

Aliases:  ENABLE_POSIX


--- ENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE ---

Build with strict ISO C compliance checking.  Defaults to OFF.

Causes C compiler options to be set for strict compliance with the
appropriate ISO C standard.

Aliases:  STRICT_ISO_C


--- BRLCAD_EXTRADOCS ---

The core option that enables and disables building of BRL-CAD's
DocBook based documentation (includes manuals and man pages for
commands, among other things).  Defaults to ON, but only HTML and MAN
formats are enabled by default - PDF must be enabled separately by use
of this option or one of its aliases.  Note that you may set
environment variable APACHE_FOP to point to your locally installed fop
executable file (which on Linux is usually a shell script with 0755
permissions).

Aliases:  ENABLE_DOCS, ENABLE_EXTRA_DOCS, ENABLE_DOCBOOK


--- BRLCAD_REGEX ---

Option for enabling and disabling compilation of the Regular
Expression Library provided with BRL-CAD's source distribution.
Default is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option
and testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.

Aliases:  ENABLE_REGEX


--- BRLCAD_ZLIB ---

Option for enabling and disabling compilation of the zlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_ZLIB, ENABLE_LIBZ


--- BRLCAD_LEMON ---

Option for enabling and disabling compilation of the lemon parser
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_LEMON


--- BRLCAD_RE2C ---

Option for enabling and disabling compilation of the re2c scanner
utility provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_RE2C


--- BRLCAD_PERPLEX ---

Option for enabling and disabling compilation of the perplex scanner
generator provided with BRL-CAD's source distribution.  Default is
AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.  perplex requires a working re2c.

Aliases:  ENABLE_PERPLEX


--- BRLCAD_XSLTPROC ---

Option for enabling and disabling compilation of the xsltproc XML
transformation utility provided with BRL-CAD's source distribution.
Used for DocBook documentation processing.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
Depends on BRLCAD_EXTRADOCS.

Aliases:  ENABLE_XSLTPROC


--- BRLCAD_XMLLINT ---

Option for enabling and disabling compilation of the xmllint XML
validation utility provided with BRL-CAD's source distribution.  Used
for DocBook documentation validation.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_XMLLINT


--- BRLCAD_TERMLIB ---

Option for enabling and disabling compilation of the termlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO. (Except when building with Visual Studio, where it is
disabled. Windows does not support the termlib API.)

Aliases:  ENABLE_TERMLIB


--- BRLCAD_PNG ---

Option for enabling and disabling compilation of the Portable Network
Graphics library provided with BRL-CAD's source distribution.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.

Aliases:  ENABLE_PNG


--- BRLCAD_UTAHRLE ---

Option for enabling and disabling compilation of the Utah Raster
Toolkit library provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_UTAHRLE


--- BRLCAD_TCL ---

Option for enabling and disabling compilation of the Tcl library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_TCL


--- BRLCAD_TK ---

Option for enabling and disabling compilation of the Tk library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the BRLCAD_TCL option and testing first for a system version if
BRLCAD_BUNDLED_LIBS is also AUTO. Option for enabling and disabling
compilation of the Tk graphics package for Tcl provided with BRL-CAD's
source distribution.  Default is AUTO, auto-enabling if the BRLCAD_TCL
option is set to BUNDLED and testing first for a system version if
BRLCAD_TCL is set to AUTO or SYSTEM.  If BRLCAD_TK is set to BUNDLED,
local copy is built even if a system version is present.  This option
also depends on BRLCAD_ENABLE_TK being ON.

Aliases:  ENABLE_TK


--- BRLCAD_ITCL ---

Option for enabling and disabling compilation of the IncrTcl package
for Tcl objects provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_ITCL is set to BUNDLED, local copy is built even if
a system version is present.

Aliases:  ENABLE_ITCL


--- BRLCAD_ITK ---

Option for enabling and disabling compilation of the IncrTcl itk
package for Tk objects provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_ITK is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_ITK


--- BRLCAD_IWIDGETS ---

Option for enabling and disabling compilation of the IWidgets Tk
widget package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_IWIDGETS is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_IWIDGETS


--- BRLCAD_TKHTML ---

Option for enabling and disabling compilation of the Tkhtml HTML
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKHTML is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_TKHTML


--- BRLCAD_TKPNG ---

Option for enabling and disabling compilation of the tkpng PNG image
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKPNG is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_TKPNG


--- BRLCAD_TKTABLE ---

Option for enabling and disabling compilation of the Tktable graphical
table widget package provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TKTABLE is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.

Aliases:  ENABLE_TKTABLE


--- BRLCAD_OPENNURBS ---

Option for enabling and disabling compilation of the openNURBS library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_OPENNURBS


--- BRLCAD_SC ---

Option for enabling and disabling compilation of the NIST Step Class
Libraries provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_SCL, ENABLE_STEP, ENABLE_STEP_CLASS_LIBRARIES


--- BRLCAD_VDS ---

Option for enabling and disabling compilation of the libvds triangle
simplification library provided with BRL-CAD's source code.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.

Aliases:  ENABLE_VDS


--- BRLCAD_OSG ---

Option for enabling and disabling compilation of the OpenSceneGraph
libraries provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_OPENSCENEGRAPH


--- BRLCAD_GLFW ---

Option for enabling and disabling compilation of the GLFW
libraries provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_OPENSCENEGRAPH


--- BRLCAD_GDIAM ---

Option for enabling and disabling compilation of the libgdiam approximate
tight bounding box library provided with BRL-CAD's source code.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.

Aliases:  ENABLE_GDIAM


--- BRLCAD_ASTYLE ---

Option for enabling and disabling compilation of the Artistic Style
(astyle) utility provided with BRL-CAD's source distribution.  Default is
AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.

Aliases:  ENABLE_ASTYLE



*** Note - Do not add or edit configuration option descriptions and alias
   lists in this file - those entries are auto-generated from information in
   the toplevel CMakeLists.txt file and src/other/CMakeLists.txt - any changes
   should be made in those files.  The CMake configuration process will
   automatically re-generate INSTALL with the new descriptions and alias
   information.
blob
data 12660
#!/bin/sh
#
# This is a simple script to translate autotools style
# configure options into CMake variables.  The resulting
# translation is then run as a CMake configure.

srcpath=$(dirname $0)
options="$srcpath"
while [ "$1" != "" ]
do
   case $1
   in
     --enable-all)                options="$options -DBRLCAD_BUNDLED_LIBS=ON";
                                  shift;;
     --disable-all)                options="$options -DBRLCAD_BUNDLED_LIBS=OFF";
                                  shift;;
     --enable-opengl)                options="$options -DBRLCAD_ENABLE_OPENGL=ON";
                                  shift;;
     --disable-opengl)                options="$options -DBRLCAD_ENABLE_OPENGL=OFF";
                                  shift;;
     --enable-runtime-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-runtime-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-run-time-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-run-time-debug)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-runtime-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-runtime-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-run-time-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=ON";
                                  shift;;
     --disable-run-time-debugging)                options="$options -DBRLCAD_ENABLE_RUNTIME_DEBUG=OFF";
                                  shift;;
     --enable-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=ON";
                                  shift;;
     --disable-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=OFF";
                                  shift;;
     --enable-flags-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=ON";
                                  shift;;
     --disable-flags-debug)                options="$options -DBRLCAD_FLAGS_DEBUG=OFF";
                                  shift;;
     --enable-debug-flags)                options="$options -DBRLCAD_FLAGS_DEBUG=ON";
                                  shift;;
     --disable-debug-flags)                options="$options -DBRLCAD_FLAGS_DEBUG=OFF";
                                  shift;;
     --enable-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=ON";
                                  shift;;
     --disable-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=OFF";
                                  shift;;
     --enable-compiler-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=ON";
                                  shift;;
     --disable-compiler-warnings)                options="$options -DBRLCAD_ENABLE_COMPILER_WARNINGS=OFF";
                                  shift;;
     --enable-strict)                options="$options -DBRLCAD_ENABLE_STRICT=ON";
                                  shift;;
     --disable-strict)                options="$options -DBRLCAD_ENABLE_STRICT=OFF";
                                  shift;;
     --enable-strict-compile)                options="$options -DBRLCAD_ENABLE_STRICT=ON";
                                  shift;;
     --disable-strict-compile)                options="$options -DBRLCAD_ENABLE_STRICT=OFF";
                                  shift;;
     --enable-strict-compile-flags)                options="$options -DBRLCAD_ENABLE_STRICT=ON";
                                  shift;;
     --disable-strict-compile-flags)                options="$options -DBRLCAD_ENABLE_STRICT=OFF";
                                  shift;;
     --enable-all-cxx)                options="$options -DENABLE_ALL_CXX_COMPILE=ON";
                                  shift;;
     --disable-all-cxx)                options="$options -DENABLE_ALL_CXX_COMPILE=OFF";
                                  shift;;
     --enable-posix)                options="$options -DENABLE_POSIX_COMPLIANCE=ON";
                                  shift;;
     --disable-posix)                options="$options -DENABLE_POSIX_COMPLIANCE=OFF";
                                  shift;;
     --strict-iso-c)                options="$options -DENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE=ON";
                                  shift;;
     --strict-iso-c)                options="$options -DENABLE_STRICT_COMPILER_STANDARD_COMPLIANCE=OFF";
                                  shift;;
     --enable-docs)                options="$options -DBRLCAD_EXTRADOCS=ON";
                                  shift;;
     --disable-docs)                options="$options -DBRLCAD_EXTRADOCS=OFF";
                                  shift;;
     --enable-extra-docs)                options="$options -DBRLCAD_EXTRADOCS=ON";
                                  shift;;
     --disable-extra-docs)                options="$options -DBRLCAD_EXTRADOCS=OFF";
                                  shift;;
     --enable-docbook)                options="$options -DBRLCAD_EXTRADOCS=ON";
                                  shift;;
     --disable-docbook)                options="$options -DBRLCAD_EXTRADOCS=OFF";
                                  shift;;
     --enable-regex)                options="$options -DBRLCAD_REGEX=BUNDLED";
                                  shift;;
     --disable-regex)                options="$options -DBRLCAD_REGEX=SYSTEM";
                                  shift;;
     --enable-zlib)                options="$options -DBRLCAD_ZLIB=BUNDLED";
                                  shift;;
     --disable-zlib)                options="$options -DBRLCAD_ZLIB=SYSTEM";
                                  shift;;
     --enable-libz)                options="$options -DBRLCAD_ZLIB=BUNDLED";
                                  shift;;
     --disable-libz)                options="$options -DBRLCAD_ZLIB=SYSTEM";
                                  shift;;
     --enable-lemon)                options="$options -DBRLCAD_LEMON=BUNDLED";
                                  shift;;
     --disable-lemon)                options="$options -DBRLCAD_LEMON=SYSTEM";
                                  shift;;
     --enable-re2c)                options="$options -DBRLCAD_RE2C=BUNDLED";
                                  shift;;
     --disable-re2c)                options="$options -DBRLCAD_RE2C=SYSTEM";
                                  shift;;
     --enable-perplex)                options="$options -DBRLCAD_PERPLEX=BUNDLED";
                                  shift;;
     --disable-perplex)                options="$options -DBRLCAD_PERPLEX=SYSTEM";
                                  shift;;
     --enable-xsltproc)                options="$options -DBRLCAD_XSLTPROC=BUNDLED";
                                  shift;;
     --disable-xsltproc)                options="$options -DBRLCAD_XSLTPROC=SYSTEM";
                                  shift;;
     --enable-xmllint)                options="$options -DBRLCAD_XMLLINT=BUNDLED";
                                  shift;;
     --disable-xmllint)                options="$options -DBRLCAD_XMLLINT=SYSTEM";
                                  shift;;
     --enable-termlib)                options="$options -DBRLCAD_TERMLIB=BUNDLED";
                                  shift;;
     --disable-termlib)                options="$options -DBRLCAD_TERMLIB=SYSTEM";
                                  shift;;
     --enable-png)                options="$options -DBRLCAD_PNG=BUNDLED";
                                  shift;;
     --disable-png)                options="$options -DBRLCAD_PNG=SYSTEM";
                                  shift;;
     --enable-utahrle)                options="$options -DBRLCAD_UTAHRLE=BUNDLED";
                                  shift;;
     --disable-utahrle)                options="$options -DBRLCAD_UTAHRLE=SYSTEM";
                                  shift;;
     --enable-tcl)                options="$options -DBRLCAD_TCL=BUNDLED";
                                  shift;;
     --disable-tcl)                options="$options -DBRLCAD_TCL=SYSTEM";
                                  shift;;
     --enable-tk)                options="$options -DBRLCAD_TK=BUNDLED";
                                  shift;;
     --disable-tk)                options="$options -DBRLCAD_TK=SYSTEM";
                                  shift;;
     --enable-itcl)                options="$options -DBRLCAD_ITCL=BUNDLED";
                                  shift;;
     --disable-itcl)                options="$options -DBRLCAD_ITCL=SYSTEM";
                                  shift;;
     --enable-itk)                options="$options -DBRLCAD_ITK=BUNDLED";
                                  shift;;
     --disable-itk)                options="$options -DBRLCAD_ITK=SYSTEM";
                                  shift;;
     --enable-iwidgets)                options="$options -DBRLCAD_IWIDGETS=BUNDLED";
                                  shift;;
     --disable-iwidgets)                options="$options -DBRLCAD_IWIDGETS=SYSTEM";
                                  shift;;
     --enable-tkhtml)                options="$options -DBRLCAD_TKHTML=BUNDLED";
                                  shift;;
     --disable-tkhtml)                options="$options -DBRLCAD_TKHTML=SYSTEM";
                                  shift;;
     --enable-tkpng)                options="$options -DBRLCAD_TKPNG=BUNDLED";
                                  shift;;
     --disable-tkpng)                options="$options -DBRLCAD_TKPNG=SYSTEM";
                                  shift;;
     --enable-tktable)                options="$options -DBRLCAD_TKTABLE=BUNDLED";
                                  shift;;
     --disable-tktable)                options="$options -DBRLCAD_TKTABLE=SYSTEM";
                                  shift;;
     --enable-opennurbs)                options="$options -DBRLCAD_OPENNURBS=BUNDLED";
                                  shift;;
     --disable-opennurbs)                options="$options -DBRLCAD_OPENNURBS=SYSTEM";
                                  shift;;
     --enable-scl)                options="$options -DBRLCAD_SC=BUNDLED";
                                  shift;;
     --disable-scl)                options="$options -DBRLCAD_SC=SYSTEM";
                                  shift;;
     --enable-step)                options="$options -DBRLCAD_SC=BUNDLED";
                                  shift;;
     --disable-step)                options="$options -DBRLCAD_SC=SYSTEM";
                                  shift;;
     --enable-step-class-libraries)                options="$options -DBRLCAD_SC=BUNDLED";
                                  shift;;
     --disable-step-class-libraries)                options="$options -DBRLCAD_SC=SYSTEM";
                                  shift;;
     --enable-vds)                options="$options -DBRLCAD_VDS=BUNDLED";
                                  shift;;
     --disable-vds)                options="$options -DBRLCAD_VDS=SYSTEM";
                                  shift;;
     --enable-openscenegraph)                options="$options -DBRLCAD_OSG=BUNDLED";
                                  shift;;
     --disable-openscenegraph)                options="$options -DBRLCAD_OSG=SYSTEM";
                                  shift;;
     --enable-openscenegraph)                options="$options -DBRLCAD_GLFW=BUNDLED";
                                  shift;;
     --disable-openscenegraph)                options="$options -DBRLCAD_GLFW=SYSTEM";
                                  shift;;
     --enable-gdiam)                options="$options -DBRLCAD_GDIAM=BUNDLED";
                                  shift;;
     --disable-gdiam)                options="$options -DBRLCAD_GDIAM=SYSTEM";
                                  shift;;
     --enable-astyle)                options="$options -DBRLCAD_ASTYLE=BUNDLED";
                                  shift;;
     --disable-astyle)                options="$options -DBRLCAD_ASTYLE=SYSTEM";
                                  shift;;
     --prefix=*)   	          inputstr=$1;
				  options="$options -DCMAKE_INSTALL_PREFIX=${inputstr#--prefix=}";
				  shift;;
     *) 	   	          echo "Warning: unknown option $1";
				  shift;;
   esac
done
echo cmake $options
cmake $options
blob
data 8727
#          B R L C A D _ C M A K E F I L E S . C M A K E
# BRL-CAD
#
# Copyright (c) 2011-2014 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
#
# 3. The name of the author may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#


# Define a macro for building lists of files.  Distcheck needs to know
# what files are "supposed" to be present in order to make sure the
# source tree is clean prior to building a distribution tarball, hence
# this macro stores its results in files and not variables  It's a
# no-op in a SUBBUILD.
#
# For this macro to work correctly, it is important that any target
# definitions or explicit calls to this macro supply relative paths for
# files present in the source tree.  Generated files fed into
# compilation targets are not one of the things that should be in lists
# generated by this macro, and the only way to reliably recognize them
# is to reject files specified using their full path.  Such files must
# use their full path in the build logic in order for out-of-src-dir
# builds to function, so as long as no full paths are used for files
# actually IN the source tree this method is reliable.  The macro will
# try to catch improperly specified files, but if the build directory
# and the source directory are one and the same this will not be
# possible.

define_property(GLOBAL PROPERTY CMAKE_IGNORE_FILES BRIEF_DOCS "distcheck ignore files" FULL_DOCS "List of files known to CMake")
define_property(GLOBAL PROPERTY CMAKE_IGNORE_DIRS BRIEF_DOCS "distcheck ignore dirs" FULL_DOCS "List of directories marked as fully known to CMake")

macro(CMAKEFILES)
  if(NOT BRLCAD_IS_SUBBUILD)
    foreach(ITEM ${ARGN})
      set(CMAKEFILES_DO_TEST 1)
      # The build targets will use certain keywords for arguments -
      # before we proceed to do any ignoring based on those names,
      # make sure the file is there.  Normally attempting to ignore
      # a non-existent file is a fatal error, but these keywords
      # don't necessarily refer to files.
      set(TARGET_FLAGS SHARED STATIC OBJECT WIN32 MACOSX_BUNDLE UNKNOWN IMPORTED MODULE)
      foreach(TARGET_FLAG ${TARGET_FLAGS})
	if("${TARGET_FLAG}" STREQUAL "${ITEM}")
	  if(NOT EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${ITEM})
            set(CMAKEFILES_DO_TEST 0)
	  endif(NOT EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${ITEM})
	endif("${TARGET_FLAG}" STREQUAL "${ITEM}")
      endforeach(TARGET_FLAG ${TARGET_FLAGS})
      set(FUZZY_TARGET_FLAGS TARGET_OBJECTS)
      foreach(TARGET_FLAG ${FUZZY_TARGET_FLAGS})
	if("${ITEM}" MATCHES "${TARGET_FLAG}")
	  if(NOT EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${ITEM})
            set(CMAKEFILES_DO_TEST 0)
	  endif(NOT EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${ITEM})
	endif("${ITEM}" MATCHES "${TARGET_FLAG}")
      endforeach(TARGET_FLAG ${FUZZY_TARGET_FLAGS})

      # Handled target flags, proceeding with tests.
      if(CMAKEFILES_DO_TEST)
	get_filename_component(ITEM_PATH "${ITEM}" PATH)
	get_filename_component(ITEM_NAME "${ITEM}" NAME)
	if(NOT "${ITEM_PATH}" STREQUAL "")
	  # If the build directory is not the same as the source
          # directory, we can enforce the convention that only
          # generated files be specified with their full name.
          # If this becomes a problem with the third party build
          # systems at some point in the future, we may have to
          # exclude src/other paths from this check.
	  if(NOT "${CMAKE_BINARY_DIR}" STREQUAL "${CMAKE_SOURCE_DIR}")
	    IS_SUBPATH("${CMAKE_BINARY_DIR}" "${ITEM_PATH}" SUBPATH_TEST)
	    if("${SUBPATH_TEST}" STREQUAL "0")
	      IS_SUBPATH("${CMAKE_SOURCE_DIR}" "${ITEM_PATH}" SUBPATH_TEST)
	      if("${SUBPATH_TEST}" STREQUAL "1")
	        message(FATAL_ERROR "${ITEM} is listed in ${CMAKE_CURRENT_SOURCE_DIR} using its absolute path.  Please specify the location of this file using a relative path.")
	      endif("${SUBPATH_TEST}" STREQUAL "1")
	    endif("${SUBPATH_TEST}" STREQUAL "0")
	  endif(NOT "${CMAKE_BINARY_DIR}" STREQUAL "${CMAKE_SOURCE_DIR}")
	  # Ignore files specified using full paths, since they
          # should be generated files and are not part of the
          # source code repository.
	  get_filename_component(ITEM_ABS_PATH "${ITEM_PATH}" ABSOLUTE)
	  if(NOT "${ITEM_PATH}" STREQUAL "${ITEM_ABS_PATH}")
	    if(NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM}")
	      message(FATAL_ERROR "Attempting to ignore non-existent file ${ITEM}, in directory ${CMAKE_CURRENT_SOURCE_DIR}")
	    endif(NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM}")
	    # Append files and directories to their respective lists.
	    if(IS_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM}")
	      set_property(GLOBAL APPEND PROPERTY CMAKE_IGNORE_DIRS "${ITEM_ABS_PATH}/${ITEM_NAME}")
	    else(IS_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM}")
	      set_property(GLOBAL APPEND PROPERTY CMAKE_IGNORE_FILES "${ITEM_ABS_PATH}/${ITEM_NAME}")
	    endif(IS_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM}")
	    set_property(GLOBAL APPEND PROPERTY CMAKE_IGNORE_FILES "${ITEM_ABS_PATH}")
	    # Add the parent directories of the specified file or directory as well -
	    # the convention is that once at least one file or directory in a path is recorded
	    # by the build logic, the parent directories along that path have also been recorded.
	    while(NOT "${ITEM_PATH}" STREQUAL "")
	      get_filename_component(ITEM_NAME "${ITEM_PATH}" NAME)
	      get_filename_component(ITEM_PATH "${ITEM_PATH}" PATH)
	      if(NOT "${ITEM_PATH}" STREQUAL "")
		get_filename_component(ITEM_ABS_PATH "${ITEM_PATH}" ABSOLUTE)
		if(NOT "${ITEM_NAME}" STREQUAL "..")
	          set_property(GLOBAL APPEND PROPERTY CMAKE_IGNORE_FILES "${ITEM_ABS_PATH}")
		endif(NOT "${ITEM_NAME}" STREQUAL "..")
	      endif(NOT "${ITEM_PATH}" STREQUAL "")
	    endwhile(NOT "${ITEM_PATH}" STREQUAL "")
	  endif(NOT "${ITEM_PATH}" STREQUAL "${ITEM_ABS_PATH}")
	else(NOT "${ITEM_PATH}" STREQUAL "")
	  # The easy case - no path specified, so assume the current source directory.
	  if(NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM}")
	    message(FATAL_ERROR "Attempting to ignore non-existent file ${ITEM}, in directory ${CMAKE_CURRENT_SOURCE_DIR}")
	  endif(NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM}")
	  if(IS_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM}")
	    set_property(GLOBAL APPEND PROPERTY CMAKE_IGNORE_DIRS "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM_NAME}")
	  else(IS_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM}")
	    set_property(GLOBAL APPEND PROPERTY CMAKE_IGNORE_FILES "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM_NAME}")
	  endif(IS_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/${ITEM}")
	endif(NOT "${ITEM_PATH}" STREQUAL "")
      endif(CMAKEFILES_DO_TEST)
    endforeach(ITEM ${ARGN})
  endif(NOT BRLCAD_IS_SUBBUILD)
endmacro(CMAKEFILES FILESLIST)

# Routine to tell distcheck to ignore a series of items in a directory.  Items may themselves
# be directories.  Primarily useful when working with src/other dist lists.
macro(CMAKEFILES_IN_DIR filestoignore targetdir)
  if(NOT BRLCAD_IS_SUBBUILD)
    set(CMAKE_IGNORE_LIST "")
    foreach(filepath ${${filestoignore}})
      set(CMAKE_IGNORE_LIST ${CMAKE_IGNORE_LIST} "${targetdir}/${filepath}")
    endforeach(filepath ${filestoignore})
    CMAKEFILES(${CMAKE_IGNORE_LIST})
  endif(NOT BRLCAD_IS_SUBBUILD)
endmacro(CMAKEFILES_IN_DIR)

# Local Variables:
# tab-width: 8
# mode: cmake
# indent-tabs-mode: t
# End:
# ex: shiftwidth=2 tabstop=8
blob
data 26280
#                   F I N D X 1 1 . C M A K E
# BRL-CAD
#
# Copyright (c) 2011-2014 United States Government as represented by
# the U.S. Army Research Laboratory.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following
# disclaimer in the documentation and/or other materials provided
# with the distribution.
#
# 3. The name of the author may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
###
# - Find X11 installation
# Try to find X11 on UNIX systems. The following values are defined
#  X11_FOUND        - True if X11 is available
#  X11_INCLUDE_DIR  - include directories to use X11
#  X11_LIBRARIES    - link against these to use X11
#
# and also the following more fine grained variables:
# Include paths: X11_ICE_INCLUDE_PATH,          X11_ICE_LIB,        X11_ICE_FOUND
#                X11_X11_INCLUDE_PATH,          X11_X11_LIB
#                X11_Xaccessrules_INCLUDE_PATH,                     X11_Xaccess_FOUND
#                X11_Xaccessstr_INCLUDE_PATH,                       X11_Xaccess_FOUND
#                X11_Xau_INCLUDE_PATH,          X11_Xau_LIB,        X11_Xau_FOUND
#                X11_Xcomposite_INCLUDE_PATH,   X11_Xcomposite_LIB, X11_Xcomposite_FOUND
#                X11_Xcursor_INCLUDE_PATH,      X11_Xcursor_LIB,    X11_Xcursor_FOUND
#                X11_Xdamage_INCLUDE_PATH,      X11_Xdamage_LIB,    X11_Xdamage_FOUND
#                X11_Xdmcp_INCLUDE_PATH,        X11_Xdmcp_LIB,      X11_Xdmcp_FOUND
#                                               X11_Xext_LIB,       X11_Xext_FOUND
#                X11_dpms_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_dpms_FOUND
#                X11_XShm_INCLUDE_PATH,         (in X11_Xext_LIB),  X11_XShm_FOUND
#                X11_Xshape_INCLUDE_PATH,       (in X11_Xext_LIB),  X11_Xshape_FOUND
#                X11_xf86misc_INCLUDE_PATH,     X11_Xxf86misc_LIB,  X11_xf86misc_FOUND
#                X11_xf86vmode_INCLUDE_PATH,                        X11_xf86vmode_FOUND
#                X11_Xfixes_INCLUDE_PATH,       X11_Xfixes_LIB,     X11_Xfixes_FOUND
#                X11_Xft_INCLUDE_PATH,          X11_Xft_LIB,        X11_Xft_FOUND
#                X11_Xi_INCLUDE_PATH,           X11_Xi_LIB,         X11_Xi_FOUND
#                X11_Xinerama_INCLUDE_PATH,     X11_Xinerama_LIB,   X11_Xinerama_FOUND
#                X11_Xinput_INCLUDE_PATH,       X11_Xinput_LIB,     X11_Xinput_FOUND
#                X11_Xkb_INCLUDE_PATH,                              X11_Xkb_FOUND
#                X11_Xkblib_INCLUDE_PATH,                           X11_Xkb_FOUND
#                X11_Xpm_INCLUDE_PATH,          X11_Xpm_LIB,        X11_Xpm_FOUND
#                X11_XTest_INCLUDE_PATH,        X11_XTest_LIB,      X11_XTest_FOUND
#                X11_Xrandr_INCLUDE_PATH,       X11_Xrandr_LIB,     X11_Xrandr_FOUND
#                X11_Xrender_INCLUDE_PATH,      X11_Xrender_LIB,    X11_Xrender_FOUND
#                X11_Xscreensaver_INCLUDE_PATH, X11_Xscreensaver_LIB, X11_Xscreensaver_FOUND
#                X11_Xt_INCLUDE_PATH,           X11_Xt_LIB,         X11_Xt_FOUND
#                X11_Xutil_INCLUDE_PATH,                            X11_Xutil_FOUND
#                X11_Xv_INCLUDE_PATH,           X11_Xv_LIB,         X11_Xv_FOUND

#=============================================================================
# Copyright 2001-2009 Kitware, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# * Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
#
# * Neither the names of Kitware, Inc., the Insight Software Consortium,
#   nor the names of their contributors may be used to endorse or promote
#   products derived from this software without specific prior written
#   permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# ------------------------------------------------------------------------------
#
# The above copyright and license notice applies to distributions of
# CMake in source and binary form.  Some source files contain additional
# notices of original copyright by their contributors; see each source
# for details.  Third-party software packages supplied with CMake under
# compatible licenses provide their own copyright notices documented in
# corresponding subdirectories.
#
# ------------------------------------------------------------------------------
#
# CMake was initially developed by Kitware with the following sponsorship:
#
#  * National Library of Medicine at the National Institutes of Health
#    as part of the Insight Segmentation and Registration Toolkit (ITK).
#
#  * US National Labs (Los Alamos, Livermore, Sandia) ASC Parallel
#    Visualization Initiative.
#
#  * National Alliance for Medical Image Computing (NAMIC) is funded by the
#    National Institutes of Health through the NIH Roadmap for Medical Research,
#    Grant U54 EB005149.
#
#  * Kitware, Inc.
#
#=============================================================================

MACRO(X11_FIND_INCLUDE_PATH component header)
  find_path(X11_${component}_INCLUDE_PATH ${header} ${X11_INC_SEARCH_PATH} NO_CMAKE_SYSTEM_PATH)
  set(X11_HDR_VARS ${X11_HDR_VARS} X11_${component}_INCLUDE_PATH)
  if(X11_${component}_INCLUDE_PATH)
    set(X11_HDR_PATHS ${X11_HDR_PATHS} ${X11_${component}_INCLUDE_PATH})
    list(REMOVE_DUPLICATES X11_HDR_PATHS)
  endif(X11_${component}_INCLUDE_PATH)
ENDMACRO(X11_FIND_INCLUDE_PATH)

MACRO(X11_FIND_LIB_PATH component libname)
  find_library(X11_${component}_LIB ${libname} ${X11_LIB_SEARCH_PATH} NO_CMAKE_SYSTEM_PATH)
  set(X11_LIB_VARS ${X11_LIB_VARS} X11_${component}_LIB)
  if(X11_${component}_LIB)
    get_filename_component(X11_${component}_DIR ${X11_${component}_LIB} PATH)
    set(X11_LIB_PATHS ${X11_LIB_PATHS} ${X11_${component}_DIR})
    list(REMOVE_DUPLICATES X11_LIB_PATHS)
  endif(X11_${component}_LIB)
ENDMACRO(X11_FIND_LIB_PATH)

if(UNIX)
  set(X11_FOUND 0)
  # X11 is never a framework and some header files may be
  # found in tcl on the mac
  set(CMAKE_FIND_FRAMEWORK_SAVE ${CMAKE_FIND_FRAMEWORK})
  set(CMAKE_FIND_FRAMEWORK NEVER)


  # See whether we're looking for 32 or 64 bit libraries,
  # and organize our search directories accordingly.  The
  # common convention is to use lib64 for 64 bit versions of
  # libraries, but some distributions (notably archlinux)
  # use lib32 for 32 bit and lib for 64 bit.
  get_property(SEARCH_64BIT GLOBAL PROPERTY FIND_LIBRARY_USE_LIB64_PATHS)
  if(SEARCH_64BIT)
    set(64BIT_DIRS "/usr/lib64/X11;/usr/lib64;/usr/lib/x86_64-linux-gnu")
    if(EXISTS "/usr/lib32" OR NOT EXISTS "/usr/lib64")
      set(64BIT_DIRS ${64BIT_DIRS} /usr/lib/X11 /usr/lib)
    endif(EXISTS "/usr/lib32" OR NOT EXISTS "/usr/lib64")
  else(SEARCH_64BIT)
    set(32BIT_DIRS "/usr/lib32/X11;/usr/lib32;/usr/lib/i386-linux-gnu")
    if(EXISTS "/usr/lib64" OR NOT EXISTS "/usr/lib32")
      set(32BIT_DIRS ${32BIT_DIRS} /usr/lib/X11 /usr/lib)
    endif(EXISTS "/usr/lib64" OR NOT EXISTS "/usr/lib32")
  endif(SEARCH_64BIT)

  # Candidate directories for headers
  set(X11_INC_SEARCH_PATH
    /usr/X11/include
    /usr/X11R7/include
    /usr/X11R6/include
    /usr/include/X11
    /usr/local/include/X11
    /usr/local/include
    /usr/include
    /usr/openwin/share/include
    /usr/openwin/include
    /usr/pkg/xorg/include
    /opt/graphics/OpenGL/include
    )

  # Candidate directories for libraries.
  set(X11_LIB_SEARCH_PATH
    ${64BIT_DIRS}
    ${32BIT_DIRS}
    /usr/X11/lib
    /usr/X11R7/lib
    /usr/X11R6/lib
    /usr/openwin/lib
    /usr/pkg/xorg/lib
    )

  # Just in case, clear our lists
  set(X11_HDR_VARS)
  set(X11_HDR_PATHS)
  set(X11_LIB_VARS)
  set(X11_LIB_PATHS)

  # Find primary X11 headers
  X11_FIND_INCLUDE_PATH(X11		X11/X.h)
  X11_FIND_INCLUDE_PATH(Xlib		X11/Xlib.h)
  # Look for other X11 includes; keep the list sorted by name of the cmake X11_<component>_INCLUDE_PATH
  # variable (component doesn't need to match the include file name).
  X11_FIND_INCLUDE_PATH(ICE 		X11/ICE/ICE.h)
  X11_FIND_INCLUDE_PATH(Xaccessrules 	X11/extensions/XKBrules.h)
  X11_FIND_INCLUDE_PATH(Xaccessstr 	X11/extensions/XKBstr.h)
  X11_FIND_INCLUDE_PATH(Xau 		X11/Xauth.h)
  X11_FIND_INCLUDE_PATH(Xcomposite 	X11/extensions/Xcomposite.h)
  X11_FIND_INCLUDE_PATH(Xcursor 	X11/Xcursor/Xcursor.h)
  X11_FIND_INCLUDE_PATH(Xdamage 	X11/extensions/Xdamage.h)
  X11_FIND_INCLUDE_PATH(Xdmcp 		X11/Xdmcp.h)
  X11_FIND_INCLUDE_PATH(dpms 		X11/extensions/dpms.h)
  X11_FIND_INCLUDE_PATH(xf86misc 	X11/extensions/xf86misc.h)
  X11_FIND_INCLUDE_PATH(xf86vmode 	X11/extensions/xf86vmode.h)
  X11_FIND_INCLUDE_PATH(Xfixes		X11/extensions/Xfixes.h)
  X11_FIND_INCLUDE_PATH(Xft		X11/Xft/Xft.h)
  X11_FIND_INCLUDE_PATH(Xi		X11/extensions/XInput.h)
  X11_FIND_INCLUDE_PATH(Xinerama	X11/extensions/Xinerama.h)
  X11_FIND_INCLUDE_PATH(Xinput		X11/extensions/XInput.h)
  X11_FIND_INCLUDE_PATH(Xkb		X11/extensions/XKB.h)
  X11_FIND_INCLUDE_PATH(Xkblib		X11/XKBlib.h)
  X11_FIND_INCLUDE_PATH(Xpm		X11/xpm.h)
  X11_FIND_INCLUDE_PATH(XTest		X11/extensions/XTest.h)
  X11_FIND_INCLUDE_PATH(XShm		X11/extensions/XShm.h)
  X11_FIND_INCLUDE_PATH(Xrandr		X11/extensions/Xrandr.h)
  X11_FIND_INCLUDE_PATH(Xrender		X11/extensions/Xrender.h)
  X11_FIND_INCLUDE_PATH(Xscreensaver	X11/extensions/scrnsaver.h)
  X11_FIND_INCLUDE_PATH(Xshape		X11/extensions/shape.h)
  X11_FIND_INCLUDE_PATH(Xutil		X11/Xutil.h)
  X11_FIND_INCLUDE_PATH(Xt		X11/Intrinsic.h)
  X11_FIND_INCLUDE_PATH(Xv		X11/extensions/Xvlib.h)


  # Find primary X11 library
  X11_FIND_LIB_PATH(X11			X11)
  # Find additional X libraries. Keep list sorted by library name.
  X11_FIND_LIB_PATH(ICE			ICE)
  X11_FIND_LIB_PATH(SM			SM)
  X11_FIND_LIB_PATH(Xau			Xau)
  X11_FIND_LIB_PATH(Xcomposite		Xcomposite)
  X11_FIND_LIB_PATH(Xcursor		Xcursor)
  X11_FIND_LIB_PATH(Xdamage		Xdamage)
  X11_FIND_LIB_PATH(Xdmcp		Xdmcp)
  X11_FIND_LIB_PATH(Xext		Xext)
  X11_FIND_LIB_PATH(Xfixes		Xfixes)
  X11_FIND_LIB_PATH(Xft			Xft)
  X11_FIND_LIB_PATH(Xi			Xi)
  X11_FIND_LIB_PATH(Xinerama		Xinerama)
  X11_FIND_LIB_PATH(Xinput 		Xi)
  X11_FIND_LIB_PATH(Xpm			Xpm)
  X11_FIND_LIB_PATH(Xrandr		Xrandr)
  X11_FIND_LIB_PATH(Xrender		Xrender)
  X11_FIND_LIB_PATH(Xscreensaver	Xss)
  X11_FIND_LIB_PATH(Xt			Xt)
  X11_FIND_LIB_PATH(XTest		Xtst)
  X11_FIND_LIB_PATH(Xv			Xv)
  X11_FIND_LIB_PATH(Xxf86misc		Xxf86misc)

  set(X11_LIBRARY_DIR "")
  if(X11_X11_LIB)
    get_filename_component(X11_LIBRARY_DIR ${X11_X11_LIB} PATH)
  endif(X11_X11_LIB)

  set(X11_INCLUDE_DIR) # start with empty list
  if(X11_X11_INCLUDE_PATH)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_X11_INCLUDE_PATH})
  endif(X11_X11_INCLUDE_PATH)

  if(X11_Xlib_INCLUDE_PATH)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xlib_INCLUDE_PATH})
  endif(X11_Xlib_INCLUDE_PATH)

  if(X11_Xutil_INCLUDE_PATH)
    set(X11_Xutil_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xutil_INCLUDE_PATH})
  endif(X11_Xutil_INCLUDE_PATH)

  if(X11_Xshape_INCLUDE_PATH)
    set(X11_Xshape_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xshape_INCLUDE_PATH})
  endif(X11_Xshape_INCLUDE_PATH)

  # We'll need a variable containing all X11 libraries found
  set(X11_LIBRARIES) # start with empty list

  if(X11_X11_LIB)
    set(X11_LIBRARIES ${X11_LIBRARIES} ${X11_X11_LIB})
  endif(X11_X11_LIB)

  if(X11_Xext_LIB)
    set(X11_Xext_FOUND TRUE)
    set(X11_LIBRARIES ${X11_LIBRARIES} ${X11_Xext_LIB})
  endif(X11_Xext_LIB)

  if(X11_Xt_LIB AND X11_Xt_INCLUDE_PATH)
    set(X11_Xt_FOUND TRUE)
  endif(X11_Xt_LIB AND X11_Xt_INCLUDE_PATH)

  if(X11_Xft_LIB AND X11_Xft_INCLUDE_PATH)
    set(X11_Xft_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xft_INCLUDE_PATH})
  endif(X11_Xft_LIB AND X11_Xft_INCLUDE_PATH)

  if(X11_Xv_LIB AND X11_Xv_INCLUDE_PATH)
    set(X11_Xv_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xv_INCLUDE_PATH})
  endif(X11_Xv_LIB AND X11_Xv_INCLUDE_PATH)

  if(X11_Xau_LIB AND X11_Xau_INCLUDE_PATH)
    set(X11_Xau_FOUND TRUE)
  endif(X11_Xau_LIB AND X11_Xau_INCLUDE_PATH)

  if(X11_Xdmcp_INCLUDE_PATH AND X11_Xdmcp_LIB)
    set(X11_Xdmcp_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xdmcp_INCLUDE_PATH})
  endif(X11_Xdmcp_INCLUDE_PATH AND X11_Xdmcp_LIB)

  if(X11_Xaccessrules_INCLUDE_PATH AND X11_Xaccessstr_INCLUDE_PATH)
    set(X11_Xaccess_FOUND TRUE)
    set(X11_Xaccess_INCLUDE_PATH ${X11_Xaccessstr_INCLUDE_PATH})
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xaccess_INCLUDE_PATH})
  endif(X11_Xaccessrules_INCLUDE_PATH AND X11_Xaccessstr_INCLUDE_PATH)

  if(X11_Xpm_INCLUDE_PATH AND X11_Xpm_LIB)
    set(X11_Xpm_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xpm_INCLUDE_PATH})
  endif(X11_Xpm_INCLUDE_PATH AND X11_Xpm_LIB)

  if(X11_Xcomposite_INCLUDE_PATH AND X11_Xcomposite_LIB)
    set(X11_Xcomposite_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xcomposite_INCLUDE_PATH})
  endif(X11_Xcomposite_INCLUDE_PATH AND X11_Xcomposite_LIB)

  if(X11_Xdamage_INCLUDE_PATH AND X11_Xdamage_LIB)
    set(X11_Xdamage_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xdamage_INCLUDE_PATH})
  endif(X11_Xdamage_INCLUDE_PATH AND X11_Xdamage_LIB)

  if(X11_XShm_INCLUDE_PATH)
    set(X11_XShm_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_XShm_INCLUDE_PATH})
  endif(X11_XShm_INCLUDE_PATH)

  if(X11_XTest_INCLUDE_PATH AND X11_XTest_LIB)
    set(X11_XTest_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_XTest_INCLUDE_PATH})
  endif(X11_XTest_INCLUDE_PATH AND X11_XTest_LIB)

  if(X11_Xi_INCLUDE_PATH AND X11_Xi_LIB)
    set(X11_Xi_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xi_INCLUDE_PATH})
  endif(X11_Xi_INCLUDE_PATH  AND X11_Xi_LIB)

  if(X11_Xinerama_INCLUDE_PATH AND X11_Xinerama_LIB)
    set(X11_Xinerama_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xinerama_INCLUDE_PATH})
  endif(X11_Xinerama_INCLUDE_PATH  AND X11_Xinerama_LIB)

  if(X11_Xfixes_INCLUDE_PATH AND X11_Xfixes_LIB)
    set(X11_Xfixes_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xfixes_INCLUDE_PATH})
  endif(X11_Xfixes_INCLUDE_PATH AND X11_Xfixes_LIB)

  if(X11_Xrender_INCLUDE_PATH AND X11_Xrender_LIB)
    set(X11_Xrender_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xrender_INCLUDE_PATH})
  endif(X11_Xrender_INCLUDE_PATH AND X11_Xrender_LIB)

  if(X11_Xrandr_INCLUDE_PATH AND X11_Xrandr_LIB)
    set(X11_Xrandr_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xrandr_INCLUDE_PATH})
  endif(X11_Xrandr_INCLUDE_PATH AND X11_Xrandr_LIB)

  if(X11_xf86misc_INCLUDE_PATH AND X11_Xxf86misc_LIB)
    set(X11_xf86misc_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_xf86misc_INCLUDE_PATH})
  endif(X11_xf86misc_INCLUDE_PATH  AND X11_Xxf86misc_LIB)

  if(X11_xf86vmode_INCLUDE_PATH)
    set(X11_xf86vmode_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_xf86vmode_INCLUDE_PATH})
  endif(X11_xf86vmode_INCLUDE_PATH)

  if(X11_Xcursor_INCLUDE_PATH AND X11_Xcursor_LIB)
    set(X11_Xcursor_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xcursor_INCLUDE_PATH})
  endif(X11_Xcursor_INCLUDE_PATH AND X11_Xcursor_LIB)

  if(X11_Xscreensaver_INCLUDE_PATH AND X11_Xscreensaver_LIB)
    set(X11_Xscreensaver_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xscreensaver_INCLUDE_PATH})
  endif(X11_Xscreensaver_INCLUDE_PATH AND X11_Xscreensaver_LIB)

  if(X11_dpms_INCLUDE_PATH)
    set(X11_dpms_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_dpms_INCLUDE_PATH})
  endif(X11_dpms_INCLUDE_PATH)

  if(X11_Xkb_INCLUDE_PATH AND X11_Xkblib_INCLUDE_PATH AND X11_Xlib_INCLUDE_PATH)
    set(X11_Xkb_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xkb_INCLUDE_PATH} )
  endif(X11_Xkb_INCLUDE_PATH AND X11_Xkblib_INCLUDE_PATH AND X11_Xlib_INCLUDE_PATH)

  if(X11_Xinput_INCLUDE_PATH AND X11_Xinput_LIB)
    set(X11_Xinput_FOUND TRUE)
    set(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xinput_INCLUDE_PATH})
  endif(X11_Xinput_INCLUDE_PATH AND X11_Xinput_LIB)

  if(X11_ICE_LIB AND X11_ICE_INCLUDE_PATH)
    set(X11_ICE_FOUND TRUE)
  endif(X11_ICE_LIB AND X11_ICE_INCLUDE_PATH)

  # Deprecated variable for backwards compatibility with CMake 1.4
  if(X11_Xlib_INCLUDE_PATH AND X11_LIBRARIES)
    set(X11_FOUND 1)
  endif(X11_Xlib_INCLUDE_PATH AND X11_LIBRARIES)

  if(X11_FOUND)
    include(CheckFunctionExists)
    include(CheckLibraryExists)

    # Translated from an autoconf-generated configure script.
    # See libs.m4 in autoconf's m4 directory.
    if($ENV{ISC} MATCHES "^yes$")
      set(X11_X_EXTRA_LIBS -lnsl_s -linet)
    else($ENV{ISC} MATCHES "^yes$")
      set(X11_X_EXTRA_LIBS "")

      # See if XOpenDisplay in X11 works by itself.
      CHECK_LIBRARY_EXISTS("${X11_LIBRARIES}" "XOpenDisplay" "${X11_LIBRARY_DIR}" X11_LIB_X11_SOLO)
      if(NOT X11_LIB_X11_SOLO)
        # Find library needed for dnet_ntoa.
        CHECK_LIBRARY_EXISTS("dnet" "dnet_ntoa" "" X11_LIB_DNET_HAS_DNET_NTOA)
        if(X11_LIB_DNET_HAS_DNET_NTOA)
          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -ldnet)
        else(X11_LIB_DNET_HAS_DNET_NTOA)
          CHECK_LIBRARY_EXISTS("dnet_stub" "dnet_ntoa" "" X11_LIB_DNET_STUB_HAS_DNET_NTOA)
          if(X11_LIB_DNET_STUB_HAS_DNET_NTOA)
            SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -ldnet_stub)
          endif(X11_LIB_DNET_STUB_HAS_DNET_NTOA)
        endif(X11_LIB_DNET_HAS_DNET_NTOA)
      endif(NOT X11_LIB_X11_SOLO)

      # Find library needed for gethostbyname.
      CHECK_FUNCTION_EXISTS("gethostbyname" CMAKE_HAVE_GETHOSTBYNAME)
      if(NOT CMAKE_HAVE_GETHOSTBYNAME)
        CHECK_LIBRARY_EXISTS("nsl" "gethostbyname" "" CMAKE_LIB_NSL_HAS_GETHOSTBYNAME)
        if(CMAKE_LIB_NSL_HAS_GETHOSTBYNAME)
          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lnsl)
        else(CMAKE_LIB_NSL_HAS_GETHOSTBYNAME)
          CHECK_LIBRARY_EXISTS("bsd" "gethostbyname" "" CMAKE_LIB_BSD_HAS_GETHOSTBYNAME)
          if(CMAKE_LIB_BSD_HAS_GETHOSTBYNAME)
            SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lbsd)
          endif(CMAKE_LIB_BSD_HAS_GETHOSTBYNAME)
        endif(CMAKE_LIB_NSL_HAS_GETHOSTBYNAME)
      endif(NOT CMAKE_HAVE_GETHOSTBYNAME)

      # Find library needed for connect.
      CHECK_FUNCTION_EXISTS("connect" CMAKE_HAVE_CONNECT)
      if(NOT CMAKE_HAVE_CONNECT)
        CHECK_LIBRARY_EXISTS("socket" "connect" "" CMAKE_LIB_SOCKET_HAS_CONNECT)
        if(CMAKE_LIB_SOCKET_HAS_CONNECT)
          SET (X11_X_EXTRA_LIBS -lsocket ${X11_X_EXTRA_LIBS})
        endif(CMAKE_LIB_SOCKET_HAS_CONNECT)
      endif(NOT CMAKE_HAVE_CONNECT)

      # Find library needed for remove.
      CHECK_FUNCTION_EXISTS("remove" CMAKE_HAVE_REMOVE)
      if(NOT CMAKE_HAVE_REMOVE)
        CHECK_LIBRARY_EXISTS("posix" "remove" "" CMAKE_LIB_POSIX_HAS_REMOVE)
        if(CMAKE_LIB_POSIX_HAS_REMOVE)
          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lposix)
        endif(CMAKE_LIB_POSIX_HAS_REMOVE)
      endif(NOT CMAKE_HAVE_REMOVE)

      # Find library needed for shmat.
      CHECK_FUNCTION_EXISTS("shmat" CMAKE_HAVE_SHMAT)
      if(NOT CMAKE_HAVE_SHMAT)
        CHECK_LIBRARY_EXISTS("ipc" "shmat" "" CMAKE_LIB_IPS_HAS_SHMAT)
        if(CMAKE_LIB_IPS_HAS_SHMAT)
          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lipc)
        endif(CMAKE_LIB_IPS_HAS_SHMAT)
      endif(NOT CMAKE_HAVE_SHMAT)
    endif($ENV{ISC} MATCHES "^yes$")

    if(X11_ICE_FOUND)
      CHECK_LIBRARY_EXISTS("ICE" "IceConnectionNumber" "${X11_LIBRARY_DIR}"
        CMAKE_LIB_ICE_HAS_ICECONNECTIONNUMBER)
      if(CMAKE_LIB_ICE_HAS_ICECONNECTIONNUMBER)
        SET (X11_X_PRE_LIBS ${X11_ICE_LIB})
        if(X11_SM_LIB)
          SET (X11_X_PRE_LIBS ${X11_SM_LIB} ${X11_X_PRE_LIBS})
        endif(X11_SM_LIB)
      endif(CMAKE_LIB_ICE_HAS_ICECONNECTIONNUMBER)
    endif(X11_ICE_FOUND)

    # Build the final list of libraries.
    set(X11_LIBRARIES ${X11_X_PRE_LIBS} ${X11_LIBRARIES} ${X11_X_EXTRA_LIBS})

    # Check whether we're pulling headers from multiple directories
    list(LENGTH X11_HDR_PATHS HDR_PATH_CNT)
    if("${HDR_PATH_CNT}" GREATER 1)
      message("\nNote: FindX11 is returning headers found in multiple paths.  The user may wish to verify that components are not being returned from multiple X11 installations.\n")
      if(CMAKE_SEARCH_OSX_PATHS)
	if(NOT "${CMAKE_SEARCH_OSX_PATHS}" STREQUAL "SYSTEM")
	  message("Note that CMAKE_SEARCH_OSX_PATHS is set to ${CMAKE_SEARCH_OSX_PATHS} - if ${CMAKE_SEARCH_OSX_PATHS} has an incomplete installation of X11, that may cause this issue - a possible workaround is to set CMAKE_SEARCH_OSX_PATHS to SYSTEM and not use ${CMAKE_SEARCH_OSX_PATHS}.\n")
	endif(NOT "${CMAKE_SEARCH_OSX_PATHS}" STREQUAL "SYSTEM")
      endif(CMAKE_SEARCH_OSX_PATHS)
      foreach(pathitem ${X11_HDR_PATHS})
	message("Headers found in ${pathitem}:")
	foreach(varitem ${X11_HDR_VARS})
	  get_filename_component(item_path "${${varitem}}" PATH)
	  if("${item_path}" STREQUAL "${pathitem}")
	    message("     ${varitem}:${${varitem}}")
	  endif("${item_path}" STREQUAL "${pathitem}")
	endforeach(varitem ${X11_HDR_PATHS})
	message(" ")
      endforeach(pathitem ${X11_HDR_PATHS})
    endif("${HDR_PATH_CNT}" GREATER 1)

    list(LENGTH X11_LIB_PATHS LIB_PATH_CNT)
    if("${LIB_PATH_CNT}" GREATER 1)
      message("\nNote: FindX11 is returning libraries found in multiple paths.  The user may wish to verify that components are not being returned from multiple X11 installations.\n")
      if(CMAKE_SEARCH_OSX_PATHS)
	if(NOT "${CMAKE_SEARCH_OSX_PATHS}" STREQUAL "SYSTEM")
	  message("Note that CMAKE_SEARCH_OSX_PATHS is set to ${CMAKE_SEARCH_OSX_PATHS} - if ${CMAKE_SEARCH_OSX_PATHS} has an incomplete installation of X11, that may cause this issue - a possible workaround is to set CMAKE_SEARCH_OSX_PATHS to SYSTEM and not use ${CMAKE_SEARCH_OSX_PATHS}.\n")
	endif(NOT "${CMAKE_SEARCH_OSX_PATHS}" STREQUAL "SYSTEM")
      endif(CMAKE_SEARCH_OSX_PATHS)

      foreach(pathitem ${X11_LIB_PATHS})
	message("Libraries found in ${pathitem}:")
	foreach(varitem ${X11_LIB_VARS})
	  get_filename_component(item_path "${${varitem}}" PATH)
	  if("${item_path}" STREQUAL "${pathitem}")
	    message("     ${varitem}:${${varitem}}")
	  endif("${item_path}" STREQUAL "${pathitem}")
	endforeach(varitem ${X11_LIB_PATHS})
	message(" ")
      endforeach(pathitem ${X11_LIB_PATHS})
    endif("${LIB_PATH_CNT}" GREATER 1)

    include(FindPackageMessage)
    FIND_PACKAGE_MESSAGE(X11 "Found X11: ${X11_X11_LIB}"
      "[${X11_X11_LIB}][${X11_INCLUDE_DIR}]")
  else(X11_FOUND)
    if(X11_FIND_REQUIRED)
      message(FATAL_ERROR "Could not find X11")
    endif(X11_FIND_REQUIRED)
  endif(X11_FOUND)

  mark_as_advanced(
    X11_X11_INCLUDE_PATH
    X11_X11_LIB
    X11_Xext_LIB
    X11_Xau_LIB
    X11_Xau_INCLUDE_PATH
    X11_Xlib_INCLUDE_PATH
    X11_Xutil_INCLUDE_PATH
    X11_Xcomposite_INCLUDE_PATH
    X11_Xcomposite_LIB
    X11_Xaccess_INCLUDE_PATH
    X11_Xfixes_LIB
    X11_Xfixes_INCLUDE_PATH
    X11_Xrandr_LIB
    X11_Xrandr_INCLUDE_PATH
    X11_Xdamage_LIB
    X11_Xdamage_INCLUDE_PATH
    X11_Xrender_LIB
    X11_Xrender_INCLUDE_PATH
    X11_Xxf86misc_LIB
    X11_xf86misc_INCLUDE_PATH
    X11_xf86vmode_INCLUDE_PATH
    X11_Xi_LIB
    X11_Xi_INCLUDE_PATH
    X11_Xinerama_LIB
    X11_Xinerama_INCLUDE_PATH
    X11_XTest_LIB
    X11_XTest_INCLUDE_PATH
    X11_Xcursor_LIB
    X11_Xcursor_INCLUDE_PATH
    X11_dpms_INCLUDE_PATH
    X11_Xt_LIB
    X11_Xt_INCLUDE_PATH
    X11_Xdmcp_LIB
    X11_LIBRARIES
    X11_Xaccessrules_INCLUDE_PATH
    X11_Xaccessstr_INCLUDE_PATH
    X11_Xdmcp_INCLUDE_PATH
    X11_Xkb_INCLUDE_PATH
    X11_Xkblib_INCLUDE_PATH
    X11_Xscreensaver_INCLUDE_PATH
    X11_Xscreensaver_LIB
    X11_Xpm_INCLUDE_PATH
    X11_Xpm_LIB
    X11_Xinput_LIB
    X11_Xinput_INCLUDE_PATH
    X11_Xft_LIB
    X11_Xft_INCLUDE_PATH
    X11_Xshape_INCLUDE_PATH
    X11_Xv_LIB
    X11_Xv_INCLUDE_PATH
    X11_XShm_INCLUDE_PATH
    X11_ICE_LIB
    X11_ICE_INCLUDE_PATH
    X11_SM_LIB
    )
  set(CMAKE_FIND_FRAMEWORK ${CMAKE_FIND_FRAMEWORK_SAVE})
endif(UNIX)

# X11_FIND_REQUIRED_<component> could be checked too

# Local Variables:
# tab-width: 8
# mode: cmake
# indent-tabs-mode: t
# End:
# ex: shiftwidth=2 tabstop=8
blob
data 60236
/*                       D M - O S G . C P P
 * BRL-CAD
 *
 * Copyright (c) 1988-2014 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @file libdm/dm-osg.cpp
 *
 * A libdm interface to OpenSceneGraph
 *
 */

#include "common.h"

#ifdef DM_OSG

#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdio.h>
#include <math.h>

#include <osg/GraphicsContext>
#include <osgViewer/Viewer>

#if defined(_WIN32)
#  include <osgViewer/api/Win32/GraphicsWindowWin32>
#else
#  include <osgViewer/api/X11/GraphicsWindowX11>
#endif

extern "C" {
#include "tcl.h"
#include "tk.h"
#include "tkPlatDecls.h"
#include "bio.h"

#include "bu.h"
#include "vmath.h"
#include "bn.h"
#include "raytrace.h"
#include "dm.h"
#include "dm/dm_xvars.h"
#include "./dm_util.h"
}
#include "dm/dm-osg.h"


/* For Tk, we need to offset when thinking about screen size in
 * order to allow for the Mac OSX top-of-screen toolbar - Tk
 * itself is quite happy to put things under it */
#define TK_SCREEN_OFFSET 30

#define VIEWFACTOR      (1.0/(*dmp->dm_vp))
#define VIEWSIZE        (2.0*(*dmp->dm_vp))

/* these are from /usr/include/gl.h could be device dependent */
#define XMAXSCREEN	1279
#define YMAXSCREEN	1023
#define YSTEREO		491	/* subfield height, in scanlines */
#define YOFFSET_LEFT	532	/* YSTEREO + YBLANK ? */

/* Display Manager package interface */
#define IRBOUND 4095.9	/* Max magnification in Rot matrix */
#define PLOTBOUND 1000.0	/* Max magnification in Rot matrix */

extern "C" {
    struct dm *osg_open(Tcl_Interp *interp, int argc, char **argv);
}
HIDDEN int osg_close(struct dm *dmp);
HIDDEN int osg_drawBegin(struct dm *dmp);
HIDDEN int osg_drawEnd(struct dm *dmp);
HIDDEN int osg_normal(struct dm *dmp);
HIDDEN int osg_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye);
HIDDEN int osg_loadPMatrix(struct dm *dmp, fastf_t *mat);
HIDDEN int osg_drawString2D(struct dm *dmp, const char *str, fastf_t x, fastf_t y, int size, int use_aspect);
HIDDEN int osg_drawLine2D(struct dm *dmp, fastf_t X1, fastf_t Y1, fastf_t X2, fastf_t Y2);
HIDDEN int osg_drawLine3D(struct dm *dmp, point_t pt1, point_t pt2);
HIDDEN int osg_drawLines3D(struct dm *dmp, int npoints, point_t *points, int sflag);
HIDDEN int osg_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y);
HIDDEN int osg_drawPoint3D(struct dm *dmp, point_t point);
HIDDEN int osg_drawPoints3D(struct dm *dmp, int npoints, point_t *points);
HIDDEN int osg_drawVList(struct dm *dmp, register struct bn_vlist *vp);
HIDDEN int osg_drawVListHiddenLine(struct dm *dmp, register struct bn_vlist *vp);
HIDDEN int osg_draw(struct dm *dmp, struct bn_vlist *(*callback_function)(void *), genptr_t *data);
HIDDEN int osg_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency);
HIDDEN int osg_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b);
HIDDEN int osg_setLineAttr(struct dm *dmp, int width, int style);
HIDDEN int osg_configureWin_guts(struct dm *dmp, int force);
HIDDEN int osg_configureWin(struct dm *dmp, int force);
HIDDEN int osg_setLight(struct dm *dmp, int lighting_on);
HIDDEN int osg_setTransparency(struct dm *dmp, int transparency_on);
HIDDEN int osg_setDepthMask(struct dm *dmp, int depthMask_on);
HIDDEN int osg_setZBuffer(struct dm *dmp, int zbuffer_on);
HIDDEN int osg_setWinBounds(struct dm *dmp, fastf_t *w);
HIDDEN int osg_debug(struct dm *dmp, int lvl);
HIDDEN int osg_logfile(struct dm *dmp, const char *filename);
HIDDEN int osg_beginDList(struct dm *dmp, unsigned int list);
HIDDEN int osg_endDList(struct dm *dmp);
HIDDEN void osg_drawDList(unsigned int list);
HIDDEN int osg_freeDLists(struct dm *dmp, unsigned int list, int range);
HIDDEN int osg_genDLists(struct dm *dmp, size_t range);
HIDDEN int osg_getDisplayImage(struct dm *dmp, unsigned char **image);
HIDDEN void osg_reshape(struct dm *dmp, int width, int height);
HIDDEN int osg_makeCurrent(struct dm *dmp);


struct dm dm_osg = {
    osg_close,
    osg_drawBegin,
    osg_drawEnd,
    osg_normal,
    osg_loadMatrix,
    osg_loadPMatrix,
    osg_drawString2D,
    osg_drawLine2D,
    osg_drawLine3D,
    osg_drawLines3D,
    osg_drawPoint2D,
    osg_drawPoint3D,
    osg_drawPoints3D,
    osg_drawVList,
    osg_drawVListHiddenLine,
    osg_draw,
    osg_setFGColor,
    osg_setBGColor,
    osg_setLineAttr,
    osg_configureWin,
    osg_setWinBounds,
    osg_setLight,
    osg_setTransparency,
    osg_setDepthMask,
    osg_setZBuffer,
    osg_debug,
    osg_logfile,
    osg_beginDList,
    osg_endDList,
    osg_drawDList,
    osg_freeDLists,
    osg_genDLists,
    osg_getDisplayImage, /* display to image function */
    osg_reshape,
    osg_makeCurrent,
    0,
    1,				/* has displaylist */
    0,                          /* no stereo by default */
    1.0,			/* zoom-in limit */
    1,				/* bound flag */
    "osg",
    "OpenSceneGraph graphics",
    DM_TYPE_OSG,
    1,
    0,
    0,
    0, /* bytes per pixel */
    0, /* bits per channel */
    0,
    0,
    1.0, /* aspect ratio */
    0,
    {0, 0},
    BU_VLS_INIT_ZERO,		/* bu_vls path name*/
    BU_VLS_INIT_ZERO,		/* bu_vls full name drawing window */
    BU_VLS_INIT_ZERO,		/* bu_vls short name drawing window */
    {0, 0, 0},			/* bg color */
    {0, 0, 0},			/* fg color */
    {GED_MIN, GED_MIN, GED_MIN},	/* clipmin */
    {GED_MAX, GED_MAX, GED_MAX},	/* clipmax */
    0,				/* no debugging */
    BU_VLS_INIT_ZERO,		/* bu_vls logfile */
    0,				/* no perspective */
    0,				/* no lighting */
    0,				/* no transparency */
    1,				/* depth buffer is writable */
    1,				/* zbuffer */
    0,				/* no zclipping */
    0,                          /* clear back buffer after drawing and swap */
    0,                          /* not overriding the auto font size */
    0				/* Tcl interpreter */
};


static fastf_t default_viewscale = 1000.0;
static double xlim_view = 1.0;	/* args for glOrtho*/
static double ylim_view = 1.0;

/* lighting parameters */
static float amb_three[] = {0.3, 0.3, 0.3, 1.0};

static float light0_position[] = {0.0, 0.0, 1.0, 0.0};
static float light0_diffuse[] = {1.0, 1.0, 1.0, 1.0}; /* white */
static float wireColor[4];
static float ambientColor[4];
static float specularColor[4];
static float diffuseColor[4];
static float backDiffuseColorDark[4];
static float backDiffuseColorLight[4];

HIDDEN void
osg_printmat(struct bu_vls *tmp_vls, fastf_t *mat) {
    bu_vls_printf(tmp_vls, "%g %g %g %g\n", mat[0], mat[4], mat[8], mat[12]);
    bu_vls_printf(tmp_vls, "%g %g %g %g\n", mat[1], mat[5], mat[9], mat[13]);
    bu_vls_printf(tmp_vls, "%g %g %g %g\n", mat[2], mat[6], mat[10], mat[14]);
    bu_vls_printf(tmp_vls, "%g %g %g %g\n", mat[3], mat[7], mat[11], mat[15]);
}

HIDDEN void
osg_printglmat(struct bu_vls *tmp_vls, GLfloat *m) {
    bu_vls_printf(tmp_vls, "%g %g %g %g\n", m[0], m[4], m[8], m[12]);
    bu_vls_printf(tmp_vls, "%g %g %g %g\n", m[1], m[5], m[9], m[13]);
    bu_vls_printf(tmp_vls, "%g %g %g %g\n", m[2], m[6], m[10], m[14]);
    bu_vls_printf(tmp_vls, "%g %g %g %g\n", m[3], m[7], m[11], m[15]);
}

extern "C" {
void
osg_fogHint(struct dm *dmp, int fastfog)
{
    ((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.fastfog = fastfog;
    glHint(GL_FOG_HINT, fastfog ? GL_FASTEST : GL_NICEST);
}
}

HIDDEN int
osg_setBGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b)
{
    if (dmp->dm_debugLevel == 1)
	bu_log("osg_setBGColor()\n");

    dmp->dm_bg[0] = r;
    dmp->dm_bg[1] = g;
    dmp->dm_bg[2] = b;

    ((struct osg_vars *)dmp->dm_vars.priv_vars)->r = r / 255.0;
    ((struct osg_vars *)dmp->dm_vars.priv_vars)->g = g / 255.0;
    ((struct osg_vars *)dmp->dm_vars.priv_vars)->b = b / 255.0;

    ((struct osg_vars *)dmp->dm_vars.priv_vars)->graphicsContext->swapBuffers();
    glClearColor(((struct osg_vars *)dmp->dm_vars.priv_vars)->r,
	    ((struct osg_vars *)dmp->dm_vars.priv_vars)->g,
	    ((struct osg_vars *)dmp->dm_vars.priv_vars)->b,
	    0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    return TCL_OK;
}


/*
 * Either initially, or on resize/reshape of the window,
 * sense the actual size of the window, and perform any
 * other initializations of the window configuration.
 *
 * also change font size if necessary
 */
HIDDEN int
osg_configureWin_guts(struct dm *dmp, int force)
{
#if 0
    XWindowAttributes xwa;
    XFontStruct *newfontstruct;

    if (dmp->dm_debugLevel)
	bu_log("osg_configureWin_guts()\n");

    XGetWindowAttributes(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			 ((struct dm_xvars *)dmp->dm_vars.pub_vars)->win, &xwa);
    /* nothing to do */
    if (!force &&
	dmp->dm_height == xwa.height &&
	dmp->dm_width == xwa.width)
	return TCL_OK;
#endif

    int width;
    int height;

    struct dm_xvars *pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;

    if (pubvars->top != pubvars->xtkwin) {
	width = Tk_Width(Tk_Parent(pubvars->xtkwin));
	height = Tk_Height(Tk_Parent(pubvars->xtkwin));
    } else {
	width = Tk_Width(pubvars->top);
	height = Tk_Height(pubvars->top);
    }

    if (!force &&
	    dmp->dm_height == height &&
	    dmp->dm_width == width)
	return TCL_OK;

    osg_reshape(dmp, width, height);
#if 0
    /* First time through, load a font or quit */
    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct == NULL) {
	if ((((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct =
	     XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			    FONT9)) == NULL) {
	    /* Try hardcoded backup font */
	    if ((((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct =
		 XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
				FONTBACK)) == NULL) {
		bu_log("osg_configureWin_guts: Can't open font '%s' or '%s'\n", FONT9, FONTBACK);
		return TCL_ERROR;
	    }
	}
	glXUseXFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
		    0, 127, ((struct osg_vars *)dmp->dm_vars.priv_vars)->fontOffset);
    }

    if (DM_VALID_FONT_SIZE(dmp->dm_fontsize)) {
	if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != dmp->dm_fontsize) {
	    if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						DM_FONT_SIZE_TO_NAME(dmp->dm_fontsize))) != NULL) {
		XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			  ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
		((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
		glXUseXFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
			    0, 127, ((struct osg_vars *)dmp->dm_vars.priv_vars)->fontOffset);
	    }
	}
    } else {
	/* Always try to choose a the font that best fits the window size.
	 */

	if (dmp->dm_width < 582) {
	    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 5) {
		if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						    FONT5)) != NULL) {
		    XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
		    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
		    glXUseXFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
				0, 127, ((struct osg_vars *)dmp->dm_vars.priv_vars)->fontOffset);
		}
	    }
	} else if (dmp->dm_width < 679) {
	    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 6) {
		if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						    FONT6)) != NULL) {
		    XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
		    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
		    glXUseXFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
				0, 127, ((struct osg_vars *)dmp->dm_vars.priv_vars)->fontOffset);
		}
	    }
	} else if (dmp->dm_width < 776) {
	    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 7) {
		if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						    FONT7)) != NULL) {
		    XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
		    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
		    glXUseXFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
				0, 127, ((struct osg_vars *)dmp->dm_vars.priv_vars)->fontOffset);
		}
	    }
	} else if (dmp->dm_width < 873) {
	    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 8) {
		if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						    FONT8)) != NULL) {
		    XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
		    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
		    glXUseXFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
				0, 127, ((struct osg_vars *)dmp->dm_vars.priv_vars)->fontOffset);
		}
	    }
	} else if (dmp->dm_width < 1455) {
	    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 9) {
		if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						    FONT9)) != NULL) {
		    XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
		    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
		    glXUseXFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
				0, 127, ((struct osg_vars *)dmp->dm_vars.priv_vars)->fontOffset);
		}
	    }
	} else if (dmp->dm_width < 2037) {
	    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 10) {
		if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						    FONT10)) != NULL) {
		    XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
		    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
		    glXUseXFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
				0, 127, ((struct osg_vars *)dmp->dm_vars.priv_vars)->fontOffset);
		}
	    }
	} else {
	    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->per_char->width != 12) {
		if ((newfontstruct = XLoadQueryFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
						    FONT12)) != NULL) {
		    XFreeFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct);
		    ((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct = newfontstruct;
		    glXUseXFont(((struct dm_xvars *)dmp->dm_vars.pub_vars)->fontstruct->fid,
				0, 127, ((struct osg_vars *)dmp->dm_vars.priv_vars)->fontOffset);
		}
	    }
	}
    }
#endif
    return TCL_OK;
}


HIDDEN void
osg_reshape(struct dm *dmp, int width, int height)
{
    GLint mm;

    dmp->dm_height = height;
    dmp->dm_width = width;
    dmp->dm_aspect = (fastf_t)dmp->dm_width / (fastf_t)dmp->dm_height;

    if (dmp->dm_debugLevel) {
	GLfloat m[16];
	bu_log("osg_reshape()\n");
	bu_log("width = %d, height = %d\n", dmp->dm_width, dmp->dm_height);
	glGetFloatv (GL_MODELVIEW_MATRIX, m);
	glGetFloatv (GL_PROJECTION_MATRIX, m);
    }

    glViewport(0, 0, dmp->dm_width, dmp->dm_height);

    glClearColor(((struct osg_vars *)dmp->dm_vars.priv_vars)->r,
		 ((struct osg_vars *)dmp->dm_vars.priv_vars)->g,
		 ((struct osg_vars *)dmp->dm_vars.priv_vars)->b,
		 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glGetIntegerv(GL_MATRIX_MODE, &mm);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-xlim_view, xlim_view, -ylim_view, ylim_view, dmp->dm_clipmin[2], dmp->dm_clipmax[2]);
    glMatrixMode(mm);
}


HIDDEN int
osg_makeCurrent(struct dm *dmp)
{
    if (dmp->dm_debugLevel)
	bu_log("osg_makeCurrent()\n");

    ((struct osg_vars *)dmp->dm_vars.priv_vars)->graphicsContext->makeCurrent();

    return TCL_OK;
}


HIDDEN int
osg_configureWin(struct dm *dmp, int force)
{
    ((struct osg_vars *)dmp->dm_vars.priv_vars)->graphicsContext->makeCurrent();

    return osg_configureWin_guts(dmp, force);
}


HIDDEN int
osg_setLight(struct dm *dmp, int lighting_on)
{
    if (dmp->dm_debugLevel)
	bu_log("osg_setLight()\n");

    dmp->dm_light = lighting_on;
    ((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.lighting_on = dmp->dm_light;

    if (!dmp->dm_light) {
	/* Turn it off */
	glDisable(GL_LIGHTING);
    } else {
	/* Turn it on */

	if (1 < dmp->dm_light)
	    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
	else
	    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);

	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, amb_three);
	glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);

	glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light0_diffuse);

	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
    }

    return TCL_OK;
}


/*
 * Gracefully release the display.
 */
HIDDEN int
osg_close(struct dm *dmp)
{
    ((struct osg_vars *)dmp->dm_vars.priv_vars)->graphicsContext->makeCurrent();
    ((struct osg_vars *)dmp->dm_vars.priv_vars)->graphicsContext->releaseContext();

    if (((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin)
	Tk_DestroyWindow(((struct dm_xvars *)dmp->dm_vars.pub_vars)->xtkwin);

    bu_vls_free(&dmp->dm_pathName);
    bu_vls_free(&dmp->dm_tkName);
    bu_vls_free(&dmp->dm_dName);
    bu_free(dmp->dm_vars.priv_vars, "osg_close: osg_vars");
    bu_free(dmp->dm_vars.pub_vars, "osg_close: dm_xvars");
    bu_free(dmp, "osg_close: dmp");

    return TCL_OK;
}


/*
 * Fire up the display manager, and the display processor.
 *
 */
extern "C"
struct dm *
osg_open(Tcl_Interp *interp, int argc, char **argv)
{
    static int count = 0;
    GLfloat backgnd[4];
    struct bu_vls str = BU_VLS_INIT_ZERO;
    struct bu_vls init_proc_vls = BU_VLS_INIT_ZERO;
    struct dm *dmp = (struct dm *)NULL;
    Tk_Window tkwin = (Tk_Window)NULL;

    struct dm_xvars *pubvars = NULL;
    struct osg_vars *privvars = NULL;

    if ((tkwin = Tk_MainWindow(interp)) == NULL) {
	return DM_NULL;
    }

    BU_ALLOC(dmp, struct dm);

    *dmp = dm_osg; /* struct copy */
    dmp->dm_interp = interp;
    dmp->dm_lineWidth = 1;
    dmp->dm_bytes_per_pixel = sizeof(GLuint);
    dmp->dm_bits_per_channel = 8;
    bu_vls_init(&(dmp->dm_log));

    BU_ALLOC(dmp->dm_vars.pub_vars, struct dm_xvars);
    if (dmp->dm_vars.pub_vars == (genptr_t)NULL) {
	bu_free(dmp, "osg_open: dmp");
	return DM_NULL;
    }
    pubvars = (struct dm_xvars *)dmp->dm_vars.pub_vars;

    BU_ALLOC(dmp->dm_vars.priv_vars, struct osg_vars);
    if (dmp->dm_vars.priv_vars == (genptr_t)NULL) {
	bu_free(dmp->dm_vars.pub_vars, "osg_open: dmp->dm_vars.pub_vars");
	bu_free(dmp, "osg_open: dmp");
	return DM_NULL;
    }
    privvars = (struct osg_vars *)dmp->dm_vars.priv_vars;
    bu_vls_init(&(privvars->mvars.log));

    dmp->dm_vp = &default_viewscale;

    bu_vls_init(&dmp->dm_pathName);
    bu_vls_init(&dmp->dm_tkName);
    bu_vls_init(&dmp->dm_dName);

    dm_processOptions(dmp, &init_proc_vls, --argc, ++argv);

    if (bu_vls_strlen(&dmp->dm_pathName) == 0)
	bu_vls_printf(&dmp->dm_pathName, ".dm_osg%d", count);
    ++count;
    if (bu_vls_strlen(&dmp->dm_dName) == 0) {
	char *dp;

	dp = getenv("DISPLAY");
	if (dp)
	    bu_vls_strcpy(&dmp->dm_dName, dp);
	else
	    bu_vls_strcpy(&dmp->dm_dName, ":0.0");
    }
    if (bu_vls_strlen(&init_proc_vls) == 0)
	bu_vls_strcpy(&init_proc_vls, "bind_dm");

    /* initialize dm specific variables */
    pubvars->devmotionnotify = LASTEvent;
    pubvars->devbuttonpress = LASTEvent;
    pubvars->devbuttonrelease = LASTEvent;
    dmp->dm_aspect = 1.0;

    /* initialize modifiable variables */
    privvars->mvars.rgb = 1;
    privvars->mvars.doublebuffer = 1;
    privvars->mvars.fastfog = 1;
    privvars->mvars.fogdensity = 1.0;
    privvars->mvars.lighting_on = dmp->dm_light;
    privvars->mvars.zbuffer_on = dmp->dm_zbuffer;
    privvars->mvars.zclipping_on = dmp->dm_zclip;
    privvars->mvars.debug = dmp->dm_debugLevel;
    privvars->mvars.bound = dmp->dm_bound;
    privvars->mvars.boundFlag = dmp->dm_boundFlag;

    /* this is important so that osg_configureWin knows to set the font */
    pubvars->fontstruct = NULL;

    if (dmp->dm_top) {
	/* Make xtkwin a toplevel window */
	pubvars->xtkwin =
	    Tk_CreateWindowFromPath(interp,
				    tkwin,
				    bu_vls_addr(&dmp->dm_pathName),
				    bu_vls_addr(&dmp->dm_dName));
	pubvars->top = pubvars->xtkwin;
    } else {
	char *cp;

	cp = strrchr(bu_vls_addr(&dmp->dm_pathName), (int)'.');
	if (cp == bu_vls_addr(&dmp->dm_pathName)) {
	    pubvars->top = tkwin;
	} else {
	    struct bu_vls top_vls = BU_VLS_INIT_ZERO;

	    bu_vls_strncpy(&top_vls, (const char *)bu_vls_addr(&dmp->dm_pathName), cp - bu_vls_addr(&dmp->dm_pathName));

	    pubvars->top =
		Tk_NameToWindow(interp, bu_vls_addr(&top_vls), tkwin);
	    bu_vls_free(&top_vls);
	}

	/* Make xtkwin an embedded window */
	pubvars->xtkwin =
	    Tk_CreateWindow(interp, pubvars->top,
			    cp + 1, (char *)NULL);
    }

    if (pubvars->xtkwin == NULL) {
	bu_log("dm-osg: Failed to open %s\n", bu_vls_addr(&dmp->dm_pathName));
	bu_vls_free(&init_proc_vls);
	(void)osg_close(dmp);
	return DM_NULL;
    }


    /* Make sure the window is large enough.  If these values are not large
     * enough, the drawing window will not resize properly to match
     * the height change of the parent window.  This is also true
     * of the ogl display manager, although it is undocumented *why*
     * this initial screen-based sizing is needed... */
    {
	int make_square = -1;

	if (dmp->dm_width == 0) {
	    bu_vls_sprintf(&str, "winfo screenwidth .");
	    if (Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR) {
		bu_vls_free(&init_proc_vls);
		bu_vls_free(&str);
		(void)osg_close(dmp);
		return DM_NULL;
	    } else {
		Tcl_Obj *tclresult = Tcl_GetObjResult(interp);
		dmp->dm_width = tclresult->internalRep.longValue - TK_SCREEN_OFFSET;
	    }
	    ++make_square;
	}
	if (dmp->dm_height == 0) {
	    bu_vls_sprintf(&str, "winfo screenheight .");
	    if (Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR) {
		bu_vls_free(&init_proc_vls);
		bu_vls_free(&str);
		(void)osg_close(dmp);
		return DM_NULL;
	    } else {
		Tcl_Obj *tclresult = Tcl_GetObjResult(interp);
		dmp->dm_height = tclresult->internalRep.longValue - TK_SCREEN_OFFSET;
	    }
	    ++make_square;
	}

	if (make_square > 0) {
	    /* Make window square */
	    if (dmp->dm_height <
		    dmp->dm_width)
		dmp->dm_width =
		    dmp->dm_height;
	    else
		dmp->dm_height =
		    dmp->dm_width;
	}
    }

    bu_vls_printf(&dmp->dm_tkName, "%s", (char *)Tk_Name(pubvars->xtkwin));

    bu_vls_sprintf(&str, "_init_dm %s %s\n",
		  bu_vls_addr(&init_proc_vls),
		  bu_vls_addr(&dmp->dm_pathName));

    if (Tcl_Eval(interp, bu_vls_addr(&str)) == TCL_ERROR) {
	bu_vls_free(&init_proc_vls);
	bu_vls_free(&str);
	(void)osg_close(dmp);
	return DM_NULL;
    }

    bu_vls_free(&init_proc_vls);
    bu_vls_free(&str);

    pubvars->dpy = Tk_Display(pubvars->top);

    /* make sure there really is a display before proceeding. */
    if (!(pubvars->dpy)) {
	bu_vls_free(&init_proc_vls);
	bu_vls_free(&str);
	(void)osg_close(dmp);
	return DM_NULL;
    }

    Tk_GeometryRequest(pubvars->xtkwin,
		       dmp->dm_width,
		       dmp->dm_height);

    pubvars->depth = privvars->mvars.depth;

    Tk_MakeWindowExist(pubvars->xtkwin);

    pubvars->win = Tk_WindowId(pubvars->xtkwin);
    dmp->dm_id = pubvars->win;

    Tk_MapWindow(pubvars->xtkwin);


    // Init the Windata Variable that holds the handle for the Window to display OSG in.
    // Check the QOSGWidget.cpp example for more logic relevant to this.  Need to find
    // something showing how to handle Cocoa for the Mac, if that's possible
    osg::ref_ptr<osg::GraphicsContext::Traits> traits = new osg::GraphicsContext::Traits;
#if defined(_WIN32)
    osg::ref_ptr<osg::Referenced> windata = new osgViewer::GraphicsWindowWin32::WindowData(Tk_GetHWND(((struct dm_xvars *)(dmp->dm_vars.pub_vars))->win));
#else
    osg::ref_ptr<osg::Referenced> windata = new osgViewer::GraphicsWindowX11::WindowData(((struct dm_xvars *)(dmp->dm_vars.pub_vars))->win);
#endif

    // Although we are not making direct use of osgViewer currently, we need its
    // initialization to make sure we have all the libraries we need loaded and
    // ready.  TODO Investigate whether GraphicsWindowEmbedded (specifically the version
    // that takes osg::GraphicsContext::Traits *traits as an argument) would work
    // better than a raw createGraphicsContext.
    osgViewer::Viewer *viewer = new osgViewer::Viewer();
    delete viewer;

    // Setup the traits parameters
    traits->x = 0;
    traits->y = 0;
    traits->width = dmp->dm_width;
    traits->height = dmp->dm_height;
    traits->depth = 24;
    traits->windowDecoration = false;
    traits->doubleBuffer = true;
    traits->sharedContext = 0;
    traits->setInheritedWindowPixelFormat = true;

    traits->inheritedWindowData = windata;

    // Create the Graphics Context
    privvars->graphicsContext = osg::GraphicsContext::createGraphicsContext(traits.get());

    privvars->graphicsContext->realize();
    privvars->graphicsContext->makeCurrent();

    /* display list (fontOffset + char) will display a given ASCII char */
    if ((privvars->fontOffset = glGenLists(128))==0) {
	bu_log("dm-ogl: Can't make display lists for font.\n");
	(void)osg_close(dmp);
	return DM_NULL;
    }

    /* This is the applications display list offset */
    dmp->dm_displaylist = privvars->fontOffset + 128;

    osg_setBGColor(dmp, 0, 0, 0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    if (privvars->mvars.doublebuffer)
	glDrawBuffer(GL_BACK);
    else
	glDrawBuffer(GL_FRONT);

    /* do viewport, ortho commands and initialize font */
    (void)osg_configureWin_guts(dmp, 1);

    /* Lines will be solid when stippling disabled, dashed when enabled*/
    glLineStipple(1, 0xCF33);
    glDisable(GL_LINE_STIPPLE);

    backgnd[0] = backgnd[1] = backgnd[2] = backgnd[3] = 0.0;
    glFogi(GL_FOG_MODE, GL_LINEAR);
    glFogf(GL_FOG_START, 0.0);
    glFogf(GL_FOG_END, 2.0);
    glFogfv(GL_FOG_COLOR, backgnd);

    /*XXX Need to do something about VIEWFACTOR */
    glFogf(GL_FOG_DENSITY, VIEWFACTOR);

    /* Initialize matrices */
    /* Leave it in model_view mode normally */
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-xlim_view, xlim_view, -ylim_view, ylim_view, 0.0, 2.0);
    glGetDoublev(GL_PROJECTION_MATRIX, privvars->faceplate_mat);
    glPushMatrix();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glPushMatrix();
    glLoadIdentity();
    privvars->face_flag = 1;	/* faceplate matrix is on top of stack */

    osg_setZBuffer(dmp, dmp->dm_zbuffer);
    osg_setLight(dmp, dmp->dm_light);

    return dmp;
}


extern "C" int
osg_share_dlist(struct dm *UNUSED(dmp1), struct dm *UNUSED(dmp2))
{
#if 0
    GLfloat backgnd[4];
    GLfloat vf;
    GLXContext old_glxContext;

    if (dmp1 == (struct dm *)NULL)
	return TCL_ERROR;

    if (dmp2 == (struct dm *)NULL) {
	/* create a new graphics context for dmp1 with private display lists */

	old_glxContext = ((struct osg_vars *)dmp1->dm_vars.priv_vars)->glxc;

	if ((((struct osg_vars *)dmp1->dm_vars.priv_vars)->glxc =
	     glXCreateContext(((struct dm_xvars *)dmp1->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp1->dm_vars.pub_vars)->vip,
			      (GLXContext)NULL, GL_TRUE))==NULL) {
	    bu_log("osg_share_dlist: couldn't create glXContext.\nUsing old context\n.");
	    ((struct osg_vars *)dmp1->dm_vars.priv_vars)->glxc = old_glxContext;

	    return TCL_ERROR;
	}

	if (!glXMakeCurrent(((struct dm_xvars *)dmp1->dm_vars.pub_vars)->dpy,
			    ((struct dm_xvars *)dmp1->dm_vars.pub_vars)->win,
			    ((struct osg_vars *)dmp1->dm_vars.priv_vars)->glxc)) {
	    bu_log("osg_share_dlist: Couldn't make context current\nUsing old context\n.");
	    ((struct osg_vars *)dmp1->dm_vars.priv_vars)->glxc = old_glxContext;

	    return TCL_ERROR;
	}

	/* display list (fontOffset + char) will display a given ASCII char */
	if ((((struct osg_vars *)dmp1->dm_vars.priv_vars)->fontOffset = glGenLists(128))==0) {
	    bu_log("dm-ogl: Can't make display lists for font.\nUsing old context\n.");
	    ((struct osg_vars *)dmp1->dm_vars.priv_vars)->glxc = old_glxContext;

	    return TCL_ERROR;
	}

	/* This is the applications display list offset */
	dmp1->dm_displaylist = ((struct osg_vars *)dmp1->dm_vars.priv_vars)->fontOffset + 128;

	osg_setBGColor(dmp1, 0, 0, 0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	if (((struct osg_vars *)dmp1->dm_vars.priv_vars)->mvars.doublebuffer)
	    glDrawBuffer(GL_BACK);
	else
	    glDrawBuffer(GL_FRONT);

	/* this is important so that osg_configureWin knows to set the font */
	((struct dm_xvars *)dmp1->dm_vars.pub_vars)->fontstruct = NULL;

	/* do viewport, ortho commands and initialize font */
	(void)osg_configureWin_guts(dmp1, 1);

	/* Lines will be solid when stippling disabled, dashed when enabled*/
	glLineStipple(1, 0xCF33);
	glDisable(GL_LINE_STIPPLE);

	backgnd[0] = backgnd[1] = backgnd[2] = backgnd[3] = 0.0;
	glFogi(GL_FOG_MODE, GL_LINEAR);
	glFogf(GL_FOG_START, 0.0);
	glFogf(GL_FOG_END, 2.0);
	glFogfv(GL_FOG_COLOR, backgnd);

	/*XXX Need to do something about VIEWFACTOR */
	vf = 1.0/(*dmp1->dm_vp);
	glFogf(GL_FOG_DENSITY, vf);

	/* Initialize matrices */
	/* Leave it in model_view mode normally */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-xlim_view, xlim_view, -ylim_view, ylim_view, 0.0, 2.0);
	glGetDoublev(GL_PROJECTION_MATRIX, ((struct osg_vars *)dmp1->dm_vars.priv_vars)->faceplate_mat);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glPushMatrix();
	glLoadIdentity();
	((struct osg_vars *)dmp1->dm_vars.priv_vars)->face_flag = 1; /* faceplate matrix is on top of stack */

	/* destroy old context */
	glXMakeCurrent(((struct dm_xvars *)dmp1->dm_vars.pub_vars)->dpy, None, NULL);
	glXDestroyContext(((struct dm_xvars *)dmp1->dm_vars.pub_vars)->dpy, old_glxContext);
    } else {
	/* dmp1 will share its display lists with dmp2 */

	old_glxContext = ((struct osg_vars *)dmp2->dm_vars.priv_vars)->glxc;

	if ((((struct osg_vars *)dmp2->dm_vars.priv_vars)->glxc =
	     glXCreateContext(((struct dm_xvars *)dmp2->dm_vars.pub_vars)->dpy,
			      ((struct dm_xvars *)dmp2->dm_vars.pub_vars)->vip,
			      ((struct osg_vars *)dmp1->dm_vars.priv_vars)->glxc,
			      GL_TRUE))==NULL) {
	    bu_log("osg_share_dlist: couldn't create glXContext.\nUsing old context\n.");
	    ((struct osg_vars *)dmp2->dm_vars.priv_vars)->glxc = old_glxContext;

	    return TCL_ERROR;
	}

	if (!glXMakeCurrent(((struct dm_xvars *)dmp2->dm_vars.pub_vars)->dpy,
			    ((struct dm_xvars *)dmp2->dm_vars.pub_vars)->win,
			    ((struct osg_vars *)dmp2->dm_vars.priv_vars)->glxc)) {
	    bu_log("osg_share_dlist: Couldn't make context current\nUsing old context\n.");
	    ((struct osg_vars *)dmp2->dm_vars.priv_vars)->glxc = old_glxContext;

	    return TCL_ERROR;
	}

	((struct osg_vars *)dmp2->dm_vars.priv_vars)->fontOffset = ((struct osg_vars *)dmp1->dm_vars.priv_vars)->fontOffset;
	dmp2->dm_displaylist = dmp1->dm_displaylist;

	osg_setBGColor(dmp2, 0, 0, 0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	if (((struct osg_vars *)dmp2->dm_vars.priv_vars)->mvars.doublebuffer)
	    glDrawBuffer(GL_BACK);
	else
	    glDrawBuffer(GL_FRONT);

	/* do viewport, ortho commands and initialize font */
	(void)osg_configureWin_guts(dmp2, 1);

	/* Lines will be solid when stippling disabled, dashed when enabled*/
	glLineStipple(1, 0xCF33);
	glDisable(GL_LINE_STIPPLE);

	backgnd[0] = backgnd[1] = backgnd[2] = backgnd[3] = 0.0;
	glFogi(GL_FOG_MODE, GL_LINEAR);
	glFogf(GL_FOG_START, 0.0);
	glFogf(GL_FOG_END, 2.0);
	glFogfv(GL_FOG_COLOR, backgnd);

	/*XXX Need to do something about VIEWFACTOR */
	vf = 1.0/(*dmp2->dm_vp);
	glFogf(GL_FOG_DENSITY, vf);

	/* Initialize matrices */
	/* Leave it in model_view mode normally */
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrtho(-xlim_view, xlim_view, -ylim_view, ylim_view, 0.0, 2.0);
	glGetDoublev(GL_PROJECTION_MATRIX, ((struct osg_vars *)dmp2->dm_vars.priv_vars)->faceplate_mat);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glPushMatrix();
	glLoadIdentity();
	((struct osg_vars *)dmp2->dm_vars.priv_vars)->face_flag = 1; /* faceplate matrix is on top of stack */

	/* destroy old context */
	glXMakeCurrent(((struct dm_xvars *)dmp2->dm_vars.pub_vars)->dpy, None, NULL);
	glXDestroyContext(((struct dm_xvars *)dmp2->dm_vars.pub_vars)->dpy, old_glxContext);
    }
#endif
    return TCL_OK;
}


/*
 * There are global variables which are parameters to this routine.
 */
HIDDEN int
osg_drawBegin(struct dm *dmp)
{
    GLfloat fogdepth;

    if (dmp->dm_debugLevel) {
	bu_log("osg_drawBegin\n");
    }

    if (dmp->dm_debugLevel == 3) {
	GLfloat m[16];
	struct bu_vls tmp_vls = BU_VLS_INIT_ZERO;

	bu_vls_printf(&tmp_vls, "initial view matrix = \n");

	glGetFloatv (GL_MODELVIEW_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_vls_printf(&tmp_vls, "initial projection matrix = \n");
	glGetFloatv (GL_PROJECTION_MATRIX, m);
	osg_printglmat(&tmp_vls, m);

	bu_log("%s", bu_vls_addr(&tmp_vls));
	bu_vls_free(&tmp_vls);
    }

    ((struct osg_vars *)dmp->dm_vars.priv_vars)->graphicsContext->makeCurrent();

    /* clear back buffer */
    if (!dmp->dm_clearBufferAfter &&
	((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.doublebuffer) {
	glClearColor(((struct osg_vars *)dmp->dm_vars.priv_vars)->r,
		     ((struct osg_vars *)dmp->dm_vars.priv_vars)->g,
		     ((struct osg_vars *)dmp->dm_vars.priv_vars)->b,
		     0.0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    if (((struct osg_vars *)dmp->dm_vars.priv_vars)->face_flag) {
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	((struct osg_vars *)dmp->dm_vars.priv_vars)->face_flag = 0;
	if (((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.cueing_on) {
	    glEnable(GL_FOG);
	    /*XXX Need to do something with Viewscale */
	    fogdepth = 2.2 * (*dmp->dm_vp); /* 2.2 is heuristic */
	    glFogf(GL_FOG_END, fogdepth);
	    fogdepth = (GLfloat) (0.5*((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.fogdensity/
				  (*dmp->dm_vp));
	    glFogf(GL_FOG_DENSITY, fogdepth);
	    glFogi(GL_FOG_MODE, dmp->dm_perspective ? GL_EXP : GL_LINEAR);
	}
	if (dmp->dm_light) {
	    glEnable(GL_LIGHTING);
	}
    }

    if (dmp->dm_debugLevel == 3) {
	GLfloat m[16];
	struct bu_vls tmp_vls = BU_VLS_INIT_ZERO;

	bu_vls_printf(&tmp_vls, "after begin view matrix = \n");

	glGetFloatv (GL_MODELVIEW_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_vls_printf(&tmp_vls, "after begin projection matrix = \n");
	glGetFloatv (GL_PROJECTION_MATRIX, m);
	osg_printglmat(&tmp_vls, m);

	bu_log("%s", bu_vls_addr(&tmp_vls));
	bu_vls_free(&tmp_vls);
    }


    return TCL_OK;
}


HIDDEN int
osg_drawEnd(struct dm *dmp)
{
    if (dmp->dm_debugLevel)
	bu_log("osg_drawEnd()\n");

    if (dmp->dm_debugLevel == 3) {
	GLfloat m[16];
	struct bu_vls tmp_vls = BU_VLS_INIT_ZERO;
	bu_vls_printf(&tmp_vls, "beginning of end view matrix = \n");
	glGetFloatv (GL_MODELVIEW_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_vls_printf(&tmp_vls, "beginning of end projection matrix = \n");
	glGetFloatv (GL_PROJECTION_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_log("%s", bu_vls_addr(&tmp_vls));
	bu_vls_free(&tmp_vls);
    }


    if (dmp->dm_light) {
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
    }

    ((struct osg_vars *)dmp->dm_vars.priv_vars)->graphicsContext->swapBuffers();
    if (dmp->dm_clearBufferAfter) {
	/* give Graphics pipe time to work */
	glClearColor(((struct osg_vars *)dmp->dm_vars.priv_vars)->r,
		((struct osg_vars *)dmp->dm_vars.priv_vars)->g,
		((struct osg_vars *)dmp->dm_vars.priv_vars)->b,
		0.0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    if (dmp->dm_debugLevel) {
	int error;
	struct bu_vls tmp_vls = BU_VLS_INIT_ZERO;

	bu_vls_printf(&tmp_vls, "ANY ERRORS?\n");

	while ((error = glGetError())!=0) {
	    bu_vls_printf(&tmp_vls, "Error: %x\n", error);
	}

	bu_log("%s", bu_vls_addr(&tmp_vls));
	bu_vls_free(&tmp_vls);
    }

    if (dmp->dm_debugLevel == 3) {
	GLfloat m[16];
	struct bu_vls tmp_vls = BU_VLS_INIT_ZERO;
	bu_vls_printf(&tmp_vls, "end of drawend view matrix = \n");
	glGetFloatv (GL_MODELVIEW_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_vls_printf(&tmp_vls, "end of drawend projection matrix = \n");
	glGetFloatv (GL_PROJECTION_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_log("%s", bu_vls_addr(&tmp_vls));
	bu_vls_free(&tmp_vls);
    }


    return TCL_OK;
}


/*
 * Load a new transformation matrix.  This will be followed by
 * many calls to osg_draw().
 */
HIDDEN int
osg_loadMatrix(struct dm *dmp, fastf_t *mat, int which_eye)
{
    fastf_t *mptr;
    GLfloat gtmat[16];

    if (dmp->dm_debugLevel == 1)
	bu_log("osg_loadMatrix()\n");

    if (dmp->dm_debugLevel == 3) {
	GLfloat m[16];
	struct bu_vls tmp_vls = BU_VLS_INIT_ZERO;
	bu_vls_printf(&tmp_vls, "beginning of loadMatrix view matrix = \n");
	glGetFloatv (GL_MODELVIEW_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_vls_printf(&tmp_vls, "beginning of loadMatrix projection matrix = \n");
	glGetFloatv (GL_PROJECTION_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_log("%s", bu_vls_addr(&tmp_vls));
	bu_vls_free(&tmp_vls);
    }


    if (dmp->dm_debugLevel == 3) {
	struct bu_vls tmp_vls = BU_VLS_INIT_ZERO;

	bu_vls_printf(&tmp_vls, "transformation matrix = \n");
	osg_printmat(&tmp_vls, mat);

	bu_log("%s", bu_vls_addr(&tmp_vls));
	bu_vls_free(&tmp_vls);
    }

    switch (which_eye) {
	case 0:
	    /* Non-stereo */
	    break;
	case 1:
	    /* R eye */
	    glViewport(0,  0, (XMAXSCREEN)+1, (YSTEREO)+1);
	    glScissor(0,  0, (XMAXSCREEN)+1, (YSTEREO)+1);
	    osg_drawString2D(dmp, "R", 0.986, 0.0, 0, 1);
	    break;
	case 2:
	    /* L eye */
	    glViewport(0,  0+YOFFSET_LEFT, (XMAXSCREEN)+1,
		       (YSTEREO+YOFFSET_LEFT)-(YOFFSET_LEFT)+1);
	    glScissor(0,  0+YOFFSET_LEFT, (XMAXSCREEN)+1,
		      (YSTEREO+YOFFSET_LEFT)-(YOFFSET_LEFT)+1);
	    break;
    }

    mptr = mat;

    gtmat[0] = *(mptr++);
    gtmat[4] = *(mptr++);
    gtmat[8] = *(mptr++);
    gtmat[12] = *(mptr++);

    gtmat[1] = *(mptr++) * dmp->dm_aspect;
    gtmat[5] = *(mptr++) * dmp->dm_aspect;
    gtmat[9] = *(mptr++) * dmp->dm_aspect;
    gtmat[13] = *(mptr++) * dmp->dm_aspect;

    gtmat[2] = *(mptr++);
    gtmat[6] = *(mptr++);
    gtmat[10] = *(mptr++);
    gtmat[14] = *(mptr++);

    gtmat[3] = *(mptr++);
    gtmat[7] = *(mptr++);
    gtmat[11] = *(mptr++);
    gtmat[15] = *(mptr++);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glLoadMatrixf(gtmat);

    if (dmp->dm_debugLevel == 3) {
	GLfloat m[16];
	struct bu_vls tmp_vls = BU_VLS_INIT_ZERO;
	bu_vls_printf(&tmp_vls, "end of loadMatrix view matrix = \n");
	glGetFloatv (GL_MODELVIEW_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_vls_printf(&tmp_vls, "end of loadMatrix projection matrix = \n");
	glGetFloatv (GL_PROJECTION_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_log("%s", bu_vls_addr(&tmp_vls));
	bu_vls_free(&tmp_vls);
    }

    return TCL_OK;
}


/*
 * Load a new projection matrix.
 *
 */
HIDDEN int
osg_loadPMatrix(struct dm *dmp, fastf_t *mat)
{
    fastf_t *mptr;
    GLfloat gtmat[16];

    glMatrixMode(GL_PROJECTION);

    if (mat == (fastf_t *)NULL) {
	if (((struct osg_vars *)dmp->dm_vars.priv_vars)->face_flag) {
	    glPopMatrix();
	    glLoadIdentity();
	    glOrtho(-xlim_view, xlim_view, -ylim_view, ylim_view, dmp->dm_clipmin[2], dmp->dm_clipmax[2]);
	    glPushMatrix();
	    glLoadMatrixd(((struct osg_vars *)dmp->dm_vars.priv_vars)->faceplate_mat);
	} else {
	    glLoadIdentity();
	    glOrtho(-xlim_view, xlim_view, -ylim_view, ylim_view, dmp->dm_clipmin[2], dmp->dm_clipmax[2]);
	}

	return TCL_OK;
    }

    mptr = mat;

    gtmat[0] = *(mptr++);
    gtmat[4] = *(mptr++);
    gtmat[8] = *(mptr++);
    gtmat[12] = *(mptr++);

    gtmat[1] = *(mptr++);
    gtmat[5] = *(mptr++);
    gtmat[9] = *(mptr++);
    gtmat[13] = *(mptr++);

    gtmat[2] = *(mptr++);
    gtmat[6] = *(mptr++);
    gtmat[10] = -*(mptr++);
    gtmat[14] = -*(mptr++);

    gtmat[3] = *(mptr++);
    gtmat[7] = *(mptr++);
    gtmat[11] = *(mptr++);
    gtmat[15] = *(mptr++);

    glLoadIdentity();
    glLoadMatrixf(gtmat);

    return TCL_OK;
}


HIDDEN int
osg_drawVListHiddenLine(struct dm *dmp, struct bn_vlist *vp)
{
    register struct bn_vlist *tvp;
    register int first;

    if (dmp->dm_debugLevel == 1)
	bu_log("osg_drawVList()\n");


    /* First, draw polygons using background color. */

    if (dmp->dm_light) {
	glDisable(GL_LIGHTING);
    }

    glDisable(GL_BLEND);
    glDepthMask(GL_TRUE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_POLYGON_OFFSET_FILL);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glPolygonOffset(1.0, 1.0);

    /* Set color to background color for drawing polygons. */
    glColor3f(((struct osg_vars *)dmp->dm_vars.priv_vars)->r,
	      ((struct osg_vars *)dmp->dm_vars.priv_vars)->g,
	      ((struct osg_vars *)dmp->dm_vars.priv_vars)->b);

    /* Viewing region is from -1.0 to +1.0 */
    first = 1;
    for (BU_LIST_FOR(tvp, bn_vlist, &vp->l)) {
	register int i;
	register int nused = tvp->nused;
	register int *cmd = tvp->cmd;
	point_t *pt = tvp->pt;
	for (i = 0; i < nused; i++, cmd++, pt++) {
	    GLdouble dpt[3];
	    VMOVE(dpt, *pt); /* fastf_t-to-double */
/*
	    if (dmp->dm_debugLevel > 2)
		bu_log(" %d (%g %g %g)\n", *cmd, V3ARGS(dpt));*/

	    switch (*cmd) {
		case BN_VLIST_LINE_MOVE:
		case BN_VLIST_LINE_DRAW:
		    break;
		case BN_VLIST_POLY_START:
		    /* Start poly marker & normal */
		    if (first == 0)
			glEnd();
		    first = 0;

		    glBegin(GL_POLYGON);
		    /* Set surface normal (vl_pnt points outward) */
		    glNormal3dv(dpt);
		    break;
		case BN_VLIST_POLY_MOVE:
		case BN_VLIST_POLY_DRAW:
		case BN_VLIST_TRI_MOVE:
		case BN_VLIST_TRI_DRAW:
		    glVertex3dv(dpt);
		    break;
		case BN_VLIST_POLY_END:
		    /* Draw, End Polygon */
		    glEnd();
		    first = 1;
		    break;
		case BN_VLIST_POLY_VERTNORM:
		case BN_VLIST_TRI_VERTNORM:
		    /* Set per-vertex normal.  Given before vert. */
		    glNormal3dv(dpt);
		    break;
		case BN_VLIST_TRI_START:
		    if (first)
			glBegin(GL_TRIANGLES);

			first = 0;

		    /* Set surface normal (vl_pnt points outward) */
		    glNormal3dv(dpt);

		    break;
		case BN_VLIST_TRI_END:
		    break;
	    }
	}
    }

    if (first == 0)
	glEnd();

    /* Last, draw wireframe/edges. */

    /* Set color to wireColor for drawing wireframe/edges */
    glColor3f(wireColor[0], wireColor[1], wireColor[2]);

    /* Viewing region is from -1.0 to +1.0 */
    first = 1;
    for (BU_LIST_FOR(tvp, bn_vlist, &vp->l)) {
	register int i;
	register int nused = tvp->nused;
	register int *cmd = tvp->cmd;
	point_t *pt = tvp->pt;

	for (i = 0; i < nused; i++, cmd++, pt++) {
	    GLdouble dpt[3];
	    VMOVE(dpt, *pt); /* fastf_t-to-double */
/*
	    if (dmp->dm_debugLevel > 2)
		bu_log(" %d (%g %g %g)\n", *cmd, V3ARGS(dpt));*/

	    switch (*cmd) {
		case BN_VLIST_LINE_MOVE:
		    /* Move, start line */
		    if (first == 0)
			glEnd();
		    first = 0;

		    glBegin(GL_LINE_STRIP);
		    glVertex3dv(dpt);
		    break;
		case BN_VLIST_POLY_START:
		case BN_VLIST_TRI_START:
		    /* Start poly marker & normal */
		    if (first == 0)
			glEnd();
		    first = 0;

		    glBegin(GL_LINE_STRIP);
		    break;
		case BN_VLIST_LINE_DRAW:
		case BN_VLIST_POLY_MOVE:
		case BN_VLIST_POLY_DRAW:
		case BN_VLIST_TRI_MOVE:
		case BN_VLIST_TRI_DRAW:
		    glVertex3dv(dpt);
		    break;
		case BN_VLIST_POLY_END:
		case BN_VLIST_TRI_END:
		    /* Draw, End Polygon */
		    glVertex3dv(dpt);
		    glEnd();
		    first = 1;
		    break;
		case BN_VLIST_POLY_VERTNORM:
		case BN_VLIST_TRI_VERTNORM:
		    /* Set per-vertex normal.  Given before vert. */
		    glNormal3dv(dpt);
		    break;
	    }
	}
    }

    if (first == 0)
	glEnd();

    if (dmp->dm_light) {
	glEnable(GL_LIGHTING);
    }

    if (!((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on)
	glDisable(GL_DEPTH_TEST);

    if (!dmp->dm_depthMask)
	glDepthMask(GL_FALSE);

    glDisable(GL_POLYGON_OFFSET_FILL);

    return TCL_OK;
    }


HIDDEN int
osg_drawVList(struct dm *dmp, struct bn_vlist *vp)
{
    struct bn_vlist *tvp;
    register int first;
    register int mflag = 1;
    static float black[4] = {0.0, 0.0, 0.0, 0.0};
    GLfloat originalPointSize, originalLineWidth;

    glGetFloatv(GL_POINT_SIZE, &originalPointSize);
    glGetFloatv(GL_LINE_WIDTH, &originalLineWidth);

    if (dmp->dm_debugLevel == 1)
	bu_log("osg_drawVList()\n");

    /* Viewing region is from -1.0 to +1.0 */
    first = 1;
    for (BU_LIST_FOR(tvp, bn_vlist, &vp->l)) {
	int i;
	int nused = tvp->nused;
	int *cmd = tvp->cmd;
	point_t *pt = tvp->pt;
	for (i = 0; i < nused; i++, cmd++, pt++) {
	    GLdouble dpt[3];
	    VMOVE(dpt, *pt);
/*
	    if (dmp->dm_debugLevel > 2)
		bu_log(" %d (%g %g %g)\n", *cmd, V3ARGS(dpt));*/

	    switch (*cmd) {
		case BN_VLIST_LINE_MOVE:
		    /* Move, start line */
		    if (first == 0)
			glEnd();
		    first = 0;

		    if (dmp->dm_light && mflag) {
			mflag = 0;
			glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, wireColor);
			glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, black);
			glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, black);
			glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, black);

			if (dmp->dm_transparency)
			    glDisable(GL_BLEND);
		    }

		    glBegin(GL_LINE_STRIP);
		    glVertex3dv(dpt);
		    break;
		case BN_VLIST_POLY_START:
		case BN_VLIST_TRI_START:
		    /* Start poly marker & normal */

		    if (dmp->dm_light && mflag) {
			mflag = 0;
			glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, black);
			glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, ambientColor);
			glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, specularColor);
			glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuseColor);

			switch (dmp->dm_light) {
			    case 1:
				break;
			    case 2:
				glMaterialfv(GL_BACK, GL_DIFFUSE, diffuseColor);
				break;
			    case 3:
				glMaterialfv(GL_BACK, GL_DIFFUSE, backDiffuseColorDark);
				break;
			    default:
				glMaterialfv(GL_BACK, GL_DIFFUSE, backDiffuseColorLight);
				break;
			}

			if (dmp->dm_transparency)
			    glEnable(GL_BLEND);
		    }

		    if (*cmd == BN_VLIST_POLY_START) {
			if (first == 0)
			    glEnd();

			glBegin(GL_POLYGON);
		    } else if (first)
			glBegin(GL_TRIANGLES);

		    /* Set surface normal (vl_pnt points outward) */
		    glNormal3dv(dpt);

		    first = 0;

		    break;
		case BN_VLIST_LINE_DRAW:
		case BN_VLIST_POLY_MOVE:
		case BN_VLIST_POLY_DRAW:
		case BN_VLIST_TRI_MOVE:
		case BN_VLIST_TRI_DRAW:
		    glVertex3dv(dpt);
		    break;
		case BN_VLIST_POLY_END:
		    /* Draw, End Polygon */
		    glEnd();
		    first = 1;
		    break;
		case BN_VLIST_TRI_END:
		    break;
		case BN_VLIST_POLY_VERTNORM:
		case BN_VLIST_TRI_VERTNORM:
		    /* Set per-vertex normal.  Given before vert. */
		    glNormal3dv(dpt);
		    break;
		case BN_VLIST_POINT_DRAW:
		    if (first == 0)
			glEnd();
		    first = 0;
		    glBegin(GL_POINTS);
		    glVertex3dv(dpt);
		    break;
		case BN_VLIST_LINE_WIDTH: {
		    GLfloat lineWidth = (GLfloat)(*pt)[0];
		    if (lineWidth > 0.0) {
			glLineWidth(lineWidth);
		    }
		    break;
		}
		case BN_VLIST_POINT_SIZE: {
		    GLfloat pointSize = (GLfloat)(*pt)[0];
		    if (pointSize > 0.0) {
			glPointSize(pointSize);
		    }
		    break;
		}
	    }
	}
    }

    if (first == 0)
	glEnd();

    if (dmp->dm_light && dmp->dm_transparency)
	glDisable(GL_BLEND);

    glPointSize(originalPointSize);
    glLineWidth(originalLineWidth);

    return TCL_OK;
}


HIDDEN int
osg_draw(struct dm *dmp, struct bn_vlist *(*callback_function)(void *), genptr_t *data)
{
    struct bn_vlist *vp;
    if (!callback_function) {
	if (data) {
	    vp = (struct bn_vlist *)data;
	    osg_drawVList(dmp, vp);
	}
    } else {
	if (!data) {
	    return TCL_ERROR;
	} else {
	(void)callback_function(data);
    }
    }
    return TCL_OK;
}


/*
 * Restore the display processor to a normal mode of operation
 * (i.e., not scaled, rotated, displaced, etc.).
 */
HIDDEN int
osg_normal(struct dm *dmp)
{
    if (dmp->dm_debugLevel)
	bu_log("osg_normal\n");

    if (dmp->dm_debugLevel == 3) {
	GLfloat m[16];
	struct bu_vls tmp_vls = BU_VLS_INIT_ZERO;
	bu_vls_printf(&tmp_vls, "beginning of osg_normal view matrix = \n");
	glGetFloatv (GL_MODELVIEW_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_vls_printf(&tmp_vls, "beginning of osg_normal projection matrix = \n");
	glGetFloatv (GL_PROJECTION_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_log("%s", bu_vls_addr(&tmp_vls));
	bu_vls_free(&tmp_vls);
    }

    if (!((struct osg_vars *)dmp->dm_vars.priv_vars)->face_flag) {
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadMatrixd(((struct osg_vars *)dmp->dm_vars.priv_vars)->faceplate_mat);
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();
	((struct osg_vars *)dmp->dm_vars.priv_vars)->face_flag = 1;
	if (((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.cueing_on)
	    glDisable(GL_FOG);
	if (dmp->dm_light)
	    glDisable(GL_LIGHTING);
    }

    if (dmp->dm_debugLevel == 3) {
	GLfloat m[16];
	struct bu_vls tmp_vls = BU_VLS_INIT_ZERO;
	bu_vls_printf(&tmp_vls, "end of osg_normal view matrix = \n");
	glGetFloatv (GL_MODELVIEW_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_vls_printf(&tmp_vls, "end of osg_normal projection matrix = \n");
	glGetFloatv (GL_PROJECTION_MATRIX, m);
	osg_printglmat(&tmp_vls, m);
	bu_log("%s", bu_vls_addr(&tmp_vls));
	bu_vls_free(&tmp_vls);
    }

    return TCL_OK;
}


/*
 * Output a string.
 * The starting position of the beam is as specified.
 */
HIDDEN int
osg_drawString2D(struct dm *dmp, const char *str, fastf_t x, fastf_t y, int UNUSED(size), int use_aspect)
{
    if (dmp->dm_debugLevel)
	bu_log("osg_drawString2D()\n");

    if (use_aspect)
	glRasterPos2f(x, y * dmp->dm_aspect);
    else
	glRasterPos2f(x, y);

    glListBase(((struct osg_vars *)dmp->dm_vars.priv_vars)->fontOffset);
    glCallLists(strlen(str), GL_UNSIGNED_BYTE,  str);

    return TCL_OK;
}


HIDDEN int
osg_drawLine2D(struct dm *dmp, fastf_t X1, fastf_t Y1, fastf_t X2, fastf_t Y2)
{
    return drawLine2D(dmp, X1, Y1, X2, Y2, "osg_drawLine2D()\n");
}


HIDDEN int
osg_drawLine3D(struct dm *dmp, point_t pt1, point_t pt2)
{
    return drawLine3D(dmp, pt1, pt2, "osg_drawLine3D()\n", wireColor);
}


HIDDEN int
osg_drawLines3D(struct dm *dmp, int npoints, point_t *points, int sflag)
{
    return drawLines3D(dmp, npoints, points, sflag, "osg_drawLine3D()\n", wireColor);
}


HIDDEN int
osg_drawPoint2D(struct dm *dmp, fastf_t x, fastf_t y)
{
    if (dmp->dm_debugLevel) {
	bu_log("osg_drawPoint2D():\n");
	bu_log("\tdmp: %p\tx - %lf\ty - %lf\n", (void *)dmp, x, y);
    }

    glBegin(GL_POINTS);
    glVertex2f(x, y);
    glEnd();

    return TCL_OK;
}


HIDDEN int
osg_drawPoint3D(struct dm *dmp, point_t point)
{
    GLdouble dpt[3];

    if (!dmp || !point)
	return TCL_ERROR;

    if (dmp->dm_debugLevel) {
	bu_log("osg_drawPoint3D():\n");
	bu_log("\tdmp: %p\tpt - %lf %lf %lf\n", (void*)dmp, V3ARGS(point));
    }

    /* fastf_t to double */
    VMOVE(dpt, point);

    glBegin(GL_POINTS);
    glVertex3dv(dpt);
    glEnd();

    return TCL_OK;
}


HIDDEN int
osg_drawPoints3D(struct dm *dmp, int npoints, point_t *points)
{
    GLdouble dpt[3];
    register int i;

    if (!dmp || npoints < 0 || !points)
	return TCL_ERROR;

    if (dmp->dm_debugLevel) {
	bu_log("osg_drawPoint3D():\n");
    }


    glBegin(GL_POINTS);
    for (i = 0; i < npoints; ++i) {
	/* fastf_t to double */
	VMOVE(dpt, points[i]);
	glVertex3dv(dpt);
    }
    glEnd();

    return TCL_OK;
}


HIDDEN int
osg_setFGColor(struct dm *dmp, unsigned char r, unsigned char g, unsigned char b, int strict, fastf_t transparency)
{
    /*if (dmp->dm_debugLevel)
	bu_log("osg_setFGColor()\n");*/

    dmp->dm_fg[0] = r;
    dmp->dm_fg[1] = g;
    dmp->dm_fg[2] = b;

    /* wireColor gets the full rgb */
    wireColor[0] = r / 255.0;
    wireColor[1] = g / 255.0;
    wireColor[2] = b / 255.0;
    wireColor[3] = transparency;

    if (strict) {
	glColor3ub((GLubyte)r, (GLubyte)g, (GLubyte)b);
    } else {

	if (dmp->dm_light) {
	    /* Ambient = .2, Diffuse = .6, Specular = .2 */

	    ambientColor[0] = wireColor[0] * 0.2;
	    ambientColor[1] = wireColor[1] * 0.2;
	    ambientColor[2] = wireColor[2] * 0.2;
	    ambientColor[3] = wireColor[3];

	    specularColor[0] = ambientColor[0];
	    specularColor[1] = ambientColor[1];
	    specularColor[2] = ambientColor[2];
	    specularColor[3] = ambientColor[3];

	    diffuseColor[0] = wireColor[0] * 0.6;
	    diffuseColor[1] = wireColor[1] * 0.6;
	    diffuseColor[2] = wireColor[2] * 0.6;
	    diffuseColor[3] = wireColor[3];

	    backDiffuseColorDark[0] = wireColor[0] * 0.3;
	    backDiffuseColorDark[1] = wireColor[1] * 0.3;
	    backDiffuseColorDark[2] = wireColor[2] * 0.3;
	    backDiffuseColorDark[3] = wireColor[3];

	    backDiffuseColorLight[0] = wireColor[0] * 0.9;
	    backDiffuseColorLight[1] = wireColor[1] * 0.9;
	    backDiffuseColorLight[2] = wireColor[2] * 0.9;
	    backDiffuseColorLight[3] = wireColor[3];

	    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, ambientColor);
	    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, specularColor);
	    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuseColor);
	} else {
	    glColor3ub((GLubyte)r,  (GLubyte)g,  (GLubyte)b);
	}
    }

    return TCL_OK;
}


HIDDEN int
osg_setLineAttr(struct dm *dmp, int width, int style)
{
    /*if (dmp->dm_debugLevel)
	bu_log("osg_setLineAttr()\n");*/

    dmp->dm_lineWidth = width;
    dmp->dm_lineStyle = style;

    glLineWidth((GLfloat) width);

    if (style == DM_DASHED_LINE)
	glEnable(GL_LINE_STIPPLE);
    else
	glDisable(GL_LINE_STIPPLE);

    return TCL_OK;
}


HIDDEN int
osg_debug(struct dm *dmp, int lvl)
{
    dmp->dm_debugLevel = lvl;

    return TCL_OK;
}

HIDDEN int
osg_logfile(struct dm *dmp, const char *filename)
{
    bu_vls_sprintf(&dmp->dm_log, "%s", filename);

    return TCL_OK;
}

HIDDEN int
osg_setWinBounds(struct dm *dmp, fastf_t *w)
{
    GLint mm;

    if (dmp->dm_debugLevel)
	bu_log("osg_setWinBounds()\n");

    dmp->dm_clipmin[0] = w[0];
    dmp->dm_clipmin[1] = w[2];
    dmp->dm_clipmin[2] = w[4];
    dmp->dm_clipmax[0] = w[1];
    dmp->dm_clipmax[1] = w[3];
    dmp->dm_clipmax[2] = w[5];

    glGetIntegerv(GL_MATRIX_MODE, &mm);
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glLoadIdentity();
    glOrtho(-xlim_view, xlim_view, -ylim_view, ylim_view, dmp->dm_clipmin[2], dmp->dm_clipmax[2]);
    glPushMatrix();
    glMatrixMode(mm);

    return TCL_OK;
}


HIDDEN int
osg_setTransparency(struct dm *dmp,
		    int transparency_on)
{
    if (dmp->dm_debugLevel)
	bu_log("osg_setTransparency()\n");

    dmp->dm_transparency = transparency_on;
    ((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.transparency_on = dmp->dm_transparency;

    if (transparency_on) {
	/* Turn it on */
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    } else {
	/* Turn it off */
	glDisable(GL_BLEND);
    }

    return TCL_OK;
}


HIDDEN int
osg_setDepthMask(struct dm *dmp,
		 int enable) {
    if (dmp->dm_debugLevel)
	bu_log("osg_setDepthMask()\n");

    dmp->dm_depthMask = enable;

    if (enable)
	glDepthMask(GL_TRUE);
    else
	glDepthMask(GL_FALSE);

    return TCL_OK;
}


HIDDEN int
osg_setZBuffer(struct dm *dmp, int zbuffer_on)
{
    if (dmp->dm_debugLevel)
	bu_log("osg_setZBuffer:\n");

    dmp->dm_zbuffer = zbuffer_on;
    ((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on = dmp->dm_zbuffer;

    if (((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.zbuf == 0) {
	dmp->dm_zbuffer = 0;
	((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on = dmp->dm_zbuffer;
    }

    if (((struct osg_vars *)dmp->dm_vars.priv_vars)->mvars.zbuffer_on) {
	glDepthFunc(GL_LEQUAL);
	glEnable(GL_DEPTH_TEST);
    } else {
	glDisable(GL_DEPTH_TEST);
    }

    return TCL_OK;
}


HIDDEN int
osg_beginDList(struct dm *dmp, unsigned int list)
{
    if (dmp->dm_debugLevel)
	bu_log("osg_beginDList()\n");

    glNewList((GLuint)list, GL_COMPILE);
    return TCL_OK;
}


HIDDEN int
osg_endDList(struct dm *dmp)
{
    if (dmp->dm_debugLevel)
	bu_log("osg_endDList()\n");

    glEndList();
    return TCL_OK;
}


HIDDEN void
osg_drawDList(unsigned int list)
{
    glCallList((GLuint)list);
}


HIDDEN int
osg_freeDLists(struct dm *dmp, unsigned int list, int range)
{
    if (dmp->dm_debugLevel)
	bu_log("osg_freeDLists()\n");

    glDeleteLists((GLuint)list, (GLsizei)range);
    return TCL_OK;
}


HIDDEN int
osg_genDLists(struct dm *dmp, size_t range)
{
    if (dmp->dm_debugLevel)
	bu_log("osg_freeDLists()\n");

    return glGenLists((GLsizei)range);
}


HIDDEN int
osg_getDisplayImage(struct dm *UNUSED(dmp), unsigned char **UNUSED(image))
{
#if 0
    unsigned char *idata = NULL;
    int width = 0;
    int height = 0;
    int bytes_per_pixel = 3; /*rgb no alpha for raw pix */
    GLuint *pixels;
    unsigned int pixel;
    unsigned int red_mask = 0xff000000;
    unsigned int green_mask = 0x00ff0000;
    unsigned int blue_mask = 0x0000ff00;
    int h, w;
#if defined(DM_WGL)
    unsigned int alpha_mask = 0x000000ff;
    int big_endian;
    int swap_bytes;

    if ((bu_byteorder() == BU_BIG_ENDIAN))
	big_endian = 1;
    else
	big_endian = 0;

    /* WTF */
    swap_bytes = !big_endian;
#endif

    if (dmp->dm_type == DM_TYPE_WGL || dmp->dm_type == DM_TYPE_OGL) {
	width = dmp->dm_width;
	height = dmp->dm_height;

	pixels = (GLuint *)bu_calloc(width * height, sizeof(GLuint), "pixels");

	{
	    glReadBuffer(GL_FRONT);
#if defined(DM_WGL)
	    /* XXX GL_UNSIGNED_INT_8_8_8_8 is currently not
	     * available on windows.  Need to update when it
	     * becomes available.
	     */
	    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
#else
	    glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8, pixels);
#endif

	    idata = (unsigned char *)bu_calloc(height * width * bytes_per_pixel, sizeof(unsigned char), "rgb data");
	    *image = idata;

	    for (h = 0; h < height; h++) {
		for (w = 0; w < width; w++) {
		    int i = h*width + w;
		    int i_h_inv = (height - h - 1)*width + w;
		    int j = i*bytes_per_pixel;
		    unsigned char *value = (unsigned char *)(idata + j);
#if defined(DM_WGL)
		    unsigned char alpha;
#endif

		    pixel = pixels[i_h_inv];

		    value[0] = (pixel & red_mask) >> 24;
		    value[1] = (pixel & green_mask) >> 16;
		    value[2] = (pixel & blue_mask) >> 8;

#if defined(DM_WGL)
		    alpha = pixel & alpha_mask;
		    if (swap_bytes) {
			unsigned char tmp_byte;

			value[0] = alpha;
			/* swap byte1 and byte2 */
			tmp_byte = value[1];
			value[1] = value[2];
			value[2] = tmp_byte;
		    }
#endif
		}

	    }

	    bu_free(pixels, "pixels");
	}
    } else {
	bu_log("osg_getDisplayImage: Display type not set as OGL or WGL\n");
	return TCL_ERROR;
    }
#endif

    return TCL_OK; /* caller will need to bu_free(idata, "image data"); */
}


#endif /* DM_OSG */

/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 2157
set(FB_INCLUDE_DIRS
  ${BRLCAD_BINARY_DIR}/include
  ${BRLCAD_SOURCE_DIR}/include
  ${BU_INCLUDE_DIRS}
  ${PKG_INCLUDE_DIRS}
  ${X11_INCLUDE_DIR}
  ${OPENGL_INCLUDE_DIR_GL}
  ${OPENGL_INCLUDE_DIR_GLX}
  ${TCL_INCLUDE_DIRS}
  ${TK_INCLUDE_PATH}
  ${OPENNURBS_INCLUDE_DIR}
  ${OPENTHREADS_INCLUDE_DIR}
  ${OSG_INCLUDE_DIR}
  ${GLFW_INCLUDE_DIR}
  )
BRLCAD_LIB_INCLUDE_DIRS(fb FB_INCLUDE_DIRS "")

set(LINKLIBS "")
if(BRLCAD_ENABLE_X11 AND X11_FOUND)
  set(FBX11DEFS "-DIF_X")
  set(LINKLIBS ${LINKLIBS} ${X11_LIBRARIES})
  set(fbX11_srcs if_X.c if_X24.c)
endif()
if(BRLCAD_ENABLE_OPENGL AND OPENGL_FOUND AND NOT MSVC)
  set(FBOGLDEFS "-DIF_OGL")
  set(LINKLIBS ${LINKLIBS} ${OPENGL_LIBRARIES})
  set(fbogl_srcs if_ogl.c)
endif()
if(WIN32)
  add_definitions(
    -DIF_WGL
    )
  set(LINKLIBS ${LINKLIBS} opengl32.lib ${TCL_TK_LIBRARY})
  set(fbwgl_srcs if_wgl.c)
endif(WIN32)
if(BRLCAD_ENABLE_TK)
  set(FBTKDEFS "-DIF_TK")
  set(LINKLIBS ${LINKLIBS} ${TK_LIBRARY})
  set(fbtk_srcs if_tk.c)
endif(BRLCAD_ENABLE_TK)

if(BRLCAD_ENABLE_OSG)
  set(FBOSGDEFS "-DIF_OSG")
  set(OSG_LIBRARIES
    ${OSGVIEWER_LIBRARY}
    ${GLFW_LIBRARY}
    )
  set(LINKLIBS ${LINKLIBS} ${OSG_LIBRARIES})
  set(fbosg_srcs if_osg.cpp)
endif()

set(LIBFB_SOURCES
  ${fbX11_srcs}
  ${fbogl_srcs}
  ${fbosg_srcs}
  ${fbwgl_srcs}
  ${fbtk_srcs}
  asize.c
  fb_generic.c
  fb_log.c
  fb_obj.c
  fb_paged_io.c
  fb_rect.c
  fb_util.c
  fbserv_obj.c
  if_debug.c
  if_disk.c
  if_mem.c
  if_null.c
  if_remote.c
  if_stack.c
  tcl.c
  vers.c
  )

add_definitions(
  -DIF_REMOTE
  -DIF_AB
  ${FBX11DEFS}
  ${FBOGLDEFS}
  ${FBOSGDEFS}
  ${FBTKDEFS}
  ${XOPEN_DEFINE}
  )

BRLCAD_ADDLIB(libfb "${LIBFB_SOURCES}" "libbu;libpkg;${LINKLIBS}")
SET_TARGET_PROPERTIES(libfb PROPERTIES VERSION 20.0.1 SOVERSION 20)
if(BRLCAD_BUILD_LOCAL_TK AND BRLCAD_ENABLE_TK)
  ADD_DEPENDENCIES(libfb tk)
endif(BRLCAD_BUILD_LOCAL_TK AND BRLCAD_ENABLE_TK)

set(libfb_ignore_files
  dmdfb.h
  if_TEMPLATE.c
  if_X.c
  if_X24.c
  if_ogl.c
  if_osg.cpp
  if_wgl.c
  if_tk.c
  )
CMAKEFILES(${libfb_ignore_files})

# Local Variables:
# tab-width: 8
# mode: cmake
# indent-tabs-mode: t
# End:
# ex: shiftwidth=2 tabstop=8
blob
data 10701
/*                       I F _ O S G . C P P
 * BRL-CAD
 *
 * Copyright (c) 1989-2014 United States Government as represented by
 * the U.S. Army Research Laboratory.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this file; see the file named COPYING for more
 * information.
 */
/** @addtogroup if */
/** @{ */
/** @file if_osg.cpp
 *
 * A OpenSceneGraph Frame Buffer.
 *
 */
/** @} */

#include "common.h"

#include <stdlib.h>
#include <stdio.h>

#include "bu/log.h"
#include "bu/str.h"
#include "fb.h"

#include <osg/GraphicsContext>
#include <osgViewer/Viewer>

#include <GLFW/glfw3.h>

struct osginfo {
    GLFWwindow 		*glfw;
    GLuint		texture_name;
    void		*texture_data;
};

#define OSG(ptr) ((struct osginfo *)((ptr)->u6.p))

HIDDEN int
osg_open(FBIO *ifp, const char *UNUSED(file), int width, int height)
{
    FB_CK_FBIO(ifp);

    /* Get some memory for the osg specific stuff */
    if ((ifp->u6.p = (char *)calloc(1, sizeof(struct osginfo))) == NULL) {
	fb_log("fb_osg_open:  osginfo malloc failed\n");
	return -1;
    }

    if (width > 0)
	ifp->if_width = width;
    if (height > 0)
	ifp->if_height = height;

    // Although we are not making direct use of osgViewer currently, we need its
    // initialization to make sure we have all the libraries we need loaded and
    // ready.
    osgViewer::Viewer *viewer = new osgViewer::Viewer();
    delete viewer;


    /* Initialize GLFW Window.  TODO - this will eventually become an
     * osgViewer setup, once the initial dev work is done. */
    glfwInit();
    GLFWwindow *glfw = glfwCreateWindow(width, height, "osg", NULL, NULL);

    int major, minor, rev;
    glfwGetVersion(&major, &minor, &rev);
    printf("\n\nOpenGL Version %d.%d.%d\n\n", major, minor, rev);

    OSG(ifp)->glfw = glfw;

    glfwSwapInterval( 1 );

    glfwMakeContextCurrent(glfw);
    glClearColor (0.0, 0.0, 0.0, 1);
    glViewport(0, 0, width, height);
    glViewport(0,0,width, height);
    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    glOrtho(0, width, height, 0, -1, 1);
    glMatrixMode (GL_MODELVIEW);
    glClear(GL_COLOR_BUFFER_BIT);

    /* Set up the texture that will hold the raytrace results */
    glGenTextures(1, &(OSG(ifp)->texture_name));
    glBindTexture(GL_TEXTURE_2D, OSG(ifp)->texture_name);
    glPixelStorei (GL_UNPACK_ALIGNMENT, 1);
    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
    OSG(ifp)->texture_data = calloc(1, width * height * 3);
    glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, OSG(ifp)->texture_data);

    glDisable(GL_LIGHTING);
    glEnable(GL_TEXTURE_2D);
    glfwMakeContextCurrent(NULL);

    return 0;
}

HIDDEN void
_display(FBIO *ifp)
{
    glDrawBuffer(GL_FRONT_AND_BACK);

    glBegin(GL_TRIANGLE_STRIP);

    glTexCoord2d(0, 1);
    glVertex3f(0, 0, 0);
    glTexCoord2d(0, 0);
    glVertex3f(0, ifp->if_height, 0);
    glTexCoord2d(1, 1);
    glVertex3f(ifp->if_width, -1, 0);
    glTexCoord2d(1, 0);
    glVertex3f(ifp->if_width, ifp->if_height, 0);

    glEnd();
}

HIDDEN int
osg_close(FBIO *ifp)
{
    FB_CK_FBIO(ifp);

    glBindTexture(GL_TEXTURE_2D, OSG(ifp)->texture_name);
    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, ifp->if_width, ifp->if_height, GL_RGB, GL_UNSIGNED_BYTE, OSG(ifp)->texture_data);

    while( !glfwWindowShouldClose(OSG(ifp)->glfw) )
    {
	_display(ifp);
	glfwSwapBuffers(OSG(ifp)->glfw);
	glfwPollEvents();
    }

    glfwDestroyWindow(OSG(ifp)->glfw);
    glfwTerminate();

    return 0;
}


HIDDEN int
osg_clear(FBIO *ifp, unsigned char *UNUSED(pp))
{
    FB_CK_FBIO(ifp);

    return 0;
}


HIDDEN ssize_t
osg_read(FBIO *ifp, int UNUSED(x), int UNUSED(y), unsigned char *UNUSED(pixelp), size_t count)
{
    FB_CK_FBIO(ifp);

    return count;
}


HIDDEN ssize_t
osg_write(FBIO *ifp, int xstart, int ystart, const unsigned char *pixelp, size_t count)
{
    register int x;
    register int y;
    size_t scan_count;  /* # pix on this scanline */
    size_t pix_count;   /* # pixels to send */
    int ybase;
    ssize_t ret;
    register unsigned char *cp;

    //fb_log("write got called!");

    FB_CK_FBIO(ifp);

    /* fast exit cases */
    pix_count = count;
    if (pix_count == 0)
	return 0;       /* OK, no pixels transferred */

    x = xstart;
    ybase = y = ystart;

    if (x < 0 || x >= ifp->if_width ||
	    y < 0 || y >= ifp->if_height)
	return -1;

    ret = 0;

    cp = (unsigned char *)(pixelp);

    while (pix_count) {
	void *scanline;

	if (y >= ifp->if_height)
	    break;

	if (pix_count >= (size_t)(ifp->if_width-x))
	    scan_count = (size_t)(ifp->if_width-x);
	else
	    scan_count = pix_count;

	scanline = &(((unsigned char *)OSG(ifp)->texture_data)[(y*ifp->if_width+x)*3]);

	memcpy(scanline, pixelp, scan_count*3);

	ret += scan_count;
	pix_count -= scan_count;
	x = 0;
	if (++y >= ifp->if_height)
	    break;
    }

    glfwMakeContextCurrent(OSG(ifp)->glfw);
    glBindTexture(GL_TEXTURE_2D, OSG(ifp)->texture_name);
    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, ifp->if_width, ifp->if_height, GL_RGB, GL_UNSIGNED_BYTE, OSG(ifp)->texture_data);
    _display(ifp);
    glfwSwapBuffers(OSG(ifp)->glfw);
    glFlush();
    glfwMakeContextCurrent(NULL);

    return ret;
}


HIDDEN int
osg_rmap(FBIO *ifp, ColorMap *UNUSED(cmp))
{
    FB_CK_FBIO(ifp);

    return 0;
}


HIDDEN int
osg_wmap(FBIO *ifp, const ColorMap *UNUSED(cmp))
{
    FB_CK_FBIO(ifp);

    fb_log("wmap got called!");

    return 0;
}


HIDDEN int
osg_view(FBIO *ifp, int UNUSED(xcenter), int UNUSED(ycenter), int UNUSED(xzoom), int UNUSED(yzoom))
{
    FB_CK_FBIO(ifp);
    fb_log("view was called!\n");

    /*fb_sim_view(ifp, xcenter, ycenter, xzoom, yzoom);*/
    return 0;
}


HIDDEN int
osg_getview(FBIO *ifp, int *UNUSED(xcenter), int *UNUSED(ycenter), int *UNUSED(xzoom), int *UNUSED(yzoom))
{
    FB_CK_FBIO(ifp);

    /*fb_sim_getview(ifp, xcenter, ycenter, xzoom, yzoom);*/
    return 0;
}


HIDDEN int
osg_setcursor(FBIO *ifp, const unsigned char *UNUSED(bits), int UNUSED(xbits), int UNUSED(ybits), int UNUSED(xorig), int UNUSED(yorig))
{
    FB_CK_FBIO(ifp);

    return 0;
}


HIDDEN int
osg_cursor(FBIO *ifp, int UNUSED(mode), int UNUSED(x), int UNUSED(y))
{
    FB_CK_FBIO(ifp);

    /*fb_sim_cursor(ifp, mode, x, y);*/
    return 0;
}


HIDDEN int
osg_getcursor(FBIO *ifp, int *UNUSED(mode), int *UNUSED(x), int *UNUSED(y))
{
    FB_CK_FBIO(ifp);

    /*fb_sim_getcursor(ifp, mode, x, y);*/
    return 0;
}


HIDDEN int
osg_readrect(FBIO *ifp, int UNUSED(xmin), int UNUSED(ymin), int width, int height, unsigned char *UNUSED(pp))
{
    FB_CK_FBIO(ifp);

    return width*height;
}


HIDDEN int
osg_writerect(FBIO *ifp, int UNUSED(xmin), int UNUSED(ymin), int width, int height, const unsigned char *UNUSED(pp))
{
    FB_CK_FBIO(ifp);

    fb_log("writerect got called!");

    return width*height;
}


HIDDEN int
osg_poll(FBIO *ifp)
{
    FB_CK_FBIO(ifp);

    return 0;
}


HIDDEN int
osg_flush(FBIO *ifp)
{
    FB_CK_FBIO(ifp);

    fb_log("flush was called!\n");

    return 0;
}


HIDDEN int
osg_free(FBIO *ifp)
{
    FB_CK_FBIO(ifp);

    return 0;
}


HIDDEN int
osg_help(FBIO *ifp)
{
    FB_CK_FBIO(ifp);

    fb_log("Description: %s\n", osg_interface.if_type);
    fb_log("Device: %s\n", ifp->if_name);
    fb_log("Max width/height: %d %d\n",
	   osg_interface.if_max_width,
	   osg_interface.if_max_height);
    fb_log("Default width/height: %d %d\n",
	   osg_interface.if_width,
	   osg_interface.if_height);
    fb_log("Useful for Benchmarking/Debugging\n");
    return 0;
}

/* Functions for pre-exising windows */
extern "C" int
osg_close_existing(FBIO *ifp)
{
    FB_CK_FBIO(ifp);
    return 0;
}

extern "C" int
_osg_open_existing(FBIO *ifp, Display *dpy, Window win, Colormap cmap, int width, int height, osg::ref_ptr<osg::GraphicsContext> graphicsContext)
{
    FB_CK_FBIO(ifp);
    if (!dpy || !win || !cmap || !width || !height || !graphicsContext) return -1;
    return 0;
}

extern "C" int
osg_open_existing(FBIO *ifp, int argc, const char **argv)
{
    FB_CK_FBIO(ifp);
    if (argc != 10 || !argv) return -1;

    return 0;
}

extern "C" int
osg_refresh(FBIO *ifp, int x, int y, int w, int h){
    FB_CK_FBIO(ifp);
    if (!x || !y || !w || !h) return -1;

    fb_log("refresh got called!\n");
    return 0;
}

extern "C" void
osg_configureWindow(FBIO *ifp, int width, int height)
{
    FB_CK_FBIO(ifp);

    if (!width || !height) return;
}

/* This is the ONLY thing that we normally "export" */
FBIO osg_interface =  {
    0,
    osg_open,		/* device_open */
    osg_close,		/* device_close */
    osg_clear,		/* device_clear */
    osg_read,		/* buffer_read */
    osg_write,		/* buffer_write */
    osg_rmap,		/* colormap_read */
    osg_wmap,		/* colormap_write */
    osg_view,		/* set view */
    osg_getview,	/* get view */
    osg_setcursor,	/* define cursor */
    osg_cursor,		/* set cursor */
    osg_getcursor,	/* get cursor */
    osg_readrect,	/* rectangle read */
    osg_writerect,	/* rectangle write */
    osg_readrect,	/* bw rectangle read */
    osg_writerect,	/* bw rectangle write */
    osg_poll,		/* handle events */
    osg_flush,		/* flush output */
    osg_free,		/* free resources */
    osg_help,		/* help message */
    "OpenSceneGraph",	/* device description */
    32*1024,		/* max width */
    32*1024,		/* max height */
    bu_strdup("/dev/osg"),		/* short device name */
    512,		/* default/current width */
    512,		/* default/current height */
    -1,			/* select fd */
    -1,			/* file descriptor */
    1, 1,		/* zoom */
    256, 256,		/* window center */
    0, 0, 0,		/* cursor */
    PIXEL_NULL,		/* page_base */
    PIXEL_NULL,		/* page_curp */
    PIXEL_NULL,		/* page_endp */
    -1,			/* page_no */
    0,			/* page_dirty */
    0L,			/* page_curpos */
    0L,			/* page_pixels */
    0,			/* debug */
    {0}, /* u1 */
    {0}, /* u2 */
    {0}, /* u3 */
    {0}, /* u4 */
    {0}, /* u5 */
    {0}  /* u6 */
};


/*
 * Local Variables:
 * mode: C
 * tab-width: 8
 * indent-tabs-mode: t
 * c-file-style: "stroustrup"
 * End:
 * ex: shiftwidth=4 tabstop=8
 */
blob
data 51053
#-----------------------------------------------------------------------
# Local Copies of External Libraries
#
# BRL-CAD depends on a variety of external libraries and tools -
# rather than fail if those requirements are not satisfied, we build
# local copies at need.
#
# There are three overall approaches to the handling of these
# dependencies:
#
# 1.  Auto - detect system libraries and use them if suitable,
#     otherwise build and use the local copy.  This is the default
#     approach.
#
# 2.  Bundled - regardless of system conditions, build and use all
#     bundled libraries.
#
# 3.  System - fail to build if the system libraries do not satisfy
#     requirements.  This is primarily useful for distributions that
#     want to ensure packages are using external libraries.
#
# In addition to the broad toplevel control, individual libraries can
# also be overridden - for example, if the toplevel setting is for
# Bundled libs, it is still possible to request a system library in
# individual cases.
#
#-----------------------------------------------------------------------

# Clear all BRL-CAD defined CMake flags
CLEAR_BUILD_FLAGS()

# Restore CMake's original flags
RESTORE_CACHED_BUILD_FLAGS()

# Quiet all warnings in this directory
if(BRLCAD_DISABLE_SRC_OTHER_WARN)
  add_definitions(-w)
endif(BRLCAD_DISABLE_SRC_OTHER_WARN)

# Ideally we wouldn't need this, but in a few cases we're using
# BRL-CAD's include dirs.
include_directories(
  ${BRLCAD_BINARY_DIR}/include
  ${BRLCAD_SOURCE_DIR}/include
  )

# Most third party items have a list calling out files for distcheck -
# these are stored in files in the dlists directory.  Ignore that
# directory for distcheck
file(GLOB dlists "*.dist")
foreach(ITEM ${dlists})
  get_filename_component(dlist ${ITEM} NAME)
  CMAKEFILES(${dlist})
endforeach(ITEM ${dlists})

# For lower build levels, some of the third party components are not
# needed.  define some variables we can use for testing.
set(BRLCAD_LEVEL2 0)
set(BRLCAD_LEVEL3 0)
if(NOT BRLCAD_ENABLE_TARGETS)
  set(BRLCAD_LEVEL2 1)
  set(BRLCAD_LEVEL3 1)
else(NOT BRLCAD_ENABLE_TARGETS)
  if(${BRLCAD_ENABLE_TARGETS} GREATER 1)
    set(BRLCAD_LEVEL2 1)
  endif(${BRLCAD_ENABLE_TARGETS} GREATER 1)
  if(${BRLCAD_ENABLE_TARGETS} GREATER 2)
    set(BRLCAD_LEVEL3 1)
  endif(${BRLCAD_ENABLE_TARGETS} GREATER 2)
endif(NOT BRLCAD_ENABLE_TARGETS)

# At the start, clear the src/other subdirs list so repeated
# configures will correctly add the required directories
set(SRC_OTHER_ADDED_DIRS "" CACHE STRING "initialize 3rd party sub-directories list" FORCE)
mark_as_advanced(SRC_OTHER_ADDED_DIRS)

macro(SetTargetFolder targetname folder)
  if(TARGET ${targetname})
    set_target_properties(${targetname} PROPERTIES FOLDER "${folder}")
  endif(TARGET ${targetname})
endmacro(SetTargetFolder)

#-----------------------------------------------------------------------------
# Load some CMake macros to handle the special case of third party libraries.
include(${BRLCAD_CMAKE_DIR}/ThirdParty.cmake)


# libregex library -  often needed by tools, so do this one first.
set(regex_ALIASES ENABLE_REGEX)
set(regex_DESCRIPTION "
Option for enabling and disabling compilation of the Regular
Expression Library provided with BRL-CAD's source distribution.
Default is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option
and testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.
")
THIRD_PARTY(libregex REGEX regex regex_DESCRIPTION ALIASES ${regex_ALIASES})
BRLCAD_INCLUDE_FILE(regex.h HAVE_REGEX_H)
SetTargetFolder(regex "Third Party Libraries")
SetTargetFolder(regex-static "Third Party Libraries")

CHECK_LIBRARY_EXISTS(c regcomp "" HAVE_LIBC_REGEX)
if(BUILD_SHARED_LIBS AND HAVE_LIBC_REGEX AND "${BRLCAD_REGEX}" MATCHES "BUNDLED")
  # Our tests indicate that the system libc defines regex symbols, but
  # we're still building with our local libregex.
  #
  # Platform differences in default linker behavior make it difficult
  # to guarantee that our libregex symbols will override libc. We'll
  # avoid the issue by renaming our libregex symbols to be
  # incompatible with libc.

  # First we add definitions to our config file to rename all of the
  # regex function calls in our first-party code.
  CONFIG_H_APPEND(BRLCAD "#define regcomp  libregex_regcomp\n")
  CONFIG_H_APPEND(BRLCAD "#define regerror libregex_regerror\n")
  CONFIG_H_APPEND(BRLCAD "#define regexec  libregex_regexec\n")
  CONFIG_H_APPEND(BRLCAD "#define regfree  libregex_regfree\n")

  # Second, we add the same definitions to libregex to rename the
  # function declarations and definitions to match the calls.
  #
  # Note that this is necessary despite the fact that libregex/regex.h
  # includes common.h. Our config file is intentionally omitted from
  # common.h until after the third party dirs are processed, so the
  # above definitions don't affect libregex.
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regcomp=libregex_regcomp)
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regerror=libregex_regerror)
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regexec=libregex_regexec)
  set_property(DIRECTORY libregex APPEND PROPERTY COMPILE_DEFINITIONS regfree=libregex_regfree)
endif(BUILD_SHARED_LIBS AND HAVE_LIBC_REGEX AND "${BRLCAD_REGEX}" MATCHES "BUNDLED")

# Same deal for zlib Library - common requirement, deal with it up front
set(zlib_ALIASES ENABLE_ZLIB ENABLE_LIBZ)
set(zlib_DESCRIPTION "
Option for enabling and disabling compilation of the zlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(libz ZLIB zlib zlib_DESCRIPTION ALIASES ${zlib_ALIASES})
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libz/CTestTestfile.cmake)
SetTargetFolder(zlib "Third Party Libraries")
SetTargetFolder(zlib-static "Third Party Libraries")
SetTargetFolder(example "Third Party Executables")
SetTargetFolder(minigzip "Third Party Executables")

#-----------------------------------------------------------------------------

#---------------------------------------------------------------------------------
# Local Copies of Tools
#---------------------------------------------------------------------------------

# Because we sometimes need to override system versions of tools, it
# is essential that the variables containing the executable to be run
# for each of the following tools use full paths - if just the name of
# the target is used, there is a chance that name is the same as the
# executable name itself.  In that case, if the system executable is
# in the path, it may get called instead of resolving to the compiled
# exectuable associated with the CMake target.  (Information from the
# CMake devs indicates this is not expected behavior, but at some
# point during the development efforts a problem apparently related to
# this came up.)  On single configuration systems we can reference
# specify the full path to the binary directory at CMake configure
# time, but this isn't possible for multi-configuration systems like
# Visual Studio since that path changes at run-time.  For those
# situations, CMake provides a variable CMAKE_CFG_INTDIR that will
# insert the correct logic for config-dependent paths.

# For those wanting to use a system version of the LEMON parser
# generator from sqlite, remember that the presence of /usr/bin/lemon
# is not enough.  LEMON needs a template file, lempar.c, and by
# default it needs it in the same directory as /usr/bin/lemon.  The
# typical approach to avoiding that requirement is to patch lemon,
# like this Gentoo ebuild:
#
# http://gentoo-overlays.zugaina.org/gentoo-zh/portage/dev-util/lemon/
#
# LEMON packages for other major Linux/BSD distros will do the same.
# BRL-CAD's FindLEMON.cmake macros will look for the template file in
# the executable directory first, and if not there will check in
# /usr/share/lemon (the location used by several distributions.)  If
# your distribution has a working lemon with the lempar.c template
# file in a custom location, specify the full path to the template
# with the variable LEMON_TEMPLATE - something like:
#
# cmake .. -DLEMON_TEMPLATE=/etc/lemon/lempar.c
#
# This is not to tell LEMON what template to use - that information is
# usually hardcoded in LEMON itself - but to let FindLEMON.cmake know
# there is a working LEMON installation.
set(lemon_ALIASES ENABLE_LEMON)
set(lemon_DESCRIPTION "
Option for enabling and disabling compilation of the lemon parser
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
if("${BRLCAD_BUNDLED_LIBS}" STREQUAL "BUNDLED" OR "${BRLCAD_LEMON}" MATCHES "BUNDLED")
  set(LEMON_TEMPLATE "${BRLCAD_SOURCE_DIR}/src/other/lemon/lempar.c")
endif("${BRLCAD_BUNDLED_LIBS}" STREQUAL "BUNDLED" OR "${BRLCAD_LEMON}" MATCHES "BUNDLED")
THIRD_PARTY_EXECUTABLE(lemon lemon "BRLCAD_LEVEL2" lemon_ALIASES lemon_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/lemon/Makefile)
# Unless some parent logic has already defined the macro, we need to
# load LEMON_Util to be able to define LEMON targets.
if(NOT COMMAND LEMON_TARGET)
  include(${BRLCAD_CMAKE_DIR}/LEMON_Util.cmake)
endif(NOT COMMAND LEMON_TARGET)
SetTargetFolder(lemon "Compilation Utilities")
SetTargetFolder(lempar_cp "Compilation Utilities")

set(re2c_ALIASES ENABLE_RE2C)
set(re2c_DESCRIPTION "
Option for enabling and disabling compilation of the re2c scanner
utility provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY_EXECUTABLE(re2c re2c "BRLCAD_LEVEL2" re2c_ALIASES re2c_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/re2c/Makefile)
SetTargetFolder(re2c "Compilation Utilities")
SetTargetFolder(re2c_bootstrap "Compilation Utilities")

# Unless some parent logic has already defined the macro, we need to
# load RE2C_Util to be able to define RE2C targets.

if(NOT COMMAND RE2C_TARGET)
  include(${BRLCAD_SOURCE_DIR}/misc/CMake/RE2C_Util.cmake)
endif(NOT COMMAND RE2C_TARGET)

# Perplex is set up as a src/other sub-build, but at this time it is
# entirely a BRL-CAD effort and not distributed or maintained as its
# own project.

# For all BRL-CAD projects, we will use the perplex template in
# src/other/perplex
set(PERPLEX_TEMPLATE "${CMAKE_CURRENT_SOURCE_DIR}/perplex/perplex_template.c" CACHE STRING "Perplex template file" FORCE)
mark_as_advanced(PERPLEX_TEMPLATE)

set(perplex_ALIASES ENABLE_PERPLEX)
set(perplex_DESCRIPTION "
Option for enabling and disabling compilation of the perplex scanner
generator provided with BRL-CAD's source distribution.  Default is
AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.  perplex requires a working re2c.
")
THIRD_PARTY_EXECUTABLE(perplex perplex "BRLCAD_LEVEL2" perplex_ALIASES perplex_DESCRIPTION NOSYS)
# Unless some parent logic has already defined the macro, we need to
# load PERPLEX_Util to be able to define PERPLEX targets.
if(NOT COMMAND PERPLEX_TARGET)
  include(${BRLCAD_SOURCE_DIR}/misc/CMake/PERPLEX_Util.cmake)
endif(NOT COMMAND PERPLEX_TARGET)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/perplex/Makefile)
SetTargetFolder(perplex "Compilation Utilities")
SetTargetFolder(perplex_template_cp "Compilation Utilities")

# libxml and libxslt tools for DocBook processing.  We build just
# enough library support to get these two tools working.
set(xsltproc_ALIASES ENABLE_XSLTPROC)
set(xsltproc_DESCRIPTION "
Option for enabling and disabling compilation of the xsltproc XML
transformation utility provided with BRL-CAD's source distribution.
Used for DocBook documentation processing.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
Depends on BRLCAD_EXTRADOCS.
")
THIRD_PARTY_EXECUTABLE(xsltproc xmltools "BRLCAD_EXTRADOCS;BRLCAD_LEVEL3" xsltproc_ALIASES xsltproc_DESCRIPTION)
SetTargetFolder(xsltproc "Compilation Utilities")

# Used only when validating XML for schema compliance
# (BRLCAD_EXTRADOCS_VALIDATE must be on to use this, although it is compiled
# regardless if the xmltools subdirectory build is added.)
set(xmllint_ALIASES ENABLE_XMLLINT)
set(xmllint_DESCRIPTION "
Option for enabling and disabling compilation of the xmllint XML
validation utility provided with BRL-CAD's source distribution.  Used
for DocBook documentation validation.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY_EXECUTABLE(xmllint xmltools "BRLCAD_EXTRADOCS_VALIDATE;BRLCAD_LEVEL3" xmllint_ALIASES xmllint_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/xmltools/include)
SetTargetFolder(xmllint "Compilation Utilities")

SetTargetFolder(xml "Third Party Libraries")
SetTargetFolder(xslt "Third Party Libraries")
SetTargetFolder(exslt "Third Party Libraries")

# --------------------------------------------------------------------
# Third Party Sources
# --------------------------------------------------------------------
# Ignore the boost subdir - it's only used for the boost headers and
# is not compiled
CMAKEFILES(boost)

# The incrtTcl subdirectory isn't directly referenced, but its
# subdirectories are used - mark incrTcl as ignored
CMAKEFILES(incrTcl)

# Ignore the osl subdir
CMAKEFILES(osl)

# libtermlib Library Only on WIN32 will the combination of the build
# search tests and libtermlib fail to find a valid term, so set
# variables accordingly
if(NOT WIN32)
  set(HAVE_TERMLIB ON CACHE BOOL "Have some termlib" FORCE)
ELSE(NOT WIN32)
  set(BRLCAD_TERMLIB_BUILD "System" CACHE STRING "Disable libtermlib build on WIN32." FORCE)
  mark_as_advanced(BRLCAD_TERMLIB_BUILD)
  set(HAVE_TERMLIB OFF CACHE BOOL "Have some termlib" FORCE)
endif(NOT WIN32)
mark_as_advanced(HAVE_TERMLIB)

set(termlib_ALIASES ENABLE_TERMLIB)
set(termlib_DESCRIPTION "
Option for enabling and disabling compilation of the termlib library
provided with BRL-CAD's source distribution.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO. (Except when building with Visual Studio, where it is
disabled. Windows does not support the termlib API.)
")
THIRD_PARTY(libtermlib TERMLIB termlib termlib_DESCRIPTION REQUIRED_VARS HAVE_TERMLIB
  BRLCAD_LEVEL2 ALIASES ${termlib_ALIASES})
if(BRLCAD_TERMLIB_BUILD)
  set(HAVE_TERMCAP_H ON CACHE BOOL "src/other termlib is on" FORCE)
  CONFIG_H_APPEND(BRLCAD "#undef HAVE_TERMCAP_H\n#cmakedefine HAVE_TERMCAP_H 1\n")
  mark_as_advanced(HAVE_TERMCAP_H)
endif(BRLCAD_TERMLIB_BUILD)

# libpng Library - Checks for ZLIB, so need to handle libpng AFTER
# zlib to set the variables if using a local copy of zlib.  If not
# using a local copy of zlib, FindZLIB results will be identical in
# both cases so there is no danger of harming the libpng setup.  The
# PNG CMake system needs some options set and some variables
# translated to fit BRL-CAD's standard assumptions, so handle that
# here as well.  BRL-CAD needs PNG's IO - turn it on (i.e. turn off
# the disabling flags)

set(PNG_NO_CONSOLE_IO OFF CACHE BOOL "Option to disable Console IO in PNG" FORCE)
mark_as_advanced(PNG_NO_CONSOLE_IO)
set(PNG_NO_STDIO OFF CACHE BOOL "Option to disable STDIO in PNG" FORCE)
mark_as_advanced(PNG_NO_STDIO)
set(SKIP_INSTALL_EXPORT ON CACHE BOOL "We dont't want export for this application" FORCE)
mark_as_advanced(SKIP_INSTALL_EXPORT)
set(PNG_MAN_DIR ${MAN_DIR} CACHE STRING "Set PNG_MAN_DIR to the global MAN_DIR" FORCE)
mark_as_advanced(PNG_MAN_DIR)
set(CMAKE_INSTALL_LIBDIR ${LIB_DIR})
set(png_ALIASES ENABLE_PNG)
set(png_DESCRIPTION "
Option for enabling and disabling compilation of the Portable Network
Graphics library provided with BRL-CAD's source distribution.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.
")
# Note - we don't actually know the libpng build target name for the
# shared library at this point - use png as a stub and override
# once we know what PNG_LIB_NAME is.
THIRD_PARTY(libpng PNG png png_DESCRIPTION REQUIRED_VARS BRLCAD_LEVEL2 ALIASES ${png_ALIASES})
if(BRLCAD_PNG_BUILD)
  # PNG_LIB_NAME doesn't automatically propagate to toplevel due to
  # scoping of CMake variables - use get_directory_property to recover
  # the value (which is later put in the CACHE)

  get_directory_property(PNG_LIBRARY DIRECTORY libpng DEFINITION PNG_LIB_NAME)

  # On Haiku the find_library call sets this variable directly, which is not
  # how we handle things elsewhere in BRL-CAD - unset the variable in that
  # situation so the remainder of the build logic works normally
  if("${M_LIBRARY}" MATCHES "NOTFOUND")
    unset(M_LIBRARY CACHE)
  endif("${M_LIBRARY}" MATCHES "NOTFOUND")
  SetTargetFolder(png16 "Third Party Libraries")
  SetTargetFolder(png16_static "Third Party Libraries")
  SetTargetFolder(pngtest "Third Party Libraries")
  SetTargetFolder(pngstest "Third Party Libraries")
  SetTargetFolder(pngvalid "Third Party Libraries")
ELSE(BRLCAD_PNG_BUILD)
  # The PNG CMake file seems to set PNG_PNG_INCLUDE_DIR rather than
  # PNG_INCLUDE_DIR, so a generic macro won't pick up the setting -
  # handle it here.
  set(PNG_INCLUDE_DIR ${PNG_PNG_INCLUDE_DIR} CACHE STRING "PNG include directory" FORCE)
endif(BRLCAD_PNG_BUILD)

# Make sure this value is in the cache, regardless of
# BRLCAD_PNG_BUILD, so it can be referenced unconditionally elsewhere.
set(PNG_LIBRARY "${PNG_LIBRARY}" CACHE STRING "libpng name for targets" FORCE)

DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/CTestTestfile.cmake)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng.pc)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng-config)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng${CMAKE_SHARED_LIBRARY_SUFFIX})
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/libpng/libpng${CMAKE_STATIC_LIBRARY_SUFFIX})
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng.pc)
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng-config)
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng${CMAKE_SHARED_LIBRARY_SUFFIX})
DISTCLEAN(${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/libpng${CMAKE_STATIC_LIBRARY_SUFFIX})
# Other PNG options to mark as advanced
mark_as_advanced(PNGARG)
mark_as_advanced(PNG_DEBUG)
mark_as_advanced(PNG_SHARED)
mark_as_advanced(PNG_STATIC)
mark_as_advanced(PNG_TESTS)
mark_as_advanced(uname_executable)


# libutahrle Library - The directory to perform ADD_SUBDIRECTORY on
# and the include directory for utahrle are different, so override the
# macro's setting of UTAHRLE_INCLUDE_DIR here.

set(utahrle_ALIASES ENABLE_UTAHRLE)
set(utahrle_DESCRIPTION "
Option for enabling and disabling compilation of the Utah Raster
Toolkit library provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(libutahrle UTAHRLE utahrle utahrle_DESCRIPTION REQUIRED_VARS BRLCAD_LEVEL3
  ALIASES ${utahrle_ALIASES} FLAGS NOSYS)
if(BRLCAD_UTAHRLE_BUILD)
  SetTargetFolder(utahrle "Third Party Libraries")
  SetTargetFolder(utahrle-static "Third Party Libraries")
  set(UTAHRLE_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/libutahrle/include" CACHE STRING "directory with rle.h header" FORCE)
  set(BRLCAD_UTAHRLE_INCLUDE_DIR "${UTAHRLE_INCLUDE_DIR}" CACHE STRING "directory with rle.h header" FORCE)
  mark_as_advanced(UTAHRLE_INCLUDE_DIR)
  mark_as_advanced(BRLCAD_UTAHRLE_INCLUDE_DIR)
endif(BRLCAD_UTAHRLE_BUILD)


# URTToolkit - Programs, not a library - needs libutahrle, but the
# "check for system install" logic will be different here.  Ignore for
# now, revisit later.

if(BRLCAD_LEVEL3)
  add_subdirectory(URToolkit)
endif(BRLCAD_LEVEL3)
include(${CMAKE_CURRENT_SOURCE_DIR}/URToolkit.dist)
CMAKEFILES_IN_DIR(URToolkit_ignore_files URToolkit)

# Tcl/Tk presents a number of complexities for BRL-CAD and CMake.
# BRL-CAD requires far more knowledge of the details of a Tcl/Tk
# installation than most programs, which unfortunately means the
# standard FindTCL.cmake is not sufficient. We have our own FindTCL
# routine which handles Tcl/Tk and its stubs, so trigger this using
# the THIRD_PARTY macro for TCL.

include(${BRLCAD_SOURCE_DIR}/misc/CMake/TCL_PKGINDEX.cmake)

# Set Tcl/Tk requirements for BRL-CAD so FindTCL.cmake knows what to reject
set(TCL_PATH_NOMATCH_PATTERNS "/usr/brlcad;brlcad-install;${CMAKE_INSTALL_PREFIX}" CACHE STRING "Paths to avoid when looking for tcl/tk" FORCE)
set(TCL_MIN_VERSION "8.5" CACHE STRING "Minimum acceptable Tcl/Tk version" FORCE)

if(BRLCAD_ENABLE_TK)
  set(TCL_REQUIRE_TK 1)
ELSE(BRLCAD_ENABLE_TK)
  set(TCL_REQUIRE_TK 0)
endif(BRLCAD_ENABLE_TK)

set(tcl_ALIASES ENABLE_TCL)
set(tcl_DESCRIPTION "
Option for enabling and disabling compilation of the Tcl library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.
")

THIRD_PARTY(tcl TCL tcl tcl_DESCRIPTION ALIASES ${tcl_ALIASES})
if(BRLCAD_TCL_BUILD)
  SetTargetFolder(tclsh "Third Party Executables")
  SetTargetFolder(tcl "Third Party Libraries")
  SetTargetFolder(tclstub "Third Party Libraries")
  # Set the variables ourselves since FindTCL.cmake doesn't know about our build
  set(TCL_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/tcl)
  set(TCL_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
  set(TCL_LIBRARY tcl CACHE STRING "TCL_LIBRARY" FORCE)
  set(TCL_LIBRARIES tcl CACHE STRING "TCL_LIBRARY" FORCE)
  set(TCL_CONF_PREFIX "NONE-CMake" CACHE STRING "TCL_CONF_PREFIX" FORCE)
  set(TCL_STUB_LIBRARY tclstub CACHE STRING "TCL_LIBRARY" FORCE)
  set(TCL_STUB_LIBRARIES tclstub CACHE STRING "TCL_LIBRARY" FORCE)
  get_directory_property(TCL_INCLUDE_DIRS DIRECTORY tcl DEFINITION TCL_INCLUDE_DIRS)
  set(TCL_INCLUDE_DIRS "${TCL_INCLUDE_DIRS}" CACHE STRING "Tcl include paths" FORCE)
  set(TCL_INCLUDE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/tcl/generic" CACHE STRING "Tcl include path" FORCE)
  set(TCL_TCLSH_EXECUTABLE tclsh CACHE STRING "Tcl shell" FORCE)
  set(TCL_TCLSH tclsh CACHE STRING "Tcl shell" FORCE)
  get_directory_property(TCL_VERSION_MAJOR DIRECTORY tcl DEFINITION TCL_VERSION_MAJOR)
  set(TCL_VERSION_MAJOR "${TCL_VERSION_MAJOR}" CACHE STRING "Tcl MAJOR version" FORCE)
  get_directory_property(TCL_VERSION_MINOR DIRECTORY tcl DEFINITION TCL_VERSION_MINOR)
  set(TCL_VERSION_MINOR "${TCL_VERSION_MINOR}" CACHE STRING "Tcl MINOR version" FORCE)
  CONFIG_H_APPEND(BRLCAD "#define HAVE_TCL_H 1\n")
  CONFIG_H_APPEND(BRLCAD "#define TCL_SYSTEM_INITTCL_PATH \"\"\n")
  include(${CMAKE_CURRENT_SOURCE_DIR}/tcl.dist)
  CMAKEFILES_IN_DIR(tcl_ignore_files tcl)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/Makefile)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/man1)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/man3)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/doc/mann)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tcl/library/Makefile)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tcl8)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tcl8.5)
ELSE(BRLCAD_TCL_BUILD)
  if(${TCL_TCLSH_EXECUTABLE})
    BRLCAD_INCLUDE_FILE(tcl.h HAVE_TCL_H)
    # We're going to need the path to the system init.tcl for btclsh and bwish
    set(inittcl_script "
set filename \"${CMAKE_BINARY_DIR}/CMakeTmp/tcl_inittcl\"
set fileID [open $filename \"w\"]
puts $fileID $auto_path
close $fileID
exit
")
    set(inittcl_scriptfile "${CMAKE_BINARY_DIR}/CMakeTmp/tcl_inittcl.tcl")
    file(WRITE ${inittcl_scriptfile} ${inittcl_script})
    EXEC_PROGRAM(${TCL_TCLSH_EXECUTABLE} ARGS ${inittcl_scriptfile} OUTPUT_VARIABLE EXECOUTPUT)
    file(READ ${CMAKE_BINARY_DIR}/CMakeTmp/tcl_inittcl tcl_inittcl_raw)
    STRING(REGEX REPLACE "\n" "" tcl_inittcl_paths_1 ${tcl_inittcl_raw})
    STRING(REGEX REPLACE " " ";" tcl_inittcl_paths ${tcl_inittcl_paths_1})
    FIND_PATH(tcl_inittcl NAMES init.tcl PATHS ${tcl_inittcl_paths})
    mark_as_advanced(tcl_inittcl)
    CONFIG_H_APPEND(BRLCAD "#define TCL_SYSTEM_INITTCL_PATH \"${tcl_inittcl}\"\n")
  endif(${TCL_TCLSH_EXECUTABLE})
endif(BRLCAD_TCL_BUILD)
mark_as_advanced(TCL_COMPILE_DEBUG)
mark_as_advanced(TCL_COMPILE_STATS)
mark_as_advanced(TCL_DEBUG)
mark_as_advanced(TCL_ENABLE_64BIT)
mark_as_advanced(TCL_ENABLE_DLL_UNLOADING)
mark_as_advanced(TCL_ENABLE_LANGINFO)
mark_as_advanced(TCL_ENABLE_LOAD)
mark_as_advanced(TCL_OPTIMIZED)
mark_as_advanced(TCL_THREADS)
mark_as_advanced(TCL_TIMEZONE_DATA)
mark_as_advanced(M_LIBRARY)

# Depending on the Tcl/Tk results, look for packages required by BRL-CAD.  If
# building local Tcl/Tk, go ahead and enable all the packages as well - otherwise,
# check the found Tcl/Tk and enable what it doesn't supply.  If doing a non-graphical
# build, only compile extensions that don't use Tk.
include(${BRLCAD_CMAKE_DIR}/ThirdParty_TCL.cmake)

# The first package to settle is Tk itself
set(tk_ALIASES ENABLE_TK)
set(tk_DESCRIPTION "
Option for enabling and disabling compilation of the Tk library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the BRLCAD_TCL option and testing first for a system version if
BRLCAD_BUNDLED_LIBS is also AUTO. Option for enabling and disabling
compilation of the Tk graphics package for Tcl provided with BRL-CAD's
source distribution.  Default is AUTO, auto-enabling if the BRLCAD_TCL
option is set to BUNDLED and testing first for a system version if
BRLCAD_TCL is set to AUTO or SYSTEM.  If BRLCAD_TK is set to BUNDLED,
local copy is built even if a system version is present.  This option
also depends on BRLCAD_ENABLE_TK being ON.
")
THIRD_PARTY_TCL_PACKAGE(Tk tk "${TCL_TCLSH_EXECUTABLE}" "tcl" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL2" "tk" tk_ALIASES tk_DESCRIPTION)
if(BRLCAD_TK_BUILD)
  SetTargetFolder(wish "Third Party Executables")
  SetTargetFolder(tk "Third Party Libraries") 
  SetTargetFolder(tkstub "Third Party Libraries") 
  # Set the variables ourselves since FindTCL.cmake doesn't know about our build
  set(TCL_TK_LIBRARY tk CACHE STRING "TCL_TK_LIBRARY" FORCE)
  set(TCL_TK_CONF_PREFIX "NONE-CMake" CACHE STRING "TCL_TK_CONF_PREFIX" FORCE)
  set(TCL_LIBRARIES ${TCL_LIBRARIES} tk CACHE STRING "TCL_LIBRARIES" FORCE)
  set(TK_LIBRARY tk CACHE STRING "TK_LIBRARY" FORCE)
  set(TCL_STUB_LIBRARIES tkstub ${TCL_STUB_LIBRARIES} CACHE STRING "TCL_TK_STUBLIBRARIES" FORCE)
  set(TCL_TK_STUB_LIBRARY tkstub CACHE STRING "TCL_TK_STUB_LIBRARY" FORCE)
  set(TK_STUB_LIBRARY tkstub CACHE STRING "TK_STUB_LIBRARY" FORCE)
  set(TK_INCLUDE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/tk/generic" CACHE STRING "Tk include path" FORCE)
  set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${TK_INCLUDE_PATH} CACHE STRING "Tcl include paths" FORCE)
  if(WIN32)
    set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/tk/win ${CMAKE_CURRENT_SOURCE_DIR}/tk/xlib CACHE STRING "Tcl include paths" FORCE)
  endif(WIN32)
  set(TCL_WISH_EXECUTABLE wish CACHE STRING "Tk shell" FORCE)
  set(TK_WISH wish CACHE STRING "Tk shell" FORCE)
  if(WIN32)
    set(TK_SYSTEM_GRAPHICS "win32" CACHE STRING "Tk system graphics" FORCE)
  ELSEif(APPLE)
    if(OPENGL_USE_AQUA)
      set(TK_SYSTEM_GRAPHICS "aqua" CACHE STRING "Tk system graphics" FORCE)
    ELSE(OPENGL_USE_AQUA)
      set(TK_SYSTEM_GRAPHICS "x11" CACHE STRING "Tk system graphics" FORCE)
    endif(OPENGL_USE_AQUA)
  ELSEif(UNIX)
    set(TK_SYSTEM_GRAPHICS "x11" CACHE STRING "Tk system graphics" FORCE)
  endif(WIN32)
  CONFIG_H_APPEND(BRLCAD "#define HAVE_TK_H 1\n")
  mark_as_advanced(TK-ENABLE_FREETYPE)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/Makefile)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/man1)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/man3)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/doc/mann)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/library/Makefile)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tk/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tk8.5)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tk8.5.9)
ELSE(BRLCAD_TK_BUILD)
  if(BRLCAD_ENABLE_TK)
    BRLCAD_INCLUDE_FILE(tk.h HAVE_TK_H)
  endif(BRLCAD_ENABLE_TK)
endif(BRLCAD_TK_BUILD)
mark_as_advanced(TK_INCLUDE_PATH)
mark_as_advanced(TK_LIBRARY)
mark_as_advanced(TK_STUB_LIBRARY)
mark_as_advanced(TK_SYSTEM_GRAPHICS)
mark_as_advanced(TK_WISH)
mark_as_advanced(TK_ENABLE_XFT)

# Now that Tcl/Tk is settled, define the HAVE_TK flag for the config.h
# file

if(BRLCAD_ENABLE_TK)
  set(HAVE_TK 1 CACHE STRING "C level Tk flag" FORCE)
  CONFIG_H_APPEND(BRLCAD "#cmakedefine HAVE_TK\n")
ELSE(BRLCAD_ENABLE_TK)
  set(HAVE_TK 0 CACHE STRING "C level Tk flag" FORCE)
endif(BRLCAD_ENABLE_TK)
mark_as_advanced(HAVE_TK)

# Tcl/Tk extensions need a variety of settings provided for them -
# take care of those here.  Because system Tcl/Tk installations are
# not guaranteed to have what is needed in the way of headers, go
# ahead and assign includedir settings based on the local sources even
# if system versions are enabled.  Ugly, but an unfortunate
# consequence of current Tcl/Tk coding styles

set(TCL_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/tcl)
set(TK_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/tk)
set(ITCL_SRC_PREFIX ${CMAKE_CURRENT_SOURCE_DIR}/incrTcl/itcl)
if(WIN32)
  set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/tcl/generic ${CMAKE_CURRENT_SOURCE_DIR}/tcl/win ${CMAKE_CURRENT_SOURCE_DIR}/tcl/libtommath)
  set(TK_INCLUDE_PATH ${TK_INCLUDE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/tk/generic ${CMAKE_CURRENT_SOURCE_DIR}/tk/xlib ${CMAKE_CURRENT_SOURCE_DIR}/tk/win ${CMAKE_CURRENT_SOURCE_DIR}/tk/bitmaps)
ELSE(WIN32)
  set(TCL_INCLUDE_DIRS ${TCL_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR}/tcl/generic ${CMAKE_CURRENT_SOURCE_DIR}/tcl/unix ${CMAKE_CURRENT_SOURCE_DIR}/tcl/libtommath)
  set(TK_INCLUDE_PATH ${TK_INCLUDE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/tk/generic ${CMAKE_CURRENT_SOURCE_DIR}/tk/unix ${CMAKE_CURRENT_SOURCE_DIR}/tk/bitmaps)
endif(WIN32)
set(ITCL_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/incrTcl/itcl/generic)
if(BRLCAD_TCL_BUILD)
  set(TCL_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
ELSE(BRLCAD_TCL_BUILD)
  get_filename_component(TCL_BIN_PREFIX ${TCL_LIBRARY} PATH)
endif(BRLCAD_TCL_BUILD)
if(BRLCAD_ENABLE_TK)
  if(BRLCAD_TK_BUILD)
    set(TK_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
    get_directory_property(TK_X11_INCLUDE_DIRS DIRECTORY tk DEFINITION TK_X11_INCLUDE_DIRS)
  ELSE(BRLCAD_TK_BUILD)
    if(TCL_TK_LIBRARY)
      get_filename_component(TK_BIN_PREFIX ${TCL_TK_LIBRARY} PATH)
    endif(TCL_TK_LIBRARY)
    if(X11_INCLUDE_DIR)
      set(TK_X11_INCLUDE_DIRS ${X11_INCLUDE_DIR})
    endif(X11_INCLUDE_DIR)
    if(X11_Xft_INCLUDE_PATH)
      set(TK_X11_INCLUDE_DIRS ${TK_X11_INCLUDE_DIRS}
	${X11_Xft_INCLUDE_PATH})
    endif(X11_Xft_INCLUDE_PATH)
    if(X11_Xrender_INCLUDE_PATH)
      set(TK_X11_INCLUDE_DIRS ${TK_X11_INCLUDE_DIRS}
	${X11_Xrender_INCLUDE_PATH})
    endif(X11_Xrender_INCLUDE_PATH)
    if(X11_Xscreensaver_INCLUDE_PATH)
      set(TK_X11_INCLUDE_DIRS ${TK_X11_INCLUDE_DIRS}
	${X11_Xscreensaver_INCLUDE_PATH})
    endif(X11_Xscreensaver_INCLUDE_PATH)
  endif(BRLCAD_TK_BUILD)
endif(BRLCAD_ENABLE_TK)


# First up, look for IncrTcl's Itcl.
set(itcl_ALIASES ENABLE_ITCL)
set(itcl_DESCRIPTION "
Option for enabling and disabling compilation of the IncrTcl package
for Tcl objects provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_ITCL is set to BUNDLED, local copy is built even if
a system version is present.
")
THIRD_PARTY_TCL_PACKAGE(Itcl incrTcl/itcl "${TCL_TCLSH_EXECUTABLE}" "tcl" "BRLCAD_LEVEL2" "itcl" itcl_ALIASES itcl_DESCRIPTION)
if(BRLCAD_ITCL_BUILD)
  set(ITCL_LIBRARY itcl CACHE STRING "ITCL_LIBRARY" FORCE)
  set(ITCL_STUB_LIBRARY itclstub CACHE STRING "ITCL_STUB_LIBRARY" FORCE)
  get_directory_property(ITCL_INCLUDE_DIRS DIRECTORY incrTcl/itcl DEFINITION ITCL_INCLUDE_DIRS)
  set(ITCL_INCLUDE_DIRS "${ITCL_INCLUDE_DIRS}" CACHE STRING "Itcl include paths" FORCE)
  set(ITCL_VERSION "3.4" CACHE STRING "ITCL_VERSION" FORCE)
  set(ITCL_BIN_PREFIX ${CMAKE_BINARY_DIR}/${LIB_DIR})
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/incrTcl/itcl/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/itcl3.4)
  SetTargetFolder(itcl "Third Party Libraries")
  SetTargetFolder(itclstub "Third Party Libraries")
ELSE(BRLCAD_ITCL_BUILD)
  # We have Itcl package AND Itcl library - we're good.
  set(ITCL_VERSION "${ITCL_PACKAGE_VERSION}" CACHE STRING "ITCL_VERSION" FORCE)
  set(ITCL_LIBRARY ${ITCL_LIBRARY} CACHE STRING "ITCL_LIBRARY" FORCE)
  if(ITCL_LIBRARY)
    get_filename_component(ITCL_BIN_PREFIX ${ITCL_LIBRARY} PATH)
  endif(ITCL_LIBRARY)
endif(BRLCAD_ITCL_BUILD)
CONFIG_H_APPEND(BRLCAD "#cmakedefine ITCL_VERSION	\"${ITCL_VERSION}\"\n")
mark_as_advanced(ITCL_LIBRARY)
mark_as_advanced(ITCL_STUB_LIBRARY)
mark_as_advanced(ITCL_INCLUDE_DIRS)
mark_as_advanced(ITCL_VERSION)

# Look for IncrTcl's Itk.
set(itk_ALIASES ENABLE_ITK)
set(itk_DESCRIPTION "
Option for enabling and disabling compilation of the IncrTcl itk
package for Tk objects provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_ITK is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Itk incrTcl/itk "${TCL_WISH_EXECUTABLE}" "tcl;itcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "itk" itk_ALIASES itk_DESCRIPTION)
if(BRLCAD_ITK_BUILD)
  SetTargetFolder(itk "Third Party Libraries")
  SetTargetFolder(itkstub "Third Party Libraries")
  # does not handle C library settings.
  set(ITK_LIBRARY itk CACHE STRING "ITK_LIBRARY" FORCE)
  set(ITK_VERSION "3.3" CACHE STRING "ITK_VERSION" FORCE)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/incrTcl/itk/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/itk3.4)
ELSE(BRLCAD_ITK_BUILD)
  # We have Itcl/Itk packages AND Itcl/Itk libraries - we're good.
  set(ITK_VERSION "${ITCL_VERSION}" CACHE STRING "ITK_VERSION" FORCE)
  set(ITK_LIBRARY ${ITK_LIBRARY} CACHE STRING "ITK_LIBRARY" FORCE)
  if(ITK_LIBRARY)
    get_filename_component(ITK_BIN_PREFIX ${ITK_LIBRARY} PATH)
  endif(ITK_LIBRARY)
endif(BRLCAD_ITK_BUILD)
mark_as_advanced(ITK_VERSION)
mark_as_advanced(ITK_LIBRARY)

set(iwidgets_ALIASES ENABLE_IWIDGETS)
set(iwidgets_DESCRIPTION "
Option for enabling and disabling compilation of the IWidgets Tk
widget package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_IWIDGETS is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Iwidgets iwidgets "${TCL_WISH_EXECUTABLE}" "tcl;tk;itcl;itk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" iwidgets_ALIASES iwidgets_DESCRIPTION)
if(BRLCAD_IWIDGETS_BUILD)
  set(IWIDGETS_VERSION "4.0.1" CACHE STRING "IWIDGETS_VERSION" FORCE)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/iwidgets/pkgIndex.tcl)
  DISTCLEAN(${CMAKE_BINARY_DIR}/lib/Iwidgets4.0.1)
ELSE(BRLCAD_IWIDGETS_BUILD)
  set(IWIDGETS_VERSION "${IWIDGETS_PACKAGE_VERSION}" CACHE STRING "IWIDGETS_VERSION" FORCE)
endif(BRLCAD_IWIDGETS_BUILD)
CONFIG_H_APPEND(BRLCAD "#define IWIDGETS_VERSION \"${IWIDGETS_VERSION}\"\n")
mark_as_advanced(IWIDGETS_VERSION)

set(tkhtml_ALIASES ENABLE_TKHTML)
set(tkhtml_DESCRIPTION "
Option for enabling and disabling compilation of the Tkhtml HTML
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKHTML is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Tkhtml tkhtml "${TCL_WISH_EXECUTABLE}" "tcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tkhtml_ALIASES tkhtml_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tkhtml/pkgIndex.tcl)
DISTCLEAN(${CMAKE_BINARY_DIR}/lib/Tkhtml3.0)
#add_subdirectory(hv3)
#include(${CMAKE_CURRENT_SOURCE_DIR}/hv3.dist)
#CMAKEFILES_IN_DIR(hv3_ignore_files hv3)
#add_subdirectory(sqlite3)
#include(${CMAKE_CURRENT_SOURCE_DIR}/sqlite3.dist)
#CMAKEFILES_IN_DIR(sqlite3_ignore_files sqlite3)
CMAKEFILES(hv3)
CMAKEFILES(sqlite3)
SetTargetFolder(Tkhtml "Third Party Libraries")
SetTargetFolder(tkhtml_n_gen "Compilation Utilities")

set(tkpng_ALIASES ENABLE_TKPNG)
set(tkpng_DESCRIPTION "
Option for enabling and disabling compilation of the tkpng PNG image
viewing package provided with BRL-CAD's source distribution.  Default
is AUTO, auto-enabling if the BRLCAD_TCL option is set to BUNDLED and
testing first for a system version if BRLCAD_TCL is set to AUTO or
SYSTEM.  If BRLCAD_TKPNG is set to BUNDLED, local copy is built even if
a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(tkpng tkpng "${TCL_WISH_EXECUTABLE}" "tcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tkpng_ALIASES tkpng_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tkpng/pkgIndex.tcl)
DISTCLEAN(${CMAKE_BINARY_DIR}/lib/tkpng0.8)
SetTargetFolder(tkpng "Third Party Libraries")

set(tktable_ALIASES ENABLE_TKTABLE)
set(tktable_DESCRIPTION "
Option for enabling and disabling compilation of the Tktable graphical
table widget package provided with BRL-CAD's source distribution.
Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
BUNDLED and testing first for a system version if BRLCAD_TCL is set to
AUTO or SYSTEM.  If BRLCAD_TKTABLE is set to BUNDLED, local copy is built
even if a system version is present.  This package will be disabled if
BRLCAD_ENABLE_TK is OFF.
")
THIRD_PARTY_TCL_PACKAGE(Tktable tktable "${TCL_WISH_EXECUTABLE}" "tcl;tk" "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tktable_ALIASES tktable_DESCRIPTION)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tktable/pkgIndex.tcl)
DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tktable/tktable_cfg.h)
DISTCLEAN(${CMAKE_BINARY_DIR}/lib/Tktable2.10)
SetTargetFolder(Tktable "Third Party Libraries")
SetTargetFolder(tktable_header_gen "Compilation Utilities")

#set(tktreectrl_ALIASES ENABLE_TKTREECTRL)
#set(tktreectrl_DESCRIPTION "
#Option for enabling and disabling compilation of the TkTreeCtrl graphical
#table widget package provided with BRL-CAD's source distribution.
#Default is AUTO, auto-enabling if the BRLCAD_TCL option is set to
#BUNDLED and testing first for a system version if BRLCAD_TCL is set to
#AUTO or SYSTEM.  If BRLCAD_TKTREECTRL is set to BUNDLED, local copy is built
#even if a system version is present.  This package will be disabled if
#BRLCAD_ENABLE_TK is OFF.
#")
#THIRD_PARTY_TCL_PACKAGE(tktreectrl tktreectrl "${TCL_WISH_EXECUTABLE}" "tcl;tk"
#  "BRLCAD_ENABLE_TK;BRLCAD_LEVEL3" "" tktreectrl_ALIASES tktreectrl_DESCRIPTION)
#DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tktreectrl/pkgIndex.tcl)
#DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/tktreectrl/tktreectrl_cfg.h)
#DISTCLEAN(${CMAKE_BINARY_DIR}/lib/TkTreeCtrl2.4)

# OpenNURBS Library
set(opennurbs_ALIASES ENABLE_OPENNURBS)
set(opennurbs_DESCRIPTION "
Option for enabling and disabling compilation of the openNURBS library
provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(openNURBS OPENNURBS openNURBS opennurbs_DESCRIPTION ALIASES
  ${opennurbs_ALIASES} FLAGS NOSYS)
SetTargetFolder(openNURBS "Third Party Libraries")
SetTargetFolder(openNURBS-static "Third Party Libraries")

# STEPcode 
# Need Lemon/Perplex to build STEP - conditionalize

# Set some options for the SCL build
set(SC_PYTHON_GENERATOR OFF)
set(SC_ENABLE_TESTING OFF)
set(SC_ENABLE_COVERAGE OFF)
set(SC_IS_SUBBUILD ON)
set(SC_BUILD_TYPE "${CMAKE_BUILD_TYPE}")
set(INCLUDE_INSTALL_DIR ${INCLUDE_DIR})
set(BIN_INSTALL_DIR ${BIN_DIR})
set(LIB_INSTALL_DIR ${LIB_DIR})

set(sc_ALIASES ENABLE_SCL ENABLE_STEP ENABLE_STEP_CLASS_LIBRARIES)
set(sc_DESCRIPTION "
Option for enabling and disabling compilation of the NIST Step Class
Libraries provided with BRL-CAD's source code.  Default is AUTO,
responsive to the toplevel BRLCAD_BUNDLED_LIBS option and testing
first for a system version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
set(IS_SUBBUILD_STASH ${IS_SUBBUILD})
set(IS_SUBBUILD ON)
set(SC_BUILD_SCHEMAS "" CACHE STRING "Disable schema builds for BRL-CAD" FORCE)
# Lots of "libraries" associated with stepcode - use "stepcode" as the
# stand-in for the build target var.
THIRD_PARTY(stepcode SC stepcode sc_DESCRIPTION REQUIRED_VARS LEMON_EXECUTABLE
  PERPLEX_EXECUTABLE BRLCAD_LEVEL3 ALIASES ${sc_ALIASES} RESET_VARS
  EXP2CXX_EXEC EXP2CXX_EXECUTABLE_TARGET FLAGS NOSYS)
if(BRLCAD_SC_BUILD)
  set(EXP2CXX_EXEC exp2cxx CACHE STRING "Express to C++ executable" FORCE)
  set(EXP2CXX_EXECUTABLE_TARGET exp2cxx CACHE STRING "Express to C++ executable target" FORCE)
  mark_as_advanced(EXP2CXX_EXEC)
  mark_as_advanced(EXP2CXX_EXECUTABLE_TARGET)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/stepcode/include/sc_cf.h.in)
  DISTCLEAN(${CMAKE_CURRENT_BINARY_DIR}/stepcode/sc_version_string.h.txt)
endif(BRLCAD_SC_BUILD)
set(IS_SUBBUILD ${IS_SUBBUILD_STASH})
mark_as_advanced(SC_BUILD_TYPE)
mark_as_advanced(SC_BUILD_SCHEMAS)
mark_as_advanced(SC_GENERATE_LEXER_PARSER)
mark_as_advanced(SC_BUILD_SHARED_LIBS)
mark_as_advanced(SC_BUILD_STATIC_LIBS)
mark_as_advanced(SC_CPP_GENERATOR)
mark_as_advanced(SC_ENABLE_COVERAGE)
mark_as_advanced(SC_ENABLE_TESTING)
mark_as_advanced(SC_PYTHON_GENERATOR)
mark_as_advanced(SC_MEMMGR_ENABLE_CHECKS)
mark_as_advanced(SC_SDAI_ADDITIONAL_EXES_SRCS)
mark_as_advanced(SC_TRACE_FPRINTF)
SetTargetFolder(exp2cxx "Third Party Executables")
SetTargetFolder(print_attrs "Compilation Utilities")
SetTargetFolder(print_schemas "Compilation Utilities")
SetTargetFolder(exppp "Third Party Executables")
SetTargetFolder(libexppp "Third Party Libraries")
SetTargetFolder(check-express "Third Party Executables")
SetTargetFolder(express "Third Party Libraries")
SetTargetFolder(express_sync_generated_files "Third Party Executables")
SetTargetFolder(express_verify "Third Party Libraries")
SetTargetFolder(base "Third Party Libraries")
SetTargetFolder(stepcore "Third Party Libraries")
SetTargetFolder(stepdai "Third Party Libraries")
SetTargetFolder(stepeditor "Third Party Libraries")
SetTargetFolder(steputils "Third Party Libraries")
SetTargetFolder(version_string "Compilation Utilities")

# Clipper polygon clipping library - for now, we're going to use our copy
if(BRLCAD_LEVEL2)
  add_subdirectory(clipper)
  include(${CMAKE_CURRENT_SOURCE_DIR}/clipper.dist)
  CMAKEFILES_IN_DIR(clipper_ignore_files clipper)
  DISTCLEAN(${CMAKE_CURRENT_SOURCE_DIR}/clipper/Makefile)
  set(CLIPPER_LIBRARY "clipper" CACHE STRING "Clipper library" FORCE)
  set(CLIPPER_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/clipper" CACHE STRING "Directory containing clipper header" FORCE)
  mark_as_advanced(CLIPPER_LIBRARY)
  mark_as_advanced(CLIPPER_INCLUDE_DIR)
  SetTargetFolder(clipper "Third Party Libraries")
else(BRLCAD_LEVEL2)
  CMAKEFILES(clipper)
endif(BRLCAD_LEVEL2)

# dom2dox - Doc-O-Matic to Doxygen C++ source converter
include(${CMAKE_CURRENT_SOURCE_DIR}/dom2dox.dist)
CMAKEFILES_IN_DIR(dom2dox_ignore_files dom2dox)

# VDSlib - A View-Dependent Simplification and Rendering Library For
# the moment, this is marked NOSYS - it's possible that some Debian
# systems would have 0.9 of vdslib installed, but it's unmaintained
# and we're likely to be making changes.  If our own copy of VDSlib
# ever spins back off into its own project, revisit the NOSYS

set(libvds_ALIASES ENABLE_VDS)
set(libvds_DESCRIPTION "
Option for enabling and disabling compilation of the libvds triangle
simplification library provided with BRL-CAD's source code.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.
")
THIRD_PARTY(libvds VDS libvds libvds_DESCRIPTION ALIASES ${libvds_ALIASES} FLAGS NOSYS)
set(LIBVDS_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/libvds" CACHE STRING "Directory containing libvds headers." FORCE)
SetTargetFolder(libvds "Third Party Libraries")
SetTargetFolder(libvds-static "Third Party Libraries")
SetTargetFolder(stdvds "Third Party Libraries")
SetTargetFolder(stdvds-static "Third Party Libraries")


# OpenSceneGraph Libraries
set(openscenegraph_ALIASES ENABLE_OPENSCENEGRAPH)
set(openscenegraph_DESCRIPTION "
Option for enabling and disabling compilation of the OpenSceneGraph
libraries provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(openscenegraph OSG osg openscenegraph_DESCRIPTION
  ALIASES ${openscenegraph_ALIASES} FIND_NAME OpenSceneGraph FIND_COMPONENTS
  osgText osgViewer FLAGS NOSYS)
if(BRLCAD_OSG_BUILD)
  set(OSG_LIBRARY osg CACHE STRING "libosg" FORCE)
  set(OSGUTIL_LIBRARY osgUtil CACHE STRING "osgutil" FORCE)
  set(OSGDB_LIBRARY osgDB CACHE STRING "osgdb" FORCE)
  set(OSGGA_LIBRARY osgGA CACHE STRING "osgGA" FORCE)
  set(OSGTEXT_LIBRARY osgText CACHE STRING "osg Text library" FORCE)
  set(OSGVIEWER_LIBRARY osgViewer CACHE STRING "osg Viewer library" FORCE)
  set(OPENTHREADS_LIBRARY OpenThreads CACHE STRING "OpenThreads library" FORCE)
  set(OPENTHREADS_INCLUDE_DIR
    ${CMAKE_CURRENT_BINARY_DIR}/openscenegraph/src/OpenThreads/include
    ${BRLCAD_SOURCE_DIR}/src/other/openscenegraph/src/OpenThreads/include
    CACHE STRING "OpenThreads include dirs" FORCE
    )
  set(OSG_INCLUDE_DIR
    ${CMAKE_CURRENT_BINARY_DIR}/openscenegraph/include
    ${BRLCAD_SOURCE_DIR}/src/other/openscenegraph/include
    CACHE STRING "OpenSceneGraph include dirs" FORCE
    )
  set(OSG_INCLUDE_DIR "${OSG_INCLUDE_DIR}" CACHE STRING "Directory containing OpenSceneGraph headers." FORCE)
else(BRLCAD_OSG_BUILD)
  find_package(OpenThreads)
endif(BRLCAD_OSG_BUILD)


# GLFW Libraries
set(glfw_ALIASES ENABLE_OPENSCENEGRAPH)
set(glfw_DESCRIPTION "
Option for enabling and disabling compilation of the GLFW
libraries provided with BRL-CAD's source code.  Default is AUTO, responsive to
the toplevel BRLCAD_BUNDLED_LIBS option and testing first for a system
version if BRLCAD_BUNDLED_LIBS is also AUTO.
")
THIRD_PARTY(glfw GLFW glfw glfw_DESCRIPTION
  ALIASES ${glfw_ALIASES} FLAGS NOSYS)
if(BRLCAD_GLFW_BUILD)
  set(GLFW_LIBRARY glfw CACHE STRING "libglfw" FORCE)
  set(GLFW_INCLUDE_DIR
    ${BRLCAD_SOURCE_DIR}/src/other/glfw/include
    CACHE STRING "GLFW include dirs" FORCE
    )
  set(GLFW_INCLUDE_DIR "${GLFW_INCLUDE_DIR}" CACHE STRING "Directory containing GLFW headers." FORCE)
else(BRLCAD_GLFW_BUILD)
  find_package(OpenThreads)
endif(BRLCAD_GLFW_BUILD)

# gdiam

set(libgdiam_ALIASES ENABLE_GDIAM)
set(libgdiam_DESCRIPTION "
Option for enabling and disabling compilation of the libgdiam approximate
tight bounding box library provided with BRL-CAD's source code.  Default
is AUTO, responsive to the toplevel BRLCAD_BUNDLED_LIBS option and
testing first for a system version if BRLCAD_BUNDLED_LIBS is also
AUTO.
")
THIRD_PARTY(libgdiam GDIAM libgdiam libgdiam_DESCRIPTION ALIASES ${libgdiam_ALIASES}
  FLAGS NOSYS)
set(LIBGDIAM_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/libgdiam" CACHE STRING "Directory containing libgdiam headers." FORCE)
SetTargetFolder(libgdiam "Third Party Libraries")
SetTargetFolder(libgdiam-static "Third Party Libraries")

# Bullet is not yet integrated as a src/other subbuild, but there is
# code that will make use of it if it is available.  If that code
# becomes sufficiently useful, Bullet will be integrated.  In the
# meantime, locate the find logic for that package here.

# Bullet physics library
if(BRLCAD_LEVEL2)
  find_package(Bullet)
  if(BULLET_FOUND)
    CONFIG_H_APPEND(BRLCAD "#define HAVE_BULLET 1\n")
  endif(BULLET_FOUND)
  # Let the rest of the package know the results
  set(BULLET_LIBRARIES "${BULLET_LIBRARIES}" CACHE STRING "Bullet libs" FORCE) 
  set(BULLET_FOUND "${BULLET_FOUND}" CACHE BOOL "Bullet status" FORCE) 
  mark_as_advanced(BULLET_INCLUDE_DIR)
  mark_as_advanced(BULLET_FOUND)
  mark_as_advanced(BULLET_LIBRARIES)
endif(BRLCAD_LEVEL2)

# Adaptagrams is not yet integrated as a src/other subbuild, but there
# is code that will make use of it if it is available.  If that code
# becomes sufficiently useful, Adaptagrams will be integrated.  In the
# meantime, locate the find logic for that package here.

# Adaptagrams library
if(BRLCAD_LEVEL2)
  find_package(ADAPTAGRAMS)
  if(ADAPTAGRAMS_FOUND)
    CONFIG_H_APPEND(BRLCAD "#define HAVE_ADAPTAGRAMS 1\n")
  endif(ADAPTAGRAMS_FOUND)
  set(ADAPTAGRAMS_LIBRARIES "${ADAPTAGRAMS_LIBRARIES}" CACHE STRING "Adaptagrams libs" FORCE) 
  set(ADAPTAGRAMS_FOUND "${ADAPTAGRAMS_FOUND}" CACHE BOOL "Adaptagrams status" FORCE) 
  mark_as_advanced(ADAPTAGRAMS_FOUND)
  mark_as_advanced(ADAPTAGRAMS_LIBRARIES)
endif(BRLCAD_LEVEL2)

# Poly2Tri CDT library
add_subdirectory(poly2tri)
include(${CMAKE_CURRENT_SOURCE_DIR}/poly2tri.dist)
CMAKEFILES_IN_DIR(poly2tri_ignore_files poly2tri)
DISTCLEAN(${CMAKE_CURRENT_SOURCE_DIR}/poly2tri/Makefile)
set(P2T_LIBRARY "p2t" CACHE STRING "Poly2Tri library" FORCE)
set(P2T_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/poly2tri" CACHE STRING "Directory containing poly2tri header" FORCE)
SetTargetFolder(p2t "Third Party Libraries")
SetTargetFolder(p2t_static "Third Party Libraries")
mark_as_advanced(P2T_LIBRARY)
mark_as_advanced(P2T_INCLUDE_DIR)
mark_as_advanced(P2T_SHARED)
mark_as_advanced(P2T_STATIC)
mark_as_advanced(P2T_TESTS)

# The jama/tnt headers are installed by default - BRL-CAD requires the
# altered headers to build (I think?)
add_subdirectory(tnt)
set(TNT_INCLUDE_DIR "${BRLCAD_SOURCE_DIR}/src/other/tnt" CACHE STRING "Directory containing tnt headers" FORCE)
CMAKEFILES(tnt)
mark_as_advanced(TNT_INCLUDE_DIR)

# Eigen is used for advanced linear algebra functionality It consists
# entirely of headers and does not need to be installed.
#
# TODO - replace jama/tnt with Eigen
#
CMAKEFILES(Eigen)

# TCLAP is used for option parsing - consists entirely of headers
# and does not need to be installed, but does need to generate a
# config file
add_subdirectory(tclap)
CMAKEFILES(tclap)

if(BRLCAD_ENABLE_OSL)
  add_subdirectory(osl)
endif(BRLCAD_ENABLE_OSL)

CMAKEFILES(README)

# Local Variables:
# tab-width: 8
# mode: cmake
# indent-tabs-mode: t
# End:
# ex: shiftwidth=2 tabstop=8

